

#include "../types.h"

#ifndef PACK_H
#define PACK_H

typedef struct {
    EGLenum api;
} ARGS_eglBindAPI;
typedef struct {
    int index;
    ARGS_eglBindAPI args;
} PACKED_eglBindAPI;
typedef struct {
    EGLDisplay dpy;
    EGLSurface surface;
    EGLint buffer;
} ARGS_eglBindTexImage;
typedef struct {
    int index;
    ARGS_eglBindTexImage args;
} PACKED_eglBindTexImage;
typedef struct {
    EGLDisplay dpy;
    EGLint * attrib_list;
    EGLConfig * configs;
    EGLint config_size;
    EGLint * num_config;
} ARGS_eglChooseConfig;
typedef struct {
    int index;
    ARGS_eglChooseConfig args;
} PACKED_eglChooseConfig;
typedef struct {
    EGLDisplay dpy;
    EGLSyncKHR sync;
    EGLint flags;
    EGLTimeKHR timeout;
} ARGS_eglClientWaitSyncKHR;
typedef struct {
    int index;
    ARGS_eglClientWaitSyncKHR args;
} PACKED_eglClientWaitSyncKHR;
typedef struct {
    EGLSyncNV sync;
    EGLint flags;
    EGLTimeNV timeout;
} ARGS_eglClientWaitSyncNV;
typedef struct {
    int index;
    ARGS_eglClientWaitSyncNV args;
} PACKED_eglClientWaitSyncNV;
typedef struct {
    EGLDisplay dpy;
    EGLSurface surface;
    EGLNativePixmapType target;
} ARGS_eglCopyBuffers;
typedef struct {
    int index;
    ARGS_eglCopyBuffers args;
} PACKED_eglCopyBuffers;
typedef struct {
    EGLDisplay dpy;
    EGLConfig config;
    EGLContext share_context;
    EGLint * attrib_list;
} ARGS_eglCreateContext;
typedef struct {
    int index;
    ARGS_eglCreateContext args;
} PACKED_eglCreateContext;
typedef struct {
    EGLDisplay dpy;
    EGLint * attrib_list;
} ARGS_eglCreateDRMImageMESA;
typedef struct {
    int index;
    ARGS_eglCreateDRMImageMESA args;
} PACKED_eglCreateDRMImageMESA;
typedef struct {
    EGLDisplay dpy;
    EGLenum condition;
    EGLint * attrib_list;
} ARGS_eglCreateFenceSyncNV;
typedef struct {
    int index;
    ARGS_eglCreateFenceSyncNV args;
} PACKED_eglCreateFenceSyncNV;
typedef struct {
    EGLDisplay dpy;
    EGLContext ctx;
    EGLenum target;
    EGLClientBuffer buffer;
    EGLint * attrib_list;
} ARGS_eglCreateImageKHR;
typedef struct {
    int index;
    ARGS_eglCreateImageKHR args;
} PACKED_eglCreateImageKHR;
typedef struct {
    EGLDisplay dpy;
    EGLenum buftype;
    EGLClientBuffer buffer;
    EGLConfig config;
    EGLint * attrib_list;
} ARGS_eglCreatePbufferFromClientBuffer;
typedef struct {
    int index;
    ARGS_eglCreatePbufferFromClientBuffer args;
} PACKED_eglCreatePbufferFromClientBuffer;
typedef struct {
    EGLDisplay dpy;
    EGLConfig config;
    EGLint * attrib_list;
} ARGS_eglCreatePbufferSurface;
typedef struct {
    int index;
    ARGS_eglCreatePbufferSurface args;
} PACKED_eglCreatePbufferSurface;
typedef struct {
    EGLDisplay dpy;
    EGLConfig config;
    EGLNativePixmapType pixmap;
    EGLint * attrib_list;
} ARGS_eglCreatePixmapSurface;
typedef struct {
    int index;
    ARGS_eglCreatePixmapSurface args;
} PACKED_eglCreatePixmapSurface;
typedef struct {
    EGLDisplay dpy;
    EGLConfig config;
    struct EGLClientPixmapHI * pixmap;
} ARGS_eglCreatePixmapSurfaceHI;
typedef struct {
    int index;
    ARGS_eglCreatePixmapSurfaceHI args;
} PACKED_eglCreatePixmapSurfaceHI;
typedef struct {
    EGLDisplay dpy;
    EGLNativeFileDescriptorKHR file_descriptor;
} ARGS_eglCreateStreamFromFileDescriptorKHR;
typedef struct {
    int index;
    ARGS_eglCreateStreamFromFileDescriptorKHR args;
} PACKED_eglCreateStreamFromFileDescriptorKHR;
typedef struct {
    EGLDisplay dpy;
    EGLint * attrib_list;
} ARGS_eglCreateStreamKHR;
typedef struct {
    int index;
    ARGS_eglCreateStreamKHR args;
} PACKED_eglCreateStreamKHR;
typedef struct {
    EGLDisplay dpy;
    EGLConfig config;
    EGLStreamKHR stream;
    EGLint * attrib_list;
} ARGS_eglCreateStreamProducerSurfaceKHR;
typedef struct {
    int index;
    ARGS_eglCreateStreamProducerSurfaceKHR args;
} PACKED_eglCreateStreamProducerSurfaceKHR;
typedef struct {
    EGLDisplay dpy;
    EGLenum type;
    EGLint * attrib_list;
} ARGS_eglCreateSyncKHR;
typedef struct {
    int index;
    ARGS_eglCreateSyncKHR args;
} PACKED_eglCreateSyncKHR;
typedef struct {
    EGLDisplay dpy;
    EGLConfig config;
    EGLNativeWindowType win;
    EGLint * attrib_list;
} ARGS_eglCreateWindowSurface;
typedef struct {
    int index;
    ARGS_eglCreateWindowSurface args;
} PACKED_eglCreateWindowSurface;
typedef struct {
    EGLDisplay dpy;
    EGLContext ctx;
} ARGS_eglDestroyContext;
typedef struct {
    int index;
    ARGS_eglDestroyContext args;
} PACKED_eglDestroyContext;
typedef struct {
    EGLDisplay dpy;
    EGLImageKHR image;
} ARGS_eglDestroyImageKHR;
typedef struct {
    int index;
    ARGS_eglDestroyImageKHR args;
} PACKED_eglDestroyImageKHR;
typedef struct {
    EGLDisplay dpy;
    EGLStreamKHR stream;
} ARGS_eglDestroyStreamKHR;
typedef struct {
    int index;
    ARGS_eglDestroyStreamKHR args;
} PACKED_eglDestroyStreamKHR;
typedef struct {
    EGLDisplay dpy;
    EGLSurface surface;
} ARGS_eglDestroySurface;
typedef struct {
    int index;
    ARGS_eglDestroySurface args;
} PACKED_eglDestroySurface;
typedef struct {
    EGLDisplay dpy;
    EGLSyncKHR sync;
} ARGS_eglDestroySyncKHR;
typedef struct {
    int index;
    ARGS_eglDestroySyncKHR args;
} PACKED_eglDestroySyncKHR;
typedef struct {
    EGLSyncNV sync;
} ARGS_eglDestroySyncNV;
typedef struct {
    int index;
    ARGS_eglDestroySyncNV args;
} PACKED_eglDestroySyncNV;
typedef struct {
    EGLDisplay dpy;
    EGLSyncKHR sync;
} ARGS_eglDupNativeFenceFDANDROID;
typedef struct {
    int index;
    ARGS_eglDupNativeFenceFDANDROID args;
} PACKED_eglDupNativeFenceFDANDROID;
typedef struct {
    EGLDisplay dpy;
    EGLImageKHR image;
    EGLint * name;
    EGLint * handle;
    EGLint * stride;
} ARGS_eglExportDRMImageMESA;
typedef struct {
    int index;
    ARGS_eglExportDRMImageMESA args;
} PACKED_eglExportDRMImageMESA;
typedef struct {
    EGLSyncNV sync;
} ARGS_eglFenceNV;
typedef struct {
    int index;
    ARGS_eglFenceNV args;
} PACKED_eglFenceNV;
typedef struct {
    EGLDisplay dpy;
    EGLConfig config;
    EGLint attribute;
    EGLint * value;
} ARGS_eglGetConfigAttrib;
typedef struct {
    int index;
    ARGS_eglGetConfigAttrib args;
} PACKED_eglGetConfigAttrib;
typedef struct {
    EGLDisplay dpy;
    EGLConfig * configs;
    EGLint config_size;
    EGLint * num_config;
} ARGS_eglGetConfigs;
typedef struct {
    int index;
    ARGS_eglGetConfigs args;
} PACKED_eglGetConfigs;
typedef struct {
    int index;
} PACKED_eglGetCurrentContext;
typedef struct {
    int index;
} PACKED_eglGetCurrentDisplay;
typedef struct {
    EGLint readdraw;
} ARGS_eglGetCurrentSurface;
typedef struct {
    int index;
    ARGS_eglGetCurrentSurface args;
} PACKED_eglGetCurrentSurface;
typedef struct {
    EGLNativeDisplayType display_id;
} ARGS_eglGetDisplay;
typedef struct {
    int index;
    ARGS_eglGetDisplay args;
} PACKED_eglGetDisplay;
typedef struct {
    int index;
} PACKED_eglGetError;
typedef struct {
    char * procname;
} ARGS_eglGetProcAddress;
typedef struct {
    int index;
    ARGS_eglGetProcAddress args;
} PACKED_eglGetProcAddress;
typedef struct {
    EGLDisplay dpy;
    EGLStreamKHR stream;
} ARGS_eglGetStreamFileDescriptorKHR;
typedef struct {
    int index;
    ARGS_eglGetStreamFileDescriptorKHR args;
} PACKED_eglGetStreamFileDescriptorKHR;
typedef struct {
    EGLDisplay dpy;
    EGLSyncKHR sync;
    EGLint attribute;
    EGLint * value;
} ARGS_eglGetSyncAttribKHR;
typedef struct {
    int index;
    ARGS_eglGetSyncAttribKHR args;
} PACKED_eglGetSyncAttribKHR;
typedef struct {
    EGLSyncNV sync;
    EGLint attribute;
    EGLint * value;
} ARGS_eglGetSyncAttribNV;
typedef struct {
    int index;
    ARGS_eglGetSyncAttribNV args;
} PACKED_eglGetSyncAttribNV;
typedef struct {
    int index;
} PACKED_eglGetSystemTimeFrequencyNV;
typedef struct {
    int index;
} PACKED_eglGetSystemTimeNV;
typedef struct {
    EGLDisplay dpy;
    EGLint * major;
    EGLint * minor;
} ARGS_eglInitialize;
typedef struct {
    int index;
    ARGS_eglInitialize args;
} PACKED_eglInitialize;
typedef struct {
    EGLDisplay display;
    EGLSurface surface;
    EGLint * attrib_list;
} ARGS_eglLockSurfaceKHR;
typedef struct {
    int index;
    ARGS_eglLockSurfaceKHR args;
} PACKED_eglLockSurfaceKHR;
typedef struct {
    EGLDisplay dpy;
    EGLSurface draw;
    EGLSurface read;
    EGLContext ctx;
} ARGS_eglMakeCurrent;
typedef struct {
    int index;
    ARGS_eglMakeCurrent args;
} PACKED_eglMakeCurrent;
typedef struct {
    EGLDisplay dpy;
    EGLSurface surface;
    EGLint x;
    EGLint y;
    EGLint width;
    EGLint height;
} ARGS_eglPostSubBufferNV;
typedef struct {
    int index;
    ARGS_eglPostSubBufferNV args;
} PACKED_eglPostSubBufferNV;
typedef struct {
    int index;
} PACKED_eglQueryAPI;
typedef struct {
    EGLDisplay dpy;
    EGLContext ctx;
    EGLint attribute;
    EGLint * value;
} ARGS_eglQueryContext;
typedef struct {
    int index;
    ARGS_eglQueryContext args;
} PACKED_eglQueryContext;
typedef struct {
    EGLDisplay dpy;
    EGLNativeDisplayType * display_id;
} ARGS_eglQueryNativeDisplayNV;
typedef struct {
    int index;
    ARGS_eglQueryNativeDisplayNV args;
} PACKED_eglQueryNativeDisplayNV;
typedef struct {
    EGLDisplay dpy;
    EGLSurface surf;
    EGLNativePixmapType * pixmap;
} ARGS_eglQueryNativePixmapNV;
typedef struct {
    int index;
    ARGS_eglQueryNativePixmapNV args;
} PACKED_eglQueryNativePixmapNV;
typedef struct {
    EGLDisplay dpy;
    EGLSurface surf;
    EGLNativeWindowType * window;
} ARGS_eglQueryNativeWindowNV;
typedef struct {
    int index;
    ARGS_eglQueryNativeWindowNV args;
} PACKED_eglQueryNativeWindowNV;
typedef struct {
    EGLDisplay dpy;
    EGLStreamKHR stream;
    EGLenum attribute;
    EGLint * value;
} ARGS_eglQueryStreamKHR;
typedef struct {
    int index;
    ARGS_eglQueryStreamKHR args;
} PACKED_eglQueryStreamKHR;
typedef struct {
    EGLDisplay dpy;
    EGLStreamKHR stream;
    EGLenum attribute;
    EGLTimeKHR * value;
} ARGS_eglQueryStreamTimeKHR;
typedef struct {
    int index;
    ARGS_eglQueryStreamTimeKHR args;
} PACKED_eglQueryStreamTimeKHR;
typedef struct {
    EGLDisplay dpy;
    EGLStreamKHR stream;
    EGLenum attribute;
    EGLuint64KHR * value;
} ARGS_eglQueryStreamu64KHR;
typedef struct {
    int index;
    ARGS_eglQueryStreamu64KHR args;
} PACKED_eglQueryStreamu64KHR;
typedef struct {
    EGLDisplay dpy;
    EGLint name;
} ARGS_eglQueryString;
typedef struct {
    int index;
    ARGS_eglQueryString args;
} PACKED_eglQueryString;
typedef struct {
    EGLDisplay dpy;
    EGLSurface surface;
    EGLint attribute;
    EGLint * value;
} ARGS_eglQuerySurface;
typedef struct {
    int index;
    ARGS_eglQuerySurface args;
} PACKED_eglQuerySurface;
typedef struct {
    EGLDisplay dpy;
    EGLSurface surface;
    EGLint attribute;
    void ** value;
} ARGS_eglQuerySurfacePointerANGLE;
typedef struct {
    int index;
    ARGS_eglQuerySurfacePointerANGLE args;
} PACKED_eglQuerySurfacePointerANGLE;
typedef struct {
    EGLDisplay dpy;
    EGLSurface surface;
    EGLint buffer;
} ARGS_eglReleaseTexImage;
typedef struct {
    int index;
    ARGS_eglReleaseTexImage args;
} PACKED_eglReleaseTexImage;
typedef struct {
    int index;
} PACKED_eglReleaseThread;
typedef struct {
    EGLDisplay dpy;
    EGLSyncKHR sync;
    EGLenum mode;
} ARGS_eglSignalSyncKHR;
typedef struct {
    int index;
    ARGS_eglSignalSyncKHR args;
} PACKED_eglSignalSyncKHR;
typedef struct {
    EGLSyncNV sync;
    EGLenum mode;
} ARGS_eglSignalSyncNV;
typedef struct {
    int index;
    ARGS_eglSignalSyncNV args;
} PACKED_eglSignalSyncNV;
typedef struct {
    EGLDisplay dpy;
    EGLStreamKHR stream;
    EGLenum attribute;
    EGLint value;
} ARGS_eglStreamAttribKHR;
typedef struct {
    int index;
    ARGS_eglStreamAttribKHR args;
} PACKED_eglStreamAttribKHR;
typedef struct {
    EGLDisplay dpy;
    EGLStreamKHR stream;
} ARGS_eglStreamConsumerAcquireKHR;
typedef struct {
    int index;
    ARGS_eglStreamConsumerAcquireKHR args;
} PACKED_eglStreamConsumerAcquireKHR;
typedef struct {
    EGLDisplay dpy;
    EGLStreamKHR stream;
} ARGS_eglStreamConsumerGLTextureExternalKHR;
typedef struct {
    int index;
    ARGS_eglStreamConsumerGLTextureExternalKHR args;
} PACKED_eglStreamConsumerGLTextureExternalKHR;
typedef struct {
    EGLDisplay dpy;
    EGLStreamKHR stream;
} ARGS_eglStreamConsumerReleaseKHR;
typedef struct {
    int index;
    ARGS_eglStreamConsumerReleaseKHR args;
} PACKED_eglStreamConsumerReleaseKHR;
typedef struct {
    EGLDisplay dpy;
    EGLSurface surface;
    EGLint attribute;
    EGLint value;
} ARGS_eglSurfaceAttrib;
typedef struct {
    int index;
    ARGS_eglSurfaceAttrib args;
} PACKED_eglSurfaceAttrib;
typedef struct {
    EGLDisplay dpy;
    EGLSurface surface;
} ARGS_eglSwapBuffers;
typedef struct {
    int index;
    ARGS_eglSwapBuffers args;
} PACKED_eglSwapBuffers;
typedef struct {
    EGLDisplay dpy;
    EGLSurface surface;
    EGLint * rects;
    EGLint n_rects;
} ARGS_eglSwapBuffersWithDamageEXT;
typedef struct {
    int index;
    ARGS_eglSwapBuffersWithDamageEXT args;
} PACKED_eglSwapBuffersWithDamageEXT;
typedef struct {
    EGLDisplay dpy;
    EGLint interval;
} ARGS_eglSwapInterval;
typedef struct {
    int index;
    ARGS_eglSwapInterval args;
} PACKED_eglSwapInterval;
typedef struct {
    EGLDisplay dpy;
} ARGS_eglTerminate;
typedef struct {
    int index;
    ARGS_eglTerminate args;
} PACKED_eglTerminate;
typedef struct {
    EGLDisplay display;
    EGLSurface surface;
} ARGS_eglUnlockSurfaceKHR;
typedef struct {
    int index;
    ARGS_eglUnlockSurfaceKHR args;
} PACKED_eglUnlockSurfaceKHR;
typedef struct {
    int index;
} PACKED_eglWaitClient;
typedef struct {
    int index;
} PACKED_eglWaitGL;
typedef struct {
    EGLint engine;
} ARGS_eglWaitNative;
typedef struct {
    int index;
    ARGS_eglWaitNative args;
} PACKED_eglWaitNative;
typedef struct {
    EGLDisplay dpy;
    EGLSyncKHR sync;
    EGLint flags;
} ARGS_eglWaitSyncKHR;
typedef struct {
    int index;
    ARGS_eglWaitSyncKHR args;
} PACKED_eglWaitSyncKHR;
typedef struct {
    GLenum op;
    GLfloat value;
} ARGS_glAccum;
typedef struct {
    int index;
    ARGS_glAccum args;
} PACKED_glAccum;
typedef struct {
    GLenum op;
    GLfixed value;
} ARGS_glAccumxOES;
typedef struct {
    int index;
    ARGS_glAccumxOES args;
} PACKED_glAccumxOES;
typedef struct {
    GLuint program;
} ARGS_glActiveProgramEXT;
typedef struct {
    int index;
    ARGS_glActiveProgramEXT args;
} PACKED_glActiveProgramEXT;
typedef struct {
    GLuint pipeline;
    GLuint program;
} ARGS_glActiveShaderProgram;
typedef struct {
    int index;
    ARGS_glActiveShaderProgram args;
} PACKED_glActiveShaderProgram;
typedef struct {
    GLenum face;
} ARGS_glActiveStencilFaceEXT;
typedef struct {
    int index;
    ARGS_glActiveStencilFaceEXT args;
} PACKED_glActiveStencilFaceEXT;
typedef struct {
    GLenum texture;
} ARGS_glActiveTexture;
typedef struct {
    int index;
    ARGS_glActiveTexture args;
} PACKED_glActiveTexture;
typedef struct {
    GLenum texture;
} ARGS_glActiveTextureARB;
typedef struct {
    int index;
    ARGS_glActiveTextureARB args;
} PACKED_glActiveTextureARB;
typedef struct {
    GLuint program;
    GLchar * name;
} ARGS_glActiveVaryingNV;
typedef struct {
    int index;
    ARGS_glActiveVaryingNV args;
} PACKED_glActiveVaryingNV;
typedef struct {
    GLenum op;
    GLuint dst;
    GLuint dstMod;
    GLuint arg1;
    GLuint arg1Rep;
    GLuint arg1Mod;
} ARGS_glAlphaFragmentOp1ATI;
typedef struct {
    int index;
    ARGS_glAlphaFragmentOp1ATI args;
} PACKED_glAlphaFragmentOp1ATI;
typedef struct {
    GLenum op;
    GLuint dst;
    GLuint dstMod;
    GLuint arg1;
    GLuint arg1Rep;
    GLuint arg1Mod;
    GLuint arg2;
    GLuint arg2Rep;
    GLuint arg2Mod;
} ARGS_glAlphaFragmentOp2ATI;
typedef struct {
    int index;
    ARGS_glAlphaFragmentOp2ATI args;
} PACKED_glAlphaFragmentOp2ATI;
typedef struct {
    GLenum op;
    GLuint dst;
    GLuint dstMod;
    GLuint arg1;
    GLuint arg1Rep;
    GLuint arg1Mod;
    GLuint arg2;
    GLuint arg2Rep;
    GLuint arg2Mod;
    GLuint arg3;
    GLuint arg3Rep;
    GLuint arg3Mod;
} ARGS_glAlphaFragmentOp3ATI;
typedef struct {
    int index;
    ARGS_glAlphaFragmentOp3ATI args;
} PACKED_glAlphaFragmentOp3ATI;
typedef struct {
    GLenum func;
    GLclampf ref;
} ARGS_glAlphaFunc;
typedef struct {
    int index;
    ARGS_glAlphaFunc args;
} PACKED_glAlphaFunc;
typedef struct {
    GLenum func;
    GLclampx ref;
} ARGS_glAlphaFuncx;
typedef struct {
    int index;
    ARGS_glAlphaFuncx args;
} PACKED_glAlphaFuncx;
typedef struct {
    GLenum func;
    GLfixed ref;
} ARGS_glAlphaFuncxOES;
typedef struct {
    int index;
    ARGS_glAlphaFuncxOES args;
} PACKED_glAlphaFuncxOES;
typedef struct {
    GLenum mode;
} ARGS_glApplyTextureEXT;
typedef struct {
    int index;
    ARGS_glApplyTextureEXT args;
} PACKED_glApplyTextureEXT;
typedef struct {
    GLsizei n;
    GLuint * programs;
    GLboolean * residences;
} ARGS_glAreProgramsResidentNV;
typedef struct {
    int index;
    ARGS_glAreProgramsResidentNV args;
} PACKED_glAreProgramsResidentNV;
typedef struct {
    GLsizei n;
    GLuint * textures;
    GLboolean * residences;
} ARGS_glAreTexturesResident;
typedef struct {
    int index;
    ARGS_glAreTexturesResident args;
} PACKED_glAreTexturesResident;
typedef struct {
    GLsizei n;
    GLuint * textures;
    GLboolean * residences;
} ARGS_glAreTexturesResidentEXT;
typedef struct {
    int index;
    ARGS_glAreTexturesResidentEXT args;
} PACKED_glAreTexturesResidentEXT;
typedef struct {
    GLint i;
} ARGS_glArrayElement;
typedef struct {
    int index;
    ARGS_glArrayElement args;
} PACKED_glArrayElement;
typedef struct {
    GLint i;
} ARGS_glArrayElementEXT;
typedef struct {
    int index;
    ARGS_glArrayElementEXT args;
} PACKED_glArrayElementEXT;
typedef struct {
    GLenum array;
    GLint size;
    GLenum type;
    GLsizei stride;
    GLuint buffer;
    GLuint offset;
} ARGS_glArrayObjectATI;
typedef struct {
    int index;
    ARGS_glArrayObjectATI args;
} PACKED_glArrayObjectATI;
typedef struct {
    GLuint marker;
} ARGS_glAsyncMarkerSGIX;
typedef struct {
    int index;
    ARGS_glAsyncMarkerSGIX args;
} PACKED_glAsyncMarkerSGIX;
typedef struct {
    GLhandleARB containerObj;
    GLhandleARB obj;
} ARGS_glAttachObjectARB;
typedef struct {
    int index;
    ARGS_glAttachObjectARB args;
} PACKED_glAttachObjectARB;
typedef struct {
    GLuint program;
    GLuint shader;
} ARGS_glAttachShader;
typedef struct {
    int index;
    ARGS_glAttachShader args;
} PACKED_glAttachShader;
typedef struct {
    GLenum mode;
} ARGS_glBegin;
typedef struct {
    int index;
    ARGS_glBegin args;
} PACKED_glBegin;
typedef struct {
    GLuint id;
    GLenum mode;
} ARGS_glBeginConditionalRender;
typedef struct {
    int index;
    ARGS_glBeginConditionalRender args;
} PACKED_glBeginConditionalRender;
typedef struct {
    GLuint id;
    GLenum mode;
} ARGS_glBeginConditionalRenderNV;
typedef struct {
    int index;
    ARGS_glBeginConditionalRenderNV args;
} PACKED_glBeginConditionalRenderNV;
typedef struct {
    GLuint id;
} ARGS_glBeginConditionalRenderNVX;
typedef struct {
    int index;
    ARGS_glBeginConditionalRenderNVX args;
} PACKED_glBeginConditionalRenderNVX;
typedef struct {
    int index;
} PACKED_glBeginFragmentShaderATI;
typedef struct {
    GLuint id;
} ARGS_glBeginOcclusionQueryNV;
typedef struct {
    int index;
    ARGS_glBeginOcclusionQueryNV args;
} PACKED_glBeginOcclusionQueryNV;
typedef struct {
    GLuint monitor;
} ARGS_glBeginPerfMonitorAMD;
typedef struct {
    int index;
    ARGS_glBeginPerfMonitorAMD args;
} PACKED_glBeginPerfMonitorAMD;
typedef struct {
    GLenum target;
    GLuint id;
} ARGS_glBeginQuery;
typedef struct {
    int index;
    ARGS_glBeginQuery args;
} PACKED_glBeginQuery;
typedef struct {
    GLenum target;
    GLuint id;
} ARGS_glBeginQueryARB;
typedef struct {
    int index;
    ARGS_glBeginQueryARB args;
} PACKED_glBeginQueryARB;
typedef struct {
    GLenum target;
    GLuint index;
    GLuint id;
} ARGS_glBeginQueryIndexed;
typedef struct {
    int index;
    ARGS_glBeginQueryIndexed args;
} PACKED_glBeginQueryIndexed;
typedef struct {
    GLenum primitiveMode;
} ARGS_glBeginTransformFeedback;
typedef struct {
    int index;
    ARGS_glBeginTransformFeedback args;
} PACKED_glBeginTransformFeedback;
typedef struct {
    GLenum primitiveMode;
} ARGS_glBeginTransformFeedbackEXT;
typedef struct {
    int index;
    ARGS_glBeginTransformFeedbackEXT args;
} PACKED_glBeginTransformFeedbackEXT;
typedef struct {
    GLenum primitiveMode;
} ARGS_glBeginTransformFeedbackNV;
typedef struct {
    int index;
    ARGS_glBeginTransformFeedbackNV args;
} PACKED_glBeginTransformFeedbackNV;
typedef struct {
    int index;
} PACKED_glBeginVertexShaderEXT;
typedef struct {
    GLuint video_capture_slot;
} ARGS_glBeginVideoCaptureNV;
typedef struct {
    int index;
    ARGS_glBeginVideoCaptureNV args;
} PACKED_glBeginVideoCaptureNV;
typedef struct {
    GLuint program;
    GLuint index;
    GLchar * name;
} ARGS_glBindAttribLocation;
typedef struct {
    int index;
    ARGS_glBindAttribLocation args;
} PACKED_glBindAttribLocation;
typedef struct {
    GLhandleARB programObj;
    GLuint index;
    GLcharARB * name;
} ARGS_glBindAttribLocationARB;
typedef struct {
    int index;
    ARGS_glBindAttribLocationARB args;
} PACKED_glBindAttribLocationARB;
typedef struct {
    GLenum target;
    GLuint buffer;
} ARGS_glBindBuffer;
typedef struct {
    int index;
    ARGS_glBindBuffer args;
} PACKED_glBindBuffer;
typedef struct {
    GLenum target;
    GLuint buffer;
} ARGS_glBindBufferARB;
typedef struct {
    int index;
    ARGS_glBindBufferARB args;
} PACKED_glBindBufferARB;
typedef struct {
    GLenum target;
    GLuint index;
    GLuint buffer;
} ARGS_glBindBufferBase;
typedef struct {
    int index;
    ARGS_glBindBufferBase args;
} PACKED_glBindBufferBase;
typedef struct {
    GLenum target;
    GLuint index;
    GLuint buffer;
} ARGS_glBindBufferBaseEXT;
typedef struct {
    int index;
    ARGS_glBindBufferBaseEXT args;
} PACKED_glBindBufferBaseEXT;
typedef struct {
    GLenum target;
    GLuint index;
    GLuint buffer;
} ARGS_glBindBufferBaseNV;
typedef struct {
    int index;
    ARGS_glBindBufferBaseNV args;
} PACKED_glBindBufferBaseNV;
typedef struct {
    GLenum target;
    GLuint index;
    GLuint buffer;
    GLintptr offset;
} ARGS_glBindBufferOffsetEXT;
typedef struct {
    int index;
    ARGS_glBindBufferOffsetEXT args;
} PACKED_glBindBufferOffsetEXT;
typedef struct {
    GLenum target;
    GLuint index;
    GLuint buffer;
    GLintptr offset;
} ARGS_glBindBufferOffsetNV;
typedef struct {
    int index;
    ARGS_glBindBufferOffsetNV args;
} PACKED_glBindBufferOffsetNV;
typedef struct {
    GLenum target;
    GLuint index;
    GLuint buffer;
    GLintptr offset;
    GLsizeiptr size;
} ARGS_glBindBufferRange;
typedef struct {
    int index;
    ARGS_glBindBufferRange args;
} PACKED_glBindBufferRange;
typedef struct {
    GLenum target;
    GLuint index;
    GLuint buffer;
    GLintptr offset;
    GLsizeiptr size;
} ARGS_glBindBufferRangeEXT;
typedef struct {
    int index;
    ARGS_glBindBufferRangeEXT args;
} PACKED_glBindBufferRangeEXT;
typedef struct {
    GLenum target;
    GLuint index;
    GLuint buffer;
    GLintptr offset;
    GLsizeiptr size;
} ARGS_glBindBufferRangeNV;
typedef struct {
    int index;
    ARGS_glBindBufferRangeNV args;
} PACKED_glBindBufferRangeNV;
typedef struct {
    GLuint program;
    GLuint color;
    GLchar * name;
} ARGS_glBindFragDataLocation;
typedef struct {
    int index;
    ARGS_glBindFragDataLocation args;
} PACKED_glBindFragDataLocation;
typedef struct {
    GLuint program;
    GLuint color;
    GLchar * name;
} ARGS_glBindFragDataLocationEXT;
typedef struct {
    int index;
    ARGS_glBindFragDataLocationEXT args;
} PACKED_glBindFragDataLocationEXT;
typedef struct {
    GLuint program;
    GLuint colorNumber;
    GLuint index;
    GLchar * name;
} ARGS_glBindFragDataLocationIndexed;
typedef struct {
    int index;
    ARGS_glBindFragDataLocationIndexed args;
} PACKED_glBindFragDataLocationIndexed;
typedef struct {
    GLuint id;
} ARGS_glBindFragmentShaderATI;
typedef struct {
    int index;
    ARGS_glBindFragmentShaderATI args;
} PACKED_glBindFragmentShaderATI;
typedef struct {
    GLenum target;
    GLuint framebuffer;
} ARGS_glBindFramebuffer;
typedef struct {
    int index;
    ARGS_glBindFramebuffer args;
} PACKED_glBindFramebuffer;
typedef struct {
    GLenum target;
    GLuint framebuffer;
} ARGS_glBindFramebufferEXT;
typedef struct {
    int index;
    ARGS_glBindFramebufferEXT args;
} PACKED_glBindFramebufferEXT;
typedef struct {
    GLuint unit;
    GLuint texture;
    GLint level;
    GLboolean layered;
    GLint layer;
    GLenum access;
    GLenum format;
} ARGS_glBindImageTexture;
typedef struct {
    int index;
    ARGS_glBindImageTexture args;
} PACKED_glBindImageTexture;
typedef struct {
    GLuint index;
    GLuint texture;
    GLint level;
    GLboolean layered;
    GLint layer;
    GLenum access;
    GLint format;
} ARGS_glBindImageTextureEXT;
typedef struct {
    int index;
    ARGS_glBindImageTextureEXT args;
} PACKED_glBindImageTextureEXT;
typedef struct {
    GLenum light;
    GLenum value;
} ARGS_glBindLightParameterEXT;
typedef struct {
    int index;
    ARGS_glBindLightParameterEXT args;
} PACKED_glBindLightParameterEXT;
typedef struct {
    GLenum face;
    GLenum value;
} ARGS_glBindMaterialParameterEXT;
typedef struct {
    int index;
    ARGS_glBindMaterialParameterEXT args;
} PACKED_glBindMaterialParameterEXT;
typedef struct {
    GLenum texunit;
    GLenum target;
    GLuint texture;
} ARGS_glBindMultiTextureEXT;
typedef struct {
    int index;
    ARGS_glBindMultiTextureEXT args;
} PACKED_glBindMultiTextureEXT;
typedef struct {
    GLenum value;
} ARGS_glBindParameterEXT;
typedef struct {
    int index;
    ARGS_glBindParameterEXT args;
} PACKED_glBindParameterEXT;
typedef struct {
    GLenum target;
    GLuint program;
} ARGS_glBindProgramARB;
typedef struct {
    int index;
    ARGS_glBindProgramARB args;
} PACKED_glBindProgramARB;
typedef struct {
    GLenum target;
    GLuint id;
} ARGS_glBindProgramNV;
typedef struct {
    int index;
    ARGS_glBindProgramNV args;
} PACKED_glBindProgramNV;
typedef struct {
    GLuint pipeline;
} ARGS_glBindProgramPipeline;
typedef struct {
    int index;
    ARGS_glBindProgramPipeline args;
} PACKED_glBindProgramPipeline;
typedef struct {
    GLenum target;
    GLuint renderbuffer;
} ARGS_glBindRenderbuffer;
typedef struct {
    int index;
    ARGS_glBindRenderbuffer args;
} PACKED_glBindRenderbuffer;
typedef struct {
    GLenum target;
    GLuint renderbuffer;
} ARGS_glBindRenderbufferEXT;
typedef struct {
    int index;
    ARGS_glBindRenderbufferEXT args;
} PACKED_glBindRenderbufferEXT;
typedef struct {
    GLuint unit;
    GLuint sampler;
} ARGS_glBindSampler;
typedef struct {
    int index;
    ARGS_glBindSampler args;
} PACKED_glBindSampler;
typedef struct {
    GLenum unit;
    GLenum coord;
    GLenum value;
} ARGS_glBindTexGenParameterEXT;
typedef struct {
    int index;
    ARGS_glBindTexGenParameterEXT args;
} PACKED_glBindTexGenParameterEXT;
typedef struct {
    GLenum target;
    GLuint texture;
} ARGS_glBindTexture;
typedef struct {
    int index;
    ARGS_glBindTexture args;
} PACKED_glBindTexture;
typedef struct {
    GLenum target;
    GLuint texture;
} ARGS_glBindTextureEXT;
typedef struct {
    int index;
    ARGS_glBindTextureEXT args;
} PACKED_glBindTextureEXT;
typedef struct {
    GLenum unit;
    GLenum value;
} ARGS_glBindTextureUnitParameterEXT;
typedef struct {
    int index;
    ARGS_glBindTextureUnitParameterEXT args;
} PACKED_glBindTextureUnitParameterEXT;
typedef struct {
    GLenum target;
    GLuint id;
} ARGS_glBindTransformFeedback;
typedef struct {
    int index;
    ARGS_glBindTransformFeedback args;
} PACKED_glBindTransformFeedback;
typedef struct {
    GLenum target;
    GLuint id;
} ARGS_glBindTransformFeedbackNV;
typedef struct {
    int index;
    ARGS_glBindTransformFeedbackNV args;
} PACKED_glBindTransformFeedbackNV;
typedef struct {
    GLuint array;
} ARGS_glBindVertexArray;
typedef struct {
    int index;
    ARGS_glBindVertexArray args;
} PACKED_glBindVertexArray;
typedef struct {
    GLuint array;
} ARGS_glBindVertexArrayAPPLE;
typedef struct {
    int index;
    ARGS_glBindVertexArrayAPPLE args;
} PACKED_glBindVertexArrayAPPLE;
typedef struct {
    GLuint bindingindex;
    GLuint buffer;
    GLintptr offset;
    GLsizei stride;
} ARGS_glBindVertexBuffer;
typedef struct {
    int index;
    ARGS_glBindVertexBuffer args;
} PACKED_glBindVertexBuffer;
typedef struct {
    GLuint id;
} ARGS_glBindVertexShaderEXT;
typedef struct {
    int index;
    ARGS_glBindVertexShaderEXT args;
} PACKED_glBindVertexShaderEXT;
typedef struct {
    GLuint video_capture_slot;
    GLuint stream;
    GLenum frame_region;
    GLintptrARB offset;
} ARGS_glBindVideoCaptureStreamBufferNV;
typedef struct {
    int index;
    ARGS_glBindVideoCaptureStreamBufferNV args;
} PACKED_glBindVideoCaptureStreamBufferNV;
typedef struct {
    GLuint video_capture_slot;
    GLuint stream;
    GLenum frame_region;
    GLenum target;
    GLuint texture;
} ARGS_glBindVideoCaptureStreamTextureNV;
typedef struct {
    int index;
    ARGS_glBindVideoCaptureStreamTextureNV args;
} PACKED_glBindVideoCaptureStreamTextureNV;
typedef struct {
    GLbyte bx;
    GLbyte by;
    GLbyte bz;
} ARGS_glBinormal3bEXT;
typedef struct {
    int index;
    ARGS_glBinormal3bEXT args;
} PACKED_glBinormal3bEXT;
typedef struct {
    GLbyte * v;
} ARGS_glBinormal3bvEXT;
typedef struct {
    int index;
    ARGS_glBinormal3bvEXT args;
} PACKED_glBinormal3bvEXT;
typedef struct {
    GLdouble bx __attribute__ ((aligned(8)));
    GLdouble by __attribute__ ((aligned(8)));
    GLdouble bz __attribute__ ((aligned(8)));
} ARGS_glBinormal3dEXT;
typedef struct {
    int index;
    ARGS_glBinormal3dEXT args;
} PACKED_glBinormal3dEXT;
typedef struct {
    GLdouble * v;
} ARGS_glBinormal3dvEXT;
typedef struct {
    int index;
    ARGS_glBinormal3dvEXT args;
} PACKED_glBinormal3dvEXT;
typedef struct {
    GLfloat bx;
    GLfloat by;
    GLfloat bz;
} ARGS_glBinormal3fEXT;
typedef struct {
    int index;
    ARGS_glBinormal3fEXT args;
} PACKED_glBinormal3fEXT;
typedef struct {
    GLfloat * v;
} ARGS_glBinormal3fvEXT;
typedef struct {
    int index;
    ARGS_glBinormal3fvEXT args;
} PACKED_glBinormal3fvEXT;
typedef struct {
    GLint bx;
    GLint by;
    GLint bz;
} ARGS_glBinormal3iEXT;
typedef struct {
    int index;
    ARGS_glBinormal3iEXT args;
} PACKED_glBinormal3iEXT;
typedef struct {
    GLint * v;
} ARGS_glBinormal3ivEXT;
typedef struct {
    int index;
    ARGS_glBinormal3ivEXT args;
} PACKED_glBinormal3ivEXT;
typedef struct {
    GLshort bx;
    GLshort by;
    GLshort bz;
} ARGS_glBinormal3sEXT;
typedef struct {
    int index;
    ARGS_glBinormal3sEXT args;
} PACKED_glBinormal3sEXT;
typedef struct {
    GLshort * v;
} ARGS_glBinormal3svEXT;
typedef struct {
    int index;
    ARGS_glBinormal3svEXT args;
} PACKED_glBinormal3svEXT;
typedef struct {
    GLenum type;
    GLsizei stride;
    GLvoid * pointer;
} ARGS_glBinormalPointerEXT;
typedef struct {
    int index;
    ARGS_glBinormalPointerEXT args;
} PACKED_glBinormalPointerEXT;
typedef struct {
    GLsizei width;
    GLsizei height;
    GLfloat xorig;
    GLfloat yorig;
    GLfloat xmove;
    GLfloat ymove;
    GLubyte * bitmap;
} ARGS_glBitmap;
typedef struct {
    int index;
    ARGS_glBitmap args;
} PACKED_glBitmap;
typedef struct {
    GLsizei width;
    GLsizei height;
    GLfixed xorig;
    GLfixed yorig;
    GLfixed xmove;
    GLfixed ymove;
    GLubyte * bitmap;
} ARGS_glBitmapxOES;
typedef struct {
    int index;
    ARGS_glBitmapxOES args;
} PACKED_glBitmapxOES;
typedef struct {
    GLclampf red;
    GLclampf green;
    GLclampf blue;
    GLclampf alpha;
} ARGS_glBlendColor;
typedef struct {
    int index;
    ARGS_glBlendColor args;
} PACKED_glBlendColor;
typedef struct {
    GLfloat red;
    GLfloat green;
    GLfloat blue;
    GLfloat alpha;
} ARGS_glBlendColorEXT;
typedef struct {
    int index;
    ARGS_glBlendColorEXT args;
} PACKED_glBlendColorEXT;
typedef struct {
    GLclampf red;
    GLclampf green;
    GLclampf blue;
    GLclampf alpha;
} ARGS_glBlendColorOES;
typedef struct {
    int index;
    ARGS_glBlendColorOES args;
} PACKED_glBlendColorOES;
typedef struct {
    GLfixed red;
    GLfixed green;
    GLfixed blue;
    GLfixed alpha;
} ARGS_glBlendColorxOES;
typedef struct {
    int index;
    ARGS_glBlendColorxOES args;
} PACKED_glBlendColorxOES;
typedef struct {
    GLenum mode;
} ARGS_glBlendEquation;
typedef struct {
    int index;
    ARGS_glBlendEquation args;
} PACKED_glBlendEquation;
typedef struct {
    GLenum mode;
} ARGS_glBlendEquationEXT;
typedef struct {
    int index;
    ARGS_glBlendEquationEXT args;
} PACKED_glBlendEquationEXT;
typedef struct {
    GLuint buf;
    GLenum mode;
} ARGS_glBlendEquationIndexedAMD;
typedef struct {
    int index;
    ARGS_glBlendEquationIndexedAMD args;
} PACKED_glBlendEquationIndexedAMD;
typedef struct {
    GLenum mode;
} ARGS_glBlendEquationOES;
typedef struct {
    int index;
    ARGS_glBlendEquationOES args;
} PACKED_glBlendEquationOES;
typedef struct {
    GLenum modeRGB;
    GLenum modeAlpha;
} ARGS_glBlendEquationSeparate;
typedef struct {
    int index;
    ARGS_glBlendEquationSeparate args;
} PACKED_glBlendEquationSeparate;
typedef struct {
    GLenum modeRGB;
    GLenum modeAlpha;
} ARGS_glBlendEquationSeparateEXT;
typedef struct {
    int index;
    ARGS_glBlendEquationSeparateEXT args;
} PACKED_glBlendEquationSeparateEXT;
typedef struct {
    GLuint buf;
    GLenum modeRGB;
    GLenum modeAlpha;
} ARGS_glBlendEquationSeparateIndexedAMD;
typedef struct {
    int index;
    ARGS_glBlendEquationSeparateIndexedAMD args;
} PACKED_glBlendEquationSeparateIndexedAMD;
typedef struct {
    GLenum modeRGB;
    GLenum modeAlpha;
} ARGS_glBlendEquationSeparateOES;
typedef struct {
    int index;
    ARGS_glBlendEquationSeparateOES args;
} PACKED_glBlendEquationSeparateOES;
typedef struct {
    GLuint buf;
    GLenum modeRGB;
    GLenum modeAlpha;
} ARGS_glBlendEquationSeparatei;
typedef struct {
    int index;
    ARGS_glBlendEquationSeparatei args;
} PACKED_glBlendEquationSeparatei;
typedef struct {
    GLuint buf;
    GLenum modeRGB;
    GLenum modeAlpha;
} ARGS_glBlendEquationSeparateiARB;
typedef struct {
    int index;
    ARGS_glBlendEquationSeparateiARB args;
} PACKED_glBlendEquationSeparateiARB;
typedef struct {
    GLuint buf;
    GLenum mode;
} ARGS_glBlendEquationi;
typedef struct {
    int index;
    ARGS_glBlendEquationi args;
} PACKED_glBlendEquationi;
typedef struct {
    GLuint buf;
    GLenum mode;
} ARGS_glBlendEquationiARB;
typedef struct {
    int index;
    ARGS_glBlendEquationiARB args;
} PACKED_glBlendEquationiARB;
typedef struct {
    GLenum sfactor;
    GLenum dfactor;
} ARGS_glBlendFunc;
typedef struct {
    int index;
    ARGS_glBlendFunc args;
} PACKED_glBlendFunc;
typedef struct {
    GLuint buf;
    GLenum src;
    GLenum dst;
} ARGS_glBlendFuncIndexedAMD;
typedef struct {
    int index;
    ARGS_glBlendFuncIndexedAMD args;
} PACKED_glBlendFuncIndexedAMD;
typedef struct {
    GLenum sfactorRGB;
    GLenum dfactorRGB;
    GLenum sfactorAlpha;
    GLenum dfactorAlpha;
} ARGS_glBlendFuncSeparate;
typedef struct {
    int index;
    ARGS_glBlendFuncSeparate args;
} PACKED_glBlendFuncSeparate;
typedef struct {
    GLenum sfactorRGB;
    GLenum dfactorRGB;
    GLenum sfactorAlpha;
    GLenum dfactorAlpha;
} ARGS_glBlendFuncSeparateEXT;
typedef struct {
    int index;
    ARGS_glBlendFuncSeparateEXT args;
} PACKED_glBlendFuncSeparateEXT;
typedef struct {
    GLenum sfactorRGB;
    GLenum dfactorRGB;
    GLenum sfactorAlpha;
    GLenum dfactorAlpha;
} ARGS_glBlendFuncSeparateINGR;
typedef struct {
    int index;
    ARGS_glBlendFuncSeparateINGR args;
} PACKED_glBlendFuncSeparateINGR;
typedef struct {
    GLuint buf;
    GLenum srcRGB;
    GLenum dstRGB;
    GLenum srcAlpha;
    GLenum dstAlpha;
} ARGS_glBlendFuncSeparateIndexedAMD;
typedef struct {
    int index;
    ARGS_glBlendFuncSeparateIndexedAMD args;
} PACKED_glBlendFuncSeparateIndexedAMD;
typedef struct {
    GLenum sfactorRGB;
    GLenum dfactorRGB;
    GLenum sfactorAlpha;
    GLenum dfactorAlpha;
} ARGS_glBlendFuncSeparateOES;
typedef struct {
    int index;
    ARGS_glBlendFuncSeparateOES args;
} PACKED_glBlendFuncSeparateOES;
typedef struct {
    GLuint buf;
    GLenum srcRGB;
    GLenum dstRGB;
    GLenum srcAlpha;
    GLenum dstAlpha;
} ARGS_glBlendFuncSeparatei;
typedef struct {
    int index;
    ARGS_glBlendFuncSeparatei args;
} PACKED_glBlendFuncSeparatei;
typedef struct {
    GLuint buf;
    GLenum srcRGB;
    GLenum dstRGB;
    GLenum srcAlpha;
    GLenum dstAlpha;
} ARGS_glBlendFuncSeparateiARB;
typedef struct {
    int index;
    ARGS_glBlendFuncSeparateiARB args;
} PACKED_glBlendFuncSeparateiARB;
typedef struct {
    GLuint buf;
    GLenum src;
    GLenum dst;
} ARGS_glBlendFunci;
typedef struct {
    int index;
    ARGS_glBlendFunci args;
} PACKED_glBlendFunci;
typedef struct {
    GLuint buf;
    GLenum src;
    GLenum dst;
} ARGS_glBlendFunciARB;
typedef struct {
    int index;
    ARGS_glBlendFunciARB args;
} PACKED_glBlendFunciARB;
typedef struct {
    GLint srcX0;
    GLint srcY0;
    GLint srcX1;
    GLint srcY1;
    GLint dstX0;
    GLint dstY0;
    GLint dstX1;
    GLint dstY1;
    GLbitfield mask;
    GLenum filter;
} ARGS_glBlitFramebuffer;
typedef struct {
    int index;
    ARGS_glBlitFramebuffer args;
} PACKED_glBlitFramebuffer;
typedef struct {
    GLint srcX0;
    GLint srcY0;
    GLint srcX1;
    GLint srcY1;
    GLint dstX0;
    GLint dstY0;
    GLint dstX1;
    GLint dstY1;
    GLbitfield mask;
    GLenum filter;
} ARGS_glBlitFramebufferEXT;
typedef struct {
    int index;
    ARGS_glBlitFramebufferEXT args;
} PACKED_glBlitFramebufferEXT;
typedef struct {
    GLenum pname;
    GLuint index;
    GLuint64EXT address;
    GLsizeiptr length;
} ARGS_glBufferAddressRangeNV;
typedef struct {
    int index;
    ARGS_glBufferAddressRangeNV args;
} PACKED_glBufferAddressRangeNV;
typedef struct {
    GLenum target;
    GLsizeiptr size;
    GLvoid * data;
    GLenum usage;
} ARGS_glBufferData;
typedef struct {
    int index;
    ARGS_glBufferData args;
} PACKED_glBufferData;
typedef struct {
    GLenum target;
    GLsizeiptrARB size;
    GLvoid * data;
    GLenum usage;
} ARGS_glBufferDataARB;
typedef struct {
    int index;
    ARGS_glBufferDataARB args;
} PACKED_glBufferDataARB;
typedef struct {
    GLenum target;
    GLenum pname;
    GLint param;
} ARGS_glBufferParameteriAPPLE;
typedef struct {
    int index;
    ARGS_glBufferParameteriAPPLE args;
} PACKED_glBufferParameteriAPPLE;
typedef struct {
    GLenum target;
    GLintptr offset;
    GLsizeiptr size;
    GLvoid * data;
} ARGS_glBufferSubData;
typedef struct {
    int index;
    ARGS_glBufferSubData args;
} PACKED_glBufferSubData;
typedef struct {
    GLenum target;
    GLintptrARB offset;
    GLsizeiptrARB size;
    GLvoid * data;
} ARGS_glBufferSubDataARB;
typedef struct {
    int index;
    ARGS_glBufferSubDataARB args;
} PACKED_glBufferSubDataARB;
typedef struct {
    GLuint list;
} ARGS_glCallList;
typedef struct {
    int index;
    ARGS_glCallList args;
} PACKED_glCallList;
typedef struct {
    GLsizei n;
    GLenum type;
    GLvoid * lists;
} ARGS_glCallLists;
typedef struct {
    int index;
    ARGS_glCallLists args;
} PACKED_glCallLists;
typedef struct {
    GLenum target;
} ARGS_glCheckFramebufferStatus;
typedef struct {
    int index;
    ARGS_glCheckFramebufferStatus args;
} PACKED_glCheckFramebufferStatus;
typedef struct {
    GLenum target;
} ARGS_glCheckFramebufferStatusEXT;
typedef struct {
    int index;
    ARGS_glCheckFramebufferStatusEXT args;
} PACKED_glCheckFramebufferStatusEXT;
typedef struct {
    GLuint framebuffer;
    GLenum target;
} ARGS_glCheckNamedFramebufferStatusEXT;
typedef struct {
    int index;
    ARGS_glCheckNamedFramebufferStatusEXT args;
} PACKED_glCheckNamedFramebufferStatusEXT;
typedef struct {
    GLenum target;
    GLenum clamp;
} ARGS_glClampColor;
typedef struct {
    int index;
    ARGS_glClampColor args;
} PACKED_glClampColor;
typedef struct {
    GLenum target;
    GLenum clamp;
} ARGS_glClampColorARB;
typedef struct {
    int index;
    ARGS_glClampColorARB args;
} PACKED_glClampColorARB;
typedef struct {
    GLbitfield mask;
} ARGS_glClear;
typedef struct {
    int index;
    ARGS_glClear args;
} PACKED_glClear;
typedef struct {
    GLfloat red;
    GLfloat green;
    GLfloat blue;
    GLfloat alpha;
} ARGS_glClearAccum;
typedef struct {
    int index;
    ARGS_glClearAccum args;
} PACKED_glClearAccum;
typedef struct {
    GLfixed red;
    GLfixed green;
    GLfixed blue;
    GLfixed alpha;
} ARGS_glClearAccumxOES;
typedef struct {
    int index;
    ARGS_glClearAccumxOES args;
} PACKED_glClearAccumxOES;
typedef struct {
    GLenum target;
    GLenum internalformat;
    GLenum format;
    GLenum type;
    void * data;
} ARGS_glClearBufferData;
typedef struct {
    int index;
    ARGS_glClearBufferData args;
} PACKED_glClearBufferData;
typedef struct {
    GLenum target;
    GLenum internalformat;
    GLintptr offset;
    GLsizeiptr size;
    GLenum format;
    GLenum type;
    void * data;
} ARGS_glClearBufferSubData;
typedef struct {
    int index;
    ARGS_glClearBufferSubData args;
} PACKED_glClearBufferSubData;
typedef struct {
    GLenum buffer;
    GLint drawbuffer;
    GLfloat depth;
    GLint stencil;
} ARGS_glClearBufferfi;
typedef struct {
    int index;
    ARGS_glClearBufferfi args;
} PACKED_glClearBufferfi;
typedef struct {
    GLenum buffer;
    GLint drawbuffer;
    GLfloat * value;
} ARGS_glClearBufferfv;
typedef struct {
    int index;
    ARGS_glClearBufferfv args;
} PACKED_glClearBufferfv;
typedef struct {
    GLenum buffer;
    GLint drawbuffer;
    GLint * value;
} ARGS_glClearBufferiv;
typedef struct {
    int index;
    ARGS_glClearBufferiv args;
} PACKED_glClearBufferiv;
typedef struct {
    GLenum buffer;
    GLint drawbuffer;
    GLuint * value;
} ARGS_glClearBufferuiv;
typedef struct {
    int index;
    ARGS_glClearBufferuiv args;
} PACKED_glClearBufferuiv;
typedef struct {
    GLclampf red;
    GLclampf green;
    GLclampf blue;
    GLclampf alpha;
} ARGS_glClearColor;
typedef struct {
    int index;
    ARGS_glClearColor args;
} PACKED_glClearColor;
typedef struct {
    GLint red;
    GLint green;
    GLint blue;
    GLint alpha;
} ARGS_glClearColorIiEXT;
typedef struct {
    int index;
    ARGS_glClearColorIiEXT args;
} PACKED_glClearColorIiEXT;
typedef struct {
    GLuint red;
    GLuint green;
    GLuint blue;
    GLuint alpha;
} ARGS_glClearColorIuiEXT;
typedef struct {
    int index;
    ARGS_glClearColorIuiEXT args;
} PACKED_glClearColorIuiEXT;
typedef struct {
    GLclampx red;
    GLclampx green;
    GLclampx blue;
    GLclampx alpha;
} ARGS_glClearColorx;
typedef struct {
    int index;
    ARGS_glClearColorx args;
} PACKED_glClearColorx;
typedef struct {
    GLfixed red;
    GLfixed green;
    GLfixed blue;
    GLfixed alpha;
} ARGS_glClearColorxOES;
typedef struct {
    int index;
    ARGS_glClearColorxOES args;
} PACKED_glClearColorxOES;
typedef struct {
    GLdouble depth __attribute__ ((aligned(8)));
} ARGS_glClearDepth;
typedef struct {
    int index;
    ARGS_glClearDepth args;
} PACKED_glClearDepth;
typedef struct {
    GLdouble depth __attribute__ ((aligned(8)));
} ARGS_glClearDepthdNV;
typedef struct {
    int index;
    ARGS_glClearDepthdNV args;
} PACKED_glClearDepthdNV;
typedef struct {
    GLclampf depth;
} ARGS_glClearDepthf;
typedef struct {
    int index;
    ARGS_glClearDepthf args;
} PACKED_glClearDepthf;
typedef struct {
    GLclampf depth;
} ARGS_glClearDepthfOES;
typedef struct {
    int index;
    ARGS_glClearDepthfOES args;
} PACKED_glClearDepthfOES;
typedef struct {
    GLclampx depth;
} ARGS_glClearDepthx;
typedef struct {
    int index;
    ARGS_glClearDepthx args;
} PACKED_glClearDepthx;
typedef struct {
    GLfixed depth;
} ARGS_glClearDepthxOES;
typedef struct {
    int index;
    ARGS_glClearDepthxOES args;
} PACKED_glClearDepthxOES;
typedef struct {
    GLfloat c;
} ARGS_glClearIndex;
typedef struct {
    int index;
    ARGS_glClearIndex args;
} PACKED_glClearIndex;
typedef struct {
    GLuint buffer;
    GLenum internalformat;
    GLenum format;
    GLenum type;
    void * data;
} ARGS_glClearNamedBufferDataEXT;
typedef struct {
    int index;
    ARGS_glClearNamedBufferDataEXT args;
} PACKED_glClearNamedBufferDataEXT;
typedef struct {
    GLuint buffer;
    GLenum internalformat;
    GLenum format;
    GLenum type;
    GLsizeiptr offset;
    GLsizeiptr size;
    void * data;
} ARGS_glClearNamedBufferSubDataEXT;
typedef struct {
    int index;
    ARGS_glClearNamedBufferSubDataEXT args;
} PACKED_glClearNamedBufferSubDataEXT;
typedef struct {
    GLint s;
} ARGS_glClearStencil;
typedef struct {
    int index;
    ARGS_glClearStencil args;
} PACKED_glClearStencil;
typedef struct {
    GLenum texture;
} ARGS_glClientActiveTexture;
typedef struct {
    int index;
    ARGS_glClientActiveTexture args;
} PACKED_glClientActiveTexture;
typedef struct {
    GLenum texture;
} ARGS_glClientActiveTextureARB;
typedef struct {
    int index;
    ARGS_glClientActiveTextureARB args;
} PACKED_glClientActiveTextureARB;
typedef struct {
    GLenum stream;
} ARGS_glClientActiveVertexStreamATI;
typedef struct {
    int index;
    ARGS_glClientActiveVertexStreamATI args;
} PACKED_glClientActiveVertexStreamATI;
typedef struct {
    GLbitfield mask;
} ARGS_glClientAttribDefaultEXT;
typedef struct {
    int index;
    ARGS_glClientAttribDefaultEXT args;
} PACKED_glClientAttribDefaultEXT;
typedef struct {
    GLsync sync;
    GLbitfield flags;
    GLuint64 timeout;
} ARGS_glClientWaitSync;
typedef struct {
    int index;
    ARGS_glClientWaitSync args;
} PACKED_glClientWaitSync;
typedef struct {
    GLenum plane;
    GLdouble * equation;
} ARGS_glClipPlane;
typedef struct {
    int index;
    ARGS_glClipPlane args;
} PACKED_glClipPlane;
typedef struct {
    GLenum plane;
    GLfloat * equation;
} ARGS_glClipPlanef;
typedef struct {
    int index;
    ARGS_glClipPlanef args;
} PACKED_glClipPlanef;
typedef struct {
    GLenum plane;
    GLfloat * equation;
} ARGS_glClipPlanefOES;
typedef struct {
    int index;
    ARGS_glClipPlanefOES args;
} PACKED_glClipPlanefOES;
typedef struct {
    GLenum plane;
    GLfixed * equation;
} ARGS_glClipPlanex;
typedef struct {
    int index;
    ARGS_glClipPlanex args;
} PACKED_glClipPlanex;
typedef struct {
    GLenum plane;
    GLfixed * equation;
} ARGS_glClipPlanexOES;
typedef struct {
    int index;
    ARGS_glClipPlanexOES args;
} PACKED_glClipPlanexOES;
typedef struct {
    GLbyte red;
    GLbyte green;
    GLbyte blue;
} ARGS_glColor3b;
typedef struct {
    int index;
    ARGS_glColor3b args;
} PACKED_glColor3b;
typedef struct {
    GLbyte * v;
} ARGS_glColor3bv;
typedef struct {
    int index;
    ARGS_glColor3bv args;
} PACKED_glColor3bv;
typedef struct {
    GLdouble red __attribute__ ((aligned(8)));
    GLdouble green __attribute__ ((aligned(8)));
    GLdouble blue __attribute__ ((aligned(8)));
} ARGS_glColor3d;
typedef struct {
    int index;
    ARGS_glColor3d args;
} PACKED_glColor3d;
typedef struct {
    GLdouble * v;
} ARGS_glColor3dv;
typedef struct {
    int index;
    ARGS_glColor3dv args;
} PACKED_glColor3dv;
typedef struct {
    GLfloat red;
    GLfloat green;
    GLfloat blue;
} ARGS_glColor3f;
typedef struct {
    int index;
    ARGS_glColor3f args;
} PACKED_glColor3f;
typedef struct {
    GLfloat r;
    GLfloat g;
    GLfloat b;
    GLfloat x;
    GLfloat y;
    GLfloat z;
} ARGS_glColor3fVertex3fSUN;
typedef struct {
    int index;
    ARGS_glColor3fVertex3fSUN args;
} PACKED_glColor3fVertex3fSUN;
typedef struct {
    GLfloat * c;
    GLfloat * v;
} ARGS_glColor3fVertex3fvSUN;
typedef struct {
    int index;
    ARGS_glColor3fVertex3fvSUN args;
} PACKED_glColor3fVertex3fvSUN;
typedef struct {
    GLfloat * v;
} ARGS_glColor3fv;
typedef struct {
    int index;
    ARGS_glColor3fv args;
} PACKED_glColor3fv;
typedef struct {
    GLhalfNV red;
    GLhalfNV green;
    GLhalfNV blue;
} ARGS_glColor3hNV;
typedef struct {
    int index;
    ARGS_glColor3hNV args;
} PACKED_glColor3hNV;
typedef struct {
    GLhalfNV * v;
} ARGS_glColor3hvNV;
typedef struct {
    int index;
    ARGS_glColor3hvNV args;
} PACKED_glColor3hvNV;
typedef struct {
    GLint red;
    GLint green;
    GLint blue;
} ARGS_glColor3i;
typedef struct {
    int index;
    ARGS_glColor3i args;
} PACKED_glColor3i;
typedef struct {
    GLint * v;
} ARGS_glColor3iv;
typedef struct {
    int index;
    ARGS_glColor3iv args;
} PACKED_glColor3iv;
typedef struct {
    GLshort red;
    GLshort green;
    GLshort blue;
} ARGS_glColor3s;
typedef struct {
    int index;
    ARGS_glColor3s args;
} PACKED_glColor3s;
typedef struct {
    GLshort * v;
} ARGS_glColor3sv;
typedef struct {
    int index;
    ARGS_glColor3sv args;
} PACKED_glColor3sv;
typedef struct {
    GLubyte red;
    GLubyte green;
    GLubyte blue;
} ARGS_glColor3ub;
typedef struct {
    int index;
    ARGS_glColor3ub args;
} PACKED_glColor3ub;
typedef struct {
    GLubyte * v;
} ARGS_glColor3ubv;
typedef struct {
    int index;
    ARGS_glColor3ubv args;
} PACKED_glColor3ubv;
typedef struct {
    GLuint red;
    GLuint green;
    GLuint blue;
} ARGS_glColor3ui;
typedef struct {
    int index;
    ARGS_glColor3ui args;
} PACKED_glColor3ui;
typedef struct {
    GLuint * v;
} ARGS_glColor3uiv;
typedef struct {
    int index;
    ARGS_glColor3uiv args;
} PACKED_glColor3uiv;
typedef struct {
    GLushort red;
    GLushort green;
    GLushort blue;
} ARGS_glColor3us;
typedef struct {
    int index;
    ARGS_glColor3us args;
} PACKED_glColor3us;
typedef struct {
    GLushort * v;
} ARGS_glColor3usv;
typedef struct {
    int index;
    ARGS_glColor3usv args;
} PACKED_glColor3usv;
typedef struct {
    GLfixed red;
    GLfixed green;
    GLfixed blue;
} ARGS_glColor3xOES;
typedef struct {
    int index;
    ARGS_glColor3xOES args;
} PACKED_glColor3xOES;
typedef struct {
    GLfixed * components;
} ARGS_glColor3xvOES;
typedef struct {
    int index;
    ARGS_glColor3xvOES args;
} PACKED_glColor3xvOES;
typedef struct {
    GLbyte red;
    GLbyte green;
    GLbyte blue;
    GLbyte alpha;
} ARGS_glColor4b;
typedef struct {
    int index;
    ARGS_glColor4b args;
} PACKED_glColor4b;
typedef struct {
    GLbyte * v;
} ARGS_glColor4bv;
typedef struct {
    int index;
    ARGS_glColor4bv args;
} PACKED_glColor4bv;
typedef struct {
    GLdouble red __attribute__ ((aligned(8)));
    GLdouble green __attribute__ ((aligned(8)));
    GLdouble blue __attribute__ ((aligned(8)));
    GLdouble alpha __attribute__ ((aligned(8)));
} ARGS_glColor4d;
typedef struct {
    int index;
    ARGS_glColor4d args;
} PACKED_glColor4d;
typedef struct {
    GLdouble * v;
} ARGS_glColor4dv;
typedef struct {
    int index;
    ARGS_glColor4dv args;
} PACKED_glColor4dv;
typedef struct {
    GLfloat red;
    GLfloat green;
    GLfloat blue;
    GLfloat alpha;
} ARGS_glColor4f;
typedef struct {
    int index;
    ARGS_glColor4f args;
} PACKED_glColor4f;
typedef struct {
    GLfloat r;
    GLfloat g;
    GLfloat b;
    GLfloat a;
    GLfloat nx;
    GLfloat ny;
    GLfloat nz;
    GLfloat x;
    GLfloat y;
    GLfloat z;
} ARGS_glColor4fNormal3fVertex3fSUN;
typedef struct {
    int index;
    ARGS_glColor4fNormal3fVertex3fSUN args;
} PACKED_glColor4fNormal3fVertex3fSUN;
typedef struct {
    GLfloat * c;
    GLfloat * n;
    GLfloat * v;
} ARGS_glColor4fNormal3fVertex3fvSUN;
typedef struct {
    int index;
    ARGS_glColor4fNormal3fVertex3fvSUN args;
} PACKED_glColor4fNormal3fVertex3fvSUN;
typedef struct {
    GLfloat * v;
} ARGS_glColor4fv;
typedef struct {
    int index;
    ARGS_glColor4fv args;
} PACKED_glColor4fv;
typedef struct {
    GLhalfNV red;
    GLhalfNV green;
    GLhalfNV blue;
    GLhalfNV alpha;
} ARGS_glColor4hNV;
typedef struct {
    int index;
    ARGS_glColor4hNV args;
} PACKED_glColor4hNV;
typedef struct {
    GLhalfNV * v;
} ARGS_glColor4hvNV;
typedef struct {
    int index;
    ARGS_glColor4hvNV args;
} PACKED_glColor4hvNV;
typedef struct {
    GLint red;
    GLint green;
    GLint blue;
    GLint alpha;
} ARGS_glColor4i;
typedef struct {
    int index;
    ARGS_glColor4i args;
} PACKED_glColor4i;
typedef struct {
    GLint * v;
} ARGS_glColor4iv;
typedef struct {
    int index;
    ARGS_glColor4iv args;
} PACKED_glColor4iv;
typedef struct {
    GLshort red;
    GLshort green;
    GLshort blue;
    GLshort alpha;
} ARGS_glColor4s;
typedef struct {
    int index;
    ARGS_glColor4s args;
} PACKED_glColor4s;
typedef struct {
    GLshort * v;
} ARGS_glColor4sv;
typedef struct {
    int index;
    ARGS_glColor4sv args;
} PACKED_glColor4sv;
typedef struct {
    GLubyte red;
    GLubyte green;
    GLubyte blue;
    GLubyte alpha;
} ARGS_glColor4ub;
typedef struct {
    int index;
    ARGS_glColor4ub args;
} PACKED_glColor4ub;
typedef struct {
    GLubyte r;
    GLubyte g;
    GLubyte b;
    GLubyte a;
    GLfloat x;
    GLfloat y;
} ARGS_glColor4ubVertex2fSUN;
typedef struct {
    int index;
    ARGS_glColor4ubVertex2fSUN args;
} PACKED_glColor4ubVertex2fSUN;
typedef struct {
    GLubyte * c;
    GLfloat * v;
} ARGS_glColor4ubVertex2fvSUN;
typedef struct {
    int index;
    ARGS_glColor4ubVertex2fvSUN args;
} PACKED_glColor4ubVertex2fvSUN;
typedef struct {
    GLubyte r;
    GLubyte g;
    GLubyte b;
    GLubyte a;
    GLfloat x;
    GLfloat y;
    GLfloat z;
} ARGS_glColor4ubVertex3fSUN;
typedef struct {
    int index;
    ARGS_glColor4ubVertex3fSUN args;
} PACKED_glColor4ubVertex3fSUN;
typedef struct {
    GLubyte * c;
    GLfloat * v;
} ARGS_glColor4ubVertex3fvSUN;
typedef struct {
    int index;
    ARGS_glColor4ubVertex3fvSUN args;
} PACKED_glColor4ubVertex3fvSUN;
typedef struct {
    GLubyte * v;
} ARGS_glColor4ubv;
typedef struct {
    int index;
    ARGS_glColor4ubv args;
} PACKED_glColor4ubv;
typedef struct {
    GLuint red;
    GLuint green;
    GLuint blue;
    GLuint alpha;
} ARGS_glColor4ui;
typedef struct {
    int index;
    ARGS_glColor4ui args;
} PACKED_glColor4ui;
typedef struct {
    GLuint * v;
} ARGS_glColor4uiv;
typedef struct {
    int index;
    ARGS_glColor4uiv args;
} PACKED_glColor4uiv;
typedef struct {
    GLushort red;
    GLushort green;
    GLushort blue;
    GLushort alpha;
} ARGS_glColor4us;
typedef struct {
    int index;
    ARGS_glColor4us args;
} PACKED_glColor4us;
typedef struct {
    GLushort * v;
} ARGS_glColor4usv;
typedef struct {
    int index;
    ARGS_glColor4usv args;
} PACKED_glColor4usv;
typedef struct {
    GLfixed red;
    GLfixed green;
    GLfixed blue;
    GLfixed alpha;
} ARGS_glColor4x;
typedef struct {
    int index;
    ARGS_glColor4x args;
} PACKED_glColor4x;
typedef struct {
    GLfixed red;
    GLfixed green;
    GLfixed blue;
    GLfixed alpha;
} ARGS_glColor4xOES;
typedef struct {
    int index;
    ARGS_glColor4xOES args;
} PACKED_glColor4xOES;
typedef struct {
    GLfixed * components;
} ARGS_glColor4xvOES;
typedef struct {
    int index;
    ARGS_glColor4xvOES args;
} PACKED_glColor4xvOES;
typedef struct {
    GLint size;
    GLenum type;
    GLsizei stride;
} ARGS_glColorFormatNV;
typedef struct {
    int index;
    ARGS_glColorFormatNV args;
} PACKED_glColorFormatNV;
typedef struct {
    GLenum op;
    GLuint dst;
    GLuint dstMask;
    GLuint dstMod;
    GLuint arg1;
    GLuint arg1Rep;
    GLuint arg1Mod;
} ARGS_glColorFragmentOp1ATI;
typedef struct {
    int index;
    ARGS_glColorFragmentOp1ATI args;
} PACKED_glColorFragmentOp1ATI;
typedef struct {
    GLenum op;
    GLuint dst;
    GLuint dstMask;
    GLuint dstMod;
    GLuint arg1;
    GLuint arg1Rep;
    GLuint arg1Mod;
    GLuint arg2;
    GLuint arg2Rep;
    GLuint arg2Mod;
} ARGS_glColorFragmentOp2ATI;
typedef struct {
    int index;
    ARGS_glColorFragmentOp2ATI args;
} PACKED_glColorFragmentOp2ATI;
typedef struct {
    GLenum op;
    GLuint dst;
    GLuint dstMask;
    GLuint dstMod;
    GLuint arg1;
    GLuint arg1Rep;
    GLuint arg1Mod;
    GLuint arg2;
    GLuint arg2Rep;
    GLuint arg2Mod;
    GLuint arg3;
    GLuint arg3Rep;
    GLuint arg3Mod;
} ARGS_glColorFragmentOp3ATI;
typedef struct {
    int index;
    ARGS_glColorFragmentOp3ATI args;
} PACKED_glColorFragmentOp3ATI;
typedef struct {
    GLboolean red;
    GLboolean green;
    GLboolean blue;
    GLboolean alpha;
} ARGS_glColorMask;
typedef struct {
    int index;
    ARGS_glColorMask args;
} PACKED_glColorMask;
typedef struct {
    GLuint index;
    GLboolean r;
    GLboolean g;
    GLboolean b;
    GLboolean a;
} ARGS_glColorMaskIndexedEXT;
typedef struct {
    int index;
    ARGS_glColorMaskIndexedEXT args;
} PACKED_glColorMaskIndexedEXT;
typedef struct {
    GLuint index;
    GLboolean r;
    GLboolean g;
    GLboolean b;
    GLboolean a;
} ARGS_glColorMaski;
typedef struct {
    int index;
    ARGS_glColorMaski args;
} PACKED_glColorMaski;
typedef struct {
    GLenum face;
    GLenum mode;
} ARGS_glColorMaterial;
typedef struct {
    int index;
    ARGS_glColorMaterial args;
} PACKED_glColorMaterial;
typedef struct {
    GLenum type;
    GLuint color;
} ARGS_glColorP3ui;
typedef struct {
    int index;
    ARGS_glColorP3ui args;
} PACKED_glColorP3ui;
typedef struct {
    GLenum type;
    GLuint * color;
} ARGS_glColorP3uiv;
typedef struct {
    int index;
    ARGS_glColorP3uiv args;
} PACKED_glColorP3uiv;
typedef struct {
    GLenum type;
    GLuint color;
} ARGS_glColorP4ui;
typedef struct {
    int index;
    ARGS_glColorP4ui args;
} PACKED_glColorP4ui;
typedef struct {
    GLenum type;
    GLuint * color;
} ARGS_glColorP4uiv;
typedef struct {
    int index;
    ARGS_glColorP4uiv args;
} PACKED_glColorP4uiv;
typedef struct {
    GLint size;
    GLenum type;
    GLsizei stride;
    GLvoid * pointer;
} ARGS_glColorPointer;
typedef struct {
    int index;
    ARGS_glColorPointer args;
} PACKED_glColorPointer;
typedef struct {
    GLint size;
    GLenum type;
    GLsizei stride;
    GLsizei count;
    GLvoid * pointer;
} ARGS_glColorPointerEXT;
typedef struct {
    int index;
    ARGS_glColorPointerEXT args;
} PACKED_glColorPointerEXT;
typedef struct {
    GLint size;
    GLenum type;
    GLint stride;
    GLvoid * pointer;
    GLint ptrstride;
} ARGS_glColorPointerListIBM;
typedef struct {
    int index;
    ARGS_glColorPointerListIBM args;
} PACKED_glColorPointerListIBM;
typedef struct {
    GLint size;
    GLenum type;
    GLvoid * pointer;
} ARGS_glColorPointervINTEL;
typedef struct {
    int index;
    ARGS_glColorPointervINTEL args;
} PACKED_glColorPointervINTEL;
typedef struct {
    GLenum target;
    GLsizei start;
    GLsizei count;
    GLenum format;
    GLenum type;
    GLvoid * data;
} ARGS_glColorSubTable;
typedef struct {
    int index;
    ARGS_glColorSubTable args;
} PACKED_glColorSubTable;
typedef struct {
    GLenum target;
    GLsizei start;
    GLsizei count;
    GLenum format;
    GLenum type;
    GLvoid * data;
} ARGS_glColorSubTableEXT;
typedef struct {
    int index;
    ARGS_glColorSubTableEXT args;
} PACKED_glColorSubTableEXT;
typedef struct {
    GLenum target;
    GLenum internalformat;
    GLsizei width;
    GLenum format;
    GLenum type;
    GLvoid * table;
} ARGS_glColorTable;
typedef struct {
    int index;
    ARGS_glColorTable args;
} PACKED_glColorTable;
typedef struct {
    GLenum target;
    GLenum internalFormat;
    GLsizei width;
    GLenum format;
    GLenum type;
    GLvoid * table;
} ARGS_glColorTableEXT;
typedef struct {
    int index;
    ARGS_glColorTableEXT args;
} PACKED_glColorTableEXT;
typedef struct {
    GLenum target;
    GLenum pname;
    GLfloat * params;
} ARGS_glColorTableParameterfv;
typedef struct {
    int index;
    ARGS_glColorTableParameterfv args;
} PACKED_glColorTableParameterfv;
typedef struct {
    GLenum target;
    GLenum pname;
    GLfloat * params;
} ARGS_glColorTableParameterfvSGI;
typedef struct {
    int index;
    ARGS_glColorTableParameterfvSGI args;
} PACKED_glColorTableParameterfvSGI;
typedef struct {
    GLenum target;
    GLenum pname;
    GLint * params;
} ARGS_glColorTableParameteriv;
typedef struct {
    int index;
    ARGS_glColorTableParameteriv args;
} PACKED_glColorTableParameteriv;
typedef struct {
    GLenum target;
    GLenum pname;
    GLint * params;
} ARGS_glColorTableParameterivSGI;
typedef struct {
    int index;
    ARGS_glColorTableParameterivSGI args;
} PACKED_glColorTableParameterivSGI;
typedef struct {
    GLenum target;
    GLenum internalformat;
    GLsizei width;
    GLenum format;
    GLenum type;
    GLvoid * table;
} ARGS_glColorTableSGI;
typedef struct {
    int index;
    ARGS_glColorTableSGI args;
} PACKED_glColorTableSGI;
typedef struct {
    GLenum stage;
    GLenum portion;
    GLenum variable;
    GLenum input;
    GLenum mapping;
    GLenum componentUsage;
} ARGS_glCombinerInputNV;
typedef struct {
    int index;
    ARGS_glCombinerInputNV args;
} PACKED_glCombinerInputNV;
typedef struct {
    GLenum stage;
    GLenum portion;
    GLenum abOutput;
    GLenum cdOutput;
    GLenum sumOutput;
    GLenum scale;
    GLenum bias;
    GLboolean abDotProduct;
    GLboolean cdDotProduct;
    GLboolean muxSum;
} ARGS_glCombinerOutputNV;
typedef struct {
    int index;
    ARGS_glCombinerOutputNV args;
} PACKED_glCombinerOutputNV;
typedef struct {
    GLenum pname;
    GLfloat param;
} ARGS_glCombinerParameterfNV;
typedef struct {
    int index;
    ARGS_glCombinerParameterfNV args;
} PACKED_glCombinerParameterfNV;
typedef struct {
    GLenum pname;
    GLfloat * params;
} ARGS_glCombinerParameterfvNV;
typedef struct {
    int index;
    ARGS_glCombinerParameterfvNV args;
} PACKED_glCombinerParameterfvNV;
typedef struct {
    GLenum pname;
    GLint param;
} ARGS_glCombinerParameteriNV;
typedef struct {
    int index;
    ARGS_glCombinerParameteriNV args;
} PACKED_glCombinerParameteriNV;
typedef struct {
    GLenum pname;
    GLint * params;
} ARGS_glCombinerParameterivNV;
typedef struct {
    int index;
    ARGS_glCombinerParameterivNV args;
} PACKED_glCombinerParameterivNV;
typedef struct {
    GLenum stage;
    GLenum pname;
    GLfloat * params;
} ARGS_glCombinerStageParameterfvNV;
typedef struct {
    int index;
    ARGS_glCombinerStageParameterfvNV args;
} PACKED_glCombinerStageParameterfvNV;
typedef struct {
    GLuint shader;
} ARGS_glCompileShader;
typedef struct {
    int index;
    ARGS_glCompileShader args;
} PACKED_glCompileShader;
typedef struct {
    GLhandleARB shaderObj;
} ARGS_glCompileShaderARB;
typedef struct {
    int index;
    ARGS_glCompileShaderARB args;
} PACKED_glCompileShaderARB;
typedef struct {
    GLuint shader;
    GLsizei count;
    GLchar * path;
    GLint * length;
} ARGS_glCompileShaderIncludeARB;
typedef struct {
    int index;
    ARGS_glCompileShaderIncludeARB args;
} PACKED_glCompileShaderIncludeARB;
typedef struct {
    GLenum texunit;
    GLenum target;
    GLint level;
    GLenum internalformat;
    GLsizei width;
    GLint border;
    GLsizei imageSize;
    GLvoid * bits;
} ARGS_glCompressedMultiTexImage1DEXT;
typedef struct {
    int index;
    ARGS_glCompressedMultiTexImage1DEXT args;
} PACKED_glCompressedMultiTexImage1DEXT;
typedef struct {
    GLenum texunit;
    GLenum target;
    GLint level;
    GLenum internalformat;
    GLsizei width;
    GLsizei height;
    GLint border;
    GLsizei imageSize;
    GLvoid * bits;
} ARGS_glCompressedMultiTexImage2DEXT;
typedef struct {
    int index;
    ARGS_glCompressedMultiTexImage2DEXT args;
} PACKED_glCompressedMultiTexImage2DEXT;
typedef struct {
    GLenum texunit;
    GLenum target;
    GLint level;
    GLenum internalformat;
    GLsizei width;
    GLsizei height;
    GLsizei depth;
    GLint border;
    GLsizei imageSize;
    GLvoid * bits;
} ARGS_glCompressedMultiTexImage3DEXT;
typedef struct {
    int index;
    ARGS_glCompressedMultiTexImage3DEXT args;
} PACKED_glCompressedMultiTexImage3DEXT;
typedef struct {
    GLenum texunit;
    GLenum target;
    GLint level;
    GLint xoffset;
    GLsizei width;
    GLenum format;
    GLsizei imageSize;
    GLvoid * bits;
} ARGS_glCompressedMultiTexSubImage1DEXT;
typedef struct {
    int index;
    ARGS_glCompressedMultiTexSubImage1DEXT args;
} PACKED_glCompressedMultiTexSubImage1DEXT;
typedef struct {
    GLenum texunit;
    GLenum target;
    GLint level;
    GLint xoffset;
    GLint yoffset;
    GLsizei width;
    GLsizei height;
    GLenum format;
    GLsizei imageSize;
    GLvoid * bits;
} ARGS_glCompressedMultiTexSubImage2DEXT;
typedef struct {
    int index;
    ARGS_glCompressedMultiTexSubImage2DEXT args;
} PACKED_glCompressedMultiTexSubImage2DEXT;
typedef struct {
    GLenum texunit;
    GLenum target;
    GLint level;
    GLint xoffset;
    GLint yoffset;
    GLint zoffset;
    GLsizei width;
    GLsizei height;
    GLsizei depth;
    GLenum format;
    GLsizei imageSize;
    GLvoid * bits;
} ARGS_glCompressedMultiTexSubImage3DEXT;
typedef struct {
    int index;
    ARGS_glCompressedMultiTexSubImage3DEXT args;
} PACKED_glCompressedMultiTexSubImage3DEXT;
typedef struct {
    GLenum target;
    GLint level;
    GLenum internalformat;
    GLsizei width;
    GLint border;
    GLsizei imageSize;
    GLvoid * data;
} ARGS_glCompressedTexImage1D;
typedef struct {
    int index;
    ARGS_glCompressedTexImage1D args;
} PACKED_glCompressedTexImage1D;
typedef struct {
    GLenum target;
    GLint level;
    GLenum internalformat;
    GLsizei width;
    GLint border;
    GLsizei imageSize;
    GLvoid * data;
} ARGS_glCompressedTexImage1DARB;
typedef struct {
    int index;
    ARGS_glCompressedTexImage1DARB args;
} PACKED_glCompressedTexImage1DARB;
typedef struct {
    GLenum target;
    GLint level;
    GLenum internalformat;
    GLsizei width;
    GLsizei height;
    GLint border;
    GLsizei imageSize;
    GLvoid * data;
} ARGS_glCompressedTexImage2D;
typedef struct {
    int index;
    ARGS_glCompressedTexImage2D args;
} PACKED_glCompressedTexImage2D;
typedef struct {
    GLenum target;
    GLint level;
    GLenum internalformat;
    GLsizei width;
    GLsizei height;
    GLint border;
    GLsizei imageSize;
    GLvoid * data;
} ARGS_glCompressedTexImage2DARB;
typedef struct {
    int index;
    ARGS_glCompressedTexImage2DARB args;
} PACKED_glCompressedTexImage2DARB;
typedef struct {
    GLenum target;
    GLint level;
    GLenum internalformat;
    GLsizei width;
    GLsizei height;
    GLsizei depth;
    GLint border;
    GLsizei imageSize;
    GLvoid * data;
} ARGS_glCompressedTexImage3D;
typedef struct {
    int index;
    ARGS_glCompressedTexImage3D args;
} PACKED_glCompressedTexImage3D;
typedef struct {
    GLenum target;
    GLint level;
    GLenum internalformat;
    GLsizei width;
    GLsizei height;
    GLsizei depth;
    GLint border;
    GLsizei imageSize;
    GLvoid * data;
} ARGS_glCompressedTexImage3DARB;
typedef struct {
    int index;
    ARGS_glCompressedTexImage3DARB args;
} PACKED_glCompressedTexImage3DARB;
typedef struct {
    GLenum target;
    GLint level;
    GLint xoffset;
    GLsizei width;
    GLenum format;
    GLsizei imageSize;
    GLvoid * data;
} ARGS_glCompressedTexSubImage1D;
typedef struct {
    int index;
    ARGS_glCompressedTexSubImage1D args;
} PACKED_glCompressedTexSubImage1D;
typedef struct {
    GLenum target;
    GLint level;
    GLint xoffset;
    GLsizei width;
    GLenum format;
    GLsizei imageSize;
    GLvoid * data;
} ARGS_glCompressedTexSubImage1DARB;
typedef struct {
    int index;
    ARGS_glCompressedTexSubImage1DARB args;
} PACKED_glCompressedTexSubImage1DARB;
typedef struct {
    GLenum target;
    GLint level;
    GLint xoffset;
    GLint yoffset;
    GLsizei width;
    GLsizei height;
    GLenum format;
    GLsizei imageSize;
    GLvoid * data;
} ARGS_glCompressedTexSubImage2D;
typedef struct {
    int index;
    ARGS_glCompressedTexSubImage2D args;
} PACKED_glCompressedTexSubImage2D;
typedef struct {
    GLenum target;
    GLint level;
    GLint xoffset;
    GLint yoffset;
    GLsizei width;
    GLsizei height;
    GLenum format;
    GLsizei imageSize;
    GLvoid * data;
} ARGS_glCompressedTexSubImage2DARB;
typedef struct {
    int index;
    ARGS_glCompressedTexSubImage2DARB args;
} PACKED_glCompressedTexSubImage2DARB;
typedef struct {
    GLenum target;
    GLint level;
    GLint xoffset;
    GLint yoffset;
    GLint zoffset;
    GLsizei width;
    GLsizei height;
    GLsizei depth;
    GLenum format;
    GLsizei imageSize;
    GLvoid * data;
} ARGS_glCompressedTexSubImage3D;
typedef struct {
    int index;
    ARGS_glCompressedTexSubImage3D args;
} PACKED_glCompressedTexSubImage3D;
typedef struct {
    GLenum target;
    GLint level;
    GLint xoffset;
    GLint yoffset;
    GLint zoffset;
    GLsizei width;
    GLsizei height;
    GLsizei depth;
    GLenum format;
    GLsizei imageSize;
    GLvoid * data;
} ARGS_glCompressedTexSubImage3DARB;
typedef struct {
    int index;
    ARGS_glCompressedTexSubImage3DARB args;
} PACKED_glCompressedTexSubImage3DARB;
typedef struct {
    GLuint texture;
    GLenum target;
    GLint level;
    GLenum internalformat;
    GLsizei width;
    GLint border;
    GLsizei imageSize;
    GLvoid * bits;
} ARGS_glCompressedTextureImage1DEXT;
typedef struct {
    int index;
    ARGS_glCompressedTextureImage1DEXT args;
} PACKED_glCompressedTextureImage1DEXT;
typedef struct {
    GLuint texture;
    GLenum target;
    GLint level;
    GLenum internalformat;
    GLsizei width;
    GLsizei height;
    GLint border;
    GLsizei imageSize;
    GLvoid * bits;
} ARGS_glCompressedTextureImage2DEXT;
typedef struct {
    int index;
    ARGS_glCompressedTextureImage2DEXT args;
} PACKED_glCompressedTextureImage2DEXT;
typedef struct {
    GLuint texture;
    GLenum target;
    GLint level;
    GLenum internalformat;
    GLsizei width;
    GLsizei height;
    GLsizei depth;
    GLint border;
    GLsizei imageSize;
    GLvoid * bits;
} ARGS_glCompressedTextureImage3DEXT;
typedef struct {
    int index;
    ARGS_glCompressedTextureImage3DEXT args;
} PACKED_glCompressedTextureImage3DEXT;
typedef struct {
    GLuint texture;
    GLenum target;
    GLint level;
    GLint xoffset;
    GLsizei width;
    GLenum format;
    GLsizei imageSize;
    GLvoid * bits;
} ARGS_glCompressedTextureSubImage1DEXT;
typedef struct {
    int index;
    ARGS_glCompressedTextureSubImage1DEXT args;
} PACKED_glCompressedTextureSubImage1DEXT;
typedef struct {
    GLuint texture;
    GLenum target;
    GLint level;
    GLint xoffset;
    GLint yoffset;
    GLsizei width;
    GLsizei height;
    GLenum format;
    GLsizei imageSize;
    GLvoid * bits;
} ARGS_glCompressedTextureSubImage2DEXT;
typedef struct {
    int index;
    ARGS_glCompressedTextureSubImage2DEXT args;
} PACKED_glCompressedTextureSubImage2DEXT;
typedef struct {
    GLuint texture;
    GLenum target;
    GLint level;
    GLint xoffset;
    GLint yoffset;
    GLint zoffset;
    GLsizei width;
    GLsizei height;
    GLsizei depth;
    GLenum format;
    GLsizei imageSize;
    GLvoid * bits;
} ARGS_glCompressedTextureSubImage3DEXT;
typedef struct {
    int index;
    ARGS_glCompressedTextureSubImage3DEXT args;
} PACKED_glCompressedTextureSubImage3DEXT;
typedef struct {
    GLenum target;
    GLenum internalformat;
    GLsizei width;
    GLenum format;
    GLenum type;
    GLvoid * image;
} ARGS_glConvolutionFilter1D;
typedef struct {
    int index;
    ARGS_glConvolutionFilter1D args;
} PACKED_glConvolutionFilter1D;
typedef struct {
    GLenum target;
    GLenum internalformat;
    GLsizei width;
    GLenum format;
    GLenum type;
    GLvoid * image;
} ARGS_glConvolutionFilter1DEXT;
typedef struct {
    int index;
    ARGS_glConvolutionFilter1DEXT args;
} PACKED_glConvolutionFilter1DEXT;
typedef struct {
    GLenum target;
    GLenum internalformat;
    GLsizei width;
    GLsizei height;
    GLenum format;
    GLenum type;
    GLvoid * image;
} ARGS_glConvolutionFilter2D;
typedef struct {
    int index;
    ARGS_glConvolutionFilter2D args;
} PACKED_glConvolutionFilter2D;
typedef struct {
    GLenum target;
    GLenum internalformat;
    GLsizei width;
    GLsizei height;
    GLenum format;
    GLenum type;
    GLvoid * image;
} ARGS_glConvolutionFilter2DEXT;
typedef struct {
    int index;
    ARGS_glConvolutionFilter2DEXT args;
} PACKED_glConvolutionFilter2DEXT;
typedef struct {
    GLenum target;
    GLenum pname;
    GLfloat params;
} ARGS_glConvolutionParameterf;
typedef struct {
    int index;
    ARGS_glConvolutionParameterf args;
} PACKED_glConvolutionParameterf;
typedef struct {
    GLenum target;
    GLenum pname;
    GLfloat params;
} ARGS_glConvolutionParameterfEXT;
typedef struct {
    int index;
    ARGS_glConvolutionParameterfEXT args;
} PACKED_glConvolutionParameterfEXT;
typedef struct {
    GLenum target;
    GLenum pname;
    GLfloat * params;
} ARGS_glConvolutionParameterfv;
typedef struct {
    int index;
    ARGS_glConvolutionParameterfv args;
} PACKED_glConvolutionParameterfv;
typedef struct {
    GLenum target;
    GLenum pname;
    GLfloat * params;
} ARGS_glConvolutionParameterfvEXT;
typedef struct {
    int index;
    ARGS_glConvolutionParameterfvEXT args;
} PACKED_glConvolutionParameterfvEXT;
typedef struct {
    GLenum target;
    GLenum pname;
    GLint params;
} ARGS_glConvolutionParameteri;
typedef struct {
    int index;
    ARGS_glConvolutionParameteri args;
} PACKED_glConvolutionParameteri;
typedef struct {
    GLenum target;
    GLenum pname;
    GLint params;
} ARGS_glConvolutionParameteriEXT;
typedef struct {
    int index;
    ARGS_glConvolutionParameteriEXT args;
} PACKED_glConvolutionParameteriEXT;
typedef struct {
    GLenum target;
    GLenum pname;
    GLint * params;
} ARGS_glConvolutionParameteriv;
typedef struct {
    int index;
    ARGS_glConvolutionParameteriv args;
} PACKED_glConvolutionParameteriv;
typedef struct {
    GLenum target;
    GLenum pname;
    GLint * params;
} ARGS_glConvolutionParameterivEXT;
typedef struct {
    int index;
    ARGS_glConvolutionParameterivEXT args;
} PACKED_glConvolutionParameterivEXT;
typedef struct {
    GLenum target;
    GLenum pname;
    GLfixed param;
} ARGS_glConvolutionParameterxOES;
typedef struct {
    int index;
    ARGS_glConvolutionParameterxOES args;
} PACKED_glConvolutionParameterxOES;
typedef struct {
    GLenum target;
    GLenum pname;
    GLfixed * params;
} ARGS_glConvolutionParameterxvOES;
typedef struct {
    int index;
    ARGS_glConvolutionParameterxvOES args;
} PACKED_glConvolutionParameterxvOES;
typedef struct {
    GLenum readTarget;
    GLenum writeTarget;
    GLintptr readOffset;
    GLintptr writeOffset;
    GLsizeiptr size;
} ARGS_glCopyBufferSubData;
typedef struct {
    int index;
    ARGS_glCopyBufferSubData args;
} PACKED_glCopyBufferSubData;
typedef struct {
    GLenum target;
    GLsizei start;
    GLint x;
    GLint y;
    GLsizei width;
} ARGS_glCopyColorSubTable;
typedef struct {
    int index;
    ARGS_glCopyColorSubTable args;
} PACKED_glCopyColorSubTable;
typedef struct {
    GLenum target;
    GLsizei start;
    GLint x;
    GLint y;
    GLsizei width;
} ARGS_glCopyColorSubTableEXT;
typedef struct {
    int index;
    ARGS_glCopyColorSubTableEXT args;
} PACKED_glCopyColorSubTableEXT;
typedef struct {
    GLenum target;
    GLenum internalformat;
    GLint x;
    GLint y;
    GLsizei width;
} ARGS_glCopyColorTable;
typedef struct {
    int index;
    ARGS_glCopyColorTable args;
} PACKED_glCopyColorTable;
typedef struct {
    GLenum target;
    GLenum internalformat;
    GLint x;
    GLint y;
    GLsizei width;
} ARGS_glCopyColorTableSGI;
typedef struct {
    int index;
    ARGS_glCopyColorTableSGI args;
} PACKED_glCopyColorTableSGI;
typedef struct {
    GLenum target;
    GLenum internalformat;
    GLint x;
    GLint y;
    GLsizei width;
} ARGS_glCopyConvolutionFilter1D;
typedef struct {
    int index;
    ARGS_glCopyConvolutionFilter1D args;
} PACKED_glCopyConvolutionFilter1D;
typedef struct {
    GLenum target;
    GLenum internalformat;
    GLint x;
    GLint y;
    GLsizei width;
} ARGS_glCopyConvolutionFilter1DEXT;
typedef struct {
    int index;
    ARGS_glCopyConvolutionFilter1DEXT args;
} PACKED_glCopyConvolutionFilter1DEXT;
typedef struct {
    GLenum target;
    GLenum internalformat;
    GLint x;
    GLint y;
    GLsizei width;
    GLsizei height;
} ARGS_glCopyConvolutionFilter2D;
typedef struct {
    int index;
    ARGS_glCopyConvolutionFilter2D args;
} PACKED_glCopyConvolutionFilter2D;
typedef struct {
    GLenum target;
    GLenum internalformat;
    GLint x;
    GLint y;
    GLsizei width;
    GLsizei height;
} ARGS_glCopyConvolutionFilter2DEXT;
typedef struct {
    int index;
    ARGS_glCopyConvolutionFilter2DEXT args;
} PACKED_glCopyConvolutionFilter2DEXT;
typedef struct {
    GLuint srcName;
    GLenum srcTarget;
    GLint srcLevel;
    GLint srcX;
    GLint srcY;
    GLint srcZ;
    GLuint dstName;
    GLenum dstTarget;
    GLint dstLevel;
    GLint dstX;
    GLint dstY;
    GLint dstZ;
    GLsizei srcWidth;
    GLsizei srcHeight;
    GLsizei srcDepth;
} ARGS_glCopyImageSubData;
typedef struct {
    int index;
    ARGS_glCopyImageSubData args;
} PACKED_glCopyImageSubData;
typedef struct {
    GLuint srcName;
    GLenum srcTarget;
    GLint srcLevel;
    GLint srcX;
    GLint srcY;
    GLint srcZ;
    GLuint dstName;
    GLenum dstTarget;
    GLint dstLevel;
    GLint dstX;
    GLint dstY;
    GLint dstZ;
    GLsizei width;
    GLsizei height;
    GLsizei depth;
} ARGS_glCopyImageSubDataNV;
typedef struct {
    int index;
    ARGS_glCopyImageSubDataNV args;
} PACKED_glCopyImageSubDataNV;
typedef struct {
    GLenum texunit;
    GLenum target;
    GLint level;
    GLenum internalformat;
    GLint x;
    GLint y;
    GLsizei width;
    GLint border;
} ARGS_glCopyMultiTexImage1DEXT;
typedef struct {
    int index;
    ARGS_glCopyMultiTexImage1DEXT args;
} PACKED_glCopyMultiTexImage1DEXT;
typedef struct {
    GLenum texunit;
    GLenum target;
    GLint level;
    GLenum internalformat;
    GLint x;
    GLint y;
    GLsizei width;
    GLsizei height;
    GLint border;
} ARGS_glCopyMultiTexImage2DEXT;
typedef struct {
    int index;
    ARGS_glCopyMultiTexImage2DEXT args;
} PACKED_glCopyMultiTexImage2DEXT;
typedef struct {
    GLenum texunit;
    GLenum target;
    GLint level;
    GLint xoffset;
    GLint x;
    GLint y;
    GLsizei width;
} ARGS_glCopyMultiTexSubImage1DEXT;
typedef struct {
    int index;
    ARGS_glCopyMultiTexSubImage1DEXT args;
} PACKED_glCopyMultiTexSubImage1DEXT;
typedef struct {
    GLenum texunit;
    GLenum target;
    GLint level;
    GLint xoffset;
    GLint yoffset;
    GLint x;
    GLint y;
    GLsizei width;
    GLsizei height;
} ARGS_glCopyMultiTexSubImage2DEXT;
typedef struct {
    int index;
    ARGS_glCopyMultiTexSubImage2DEXT args;
} PACKED_glCopyMultiTexSubImage2DEXT;
typedef struct {
    GLenum texunit;
    GLenum target;
    GLint level;
    GLint xoffset;
    GLint yoffset;
    GLint zoffset;
    GLint x;
    GLint y;
    GLsizei width;
    GLsizei height;
} ARGS_glCopyMultiTexSubImage3DEXT;
typedef struct {
    int index;
    ARGS_glCopyMultiTexSubImage3DEXT args;
} PACKED_glCopyMultiTexSubImage3DEXT;
typedef struct {
    GLuint resultPath;
    GLuint srcPath;
} ARGS_glCopyPathNV;
typedef struct {
    int index;
    ARGS_glCopyPathNV args;
} PACKED_glCopyPathNV;
typedef struct {
    GLint x;
    GLint y;
    GLsizei width;
    GLsizei height;
    GLenum type;
} ARGS_glCopyPixels;
typedef struct {
    int index;
    ARGS_glCopyPixels args;
} PACKED_glCopyPixels;
typedef struct {
    GLenum target;
    GLint level;
    GLenum internalformat;
    GLint x;
    GLint y;
    GLsizei width;
    GLint border;
} ARGS_glCopyTexImage1D;
typedef struct {
    int index;
    ARGS_glCopyTexImage1D args;
} PACKED_glCopyTexImage1D;
typedef struct {
    GLenum target;
    GLint level;
    GLenum internalformat;
    GLint x;
    GLint y;
    GLsizei width;
    GLint border;
} ARGS_glCopyTexImage1DEXT;
typedef struct {
    int index;
    ARGS_glCopyTexImage1DEXT args;
} PACKED_glCopyTexImage1DEXT;
typedef struct {
    GLenum target;
    GLint level;
    GLenum internalformat;
    GLint x;
    GLint y;
    GLsizei width;
    GLsizei height;
    GLint border;
} ARGS_glCopyTexImage2D;
typedef struct {
    int index;
    ARGS_glCopyTexImage2D args;
} PACKED_glCopyTexImage2D;
typedef struct {
    GLenum target;
    GLint level;
    GLenum internalformat;
    GLint x;
    GLint y;
    GLsizei width;
    GLsizei height;
    GLint border;
} ARGS_glCopyTexImage2DEXT;
typedef struct {
    int index;
    ARGS_glCopyTexImage2DEXT args;
} PACKED_glCopyTexImage2DEXT;
typedef struct {
    GLenum target;
    GLint level;
    GLint xoffset;
    GLint x;
    GLint y;
    GLsizei width;
} ARGS_glCopyTexSubImage1D;
typedef struct {
    int index;
    ARGS_glCopyTexSubImage1D args;
} PACKED_glCopyTexSubImage1D;
typedef struct {
    GLenum target;
    GLint level;
    GLint xoffset;
    GLint x;
    GLint y;
    GLsizei width;
} ARGS_glCopyTexSubImage1DEXT;
typedef struct {
    int index;
    ARGS_glCopyTexSubImage1DEXT args;
} PACKED_glCopyTexSubImage1DEXT;
typedef struct {
    GLenum target;
    GLint level;
    GLint xoffset;
    GLint yoffset;
    GLint x;
    GLint y;
    GLsizei width;
    GLsizei height;
} ARGS_glCopyTexSubImage2D;
typedef struct {
    int index;
    ARGS_glCopyTexSubImage2D args;
} PACKED_glCopyTexSubImage2D;
typedef struct {
    GLenum target;
    GLint level;
    GLint xoffset;
    GLint yoffset;
    GLint x;
    GLint y;
    GLsizei width;
    GLsizei height;
} ARGS_glCopyTexSubImage2DEXT;
typedef struct {
    int index;
    ARGS_glCopyTexSubImage2DEXT args;
} PACKED_glCopyTexSubImage2DEXT;
typedef struct {
    GLenum target;
    GLint level;
    GLint xoffset;
    GLint yoffset;
    GLint zoffset;
    GLint x;
    GLint y;
    GLsizei width;
    GLsizei height;
} ARGS_glCopyTexSubImage3D;
typedef struct {
    int index;
    ARGS_glCopyTexSubImage3D args;
} PACKED_glCopyTexSubImage3D;
typedef struct {
    GLenum target;
    GLint level;
    GLint xoffset;
    GLint yoffset;
    GLint zoffset;
    GLint x;
    GLint y;
    GLsizei width;
    GLsizei height;
} ARGS_glCopyTexSubImage3DEXT;
typedef struct {
    int index;
    ARGS_glCopyTexSubImage3DEXT args;
} PACKED_glCopyTexSubImage3DEXT;
typedef struct {
    GLuint texture;
    GLenum target;
    GLint level;
    GLenum internalformat;
    GLint x;
    GLint y;
    GLsizei width;
    GLint border;
} ARGS_glCopyTextureImage1DEXT;
typedef struct {
    int index;
    ARGS_glCopyTextureImage1DEXT args;
} PACKED_glCopyTextureImage1DEXT;
typedef struct {
    GLuint texture;
    GLenum target;
    GLint level;
    GLenum internalformat;
    GLint x;
    GLint y;
    GLsizei width;
    GLsizei height;
    GLint border;
} ARGS_glCopyTextureImage2DEXT;
typedef struct {
    int index;
    ARGS_glCopyTextureImage2DEXT args;
} PACKED_glCopyTextureImage2DEXT;
typedef struct {
    GLuint texture;
    GLenum target;
    GLint level;
    GLint xoffset;
    GLint x;
    GLint y;
    GLsizei width;
} ARGS_glCopyTextureSubImage1DEXT;
typedef struct {
    int index;
    ARGS_glCopyTextureSubImage1DEXT args;
} PACKED_glCopyTextureSubImage1DEXT;
typedef struct {
    GLuint texture;
    GLenum target;
    GLint level;
    GLint xoffset;
    GLint yoffset;
    GLint x;
    GLint y;
    GLsizei width;
    GLsizei height;
} ARGS_glCopyTextureSubImage2DEXT;
typedef struct {
    int index;
    ARGS_glCopyTextureSubImage2DEXT args;
} PACKED_glCopyTextureSubImage2DEXT;
typedef struct {
    GLuint texture;
    GLenum target;
    GLint level;
    GLint xoffset;
    GLint yoffset;
    GLint zoffset;
    GLint x;
    GLint y;
    GLsizei width;
    GLsizei height;
} ARGS_glCopyTextureSubImage3DEXT;
typedef struct {
    int index;
    ARGS_glCopyTextureSubImage3DEXT args;
} PACKED_glCopyTextureSubImage3DEXT;
typedef struct {
    GLsizei numPaths;
    GLenum pathNameType;
    GLvoid * paths;
    GLuint pathBase;
    GLenum coverMode;
    GLenum transformType;
    GLfloat * transformValues;
} ARGS_glCoverFillPathInstancedNV;
typedef struct {
    int index;
    ARGS_glCoverFillPathInstancedNV args;
} PACKED_glCoverFillPathInstancedNV;
typedef struct {
    GLuint path;
    GLenum coverMode;
} ARGS_glCoverFillPathNV;
typedef struct {
    int index;
    ARGS_glCoverFillPathNV args;
} PACKED_glCoverFillPathNV;
typedef struct {
    GLsizei numPaths;
    GLenum pathNameType;
    GLvoid * paths;
    GLuint pathBase;
    GLenum coverMode;
    GLenum transformType;
    GLfloat * transformValues;
} ARGS_glCoverStrokePathInstancedNV;
typedef struct {
    int index;
    ARGS_glCoverStrokePathInstancedNV args;
} PACKED_glCoverStrokePathInstancedNV;
typedef struct {
    GLuint path;
    GLenum coverMode;
} ARGS_glCoverStrokePathNV;
typedef struct {
    int index;
    ARGS_glCoverStrokePathNV args;
} PACKED_glCoverStrokePathNV;
typedef struct {
    int index;
} PACKED_glCreateProgram;
typedef struct {
    int index;
} PACKED_glCreateProgramObjectARB;
typedef struct {
    GLenum type;
} ARGS_glCreateShader;
typedef struct {
    int index;
    ARGS_glCreateShader args;
} PACKED_glCreateShader;
typedef struct {
    GLenum shaderType;
} ARGS_glCreateShaderObjectARB;
typedef struct {
    int index;
    ARGS_glCreateShaderObjectARB args;
} PACKED_glCreateShaderObjectARB;
typedef struct {
    GLenum type;
    GLchar * string;
} ARGS_glCreateShaderProgramEXT;
typedef struct {
    int index;
    ARGS_glCreateShaderProgramEXT args;
} PACKED_glCreateShaderProgramEXT;
typedef struct {
    GLenum type;
    GLsizei count;
    GLchar*const * strings;
} ARGS_glCreateShaderProgramv;
typedef struct {
    int index;
    ARGS_glCreateShaderProgramv args;
} PACKED_glCreateShaderProgramv;
typedef struct {
    struct _cl_context * context;
    struct _cl_event * event;
    GLbitfield flags;
} ARGS_glCreateSyncFromCLeventARB;
typedef struct {
    int index;
    ARGS_glCreateSyncFromCLeventARB args;
} PACKED_glCreateSyncFromCLeventARB;
typedef struct {
    GLenum mode;
} ARGS_glCullFace;
typedef struct {
    int index;
    ARGS_glCullFace args;
} PACKED_glCullFace;
typedef struct {
    GLenum pname;
    GLdouble * params;
} ARGS_glCullParameterdvEXT;
typedef struct {
    int index;
    ARGS_glCullParameterdvEXT args;
} PACKED_glCullParameterdvEXT;
typedef struct {
    GLenum pname;
    GLfloat * params;
} ARGS_glCullParameterfvEXT;
typedef struct {
    int index;
    ARGS_glCullParameterfvEXT args;
} PACKED_glCullParameterfvEXT;
typedef struct {
    GLint index;
} ARGS_glCurrentPaletteMatrixARB;
typedef struct {
    int index;
    ARGS_glCurrentPaletteMatrixARB args;
} PACKED_glCurrentPaletteMatrixARB;
typedef struct {
    GLDEBUGPROC callback;
    void * userParam;
} ARGS_glDebugMessageCallback;
typedef struct {
    int index;
    ARGS_glDebugMessageCallback args;
} PACKED_glDebugMessageCallback;
typedef struct {
    GLDEBUGPROCAMD callback;
    GLvoid * userParam;
} ARGS_glDebugMessageCallbackAMD;
typedef struct {
    int index;
    ARGS_glDebugMessageCallbackAMD args;
} PACKED_glDebugMessageCallbackAMD;
typedef struct {
    GLDEBUGPROCARB callback;
    GLvoid * userParam;
} ARGS_glDebugMessageCallbackARB;
typedef struct {
    int index;
    ARGS_glDebugMessageCallbackARB args;
} PACKED_glDebugMessageCallbackARB;
typedef struct {
    GLenum source;
    GLenum type;
    GLenum severity;
    GLsizei count;
    GLuint * ids;
    GLboolean enabled;
} ARGS_glDebugMessageControl;
typedef struct {
    int index;
    ARGS_glDebugMessageControl args;
} PACKED_glDebugMessageControl;
typedef struct {
    GLenum source;
    GLenum type;
    GLenum severity;
    GLsizei count;
    GLuint * ids;
    GLboolean enabled;
} ARGS_glDebugMessageControlARB;
typedef struct {
    int index;
    ARGS_glDebugMessageControlARB args;
} PACKED_glDebugMessageControlARB;
typedef struct {
    GLenum category;
    GLenum severity;
    GLsizei count;
    GLuint * ids;
    GLboolean enabled;
} ARGS_glDebugMessageEnableAMD;
typedef struct {
    int index;
    ARGS_glDebugMessageEnableAMD args;
} PACKED_glDebugMessageEnableAMD;
typedef struct {
    GLenum source;
    GLenum type;
    GLuint id;
    GLenum severity;
    GLsizei length;
    GLchar * buf;
} ARGS_glDebugMessageInsert;
typedef struct {
    int index;
    ARGS_glDebugMessageInsert args;
} PACKED_glDebugMessageInsert;
typedef struct {
    GLenum category;
    GLenum severity;
    GLuint id;
    GLsizei length;
    GLchar * buf;
} ARGS_glDebugMessageInsertAMD;
typedef struct {
    int index;
    ARGS_glDebugMessageInsertAMD args;
} PACKED_glDebugMessageInsertAMD;
typedef struct {
    GLenum source;
    GLenum type;
    GLuint id;
    GLenum severity;
    GLsizei length;
    GLchar * buf;
} ARGS_glDebugMessageInsertARB;
typedef struct {
    int index;
    ARGS_glDebugMessageInsertARB args;
} PACKED_glDebugMessageInsertARB;
typedef struct {
    GLbitfield mask;
} ARGS_glDeformSGIX;
typedef struct {
    int index;
    ARGS_glDeformSGIX args;
} PACKED_glDeformSGIX;
typedef struct {
    GLenum target;
    GLdouble u1 __attribute__ ((aligned(8)));
    GLdouble u2 __attribute__ ((aligned(8)));
    GLint ustride;
    GLint uorder;
    GLdouble v1 __attribute__ ((aligned(8)));
    GLdouble v2 __attribute__ ((aligned(8)));
    GLint vstride;
    GLint vorder;
    GLdouble w1 __attribute__ ((aligned(8)));
    GLdouble w2 __attribute__ ((aligned(8)));
    GLint wstride;
    GLint worder;
    GLdouble * points;
} ARGS_glDeformationMap3dSGIX;
typedef struct {
    int index;
    ARGS_glDeformationMap3dSGIX args;
} PACKED_glDeformationMap3dSGIX;
typedef struct {
    GLenum target;
    GLfloat u1;
    GLfloat u2;
    GLint ustride;
    GLint uorder;
    GLfloat v1;
    GLfloat v2;
    GLint vstride;
    GLint vorder;
    GLfloat w1;
    GLfloat w2;
    GLint wstride;
    GLint worder;
    GLfloat * points;
} ARGS_glDeformationMap3fSGIX;
typedef struct {
    int index;
    ARGS_glDeformationMap3fSGIX args;
} PACKED_glDeformationMap3fSGIX;
typedef struct {
    GLuint marker;
    GLsizei range;
} ARGS_glDeleteAsyncMarkersSGIX;
typedef struct {
    int index;
    ARGS_glDeleteAsyncMarkersSGIX args;
} PACKED_glDeleteAsyncMarkersSGIX;
typedef struct {
    GLsizei n;
    GLuint * buffers;
} ARGS_glDeleteBuffers;
typedef struct {
    int index;
    ARGS_glDeleteBuffers args;
} PACKED_glDeleteBuffers;
typedef struct {
    GLsizei n;
    GLuint * buffers;
} ARGS_glDeleteBuffersARB;
typedef struct {
    int index;
    ARGS_glDeleteBuffersARB args;
} PACKED_glDeleteBuffersARB;
typedef struct {
    GLsizei n;
    GLuint * fences;
} ARGS_glDeleteFencesAPPLE;
typedef struct {
    int index;
    ARGS_glDeleteFencesAPPLE args;
} PACKED_glDeleteFencesAPPLE;
typedef struct {
    GLsizei n;
    GLuint * fences;
} ARGS_glDeleteFencesNV;
typedef struct {
    int index;
    ARGS_glDeleteFencesNV args;
} PACKED_glDeleteFencesNV;
typedef struct {
    GLuint id;
} ARGS_glDeleteFragmentShaderATI;
typedef struct {
    int index;
    ARGS_glDeleteFragmentShaderATI args;
} PACKED_glDeleteFragmentShaderATI;
typedef struct {
    GLsizei n;
    GLuint * framebuffers;
} ARGS_glDeleteFramebuffers;
typedef struct {
    int index;
    ARGS_glDeleteFramebuffers args;
} PACKED_glDeleteFramebuffers;
typedef struct {
    GLsizei n;
    GLuint * framebuffers;
} ARGS_glDeleteFramebuffersEXT;
typedef struct {
    int index;
    ARGS_glDeleteFramebuffersEXT args;
} PACKED_glDeleteFramebuffersEXT;
typedef struct {
    GLuint list;
    GLsizei range;
} ARGS_glDeleteLists;
typedef struct {
    int index;
    ARGS_glDeleteLists args;
} PACKED_glDeleteLists;
typedef struct {
    GLint namelen;
    GLchar * name;
} ARGS_glDeleteNamedStringARB;
typedef struct {
    int index;
    ARGS_glDeleteNamedStringARB args;
} PACKED_glDeleteNamedStringARB;
typedef struct {
    GLenum identifier;
    GLuint num;
    GLuint * names;
} ARGS_glDeleteNamesAMD;
typedef struct {
    int index;
    ARGS_glDeleteNamesAMD args;
} PACKED_glDeleteNamesAMD;
typedef struct {
    GLhandleARB obj;
} ARGS_glDeleteObjectARB;
typedef struct {
    int index;
    ARGS_glDeleteObjectARB args;
} PACKED_glDeleteObjectARB;
typedef struct {
    GLsizei n;
    GLuint * ids;
} ARGS_glDeleteOcclusionQueriesNV;
typedef struct {
    int index;
    ARGS_glDeleteOcclusionQueriesNV args;
} PACKED_glDeleteOcclusionQueriesNV;
typedef struct {
    GLuint path;
    GLsizei range;
} ARGS_glDeletePathsNV;
typedef struct {
    int index;
    ARGS_glDeletePathsNV args;
} PACKED_glDeletePathsNV;
typedef struct {
    GLsizei n;
    GLuint * monitors;
} ARGS_glDeletePerfMonitorsAMD;
typedef struct {
    int index;
    ARGS_glDeletePerfMonitorsAMD args;
} PACKED_glDeletePerfMonitorsAMD;
typedef struct {
    GLuint program;
} ARGS_glDeleteProgram;
typedef struct {
    int index;
    ARGS_glDeleteProgram args;
} PACKED_glDeleteProgram;
typedef struct {
    GLsizei n;
    GLuint * pipelines;
} ARGS_glDeleteProgramPipelines;
typedef struct {
    int index;
    ARGS_glDeleteProgramPipelines args;
} PACKED_glDeleteProgramPipelines;
typedef struct {
    GLsizei n;
    GLuint * programs;
} ARGS_glDeleteProgramsARB;
typedef struct {
    int index;
    ARGS_glDeleteProgramsARB args;
} PACKED_glDeleteProgramsARB;
typedef struct {
    GLsizei n;
    GLuint * programs;
} ARGS_glDeleteProgramsNV;
typedef struct {
    int index;
    ARGS_glDeleteProgramsNV args;
} PACKED_glDeleteProgramsNV;
typedef struct {
    GLsizei n;
    GLuint * ids;
} ARGS_glDeleteQueries;
typedef struct {
    int index;
    ARGS_glDeleteQueries args;
} PACKED_glDeleteQueries;
typedef struct {
    GLsizei n;
    GLuint * ids;
} ARGS_glDeleteQueriesARB;
typedef struct {
    int index;
    ARGS_glDeleteQueriesARB args;
} PACKED_glDeleteQueriesARB;
typedef struct {
    GLsizei n;
    GLuint * renderbuffers;
} ARGS_glDeleteRenderbuffers;
typedef struct {
    int index;
    ARGS_glDeleteRenderbuffers args;
} PACKED_glDeleteRenderbuffers;
typedef struct {
    GLsizei n;
    GLuint * renderbuffers;
} ARGS_glDeleteRenderbuffersEXT;
typedef struct {
    int index;
    ARGS_glDeleteRenderbuffersEXT args;
} PACKED_glDeleteRenderbuffersEXT;
typedef struct {
    GLsizei count;
    GLuint * samplers;
} ARGS_glDeleteSamplers;
typedef struct {
    int index;
    ARGS_glDeleteSamplers args;
} PACKED_glDeleteSamplers;
typedef struct {
    GLuint shader;
} ARGS_glDeleteShader;
typedef struct {
    int index;
    ARGS_glDeleteShader args;
} PACKED_glDeleteShader;
typedef struct {
    GLsync sync;
} ARGS_glDeleteSync;
typedef struct {
    int index;
    ARGS_glDeleteSync args;
} PACKED_glDeleteSync;
typedef struct {
    GLsizei n;
    GLuint * textures;
} ARGS_glDeleteTextures;
typedef struct {
    int index;
    ARGS_glDeleteTextures args;
} PACKED_glDeleteTextures;
typedef struct {
    GLsizei n;
    GLuint * textures;
} ARGS_glDeleteTexturesEXT;
typedef struct {
    int index;
    ARGS_glDeleteTexturesEXT args;
} PACKED_glDeleteTexturesEXT;
typedef struct {
    GLsizei n;
    GLuint * ids;
} ARGS_glDeleteTransformFeedbacks;
typedef struct {
    int index;
    ARGS_glDeleteTransformFeedbacks args;
} PACKED_glDeleteTransformFeedbacks;
typedef struct {
    GLsizei n;
    GLuint * ids;
} ARGS_glDeleteTransformFeedbacksNV;
typedef struct {
    int index;
    ARGS_glDeleteTransformFeedbacksNV args;
} PACKED_glDeleteTransformFeedbacksNV;
typedef struct {
    GLsizei n;
    GLuint * arrays;
} ARGS_glDeleteVertexArrays;
typedef struct {
    int index;
    ARGS_glDeleteVertexArrays args;
} PACKED_glDeleteVertexArrays;
typedef struct {
    GLsizei n;
    GLuint * arrays;
} ARGS_glDeleteVertexArraysAPPLE;
typedef struct {
    int index;
    ARGS_glDeleteVertexArraysAPPLE args;
} PACKED_glDeleteVertexArraysAPPLE;
typedef struct {
    GLuint id;
} ARGS_glDeleteVertexShaderEXT;
typedef struct {
    int index;
    ARGS_glDeleteVertexShaderEXT args;
} PACKED_glDeleteVertexShaderEXT;
typedef struct {
    GLclampd zmin;
    GLclampd zmax;
} ARGS_glDepthBoundsEXT;
typedef struct {
    int index;
    ARGS_glDepthBoundsEXT args;
} PACKED_glDepthBoundsEXT;
typedef struct {
    GLdouble zmin __attribute__ ((aligned(8)));
    GLdouble zmax __attribute__ ((aligned(8)));
} ARGS_glDepthBoundsdNV;
typedef struct {
    int index;
    ARGS_glDepthBoundsdNV args;
} PACKED_glDepthBoundsdNV;
typedef struct {
    GLenum func;
} ARGS_glDepthFunc;
typedef struct {
    int index;
    ARGS_glDepthFunc args;
} PACKED_glDepthFunc;
typedef struct {
    GLboolean flag;
} ARGS_glDepthMask;
typedef struct {
    int index;
    ARGS_glDepthMask args;
} PACKED_glDepthMask;
typedef struct {
    GLdouble near __attribute__ ((aligned(8)));
    GLdouble far __attribute__ ((aligned(8)));
} ARGS_glDepthRange;
typedef struct {
    int index;
    ARGS_glDepthRange args;
} PACKED_glDepthRange;
typedef struct {
    GLuint first;
    GLsizei count;
    GLdouble * v;
} ARGS_glDepthRangeArrayv;
typedef struct {
    int index;
    ARGS_glDepthRangeArrayv args;
} PACKED_glDepthRangeArrayv;
typedef struct {
    GLuint index;
    GLdouble n __attribute__ ((aligned(8)));
    GLdouble f __attribute__ ((aligned(8)));
} ARGS_glDepthRangeIndexed;
typedef struct {
    int index;
    ARGS_glDepthRangeIndexed args;
} PACKED_glDepthRangeIndexed;
typedef struct {
    GLdouble zNear __attribute__ ((aligned(8)));
    GLdouble zFar __attribute__ ((aligned(8)));
} ARGS_glDepthRangedNV;
typedef struct {
    int index;
    ARGS_glDepthRangedNV args;
} PACKED_glDepthRangedNV;
typedef struct {
    GLclampf near;
    GLclampf far;
} ARGS_glDepthRangef;
typedef struct {
    int index;
    ARGS_glDepthRangef args;
} PACKED_glDepthRangef;
typedef struct {
    GLclampf n;
    GLclampf f;
} ARGS_glDepthRangefOES;
typedef struct {
    int index;
    ARGS_glDepthRangefOES args;
} PACKED_glDepthRangefOES;
typedef struct {
    GLclampx near;
    GLclampx far;
} ARGS_glDepthRangex;
typedef struct {
    int index;
    ARGS_glDepthRangex args;
} PACKED_glDepthRangex;
typedef struct {
    GLfixed n;
    GLfixed f;
} ARGS_glDepthRangexOES;
typedef struct {
    int index;
    ARGS_glDepthRangexOES args;
} PACKED_glDepthRangexOES;
typedef struct {
    GLhandleARB containerObj;
    GLhandleARB attachedObj;
} ARGS_glDetachObjectARB;
typedef struct {
    int index;
    ARGS_glDetachObjectARB args;
} PACKED_glDetachObjectARB;
typedef struct {
    GLuint program;
    GLuint shader;
} ARGS_glDetachShader;
typedef struct {
    int index;
    ARGS_glDetachShader args;
} PACKED_glDetachShader;
typedef struct {
    GLenum target;
    GLsizei n;
    GLfloat * points;
} ARGS_glDetailTexFuncSGIS;
typedef struct {
    int index;
    ARGS_glDetailTexFuncSGIS args;
} PACKED_glDetailTexFuncSGIS;
typedef struct {
    GLenum cap;
} ARGS_glDisable;
typedef struct {
    int index;
    ARGS_glDisable args;
} PACKED_glDisable;
typedef struct {
    GLenum array;
} ARGS_glDisableClientState;
typedef struct {
    int index;
    ARGS_glDisableClientState args;
} PACKED_glDisableClientState;
typedef struct {
    GLenum array;
    GLuint index;
} ARGS_glDisableClientStateIndexedEXT;
typedef struct {
    int index;
    ARGS_glDisableClientStateIndexedEXT args;
} PACKED_glDisableClientStateIndexedEXT;
typedef struct {
    GLenum array;
    GLuint index;
} ARGS_glDisableClientStateiEXT;
typedef struct {
    int index;
    ARGS_glDisableClientStateiEXT args;
} PACKED_glDisableClientStateiEXT;
typedef struct {
    GLenum target;
    GLuint index;
} ARGS_glDisableIndexedEXT;
typedef struct {
    int index;
    ARGS_glDisableIndexedEXT args;
} PACKED_glDisableIndexedEXT;
typedef struct {
    GLuint id;
} ARGS_glDisableVariantClientStateEXT;
typedef struct {
    int index;
    ARGS_glDisableVariantClientStateEXT args;
} PACKED_glDisableVariantClientStateEXT;
typedef struct {
    GLuint vaobj;
    GLuint index;
} ARGS_glDisableVertexArrayAttribEXT;
typedef struct {
    int index;
    ARGS_glDisableVertexArrayAttribEXT args;
} PACKED_glDisableVertexArrayAttribEXT;
typedef struct {
    GLuint vaobj;
    GLenum array;
} ARGS_glDisableVertexArrayEXT;
typedef struct {
    int index;
    ARGS_glDisableVertexArrayEXT args;
} PACKED_glDisableVertexArrayEXT;
typedef struct {
    GLuint index;
    GLenum pname;
} ARGS_glDisableVertexAttribAPPLE;
typedef struct {
    int index;
    ARGS_glDisableVertexAttribAPPLE args;
} PACKED_glDisableVertexAttribAPPLE;
typedef struct {
    GLuint index;
} ARGS_glDisableVertexAttribArray;
typedef struct {
    int index;
    ARGS_glDisableVertexAttribArray args;
} PACKED_glDisableVertexAttribArray;
typedef struct {
    GLuint index;
} ARGS_glDisableVertexAttribArrayARB;
typedef struct {
    int index;
    ARGS_glDisableVertexAttribArrayARB args;
} PACKED_glDisableVertexAttribArrayARB;
typedef struct {
    GLenum target;
    GLuint index;
} ARGS_glDisablei;
typedef struct {
    int index;
    ARGS_glDisablei args;
} PACKED_glDisablei;
typedef struct {
    GLuint num_groups_x;
    GLuint num_groups_y;
    GLuint num_groups_z;
} ARGS_glDispatchCompute;
typedef struct {
    int index;
    ARGS_glDispatchCompute args;
} PACKED_glDispatchCompute;
typedef struct {
    GLintptr indirect;
} ARGS_glDispatchComputeIndirect;
typedef struct {
    int index;
    ARGS_glDispatchComputeIndirect args;
} PACKED_glDispatchComputeIndirect;
typedef struct {
    GLenum mode;
    GLint first;
    GLsizei count;
} ARGS_glDrawArrays;
typedef struct {
    int index;
    ARGS_glDrawArrays args;
} PACKED_glDrawArrays;
typedef struct {
    GLenum mode;
    GLint first;
    GLsizei count;
} ARGS_glDrawArraysEXT;
typedef struct {
    int index;
    ARGS_glDrawArraysEXT args;
} PACKED_glDrawArraysEXT;
typedef struct {
    GLenum mode;
    GLvoid * indirect;
} ARGS_glDrawArraysIndirect;
typedef struct {
    int index;
    ARGS_glDrawArraysIndirect args;
} PACKED_glDrawArraysIndirect;
typedef struct {
    GLenum mode;
    GLint first;
    GLsizei count;
    GLsizei instancecount;
} ARGS_glDrawArraysInstanced;
typedef struct {
    int index;
    ARGS_glDrawArraysInstanced args;
} PACKED_glDrawArraysInstanced;
typedef struct {
    GLenum mode;
    GLint first;
    GLsizei count;
    GLsizei primcount;
} ARGS_glDrawArraysInstancedARB;
typedef struct {
    int index;
    ARGS_glDrawArraysInstancedARB args;
} PACKED_glDrawArraysInstancedARB;
typedef struct {
    GLenum mode;
    GLint first;
    GLsizei count;
    GLsizei instancecount;
    GLuint baseinstance;
} ARGS_glDrawArraysInstancedBaseInstance;
typedef struct {
    int index;
    ARGS_glDrawArraysInstancedBaseInstance args;
} PACKED_glDrawArraysInstancedBaseInstance;
typedef struct {
    GLenum mode;
    GLint start;
    GLsizei count;
    GLsizei primcount;
} ARGS_glDrawArraysInstancedEXT;
typedef struct {
    int index;
    ARGS_glDrawArraysInstancedEXT args;
} PACKED_glDrawArraysInstancedEXT;
typedef struct {
    GLenum mode;
} ARGS_glDrawBuffer;
typedef struct {
    int index;
    ARGS_glDrawBuffer args;
} PACKED_glDrawBuffer;
typedef struct {
    GLsizei n;
    GLenum * bufs;
} ARGS_glDrawBuffers;
typedef struct {
    int index;
    ARGS_glDrawBuffers args;
} PACKED_glDrawBuffers;
typedef struct {
    GLsizei n;
    GLenum * bufs;
} ARGS_glDrawBuffersARB;
typedef struct {
    int index;
    ARGS_glDrawBuffersARB args;
} PACKED_glDrawBuffersARB;
typedef struct {
    GLsizei n;
    GLenum * bufs;
} ARGS_glDrawBuffersATI;
typedef struct {
    int index;
    ARGS_glDrawBuffersATI args;
} PACKED_glDrawBuffersATI;
typedef struct {
    GLenum mode;
    GLint first;
    GLsizei count;
} ARGS_glDrawElementArrayAPPLE;
typedef struct {
    int index;
    ARGS_glDrawElementArrayAPPLE args;
} PACKED_glDrawElementArrayAPPLE;
typedef struct {
    GLenum mode;
    GLsizei count;
} ARGS_glDrawElementArrayATI;
typedef struct {
    int index;
    ARGS_glDrawElementArrayATI args;
} PACKED_glDrawElementArrayATI;
typedef struct {
    GLenum mode;
    GLsizei count;
    GLenum type;
    GLvoid * indices;
} ARGS_glDrawElements;
typedef struct {
    int index;
    ARGS_glDrawElements args;
} PACKED_glDrawElements;
typedef struct {
    GLenum mode;
    GLsizei count;
    GLenum type;
    GLvoid * indices;
    GLint basevertex;
} ARGS_glDrawElementsBaseVertex;
typedef struct {
    int index;
    ARGS_glDrawElementsBaseVertex args;
} PACKED_glDrawElementsBaseVertex;
typedef struct {
    GLenum mode;
    GLenum type;
    GLvoid * indirect;
} ARGS_glDrawElementsIndirect;
typedef struct {
    int index;
    ARGS_glDrawElementsIndirect args;
} PACKED_glDrawElementsIndirect;
typedef struct {
    GLenum mode;
    GLsizei count;
    GLenum type;
    GLvoid * indices;
    GLsizei instancecount;
} ARGS_glDrawElementsInstanced;
typedef struct {
    int index;
    ARGS_glDrawElementsInstanced args;
} PACKED_glDrawElementsInstanced;
typedef struct {
    GLenum mode;
    GLsizei count;
    GLenum type;
    GLvoid * indices;
    GLsizei primcount;
} ARGS_glDrawElementsInstancedARB;
typedef struct {
    int index;
    ARGS_glDrawElementsInstancedARB args;
} PACKED_glDrawElementsInstancedARB;
typedef struct {
    GLenum mode;
    GLsizei count;
    GLenum type;
    void * indices;
    GLsizei instancecount;
    GLuint baseinstance;
} ARGS_glDrawElementsInstancedBaseInstance;
typedef struct {
    int index;
    ARGS_glDrawElementsInstancedBaseInstance args;
} PACKED_glDrawElementsInstancedBaseInstance;
typedef struct {
    GLenum mode;
    GLsizei count;
    GLenum type;
    GLvoid * indices;
    GLsizei instancecount;
    GLint basevertex;
} ARGS_glDrawElementsInstancedBaseVertex;
typedef struct {
    int index;
    ARGS_glDrawElementsInstancedBaseVertex args;
} PACKED_glDrawElementsInstancedBaseVertex;
typedef struct {
    GLenum mode;
    GLsizei count;
    GLenum type;
    void * indices;
    GLsizei instancecount;
    GLint basevertex;
    GLuint baseinstance;
} ARGS_glDrawElementsInstancedBaseVertexBaseInstance;
typedef struct {
    int index;
    ARGS_glDrawElementsInstancedBaseVertexBaseInstance args;
} PACKED_glDrawElementsInstancedBaseVertexBaseInstance;
typedef struct {
    GLenum mode;
    GLsizei count;
    GLenum type;
    GLvoid * indices;
    GLsizei primcount;
} ARGS_glDrawElementsInstancedEXT;
typedef struct {
    int index;
    ARGS_glDrawElementsInstancedEXT args;
} PACKED_glDrawElementsInstancedEXT;
typedef struct {
    GLenum mode;
    GLint first;
    GLsizei count;
    GLsizei width;
} ARGS_glDrawMeshArraysSUN;
typedef struct {
    int index;
    ARGS_glDrawMeshArraysSUN args;
} PACKED_glDrawMeshArraysSUN;
typedef struct {
    GLsizei width;
    GLsizei height;
    GLenum format;
    GLenum type;
    GLvoid * pixels;
} ARGS_glDrawPixels;
typedef struct {
    int index;
    ARGS_glDrawPixels args;
} PACKED_glDrawPixels;
typedef struct {
    GLenum mode;
    GLuint start;
    GLuint end;
    GLint first;
    GLsizei count;
} ARGS_glDrawRangeElementArrayAPPLE;
typedef struct {
    int index;
    ARGS_glDrawRangeElementArrayAPPLE args;
} PACKED_glDrawRangeElementArrayAPPLE;
typedef struct {
    GLenum mode;
    GLuint start;
    GLuint end;
    GLsizei count;
} ARGS_glDrawRangeElementArrayATI;
typedef struct {
    int index;
    ARGS_glDrawRangeElementArrayATI args;
} PACKED_glDrawRangeElementArrayATI;
typedef struct {
    GLenum mode;
    GLuint start;
    GLuint end;
    GLsizei count;
    GLenum type;
    GLvoid * indices;
} ARGS_glDrawRangeElements;
typedef struct {
    int index;
    ARGS_glDrawRangeElements args;
} PACKED_glDrawRangeElements;
typedef struct {
    GLenum mode;
    GLuint start;
    GLuint end;
    GLsizei count;
    GLenum type;
    GLvoid * indices;
    GLint basevertex;
} ARGS_glDrawRangeElementsBaseVertex;
typedef struct {
    int index;
    ARGS_glDrawRangeElementsBaseVertex args;
} PACKED_glDrawRangeElementsBaseVertex;
typedef struct {
    GLenum mode;
    GLuint start;
    GLuint end;
    GLsizei count;
    GLenum type;
    GLvoid * indices;
} ARGS_glDrawRangeElementsEXT;
typedef struct {
    int index;
    ARGS_glDrawRangeElementsEXT args;
} PACKED_glDrawRangeElementsEXT;
typedef struct {
    GLuint texture;
    GLuint sampler;
    GLfloat x0;
    GLfloat y0;
    GLfloat x1;
    GLfloat y1;
    GLfloat z;
    GLfloat s0;
    GLfloat t0;
    GLfloat s1;
    GLfloat t1;
} ARGS_glDrawTextureNV;
typedef struct {
    int index;
    ARGS_glDrawTextureNV args;
} PACKED_glDrawTextureNV;
typedef struct {
    GLenum mode;
    GLuint id;
} ARGS_glDrawTransformFeedback;
typedef struct {
    int index;
    ARGS_glDrawTransformFeedback args;
} PACKED_glDrawTransformFeedback;
typedef struct {
    GLenum mode;
    GLuint id;
    GLsizei instancecount;
} ARGS_glDrawTransformFeedbackInstanced;
typedef struct {
    int index;
    ARGS_glDrawTransformFeedbackInstanced args;
} PACKED_glDrawTransformFeedbackInstanced;
typedef struct {
    GLenum mode;
    GLuint id;
} ARGS_glDrawTransformFeedbackNV;
typedef struct {
    int index;
    ARGS_glDrawTransformFeedbackNV args;
} PACKED_glDrawTransformFeedbackNV;
typedef struct {
    GLenum mode;
    GLuint id;
    GLuint stream;
} ARGS_glDrawTransformFeedbackStream;
typedef struct {
    int index;
    ARGS_glDrawTransformFeedbackStream args;
} PACKED_glDrawTransformFeedbackStream;
typedef struct {
    GLenum mode;
    GLuint id;
    GLuint stream;
    GLsizei instancecount;
} ARGS_glDrawTransformFeedbackStreamInstanced;
typedef struct {
    int index;
    ARGS_glDrawTransformFeedbackStreamInstanced args;
} PACKED_glDrawTransformFeedbackStreamInstanced;
typedef struct {
    GLboolean flag;
} ARGS_glEdgeFlag;
typedef struct {
    int index;
    ARGS_glEdgeFlag args;
} PACKED_glEdgeFlag;
typedef struct {
    GLsizei stride;
} ARGS_glEdgeFlagFormatNV;
typedef struct {
    int index;
    ARGS_glEdgeFlagFormatNV args;
} PACKED_glEdgeFlagFormatNV;
typedef struct {
    GLsizei stride;
    GLvoid * pointer;
} ARGS_glEdgeFlagPointer;
typedef struct {
    int index;
    ARGS_glEdgeFlagPointer args;
} PACKED_glEdgeFlagPointer;
typedef struct {
    GLsizei stride;
    GLsizei count;
    GLboolean * pointer;
} ARGS_glEdgeFlagPointerEXT;
typedef struct {
    int index;
    ARGS_glEdgeFlagPointerEXT args;
} PACKED_glEdgeFlagPointerEXT;
typedef struct {
    GLint stride;
    GLboolean * pointer;
    GLint ptrstride;
} ARGS_glEdgeFlagPointerListIBM;
typedef struct {
    int index;
    ARGS_glEdgeFlagPointerListIBM args;
} PACKED_glEdgeFlagPointerListIBM;
typedef struct {
    GLboolean * flag;
} ARGS_glEdgeFlagv;
typedef struct {
    int index;
    ARGS_glEdgeFlagv args;
} PACKED_glEdgeFlagv;
typedef struct {
    GLenum type;
    GLvoid * pointer;
} ARGS_glElementPointerAPPLE;
typedef struct {
    int index;
    ARGS_glElementPointerAPPLE args;
} PACKED_glElementPointerAPPLE;
typedef struct {
    GLenum type;
    GLvoid * pointer;
} ARGS_glElementPointerATI;
typedef struct {
    int index;
    ARGS_glElementPointerATI args;
} PACKED_glElementPointerATI;
typedef struct {
    GLenum cap;
} ARGS_glEnable;
typedef struct {
    int index;
    ARGS_glEnable args;
} PACKED_glEnable;
typedef struct {
    GLenum array;
} ARGS_glEnableClientState;
typedef struct {
    int index;
    ARGS_glEnableClientState args;
} PACKED_glEnableClientState;
typedef struct {
    GLenum array;
    GLuint index;
} ARGS_glEnableClientStateIndexedEXT;
typedef struct {
    int index;
    ARGS_glEnableClientStateIndexedEXT args;
} PACKED_glEnableClientStateIndexedEXT;
typedef struct {
    GLenum array;
    GLuint index;
} ARGS_glEnableClientStateiEXT;
typedef struct {
    int index;
    ARGS_glEnableClientStateiEXT args;
} PACKED_glEnableClientStateiEXT;
typedef struct {
    GLenum target;
    GLuint index;
} ARGS_glEnableIndexedEXT;
typedef struct {
    int index;
    ARGS_glEnableIndexedEXT args;
} PACKED_glEnableIndexedEXT;
typedef struct {
    GLuint id;
} ARGS_glEnableVariantClientStateEXT;
typedef struct {
    int index;
    ARGS_glEnableVariantClientStateEXT args;
} PACKED_glEnableVariantClientStateEXT;
typedef struct {
    GLuint vaobj;
    GLuint index;
} ARGS_glEnableVertexArrayAttribEXT;
typedef struct {
    int index;
    ARGS_glEnableVertexArrayAttribEXT args;
} PACKED_glEnableVertexArrayAttribEXT;
typedef struct {
    GLuint vaobj;
    GLenum array;
} ARGS_glEnableVertexArrayEXT;
typedef struct {
    int index;
    ARGS_glEnableVertexArrayEXT args;
} PACKED_glEnableVertexArrayEXT;
typedef struct {
    GLuint index;
    GLenum pname;
} ARGS_glEnableVertexAttribAPPLE;
typedef struct {
    int index;
    ARGS_glEnableVertexAttribAPPLE args;
} PACKED_glEnableVertexAttribAPPLE;
typedef struct {
    GLuint index;
} ARGS_glEnableVertexAttribArray;
typedef struct {
    int index;
    ARGS_glEnableVertexAttribArray args;
} PACKED_glEnableVertexAttribArray;
typedef struct {
    GLuint index;
} ARGS_glEnableVertexAttribArrayARB;
typedef struct {
    int index;
    ARGS_glEnableVertexAttribArrayARB args;
} PACKED_glEnableVertexAttribArrayARB;
typedef struct {
    GLenum target;
    GLuint index;
} ARGS_glEnablei;
typedef struct {
    int index;
    ARGS_glEnablei args;
} PACKED_glEnablei;
typedef struct {
    int index;
} PACKED_glEnd;
typedef struct {
    int index;
} PACKED_glEndConditionalRender;
typedef struct {
    int index;
} PACKED_glEndConditionalRenderNV;
typedef struct {
    int index;
} PACKED_glEndConditionalRenderNVX;
typedef struct {
    int index;
} PACKED_glEndFragmentShaderATI;
typedef struct {
    int index;
} PACKED_glEndList;
typedef struct {
    int index;
} PACKED_glEndOcclusionQueryNV;
typedef struct {
    GLuint monitor;
} ARGS_glEndPerfMonitorAMD;
typedef struct {
    int index;
    ARGS_glEndPerfMonitorAMD args;
} PACKED_glEndPerfMonitorAMD;
typedef struct {
    GLenum target;
} ARGS_glEndQuery;
typedef struct {
    int index;
    ARGS_glEndQuery args;
} PACKED_glEndQuery;
typedef struct {
    GLenum target;
} ARGS_glEndQueryARB;
typedef struct {
    int index;
    ARGS_glEndQueryARB args;
} PACKED_glEndQueryARB;
typedef struct {
    GLenum target;
    GLuint index;
} ARGS_glEndQueryIndexed;
typedef struct {
    int index;
    ARGS_glEndQueryIndexed args;
} PACKED_glEndQueryIndexed;
typedef struct {
    int index;
} PACKED_glEndTransformFeedback;
typedef struct {
    int index;
} PACKED_glEndTransformFeedbackEXT;
typedef struct {
    int index;
} PACKED_glEndTransformFeedbackNV;
typedef struct {
    int index;
} PACKED_glEndVertexShaderEXT;
typedef struct {
    GLuint video_capture_slot;
} ARGS_glEndVideoCaptureNV;
typedef struct {
    int index;
    ARGS_glEndVideoCaptureNV args;
} PACKED_glEndVideoCaptureNV;
typedef struct {
    GLdouble u __attribute__ ((aligned(8)));
} ARGS_glEvalCoord1d;
typedef struct {
    int index;
    ARGS_glEvalCoord1d args;
} PACKED_glEvalCoord1d;
typedef struct {
    GLdouble * u;
} ARGS_glEvalCoord1dv;
typedef struct {
    int index;
    ARGS_glEvalCoord1dv args;
} PACKED_glEvalCoord1dv;
typedef struct {
    GLfloat u;
} ARGS_glEvalCoord1f;
typedef struct {
    int index;
    ARGS_glEvalCoord1f args;
} PACKED_glEvalCoord1f;
typedef struct {
    GLfloat * u;
} ARGS_glEvalCoord1fv;
typedef struct {
    int index;
    ARGS_glEvalCoord1fv args;
} PACKED_glEvalCoord1fv;
typedef struct {
    GLfixed u;
} ARGS_glEvalCoord1xOES;
typedef struct {
    int index;
    ARGS_glEvalCoord1xOES args;
} PACKED_glEvalCoord1xOES;
typedef struct {
    GLfixed * coords;
} ARGS_glEvalCoord1xvOES;
typedef struct {
    int index;
    ARGS_glEvalCoord1xvOES args;
} PACKED_glEvalCoord1xvOES;
typedef struct {
    GLdouble u __attribute__ ((aligned(8)));
    GLdouble v __attribute__ ((aligned(8)));
} ARGS_glEvalCoord2d;
typedef struct {
    int index;
    ARGS_glEvalCoord2d args;
} PACKED_glEvalCoord2d;
typedef struct {
    GLdouble * u;
} ARGS_glEvalCoord2dv;
typedef struct {
    int index;
    ARGS_glEvalCoord2dv args;
} PACKED_glEvalCoord2dv;
typedef struct {
    GLfloat u;
    GLfloat v;
} ARGS_glEvalCoord2f;
typedef struct {
    int index;
    ARGS_glEvalCoord2f args;
} PACKED_glEvalCoord2f;
typedef struct {
    GLfloat * u;
} ARGS_glEvalCoord2fv;
typedef struct {
    int index;
    ARGS_glEvalCoord2fv args;
} PACKED_glEvalCoord2fv;
typedef struct {
    GLfixed u;
    GLfixed v;
} ARGS_glEvalCoord2xOES;
typedef struct {
    int index;
    ARGS_glEvalCoord2xOES args;
} PACKED_glEvalCoord2xOES;
typedef struct {
    GLfixed * coords;
} ARGS_glEvalCoord2xvOES;
typedef struct {
    int index;
    ARGS_glEvalCoord2xvOES args;
} PACKED_glEvalCoord2xvOES;
typedef struct {
    GLenum target;
    GLenum mode;
} ARGS_glEvalMapsNV;
typedef struct {
    int index;
    ARGS_glEvalMapsNV args;
} PACKED_glEvalMapsNV;
typedef struct {
    GLenum mode;
    GLint i1;
    GLint i2;
} ARGS_glEvalMesh1;
typedef struct {
    int index;
    ARGS_glEvalMesh1 args;
} PACKED_glEvalMesh1;
typedef struct {
    GLenum mode;
    GLint i1;
    GLint i2;
    GLint j1;
    GLint j2;
} ARGS_glEvalMesh2;
typedef struct {
    int index;
    ARGS_glEvalMesh2 args;
} PACKED_glEvalMesh2;
typedef struct {
    GLint i;
} ARGS_glEvalPoint1;
typedef struct {
    int index;
    ARGS_glEvalPoint1 args;
} PACKED_glEvalPoint1;
typedef struct {
    GLint i;
    GLint j;
} ARGS_glEvalPoint2;
typedef struct {
    int index;
    ARGS_glEvalPoint2 args;
} PACKED_glEvalPoint2;
typedef struct {
    GLenum target;
    GLuint id;
    GLfloat * params;
} ARGS_glExecuteProgramNV;
typedef struct {
    int index;
    ARGS_glExecuteProgramNV args;
} PACKED_glExecuteProgramNV;
typedef struct {
    GLuint res;
    GLuint src;
    GLuint num;
} ARGS_glExtractComponentEXT;
typedef struct {
    int index;
    ARGS_glExtractComponentEXT args;
} PACKED_glExtractComponentEXT;
typedef struct {
    GLsizei size;
    GLenum type;
    GLfloat * buffer;
} ARGS_glFeedbackBuffer;
typedef struct {
    int index;
    ARGS_glFeedbackBuffer args;
} PACKED_glFeedbackBuffer;
typedef struct {
    GLsizei n;
    GLenum type;
    GLfixed * buffer;
} ARGS_glFeedbackBufferxOES;
typedef struct {
    int index;
    ARGS_glFeedbackBufferxOES args;
} PACKED_glFeedbackBufferxOES;
typedef struct {
    GLenum condition;
    GLbitfield flags;
} ARGS_glFenceSync;
typedef struct {
    int index;
    ARGS_glFenceSync args;
} PACKED_glFenceSync;
typedef struct {
    GLenum variable;
    GLenum input;
    GLenum mapping;
    GLenum componentUsage;
} ARGS_glFinalCombinerInputNV;
typedef struct {
    int index;
    ARGS_glFinalCombinerInputNV args;
} PACKED_glFinalCombinerInputNV;
typedef struct {
    int index;
} PACKED_glFinish;
typedef struct {
    GLuint * markerp;
} ARGS_glFinishAsyncSGIX;
typedef struct {
    int index;
    ARGS_glFinishAsyncSGIX args;
} PACKED_glFinishAsyncSGIX;
typedef struct {
    GLuint fence;
} ARGS_glFinishFenceAPPLE;
typedef struct {
    int index;
    ARGS_glFinishFenceAPPLE args;
} PACKED_glFinishFenceAPPLE;
typedef struct {
    GLuint fence;
} ARGS_glFinishFenceNV;
typedef struct {
    int index;
    ARGS_glFinishFenceNV args;
} PACKED_glFinishFenceNV;
typedef struct {
    GLenum object;
    GLint name;
} ARGS_glFinishObjectAPPLE;
typedef struct {
    int index;
    ARGS_glFinishObjectAPPLE args;
} PACKED_glFinishObjectAPPLE;
typedef struct {
    int index;
} PACKED_glFinishTextureSUNX;
typedef struct {
    int index;
} PACKED_glFlush;
typedef struct {
    GLenum target;
    GLintptr offset;
    GLsizeiptr length;
} ARGS_glFlushMappedBufferRange;
typedef struct {
    int index;
    ARGS_glFlushMappedBufferRange args;
} PACKED_glFlushMappedBufferRange;
typedef struct {
    GLenum target;
    GLintptr offset;
    GLsizeiptr size;
} ARGS_glFlushMappedBufferRangeAPPLE;
typedef struct {
    int index;
    ARGS_glFlushMappedBufferRangeAPPLE args;
} PACKED_glFlushMappedBufferRangeAPPLE;
typedef struct {
    GLuint buffer;
    GLintptr offset;
    GLsizeiptr length;
} ARGS_glFlushMappedNamedBufferRangeEXT;
typedef struct {
    int index;
    ARGS_glFlushMappedNamedBufferRangeEXT args;
} PACKED_glFlushMappedNamedBufferRangeEXT;
typedef struct {
    GLenum target;
} ARGS_glFlushPixelDataRangeNV;
typedef struct {
    int index;
    ARGS_glFlushPixelDataRangeNV args;
} PACKED_glFlushPixelDataRangeNV;
typedef struct {
    int index;
} PACKED_glFlushRasterSGIX;
typedef struct {
    GLenum target;
} ARGS_glFlushStaticDataIBM;
typedef struct {
    int index;
    ARGS_glFlushStaticDataIBM args;
} PACKED_glFlushStaticDataIBM;
typedef struct {
    GLsizei length;
    GLvoid * pointer;
} ARGS_glFlushVertexArrayRangeAPPLE;
typedef struct {
    int index;
    ARGS_glFlushVertexArrayRangeAPPLE args;
} PACKED_glFlushVertexArrayRangeAPPLE;
typedef struct {
    int index;
} PACKED_glFlushVertexArrayRangeNV;
typedef struct {
    GLenum type;
    GLsizei stride;
} ARGS_glFogCoordFormatNV;
typedef struct {
    int index;
    ARGS_glFogCoordFormatNV args;
} PACKED_glFogCoordFormatNV;
typedef struct {
    GLenum type;
    GLsizei stride;
    GLvoid * pointer;
} ARGS_glFogCoordPointer;
typedef struct {
    int index;
    ARGS_glFogCoordPointer args;
} PACKED_glFogCoordPointer;
typedef struct {
    GLenum type;
    GLsizei stride;
    GLvoid * pointer;
} ARGS_glFogCoordPointerEXT;
typedef struct {
    int index;
    ARGS_glFogCoordPointerEXT args;
} PACKED_glFogCoordPointerEXT;
typedef struct {
    GLenum type;
    GLint stride;
    GLvoid * pointer;
    GLint ptrstride;
} ARGS_glFogCoordPointerListIBM;
typedef struct {
    int index;
    ARGS_glFogCoordPointerListIBM args;
} PACKED_glFogCoordPointerListIBM;
typedef struct {
    GLdouble coord __attribute__ ((aligned(8)));
} ARGS_glFogCoordd;
typedef struct {
    int index;
    ARGS_glFogCoordd args;
} PACKED_glFogCoordd;
typedef struct {
    GLdouble coord __attribute__ ((aligned(8)));
} ARGS_glFogCoorddEXT;
typedef struct {
    int index;
    ARGS_glFogCoorddEXT args;
} PACKED_glFogCoorddEXT;
typedef struct {
    GLdouble * coord;
} ARGS_glFogCoorddv;
typedef struct {
    int index;
    ARGS_glFogCoorddv args;
} PACKED_glFogCoorddv;
typedef struct {
    GLdouble * coord;
} ARGS_glFogCoorddvEXT;
typedef struct {
    int index;
    ARGS_glFogCoorddvEXT args;
} PACKED_glFogCoorddvEXT;
typedef struct {
    GLfloat coord;
} ARGS_glFogCoordf;
typedef struct {
    int index;
    ARGS_glFogCoordf args;
} PACKED_glFogCoordf;
typedef struct {
    GLfloat coord;
} ARGS_glFogCoordfEXT;
typedef struct {
    int index;
    ARGS_glFogCoordfEXT args;
} PACKED_glFogCoordfEXT;
typedef struct {
    GLfloat * coord;
} ARGS_glFogCoordfv;
typedef struct {
    int index;
    ARGS_glFogCoordfv args;
} PACKED_glFogCoordfv;
typedef struct {
    GLfloat * coord;
} ARGS_glFogCoordfvEXT;
typedef struct {
    int index;
    ARGS_glFogCoordfvEXT args;
} PACKED_glFogCoordfvEXT;
typedef struct {
    GLhalfNV fog;
} ARGS_glFogCoordhNV;
typedef struct {
    int index;
    ARGS_glFogCoordhNV args;
} PACKED_glFogCoordhNV;
typedef struct {
    GLhalfNV * fog;
} ARGS_glFogCoordhvNV;
typedef struct {
    int index;
    ARGS_glFogCoordhvNV args;
} PACKED_glFogCoordhvNV;
typedef struct {
    GLsizei n;
    GLfloat * points;
} ARGS_glFogFuncSGIS;
typedef struct {
    int index;
    ARGS_glFogFuncSGIS args;
} PACKED_glFogFuncSGIS;
typedef struct {
    GLenum pname;
    GLfloat param;
} ARGS_glFogf;
typedef struct {
    int index;
    ARGS_glFogf args;
} PACKED_glFogf;
typedef struct {
    GLenum pname;
    GLfloat * params;
} ARGS_glFogfv;
typedef struct {
    int index;
    ARGS_glFogfv args;
} PACKED_glFogfv;
typedef struct {
    GLenum pname;
    GLint param;
} ARGS_glFogi;
typedef struct {
    int index;
    ARGS_glFogi args;
} PACKED_glFogi;
typedef struct {
    GLenum pname;
    GLint * params;
} ARGS_glFogiv;
typedef struct {
    int index;
    ARGS_glFogiv args;
} PACKED_glFogiv;
typedef struct {
    GLenum pname;
    GLfixed param;
} ARGS_glFogx;
typedef struct {
    int index;
    ARGS_glFogx args;
} PACKED_glFogx;
typedef struct {
    GLenum pname;
    GLfixed param;
} ARGS_glFogxOES;
typedef struct {
    int index;
    ARGS_glFogxOES args;
} PACKED_glFogxOES;
typedef struct {
    GLenum pname;
    GLfixed * params;
} ARGS_glFogxv;
typedef struct {
    int index;
    ARGS_glFogxv args;
} PACKED_glFogxv;
typedef struct {
    GLenum pname;
    GLfixed * param;
} ARGS_glFogxvOES;
typedef struct {
    int index;
    ARGS_glFogxvOES args;
} PACKED_glFogxvOES;
typedef struct {
    GLenum face;
    GLenum mode;
} ARGS_glFragmentColorMaterialSGIX;
typedef struct {
    int index;
    ARGS_glFragmentColorMaterialSGIX args;
} PACKED_glFragmentColorMaterialSGIX;
typedef struct {
    GLenum pname;
    GLfloat param;
} ARGS_glFragmentLightModelfSGIX;
typedef struct {
    int index;
    ARGS_glFragmentLightModelfSGIX args;
} PACKED_glFragmentLightModelfSGIX;
typedef struct {
    GLenum pname;
    GLfloat * params;
} ARGS_glFragmentLightModelfvSGIX;
typedef struct {
    int index;
    ARGS_glFragmentLightModelfvSGIX args;
} PACKED_glFragmentLightModelfvSGIX;
typedef struct {
    GLenum pname;
    GLint param;
} ARGS_glFragmentLightModeliSGIX;
typedef struct {
    int index;
    ARGS_glFragmentLightModeliSGIX args;
} PACKED_glFragmentLightModeliSGIX;
typedef struct {
    GLenum pname;
    GLint * params;
} ARGS_glFragmentLightModelivSGIX;
typedef struct {
    int index;
    ARGS_glFragmentLightModelivSGIX args;
} PACKED_glFragmentLightModelivSGIX;
typedef struct {
    GLenum light;
    GLenum pname;
    GLfloat param;
} ARGS_glFragmentLightfSGIX;
typedef struct {
    int index;
    ARGS_glFragmentLightfSGIX args;
} PACKED_glFragmentLightfSGIX;
typedef struct {
    GLenum light;
    GLenum pname;
    GLfloat * params;
} ARGS_glFragmentLightfvSGIX;
typedef struct {
    int index;
    ARGS_glFragmentLightfvSGIX args;
} PACKED_glFragmentLightfvSGIX;
typedef struct {
    GLenum light;
    GLenum pname;
    GLint param;
} ARGS_glFragmentLightiSGIX;
typedef struct {
    int index;
    ARGS_glFragmentLightiSGIX args;
} PACKED_glFragmentLightiSGIX;
typedef struct {
    GLenum light;
    GLenum pname;
    GLint * params;
} ARGS_glFragmentLightivSGIX;
typedef struct {
    int index;
    ARGS_glFragmentLightivSGIX args;
} PACKED_glFragmentLightivSGIX;
typedef struct {
    GLenum face;
    GLenum pname;
    GLfloat param;
} ARGS_glFragmentMaterialfSGIX;
typedef struct {
    int index;
    ARGS_glFragmentMaterialfSGIX args;
} PACKED_glFragmentMaterialfSGIX;
typedef struct {
    GLenum face;
    GLenum pname;
    GLfloat * params;
} ARGS_glFragmentMaterialfvSGIX;
typedef struct {
    int index;
    ARGS_glFragmentMaterialfvSGIX args;
} PACKED_glFragmentMaterialfvSGIX;
typedef struct {
    GLenum face;
    GLenum pname;
    GLint param;
} ARGS_glFragmentMaterialiSGIX;
typedef struct {
    int index;
    ARGS_glFragmentMaterialiSGIX args;
} PACKED_glFragmentMaterialiSGIX;
typedef struct {
    GLenum face;
    GLenum pname;
    GLint * params;
} ARGS_glFragmentMaterialivSGIX;
typedef struct {
    int index;
    ARGS_glFragmentMaterialivSGIX args;
} PACKED_glFragmentMaterialivSGIX;
typedef struct {
    int index;
} PACKED_glFrameTerminatorGREMEDY;
typedef struct {
    GLint factor;
} ARGS_glFrameZoomSGIX;
typedef struct {
    int index;
    ARGS_glFrameZoomSGIX args;
} PACKED_glFrameZoomSGIX;
typedef struct {
    GLuint framebuffer;
    GLenum mode;
} ARGS_glFramebufferDrawBufferEXT;
typedef struct {
    int index;
    ARGS_glFramebufferDrawBufferEXT args;
} PACKED_glFramebufferDrawBufferEXT;
typedef struct {
    GLuint framebuffer;
    GLsizei n;
    GLenum * bufs;
} ARGS_glFramebufferDrawBuffersEXT;
typedef struct {
    int index;
    ARGS_glFramebufferDrawBuffersEXT args;
} PACKED_glFramebufferDrawBuffersEXT;
typedef struct {
    GLenum target;
    GLenum pname;
    GLint param;
} ARGS_glFramebufferParameteri;
typedef struct {
    int index;
    ARGS_glFramebufferParameteri args;
} PACKED_glFramebufferParameteri;
typedef struct {
    GLuint framebuffer;
    GLenum mode;
} ARGS_glFramebufferReadBufferEXT;
typedef struct {
    int index;
    ARGS_glFramebufferReadBufferEXT args;
} PACKED_glFramebufferReadBufferEXT;
typedef struct {
    GLenum target;
    GLenum attachment;
    GLenum renderbuffertarget;
    GLuint renderbuffer;
} ARGS_glFramebufferRenderbuffer;
typedef struct {
    int index;
    ARGS_glFramebufferRenderbuffer args;
} PACKED_glFramebufferRenderbuffer;
typedef struct {
    GLenum target;
    GLenum attachment;
    GLenum renderbuffertarget;
    GLuint renderbuffer;
} ARGS_glFramebufferRenderbufferEXT;
typedef struct {
    int index;
    ARGS_glFramebufferRenderbufferEXT args;
} PACKED_glFramebufferRenderbufferEXT;
typedef struct {
    GLenum target;
    GLenum attachment;
    GLuint texture;
    GLint level;
} ARGS_glFramebufferTexture;
typedef struct {
    int index;
    ARGS_glFramebufferTexture args;
} PACKED_glFramebufferTexture;
typedef struct {
    GLenum target;
    GLenum attachment;
    GLenum textarget;
    GLuint texture;
    GLint level;
} ARGS_glFramebufferTexture1D;
typedef struct {
    int index;
    ARGS_glFramebufferTexture1D args;
} PACKED_glFramebufferTexture1D;
typedef struct {
    GLenum target;
    GLenum attachment;
    GLenum textarget;
    GLuint texture;
    GLint level;
} ARGS_glFramebufferTexture1DEXT;
typedef struct {
    int index;
    ARGS_glFramebufferTexture1DEXT args;
} PACKED_glFramebufferTexture1DEXT;
typedef struct {
    GLenum target;
    GLenum attachment;
    GLenum textarget;
    GLuint texture;
    GLint level;
} ARGS_glFramebufferTexture2D;
typedef struct {
    int index;
    ARGS_glFramebufferTexture2D args;
} PACKED_glFramebufferTexture2D;
typedef struct {
    GLenum target;
    GLenum attachment;
    GLenum textarget;
    GLuint texture;
    GLint level;
} ARGS_glFramebufferTexture2DEXT;
typedef struct {
    int index;
    ARGS_glFramebufferTexture2DEXT args;
} PACKED_glFramebufferTexture2DEXT;
typedef struct {
    GLenum target;
    GLenum attachment;
    GLenum textarget;
    GLuint texture;
    GLint level;
    GLint zoffset;
} ARGS_glFramebufferTexture3D;
typedef struct {
    int index;
    ARGS_glFramebufferTexture3D args;
} PACKED_glFramebufferTexture3D;
typedef struct {
    GLenum target;
    GLenum attachment;
    GLenum textarget;
    GLuint texture;
    GLint level;
    GLint zoffset;
} ARGS_glFramebufferTexture3DEXT;
typedef struct {
    int index;
    ARGS_glFramebufferTexture3DEXT args;
} PACKED_glFramebufferTexture3DEXT;
typedef struct {
    GLenum target;
    GLenum attachment;
    GLuint texture;
    GLint level;
} ARGS_glFramebufferTextureARB;
typedef struct {
    int index;
    ARGS_glFramebufferTextureARB args;
} PACKED_glFramebufferTextureARB;
typedef struct {
    GLenum target;
    GLenum attachment;
    GLuint texture;
    GLint level;
} ARGS_glFramebufferTextureEXT;
typedef struct {
    int index;
    ARGS_glFramebufferTextureEXT args;
} PACKED_glFramebufferTextureEXT;
typedef struct {
    GLenum target;
    GLenum attachment;
    GLuint texture;
    GLint level;
    GLenum face;
} ARGS_glFramebufferTextureFaceARB;
typedef struct {
    int index;
    ARGS_glFramebufferTextureFaceARB args;
} PACKED_glFramebufferTextureFaceARB;
typedef struct {
    GLenum target;
    GLenum attachment;
    GLuint texture;
    GLint level;
    GLenum face;
} ARGS_glFramebufferTextureFaceEXT;
typedef struct {
    int index;
    ARGS_glFramebufferTextureFaceEXT args;
} PACKED_glFramebufferTextureFaceEXT;
typedef struct {
    GLenum target;
    GLenum attachment;
    GLuint texture;
    GLint level;
    GLint layer;
} ARGS_glFramebufferTextureLayer;
typedef struct {
    int index;
    ARGS_glFramebufferTextureLayer args;
} PACKED_glFramebufferTextureLayer;
typedef struct {
    GLenum target;
    GLenum attachment;
    GLuint texture;
    GLint level;
    GLint layer;
} ARGS_glFramebufferTextureLayerARB;
typedef struct {
    int index;
    ARGS_glFramebufferTextureLayerARB args;
} PACKED_glFramebufferTextureLayerARB;
typedef struct {
    GLenum target;
    GLenum attachment;
    GLuint texture;
    GLint level;
    GLint layer;
} ARGS_glFramebufferTextureLayerEXT;
typedef struct {
    int index;
    ARGS_glFramebufferTextureLayerEXT args;
} PACKED_glFramebufferTextureLayerEXT;
typedef struct {
    GLuint buffer;
} ARGS_glFreeObjectBufferATI;
typedef struct {
    int index;
    ARGS_glFreeObjectBufferATI args;
} PACKED_glFreeObjectBufferATI;
typedef struct {
    GLenum mode;
} ARGS_glFrontFace;
typedef struct {
    int index;
    ARGS_glFrontFace args;
} PACKED_glFrontFace;
typedef struct {
    GLdouble left __attribute__ ((aligned(8)));
    GLdouble right __attribute__ ((aligned(8)));
    GLdouble bottom __attribute__ ((aligned(8)));
    GLdouble top __attribute__ ((aligned(8)));
    GLdouble zNear __attribute__ ((aligned(8)));
    GLdouble zFar __attribute__ ((aligned(8)));
} ARGS_glFrustum;
typedef struct {
    int index;
    ARGS_glFrustum args;
} PACKED_glFrustum;
typedef struct {
    GLfloat left;
    GLfloat right;
    GLfloat bottom;
    GLfloat top;
    GLfloat near;
    GLfloat far;
} ARGS_glFrustumf;
typedef struct {
    int index;
    ARGS_glFrustumf args;
} PACKED_glFrustumf;
typedef struct {
    GLfloat l;
    GLfloat r;
    GLfloat b;
    GLfloat t;
    GLfloat n;
    GLfloat f;
} ARGS_glFrustumfOES;
typedef struct {
    int index;
    ARGS_glFrustumfOES args;
} PACKED_glFrustumfOES;
typedef struct {
    GLfixed left;
    GLfixed right;
    GLfixed bottom;
    GLfixed top;
    GLfixed near;
    GLfixed far;
} ARGS_glFrustumx;
typedef struct {
    int index;
    ARGS_glFrustumx args;
} PACKED_glFrustumx;
typedef struct {
    GLfixed l;
    GLfixed r;
    GLfixed b;
    GLfixed t;
    GLfixed n;
    GLfixed f;
} ARGS_glFrustumxOES;
typedef struct {
    int index;
    ARGS_glFrustumxOES args;
} PACKED_glFrustumxOES;
typedef struct {
    GLsizei range;
} ARGS_glGenAsyncMarkersSGIX;
typedef struct {
    int index;
    ARGS_glGenAsyncMarkersSGIX args;
} PACKED_glGenAsyncMarkersSGIX;
typedef struct {
    GLsizei n;
    GLuint * buffers;
} ARGS_glGenBuffers;
typedef struct {
    int index;
    ARGS_glGenBuffers args;
} PACKED_glGenBuffers;
typedef struct {
    GLsizei n;
    GLuint * buffers;
} ARGS_glGenBuffersARB;
typedef struct {
    int index;
    ARGS_glGenBuffersARB args;
} PACKED_glGenBuffersARB;
typedef struct {
    GLsizei n;
    GLuint * fences;
} ARGS_glGenFencesAPPLE;
typedef struct {
    int index;
    ARGS_glGenFencesAPPLE args;
} PACKED_glGenFencesAPPLE;
typedef struct {
    GLsizei n;
    GLuint * fences;
} ARGS_glGenFencesNV;
typedef struct {
    int index;
    ARGS_glGenFencesNV args;
} PACKED_glGenFencesNV;
typedef struct {
    GLuint range;
} ARGS_glGenFragmentShadersATI;
typedef struct {
    int index;
    ARGS_glGenFragmentShadersATI args;
} PACKED_glGenFragmentShadersATI;
typedef struct {
    GLsizei n;
    GLuint * framebuffers;
} ARGS_glGenFramebuffers;
typedef struct {
    int index;
    ARGS_glGenFramebuffers args;
} PACKED_glGenFramebuffers;
typedef struct {
    GLsizei n;
    GLuint * framebuffers;
} ARGS_glGenFramebuffersEXT;
typedef struct {
    int index;
    ARGS_glGenFramebuffersEXT args;
} PACKED_glGenFramebuffersEXT;
typedef struct {
    GLsizei range;
} ARGS_glGenLists;
typedef struct {
    int index;
    ARGS_glGenLists args;
} PACKED_glGenLists;
typedef struct {
    GLenum identifier;
    GLuint num;
    GLuint * names;
} ARGS_glGenNamesAMD;
typedef struct {
    int index;
    ARGS_glGenNamesAMD args;
} PACKED_glGenNamesAMD;
typedef struct {
    GLsizei n;
    GLuint * ids;
} ARGS_glGenOcclusionQueriesNV;
typedef struct {
    int index;
    ARGS_glGenOcclusionQueriesNV args;
} PACKED_glGenOcclusionQueriesNV;
typedef struct {
    GLsizei range;
} ARGS_glGenPathsNV;
typedef struct {
    int index;
    ARGS_glGenPathsNV args;
} PACKED_glGenPathsNV;
typedef struct {
    GLsizei n;
    GLuint * monitors;
} ARGS_glGenPerfMonitorsAMD;
typedef struct {
    int index;
    ARGS_glGenPerfMonitorsAMD args;
} PACKED_glGenPerfMonitorsAMD;
typedef struct {
    GLsizei n;
    GLuint * pipelines;
} ARGS_glGenProgramPipelines;
typedef struct {
    int index;
    ARGS_glGenProgramPipelines args;
} PACKED_glGenProgramPipelines;
typedef struct {
    GLsizei n;
    GLuint * programs;
} ARGS_glGenProgramsARB;
typedef struct {
    int index;
    ARGS_glGenProgramsARB args;
} PACKED_glGenProgramsARB;
typedef struct {
    GLsizei n;
    GLuint * programs;
} ARGS_glGenProgramsNV;
typedef struct {
    int index;
    ARGS_glGenProgramsNV args;
} PACKED_glGenProgramsNV;
typedef struct {
    GLsizei n;
    GLuint * ids;
} ARGS_glGenQueries;
typedef struct {
    int index;
    ARGS_glGenQueries args;
} PACKED_glGenQueries;
typedef struct {
    GLsizei n;
    GLuint * ids;
} ARGS_glGenQueriesARB;
typedef struct {
    int index;
    ARGS_glGenQueriesARB args;
} PACKED_glGenQueriesARB;
typedef struct {
    GLsizei n;
    GLuint * renderbuffers;
} ARGS_glGenRenderbuffers;
typedef struct {
    int index;
    ARGS_glGenRenderbuffers args;
} PACKED_glGenRenderbuffers;
typedef struct {
    GLsizei n;
    GLuint * renderbuffers;
} ARGS_glGenRenderbuffersEXT;
typedef struct {
    int index;
    ARGS_glGenRenderbuffersEXT args;
} PACKED_glGenRenderbuffersEXT;
typedef struct {
    GLsizei count;
    GLuint * samplers;
} ARGS_glGenSamplers;
typedef struct {
    int index;
    ARGS_glGenSamplers args;
} PACKED_glGenSamplers;
typedef struct {
    GLenum datatype;
    GLenum storagetype;
    GLenum range;
    GLuint components;
} ARGS_glGenSymbolsEXT;
typedef struct {
    int index;
    ARGS_glGenSymbolsEXT args;
} PACKED_glGenSymbolsEXT;
typedef struct {
    GLsizei n;
    GLuint * textures;
} ARGS_glGenTextures;
typedef struct {
    int index;
    ARGS_glGenTextures args;
} PACKED_glGenTextures;
typedef struct {
    GLsizei n;
    GLuint * textures;
} ARGS_glGenTexturesEXT;
typedef struct {
    int index;
    ARGS_glGenTexturesEXT args;
} PACKED_glGenTexturesEXT;
typedef struct {
    GLsizei n;
    GLuint * ids;
} ARGS_glGenTransformFeedbacks;
typedef struct {
    int index;
    ARGS_glGenTransformFeedbacks args;
} PACKED_glGenTransformFeedbacks;
typedef struct {
    GLsizei n;
    GLuint * ids;
} ARGS_glGenTransformFeedbacksNV;
typedef struct {
    int index;
    ARGS_glGenTransformFeedbacksNV args;
} PACKED_glGenTransformFeedbacksNV;
typedef struct {
    GLsizei n;
    GLuint * arrays;
} ARGS_glGenVertexArrays;
typedef struct {
    int index;
    ARGS_glGenVertexArrays args;
} PACKED_glGenVertexArrays;
typedef struct {
    GLsizei n;
    GLuint * arrays;
} ARGS_glGenVertexArraysAPPLE;
typedef struct {
    int index;
    ARGS_glGenVertexArraysAPPLE args;
} PACKED_glGenVertexArraysAPPLE;
typedef struct {
    GLuint range;
} ARGS_glGenVertexShadersEXT;
typedef struct {
    int index;
    ARGS_glGenVertexShadersEXT args;
} PACKED_glGenVertexShadersEXT;
typedef struct {
    GLenum target;
} ARGS_glGenerateMipmap;
typedef struct {
    int index;
    ARGS_glGenerateMipmap args;
} PACKED_glGenerateMipmap;
typedef struct {
    GLenum target;
} ARGS_glGenerateMipmapEXT;
typedef struct {
    int index;
    ARGS_glGenerateMipmapEXT args;
} PACKED_glGenerateMipmapEXT;
typedef struct {
    GLenum texunit;
    GLenum target;
} ARGS_glGenerateMultiTexMipmapEXT;
typedef struct {
    int index;
    ARGS_glGenerateMultiTexMipmapEXT args;
} PACKED_glGenerateMultiTexMipmapEXT;
typedef struct {
    GLuint texture;
    GLenum target;
} ARGS_glGenerateTextureMipmapEXT;
typedef struct {
    int index;
    ARGS_glGenerateTextureMipmapEXT args;
} PACKED_glGenerateTextureMipmapEXT;
typedef struct {
    GLuint program;
    GLuint bufferIndex;
    GLenum pname;
    GLint * params;
} ARGS_glGetActiveAtomicCounterBufferiv;
typedef struct {
    int index;
    ARGS_glGetActiveAtomicCounterBufferiv args;
} PACKED_glGetActiveAtomicCounterBufferiv;
typedef struct {
    GLuint program;
    GLuint index;
    GLsizei bufSize;
    GLsizei * length;
    GLint * size;
    GLenum * type;
    GLchar * name;
} ARGS_glGetActiveAttrib;
typedef struct {
    int index;
    ARGS_glGetActiveAttrib args;
} PACKED_glGetActiveAttrib;
typedef struct {
    GLhandleARB programObj;
    GLuint index;
    GLsizei maxLength;
    GLsizei * length;
    GLint * size;
    GLenum * type;
    GLcharARB * name;
} ARGS_glGetActiveAttribARB;
typedef struct {
    int index;
    ARGS_glGetActiveAttribARB args;
} PACKED_glGetActiveAttribARB;
typedef struct {
    GLuint program;
    GLenum shadertype;
    GLuint index;
    GLsizei bufsize;
    GLsizei * length;
    GLchar * name;
} ARGS_glGetActiveSubroutineName;
typedef struct {
    int index;
    ARGS_glGetActiveSubroutineName args;
} PACKED_glGetActiveSubroutineName;
typedef struct {
    GLuint program;
    GLenum shadertype;
    GLuint index;
    GLsizei bufsize;
    GLsizei * length;
    GLchar * name;
} ARGS_glGetActiveSubroutineUniformName;
typedef struct {
    int index;
    ARGS_glGetActiveSubroutineUniformName args;
} PACKED_glGetActiveSubroutineUniformName;
typedef struct {
    GLuint program;
    GLenum shadertype;
    GLuint index;
    GLenum pname;
    GLint * values;
} ARGS_glGetActiveSubroutineUniformiv;
typedef struct {
    int index;
    ARGS_glGetActiveSubroutineUniformiv args;
} PACKED_glGetActiveSubroutineUniformiv;
typedef struct {
    GLuint program;
    GLuint index;
    GLsizei bufSize;
    GLsizei * length;
    GLint * size;
    GLenum * type;
    GLchar * name;
} ARGS_glGetActiveUniform;
typedef struct {
    int index;
    ARGS_glGetActiveUniform args;
} PACKED_glGetActiveUniform;
typedef struct {
    GLhandleARB programObj;
    GLuint index;
    GLsizei maxLength;
    GLsizei * length;
    GLint * size;
    GLenum * type;
    GLcharARB * name;
} ARGS_glGetActiveUniformARB;
typedef struct {
    int index;
    ARGS_glGetActiveUniformARB args;
} PACKED_glGetActiveUniformARB;
typedef struct {
    GLuint program;
    GLuint uniformBlockIndex;
    GLsizei bufSize;
    GLsizei * length;
    GLchar * uniformBlockName;
} ARGS_glGetActiveUniformBlockName;
typedef struct {
    int index;
    ARGS_glGetActiveUniformBlockName args;
} PACKED_glGetActiveUniformBlockName;
typedef struct {
    GLuint program;
    GLuint uniformBlockIndex;
    GLenum pname;
    GLint * params;
} ARGS_glGetActiveUniformBlockiv;
typedef struct {
    int index;
    ARGS_glGetActiveUniformBlockiv args;
} PACKED_glGetActiveUniformBlockiv;
typedef struct {
    GLuint program;
    GLuint uniformIndex;
    GLsizei bufSize;
    GLsizei * length;
    GLchar * uniformName;
} ARGS_glGetActiveUniformName;
typedef struct {
    int index;
    ARGS_glGetActiveUniformName args;
} PACKED_glGetActiveUniformName;
typedef struct {
    GLuint program;
    GLsizei uniformCount;
    GLuint * uniformIndices;
    GLenum pname;
    GLint * params;
} ARGS_glGetActiveUniformsiv;
typedef struct {
    int index;
    ARGS_glGetActiveUniformsiv args;
} PACKED_glGetActiveUniformsiv;
typedef struct {
    GLuint program;
    GLuint index;
    GLsizei bufSize;
    GLsizei * length;
    GLsizei * size;
    GLenum * type;
    GLchar * name;
} ARGS_glGetActiveVaryingNV;
typedef struct {
    int index;
    ARGS_glGetActiveVaryingNV args;
} PACKED_glGetActiveVaryingNV;
typedef struct {
    GLenum array;
    GLenum pname;
    GLfloat * params;
} ARGS_glGetArrayObjectfvATI;
typedef struct {
    int index;
    ARGS_glGetArrayObjectfvATI args;
} PACKED_glGetArrayObjectfvATI;
typedef struct {
    GLenum array;
    GLenum pname;
    GLint * params;
} ARGS_glGetArrayObjectivATI;
typedef struct {
    int index;
    ARGS_glGetArrayObjectivATI args;
} PACKED_glGetArrayObjectivATI;
typedef struct {
    GLhandleARB containerObj;
    GLsizei maxCount;
    GLsizei * count;
    GLhandleARB * obj;
} ARGS_glGetAttachedObjectsARB;
typedef struct {
    int index;
    ARGS_glGetAttachedObjectsARB args;
} PACKED_glGetAttachedObjectsARB;
typedef struct {
    GLuint program;
    GLsizei maxCount;
    GLsizei * count;
    GLuint * obj;
} ARGS_glGetAttachedShaders;
typedef struct {
    int index;
    ARGS_glGetAttachedShaders args;
} PACKED_glGetAttachedShaders;
typedef struct {
    GLuint program;
    GLchar * name;
} ARGS_glGetAttribLocation;
typedef struct {
    int index;
    ARGS_glGetAttribLocation args;
} PACKED_glGetAttribLocation;
typedef struct {
    GLhandleARB programObj;
    GLcharARB * name;
} ARGS_glGetAttribLocationARB;
typedef struct {
    int index;
    ARGS_glGetAttribLocationARB args;
} PACKED_glGetAttribLocationARB;
typedef struct {
    GLenum target;
    GLuint index;
    GLboolean * data;
} ARGS_glGetBooleanIndexedvEXT;
typedef struct {
    int index;
    ARGS_glGetBooleanIndexedvEXT args;
} PACKED_glGetBooleanIndexedvEXT;
typedef struct {
    GLenum target;
    GLuint index;
    GLboolean * data;
} ARGS_glGetBooleani_v;
typedef struct {
    int index;
    ARGS_glGetBooleani_v args;
} PACKED_glGetBooleani_v;
typedef struct {
    GLenum pname;
    GLboolean * params;
} ARGS_glGetBooleanv;
typedef struct {
    int index;
    ARGS_glGetBooleanv args;
} PACKED_glGetBooleanv;
typedef struct {
    GLenum target;
    GLenum pname;
    GLint64 * params;
} ARGS_glGetBufferParameteri64v;
typedef struct {
    int index;
    ARGS_glGetBufferParameteri64v args;
} PACKED_glGetBufferParameteri64v;
typedef struct {
    GLenum target;
    GLenum pname;
    GLint * params;
} ARGS_glGetBufferParameteriv;
typedef struct {
    int index;
    ARGS_glGetBufferParameteriv args;
} PACKED_glGetBufferParameteriv;
typedef struct {
    GLenum target;
    GLenum pname;
    GLint * params;
} ARGS_glGetBufferParameterivARB;
typedef struct {
    int index;
    ARGS_glGetBufferParameterivARB args;
} PACKED_glGetBufferParameterivARB;
typedef struct {
    GLenum target;
    GLenum pname;
    GLuint64EXT * params;
} ARGS_glGetBufferParameterui64vNV;
typedef struct {
    int index;
    ARGS_glGetBufferParameterui64vNV args;
} PACKED_glGetBufferParameterui64vNV;
typedef struct {
    GLenum target;
    GLenum pname;
    GLvoid * params;
} ARGS_glGetBufferPointerv;
typedef struct {
    int index;
    ARGS_glGetBufferPointerv args;
} PACKED_glGetBufferPointerv;
typedef struct {
    GLenum target;
    GLenum pname;
    GLvoid * params;
} ARGS_glGetBufferPointervARB;
typedef struct {
    int index;
    ARGS_glGetBufferPointervARB args;
} PACKED_glGetBufferPointervARB;
typedef struct {
    GLenum target;
    GLintptr offset;
    GLsizeiptr size;
    GLvoid * data;
} ARGS_glGetBufferSubData;
typedef struct {
    int index;
    ARGS_glGetBufferSubData args;
} PACKED_glGetBufferSubData;
typedef struct {
    GLenum target;
    GLintptrARB offset;
    GLsizeiptrARB size;
    GLvoid * data;
} ARGS_glGetBufferSubDataARB;
typedef struct {
    int index;
    ARGS_glGetBufferSubDataARB args;
} PACKED_glGetBufferSubDataARB;
typedef struct {
    GLenum plane;
    GLdouble * equation;
} ARGS_glGetClipPlane;
typedef struct {
    int index;
    ARGS_glGetClipPlane args;
} PACKED_glGetClipPlane;
typedef struct {
    GLenum plane;
    GLfloat * equation;
} ARGS_glGetClipPlanef;
typedef struct {
    int index;
    ARGS_glGetClipPlanef args;
} PACKED_glGetClipPlanef;
typedef struct {
    GLenum plane;
    GLfloat * equation;
} ARGS_glGetClipPlanefOES;
typedef struct {
    int index;
    ARGS_glGetClipPlanefOES args;
} PACKED_glGetClipPlanefOES;
typedef struct {
    GLenum plane;
    GLfixed * equation;
} ARGS_glGetClipPlanex;
typedef struct {
    int index;
    ARGS_glGetClipPlanex args;
} PACKED_glGetClipPlanex;
typedef struct {
    GLenum plane;
    GLfixed * equation;
} ARGS_glGetClipPlanexOES;
typedef struct {
    int index;
    ARGS_glGetClipPlanexOES args;
} PACKED_glGetClipPlanexOES;
typedef struct {
    GLenum target;
    GLenum format;
    GLenum type;
    GLvoid * table;
} ARGS_glGetColorTable;
typedef struct {
    int index;
    ARGS_glGetColorTable args;
} PACKED_glGetColorTable;
typedef struct {
    GLenum target;
    GLenum format;
    GLenum type;
    GLvoid * data;
} ARGS_glGetColorTableEXT;
typedef struct {
    int index;
    ARGS_glGetColorTableEXT args;
} PACKED_glGetColorTableEXT;
typedef struct {
    GLenum target;
    GLenum pname;
    GLfloat * params;
} ARGS_glGetColorTableParameterfv;
typedef struct {
    int index;
    ARGS_glGetColorTableParameterfv args;
} PACKED_glGetColorTableParameterfv;
typedef struct {
    GLenum target;
    GLenum pname;
    GLfloat * params;
} ARGS_glGetColorTableParameterfvEXT;
typedef struct {
    int index;
    ARGS_glGetColorTableParameterfvEXT args;
} PACKED_glGetColorTableParameterfvEXT;
typedef struct {
    GLenum target;
    GLenum pname;
    GLfloat * params;
} ARGS_glGetColorTableParameterfvSGI;
typedef struct {
    int index;
    ARGS_glGetColorTableParameterfvSGI args;
} PACKED_glGetColorTableParameterfvSGI;
typedef struct {
    GLenum target;
    GLenum pname;
    GLint * params;
} ARGS_glGetColorTableParameteriv;
typedef struct {
    int index;
    ARGS_glGetColorTableParameteriv args;
} PACKED_glGetColorTableParameteriv;
typedef struct {
    GLenum target;
    GLenum pname;
    GLint * params;
} ARGS_glGetColorTableParameterivEXT;
typedef struct {
    int index;
    ARGS_glGetColorTableParameterivEXT args;
} PACKED_glGetColorTableParameterivEXT;
typedef struct {
    GLenum target;
    GLenum pname;
    GLint * params;
} ARGS_glGetColorTableParameterivSGI;
typedef struct {
    int index;
    ARGS_glGetColorTableParameterivSGI args;
} PACKED_glGetColorTableParameterivSGI;
typedef struct {
    GLenum target;
    GLenum format;
    GLenum type;
    GLvoid * table;
} ARGS_glGetColorTableSGI;
typedef struct {
    int index;
    ARGS_glGetColorTableSGI args;
} PACKED_glGetColorTableSGI;
typedef struct {
    GLenum stage;
    GLenum portion;
    GLenum variable;
    GLenum pname;
    GLfloat * params;
} ARGS_glGetCombinerInputParameterfvNV;
typedef struct {
    int index;
    ARGS_glGetCombinerInputParameterfvNV args;
} PACKED_glGetCombinerInputParameterfvNV;
typedef struct {
    GLenum stage;
    GLenum portion;
    GLenum variable;
    GLenum pname;
    GLint * params;
} ARGS_glGetCombinerInputParameterivNV;
typedef struct {
    int index;
    ARGS_glGetCombinerInputParameterivNV args;
} PACKED_glGetCombinerInputParameterivNV;
typedef struct {
    GLenum stage;
    GLenum portion;
    GLenum pname;
    GLfloat * params;
} ARGS_glGetCombinerOutputParameterfvNV;
typedef struct {
    int index;
    ARGS_glGetCombinerOutputParameterfvNV args;
} PACKED_glGetCombinerOutputParameterfvNV;
typedef struct {
    GLenum stage;
    GLenum portion;
    GLenum pname;
    GLint * params;
} ARGS_glGetCombinerOutputParameterivNV;
typedef struct {
    int index;
    ARGS_glGetCombinerOutputParameterivNV args;
} PACKED_glGetCombinerOutputParameterivNV;
typedef struct {
    GLenum stage;
    GLenum pname;
    GLfloat * params;
} ARGS_glGetCombinerStageParameterfvNV;
typedef struct {
    int index;
    ARGS_glGetCombinerStageParameterfvNV args;
} PACKED_glGetCombinerStageParameterfvNV;
typedef struct {
    GLenum texunit;
    GLenum target;
    GLint lod;
    GLvoid * img;
} ARGS_glGetCompressedMultiTexImageEXT;
typedef struct {
    int index;
    ARGS_glGetCompressedMultiTexImageEXT args;
} PACKED_glGetCompressedMultiTexImageEXT;
typedef struct {
    GLenum target;
    GLint level;
    GLvoid * img;
} ARGS_glGetCompressedTexImage;
typedef struct {
    int index;
    ARGS_glGetCompressedTexImage args;
} PACKED_glGetCompressedTexImage;
typedef struct {
    GLenum target;
    GLint level;
    GLvoid * img;
} ARGS_glGetCompressedTexImageARB;
typedef struct {
    int index;
    ARGS_glGetCompressedTexImageARB args;
} PACKED_glGetCompressedTexImageARB;
typedef struct {
    GLuint texture;
    GLenum target;
    GLint lod;
    GLvoid * img;
} ARGS_glGetCompressedTextureImageEXT;
typedef struct {
    int index;
    ARGS_glGetCompressedTextureImageEXT args;
} PACKED_glGetCompressedTextureImageEXT;
typedef struct {
    GLenum target;
    GLenum format;
    GLenum type;
    GLvoid * image;
} ARGS_glGetConvolutionFilter;
typedef struct {
    int index;
    ARGS_glGetConvolutionFilter args;
} PACKED_glGetConvolutionFilter;
typedef struct {
    GLenum target;
    GLenum format;
    GLenum type;
    GLvoid * image;
} ARGS_glGetConvolutionFilterEXT;
typedef struct {
    int index;
    ARGS_glGetConvolutionFilterEXT args;
} PACKED_glGetConvolutionFilterEXT;
typedef struct {
    GLenum target;
    GLenum pname;
    GLfloat * params;
} ARGS_glGetConvolutionParameterfv;
typedef struct {
    int index;
    ARGS_glGetConvolutionParameterfv args;
} PACKED_glGetConvolutionParameterfv;
typedef struct {
    GLenum target;
    GLenum pname;
    GLfloat * params;
} ARGS_glGetConvolutionParameterfvEXT;
typedef struct {
    int index;
    ARGS_glGetConvolutionParameterfvEXT args;
} PACKED_glGetConvolutionParameterfvEXT;
typedef struct {
    GLenum target;
    GLenum pname;
    GLint * params;
} ARGS_glGetConvolutionParameteriv;
typedef struct {
    int index;
    ARGS_glGetConvolutionParameteriv args;
} PACKED_glGetConvolutionParameteriv;
typedef struct {
    GLenum target;
    GLenum pname;
    GLint * params;
} ARGS_glGetConvolutionParameterivEXT;
typedef struct {
    int index;
    ARGS_glGetConvolutionParameterivEXT args;
} PACKED_glGetConvolutionParameterivEXT;
typedef struct {
    GLenum target;
    GLenum pname;
    GLfixed * params;
} ARGS_glGetConvolutionParameterxvOES;
typedef struct {
    int index;
    ARGS_glGetConvolutionParameterxvOES args;
} PACKED_glGetConvolutionParameterxvOES;
typedef struct {
    GLuint count;
    GLsizei bufsize;
    GLenum * sources;
    GLenum * types;
    GLuint * ids;
    GLenum * severities;
    GLsizei * lengths;
    GLchar * messageLog;
} ARGS_glGetDebugMessageLog;
typedef struct {
    int index;
    ARGS_glGetDebugMessageLog args;
} PACKED_glGetDebugMessageLog;
typedef struct {
    GLuint count;
    GLsizei bufsize;
    GLenum * categories;
    GLuint * severities;
    GLuint * ids;
    GLsizei * lengths;
    GLchar * message;
} ARGS_glGetDebugMessageLogAMD;
typedef struct {
    int index;
    ARGS_glGetDebugMessageLogAMD args;
} PACKED_glGetDebugMessageLogAMD;
typedef struct {
    GLuint count;
    GLsizei bufsize;
    GLenum * sources;
    GLenum * types;
    GLuint * ids;
    GLenum * severities;
    GLsizei * lengths;
    GLchar * messageLog;
} ARGS_glGetDebugMessageLogARB;
typedef struct {
    int index;
    ARGS_glGetDebugMessageLogARB args;
} PACKED_glGetDebugMessageLogARB;
typedef struct {
    GLenum target;
    GLfloat * points;
} ARGS_glGetDetailTexFuncSGIS;
typedef struct {
    int index;
    ARGS_glGetDetailTexFuncSGIS args;
} PACKED_glGetDetailTexFuncSGIS;
typedef struct {
    GLenum target;
    GLuint index;
    GLdouble * data;
} ARGS_glGetDoubleIndexedvEXT;
typedef struct {
    int index;
    ARGS_glGetDoubleIndexedvEXT args;
} PACKED_glGetDoubleIndexedvEXT;
typedef struct {
    GLenum target;
    GLuint index;
    GLdouble * data;
} ARGS_glGetDoublei_v;
typedef struct {
    int index;
    ARGS_glGetDoublei_v args;
} PACKED_glGetDoublei_v;
typedef struct {
    GLenum target;
    GLuint index;
    GLdouble * data;
} ARGS_glGetDoublei_vEXT;
typedef struct {
    int index;
    ARGS_glGetDoublei_vEXT args;
} PACKED_glGetDoublei_vEXT;
typedef struct {
    GLenum pname;
    GLdouble * params;
} ARGS_glGetDoublev;
typedef struct {
    int index;
    ARGS_glGetDoublev args;
} PACKED_glGetDoublev;
typedef struct {
    int index;
} PACKED_glGetError;
typedef struct {
    GLuint fence;
    GLenum pname;
    GLint * params;
} ARGS_glGetFenceivNV;
typedef struct {
    int index;
    ARGS_glGetFenceivNV args;
} PACKED_glGetFenceivNV;
typedef struct {
    GLenum variable;
    GLenum pname;
    GLfloat * params;
} ARGS_glGetFinalCombinerInputParameterfvNV;
typedef struct {
    int index;
    ARGS_glGetFinalCombinerInputParameterfvNV args;
} PACKED_glGetFinalCombinerInputParameterfvNV;
typedef struct {
    GLenum variable;
    GLenum pname;
    GLint * params;
} ARGS_glGetFinalCombinerInputParameterivNV;
typedef struct {
    int index;
    ARGS_glGetFinalCombinerInputParameterivNV args;
} PACKED_glGetFinalCombinerInputParameterivNV;
typedef struct {
    GLenum pname;
    GLfixed * params;
} ARGS_glGetFixedv;
typedef struct {
    int index;
    ARGS_glGetFixedv args;
} PACKED_glGetFixedv;
typedef struct {
    GLenum pname;
    GLfixed * params;
} ARGS_glGetFixedvOES;
typedef struct {
    int index;
    ARGS_glGetFixedvOES args;
} PACKED_glGetFixedvOES;
typedef struct {
    GLenum target;
    GLuint index;
    GLfloat * data;
} ARGS_glGetFloatIndexedvEXT;
typedef struct {
    int index;
    ARGS_glGetFloatIndexedvEXT args;
} PACKED_glGetFloatIndexedvEXT;
typedef struct {
    GLenum target;
    GLuint index;
    GLfloat * data;
} ARGS_glGetFloati_v;
typedef struct {
    int index;
    ARGS_glGetFloati_v args;
} PACKED_glGetFloati_v;
typedef struct {
    GLenum target;
    GLuint index;
    GLfloat * data;
} ARGS_glGetFloati_vEXT;
typedef struct {
    int index;
    ARGS_glGetFloati_vEXT args;
} PACKED_glGetFloati_vEXT;
typedef struct {
    GLenum pname;
    GLfloat * params;
} ARGS_glGetFloatv;
typedef struct {
    int index;
    ARGS_glGetFloatv args;
} PACKED_glGetFloatv;
typedef struct {
    GLfloat * points;
} ARGS_glGetFogFuncSGIS;
typedef struct {
    int index;
    ARGS_glGetFogFuncSGIS args;
} PACKED_glGetFogFuncSGIS;
typedef struct {
    GLuint program;
    GLchar * name;
} ARGS_glGetFragDataIndex;
typedef struct {
    int index;
    ARGS_glGetFragDataIndex args;
} PACKED_glGetFragDataIndex;
typedef struct {
    GLuint program;
    GLchar * name;
} ARGS_glGetFragDataLocation;
typedef struct {
    int index;
    ARGS_glGetFragDataLocation args;
} PACKED_glGetFragDataLocation;
typedef struct {
    GLuint program;
    GLchar * name;
} ARGS_glGetFragDataLocationEXT;
typedef struct {
    int index;
    ARGS_glGetFragDataLocationEXT args;
} PACKED_glGetFragDataLocationEXT;
typedef struct {
    GLenum light;
    GLenum pname;
    GLfloat * params;
} ARGS_glGetFragmentLightfvSGIX;
typedef struct {
    int index;
    ARGS_glGetFragmentLightfvSGIX args;
} PACKED_glGetFragmentLightfvSGIX;
typedef struct {
    GLenum light;
    GLenum pname;
    GLint * params;
} ARGS_glGetFragmentLightivSGIX;
typedef struct {
    int index;
    ARGS_glGetFragmentLightivSGIX args;
} PACKED_glGetFragmentLightivSGIX;
typedef struct {
    GLenum face;
    GLenum pname;
    GLfloat * params;
} ARGS_glGetFragmentMaterialfvSGIX;
typedef struct {
    int index;
    ARGS_glGetFragmentMaterialfvSGIX args;
} PACKED_glGetFragmentMaterialfvSGIX;
typedef struct {
    GLenum face;
    GLenum pname;
    GLint * params;
} ARGS_glGetFragmentMaterialivSGIX;
typedef struct {
    int index;
    ARGS_glGetFragmentMaterialivSGIX args;
} PACKED_glGetFragmentMaterialivSGIX;
typedef struct {
    GLenum target;
    GLenum attachment;
    GLenum pname;
    GLint * params;
} ARGS_glGetFramebufferAttachmentParameteriv;
typedef struct {
    int index;
    ARGS_glGetFramebufferAttachmentParameteriv args;
} PACKED_glGetFramebufferAttachmentParameteriv;
typedef struct {
    GLenum target;
    GLenum attachment;
    GLenum pname;
    GLint * params;
} ARGS_glGetFramebufferAttachmentParameterivEXT;
typedef struct {
    int index;
    ARGS_glGetFramebufferAttachmentParameterivEXT args;
} PACKED_glGetFramebufferAttachmentParameterivEXT;
typedef struct {
    GLenum target;
    GLenum pname;
    GLint * params;
} ARGS_glGetFramebufferParameteriv;
typedef struct {
    int index;
    ARGS_glGetFramebufferParameteriv args;
} PACKED_glGetFramebufferParameteriv;
typedef struct {
    GLuint framebuffer;
    GLenum pname;
    GLint * params;
} ARGS_glGetFramebufferParameterivEXT;
typedef struct {
    int index;
    ARGS_glGetFramebufferParameterivEXT args;
} PACKED_glGetFramebufferParameterivEXT;
typedef struct {
    int index;
} PACKED_glGetGraphicsResetStatusARB;
typedef struct {
    GLenum pname;
} ARGS_glGetHandleARB;
typedef struct {
    int index;
    ARGS_glGetHandleARB args;
} PACKED_glGetHandleARB;
typedef struct {
    GLenum target;
    GLboolean reset;
    GLenum format;
    GLenum type;
    GLvoid * values;
} ARGS_glGetHistogram;
typedef struct {
    int index;
    ARGS_glGetHistogram args;
} PACKED_glGetHistogram;
typedef struct {
    GLenum target;
    GLboolean reset;
    GLenum format;
    GLenum type;
    GLvoid * values;
} ARGS_glGetHistogramEXT;
typedef struct {
    int index;
    ARGS_glGetHistogramEXT args;
} PACKED_glGetHistogramEXT;
typedef struct {
    GLenum target;
    GLenum pname;
    GLfloat * params;
} ARGS_glGetHistogramParameterfv;
typedef struct {
    int index;
    ARGS_glGetHistogramParameterfv args;
} PACKED_glGetHistogramParameterfv;
typedef struct {
    GLenum target;
    GLenum pname;
    GLfloat * params;
} ARGS_glGetHistogramParameterfvEXT;
typedef struct {
    int index;
    ARGS_glGetHistogramParameterfvEXT args;
} PACKED_glGetHistogramParameterfvEXT;
typedef struct {
    GLenum target;
    GLenum pname;
    GLint * params;
} ARGS_glGetHistogramParameteriv;
typedef struct {
    int index;
    ARGS_glGetHistogramParameteriv args;
} PACKED_glGetHistogramParameteriv;
typedef struct {
    GLenum target;
    GLenum pname;
    GLint * params;
} ARGS_glGetHistogramParameterivEXT;
typedef struct {
    int index;
    ARGS_glGetHistogramParameterivEXT args;
} PACKED_glGetHistogramParameterivEXT;
typedef struct {
    GLenum target;
    GLenum pname;
    GLfixed * params;
} ARGS_glGetHistogramParameterxvOES;
typedef struct {
    int index;
    ARGS_glGetHistogramParameterxvOES args;
} PACKED_glGetHistogramParameterxvOES;
typedef struct {
    GLuint texture;
    GLint level;
    GLboolean layered;
    GLint layer;
    GLenum format;
} ARGS_glGetImageHandleNV;
typedef struct {
    int index;
    ARGS_glGetImageHandleNV args;
} PACKED_glGetImageHandleNV;
typedef struct {
    GLenum target;
    GLenum pname;
    GLfloat * params;
} ARGS_glGetImageTransformParameterfvHP;
typedef struct {
    int index;
    ARGS_glGetImageTransformParameterfvHP args;
} PACKED_glGetImageTransformParameterfvHP;
typedef struct {
    GLenum target;
    GLenum pname;
    GLint * params;
} ARGS_glGetImageTransformParameterivHP;
typedef struct {
    int index;
    ARGS_glGetImageTransformParameterivHP args;
} PACKED_glGetImageTransformParameterivHP;
typedef struct {
    GLhandleARB obj;
    GLsizei maxLength;
    GLsizei * length;
    GLcharARB * infoLog;
} ARGS_glGetInfoLogARB;
typedef struct {
    int index;
    ARGS_glGetInfoLogARB args;
} PACKED_glGetInfoLogARB;
typedef struct {
    int index;
} PACKED_glGetInstrumentsSGIX;
typedef struct {
    GLenum target;
    GLuint index;
    GLint64 * data;
} ARGS_glGetInteger64i_v;
typedef struct {
    int index;
    ARGS_glGetInteger64i_v args;
} PACKED_glGetInteger64i_v;
typedef struct {
    GLenum pname;
    GLint64 * params;
} ARGS_glGetInteger64v;
typedef struct {
    int index;
    ARGS_glGetInteger64v args;
} PACKED_glGetInteger64v;
typedef struct {
    GLenum target;
    GLuint index;
    GLint * data;
} ARGS_glGetIntegerIndexedvEXT;
typedef struct {
    int index;
    ARGS_glGetIntegerIndexedvEXT args;
} PACKED_glGetIntegerIndexedvEXT;
typedef struct {
    GLenum target;
    GLuint index;
    GLint * data;
} ARGS_glGetIntegeri_v;
typedef struct {
    int index;
    ARGS_glGetIntegeri_v args;
} PACKED_glGetIntegeri_v;
typedef struct {
    GLenum value;
    GLuint index;
    GLuint64EXT * result;
} ARGS_glGetIntegerui64i_vNV;
typedef struct {
    int index;
    ARGS_glGetIntegerui64i_vNV args;
} PACKED_glGetIntegerui64i_vNV;
typedef struct {
    GLenum value;
    GLuint64EXT * result;
} ARGS_glGetIntegerui64vNV;
typedef struct {
    int index;
    ARGS_glGetIntegerui64vNV args;
} PACKED_glGetIntegerui64vNV;
typedef struct {
    GLenum pname;
    GLint * params;
} ARGS_glGetIntegerv;
typedef struct {
    int index;
    ARGS_glGetIntegerv args;
} PACKED_glGetIntegerv;
typedef struct {
    GLenum target;
    GLenum internalformat;
    GLenum pname;
    GLsizei bufSize;
    GLint64 * params;
} ARGS_glGetInternalformati64v;
typedef struct {
    int index;
    ARGS_glGetInternalformati64v args;
} PACKED_glGetInternalformati64v;
typedef struct {
    GLenum target;
    GLenum internalformat;
    GLenum pname;
    GLsizei bufSize;
    GLint * params;
} ARGS_glGetInternalformativ;
typedef struct {
    int index;
    ARGS_glGetInternalformativ args;
} PACKED_glGetInternalformativ;
typedef struct {
    GLuint id;
    GLenum value;
    GLboolean * data;
} ARGS_glGetInvariantBooleanvEXT;
typedef struct {
    int index;
    ARGS_glGetInvariantBooleanvEXT args;
} PACKED_glGetInvariantBooleanvEXT;
typedef struct {
    GLuint id;
    GLenum value;
    GLfloat * data;
} ARGS_glGetInvariantFloatvEXT;
typedef struct {
    int index;
    ARGS_glGetInvariantFloatvEXT args;
} PACKED_glGetInvariantFloatvEXT;
typedef struct {
    GLuint id;
    GLenum value;
    GLint * data;
} ARGS_glGetInvariantIntegervEXT;
typedef struct {
    int index;
    ARGS_glGetInvariantIntegervEXT args;
} PACKED_glGetInvariantIntegervEXT;
typedef struct {
    GLenum light;
    GLenum pname;
    GLfloat * params;
} ARGS_glGetLightfv;
typedef struct {
    int index;
    ARGS_glGetLightfv args;
} PACKED_glGetLightfv;
typedef struct {
    GLenum light;
    GLenum pname;
    GLint * params;
} ARGS_glGetLightiv;
typedef struct {
    int index;
    ARGS_glGetLightiv args;
} PACKED_glGetLightiv;
typedef struct {
    GLenum light;
    GLenum pname;
    GLfixed * params;
} ARGS_glGetLightxOES;
typedef struct {
    int index;
    ARGS_glGetLightxOES args;
} PACKED_glGetLightxOES;
typedef struct {
    GLenum light;
    GLenum pname;
    GLfixed * params;
} ARGS_glGetLightxv;
typedef struct {
    int index;
    ARGS_glGetLightxv args;
} PACKED_glGetLightxv;
typedef struct {
    GLuint list;
    GLenum pname;
    GLfloat * params;
} ARGS_glGetListParameterfvSGIX;
typedef struct {
    int index;
    ARGS_glGetListParameterfvSGIX args;
} PACKED_glGetListParameterfvSGIX;
typedef struct {
    GLuint list;
    GLenum pname;
    GLint * params;
} ARGS_glGetListParameterivSGIX;
typedef struct {
    int index;
    ARGS_glGetListParameterivSGIX args;
} PACKED_glGetListParameterivSGIX;
typedef struct {
    GLuint id;
    GLenum value;
    GLboolean * data;
} ARGS_glGetLocalConstantBooleanvEXT;
typedef struct {
    int index;
    ARGS_glGetLocalConstantBooleanvEXT args;
} PACKED_glGetLocalConstantBooleanvEXT;
typedef struct {
    GLuint id;
    GLenum value;
    GLfloat * data;
} ARGS_glGetLocalConstantFloatvEXT;
typedef struct {
    int index;
    ARGS_glGetLocalConstantFloatvEXT args;
} PACKED_glGetLocalConstantFloatvEXT;
typedef struct {
    GLuint id;
    GLenum value;
    GLint * data;
} ARGS_glGetLocalConstantIntegervEXT;
typedef struct {
    int index;
    ARGS_glGetLocalConstantIntegervEXT args;
} PACKED_glGetLocalConstantIntegervEXT;
typedef struct {
    GLenum target;
    GLuint index;
    GLenum pname;
    GLfloat * params;
} ARGS_glGetMapAttribParameterfvNV;
typedef struct {
    int index;
    ARGS_glGetMapAttribParameterfvNV args;
} PACKED_glGetMapAttribParameterfvNV;
typedef struct {
    GLenum target;
    GLuint index;
    GLenum pname;
    GLint * params;
} ARGS_glGetMapAttribParameterivNV;
typedef struct {
    int index;
    ARGS_glGetMapAttribParameterivNV args;
} PACKED_glGetMapAttribParameterivNV;
typedef struct {
    GLenum target;
    GLuint index;
    GLenum type;
    GLsizei ustride;
    GLsizei vstride;
    GLboolean packed;
    GLvoid * points;
} ARGS_glGetMapControlPointsNV;
typedef struct {
    int index;
    ARGS_glGetMapControlPointsNV args;
} PACKED_glGetMapControlPointsNV;
typedef struct {
    GLenum target;
    GLenum pname;
    GLfloat * params;
} ARGS_glGetMapParameterfvNV;
typedef struct {
    int index;
    ARGS_glGetMapParameterfvNV args;
} PACKED_glGetMapParameterfvNV;
typedef struct {
    GLenum target;
    GLenum pname;
    GLint * params;
} ARGS_glGetMapParameterivNV;
typedef struct {
    int index;
    ARGS_glGetMapParameterivNV args;
} PACKED_glGetMapParameterivNV;
typedef struct {
    GLenum target;
    GLenum query;
    GLdouble * v;
} ARGS_glGetMapdv;
typedef struct {
    int index;
    ARGS_glGetMapdv args;
} PACKED_glGetMapdv;
typedef struct {
    GLenum target;
    GLenum query;
    GLfloat * v;
} ARGS_glGetMapfv;
typedef struct {
    int index;
    ARGS_glGetMapfv args;
} PACKED_glGetMapfv;
typedef struct {
    GLenum target;
    GLenum query;
    GLint * v;
} ARGS_glGetMapiv;
typedef struct {
    int index;
    ARGS_glGetMapiv args;
} PACKED_glGetMapiv;
typedef struct {
    GLenum target;
    GLenum query;
    GLfixed * v;
} ARGS_glGetMapxvOES;
typedef struct {
    int index;
    ARGS_glGetMapxvOES args;
} PACKED_glGetMapxvOES;
typedef struct {
    GLenum face;
    GLenum pname;
    GLfloat * params;
} ARGS_glGetMaterialfv;
typedef struct {
    int index;
    ARGS_glGetMaterialfv args;
} PACKED_glGetMaterialfv;
typedef struct {
    GLenum face;
    GLenum pname;
    GLint * params;
} ARGS_glGetMaterialiv;
typedef struct {
    int index;
    ARGS_glGetMaterialiv args;
} PACKED_glGetMaterialiv;
typedef struct {
    GLenum face;
    GLenum pname;
    GLfixed param;
} ARGS_glGetMaterialxOES;
typedef struct {
    int index;
    ARGS_glGetMaterialxOES args;
} PACKED_glGetMaterialxOES;
typedef struct {
    GLenum face;
    GLenum pname;
    GLfixed * params;
} ARGS_glGetMaterialxv;
typedef struct {
    int index;
    ARGS_glGetMaterialxv args;
} PACKED_glGetMaterialxv;
typedef struct {
    GLenum target;
    GLboolean reset;
    GLenum format;
    GLenum type;
    GLvoid * values;
} ARGS_glGetMinmax;
typedef struct {
    int index;
    ARGS_glGetMinmax args;
} PACKED_glGetMinmax;
typedef struct {
    GLenum target;
    GLboolean reset;
    GLenum format;
    GLenum type;
    GLvoid * values;
} ARGS_glGetMinmaxEXT;
typedef struct {
    int index;
    ARGS_glGetMinmaxEXT args;
} PACKED_glGetMinmaxEXT;
typedef struct {
    GLenum target;
    GLenum pname;
    GLfloat * params;
} ARGS_glGetMinmaxParameterfv;
typedef struct {
    int index;
    ARGS_glGetMinmaxParameterfv args;
} PACKED_glGetMinmaxParameterfv;
typedef struct {
    GLenum target;
    GLenum pname;
    GLfloat * params;
} ARGS_glGetMinmaxParameterfvEXT;
typedef struct {
    int index;
    ARGS_glGetMinmaxParameterfvEXT args;
} PACKED_glGetMinmaxParameterfvEXT;
typedef struct {
    GLenum target;
    GLenum pname;
    GLint * params;
} ARGS_glGetMinmaxParameteriv;
typedef struct {
    int index;
    ARGS_glGetMinmaxParameteriv args;
} PACKED_glGetMinmaxParameteriv;
typedef struct {
    GLenum target;
    GLenum pname;
    GLint * params;
} ARGS_glGetMinmaxParameterivEXT;
typedef struct {
    int index;
    ARGS_glGetMinmaxParameterivEXT args;
} PACKED_glGetMinmaxParameterivEXT;
typedef struct {
    GLenum texunit;
    GLenum target;
    GLenum pname;
    GLfloat * params;
} ARGS_glGetMultiTexEnvfvEXT;
typedef struct {
    int index;
    ARGS_glGetMultiTexEnvfvEXT args;
} PACKED_glGetMultiTexEnvfvEXT;
typedef struct {
    GLenum texunit;
    GLenum target;
    GLenum pname;
    GLint * params;
} ARGS_glGetMultiTexEnvivEXT;
typedef struct {
    int index;
    ARGS_glGetMultiTexEnvivEXT args;
} PACKED_glGetMultiTexEnvivEXT;
typedef struct {
    GLenum texunit;
    GLenum coord;
    GLenum pname;
    GLdouble * params;
} ARGS_glGetMultiTexGendvEXT;
typedef struct {
    int index;
    ARGS_glGetMultiTexGendvEXT args;
} PACKED_glGetMultiTexGendvEXT;
typedef struct {
    GLenum texunit;
    GLenum coord;
    GLenum pname;
    GLfloat * params;
} ARGS_glGetMultiTexGenfvEXT;
typedef struct {
    int index;
    ARGS_glGetMultiTexGenfvEXT args;
} PACKED_glGetMultiTexGenfvEXT;
typedef struct {
    GLenum texunit;
    GLenum coord;
    GLenum pname;
    GLint * params;
} ARGS_glGetMultiTexGenivEXT;
typedef struct {
    int index;
    ARGS_glGetMultiTexGenivEXT args;
} PACKED_glGetMultiTexGenivEXT;
typedef struct {
    GLenum texunit;
    GLenum target;
    GLint level;
    GLenum format;
    GLenum type;
    GLvoid * pixels;
} ARGS_glGetMultiTexImageEXT;
typedef struct {
    int index;
    ARGS_glGetMultiTexImageEXT args;
} PACKED_glGetMultiTexImageEXT;
typedef struct {
    GLenum texunit;
    GLenum target;
    GLint level;
    GLenum pname;
    GLfloat * params;
} ARGS_glGetMultiTexLevelParameterfvEXT;
typedef struct {
    int index;
    ARGS_glGetMultiTexLevelParameterfvEXT args;
} PACKED_glGetMultiTexLevelParameterfvEXT;
typedef struct {
    GLenum texunit;
    GLenum target;
    GLint level;
    GLenum pname;
    GLint * params;
} ARGS_glGetMultiTexLevelParameterivEXT;
typedef struct {
    int index;
    ARGS_glGetMultiTexLevelParameterivEXT args;
} PACKED_glGetMultiTexLevelParameterivEXT;
typedef struct {
    GLenum texunit;
    GLenum target;
    GLenum pname;
    GLint * params;
} ARGS_glGetMultiTexParameterIivEXT;
typedef struct {
    int index;
    ARGS_glGetMultiTexParameterIivEXT args;
} PACKED_glGetMultiTexParameterIivEXT;
typedef struct {
    GLenum texunit;
    GLenum target;
    GLenum pname;
    GLuint * params;
} ARGS_glGetMultiTexParameterIuivEXT;
typedef struct {
    int index;
    ARGS_glGetMultiTexParameterIuivEXT args;
} PACKED_glGetMultiTexParameterIuivEXT;
typedef struct {
    GLenum texunit;
    GLenum target;
    GLenum pname;
    GLfloat * params;
} ARGS_glGetMultiTexParameterfvEXT;
typedef struct {
    int index;
    ARGS_glGetMultiTexParameterfvEXT args;
} PACKED_glGetMultiTexParameterfvEXT;
typedef struct {
    GLenum texunit;
    GLenum target;
    GLenum pname;
    GLint * params;
} ARGS_glGetMultiTexParameterivEXT;
typedef struct {
    int index;
    ARGS_glGetMultiTexParameterivEXT args;
} PACKED_glGetMultiTexParameterivEXT;
typedef struct {
    GLenum pname;
    GLuint index;
    GLfloat * val;
} ARGS_glGetMultisamplefv;
typedef struct {
    int index;
    ARGS_glGetMultisamplefv args;
} PACKED_glGetMultisamplefv;
typedef struct {
    GLenum pname;
    GLuint index;
    GLfloat * val;
} ARGS_glGetMultisamplefvNV;
typedef struct {
    int index;
    ARGS_glGetMultisamplefvNV args;
} PACKED_glGetMultisamplefvNV;
typedef struct {
    GLuint buffer;
    GLenum pname;
    GLint * params;
} ARGS_glGetNamedBufferParameterivEXT;
typedef struct {
    int index;
    ARGS_glGetNamedBufferParameterivEXT args;
} PACKED_glGetNamedBufferParameterivEXT;
typedef struct {
    GLuint buffer;
    GLenum pname;
    GLuint64EXT * params;
} ARGS_glGetNamedBufferParameterui64vNV;
typedef struct {
    int index;
    ARGS_glGetNamedBufferParameterui64vNV args;
} PACKED_glGetNamedBufferParameterui64vNV;
typedef struct {
    GLuint buffer;
    GLenum pname;
    GLvoid * params;
} ARGS_glGetNamedBufferPointervEXT;
typedef struct {
    int index;
    ARGS_glGetNamedBufferPointervEXT args;
} PACKED_glGetNamedBufferPointervEXT;
typedef struct {
    GLuint buffer;
    GLintptr offset;
    GLsizeiptr size;
    GLvoid * data;
} ARGS_glGetNamedBufferSubDataEXT;
typedef struct {
    int index;
    ARGS_glGetNamedBufferSubDataEXT args;
} PACKED_glGetNamedBufferSubDataEXT;
typedef struct {
    GLuint framebuffer;
    GLenum attachment;
    GLenum pname;
    GLint * params;
} ARGS_glGetNamedFramebufferAttachmentParameterivEXT;
typedef struct {
    int index;
    ARGS_glGetNamedFramebufferAttachmentParameterivEXT args;
} PACKED_glGetNamedFramebufferAttachmentParameterivEXT;
typedef struct {
    GLuint framebuffer;
    GLenum pname;
    GLint * params;
} ARGS_glGetNamedFramebufferParameterivEXT;
typedef struct {
    int index;
    ARGS_glGetNamedFramebufferParameterivEXT args;
} PACKED_glGetNamedFramebufferParameterivEXT;
typedef struct {
    GLuint program;
    GLenum target;
    GLuint index;
    GLint * params;
} ARGS_glGetNamedProgramLocalParameterIivEXT;
typedef struct {
    int index;
    ARGS_glGetNamedProgramLocalParameterIivEXT args;
} PACKED_glGetNamedProgramLocalParameterIivEXT;
typedef struct {
    GLuint program;
    GLenum target;
    GLuint index;
    GLuint * params;
} ARGS_glGetNamedProgramLocalParameterIuivEXT;
typedef struct {
    int index;
    ARGS_glGetNamedProgramLocalParameterIuivEXT args;
} PACKED_glGetNamedProgramLocalParameterIuivEXT;
typedef struct {
    GLuint program;
    GLenum target;
    GLuint index;
    GLdouble * params;
} ARGS_glGetNamedProgramLocalParameterdvEXT;
typedef struct {
    int index;
    ARGS_glGetNamedProgramLocalParameterdvEXT args;
} PACKED_glGetNamedProgramLocalParameterdvEXT;
typedef struct {
    GLuint program;
    GLenum target;
    GLuint index;
    GLfloat * params;
} ARGS_glGetNamedProgramLocalParameterfvEXT;
typedef struct {
    int index;
    ARGS_glGetNamedProgramLocalParameterfvEXT args;
} PACKED_glGetNamedProgramLocalParameterfvEXT;
typedef struct {
    GLuint program;
    GLenum target;
    GLenum pname;
    GLvoid * string;
} ARGS_glGetNamedProgramStringEXT;
typedef struct {
    int index;
    ARGS_glGetNamedProgramStringEXT args;
} PACKED_glGetNamedProgramStringEXT;
typedef struct {
    GLuint program;
    GLenum target;
    GLenum pname;
    GLint * params;
} ARGS_glGetNamedProgramivEXT;
typedef struct {
    int index;
    ARGS_glGetNamedProgramivEXT args;
} PACKED_glGetNamedProgramivEXT;
typedef struct {
    GLuint renderbuffer;
    GLenum pname;
    GLint * params;
} ARGS_glGetNamedRenderbufferParameterivEXT;
typedef struct {
    int index;
    ARGS_glGetNamedRenderbufferParameterivEXT args;
} PACKED_glGetNamedRenderbufferParameterivEXT;
typedef struct {
    GLint namelen;
    GLchar * name;
    GLsizei bufSize;
    GLint * stringlen;
    GLchar * string;
} ARGS_glGetNamedStringARB;
typedef struct {
    int index;
    ARGS_glGetNamedStringARB args;
} PACKED_glGetNamedStringARB;
typedef struct {
    GLint namelen;
    GLchar * name;
    GLenum pname;
    GLint * params;
} ARGS_glGetNamedStringivARB;
typedef struct {
    int index;
    ARGS_glGetNamedStringivARB args;
} PACKED_glGetNamedStringivARB;
typedef struct {
    GLuint buffer;
    GLenum pname;
    GLfloat * params;
} ARGS_glGetObjectBufferfvATI;
typedef struct {
    int index;
    ARGS_glGetObjectBufferfvATI args;
} PACKED_glGetObjectBufferfvATI;
typedef struct {
    GLuint buffer;
    GLenum pname;
    GLint * params;
} ARGS_glGetObjectBufferivATI;
typedef struct {
    int index;
    ARGS_glGetObjectBufferivATI args;
} PACKED_glGetObjectBufferivATI;
typedef struct {
    GLenum identifier;
    GLuint name;
    GLsizei bufSize;
    GLsizei * length;
    GLchar * label;
} ARGS_glGetObjectLabel;
typedef struct {
    int index;
    ARGS_glGetObjectLabel args;
} PACKED_glGetObjectLabel;
typedef struct {
    GLhandleARB obj;
    GLenum pname;
    GLfloat * params;
} ARGS_glGetObjectParameterfvARB;
typedef struct {
    int index;
    ARGS_glGetObjectParameterfvARB args;
} PACKED_glGetObjectParameterfvARB;
typedef struct {
    GLenum objectType;
    GLuint name;
    GLenum pname;
    GLint * params;
} ARGS_glGetObjectParameterivAPPLE;
typedef struct {
    int index;
    ARGS_glGetObjectParameterivAPPLE args;
} PACKED_glGetObjectParameterivAPPLE;
typedef struct {
    GLhandleARB obj;
    GLenum pname;
    GLint * params;
} ARGS_glGetObjectParameterivARB;
typedef struct {
    int index;
    ARGS_glGetObjectParameterivARB args;
} PACKED_glGetObjectParameterivARB;
typedef struct {
    void * ptr;
    GLsizei bufSize;
    GLsizei * length;
    GLchar * label;
} ARGS_glGetObjectPtrLabel;
typedef struct {
    int index;
    ARGS_glGetObjectPtrLabel args;
} PACKED_glGetObjectPtrLabel;
typedef struct {
    GLuint id;
    GLenum pname;
    GLint * params;
} ARGS_glGetOcclusionQueryivNV;
typedef struct {
    int index;
    ARGS_glGetOcclusionQueryivNV args;
} PACKED_glGetOcclusionQueryivNV;
typedef struct {
    GLuint id;
    GLenum pname;
    GLuint * params;
} ARGS_glGetOcclusionQueryuivNV;
typedef struct {
    int index;
    ARGS_glGetOcclusionQueryuivNV args;
} PACKED_glGetOcclusionQueryuivNV;
typedef struct {
    GLenum color;
    GLenum pname;
    GLfloat * value;
} ARGS_glGetPathColorGenfvNV;
typedef struct {
    int index;
    ARGS_glGetPathColorGenfvNV args;
} PACKED_glGetPathColorGenfvNV;
typedef struct {
    GLenum color;
    GLenum pname;
    GLint * value;
} ARGS_glGetPathColorGenivNV;
typedef struct {
    int index;
    ARGS_glGetPathColorGenivNV args;
} PACKED_glGetPathColorGenivNV;
typedef struct {
    GLuint path;
    GLubyte * commands;
} ARGS_glGetPathCommandsNV;
typedef struct {
    int index;
    ARGS_glGetPathCommandsNV args;
} PACKED_glGetPathCommandsNV;
typedef struct {
    GLuint path;
    GLfloat * coords;
} ARGS_glGetPathCoordsNV;
typedef struct {
    int index;
    ARGS_glGetPathCoordsNV args;
} PACKED_glGetPathCoordsNV;
typedef struct {
    GLuint path;
    GLfloat * dashArray;
} ARGS_glGetPathDashArrayNV;
typedef struct {
    int index;
    ARGS_glGetPathDashArrayNV args;
} PACKED_glGetPathDashArrayNV;
typedef struct {
    GLuint path;
    GLsizei startSegment;
    GLsizei numSegments;
} ARGS_glGetPathLengthNV;
typedef struct {
    int index;
    ARGS_glGetPathLengthNV args;
} PACKED_glGetPathLengthNV;
typedef struct {
    GLbitfield metricQueryMask;
    GLuint firstPathName;
    GLsizei numPaths;
    GLsizei stride;
    GLfloat * metrics;
} ARGS_glGetPathMetricRangeNV;
typedef struct {
    int index;
    ARGS_glGetPathMetricRangeNV args;
} PACKED_glGetPathMetricRangeNV;
typedef struct {
    GLbitfield metricQueryMask;
    GLsizei numPaths;
    GLenum pathNameType;
    GLvoid * paths;
    GLuint pathBase;
    GLsizei stride;
    GLfloat * metrics;
} ARGS_glGetPathMetricsNV;
typedef struct {
    int index;
    ARGS_glGetPathMetricsNV args;
} PACKED_glGetPathMetricsNV;
typedef struct {
    GLuint path;
    GLenum pname;
    GLfloat * value;
} ARGS_glGetPathParameterfvNV;
typedef struct {
    int index;
    ARGS_glGetPathParameterfvNV args;
} PACKED_glGetPathParameterfvNV;
typedef struct {
    GLuint path;
    GLenum pname;
    GLint * value;
} ARGS_glGetPathParameterivNV;
typedef struct {
    int index;
    ARGS_glGetPathParameterivNV args;
} PACKED_glGetPathParameterivNV;
typedef struct {
    GLenum pathListMode;
    GLsizei numPaths;
    GLenum pathNameType;
    GLvoid * paths;
    GLuint pathBase;
    GLfloat advanceScale;
    GLfloat kerningScale;
    GLenum transformType;
    GLfloat * returnedSpacing;
} ARGS_glGetPathSpacingNV;
typedef struct {
    int index;
    ARGS_glGetPathSpacingNV args;
} PACKED_glGetPathSpacingNV;
typedef struct {
    GLenum texCoordSet;
    GLenum pname;
    GLfloat * value;
} ARGS_glGetPathTexGenfvNV;
typedef struct {
    int index;
    ARGS_glGetPathTexGenfvNV args;
} PACKED_glGetPathTexGenfvNV;
typedef struct {
    GLenum texCoordSet;
    GLenum pname;
    GLint * value;
} ARGS_glGetPathTexGenivNV;
typedef struct {
    int index;
    ARGS_glGetPathTexGenivNV args;
} PACKED_glGetPathTexGenivNV;
typedef struct {
    GLuint monitor;
    GLenum pname;
    GLsizei dataSize;
    GLuint * data;
    GLint * bytesWritten;
} ARGS_glGetPerfMonitorCounterDataAMD;
typedef struct {
    int index;
    ARGS_glGetPerfMonitorCounterDataAMD args;
} PACKED_glGetPerfMonitorCounterDataAMD;
typedef struct {
    GLuint group;
    GLuint counter;
    GLenum pname;
    GLvoid * data;
} ARGS_glGetPerfMonitorCounterInfoAMD;
typedef struct {
    int index;
    ARGS_glGetPerfMonitorCounterInfoAMD args;
} PACKED_glGetPerfMonitorCounterInfoAMD;
typedef struct {
    GLuint group;
    GLuint counter;
    GLsizei bufSize;
    GLsizei * length;
    GLchar * counterString;
} ARGS_glGetPerfMonitorCounterStringAMD;
typedef struct {
    int index;
    ARGS_glGetPerfMonitorCounterStringAMD args;
} PACKED_glGetPerfMonitorCounterStringAMD;
typedef struct {
    GLuint group;
    GLint * numCounters;
    GLint * maxActiveCounters;
    GLsizei counterSize;
    GLuint * counters;
} ARGS_glGetPerfMonitorCountersAMD;
typedef struct {
    int index;
    ARGS_glGetPerfMonitorCountersAMD args;
} PACKED_glGetPerfMonitorCountersAMD;
typedef struct {
    GLuint group;
    GLsizei bufSize;
    GLsizei * length;
    GLchar * groupString;
} ARGS_glGetPerfMonitorGroupStringAMD;
typedef struct {
    int index;
    ARGS_glGetPerfMonitorGroupStringAMD args;
} PACKED_glGetPerfMonitorGroupStringAMD;
typedef struct {
    GLint * numGroups;
    GLsizei groupsSize;
    GLuint * groups;
} ARGS_glGetPerfMonitorGroupsAMD;
typedef struct {
    int index;
    ARGS_glGetPerfMonitorGroupsAMD args;
} PACKED_glGetPerfMonitorGroupsAMD;
typedef struct {
    GLenum map;
    GLfloat * values;
} ARGS_glGetPixelMapfv;
typedef struct {
    int index;
    ARGS_glGetPixelMapfv args;
} PACKED_glGetPixelMapfv;
typedef struct {
    GLenum map;
    GLuint * values;
} ARGS_glGetPixelMapuiv;
typedef struct {
    int index;
    ARGS_glGetPixelMapuiv args;
} PACKED_glGetPixelMapuiv;
typedef struct {
    GLenum map;
    GLushort * values;
} ARGS_glGetPixelMapusv;
typedef struct {
    int index;
    ARGS_glGetPixelMapusv args;
} PACKED_glGetPixelMapusv;
typedef struct {
    GLenum map;
    GLint size;
    GLfixed * values;
} ARGS_glGetPixelMapxv;
typedef struct {
    int index;
    ARGS_glGetPixelMapxv args;
} PACKED_glGetPixelMapxv;
typedef struct {
    GLenum pname;
    GLfloat * params;
} ARGS_glGetPixelTexGenParameterfvSGIS;
typedef struct {
    int index;
    ARGS_glGetPixelTexGenParameterfvSGIS args;
} PACKED_glGetPixelTexGenParameterfvSGIS;
typedef struct {
    GLenum pname;
    GLint * params;
} ARGS_glGetPixelTexGenParameterivSGIS;
typedef struct {
    int index;
    ARGS_glGetPixelTexGenParameterivSGIS args;
} PACKED_glGetPixelTexGenParameterivSGIS;
typedef struct {
    GLenum target;
    GLenum pname;
    GLfloat * params;
} ARGS_glGetPixelTransformParameterfvEXT;
typedef struct {
    int index;
    ARGS_glGetPixelTransformParameterfvEXT args;
} PACKED_glGetPixelTransformParameterfvEXT;
typedef struct {
    GLenum target;
    GLenum pname;
    GLint * params;
} ARGS_glGetPixelTransformParameterivEXT;
typedef struct {
    int index;
    ARGS_glGetPixelTransformParameterivEXT args;
} PACKED_glGetPixelTransformParameterivEXT;
typedef struct {
    GLenum target;
    GLuint index;
    GLvoid * data;
} ARGS_glGetPointerIndexedvEXT;
typedef struct {
    int index;
    ARGS_glGetPointerIndexedvEXT args;
} PACKED_glGetPointerIndexedvEXT;
typedef struct {
    GLenum target;
    GLuint index;
    GLvoid * data;
} ARGS_glGetPointeri_vEXT;
typedef struct {
    int index;
    ARGS_glGetPointeri_vEXT args;
} PACKED_glGetPointeri_vEXT;
typedef struct {
    GLenum pname;
    GLvoid ** params;
} ARGS_glGetPointerv;
typedef struct {
    int index;
    ARGS_glGetPointerv args;
} PACKED_glGetPointerv;
typedef struct {
    GLenum pname;
    GLvoid * params;
} ARGS_glGetPointervEXT;
typedef struct {
    int index;
    ARGS_glGetPointervEXT args;
} PACKED_glGetPointervEXT;
typedef struct {
    GLubyte * mask;
} ARGS_glGetPolygonStipple;
typedef struct {
    int index;
    ARGS_glGetPolygonStipple args;
} PACKED_glGetPolygonStipple;
typedef struct {
    GLuint program;
    GLsizei bufSize;
    GLsizei * length;
    GLenum * binaryFormat;
    GLvoid * binary;
} ARGS_glGetProgramBinary;
typedef struct {
    int index;
    ARGS_glGetProgramBinary args;
} PACKED_glGetProgramBinary;
typedef struct {
    GLenum target;
    GLuint index;
    GLint * params;
} ARGS_glGetProgramEnvParameterIivNV;
typedef struct {
    int index;
    ARGS_glGetProgramEnvParameterIivNV args;
} PACKED_glGetProgramEnvParameterIivNV;
typedef struct {
    GLenum target;
    GLuint index;
    GLuint * params;
} ARGS_glGetProgramEnvParameterIuivNV;
typedef struct {
    int index;
    ARGS_glGetProgramEnvParameterIuivNV args;
} PACKED_glGetProgramEnvParameterIuivNV;
typedef struct {
    GLenum target;
    GLuint index;
    GLdouble * params;
} ARGS_glGetProgramEnvParameterdvARB;
typedef struct {
    int index;
    ARGS_glGetProgramEnvParameterdvARB args;
} PACKED_glGetProgramEnvParameterdvARB;
typedef struct {
    GLenum target;
    GLuint index;
    GLfloat * params;
} ARGS_glGetProgramEnvParameterfvARB;
typedef struct {
    int index;
    ARGS_glGetProgramEnvParameterfvARB args;
} PACKED_glGetProgramEnvParameterfvARB;
typedef struct {
    GLuint program;
    GLsizei bufSize;
    GLsizei * length;
    GLchar * infoLog;
} ARGS_glGetProgramInfoLog;
typedef struct {
    int index;
    ARGS_glGetProgramInfoLog args;
} PACKED_glGetProgramInfoLog;
typedef struct {
    GLuint program;
    GLenum programInterface;
    GLenum pname;
    GLint * params;
} ARGS_glGetProgramInterfaceiv;
typedef struct {
    int index;
    ARGS_glGetProgramInterfaceiv args;
} PACKED_glGetProgramInterfaceiv;
typedef struct {
    GLenum target;
    GLuint index;
    GLint * params;
} ARGS_glGetProgramLocalParameterIivNV;
typedef struct {
    int index;
    ARGS_glGetProgramLocalParameterIivNV args;
} PACKED_glGetProgramLocalParameterIivNV;
typedef struct {
    GLenum target;
    GLuint index;
    GLuint * params;
} ARGS_glGetProgramLocalParameterIuivNV;
typedef struct {
    int index;
    ARGS_glGetProgramLocalParameterIuivNV args;
} PACKED_glGetProgramLocalParameterIuivNV;
typedef struct {
    GLenum target;
    GLuint index;
    GLdouble * params;
} ARGS_glGetProgramLocalParameterdvARB;
typedef struct {
    int index;
    ARGS_glGetProgramLocalParameterdvARB args;
} PACKED_glGetProgramLocalParameterdvARB;
typedef struct {
    GLenum target;
    GLuint index;
    GLfloat * params;
} ARGS_glGetProgramLocalParameterfvARB;
typedef struct {
    int index;
    ARGS_glGetProgramLocalParameterfvARB args;
} PACKED_glGetProgramLocalParameterfvARB;
typedef struct {
    GLuint id;
    GLsizei len;
    GLubyte * name;
    GLdouble * params;
} ARGS_glGetProgramNamedParameterdvNV;
typedef struct {
    int index;
    ARGS_glGetProgramNamedParameterdvNV args;
} PACKED_glGetProgramNamedParameterdvNV;
typedef struct {
    GLuint id;
    GLsizei len;
    GLubyte * name;
    GLfloat * params;
} ARGS_glGetProgramNamedParameterfvNV;
typedef struct {
    int index;
    ARGS_glGetProgramNamedParameterfvNV args;
} PACKED_glGetProgramNamedParameterfvNV;
typedef struct {
    GLenum target;
    GLuint index;
    GLenum pname;
    GLdouble * params;
} ARGS_glGetProgramParameterdvNV;
typedef struct {
    int index;
    ARGS_glGetProgramParameterdvNV args;
} PACKED_glGetProgramParameterdvNV;
typedef struct {
    GLenum target;
    GLuint index;
    GLenum pname;
    GLfloat * params;
} ARGS_glGetProgramParameterfvNV;
typedef struct {
    int index;
    ARGS_glGetProgramParameterfvNV args;
} PACKED_glGetProgramParameterfvNV;
typedef struct {
    GLuint pipeline;
    GLsizei bufSize;
    GLsizei * length;
    GLchar * infoLog;
} ARGS_glGetProgramPipelineInfoLog;
typedef struct {
    int index;
    ARGS_glGetProgramPipelineInfoLog args;
} PACKED_glGetProgramPipelineInfoLog;
typedef struct {
    GLuint pipeline;
    GLenum pname;
    GLint * params;
} ARGS_glGetProgramPipelineiv;
typedef struct {
    int index;
    ARGS_glGetProgramPipelineiv args;
} PACKED_glGetProgramPipelineiv;
typedef struct {
    GLuint program;
    GLenum programInterface;
    GLchar * name;
} ARGS_glGetProgramResourceIndex;
typedef struct {
    int index;
    ARGS_glGetProgramResourceIndex args;
} PACKED_glGetProgramResourceIndex;
typedef struct {
    GLuint program;
    GLenum programInterface;
    GLchar * name;
} ARGS_glGetProgramResourceLocation;
typedef struct {
    int index;
    ARGS_glGetProgramResourceLocation args;
} PACKED_glGetProgramResourceLocation;
typedef struct {
    GLuint program;
    GLenum programInterface;
    GLchar * name;
} ARGS_glGetProgramResourceLocationIndex;
typedef struct {
    int index;
    ARGS_glGetProgramResourceLocationIndex args;
} PACKED_glGetProgramResourceLocationIndex;
typedef struct {
    GLuint program;
    GLenum programInterface;
    GLuint index;
    GLsizei bufSize;
    GLsizei * length;
    GLchar * name;
} ARGS_glGetProgramResourceName;
typedef struct {
    int index;
    ARGS_glGetProgramResourceName args;
} PACKED_glGetProgramResourceName;
typedef struct {
    GLuint program;
    GLenum programInterface;
    GLuint index;
    GLsizei propCount;
    GLenum * props;
    GLsizei bufSize;
    GLsizei * length;
    GLint * params;
} ARGS_glGetProgramResourceiv;
typedef struct {
    int index;
    ARGS_glGetProgramResourceiv args;
} PACKED_glGetProgramResourceiv;
typedef struct {
    GLuint program;
    GLenum shadertype;
    GLenum pname;
    GLint * values;
} ARGS_glGetProgramStageiv;
typedef struct {
    int index;
    ARGS_glGetProgramStageiv args;
} PACKED_glGetProgramStageiv;
typedef struct {
    GLenum target;
    GLenum pname;
    GLvoid * string;
} ARGS_glGetProgramStringARB;
typedef struct {
    int index;
    ARGS_glGetProgramStringARB args;
} PACKED_glGetProgramStringARB;
typedef struct {
    GLuint id;
    GLenum pname;
    GLubyte * program;
} ARGS_glGetProgramStringNV;
typedef struct {
    int index;
    ARGS_glGetProgramStringNV args;
} PACKED_glGetProgramStringNV;
typedef struct {
    GLenum target;
    GLuint index;
    GLuint * param;
} ARGS_glGetProgramSubroutineParameteruivNV;
typedef struct {
    int index;
    ARGS_glGetProgramSubroutineParameteruivNV args;
} PACKED_glGetProgramSubroutineParameteruivNV;
typedef struct {
    GLuint program;
    GLenum pname;
    GLint * params;
} ARGS_glGetProgramiv;
typedef struct {
    int index;
    ARGS_glGetProgramiv args;
} PACKED_glGetProgramiv;
typedef struct {
    GLenum target;
    GLenum pname;
    GLint * params;
} ARGS_glGetProgramivARB;
typedef struct {
    int index;
    ARGS_glGetProgramivARB args;
} PACKED_glGetProgramivARB;
typedef struct {
    GLuint id;
    GLenum pname;
    GLint * params;
} ARGS_glGetProgramivNV;
typedef struct {
    int index;
    ARGS_glGetProgramivNV args;
} PACKED_glGetProgramivNV;
typedef struct {
    GLenum target;
    GLuint index;
    GLenum pname;
    GLint * params;
} ARGS_glGetQueryIndexediv;
typedef struct {
    int index;
    ARGS_glGetQueryIndexediv args;
} PACKED_glGetQueryIndexediv;
typedef struct {
    GLuint id;
    GLenum pname;
    GLint64 * params;
} ARGS_glGetQueryObjecti64v;
typedef struct {
    int index;
    ARGS_glGetQueryObjecti64v args;
} PACKED_glGetQueryObjecti64v;
typedef struct {
    GLuint id;
    GLenum pname;
    GLint64EXT * params;
} ARGS_glGetQueryObjecti64vEXT;
typedef struct {
    int index;
    ARGS_glGetQueryObjecti64vEXT args;
} PACKED_glGetQueryObjecti64vEXT;
typedef struct {
    GLuint id;
    GLenum pname;
    GLint * params;
} ARGS_glGetQueryObjectiv;
typedef struct {
    int index;
    ARGS_glGetQueryObjectiv args;
} PACKED_glGetQueryObjectiv;
typedef struct {
    GLuint id;
    GLenum pname;
    GLint * params;
} ARGS_glGetQueryObjectivARB;
typedef struct {
    int index;
    ARGS_glGetQueryObjectivARB args;
} PACKED_glGetQueryObjectivARB;
typedef struct {
    GLuint id;
    GLenum pname;
    GLuint64 * params;
} ARGS_glGetQueryObjectui64v;
typedef struct {
    int index;
    ARGS_glGetQueryObjectui64v args;
} PACKED_glGetQueryObjectui64v;
typedef struct {
    GLuint id;
    GLenum pname;
    GLuint64EXT * params;
} ARGS_glGetQueryObjectui64vEXT;
typedef struct {
    int index;
    ARGS_glGetQueryObjectui64vEXT args;
} PACKED_glGetQueryObjectui64vEXT;
typedef struct {
    GLuint id;
    GLenum pname;
    GLuint * params;
} ARGS_glGetQueryObjectuiv;
typedef struct {
    int index;
    ARGS_glGetQueryObjectuiv args;
} PACKED_glGetQueryObjectuiv;
typedef struct {
    GLuint id;
    GLenum pname;
    GLuint * params;
} ARGS_glGetQueryObjectuivARB;
typedef struct {
    int index;
    ARGS_glGetQueryObjectuivARB args;
} PACKED_glGetQueryObjectuivARB;
typedef struct {
    GLenum target;
    GLenum pname;
    GLint * params;
} ARGS_glGetQueryiv;
typedef struct {
    int index;
    ARGS_glGetQueryiv args;
} PACKED_glGetQueryiv;
typedef struct {
    GLenum target;
    GLenum pname;
    GLint * params;
} ARGS_glGetQueryivARB;
typedef struct {
    int index;
    ARGS_glGetQueryivARB args;
} PACKED_glGetQueryivARB;
typedef struct {
    GLenum target;
    GLenum pname;
    GLint * params;
} ARGS_glGetRenderbufferParameteriv;
typedef struct {
    int index;
    ARGS_glGetRenderbufferParameteriv args;
} PACKED_glGetRenderbufferParameteriv;
typedef struct {
    GLenum target;
    GLenum pname;
    GLint * params;
} ARGS_glGetRenderbufferParameterivEXT;
typedef struct {
    int index;
    ARGS_glGetRenderbufferParameterivEXT args;
} PACKED_glGetRenderbufferParameterivEXT;
typedef struct {
    GLuint sampler;
    GLenum pname;
    GLint * params;
} ARGS_glGetSamplerParameterIiv;
typedef struct {
    int index;
    ARGS_glGetSamplerParameterIiv args;
} PACKED_glGetSamplerParameterIiv;
typedef struct {
    GLuint sampler;
    GLenum pname;
    GLuint * params;
} ARGS_glGetSamplerParameterIuiv;
typedef struct {
    int index;
    ARGS_glGetSamplerParameterIuiv args;
} PACKED_glGetSamplerParameterIuiv;
typedef struct {
    GLuint sampler;
    GLenum pname;
    GLfloat * params;
} ARGS_glGetSamplerParameterfv;
typedef struct {
    int index;
    ARGS_glGetSamplerParameterfv args;
} PACKED_glGetSamplerParameterfv;
typedef struct {
    GLuint sampler;
    GLenum pname;
    GLint * params;
} ARGS_glGetSamplerParameteriv;
typedef struct {
    int index;
    ARGS_glGetSamplerParameteriv args;
} PACKED_glGetSamplerParameteriv;
typedef struct {
    GLenum target;
    GLenum format;
    GLenum type;
    GLvoid * row;
    GLvoid * column;
    GLvoid * span;
} ARGS_glGetSeparableFilter;
typedef struct {
    int index;
    ARGS_glGetSeparableFilter args;
} PACKED_glGetSeparableFilter;
typedef struct {
    GLenum target;
    GLenum format;
    GLenum type;
    GLvoid * row;
    GLvoid * column;
    GLvoid * span;
} ARGS_glGetSeparableFilterEXT;
typedef struct {
    int index;
    ARGS_glGetSeparableFilterEXT args;
} PACKED_glGetSeparableFilterEXT;
typedef struct {
    GLuint shader;
    GLsizei bufSize;
    GLsizei * length;
    GLchar * infoLog;
} ARGS_glGetShaderInfoLog;
typedef struct {
    int index;
    ARGS_glGetShaderInfoLog args;
} PACKED_glGetShaderInfoLog;
typedef struct {
    GLenum shadertype;
    GLenum precisiontype;
    GLint * range;
    GLint * precision;
} ARGS_glGetShaderPrecisionFormat;
typedef struct {
    int index;
    ARGS_glGetShaderPrecisionFormat args;
} PACKED_glGetShaderPrecisionFormat;
typedef struct {
    GLuint shader;
    GLsizei bufSize;
    GLsizei * length;
    GLchar * source;
} ARGS_glGetShaderSource;
typedef struct {
    int index;
    ARGS_glGetShaderSource args;
} PACKED_glGetShaderSource;
typedef struct {
    GLhandleARB obj;
    GLsizei maxLength;
    GLsizei * length;
    GLcharARB * source;
} ARGS_glGetShaderSourceARB;
typedef struct {
    int index;
    ARGS_glGetShaderSourceARB args;
} PACKED_glGetShaderSourceARB;
typedef struct {
    GLuint shader;
    GLenum pname;
    GLint * params;
} ARGS_glGetShaderiv;
typedef struct {
    int index;
    ARGS_glGetShaderiv args;
} PACKED_glGetShaderiv;
typedef struct {
    GLenum target;
    GLfloat * points;
} ARGS_glGetSharpenTexFuncSGIS;
typedef struct {
    int index;
    ARGS_glGetSharpenTexFuncSGIS args;
} PACKED_glGetSharpenTexFuncSGIS;
typedef struct {
    GLenum name;
} ARGS_glGetString;
typedef struct {
    int index;
    ARGS_glGetString args;
} PACKED_glGetString;
typedef struct {
    GLenum name;
    GLuint index;
} ARGS_glGetStringi;
typedef struct {
    int index;
    ARGS_glGetStringi args;
} PACKED_glGetStringi;
typedef struct {
    GLuint program;
    GLenum shadertype;
    GLchar * name;
} ARGS_glGetSubroutineIndex;
typedef struct {
    int index;
    ARGS_glGetSubroutineIndex args;
} PACKED_glGetSubroutineIndex;
typedef struct {
    GLuint program;
    GLenum shadertype;
    GLchar * name;
} ARGS_glGetSubroutineUniformLocation;
typedef struct {
    int index;
    ARGS_glGetSubroutineUniformLocation args;
} PACKED_glGetSubroutineUniformLocation;
typedef struct {
    GLsync sync;
    GLenum pname;
    GLsizei bufSize;
    GLsizei * length;
    GLint * values;
} ARGS_glGetSynciv;
typedef struct {
    int index;
    ARGS_glGetSynciv args;
} PACKED_glGetSynciv;
typedef struct {
    GLenum pname;
    GLfloat * param;
} ARGS_glGetTexBumpParameterfvATI;
typedef struct {
    int index;
    ARGS_glGetTexBumpParameterfvATI args;
} PACKED_glGetTexBumpParameterfvATI;
typedef struct {
    GLenum pname;
    GLint * param;
} ARGS_glGetTexBumpParameterivATI;
typedef struct {
    int index;
    ARGS_glGetTexBumpParameterivATI args;
} PACKED_glGetTexBumpParameterivATI;
typedef struct {
    GLenum target;
    GLenum pname;
    GLfloat * params;
} ARGS_glGetTexEnvfv;
typedef struct {
    int index;
    ARGS_glGetTexEnvfv args;
} PACKED_glGetTexEnvfv;
typedef struct {
    GLenum target;
    GLenum pname;
    GLint * params;
} ARGS_glGetTexEnviv;
typedef struct {
    int index;
    ARGS_glGetTexEnviv args;
} PACKED_glGetTexEnviv;
typedef struct {
    GLenum target;
    GLenum pname;
    GLfixed * params;
} ARGS_glGetTexEnvxv;
typedef struct {
    int index;
    ARGS_glGetTexEnvxv args;
} PACKED_glGetTexEnvxv;
typedef struct {
    GLenum target;
    GLenum pname;
    GLfixed * params;
} ARGS_glGetTexEnvxvOES;
typedef struct {
    int index;
    ARGS_glGetTexEnvxvOES args;
} PACKED_glGetTexEnvxvOES;
typedef struct {
    GLenum target;
    GLenum filter;
    GLfloat * weights;
} ARGS_glGetTexFilterFuncSGIS;
typedef struct {
    int index;
    ARGS_glGetTexFilterFuncSGIS args;
} PACKED_glGetTexFilterFuncSGIS;
typedef struct {
    GLenum coord;
    GLenum pname;
    GLdouble * params;
} ARGS_glGetTexGendv;
typedef struct {
    int index;
    ARGS_glGetTexGendv args;
} PACKED_glGetTexGendv;
typedef struct {
    GLenum coord;
    GLenum pname;
    GLfloat * params;
} ARGS_glGetTexGenfv;
typedef struct {
    int index;
    ARGS_glGetTexGenfv args;
} PACKED_glGetTexGenfv;
typedef struct {
    GLenum coord;
    GLenum pname;
    GLint * params;
} ARGS_glGetTexGeniv;
typedef struct {
    int index;
    ARGS_glGetTexGeniv args;
} PACKED_glGetTexGeniv;
typedef struct {
    GLenum coord;
    GLenum pname;
    GLfixed * params;
} ARGS_glGetTexGenxvOES;
typedef struct {
    int index;
    ARGS_glGetTexGenxvOES args;
} PACKED_glGetTexGenxvOES;
typedef struct {
    GLenum target;
    GLint level;
    GLenum format;
    GLenum type;
    GLvoid * pixels;
} ARGS_glGetTexImage;
typedef struct {
    int index;
    ARGS_glGetTexImage args;
} PACKED_glGetTexImage;
typedef struct {
    GLenum target;
    GLint level;
    GLenum pname;
    GLfloat * params;
} ARGS_glGetTexLevelParameterfv;
typedef struct {
    int index;
    ARGS_glGetTexLevelParameterfv args;
} PACKED_glGetTexLevelParameterfv;
typedef struct {
    GLenum target;
    GLint level;
    GLenum pname;
    GLint * params;
} ARGS_glGetTexLevelParameteriv;
typedef struct {
    int index;
    ARGS_glGetTexLevelParameteriv args;
} PACKED_glGetTexLevelParameteriv;
typedef struct {
    GLenum target;
    GLint level;
    GLenum pname;
    GLfixed * params;
} ARGS_glGetTexLevelParameterxvOES;
typedef struct {
    int index;
    ARGS_glGetTexLevelParameterxvOES args;
} PACKED_glGetTexLevelParameterxvOES;
typedef struct {
    GLenum target;
    GLenum pname;
    GLint * params;
} ARGS_glGetTexParameterIiv;
typedef struct {
    int index;
    ARGS_glGetTexParameterIiv args;
} PACKED_glGetTexParameterIiv;
typedef struct {
    GLenum target;
    GLenum pname;
    GLint * params;
} ARGS_glGetTexParameterIivEXT;
typedef struct {
    int index;
    ARGS_glGetTexParameterIivEXT args;
} PACKED_glGetTexParameterIivEXT;
typedef struct {
    GLenum target;
    GLenum pname;
    GLuint * params;
} ARGS_glGetTexParameterIuiv;
typedef struct {
    int index;
    ARGS_glGetTexParameterIuiv args;
} PACKED_glGetTexParameterIuiv;
typedef struct {
    GLenum target;
    GLenum pname;
    GLuint * params;
} ARGS_glGetTexParameterIuivEXT;
typedef struct {
    int index;
    ARGS_glGetTexParameterIuivEXT args;
} PACKED_glGetTexParameterIuivEXT;
typedef struct {
    GLenum target;
    GLenum pname;
    GLvoid * params;
} ARGS_glGetTexParameterPointervAPPLE;
typedef struct {
    int index;
    ARGS_glGetTexParameterPointervAPPLE args;
} PACKED_glGetTexParameterPointervAPPLE;
typedef struct {
    GLenum target;
    GLenum pname;
    GLfloat * params;
} ARGS_glGetTexParameterfv;
typedef struct {
    int index;
    ARGS_glGetTexParameterfv args;
} PACKED_glGetTexParameterfv;
typedef struct {
    GLenum target;
    GLenum pname;
    GLint * params;
} ARGS_glGetTexParameteriv;
typedef struct {
    int index;
    ARGS_glGetTexParameteriv args;
} PACKED_glGetTexParameteriv;
typedef struct {
    GLenum target;
    GLenum pname;
    GLfixed * params;
} ARGS_glGetTexParameterxv;
typedef struct {
    int index;
    ARGS_glGetTexParameterxv args;
} PACKED_glGetTexParameterxv;
typedef struct {
    GLenum target;
    GLenum pname;
    GLfixed * params;
} ARGS_glGetTexParameterxvOES;
typedef struct {
    int index;
    ARGS_glGetTexParameterxvOES args;
} PACKED_glGetTexParameterxvOES;
typedef struct {
    GLuint texture;
} ARGS_glGetTextureHandleNV;
typedef struct {
    int index;
    ARGS_glGetTextureHandleNV args;
} PACKED_glGetTextureHandleNV;
typedef struct {
    GLuint texture;
    GLenum target;
    GLint level;
    GLenum format;
    GLenum type;
    GLvoid * pixels;
} ARGS_glGetTextureImageEXT;
typedef struct {
    int index;
    ARGS_glGetTextureImageEXT args;
} PACKED_glGetTextureImageEXT;
typedef struct {
    GLuint texture;
    GLenum target;
    GLint level;
    GLenum pname;
    GLfloat * params;
} ARGS_glGetTextureLevelParameterfvEXT;
typedef struct {
    int index;
    ARGS_glGetTextureLevelParameterfvEXT args;
} PACKED_glGetTextureLevelParameterfvEXT;
typedef struct {
    GLuint texture;
    GLenum target;
    GLint level;
    GLenum pname;
    GLint * params;
} ARGS_glGetTextureLevelParameterivEXT;
typedef struct {
    int index;
    ARGS_glGetTextureLevelParameterivEXT args;
} PACKED_glGetTextureLevelParameterivEXT;
typedef struct {
    GLuint texture;
    GLenum target;
    GLenum pname;
    GLint * params;
} ARGS_glGetTextureParameterIivEXT;
typedef struct {
    int index;
    ARGS_glGetTextureParameterIivEXT args;
} PACKED_glGetTextureParameterIivEXT;
typedef struct {
    GLuint texture;
    GLenum target;
    GLenum pname;
    GLuint * params;
} ARGS_glGetTextureParameterIuivEXT;
typedef struct {
    int index;
    ARGS_glGetTextureParameterIuivEXT args;
} PACKED_glGetTextureParameterIuivEXT;
typedef struct {
    GLuint texture;
    GLenum target;
    GLenum pname;
    GLfloat * params;
} ARGS_glGetTextureParameterfvEXT;
typedef struct {
    int index;
    ARGS_glGetTextureParameterfvEXT args;
} PACKED_glGetTextureParameterfvEXT;
typedef struct {
    GLuint texture;
    GLenum target;
    GLenum pname;
    GLint * params;
} ARGS_glGetTextureParameterivEXT;
typedef struct {
    int index;
    ARGS_glGetTextureParameterivEXT args;
} PACKED_glGetTextureParameterivEXT;
typedef struct {
    GLuint texture;
    GLuint sampler;
} ARGS_glGetTextureSamplerHandleNV;
typedef struct {
    int index;
    ARGS_glGetTextureSamplerHandleNV args;
} PACKED_glGetTextureSamplerHandleNV;
typedef struct {
    GLenum target;
    GLuint address;
    GLenum pname;
    GLint * params;
} ARGS_glGetTrackMatrixivNV;
typedef struct {
    int index;
    ARGS_glGetTrackMatrixivNV args;
} PACKED_glGetTrackMatrixivNV;
typedef struct {
    GLuint program;
    GLuint index;
    GLsizei bufSize;
    GLsizei * length;
    GLsizei * size;
    GLenum * type;
    GLchar * name;
} ARGS_glGetTransformFeedbackVarying;
typedef struct {
    int index;
    ARGS_glGetTransformFeedbackVarying args;
} PACKED_glGetTransformFeedbackVarying;
typedef struct {
    GLuint program;
    GLuint index;
    GLsizei bufSize;
    GLsizei * length;
    GLsizei * size;
    GLenum * type;
    GLchar * name;
} ARGS_glGetTransformFeedbackVaryingEXT;
typedef struct {
    int index;
    ARGS_glGetTransformFeedbackVaryingEXT args;
} PACKED_glGetTransformFeedbackVaryingEXT;
typedef struct {
    GLuint program;
    GLuint index;
    GLint * location;
} ARGS_glGetTransformFeedbackVaryingNV;
typedef struct {
    int index;
    ARGS_glGetTransformFeedbackVaryingNV args;
} PACKED_glGetTransformFeedbackVaryingNV;
typedef struct {
    GLuint program;
    GLchar * uniformBlockName;
} ARGS_glGetUniformBlockIndex;
typedef struct {
    int index;
    ARGS_glGetUniformBlockIndex args;
} PACKED_glGetUniformBlockIndex;
typedef struct {
    GLuint program;
    GLint location;
} ARGS_glGetUniformBufferSizeEXT;
typedef struct {
    int index;
    ARGS_glGetUniformBufferSizeEXT args;
} PACKED_glGetUniformBufferSizeEXT;
typedef struct {
    GLuint program;
    GLsizei uniformCount;
    GLchar*const * uniformNames;
    GLuint * uniformIndices;
} ARGS_glGetUniformIndices;
typedef struct {
    int index;
    ARGS_glGetUniformIndices args;
} PACKED_glGetUniformIndices;
typedef struct {
    GLuint program;
    GLchar * name;
} ARGS_glGetUniformLocation;
typedef struct {
    int index;
    ARGS_glGetUniformLocation args;
} PACKED_glGetUniformLocation;
typedef struct {
    GLhandleARB programObj;
    GLcharARB * name;
} ARGS_glGetUniformLocationARB;
typedef struct {
    int index;
    ARGS_glGetUniformLocationARB args;
} PACKED_glGetUniformLocationARB;
typedef struct {
    GLuint program;
    GLint location;
} ARGS_glGetUniformOffsetEXT;
typedef struct {
    int index;
    ARGS_glGetUniformOffsetEXT args;
} PACKED_glGetUniformOffsetEXT;
typedef struct {
    GLenum shadertype;
    GLint location;
    GLuint * params;
} ARGS_glGetUniformSubroutineuiv;
typedef struct {
    int index;
    ARGS_glGetUniformSubroutineuiv args;
} PACKED_glGetUniformSubroutineuiv;
typedef struct {
    GLuint program;
    GLint location;
    GLdouble * params;
} ARGS_glGetUniformdv;
typedef struct {
    int index;
    ARGS_glGetUniformdv args;
} PACKED_glGetUniformdv;
typedef struct {
    GLuint program;
    GLint location;
    GLfloat * params;
} ARGS_glGetUniformfv;
typedef struct {
    int index;
    ARGS_glGetUniformfv args;
} PACKED_glGetUniformfv;
typedef struct {
    GLhandleARB programObj;
    GLint location;
    GLfloat * params;
} ARGS_glGetUniformfvARB;
typedef struct {
    int index;
    ARGS_glGetUniformfvARB args;
} PACKED_glGetUniformfvARB;
typedef struct {
    GLuint program;
    GLint location;
    GLint64EXT * params;
} ARGS_glGetUniformi64vNV;
typedef struct {
    int index;
    ARGS_glGetUniformi64vNV args;
} PACKED_glGetUniformi64vNV;
typedef struct {
    GLuint program;
    GLint location;
    GLint * params;
} ARGS_glGetUniformiv;
typedef struct {
    int index;
    ARGS_glGetUniformiv args;
} PACKED_glGetUniformiv;
typedef struct {
    GLhandleARB programObj;
    GLint location;
    GLint * params;
} ARGS_glGetUniformivARB;
typedef struct {
    int index;
    ARGS_glGetUniformivARB args;
} PACKED_glGetUniformivARB;
typedef struct {
    GLuint program;
    GLint location;
    GLuint64EXT * params;
} ARGS_glGetUniformui64vNV;
typedef struct {
    int index;
    ARGS_glGetUniformui64vNV args;
} PACKED_glGetUniformui64vNV;
typedef struct {
    GLuint program;
    GLint location;
    GLuint * params;
} ARGS_glGetUniformuiv;
typedef struct {
    int index;
    ARGS_glGetUniformuiv args;
} PACKED_glGetUniformuiv;
typedef struct {
    GLuint program;
    GLint location;
    GLuint * params;
} ARGS_glGetUniformuivEXT;
typedef struct {
    int index;
    ARGS_glGetUniformuivEXT args;
} PACKED_glGetUniformuivEXT;
typedef struct {
    GLuint id;
    GLenum pname;
    GLfloat * params;
} ARGS_glGetVariantArrayObjectfvATI;
typedef struct {
    int index;
    ARGS_glGetVariantArrayObjectfvATI args;
} PACKED_glGetVariantArrayObjectfvATI;
typedef struct {
    GLuint id;
    GLenum pname;
    GLint * params;
} ARGS_glGetVariantArrayObjectivATI;
typedef struct {
    int index;
    ARGS_glGetVariantArrayObjectivATI args;
} PACKED_glGetVariantArrayObjectivATI;
typedef struct {
    GLuint id;
    GLenum value;
    GLboolean * data;
} ARGS_glGetVariantBooleanvEXT;
typedef struct {
    int index;
    ARGS_glGetVariantBooleanvEXT args;
} PACKED_glGetVariantBooleanvEXT;
typedef struct {
    GLuint id;
    GLenum value;
    GLfloat * data;
} ARGS_glGetVariantFloatvEXT;
typedef struct {
    int index;
    ARGS_glGetVariantFloatvEXT args;
} PACKED_glGetVariantFloatvEXT;
typedef struct {
    GLuint id;
    GLenum value;
    GLint * data;
} ARGS_glGetVariantIntegervEXT;
typedef struct {
    int index;
    ARGS_glGetVariantIntegervEXT args;
} PACKED_glGetVariantIntegervEXT;
typedef struct {
    GLuint id;
    GLenum value;
    GLvoid * data;
} ARGS_glGetVariantPointervEXT;
typedef struct {
    int index;
    ARGS_glGetVariantPointervEXT args;
} PACKED_glGetVariantPointervEXT;
typedef struct {
    GLuint program;
    GLchar * name;
} ARGS_glGetVaryingLocationNV;
typedef struct {
    int index;
    ARGS_glGetVaryingLocationNV args;
} PACKED_glGetVaryingLocationNV;
typedef struct {
    GLuint vaobj;
    GLuint index;
    GLenum pname;
    GLint * param;
} ARGS_glGetVertexArrayIntegeri_vEXT;
typedef struct {
    int index;
    ARGS_glGetVertexArrayIntegeri_vEXT args;
} PACKED_glGetVertexArrayIntegeri_vEXT;
typedef struct {
    GLuint vaobj;
    GLenum pname;
    GLint * param;
} ARGS_glGetVertexArrayIntegervEXT;
typedef struct {
    int index;
    ARGS_glGetVertexArrayIntegervEXT args;
} PACKED_glGetVertexArrayIntegervEXT;
typedef struct {
    GLuint vaobj;
    GLuint index;
    GLenum pname;
    GLvoid * param;
} ARGS_glGetVertexArrayPointeri_vEXT;
typedef struct {
    int index;
    ARGS_glGetVertexArrayPointeri_vEXT args;
} PACKED_glGetVertexArrayPointeri_vEXT;
typedef struct {
    GLuint vaobj;
    GLenum pname;
    GLvoid * param;
} ARGS_glGetVertexArrayPointervEXT;
typedef struct {
    int index;
    ARGS_glGetVertexArrayPointervEXT args;
} PACKED_glGetVertexArrayPointervEXT;
typedef struct {
    GLuint index;
    GLenum pname;
    GLfloat * params;
} ARGS_glGetVertexAttribArrayObjectfvATI;
typedef struct {
    int index;
    ARGS_glGetVertexAttribArrayObjectfvATI args;
} PACKED_glGetVertexAttribArrayObjectfvATI;
typedef struct {
    GLuint index;
    GLenum pname;
    GLint * params;
} ARGS_glGetVertexAttribArrayObjectivATI;
typedef struct {
    int index;
    ARGS_glGetVertexAttribArrayObjectivATI args;
} PACKED_glGetVertexAttribArrayObjectivATI;
typedef struct {
    GLuint index;
    GLenum pname;
    GLint * params;
} ARGS_glGetVertexAttribIiv;
typedef struct {
    int index;
    ARGS_glGetVertexAttribIiv args;
} PACKED_glGetVertexAttribIiv;
typedef struct {
    GLuint index;
    GLenum pname;
    GLint * params;
} ARGS_glGetVertexAttribIivEXT;
typedef struct {
    int index;
    ARGS_glGetVertexAttribIivEXT args;
} PACKED_glGetVertexAttribIivEXT;
typedef struct {
    GLuint index;
    GLenum pname;
    GLuint * params;
} ARGS_glGetVertexAttribIuiv;
typedef struct {
    int index;
    ARGS_glGetVertexAttribIuiv args;
} PACKED_glGetVertexAttribIuiv;
typedef struct {
    GLuint index;
    GLenum pname;
    GLuint * params;
} ARGS_glGetVertexAttribIuivEXT;
typedef struct {
    int index;
    ARGS_glGetVertexAttribIuivEXT args;
} PACKED_glGetVertexAttribIuivEXT;
typedef struct {
    GLuint index;
    GLenum pname;
    GLdouble * params;
} ARGS_glGetVertexAttribLdv;
typedef struct {
    int index;
    ARGS_glGetVertexAttribLdv args;
} PACKED_glGetVertexAttribLdv;
typedef struct {
    GLuint index;
    GLenum pname;
    GLdouble * params;
} ARGS_glGetVertexAttribLdvEXT;
typedef struct {
    int index;
    ARGS_glGetVertexAttribLdvEXT args;
} PACKED_glGetVertexAttribLdvEXT;
typedef struct {
    GLuint index;
    GLenum pname;
    GLint64EXT * params;
} ARGS_glGetVertexAttribLi64vNV;
typedef struct {
    int index;
    ARGS_glGetVertexAttribLi64vNV args;
} PACKED_glGetVertexAttribLi64vNV;
typedef struct {
    GLuint index;
    GLenum pname;
    GLuint64EXT * params;
} ARGS_glGetVertexAttribLui64vNV;
typedef struct {
    int index;
    ARGS_glGetVertexAttribLui64vNV args;
} PACKED_glGetVertexAttribLui64vNV;
typedef struct {
    GLuint index;
    GLenum pname;
    GLvoid ** pointer;
} ARGS_glGetVertexAttribPointerv;
typedef struct {
    int index;
    ARGS_glGetVertexAttribPointerv args;
} PACKED_glGetVertexAttribPointerv;
typedef struct {
    GLuint index;
    GLenum pname;
    GLvoid * pointer;
} ARGS_glGetVertexAttribPointervARB;
typedef struct {
    int index;
    ARGS_glGetVertexAttribPointervARB args;
} PACKED_glGetVertexAttribPointervARB;
typedef struct {
    GLuint index;
    GLenum pname;
    GLvoid * pointer;
} ARGS_glGetVertexAttribPointervNV;
typedef struct {
    int index;
    ARGS_glGetVertexAttribPointervNV args;
} PACKED_glGetVertexAttribPointervNV;
typedef struct {
    GLuint index;
    GLenum pname;
    GLdouble * params;
} ARGS_glGetVertexAttribdv;
typedef struct {
    int index;
    ARGS_glGetVertexAttribdv args;
} PACKED_glGetVertexAttribdv;
typedef struct {
    GLuint index;
    GLenum pname;
    GLdouble * params;
} ARGS_glGetVertexAttribdvARB;
typedef struct {
    int index;
    ARGS_glGetVertexAttribdvARB args;
} PACKED_glGetVertexAttribdvARB;
typedef struct {
    GLuint index;
    GLenum pname;
    GLdouble * params;
} ARGS_glGetVertexAttribdvNV;
typedef struct {
    int index;
    ARGS_glGetVertexAttribdvNV args;
} PACKED_glGetVertexAttribdvNV;
typedef struct {
    GLuint index;
    GLenum pname;
    GLfloat * params;
} ARGS_glGetVertexAttribfv;
typedef struct {
    int index;
    ARGS_glGetVertexAttribfv args;
} PACKED_glGetVertexAttribfv;
typedef struct {
    GLuint index;
    GLenum pname;
    GLfloat * params;
} ARGS_glGetVertexAttribfvARB;
typedef struct {
    int index;
    ARGS_glGetVertexAttribfvARB args;
} PACKED_glGetVertexAttribfvARB;
typedef struct {
    GLuint index;
    GLenum pname;
    GLfloat * params;
} ARGS_glGetVertexAttribfvNV;
typedef struct {
    int index;
    ARGS_glGetVertexAttribfvNV args;
} PACKED_glGetVertexAttribfvNV;
typedef struct {
    GLuint index;
    GLenum pname;
    GLint * params;
} ARGS_glGetVertexAttribiv;
typedef struct {
    int index;
    ARGS_glGetVertexAttribiv args;
} PACKED_glGetVertexAttribiv;
typedef struct {
    GLuint index;
    GLenum pname;
    GLint * params;
} ARGS_glGetVertexAttribivARB;
typedef struct {
    int index;
    ARGS_glGetVertexAttribivARB args;
} PACKED_glGetVertexAttribivARB;
typedef struct {
    GLuint index;
    GLenum pname;
    GLint * params;
} ARGS_glGetVertexAttribivNV;
typedef struct {
    int index;
    ARGS_glGetVertexAttribivNV args;
} PACKED_glGetVertexAttribivNV;
typedef struct {
    GLuint video_capture_slot;
    GLuint stream;
    GLenum pname;
    GLdouble * params;
} ARGS_glGetVideoCaptureStreamdvNV;
typedef struct {
    int index;
    ARGS_glGetVideoCaptureStreamdvNV args;
} PACKED_glGetVideoCaptureStreamdvNV;
typedef struct {
    GLuint video_capture_slot;
    GLuint stream;
    GLenum pname;
    GLfloat * params;
} ARGS_glGetVideoCaptureStreamfvNV;
typedef struct {
    int index;
    ARGS_glGetVideoCaptureStreamfvNV args;
} PACKED_glGetVideoCaptureStreamfvNV;
typedef struct {
    GLuint video_capture_slot;
    GLuint stream;
    GLenum pname;
    GLint * params;
} ARGS_glGetVideoCaptureStreamivNV;
typedef struct {
    int index;
    ARGS_glGetVideoCaptureStreamivNV args;
} PACKED_glGetVideoCaptureStreamivNV;
typedef struct {
    GLuint video_capture_slot;
    GLenum pname;
    GLint * params;
} ARGS_glGetVideoCaptureivNV;
typedef struct {
    int index;
    ARGS_glGetVideoCaptureivNV args;
} PACKED_glGetVideoCaptureivNV;
typedef struct {
    GLuint video_slot;
    GLenum pname;
    GLint64EXT * params;
} ARGS_glGetVideoi64vNV;
typedef struct {
    int index;
    ARGS_glGetVideoi64vNV args;
} PACKED_glGetVideoi64vNV;
typedef struct {
    GLuint video_slot;
    GLenum pname;
    GLint * params;
} ARGS_glGetVideoivNV;
typedef struct {
    int index;
    ARGS_glGetVideoivNV args;
} PACKED_glGetVideoivNV;
typedef struct {
    GLuint video_slot;
    GLenum pname;
    GLuint64EXT * params;
} ARGS_glGetVideoui64vNV;
typedef struct {
    int index;
    ARGS_glGetVideoui64vNV args;
} PACKED_glGetVideoui64vNV;
typedef struct {
    GLuint video_slot;
    GLenum pname;
    GLuint * params;
} ARGS_glGetVideouivNV;
typedef struct {
    int index;
    ARGS_glGetVideouivNV args;
} PACKED_glGetVideouivNV;
typedef struct {
    GLenum target;
    GLenum format;
    GLenum type;
    GLsizei bufSize;
    GLvoid * table;
} ARGS_glGetnColorTableARB;
typedef struct {
    int index;
    ARGS_glGetnColorTableARB args;
} PACKED_glGetnColorTableARB;
typedef struct {
    GLenum target;
    GLint lod;
    GLsizei bufSize;
    GLvoid * img;
} ARGS_glGetnCompressedTexImageARB;
typedef struct {
    int index;
    ARGS_glGetnCompressedTexImageARB args;
} PACKED_glGetnCompressedTexImageARB;
typedef struct {
    GLenum target;
    GLenum format;
    GLenum type;
    GLsizei bufSize;
    GLvoid * image;
} ARGS_glGetnConvolutionFilterARB;
typedef struct {
    int index;
    ARGS_glGetnConvolutionFilterARB args;
} PACKED_glGetnConvolutionFilterARB;
typedef struct {
    GLenum target;
    GLboolean reset;
    GLenum format;
    GLenum type;
    GLsizei bufSize;
    GLvoid * values;
} ARGS_glGetnHistogramARB;
typedef struct {
    int index;
    ARGS_glGetnHistogramARB args;
} PACKED_glGetnHistogramARB;
typedef struct {
    GLenum target;
    GLenum query;
    GLsizei bufSize;
    GLdouble * v;
} ARGS_glGetnMapdvARB;
typedef struct {
    int index;
    ARGS_glGetnMapdvARB args;
} PACKED_glGetnMapdvARB;
typedef struct {
    GLenum target;
    GLenum query;
    GLsizei bufSize;
    GLfloat * v;
} ARGS_glGetnMapfvARB;
typedef struct {
    int index;
    ARGS_glGetnMapfvARB args;
} PACKED_glGetnMapfvARB;
typedef struct {
    GLenum target;
    GLenum query;
    GLsizei bufSize;
    GLint * v;
} ARGS_glGetnMapivARB;
typedef struct {
    int index;
    ARGS_glGetnMapivARB args;
} PACKED_glGetnMapivARB;
typedef struct {
    GLenum target;
    GLboolean reset;
    GLenum format;
    GLenum type;
    GLsizei bufSize;
    GLvoid * values;
} ARGS_glGetnMinmaxARB;
typedef struct {
    int index;
    ARGS_glGetnMinmaxARB args;
} PACKED_glGetnMinmaxARB;
typedef struct {
    GLenum map;
    GLsizei bufSize;
    GLfloat * values;
} ARGS_glGetnPixelMapfvARB;
typedef struct {
    int index;
    ARGS_glGetnPixelMapfvARB args;
} PACKED_glGetnPixelMapfvARB;
typedef struct {
    GLenum map;
    GLsizei bufSize;
    GLuint * values;
} ARGS_glGetnPixelMapuivARB;
typedef struct {
    int index;
    ARGS_glGetnPixelMapuivARB args;
} PACKED_glGetnPixelMapuivARB;
typedef struct {
    GLenum map;
    GLsizei bufSize;
    GLushort * values;
} ARGS_glGetnPixelMapusvARB;
typedef struct {
    int index;
    ARGS_glGetnPixelMapusvARB args;
} PACKED_glGetnPixelMapusvARB;
typedef struct {
    GLsizei bufSize;
    GLubyte * pattern;
} ARGS_glGetnPolygonStippleARB;
typedef struct {
    int index;
    ARGS_glGetnPolygonStippleARB args;
} PACKED_glGetnPolygonStippleARB;
typedef struct {
    GLenum target;
    GLenum format;
    GLenum type;
    GLsizei rowBufSize;
    GLvoid * row;
    GLsizei columnBufSize;
    GLvoid * column;
    GLvoid * span;
} ARGS_glGetnSeparableFilterARB;
typedef struct {
    int index;
    ARGS_glGetnSeparableFilterARB args;
} PACKED_glGetnSeparableFilterARB;
typedef struct {
    GLenum target;
    GLint level;
    GLenum format;
    GLenum type;
    GLsizei bufSize;
    GLvoid * img;
} ARGS_glGetnTexImageARB;
typedef struct {
    int index;
    ARGS_glGetnTexImageARB args;
} PACKED_glGetnTexImageARB;
typedef struct {
    GLuint program;
    GLint location;
    GLsizei bufSize;
    GLdouble * params;
} ARGS_glGetnUniformdvARB;
typedef struct {
    int index;
    ARGS_glGetnUniformdvARB args;
} PACKED_glGetnUniformdvARB;
typedef struct {
    GLuint program;
    GLint location;
    GLsizei bufSize;
    GLfloat * params;
} ARGS_glGetnUniformfvARB;
typedef struct {
    int index;
    ARGS_glGetnUniformfvARB args;
} PACKED_glGetnUniformfvARB;
typedef struct {
    GLuint program;
    GLint location;
    GLsizei bufSize;
    GLint * params;
} ARGS_glGetnUniformivARB;
typedef struct {
    int index;
    ARGS_glGetnUniformivARB args;
} PACKED_glGetnUniformivARB;
typedef struct {
    GLuint program;
    GLint location;
    GLsizei bufSize;
    GLuint * params;
} ARGS_glGetnUniformuivARB;
typedef struct {
    int index;
    ARGS_glGetnUniformuivARB args;
} PACKED_glGetnUniformuivARB;
typedef struct {
    GLbyte factor;
} ARGS_glGlobalAlphaFactorbSUN;
typedef struct {
    int index;
    ARGS_glGlobalAlphaFactorbSUN args;
} PACKED_glGlobalAlphaFactorbSUN;
typedef struct {
    GLdouble factor __attribute__ ((aligned(8)));
} ARGS_glGlobalAlphaFactordSUN;
typedef struct {
    int index;
    ARGS_glGlobalAlphaFactordSUN args;
} PACKED_glGlobalAlphaFactordSUN;
typedef struct {
    GLfloat factor;
} ARGS_glGlobalAlphaFactorfSUN;
typedef struct {
    int index;
    ARGS_glGlobalAlphaFactorfSUN args;
} PACKED_glGlobalAlphaFactorfSUN;
typedef struct {
    GLint factor;
} ARGS_glGlobalAlphaFactoriSUN;
typedef struct {
    int index;
    ARGS_glGlobalAlphaFactoriSUN args;
} PACKED_glGlobalAlphaFactoriSUN;
typedef struct {
    GLshort factor;
} ARGS_glGlobalAlphaFactorsSUN;
typedef struct {
    int index;
    ARGS_glGlobalAlphaFactorsSUN args;
} PACKED_glGlobalAlphaFactorsSUN;
typedef struct {
    GLubyte factor;
} ARGS_glGlobalAlphaFactorubSUN;
typedef struct {
    int index;
    ARGS_glGlobalAlphaFactorubSUN args;
} PACKED_glGlobalAlphaFactorubSUN;
typedef struct {
    GLuint factor;
} ARGS_glGlobalAlphaFactoruiSUN;
typedef struct {
    int index;
    ARGS_glGlobalAlphaFactoruiSUN args;
} PACKED_glGlobalAlphaFactoruiSUN;
typedef struct {
    GLushort factor;
} ARGS_glGlobalAlphaFactorusSUN;
typedef struct {
    int index;
    ARGS_glGlobalAlphaFactorusSUN args;
} PACKED_glGlobalAlphaFactorusSUN;
typedef struct {
    GLenum target;
    GLenum mode;
} ARGS_glHint;
typedef struct {
    int index;
    ARGS_glHint args;
} PACKED_glHint;
typedef struct {
    GLenum target;
    GLint mode;
} ARGS_glHintPGI;
typedef struct {
    int index;
    ARGS_glHintPGI args;
} PACKED_glHintPGI;
typedef struct {
    GLenum target;
    GLsizei width;
    GLenum internalformat;
    GLboolean sink;
} ARGS_glHistogram;
typedef struct {
    int index;
    ARGS_glHistogram args;
} PACKED_glHistogram;
typedef struct {
    GLenum target;
    GLsizei width;
    GLenum internalformat;
    GLboolean sink;
} ARGS_glHistogramEXT;
typedef struct {
    int index;
    ARGS_glHistogramEXT args;
} PACKED_glHistogramEXT;
typedef struct {
    GLenum pname;
    GLvoid * params;
} ARGS_glIglooInterfaceSGIX;
typedef struct {
    int index;
    ARGS_glIglooInterfaceSGIX args;
} PACKED_glIglooInterfaceSGIX;
typedef struct {
    GLenum target;
    GLenum pname;
    GLfloat param;
} ARGS_glImageTransformParameterfHP;
typedef struct {
    int index;
    ARGS_glImageTransformParameterfHP args;
} PACKED_glImageTransformParameterfHP;
typedef struct {
    GLenum target;
    GLenum pname;
    GLfloat * params;
} ARGS_glImageTransformParameterfvHP;
typedef struct {
    int index;
    ARGS_glImageTransformParameterfvHP args;
} PACKED_glImageTransformParameterfvHP;
typedef struct {
    GLenum target;
    GLenum pname;
    GLint param;
} ARGS_glImageTransformParameteriHP;
typedef struct {
    int index;
    ARGS_glImageTransformParameteriHP args;
} PACKED_glImageTransformParameteriHP;
typedef struct {
    GLenum target;
    GLenum pname;
    GLint * params;
} ARGS_glImageTransformParameterivHP;
typedef struct {
    int index;
    ARGS_glImageTransformParameterivHP args;
} PACKED_glImageTransformParameterivHP;
typedef struct {
    GLenum external_sync_type;
    GLintptr external_sync;
    GLbitfield flags;
} ARGS_glImportSyncEXT;
typedef struct {
    int index;
    ARGS_glImportSyncEXT args;
} PACKED_glImportSyncEXT;
typedef struct {
    GLenum type;
    GLsizei stride;
} ARGS_glIndexFormatNV;
typedef struct {
    int index;
    ARGS_glIndexFormatNV args;
} PACKED_glIndexFormatNV;
typedef struct {
    GLenum func;
    GLclampf ref;
} ARGS_glIndexFuncEXT;
typedef struct {
    int index;
    ARGS_glIndexFuncEXT args;
} PACKED_glIndexFuncEXT;
typedef struct {
    GLuint mask;
} ARGS_glIndexMask;
typedef struct {
    int index;
    ARGS_glIndexMask args;
} PACKED_glIndexMask;
typedef struct {
    GLenum face;
    GLenum mode;
} ARGS_glIndexMaterialEXT;
typedef struct {
    int index;
    ARGS_glIndexMaterialEXT args;
} PACKED_glIndexMaterialEXT;
typedef struct {
    GLenum type;
    GLsizei stride;
    GLvoid * pointer;
} ARGS_glIndexPointer;
typedef struct {
    int index;
    ARGS_glIndexPointer args;
} PACKED_glIndexPointer;
typedef struct {
    GLenum type;
    GLsizei stride;
    GLsizei count;
    GLvoid * pointer;
} ARGS_glIndexPointerEXT;
typedef struct {
    int index;
    ARGS_glIndexPointerEXT args;
} PACKED_glIndexPointerEXT;
typedef struct {
    GLenum type;
    GLint stride;
    GLvoid * pointer;
    GLint ptrstride;
} ARGS_glIndexPointerListIBM;
typedef struct {
    int index;
    ARGS_glIndexPointerListIBM args;
} PACKED_glIndexPointerListIBM;
typedef struct {
    GLdouble c __attribute__ ((aligned(8)));
} ARGS_glIndexd;
typedef struct {
    int index;
    ARGS_glIndexd args;
} PACKED_glIndexd;
typedef struct {
    GLdouble * c;
} ARGS_glIndexdv;
typedef struct {
    int index;
    ARGS_glIndexdv args;
} PACKED_glIndexdv;
typedef struct {
    GLfloat c;
} ARGS_glIndexf;
typedef struct {
    int index;
    ARGS_glIndexf args;
} PACKED_glIndexf;
typedef struct {
    GLfloat * c;
} ARGS_glIndexfv;
typedef struct {
    int index;
    ARGS_glIndexfv args;
} PACKED_glIndexfv;
typedef struct {
    GLint c;
} ARGS_glIndexi;
typedef struct {
    int index;
    ARGS_glIndexi args;
} PACKED_glIndexi;
typedef struct {
    GLint * c;
} ARGS_glIndexiv;
typedef struct {
    int index;
    ARGS_glIndexiv args;
} PACKED_glIndexiv;
typedef struct {
    GLshort c;
} ARGS_glIndexs;
typedef struct {
    int index;
    ARGS_glIndexs args;
} PACKED_glIndexs;
typedef struct {
    GLshort * c;
} ARGS_glIndexsv;
typedef struct {
    int index;
    ARGS_glIndexsv args;
} PACKED_glIndexsv;
typedef struct {
    GLubyte c;
} ARGS_glIndexub;
typedef struct {
    int index;
    ARGS_glIndexub args;
} PACKED_glIndexub;
typedef struct {
    GLubyte * c;
} ARGS_glIndexubv;
typedef struct {
    int index;
    ARGS_glIndexubv args;
} PACKED_glIndexubv;
typedef struct {
    GLfixed component;
} ARGS_glIndexxOES;
typedef struct {
    int index;
    ARGS_glIndexxOES args;
} PACKED_glIndexxOES;
typedef struct {
    GLfixed * component;
} ARGS_glIndexxvOES;
typedef struct {
    int index;
    ARGS_glIndexxvOES args;
} PACKED_glIndexxvOES;
typedef struct {
    int index;
} PACKED_glInitNames;
typedef struct {
    GLuint res;
    GLuint src;
    GLuint num;
} ARGS_glInsertComponentEXT;
typedef struct {
    int index;
    ARGS_glInsertComponentEXT args;
} PACKED_glInsertComponentEXT;
typedef struct {
    GLsizei size;
    GLint * buffer;
} ARGS_glInstrumentsBufferSGIX;
typedef struct {
    int index;
    ARGS_glInstrumentsBufferSGIX args;
} PACKED_glInstrumentsBufferSGIX;
typedef struct {
    GLenum format;
    GLsizei stride;
    GLvoid * pointer;
} ARGS_glInterleavedArrays;
typedef struct {
    int index;
    ARGS_glInterleavedArrays args;
} PACKED_glInterleavedArrays;
typedef struct {
    GLuint resultPath;
    GLuint pathA;
    GLuint pathB;
    GLfloat weight;
} ARGS_glInterpolatePathsNV;
typedef struct {
    int index;
    ARGS_glInterpolatePathsNV args;
} PACKED_glInterpolatePathsNV;
typedef struct {
    GLuint buffer;
} ARGS_glInvalidateBufferData;
typedef struct {
    int index;
    ARGS_glInvalidateBufferData args;
} PACKED_glInvalidateBufferData;
typedef struct {
    GLuint buffer;
    GLintptr offset;
    GLsizeiptr length;
} ARGS_glInvalidateBufferSubData;
typedef struct {
    int index;
    ARGS_glInvalidateBufferSubData args;
} PACKED_glInvalidateBufferSubData;
typedef struct {
    GLenum target;
    GLsizei numAttachments;
    GLenum * attachments;
} ARGS_glInvalidateFramebuffer;
typedef struct {
    int index;
    ARGS_glInvalidateFramebuffer args;
} PACKED_glInvalidateFramebuffer;
typedef struct {
    GLenum target;
    GLsizei numAttachments;
    GLenum * attachments;
    GLint x;
    GLint y;
    GLsizei width;
    GLsizei height;
} ARGS_glInvalidateSubFramebuffer;
typedef struct {
    int index;
    ARGS_glInvalidateSubFramebuffer args;
} PACKED_glInvalidateSubFramebuffer;
typedef struct {
    GLuint texture;
    GLint level;
} ARGS_glInvalidateTexImage;
typedef struct {
    int index;
    ARGS_glInvalidateTexImage args;
} PACKED_glInvalidateTexImage;
typedef struct {
    GLuint texture;
    GLint level;
    GLint xoffset;
    GLint yoffset;
    GLint zoffset;
    GLsizei width;
    GLsizei height;
    GLsizei depth;
} ARGS_glInvalidateTexSubImage;
typedef struct {
    int index;
    ARGS_glInvalidateTexSubImage args;
} PACKED_glInvalidateTexSubImage;
typedef struct {
    GLuint marker;
} ARGS_glIsAsyncMarkerSGIX;
typedef struct {
    int index;
    ARGS_glIsAsyncMarkerSGIX args;
} PACKED_glIsAsyncMarkerSGIX;
typedef struct {
    GLuint buffer;
} ARGS_glIsBuffer;
typedef struct {
    int index;
    ARGS_glIsBuffer args;
} PACKED_glIsBuffer;
typedef struct {
    GLuint buffer;
} ARGS_glIsBufferARB;
typedef struct {
    int index;
    ARGS_glIsBufferARB args;
} PACKED_glIsBufferARB;
typedef struct {
    GLenum target;
} ARGS_glIsBufferResidentNV;
typedef struct {
    int index;
    ARGS_glIsBufferResidentNV args;
} PACKED_glIsBufferResidentNV;
typedef struct {
    GLenum cap;
} ARGS_glIsEnabled;
typedef struct {
    int index;
    ARGS_glIsEnabled args;
} PACKED_glIsEnabled;
typedef struct {
    GLenum target;
    GLuint index;
} ARGS_glIsEnabledIndexedEXT;
typedef struct {
    int index;
    ARGS_glIsEnabledIndexedEXT args;
} PACKED_glIsEnabledIndexedEXT;
typedef struct {
    GLenum target;
    GLuint index;
} ARGS_glIsEnabledi;
typedef struct {
    int index;
    ARGS_glIsEnabledi args;
} PACKED_glIsEnabledi;
typedef struct {
    GLuint fence;
} ARGS_glIsFenceAPPLE;
typedef struct {
    int index;
    ARGS_glIsFenceAPPLE args;
} PACKED_glIsFenceAPPLE;
typedef struct {
    GLuint fence;
} ARGS_glIsFenceNV;
typedef struct {
    int index;
    ARGS_glIsFenceNV args;
} PACKED_glIsFenceNV;
typedef struct {
    GLuint framebuffer;
} ARGS_glIsFramebuffer;
typedef struct {
    int index;
    ARGS_glIsFramebuffer args;
} PACKED_glIsFramebuffer;
typedef struct {
    GLuint framebuffer;
} ARGS_glIsFramebufferEXT;
typedef struct {
    int index;
    ARGS_glIsFramebufferEXT args;
} PACKED_glIsFramebufferEXT;
typedef struct {
    GLuint64 handle;
} ARGS_glIsImageHandleResidentNV;
typedef struct {
    int index;
    ARGS_glIsImageHandleResidentNV args;
} PACKED_glIsImageHandleResidentNV;
typedef struct {
    GLuint list;
} ARGS_glIsList;
typedef struct {
    int index;
    ARGS_glIsList args;
} PACKED_glIsList;
typedef struct {
    GLenum identifier;
    GLuint name;
} ARGS_glIsNameAMD;
typedef struct {
    int index;
    ARGS_glIsNameAMD args;
} PACKED_glIsNameAMD;
typedef struct {
    GLuint buffer;
} ARGS_glIsNamedBufferResidentNV;
typedef struct {
    int index;
    ARGS_glIsNamedBufferResidentNV args;
} PACKED_glIsNamedBufferResidentNV;
typedef struct {
    GLint namelen;
    GLchar * name;
} ARGS_glIsNamedStringARB;
typedef struct {
    int index;
    ARGS_glIsNamedStringARB args;
} PACKED_glIsNamedStringARB;
typedef struct {
    GLuint buffer;
} ARGS_glIsObjectBufferATI;
typedef struct {
    int index;
    ARGS_glIsObjectBufferATI args;
} PACKED_glIsObjectBufferATI;
typedef struct {
    GLuint id;
} ARGS_glIsOcclusionQueryNV;
typedef struct {
    int index;
    ARGS_glIsOcclusionQueryNV args;
} PACKED_glIsOcclusionQueryNV;
typedef struct {
    GLuint path;
} ARGS_glIsPathNV;
typedef struct {
    int index;
    ARGS_glIsPathNV args;
} PACKED_glIsPathNV;
typedef struct {
    GLuint path;
    GLuint mask;
    GLfloat x;
    GLfloat y;
} ARGS_glIsPointInFillPathNV;
typedef struct {
    int index;
    ARGS_glIsPointInFillPathNV args;
} PACKED_glIsPointInFillPathNV;
typedef struct {
    GLuint path;
    GLfloat x;
    GLfloat y;
} ARGS_glIsPointInStrokePathNV;
typedef struct {
    int index;
    ARGS_glIsPointInStrokePathNV args;
} PACKED_glIsPointInStrokePathNV;
typedef struct {
    GLuint program;
} ARGS_glIsProgram;
typedef struct {
    int index;
    ARGS_glIsProgram args;
} PACKED_glIsProgram;
typedef struct {
    GLuint program;
} ARGS_glIsProgramARB;
typedef struct {
    int index;
    ARGS_glIsProgramARB args;
} PACKED_glIsProgramARB;
typedef struct {
    GLuint id;
} ARGS_glIsProgramNV;
typedef struct {
    int index;
    ARGS_glIsProgramNV args;
} PACKED_glIsProgramNV;
typedef struct {
    GLuint pipeline;
} ARGS_glIsProgramPipeline;
typedef struct {
    int index;
    ARGS_glIsProgramPipeline args;
} PACKED_glIsProgramPipeline;
typedef struct {
    GLuint id;
} ARGS_glIsQuery;
typedef struct {
    int index;
    ARGS_glIsQuery args;
} PACKED_glIsQuery;
typedef struct {
    GLuint id;
} ARGS_glIsQueryARB;
typedef struct {
    int index;
    ARGS_glIsQueryARB args;
} PACKED_glIsQueryARB;
typedef struct {
    GLuint renderbuffer;
} ARGS_glIsRenderbuffer;
typedef struct {
    int index;
    ARGS_glIsRenderbuffer args;
} PACKED_glIsRenderbuffer;
typedef struct {
    GLuint renderbuffer;
} ARGS_glIsRenderbufferEXT;
typedef struct {
    int index;
    ARGS_glIsRenderbufferEXT args;
} PACKED_glIsRenderbufferEXT;
typedef struct {
    GLuint sampler;
} ARGS_glIsSampler;
typedef struct {
    int index;
    ARGS_glIsSampler args;
} PACKED_glIsSampler;
typedef struct {
    GLuint shader;
} ARGS_glIsShader;
typedef struct {
    int index;
    ARGS_glIsShader args;
} PACKED_glIsShader;
typedef struct {
    GLsync sync;
} ARGS_glIsSync;
typedef struct {
    int index;
    ARGS_glIsSync args;
} PACKED_glIsSync;
typedef struct {
    GLuint texture;
} ARGS_glIsTexture;
typedef struct {
    int index;
    ARGS_glIsTexture args;
} PACKED_glIsTexture;
typedef struct {
    GLuint texture;
} ARGS_glIsTextureEXT;
typedef struct {
    int index;
    ARGS_glIsTextureEXT args;
} PACKED_glIsTextureEXT;
typedef struct {
    GLuint64 handle;
} ARGS_glIsTextureHandleResidentNV;
typedef struct {
    int index;
    ARGS_glIsTextureHandleResidentNV args;
} PACKED_glIsTextureHandleResidentNV;
typedef struct {
    GLuint id;
} ARGS_glIsTransformFeedback;
typedef struct {
    int index;
    ARGS_glIsTransformFeedback args;
} PACKED_glIsTransformFeedback;
typedef struct {
    GLuint id;
} ARGS_glIsTransformFeedbackNV;
typedef struct {
    int index;
    ARGS_glIsTransformFeedbackNV args;
} PACKED_glIsTransformFeedbackNV;
typedef struct {
    GLuint id;
    GLenum cap;
} ARGS_glIsVariantEnabledEXT;
typedef struct {
    int index;
    ARGS_glIsVariantEnabledEXT args;
} PACKED_glIsVariantEnabledEXT;
typedef struct {
    GLuint array;
} ARGS_glIsVertexArray;
typedef struct {
    int index;
    ARGS_glIsVertexArray args;
} PACKED_glIsVertexArray;
typedef struct {
    GLuint array;
} ARGS_glIsVertexArrayAPPLE;
typedef struct {
    int index;
    ARGS_glIsVertexArrayAPPLE args;
} PACKED_glIsVertexArrayAPPLE;
typedef struct {
    GLuint index;
    GLenum pname;
} ARGS_glIsVertexAttribEnabledAPPLE;
typedef struct {
    int index;
    ARGS_glIsVertexAttribEnabledAPPLE args;
} PACKED_glIsVertexAttribEnabledAPPLE;
typedef struct {
    GLenum pname;
    GLint param;
} ARGS_glLightEnviSGIX;
typedef struct {
    int index;
    ARGS_glLightEnviSGIX args;
} PACKED_glLightEnviSGIX;
typedef struct {
    GLenum pname;
    GLfloat param;
} ARGS_glLightModelf;
typedef struct {
    int index;
    ARGS_glLightModelf args;
} PACKED_glLightModelf;
typedef struct {
    GLenum pname;
    GLfloat * params;
} ARGS_glLightModelfv;
typedef struct {
    int index;
    ARGS_glLightModelfv args;
} PACKED_glLightModelfv;
typedef struct {
    GLenum pname;
    GLint param;
} ARGS_glLightModeli;
typedef struct {
    int index;
    ARGS_glLightModeli args;
} PACKED_glLightModeli;
typedef struct {
    GLenum pname;
    GLint * params;
} ARGS_glLightModeliv;
typedef struct {
    int index;
    ARGS_glLightModeliv args;
} PACKED_glLightModeliv;
typedef struct {
    GLenum pname;
    GLfixed param;
} ARGS_glLightModelx;
typedef struct {
    int index;
    ARGS_glLightModelx args;
} PACKED_glLightModelx;
typedef struct {
    GLenum pname;
    GLfixed param;
} ARGS_glLightModelxOES;
typedef struct {
    int index;
    ARGS_glLightModelxOES args;
} PACKED_glLightModelxOES;
typedef struct {
    GLenum pname;
    GLfixed * params;
} ARGS_glLightModelxv;
typedef struct {
    int index;
    ARGS_glLightModelxv args;
} PACKED_glLightModelxv;
typedef struct {
    GLenum pname;
    GLfixed * param;
} ARGS_glLightModelxvOES;
typedef struct {
    int index;
    ARGS_glLightModelxvOES args;
} PACKED_glLightModelxvOES;
typedef struct {
    GLenum light;
    GLenum pname;
    GLfloat param;
} ARGS_glLightf;
typedef struct {
    int index;
    ARGS_glLightf args;
} PACKED_glLightf;
typedef struct {
    GLenum light;
    GLenum pname;
    GLfloat * params;
} ARGS_glLightfv;
typedef struct {
    int index;
    ARGS_glLightfv args;
} PACKED_glLightfv;
typedef struct {
    GLenum light;
    GLenum pname;
    GLint param;
} ARGS_glLighti;
typedef struct {
    int index;
    ARGS_glLighti args;
} PACKED_glLighti;
typedef struct {
    GLenum light;
    GLenum pname;
    GLint * params;
} ARGS_glLightiv;
typedef struct {
    int index;
    ARGS_glLightiv args;
} PACKED_glLightiv;
typedef struct {
    GLenum light;
    GLenum pname;
    GLfixed param;
} ARGS_glLightx;
typedef struct {
    int index;
    ARGS_glLightx args;
} PACKED_glLightx;
typedef struct {
    GLenum light;
    GLenum pname;
    GLfixed param;
} ARGS_glLightxOES;
typedef struct {
    int index;
    ARGS_glLightxOES args;
} PACKED_glLightxOES;
typedef struct {
    GLenum light;
    GLenum pname;
    GLfixed * params;
} ARGS_glLightxv;
typedef struct {
    int index;
    ARGS_glLightxv args;
} PACKED_glLightxv;
typedef struct {
    GLenum light;
    GLenum pname;
    GLfixed * params;
} ARGS_glLightxvOES;
typedef struct {
    int index;
    ARGS_glLightxvOES args;
} PACKED_glLightxvOES;
typedef struct {
    GLint factor;
    GLushort pattern;
} ARGS_glLineStipple;
typedef struct {
    int index;
    ARGS_glLineStipple args;
} PACKED_glLineStipple;
typedef struct {
    GLfloat width;
} ARGS_glLineWidth;
typedef struct {
    int index;
    ARGS_glLineWidth args;
} PACKED_glLineWidth;
typedef struct {
    GLfixed width;
} ARGS_glLineWidthx;
typedef struct {
    int index;
    ARGS_glLineWidthx args;
} PACKED_glLineWidthx;
typedef struct {
    GLfixed width;
} ARGS_glLineWidthxOES;
typedef struct {
    int index;
    ARGS_glLineWidthxOES args;
} PACKED_glLineWidthxOES;
typedef struct {
    GLuint program;
} ARGS_glLinkProgram;
typedef struct {
    int index;
    ARGS_glLinkProgram args;
} PACKED_glLinkProgram;
typedef struct {
    GLhandleARB programObj;
} ARGS_glLinkProgramARB;
typedef struct {
    int index;
    ARGS_glLinkProgramARB args;
} PACKED_glLinkProgramARB;
typedef struct {
    GLuint base;
} ARGS_glListBase;
typedef struct {
    int index;
    ARGS_glListBase args;
} PACKED_glListBase;
typedef struct {
    GLuint list;
    GLenum pname;
    GLfloat param;
} ARGS_glListParameterfSGIX;
typedef struct {
    int index;
    ARGS_glListParameterfSGIX args;
} PACKED_glListParameterfSGIX;
typedef struct {
    GLuint list;
    GLenum pname;
    GLfloat * params;
} ARGS_glListParameterfvSGIX;
typedef struct {
    int index;
    ARGS_glListParameterfvSGIX args;
} PACKED_glListParameterfvSGIX;
typedef struct {
    GLuint list;
    GLenum pname;
    GLint param;
} ARGS_glListParameteriSGIX;
typedef struct {
    int index;
    ARGS_glListParameteriSGIX args;
} PACKED_glListParameteriSGIX;
typedef struct {
    GLuint list;
    GLenum pname;
    GLint * params;
} ARGS_glListParameterivSGIX;
typedef struct {
    int index;
    ARGS_glListParameterivSGIX args;
} PACKED_glListParameterivSGIX;
typedef struct {
    int index;
} PACKED_glLoadIdentity;
typedef struct {
    GLbitfield mask;
} ARGS_glLoadIdentityDeformationMapSGIX;
typedef struct {
    int index;
    ARGS_glLoadIdentityDeformationMapSGIX args;
} PACKED_glLoadIdentityDeformationMapSGIX;
typedef struct {
    GLdouble * m;
} ARGS_glLoadMatrixd;
typedef struct {
    int index;
    ARGS_glLoadMatrixd args;
} PACKED_glLoadMatrixd;
typedef struct {
    GLfloat * m;
} ARGS_glLoadMatrixf;
typedef struct {
    int index;
    ARGS_glLoadMatrixf args;
} PACKED_glLoadMatrixf;
typedef struct {
    GLfixed * m;
} ARGS_glLoadMatrixx;
typedef struct {
    int index;
    ARGS_glLoadMatrixx args;
} PACKED_glLoadMatrixx;
typedef struct {
    GLfixed * m;
} ARGS_glLoadMatrixxOES;
typedef struct {
    int index;
    ARGS_glLoadMatrixxOES args;
} PACKED_glLoadMatrixxOES;
typedef struct {
    GLuint name;
} ARGS_glLoadName;
typedef struct {
    int index;
    ARGS_glLoadName args;
} PACKED_glLoadName;
typedef struct {
    GLenum target;
    GLuint id;
    GLsizei len;
    GLubyte * program;
} ARGS_glLoadProgramNV;
typedef struct {
    int index;
    ARGS_glLoadProgramNV args;
} PACKED_glLoadProgramNV;
typedef struct {
    GLdouble * m;
} ARGS_glLoadTransposeMatrixd;
typedef struct {
    int index;
    ARGS_glLoadTransposeMatrixd args;
} PACKED_glLoadTransposeMatrixd;
typedef struct {
    GLdouble * m;
} ARGS_glLoadTransposeMatrixdARB;
typedef struct {
    int index;
    ARGS_glLoadTransposeMatrixdARB args;
} PACKED_glLoadTransposeMatrixdARB;
typedef struct {
    GLfloat * m;
} ARGS_glLoadTransposeMatrixf;
typedef struct {
    int index;
    ARGS_glLoadTransposeMatrixf args;
} PACKED_glLoadTransposeMatrixf;
typedef struct {
    GLfloat * m;
} ARGS_glLoadTransposeMatrixfARB;
typedef struct {
    int index;
    ARGS_glLoadTransposeMatrixfARB args;
} PACKED_glLoadTransposeMatrixfARB;
typedef struct {
    GLfixed * m;
} ARGS_glLoadTransposeMatrixxOES;
typedef struct {
    int index;
    ARGS_glLoadTransposeMatrixxOES args;
} PACKED_glLoadTransposeMatrixxOES;
typedef struct {
    GLint first;
    GLsizei count;
} ARGS_glLockArraysEXT;
typedef struct {
    int index;
    ARGS_glLockArraysEXT args;
} PACKED_glLockArraysEXT;
typedef struct {
    GLenum opcode;
} ARGS_glLogicOp;
typedef struct {
    int index;
    ARGS_glLogicOp args;
} PACKED_glLogicOp;
typedef struct {
    GLenum target;
} ARGS_glMakeBufferNonResidentNV;
typedef struct {
    int index;
    ARGS_glMakeBufferNonResidentNV args;
} PACKED_glMakeBufferNonResidentNV;
typedef struct {
    GLenum target;
    GLenum access;
} ARGS_glMakeBufferResidentNV;
typedef struct {
    int index;
    ARGS_glMakeBufferResidentNV args;
} PACKED_glMakeBufferResidentNV;
typedef struct {
    GLuint64 handle;
} ARGS_glMakeImageHandleNonResidentNV;
typedef struct {
    int index;
    ARGS_glMakeImageHandleNonResidentNV args;
} PACKED_glMakeImageHandleNonResidentNV;
typedef struct {
    GLuint64 handle;
    GLenum access;
} ARGS_glMakeImageHandleResidentNV;
typedef struct {
    int index;
    ARGS_glMakeImageHandleResidentNV args;
} PACKED_glMakeImageHandleResidentNV;
typedef struct {
    GLuint buffer;
} ARGS_glMakeNamedBufferNonResidentNV;
typedef struct {
    int index;
    ARGS_glMakeNamedBufferNonResidentNV args;
} PACKED_glMakeNamedBufferNonResidentNV;
typedef struct {
    GLuint buffer;
    GLenum access;
} ARGS_glMakeNamedBufferResidentNV;
typedef struct {
    int index;
    ARGS_glMakeNamedBufferResidentNV args;
} PACKED_glMakeNamedBufferResidentNV;
typedef struct {
    GLuint64 handle;
} ARGS_glMakeTextureHandleNonResidentNV;
typedef struct {
    int index;
    ARGS_glMakeTextureHandleNonResidentNV args;
} PACKED_glMakeTextureHandleNonResidentNV;
typedef struct {
    GLuint64 handle;
} ARGS_glMakeTextureHandleResidentNV;
typedef struct {
    int index;
    ARGS_glMakeTextureHandleResidentNV args;
} PACKED_glMakeTextureHandleResidentNV;
typedef struct {
    GLenum target;
    GLdouble u1 __attribute__ ((aligned(8)));
    GLdouble u2 __attribute__ ((aligned(8)));
    GLint stride;
    GLint order;
    GLdouble * points;
} ARGS_glMap1d;
typedef struct {
    int index;
    ARGS_glMap1d args;
} PACKED_glMap1d;
typedef struct {
    GLenum target;
    GLfloat u1;
    GLfloat u2;
    GLint stride;
    GLint order;
    GLfloat * points;
} ARGS_glMap1f;
typedef struct {
    int index;
    ARGS_glMap1f args;
} PACKED_glMap1f;
typedef struct {
    GLenum target;
    GLfixed u1;
    GLfixed u2;
    GLint stride;
    GLint order;
    GLfixed points;
} ARGS_glMap1xOES;
typedef struct {
    int index;
    ARGS_glMap1xOES args;
} PACKED_glMap1xOES;
typedef struct {
    GLenum target;
    GLdouble u1 __attribute__ ((aligned(8)));
    GLdouble u2 __attribute__ ((aligned(8)));
    GLint ustride;
    GLint uorder;
    GLdouble v1 __attribute__ ((aligned(8)));
    GLdouble v2 __attribute__ ((aligned(8)));
    GLint vstride;
    GLint vorder;
    GLdouble * points;
} ARGS_glMap2d;
typedef struct {
    int index;
    ARGS_glMap2d args;
} PACKED_glMap2d;
typedef struct {
    GLenum target;
    GLfloat u1;
    GLfloat u2;
    GLint ustride;
    GLint uorder;
    GLfloat v1;
    GLfloat v2;
    GLint vstride;
    GLint vorder;
    GLfloat * points;
} ARGS_glMap2f;
typedef struct {
    int index;
    ARGS_glMap2f args;
} PACKED_glMap2f;
typedef struct {
    GLenum target;
    GLfixed u1;
    GLfixed u2;
    GLint ustride;
    GLint uorder;
    GLfixed v1;
    GLfixed v2;
    GLint vstride;
    GLint vorder;
    GLfixed points;
} ARGS_glMap2xOES;
typedef struct {
    int index;
    ARGS_glMap2xOES args;
} PACKED_glMap2xOES;
typedef struct {
    GLenum target;
    GLenum access;
} ARGS_glMapBuffer;
typedef struct {
    int index;
    ARGS_glMapBuffer args;
} PACKED_glMapBuffer;
typedef struct {
    GLenum target;
    GLenum access;
} ARGS_glMapBufferARB;
typedef struct {
    int index;
    ARGS_glMapBufferARB args;
} PACKED_glMapBufferARB;
typedef struct {
    GLenum target;
    GLintptr offset;
    GLsizeiptr length;
    GLbitfield access;
} ARGS_glMapBufferRange;
typedef struct {
    int index;
    ARGS_glMapBufferRange args;
} PACKED_glMapBufferRange;
typedef struct {
    GLenum target;
    GLuint index;
    GLenum type;
    GLsizei ustride;
    GLsizei vstride;
    GLint uorder;
    GLint vorder;
    GLboolean packed;
    GLvoid * points;
} ARGS_glMapControlPointsNV;
typedef struct {
    int index;
    ARGS_glMapControlPointsNV args;
} PACKED_glMapControlPointsNV;
typedef struct {
    GLint un;
    GLdouble u1 __attribute__ ((aligned(8)));
    GLdouble u2 __attribute__ ((aligned(8)));
} ARGS_glMapGrid1d;
typedef struct {
    int index;
    ARGS_glMapGrid1d args;
} PACKED_glMapGrid1d;
typedef struct {
    GLint un;
    GLfloat u1;
    GLfloat u2;
} ARGS_glMapGrid1f;
typedef struct {
    int index;
    ARGS_glMapGrid1f args;
} PACKED_glMapGrid1f;
typedef struct {
    GLint n;
    GLfixed u1;
    GLfixed u2;
} ARGS_glMapGrid1xOES;
typedef struct {
    int index;
    ARGS_glMapGrid1xOES args;
} PACKED_glMapGrid1xOES;
typedef struct {
    GLint un;
    GLdouble u1 __attribute__ ((aligned(8)));
    GLdouble u2 __attribute__ ((aligned(8)));
    GLint vn;
    GLdouble v1 __attribute__ ((aligned(8)));
    GLdouble v2 __attribute__ ((aligned(8)));
} ARGS_glMapGrid2d;
typedef struct {
    int index;
    ARGS_glMapGrid2d args;
} PACKED_glMapGrid2d;
typedef struct {
    GLint un;
    GLfloat u1;
    GLfloat u2;
    GLint vn;
    GLfloat v1;
    GLfloat v2;
} ARGS_glMapGrid2f;
typedef struct {
    int index;
    ARGS_glMapGrid2f args;
} PACKED_glMapGrid2f;
typedef struct {
    GLint n;
    GLfixed u1;
    GLfixed u2;
    GLfixed v1;
    GLfixed v2;
} ARGS_glMapGrid2xOES;
typedef struct {
    int index;
    ARGS_glMapGrid2xOES args;
} PACKED_glMapGrid2xOES;
typedef struct {
    GLuint buffer;
    GLenum access;
} ARGS_glMapNamedBufferEXT;
typedef struct {
    int index;
    ARGS_glMapNamedBufferEXT args;
} PACKED_glMapNamedBufferEXT;
typedef struct {
    GLuint buffer;
    GLintptr offset;
    GLsizeiptr length;
    GLbitfield access;
} ARGS_glMapNamedBufferRangeEXT;
typedef struct {
    int index;
    ARGS_glMapNamedBufferRangeEXT args;
} PACKED_glMapNamedBufferRangeEXT;
typedef struct {
    GLuint buffer;
} ARGS_glMapObjectBufferATI;
typedef struct {
    int index;
    ARGS_glMapObjectBufferATI args;
} PACKED_glMapObjectBufferATI;
typedef struct {
    GLenum target;
    GLenum pname;
    GLfloat * params;
} ARGS_glMapParameterfvNV;
typedef struct {
    int index;
    ARGS_glMapParameterfvNV args;
} PACKED_glMapParameterfvNV;
typedef struct {
    GLenum target;
    GLenum pname;
    GLint * params;
} ARGS_glMapParameterivNV;
typedef struct {
    int index;
    ARGS_glMapParameterivNV args;
} PACKED_glMapParameterivNV;
typedef struct {
    GLuint texture;
    GLint level;
    GLbitfield access;
    GLint * stride;
    GLenum * layout;
} ARGS_glMapTexture2DINTEL;
typedef struct {
    int index;
    ARGS_glMapTexture2DINTEL args;
} PACKED_glMapTexture2DINTEL;
typedef struct {
    GLuint index;
    GLuint size;
    GLdouble u1 __attribute__ ((aligned(8)));
    GLdouble u2 __attribute__ ((aligned(8)));
    GLint stride;
    GLint order;
    GLdouble * points;
} ARGS_glMapVertexAttrib1dAPPLE;
typedef struct {
    int index;
    ARGS_glMapVertexAttrib1dAPPLE args;
} PACKED_glMapVertexAttrib1dAPPLE;
typedef struct {
    GLuint index;
    GLuint size;
    GLfloat u1;
    GLfloat u2;
    GLint stride;
    GLint order;
    GLfloat * points;
} ARGS_glMapVertexAttrib1fAPPLE;
typedef struct {
    int index;
    ARGS_glMapVertexAttrib1fAPPLE args;
} PACKED_glMapVertexAttrib1fAPPLE;
typedef struct {
    GLuint index;
    GLuint size;
    GLdouble u1 __attribute__ ((aligned(8)));
    GLdouble u2 __attribute__ ((aligned(8)));
    GLint ustride;
    GLint uorder;
    GLdouble v1 __attribute__ ((aligned(8)));
    GLdouble v2 __attribute__ ((aligned(8)));
    GLint vstride;
    GLint vorder;
    GLdouble * points;
} ARGS_glMapVertexAttrib2dAPPLE;
typedef struct {
    int index;
    ARGS_glMapVertexAttrib2dAPPLE args;
} PACKED_glMapVertexAttrib2dAPPLE;
typedef struct {
    GLuint index;
    GLuint size;
    GLfloat u1;
    GLfloat u2;
    GLint ustride;
    GLint uorder;
    GLfloat v1;
    GLfloat v2;
    GLint vstride;
    GLint vorder;
    GLfloat * points;
} ARGS_glMapVertexAttrib2fAPPLE;
typedef struct {
    int index;
    ARGS_glMapVertexAttrib2fAPPLE args;
} PACKED_glMapVertexAttrib2fAPPLE;
typedef struct {
    GLenum face;
    GLenum pname;
    GLfloat param;
} ARGS_glMaterialf;
typedef struct {
    int index;
    ARGS_glMaterialf args;
} PACKED_glMaterialf;
typedef struct {
    GLenum face;
    GLenum pname;
    GLfloat * params;
} ARGS_glMaterialfv;
typedef struct {
    int index;
    ARGS_glMaterialfv args;
} PACKED_glMaterialfv;
typedef struct {
    GLenum face;
    GLenum pname;
    GLint param;
} ARGS_glMateriali;
typedef struct {
    int index;
    ARGS_glMateriali args;
} PACKED_glMateriali;
typedef struct {
    GLenum face;
    GLenum pname;
    GLint * params;
} ARGS_glMaterialiv;
typedef struct {
    int index;
    ARGS_glMaterialiv args;
} PACKED_glMaterialiv;
typedef struct {
    GLenum face;
    GLenum pname;
    GLfixed param;
} ARGS_glMaterialx;
typedef struct {
    int index;
    ARGS_glMaterialx args;
} PACKED_glMaterialx;
typedef struct {
    GLenum face;
    GLenum pname;
    GLfixed param;
} ARGS_glMaterialxOES;
typedef struct {
    int index;
    ARGS_glMaterialxOES args;
} PACKED_glMaterialxOES;
typedef struct {
    GLenum face;
    GLenum pname;
    GLfixed * params;
} ARGS_glMaterialxv;
typedef struct {
    int index;
    ARGS_glMaterialxv args;
} PACKED_glMaterialxv;
typedef struct {
    GLenum face;
    GLenum pname;
    GLfixed * param;
} ARGS_glMaterialxvOES;
typedef struct {
    int index;
    ARGS_glMaterialxvOES args;
} PACKED_glMaterialxvOES;
typedef struct {
    GLenum mode;
    GLdouble left __attribute__ ((aligned(8)));
    GLdouble right __attribute__ ((aligned(8)));
    GLdouble bottom __attribute__ ((aligned(8)));
    GLdouble top __attribute__ ((aligned(8)));
    GLdouble zNear __attribute__ ((aligned(8)));
    GLdouble zFar __attribute__ ((aligned(8)));
} ARGS_glMatrixFrustumEXT;
typedef struct {
    int index;
    ARGS_glMatrixFrustumEXT args;
} PACKED_glMatrixFrustumEXT;
typedef struct {
    GLint size;
    GLenum type;
    GLsizei stride;
    GLvoid * pointer;
} ARGS_glMatrixIndexPointerARB;
typedef struct {
    int index;
    ARGS_glMatrixIndexPointerARB args;
} PACKED_glMatrixIndexPointerARB;
typedef struct {
    GLint size;
    GLubyte * indices;
} ARGS_glMatrixIndexubvARB;
typedef struct {
    int index;
    ARGS_glMatrixIndexubvARB args;
} PACKED_glMatrixIndexubvARB;
typedef struct {
    GLint size;
    GLuint * indices;
} ARGS_glMatrixIndexuivARB;
typedef struct {
    int index;
    ARGS_glMatrixIndexuivARB args;
} PACKED_glMatrixIndexuivARB;
typedef struct {
    GLint size;
    GLushort * indices;
} ARGS_glMatrixIndexusvARB;
typedef struct {
    int index;
    ARGS_glMatrixIndexusvARB args;
} PACKED_glMatrixIndexusvARB;
typedef struct {
    GLenum mode;
} ARGS_glMatrixLoadIdentityEXT;
typedef struct {
    int index;
    ARGS_glMatrixLoadIdentityEXT args;
} PACKED_glMatrixLoadIdentityEXT;
typedef struct {
    GLenum mode;
    GLdouble * m;
} ARGS_glMatrixLoadTransposedEXT;
typedef struct {
    int index;
    ARGS_glMatrixLoadTransposedEXT args;
} PACKED_glMatrixLoadTransposedEXT;
typedef struct {
    GLenum mode;
    GLfloat * m;
} ARGS_glMatrixLoadTransposefEXT;
typedef struct {
    int index;
    ARGS_glMatrixLoadTransposefEXT args;
} PACKED_glMatrixLoadTransposefEXT;
typedef struct {
    GLenum mode;
    GLdouble * m;
} ARGS_glMatrixLoaddEXT;
typedef struct {
    int index;
    ARGS_glMatrixLoaddEXT args;
} PACKED_glMatrixLoaddEXT;
typedef struct {
    GLenum mode;
    GLfloat * m;
} ARGS_glMatrixLoadfEXT;
typedef struct {
    int index;
    ARGS_glMatrixLoadfEXT args;
} PACKED_glMatrixLoadfEXT;
typedef struct {
    GLenum mode;
} ARGS_glMatrixMode;
typedef struct {
    int index;
    ARGS_glMatrixMode args;
} PACKED_glMatrixMode;
typedef struct {
    GLenum mode;
    GLdouble * m;
} ARGS_glMatrixMultTransposedEXT;
typedef struct {
    int index;
    ARGS_glMatrixMultTransposedEXT args;
} PACKED_glMatrixMultTransposedEXT;
typedef struct {
    GLenum mode;
    GLfloat * m;
} ARGS_glMatrixMultTransposefEXT;
typedef struct {
    int index;
    ARGS_glMatrixMultTransposefEXT args;
} PACKED_glMatrixMultTransposefEXT;
typedef struct {
    GLenum mode;
    GLdouble * m;
} ARGS_glMatrixMultdEXT;
typedef struct {
    int index;
    ARGS_glMatrixMultdEXT args;
} PACKED_glMatrixMultdEXT;
typedef struct {
    GLenum mode;
    GLfloat * m;
} ARGS_glMatrixMultfEXT;
typedef struct {
    int index;
    ARGS_glMatrixMultfEXT args;
} PACKED_glMatrixMultfEXT;
typedef struct {
    GLenum mode;
    GLdouble left __attribute__ ((aligned(8)));
    GLdouble right __attribute__ ((aligned(8)));
    GLdouble bottom __attribute__ ((aligned(8)));
    GLdouble top __attribute__ ((aligned(8)));
    GLdouble zNear __attribute__ ((aligned(8)));
    GLdouble zFar __attribute__ ((aligned(8)));
} ARGS_glMatrixOrthoEXT;
typedef struct {
    int index;
    ARGS_glMatrixOrthoEXT args;
} PACKED_glMatrixOrthoEXT;
typedef struct {
    GLenum mode;
} ARGS_glMatrixPopEXT;
typedef struct {
    int index;
    ARGS_glMatrixPopEXT args;
} PACKED_glMatrixPopEXT;
typedef struct {
    GLenum mode;
} ARGS_glMatrixPushEXT;
typedef struct {
    int index;
    ARGS_glMatrixPushEXT args;
} PACKED_glMatrixPushEXT;
typedef struct {
    GLenum mode;
    GLdouble angle __attribute__ ((aligned(8)));
    GLdouble x __attribute__ ((aligned(8)));
    GLdouble y __attribute__ ((aligned(8)));
    GLdouble z __attribute__ ((aligned(8)));
} ARGS_glMatrixRotatedEXT;
typedef struct {
    int index;
    ARGS_glMatrixRotatedEXT args;
} PACKED_glMatrixRotatedEXT;
typedef struct {
    GLenum mode;
    GLfloat angle;
    GLfloat x;
    GLfloat y;
    GLfloat z;
} ARGS_glMatrixRotatefEXT;
typedef struct {
    int index;
    ARGS_glMatrixRotatefEXT args;
} PACKED_glMatrixRotatefEXT;
typedef struct {
    GLenum mode;
    GLdouble x __attribute__ ((aligned(8)));
    GLdouble y __attribute__ ((aligned(8)));
    GLdouble z __attribute__ ((aligned(8)));
} ARGS_glMatrixScaledEXT;
typedef struct {
    int index;
    ARGS_glMatrixScaledEXT args;
} PACKED_glMatrixScaledEXT;
typedef struct {
    GLenum mode;
    GLfloat x;
    GLfloat y;
    GLfloat z;
} ARGS_glMatrixScalefEXT;
typedef struct {
    int index;
    ARGS_glMatrixScalefEXT args;
} PACKED_glMatrixScalefEXT;
typedef struct {
    GLenum mode;
    GLdouble x __attribute__ ((aligned(8)));
    GLdouble y __attribute__ ((aligned(8)));
    GLdouble z __attribute__ ((aligned(8)));
} ARGS_glMatrixTranslatedEXT;
typedef struct {
    int index;
    ARGS_glMatrixTranslatedEXT args;
} PACKED_glMatrixTranslatedEXT;
typedef struct {
    GLenum mode;
    GLfloat x;
    GLfloat y;
    GLfloat z;
} ARGS_glMatrixTranslatefEXT;
typedef struct {
    int index;
    ARGS_glMatrixTranslatefEXT args;
} PACKED_glMatrixTranslatefEXT;
typedef struct {
    GLbitfield barriers;
} ARGS_glMemoryBarrier;
typedef struct {
    int index;
    ARGS_glMemoryBarrier args;
} PACKED_glMemoryBarrier;
typedef struct {
    GLbitfield barriers;
} ARGS_glMemoryBarrierEXT;
typedef struct {
    int index;
    ARGS_glMemoryBarrierEXT args;
} PACKED_glMemoryBarrierEXT;
typedef struct {
    GLfloat value;
} ARGS_glMinSampleShading;
typedef struct {
    int index;
    ARGS_glMinSampleShading args;
} PACKED_glMinSampleShading;
typedef struct {
    GLfloat value;
} ARGS_glMinSampleShadingARB;
typedef struct {
    int index;
    ARGS_glMinSampleShadingARB args;
} PACKED_glMinSampleShadingARB;
typedef struct {
    GLenum target;
    GLenum internalformat;
    GLboolean sink;
} ARGS_glMinmax;
typedef struct {
    int index;
    ARGS_glMinmax args;
} PACKED_glMinmax;
typedef struct {
    GLenum target;
    GLenum internalformat;
    GLboolean sink;
} ARGS_glMinmaxEXT;
typedef struct {
    int index;
    ARGS_glMinmaxEXT args;
} PACKED_glMinmaxEXT;
typedef struct {
    GLdouble * m;
} ARGS_glMultMatrixd;
typedef struct {
    int index;
    ARGS_glMultMatrixd args;
} PACKED_glMultMatrixd;
typedef struct {
    GLfloat * m;
} ARGS_glMultMatrixf;
typedef struct {
    int index;
    ARGS_glMultMatrixf args;
} PACKED_glMultMatrixf;
typedef struct {
    GLfixed * m;
} ARGS_glMultMatrixx;
typedef struct {
    int index;
    ARGS_glMultMatrixx args;
} PACKED_glMultMatrixx;
typedef struct {
    GLfixed * m;
} ARGS_glMultMatrixxOES;
typedef struct {
    int index;
    ARGS_glMultMatrixxOES args;
} PACKED_glMultMatrixxOES;
typedef struct {
    GLdouble * m;
} ARGS_glMultTransposeMatrixd;
typedef struct {
    int index;
    ARGS_glMultTransposeMatrixd args;
} PACKED_glMultTransposeMatrixd;
typedef struct {
    GLdouble * m;
} ARGS_glMultTransposeMatrixdARB;
typedef struct {
    int index;
    ARGS_glMultTransposeMatrixdARB args;
} PACKED_glMultTransposeMatrixdARB;
typedef struct {
    GLfloat * m;
} ARGS_glMultTransposeMatrixf;
typedef struct {
    int index;
    ARGS_glMultTransposeMatrixf args;
} PACKED_glMultTransposeMatrixf;
typedef struct {
    GLfloat * m;
} ARGS_glMultTransposeMatrixfARB;
typedef struct {
    int index;
    ARGS_glMultTransposeMatrixfARB args;
} PACKED_glMultTransposeMatrixfARB;
typedef struct {
    GLfixed * m;
} ARGS_glMultTransposeMatrixxOES;
typedef struct {
    int index;
    ARGS_glMultTransposeMatrixxOES args;
} PACKED_glMultTransposeMatrixxOES;
typedef struct {
    GLenum mode;
    GLint * first;
    GLsizei * count;
    GLsizei drawcount;
} ARGS_glMultiDrawArrays;
typedef struct {
    int index;
    ARGS_glMultiDrawArrays args;
} PACKED_glMultiDrawArrays;
typedef struct {
    GLenum mode;
    GLint * first;
    GLsizei * count;
    GLsizei primcount;
} ARGS_glMultiDrawArraysEXT;
typedef struct {
    int index;
    ARGS_glMultiDrawArraysEXT args;
} PACKED_glMultiDrawArraysEXT;
typedef struct {
    GLenum mode;
    void * indirect;
    GLsizei drawcount;
    GLsizei stride;
} ARGS_glMultiDrawArraysIndirect;
typedef struct {
    int index;
    ARGS_glMultiDrawArraysIndirect args;
} PACKED_glMultiDrawArraysIndirect;
typedef struct {
    GLenum mode;
    GLvoid * indirect;
    GLsizei primcount;
    GLsizei stride;
} ARGS_glMultiDrawArraysIndirectAMD;
typedef struct {
    int index;
    ARGS_glMultiDrawArraysIndirectAMD args;
} PACKED_glMultiDrawArraysIndirectAMD;
typedef struct {
    GLenum mode;
    GLint * first;
    GLsizei * count;
    GLsizei primcount;
} ARGS_glMultiDrawElementArrayAPPLE;
typedef struct {
    int index;
    ARGS_glMultiDrawElementArrayAPPLE args;
} PACKED_glMultiDrawElementArrayAPPLE;
typedef struct {
    GLenum mode;
    GLsizei * count;
    GLenum type;
    GLvoid*const * indices;
    GLsizei drawcount;
} ARGS_glMultiDrawElements;
typedef struct {
    int index;
    ARGS_glMultiDrawElements args;
} PACKED_glMultiDrawElements;
typedef struct {
    GLenum mode;
    GLsizei * count;
    GLenum type;
    GLvoid*const * indices;
    GLsizei drawcount;
    GLint * basevertex;
} ARGS_glMultiDrawElementsBaseVertex;
typedef struct {
    int index;
    ARGS_glMultiDrawElementsBaseVertex args;
} PACKED_glMultiDrawElementsBaseVertex;
typedef struct {
    GLenum mode;
    GLsizei * count;
    GLenum type;
    GLvoid * indices;
    GLsizei primcount;
} ARGS_glMultiDrawElementsEXT;
typedef struct {
    int index;
    ARGS_glMultiDrawElementsEXT args;
} PACKED_glMultiDrawElementsEXT;
typedef struct {
    GLenum mode;
    GLenum type;
    void * indirect;
    GLsizei drawcount;
    GLsizei stride;
} ARGS_glMultiDrawElementsIndirect;
typedef struct {
    int index;
    ARGS_glMultiDrawElementsIndirect args;
} PACKED_glMultiDrawElementsIndirect;
typedef struct {
    GLenum mode;
    GLenum type;
    GLvoid * indirect;
    GLsizei primcount;
    GLsizei stride;
} ARGS_glMultiDrawElementsIndirectAMD;
typedef struct {
    int index;
    ARGS_glMultiDrawElementsIndirectAMD args;
} PACKED_glMultiDrawElementsIndirectAMD;
typedef struct {
    GLenum mode;
    GLuint start;
    GLuint end;
    GLint * first;
    GLsizei * count;
    GLsizei primcount;
} ARGS_glMultiDrawRangeElementArrayAPPLE;
typedef struct {
    int index;
    ARGS_glMultiDrawRangeElementArrayAPPLE args;
} PACKED_glMultiDrawRangeElementArrayAPPLE;
typedef struct {
    GLenum * mode;
    GLint * first;
    GLsizei * count;
    GLsizei primcount;
    GLint modestride;
} ARGS_glMultiModeDrawArraysIBM;
typedef struct {
    int index;
    ARGS_glMultiModeDrawArraysIBM args;
} PACKED_glMultiModeDrawArraysIBM;
typedef struct {
    GLenum * mode;
    GLsizei * count;
    GLenum type;
    GLvoid*const * indices;
    GLsizei primcount;
    GLint modestride;
} ARGS_glMultiModeDrawElementsIBM;
typedef struct {
    int index;
    ARGS_glMultiModeDrawElementsIBM args;
} PACKED_glMultiModeDrawElementsIBM;
typedef struct {
    GLenum texunit;
    GLenum target;
    GLenum internalformat;
    GLuint buffer;
} ARGS_glMultiTexBufferEXT;
typedef struct {
    int index;
    ARGS_glMultiTexBufferEXT args;
} PACKED_glMultiTexBufferEXT;
typedef struct {
    GLenum texture;
    GLbyte s;
} ARGS_glMultiTexCoord1bOES;
typedef struct {
    int index;
    ARGS_glMultiTexCoord1bOES args;
} PACKED_glMultiTexCoord1bOES;
typedef struct {
    GLenum texture;
    GLbyte * coords;
} ARGS_glMultiTexCoord1bvOES;
typedef struct {
    int index;
    ARGS_glMultiTexCoord1bvOES args;
} PACKED_glMultiTexCoord1bvOES;
typedef struct {
    GLenum target;
    GLdouble s __attribute__ ((aligned(8)));
} ARGS_glMultiTexCoord1d;
typedef struct {
    int index;
    ARGS_glMultiTexCoord1d args;
} PACKED_glMultiTexCoord1d;
typedef struct {
    GLenum target;
    GLdouble s __attribute__ ((aligned(8)));
} ARGS_glMultiTexCoord1dARB;
typedef struct {
    int index;
    ARGS_glMultiTexCoord1dARB args;
} PACKED_glMultiTexCoord1dARB;
typedef struct {
    GLenum target;
    GLdouble * v;
} ARGS_glMultiTexCoord1dv;
typedef struct {
    int index;
    ARGS_glMultiTexCoord1dv args;
} PACKED_glMultiTexCoord1dv;
typedef struct {
    GLenum target;
    GLdouble * v;
} ARGS_glMultiTexCoord1dvARB;
typedef struct {
    int index;
    ARGS_glMultiTexCoord1dvARB args;
} PACKED_glMultiTexCoord1dvARB;
typedef struct {
    GLenum target;
    GLfloat s;
} ARGS_glMultiTexCoord1f;
typedef struct {
    int index;
    ARGS_glMultiTexCoord1f args;
} PACKED_glMultiTexCoord1f;
typedef struct {
    GLenum target;
    GLfloat s;
} ARGS_glMultiTexCoord1fARB;
typedef struct {
    int index;
    ARGS_glMultiTexCoord1fARB args;
} PACKED_glMultiTexCoord1fARB;
typedef struct {
    GLenum target;
    GLfloat * v;
} ARGS_glMultiTexCoord1fv;
typedef struct {
    int index;
    ARGS_glMultiTexCoord1fv args;
} PACKED_glMultiTexCoord1fv;
typedef struct {
    GLenum target;
    GLfloat * v;
} ARGS_glMultiTexCoord1fvARB;
typedef struct {
    int index;
    ARGS_glMultiTexCoord1fvARB args;
} PACKED_glMultiTexCoord1fvARB;
typedef struct {
    GLenum target;
    GLhalfNV s;
} ARGS_glMultiTexCoord1hNV;
typedef struct {
    int index;
    ARGS_glMultiTexCoord1hNV args;
} PACKED_glMultiTexCoord1hNV;
typedef struct {
    GLenum target;
    GLhalfNV * v;
} ARGS_glMultiTexCoord1hvNV;
typedef struct {
    int index;
    ARGS_glMultiTexCoord1hvNV args;
} PACKED_glMultiTexCoord1hvNV;
typedef struct {
    GLenum target;
    GLint s;
} ARGS_glMultiTexCoord1i;
typedef struct {
    int index;
    ARGS_glMultiTexCoord1i args;
} PACKED_glMultiTexCoord1i;
typedef struct {
    GLenum target;
    GLint s;
} ARGS_glMultiTexCoord1iARB;
typedef struct {
    int index;
    ARGS_glMultiTexCoord1iARB args;
} PACKED_glMultiTexCoord1iARB;
typedef struct {
    GLenum target;
    GLint * v;
} ARGS_glMultiTexCoord1iv;
typedef struct {
    int index;
    ARGS_glMultiTexCoord1iv args;
} PACKED_glMultiTexCoord1iv;
typedef struct {
    GLenum target;
    GLint * v;
} ARGS_glMultiTexCoord1ivARB;
typedef struct {
    int index;
    ARGS_glMultiTexCoord1ivARB args;
} PACKED_glMultiTexCoord1ivARB;
typedef struct {
    GLenum target;
    GLshort s;
} ARGS_glMultiTexCoord1s;
typedef struct {
    int index;
    ARGS_glMultiTexCoord1s args;
} PACKED_glMultiTexCoord1s;
typedef struct {
    GLenum target;
    GLshort s;
} ARGS_glMultiTexCoord1sARB;
typedef struct {
    int index;
    ARGS_glMultiTexCoord1sARB args;
} PACKED_glMultiTexCoord1sARB;
typedef struct {
    GLenum target;
    GLshort * v;
} ARGS_glMultiTexCoord1sv;
typedef struct {
    int index;
    ARGS_glMultiTexCoord1sv args;
} PACKED_glMultiTexCoord1sv;
typedef struct {
    GLenum target;
    GLshort * v;
} ARGS_glMultiTexCoord1svARB;
typedef struct {
    int index;
    ARGS_glMultiTexCoord1svARB args;
} PACKED_glMultiTexCoord1svARB;
typedef struct {
    GLenum texture;
    GLfixed s;
} ARGS_glMultiTexCoord1xOES;
typedef struct {
    int index;
    ARGS_glMultiTexCoord1xOES args;
} PACKED_glMultiTexCoord1xOES;
typedef struct {
    GLenum texture;
    GLfixed * coords;
} ARGS_glMultiTexCoord1xvOES;
typedef struct {
    int index;
    ARGS_glMultiTexCoord1xvOES args;
} PACKED_glMultiTexCoord1xvOES;
typedef struct {
    GLenum texture;
    GLbyte s;
    GLbyte t;
} ARGS_glMultiTexCoord2bOES;
typedef struct {
    int index;
    ARGS_glMultiTexCoord2bOES args;
} PACKED_glMultiTexCoord2bOES;
typedef struct {
    GLenum texture;
    GLbyte * coords;
} ARGS_glMultiTexCoord2bvOES;
typedef struct {
    int index;
    ARGS_glMultiTexCoord2bvOES args;
} PACKED_glMultiTexCoord2bvOES;
typedef struct {
    GLenum target;
    GLdouble s __attribute__ ((aligned(8)));
    GLdouble t __attribute__ ((aligned(8)));
} ARGS_glMultiTexCoord2d;
typedef struct {
    int index;
    ARGS_glMultiTexCoord2d args;
} PACKED_glMultiTexCoord2d;
typedef struct {
    GLenum target;
    GLdouble s __attribute__ ((aligned(8)));
    GLdouble t __attribute__ ((aligned(8)));
} ARGS_glMultiTexCoord2dARB;
typedef struct {
    int index;
    ARGS_glMultiTexCoord2dARB args;
} PACKED_glMultiTexCoord2dARB;
typedef struct {
    GLenum target;
    GLdouble * v;
} ARGS_glMultiTexCoord2dv;
typedef struct {
    int index;
    ARGS_glMultiTexCoord2dv args;
} PACKED_glMultiTexCoord2dv;
typedef struct {
    GLenum target;
    GLdouble * v;
} ARGS_glMultiTexCoord2dvARB;
typedef struct {
    int index;
    ARGS_glMultiTexCoord2dvARB args;
} PACKED_glMultiTexCoord2dvARB;
typedef struct {
    GLenum target;
    GLfloat s;
    GLfloat t;
} ARGS_glMultiTexCoord2f;
typedef struct {
    int index;
    ARGS_glMultiTexCoord2f args;
} PACKED_glMultiTexCoord2f;
typedef struct {
    GLenum target;
    GLfloat s;
    GLfloat t;
} ARGS_glMultiTexCoord2fARB;
typedef struct {
    int index;
    ARGS_glMultiTexCoord2fARB args;
} PACKED_glMultiTexCoord2fARB;
typedef struct {
    GLenum target;
    GLfloat * v;
} ARGS_glMultiTexCoord2fv;
typedef struct {
    int index;
    ARGS_glMultiTexCoord2fv args;
} PACKED_glMultiTexCoord2fv;
typedef struct {
    GLenum target;
    GLfloat * v;
} ARGS_glMultiTexCoord2fvARB;
typedef struct {
    int index;
    ARGS_glMultiTexCoord2fvARB args;
} PACKED_glMultiTexCoord2fvARB;
typedef struct {
    GLenum target;
    GLhalfNV s;
    GLhalfNV t;
} ARGS_glMultiTexCoord2hNV;
typedef struct {
    int index;
    ARGS_glMultiTexCoord2hNV args;
} PACKED_glMultiTexCoord2hNV;
typedef struct {
    GLenum target;
    GLhalfNV * v;
} ARGS_glMultiTexCoord2hvNV;
typedef struct {
    int index;
    ARGS_glMultiTexCoord2hvNV args;
} PACKED_glMultiTexCoord2hvNV;
typedef struct {
    GLenum target;
    GLint s;
    GLint t;
} ARGS_glMultiTexCoord2i;
typedef struct {
    int index;
    ARGS_glMultiTexCoord2i args;
} PACKED_glMultiTexCoord2i;
typedef struct {
    GLenum target;
    GLint s;
    GLint t;
} ARGS_glMultiTexCoord2iARB;
typedef struct {
    int index;
    ARGS_glMultiTexCoord2iARB args;
} PACKED_glMultiTexCoord2iARB;
typedef struct {
    GLenum target;
    GLint * v;
} ARGS_glMultiTexCoord2iv;
typedef struct {
    int index;
    ARGS_glMultiTexCoord2iv args;
} PACKED_glMultiTexCoord2iv;
typedef struct {
    GLenum target;
    GLint * v;
} ARGS_glMultiTexCoord2ivARB;
typedef struct {
    int index;
    ARGS_glMultiTexCoord2ivARB args;
} PACKED_glMultiTexCoord2ivARB;
typedef struct {
    GLenum target;
    GLshort s;
    GLshort t;
} ARGS_glMultiTexCoord2s;
typedef struct {
    int index;
    ARGS_glMultiTexCoord2s args;
} PACKED_glMultiTexCoord2s;
typedef struct {
    GLenum target;
    GLshort s;
    GLshort t;
} ARGS_glMultiTexCoord2sARB;
typedef struct {
    int index;
    ARGS_glMultiTexCoord2sARB args;
} PACKED_glMultiTexCoord2sARB;
typedef struct {
    GLenum target;
    GLshort * v;
} ARGS_glMultiTexCoord2sv;
typedef struct {
    int index;
    ARGS_glMultiTexCoord2sv args;
} PACKED_glMultiTexCoord2sv;
typedef struct {
    GLenum target;
    GLshort * v;
} ARGS_glMultiTexCoord2svARB;
typedef struct {
    int index;
    ARGS_glMultiTexCoord2svARB args;
} PACKED_glMultiTexCoord2svARB;
typedef struct {
    GLenum texture;
    GLfixed s;
    GLfixed t;
} ARGS_glMultiTexCoord2xOES;
typedef struct {
    int index;
    ARGS_glMultiTexCoord2xOES args;
} PACKED_glMultiTexCoord2xOES;
typedef struct {
    GLenum texture;
    GLfixed * coords;
} ARGS_glMultiTexCoord2xvOES;
typedef struct {
    int index;
    ARGS_glMultiTexCoord2xvOES args;
} PACKED_glMultiTexCoord2xvOES;
typedef struct {
    GLenum texture;
    GLbyte s;
    GLbyte t;
    GLbyte r;
} ARGS_glMultiTexCoord3bOES;
typedef struct {
    int index;
    ARGS_glMultiTexCoord3bOES args;
} PACKED_glMultiTexCoord3bOES;
typedef struct {
    GLenum texture;
    GLbyte * coords;
} ARGS_glMultiTexCoord3bvOES;
typedef struct {
    int index;
    ARGS_glMultiTexCoord3bvOES args;
} PACKED_glMultiTexCoord3bvOES;
typedef struct {
    GLenum target;
    GLdouble s __attribute__ ((aligned(8)));
    GLdouble t __attribute__ ((aligned(8)));
    GLdouble r __attribute__ ((aligned(8)));
} ARGS_glMultiTexCoord3d;
typedef struct {
    int index;
    ARGS_glMultiTexCoord3d args;
} PACKED_glMultiTexCoord3d;
typedef struct {
    GLenum target;
    GLdouble s __attribute__ ((aligned(8)));
    GLdouble t __attribute__ ((aligned(8)));
    GLdouble r __attribute__ ((aligned(8)));
} ARGS_glMultiTexCoord3dARB;
typedef struct {
    int index;
    ARGS_glMultiTexCoord3dARB args;
} PACKED_glMultiTexCoord3dARB;
typedef struct {
    GLenum target;
    GLdouble * v;
} ARGS_glMultiTexCoord3dv;
typedef struct {
    int index;
    ARGS_glMultiTexCoord3dv args;
} PACKED_glMultiTexCoord3dv;
typedef struct {
    GLenum target;
    GLdouble * v;
} ARGS_glMultiTexCoord3dvARB;
typedef struct {
    int index;
    ARGS_glMultiTexCoord3dvARB args;
} PACKED_glMultiTexCoord3dvARB;
typedef struct {
    GLenum target;
    GLfloat s;
    GLfloat t;
    GLfloat r;
} ARGS_glMultiTexCoord3f;
typedef struct {
    int index;
    ARGS_glMultiTexCoord3f args;
} PACKED_glMultiTexCoord3f;
typedef struct {
    GLenum target;
    GLfloat s;
    GLfloat t;
    GLfloat r;
} ARGS_glMultiTexCoord3fARB;
typedef struct {
    int index;
    ARGS_glMultiTexCoord3fARB args;
} PACKED_glMultiTexCoord3fARB;
typedef struct {
    GLenum target;
    GLfloat * v;
} ARGS_glMultiTexCoord3fv;
typedef struct {
    int index;
    ARGS_glMultiTexCoord3fv args;
} PACKED_glMultiTexCoord3fv;
typedef struct {
    GLenum target;
    GLfloat * v;
} ARGS_glMultiTexCoord3fvARB;
typedef struct {
    int index;
    ARGS_glMultiTexCoord3fvARB args;
} PACKED_glMultiTexCoord3fvARB;
typedef struct {
    GLenum target;
    GLhalfNV s;
    GLhalfNV t;
    GLhalfNV r;
} ARGS_glMultiTexCoord3hNV;
typedef struct {
    int index;
    ARGS_glMultiTexCoord3hNV args;
} PACKED_glMultiTexCoord3hNV;
typedef struct {
    GLenum target;
    GLhalfNV * v;
} ARGS_glMultiTexCoord3hvNV;
typedef struct {
    int index;
    ARGS_glMultiTexCoord3hvNV args;
} PACKED_glMultiTexCoord3hvNV;
typedef struct {
    GLenum target;
    GLint s;
    GLint t;
    GLint r;
} ARGS_glMultiTexCoord3i;
typedef struct {
    int index;
    ARGS_glMultiTexCoord3i args;
} PACKED_glMultiTexCoord3i;
typedef struct {
    GLenum target;
    GLint s;
    GLint t;
    GLint r;
} ARGS_glMultiTexCoord3iARB;
typedef struct {
    int index;
    ARGS_glMultiTexCoord3iARB args;
} PACKED_glMultiTexCoord3iARB;
typedef struct {
    GLenum target;
    GLint * v;
} ARGS_glMultiTexCoord3iv;
typedef struct {
    int index;
    ARGS_glMultiTexCoord3iv args;
} PACKED_glMultiTexCoord3iv;
typedef struct {
    GLenum target;
    GLint * v;
} ARGS_glMultiTexCoord3ivARB;
typedef struct {
    int index;
    ARGS_glMultiTexCoord3ivARB args;
} PACKED_glMultiTexCoord3ivARB;
typedef struct {
    GLenum target;
    GLshort s;
    GLshort t;
    GLshort r;
} ARGS_glMultiTexCoord3s;
typedef struct {
    int index;
    ARGS_glMultiTexCoord3s args;
} PACKED_glMultiTexCoord3s;
typedef struct {
    GLenum target;
    GLshort s;
    GLshort t;
    GLshort r;
} ARGS_glMultiTexCoord3sARB;
typedef struct {
    int index;
    ARGS_glMultiTexCoord3sARB args;
} PACKED_glMultiTexCoord3sARB;
typedef struct {
    GLenum target;
    GLshort * v;
} ARGS_glMultiTexCoord3sv;
typedef struct {
    int index;
    ARGS_glMultiTexCoord3sv args;
} PACKED_glMultiTexCoord3sv;
typedef struct {
    GLenum target;
    GLshort * v;
} ARGS_glMultiTexCoord3svARB;
typedef struct {
    int index;
    ARGS_glMultiTexCoord3svARB args;
} PACKED_glMultiTexCoord3svARB;
typedef struct {
    GLenum texture;
    GLfixed s;
    GLfixed t;
    GLfixed r;
} ARGS_glMultiTexCoord3xOES;
typedef struct {
    int index;
    ARGS_glMultiTexCoord3xOES args;
} PACKED_glMultiTexCoord3xOES;
typedef struct {
    GLenum texture;
    GLfixed * coords;
} ARGS_glMultiTexCoord3xvOES;
typedef struct {
    int index;
    ARGS_glMultiTexCoord3xvOES args;
} PACKED_glMultiTexCoord3xvOES;
typedef struct {
    GLenum texture;
    GLbyte s;
    GLbyte t;
    GLbyte r;
    GLbyte q;
} ARGS_glMultiTexCoord4bOES;
typedef struct {
    int index;
    ARGS_glMultiTexCoord4bOES args;
} PACKED_glMultiTexCoord4bOES;
typedef struct {
    GLenum texture;
    GLbyte * coords;
} ARGS_glMultiTexCoord4bvOES;
typedef struct {
    int index;
    ARGS_glMultiTexCoord4bvOES args;
} PACKED_glMultiTexCoord4bvOES;
typedef struct {
    GLenum target;
    GLdouble s __attribute__ ((aligned(8)));
    GLdouble t __attribute__ ((aligned(8)));
    GLdouble r __attribute__ ((aligned(8)));
    GLdouble q __attribute__ ((aligned(8)));
} ARGS_glMultiTexCoord4d;
typedef struct {
    int index;
    ARGS_glMultiTexCoord4d args;
} PACKED_glMultiTexCoord4d;
typedef struct {
    GLenum target;
    GLdouble s __attribute__ ((aligned(8)));
    GLdouble t __attribute__ ((aligned(8)));
    GLdouble r __attribute__ ((aligned(8)));
    GLdouble q __attribute__ ((aligned(8)));
} ARGS_glMultiTexCoord4dARB;
typedef struct {
    int index;
    ARGS_glMultiTexCoord4dARB args;
} PACKED_glMultiTexCoord4dARB;
typedef struct {
    GLenum target;
    GLdouble * v;
} ARGS_glMultiTexCoord4dv;
typedef struct {
    int index;
    ARGS_glMultiTexCoord4dv args;
} PACKED_glMultiTexCoord4dv;
typedef struct {
    GLenum target;
    GLdouble * v;
} ARGS_glMultiTexCoord4dvARB;
typedef struct {
    int index;
    ARGS_glMultiTexCoord4dvARB args;
} PACKED_glMultiTexCoord4dvARB;
typedef struct {
    GLenum target;
    GLfloat s;
    GLfloat t;
    GLfloat r;
    GLfloat q;
} ARGS_glMultiTexCoord4f;
typedef struct {
    int index;
    ARGS_glMultiTexCoord4f args;
} PACKED_glMultiTexCoord4f;
typedef struct {
    GLenum target;
    GLfloat s;
    GLfloat t;
    GLfloat r;
    GLfloat q;
} ARGS_glMultiTexCoord4fARB;
typedef struct {
    int index;
    ARGS_glMultiTexCoord4fARB args;
} PACKED_glMultiTexCoord4fARB;
typedef struct {
    GLenum target;
    GLfloat * v;
} ARGS_glMultiTexCoord4fv;
typedef struct {
    int index;
    ARGS_glMultiTexCoord4fv args;
} PACKED_glMultiTexCoord4fv;
typedef struct {
    GLenum target;
    GLfloat * v;
} ARGS_glMultiTexCoord4fvARB;
typedef struct {
    int index;
    ARGS_glMultiTexCoord4fvARB args;
} PACKED_glMultiTexCoord4fvARB;
typedef struct {
    GLenum target;
    GLhalfNV s;
    GLhalfNV t;
    GLhalfNV r;
    GLhalfNV q;
} ARGS_glMultiTexCoord4hNV;
typedef struct {
    int index;
    ARGS_glMultiTexCoord4hNV args;
} PACKED_glMultiTexCoord4hNV;
typedef struct {
    GLenum target;
    GLhalfNV * v;
} ARGS_glMultiTexCoord4hvNV;
typedef struct {
    int index;
    ARGS_glMultiTexCoord4hvNV args;
} PACKED_glMultiTexCoord4hvNV;
typedef struct {
    GLenum target;
    GLint s;
    GLint t;
    GLint r;
    GLint q;
} ARGS_glMultiTexCoord4i;
typedef struct {
    int index;
    ARGS_glMultiTexCoord4i args;
} PACKED_glMultiTexCoord4i;
typedef struct {
    GLenum target;
    GLint s;
    GLint t;
    GLint r;
    GLint q;
} ARGS_glMultiTexCoord4iARB;
typedef struct {
    int index;
    ARGS_glMultiTexCoord4iARB args;
} PACKED_glMultiTexCoord4iARB;
typedef struct {
    GLenum target;
    GLint * v;
} ARGS_glMultiTexCoord4iv;
typedef struct {
    int index;
    ARGS_glMultiTexCoord4iv args;
} PACKED_glMultiTexCoord4iv;
typedef struct {
    GLenum target;
    GLint * v;
} ARGS_glMultiTexCoord4ivARB;
typedef struct {
    int index;
    ARGS_glMultiTexCoord4ivARB args;
} PACKED_glMultiTexCoord4ivARB;
typedef struct {
    GLenum target;
    GLshort s;
    GLshort t;
    GLshort r;
    GLshort q;
} ARGS_glMultiTexCoord4s;
typedef struct {
    int index;
    ARGS_glMultiTexCoord4s args;
} PACKED_glMultiTexCoord4s;
typedef struct {
    GLenum target;
    GLshort s;
    GLshort t;
    GLshort r;
    GLshort q;
} ARGS_glMultiTexCoord4sARB;
typedef struct {
    int index;
    ARGS_glMultiTexCoord4sARB args;
} PACKED_glMultiTexCoord4sARB;
typedef struct {
    GLenum target;
    GLshort * v;
} ARGS_glMultiTexCoord4sv;
typedef struct {
    int index;
    ARGS_glMultiTexCoord4sv args;
} PACKED_glMultiTexCoord4sv;
typedef struct {
    GLenum target;
    GLshort * v;
} ARGS_glMultiTexCoord4svARB;
typedef struct {
    int index;
    ARGS_glMultiTexCoord4svARB args;
} PACKED_glMultiTexCoord4svARB;
typedef struct {
    GLenum target;
    GLfixed s;
    GLfixed t;
    GLfixed r;
    GLfixed q;
} ARGS_glMultiTexCoord4x;
typedef struct {
    int index;
    ARGS_glMultiTexCoord4x args;
} PACKED_glMultiTexCoord4x;
typedef struct {
    GLenum texture;
    GLfixed s;
    GLfixed t;
    GLfixed r;
    GLfixed q;
} ARGS_glMultiTexCoord4xOES;
typedef struct {
    int index;
    ARGS_glMultiTexCoord4xOES args;
} PACKED_glMultiTexCoord4xOES;
typedef struct {
    GLenum texture;
    GLfixed * coords;
} ARGS_glMultiTexCoord4xvOES;
typedef struct {
    int index;
    ARGS_glMultiTexCoord4xvOES args;
} PACKED_glMultiTexCoord4xvOES;
typedef struct {
    GLenum texture;
    GLenum type;
    GLuint coords;
} ARGS_glMultiTexCoordP1ui;
typedef struct {
    int index;
    ARGS_glMultiTexCoordP1ui args;
} PACKED_glMultiTexCoordP1ui;
typedef struct {
    GLenum texture;
    GLenum type;
    GLuint * coords;
} ARGS_glMultiTexCoordP1uiv;
typedef struct {
    int index;
    ARGS_glMultiTexCoordP1uiv args;
} PACKED_glMultiTexCoordP1uiv;
typedef struct {
    GLenum texture;
    GLenum type;
    GLuint coords;
} ARGS_glMultiTexCoordP2ui;
typedef struct {
    int index;
    ARGS_glMultiTexCoordP2ui args;
} PACKED_glMultiTexCoordP2ui;
typedef struct {
    GLenum texture;
    GLenum type;
    GLuint * coords;
} ARGS_glMultiTexCoordP2uiv;
typedef struct {
    int index;
    ARGS_glMultiTexCoordP2uiv args;
} PACKED_glMultiTexCoordP2uiv;
typedef struct {
    GLenum texture;
    GLenum type;
    GLuint coords;
} ARGS_glMultiTexCoordP3ui;
typedef struct {
    int index;
    ARGS_glMultiTexCoordP3ui args;
} PACKED_glMultiTexCoordP3ui;
typedef struct {
    GLenum texture;
    GLenum type;
    GLuint * coords;
} ARGS_glMultiTexCoordP3uiv;
typedef struct {
    int index;
    ARGS_glMultiTexCoordP3uiv args;
} PACKED_glMultiTexCoordP3uiv;
typedef struct {
    GLenum texture;
    GLenum type;
    GLuint coords;
} ARGS_glMultiTexCoordP4ui;
typedef struct {
    int index;
    ARGS_glMultiTexCoordP4ui args;
} PACKED_glMultiTexCoordP4ui;
typedef struct {
    GLenum texture;
    GLenum type;
    GLuint * coords;
} ARGS_glMultiTexCoordP4uiv;
typedef struct {
    int index;
    ARGS_glMultiTexCoordP4uiv args;
} PACKED_glMultiTexCoordP4uiv;
typedef struct {
    GLenum texunit;
    GLint size;
    GLenum type;
    GLsizei stride;
    GLvoid * pointer;
} ARGS_glMultiTexCoordPointerEXT;
typedef struct {
    int index;
    ARGS_glMultiTexCoordPointerEXT args;
} PACKED_glMultiTexCoordPointerEXT;
typedef struct {
    GLenum texunit;
    GLenum target;
    GLenum pname;
    GLfloat param;
} ARGS_glMultiTexEnvfEXT;
typedef struct {
    int index;
    ARGS_glMultiTexEnvfEXT args;
} PACKED_glMultiTexEnvfEXT;
typedef struct {
    GLenum texunit;
    GLenum target;
    GLenum pname;
    GLfloat * params;
} ARGS_glMultiTexEnvfvEXT;
typedef struct {
    int index;
    ARGS_glMultiTexEnvfvEXT args;
} PACKED_glMultiTexEnvfvEXT;
typedef struct {
    GLenum texunit;
    GLenum target;
    GLenum pname;
    GLint param;
} ARGS_glMultiTexEnviEXT;
typedef struct {
    int index;
    ARGS_glMultiTexEnviEXT args;
} PACKED_glMultiTexEnviEXT;
typedef struct {
    GLenum texunit;
    GLenum target;
    GLenum pname;
    GLint * params;
} ARGS_glMultiTexEnvivEXT;
typedef struct {
    int index;
    ARGS_glMultiTexEnvivEXT args;
} PACKED_glMultiTexEnvivEXT;
typedef struct {
    GLenum texunit;
    GLenum coord;
    GLenum pname;
    GLdouble param __attribute__ ((aligned(8)));
} ARGS_glMultiTexGendEXT;
typedef struct {
    int index;
    ARGS_glMultiTexGendEXT args;
} PACKED_glMultiTexGendEXT;
typedef struct {
    GLenum texunit;
    GLenum coord;
    GLenum pname;
    GLdouble * params;
} ARGS_glMultiTexGendvEXT;
typedef struct {
    int index;
    ARGS_glMultiTexGendvEXT args;
} PACKED_glMultiTexGendvEXT;
typedef struct {
    GLenum texunit;
    GLenum coord;
    GLenum pname;
    GLfloat param;
} ARGS_glMultiTexGenfEXT;
typedef struct {
    int index;
    ARGS_glMultiTexGenfEXT args;
} PACKED_glMultiTexGenfEXT;
typedef struct {
    GLenum texunit;
    GLenum coord;
    GLenum pname;
    GLfloat * params;
} ARGS_glMultiTexGenfvEXT;
typedef struct {
    int index;
    ARGS_glMultiTexGenfvEXT args;
} PACKED_glMultiTexGenfvEXT;
typedef struct {
    GLenum texunit;
    GLenum coord;
    GLenum pname;
    GLint param;
} ARGS_glMultiTexGeniEXT;
typedef struct {
    int index;
    ARGS_glMultiTexGeniEXT args;
} PACKED_glMultiTexGeniEXT;
typedef struct {
    GLenum texunit;
    GLenum coord;
    GLenum pname;
    GLint * params;
} ARGS_glMultiTexGenivEXT;
typedef struct {
    int index;
    ARGS_glMultiTexGenivEXT args;
} PACKED_glMultiTexGenivEXT;
typedef struct {
    GLenum texunit;
    GLenum target;
    GLint level;
    GLenum internalformat;
    GLsizei width;
    GLint border;
    GLenum format;
    GLenum type;
    GLvoid * pixels;
} ARGS_glMultiTexImage1DEXT;
typedef struct {
    int index;
    ARGS_glMultiTexImage1DEXT args;
} PACKED_glMultiTexImage1DEXT;
typedef struct {
    GLenum texunit;
    GLenum target;
    GLint level;
    GLenum internalformat;
    GLsizei width;
    GLsizei height;
    GLint border;
    GLenum format;
    GLenum type;
    GLvoid * pixels;
} ARGS_glMultiTexImage2DEXT;
typedef struct {
    int index;
    ARGS_glMultiTexImage2DEXT args;
} PACKED_glMultiTexImage2DEXT;
typedef struct {
    GLenum texunit;
    GLenum target;
    GLint level;
    GLenum internalformat;
    GLsizei width;
    GLsizei height;
    GLsizei depth;
    GLint border;
    GLenum format;
    GLenum type;
    GLvoid * pixels;
} ARGS_glMultiTexImage3DEXT;
typedef struct {
    int index;
    ARGS_glMultiTexImage3DEXT args;
} PACKED_glMultiTexImage3DEXT;
typedef struct {
    GLenum texunit;
    GLenum target;
    GLenum pname;
    GLint * params;
} ARGS_glMultiTexParameterIivEXT;
typedef struct {
    int index;
    ARGS_glMultiTexParameterIivEXT args;
} PACKED_glMultiTexParameterIivEXT;
typedef struct {
    GLenum texunit;
    GLenum target;
    GLenum pname;
    GLuint * params;
} ARGS_glMultiTexParameterIuivEXT;
typedef struct {
    int index;
    ARGS_glMultiTexParameterIuivEXT args;
} PACKED_glMultiTexParameterIuivEXT;
typedef struct {
    GLenum texunit;
    GLenum target;
    GLenum pname;
    GLfloat param;
} ARGS_glMultiTexParameterfEXT;
typedef struct {
    int index;
    ARGS_glMultiTexParameterfEXT args;
} PACKED_glMultiTexParameterfEXT;
typedef struct {
    GLenum texunit;
    GLenum target;
    GLenum pname;
    GLfloat * params;
} ARGS_glMultiTexParameterfvEXT;
typedef struct {
    int index;
    ARGS_glMultiTexParameterfvEXT args;
} PACKED_glMultiTexParameterfvEXT;
typedef struct {
    GLenum texunit;
    GLenum target;
    GLenum pname;
    GLint param;
} ARGS_glMultiTexParameteriEXT;
typedef struct {
    int index;
    ARGS_glMultiTexParameteriEXT args;
} PACKED_glMultiTexParameteriEXT;
typedef struct {
    GLenum texunit;
    GLenum target;
    GLenum pname;
    GLint * params;
} ARGS_glMultiTexParameterivEXT;
typedef struct {
    int index;
    ARGS_glMultiTexParameterivEXT args;
} PACKED_glMultiTexParameterivEXT;
typedef struct {
    GLenum texunit;
    GLenum target;
    GLuint renderbuffer;
} ARGS_glMultiTexRenderbufferEXT;
typedef struct {
    int index;
    ARGS_glMultiTexRenderbufferEXT args;
} PACKED_glMultiTexRenderbufferEXT;
typedef struct {
    GLenum texunit;
    GLenum target;
    GLint level;
    GLint xoffset;
    GLsizei width;
    GLenum format;
    GLenum type;
    GLvoid * pixels;
} ARGS_glMultiTexSubImage1DEXT;
typedef struct {
    int index;
    ARGS_glMultiTexSubImage1DEXT args;
} PACKED_glMultiTexSubImage1DEXT;
typedef struct {
    GLenum texunit;
    GLenum target;
    GLint level;
    GLint xoffset;
    GLint yoffset;
    GLsizei width;
    GLsizei height;
    GLenum format;
    GLenum type;
    GLvoid * pixels;
} ARGS_glMultiTexSubImage2DEXT;
typedef struct {
    int index;
    ARGS_glMultiTexSubImage2DEXT args;
} PACKED_glMultiTexSubImage2DEXT;
typedef struct {
    GLenum texunit;
    GLenum target;
    GLint level;
    GLint xoffset;
    GLint yoffset;
    GLint zoffset;
    GLsizei width;
    GLsizei height;
    GLsizei depth;
    GLenum format;
    GLenum type;
    GLvoid * pixels;
} ARGS_glMultiTexSubImage3DEXT;
typedef struct {
    int index;
    ARGS_glMultiTexSubImage3DEXT args;
} PACKED_glMultiTexSubImage3DEXT;
typedef struct {
    GLuint buffer;
    GLsizeiptr size;
    GLvoid * data;
    GLenum usage;
} ARGS_glNamedBufferDataEXT;
typedef struct {
    int index;
    ARGS_glNamedBufferDataEXT args;
} PACKED_glNamedBufferDataEXT;
typedef struct {
    GLuint buffer;
    GLintptr offset;
    GLsizeiptr size;
    GLvoid * data;
} ARGS_glNamedBufferSubDataEXT;
typedef struct {
    int index;
    ARGS_glNamedBufferSubDataEXT args;
} PACKED_glNamedBufferSubDataEXT;
typedef struct {
    GLuint readBuffer;
    GLuint writeBuffer;
    GLintptr readOffset;
    GLintptr writeOffset;
    GLsizeiptr size;
} ARGS_glNamedCopyBufferSubDataEXT;
typedef struct {
    int index;
    ARGS_glNamedCopyBufferSubDataEXT args;
} PACKED_glNamedCopyBufferSubDataEXT;
typedef struct {
    GLuint framebuffer;
    GLenum pname;
    GLint param;
} ARGS_glNamedFramebufferParameteriEXT;
typedef struct {
    int index;
    ARGS_glNamedFramebufferParameteriEXT args;
} PACKED_glNamedFramebufferParameteriEXT;
typedef struct {
    GLuint framebuffer;
    GLenum attachment;
    GLenum renderbuffertarget;
    GLuint renderbuffer;
} ARGS_glNamedFramebufferRenderbufferEXT;
typedef struct {
    int index;
    ARGS_glNamedFramebufferRenderbufferEXT args;
} PACKED_glNamedFramebufferRenderbufferEXT;
typedef struct {
    GLuint framebuffer;
    GLenum attachment;
    GLenum textarget;
    GLuint texture;
    GLint level;
} ARGS_glNamedFramebufferTexture1DEXT;
typedef struct {
    int index;
    ARGS_glNamedFramebufferTexture1DEXT args;
} PACKED_glNamedFramebufferTexture1DEXT;
typedef struct {
    GLuint framebuffer;
    GLenum attachment;
    GLenum textarget;
    GLuint texture;
    GLint level;
} ARGS_glNamedFramebufferTexture2DEXT;
typedef struct {
    int index;
    ARGS_glNamedFramebufferTexture2DEXT args;
} PACKED_glNamedFramebufferTexture2DEXT;
typedef struct {
    GLuint framebuffer;
    GLenum attachment;
    GLenum textarget;
    GLuint texture;
    GLint level;
    GLint zoffset;
} ARGS_glNamedFramebufferTexture3DEXT;
typedef struct {
    int index;
    ARGS_glNamedFramebufferTexture3DEXT args;
} PACKED_glNamedFramebufferTexture3DEXT;
typedef struct {
    GLuint framebuffer;
    GLenum attachment;
    GLuint texture;
    GLint level;
} ARGS_glNamedFramebufferTextureEXT;
typedef struct {
    int index;
    ARGS_glNamedFramebufferTextureEXT args;
} PACKED_glNamedFramebufferTextureEXT;
typedef struct {
    GLuint framebuffer;
    GLenum attachment;
    GLuint texture;
    GLint level;
    GLenum face;
} ARGS_glNamedFramebufferTextureFaceEXT;
typedef struct {
    int index;
    ARGS_glNamedFramebufferTextureFaceEXT args;
} PACKED_glNamedFramebufferTextureFaceEXT;
typedef struct {
    GLuint framebuffer;
    GLenum attachment;
    GLuint texture;
    GLint level;
    GLint layer;
} ARGS_glNamedFramebufferTextureLayerEXT;
typedef struct {
    int index;
    ARGS_glNamedFramebufferTextureLayerEXT args;
} PACKED_glNamedFramebufferTextureLayerEXT;
typedef struct {
    GLuint program;
    GLenum target;
    GLuint index;
    GLdouble x __attribute__ ((aligned(8)));
    GLdouble y __attribute__ ((aligned(8)));
    GLdouble z __attribute__ ((aligned(8)));
    GLdouble w __attribute__ ((aligned(8)));
} ARGS_glNamedProgramLocalParameter4dEXT;
typedef struct {
    int index;
    ARGS_glNamedProgramLocalParameter4dEXT args;
} PACKED_glNamedProgramLocalParameter4dEXT;
typedef struct {
    GLuint program;
    GLenum target;
    GLuint index;
    GLdouble * params;
} ARGS_glNamedProgramLocalParameter4dvEXT;
typedef struct {
    int index;
    ARGS_glNamedProgramLocalParameter4dvEXT args;
} PACKED_glNamedProgramLocalParameter4dvEXT;
typedef struct {
    GLuint program;
    GLenum target;
    GLuint index;
    GLfloat x;
    GLfloat y;
    GLfloat z;
    GLfloat w;
} ARGS_glNamedProgramLocalParameter4fEXT;
typedef struct {
    int index;
    ARGS_glNamedProgramLocalParameter4fEXT args;
} PACKED_glNamedProgramLocalParameter4fEXT;
typedef struct {
    GLuint program;
    GLenum target;
    GLuint index;
    GLfloat * params;
} ARGS_glNamedProgramLocalParameter4fvEXT;
typedef struct {
    int index;
    ARGS_glNamedProgramLocalParameter4fvEXT args;
} PACKED_glNamedProgramLocalParameter4fvEXT;
typedef struct {
    GLuint program;
    GLenum target;
    GLuint index;
    GLint x;
    GLint y;
    GLint z;
    GLint w;
} ARGS_glNamedProgramLocalParameterI4iEXT;
typedef struct {
    int index;
    ARGS_glNamedProgramLocalParameterI4iEXT args;
} PACKED_glNamedProgramLocalParameterI4iEXT;
typedef struct {
    GLuint program;
    GLenum target;
    GLuint index;
    GLint * params;
} ARGS_glNamedProgramLocalParameterI4ivEXT;
typedef struct {
    int index;
    ARGS_glNamedProgramLocalParameterI4ivEXT args;
} PACKED_glNamedProgramLocalParameterI4ivEXT;
typedef struct {
    GLuint program;
    GLenum target;
    GLuint index;
    GLuint x;
    GLuint y;
    GLuint z;
    GLuint w;
} ARGS_glNamedProgramLocalParameterI4uiEXT;
typedef struct {
    int index;
    ARGS_glNamedProgramLocalParameterI4uiEXT args;
} PACKED_glNamedProgramLocalParameterI4uiEXT;
typedef struct {
    GLuint program;
    GLenum target;
    GLuint index;
    GLuint * params;
} ARGS_glNamedProgramLocalParameterI4uivEXT;
typedef struct {
    int index;
    ARGS_glNamedProgramLocalParameterI4uivEXT args;
} PACKED_glNamedProgramLocalParameterI4uivEXT;
typedef struct {
    GLuint program;
    GLenum target;
    GLuint index;
    GLsizei count;
    GLfloat * params;
} ARGS_glNamedProgramLocalParameters4fvEXT;
typedef struct {
    int index;
    ARGS_glNamedProgramLocalParameters4fvEXT args;
} PACKED_glNamedProgramLocalParameters4fvEXT;
typedef struct {
    GLuint program;
    GLenum target;
    GLuint index;
    GLsizei count;
    GLint * params;
} ARGS_glNamedProgramLocalParametersI4ivEXT;
typedef struct {
    int index;
    ARGS_glNamedProgramLocalParametersI4ivEXT args;
} PACKED_glNamedProgramLocalParametersI4ivEXT;
typedef struct {
    GLuint program;
    GLenum target;
    GLuint index;
    GLsizei count;
    GLuint * params;
} ARGS_glNamedProgramLocalParametersI4uivEXT;
typedef struct {
    int index;
    ARGS_glNamedProgramLocalParametersI4uivEXT args;
} PACKED_glNamedProgramLocalParametersI4uivEXT;
typedef struct {
    GLuint program;
    GLenum target;
    GLenum format;
    GLsizei len;
    GLvoid * string;
} ARGS_glNamedProgramStringEXT;
typedef struct {
    int index;
    ARGS_glNamedProgramStringEXT args;
} PACKED_glNamedProgramStringEXT;
typedef struct {
    GLuint renderbuffer;
    GLenum internalformat;
    GLsizei width;
    GLsizei height;
} ARGS_glNamedRenderbufferStorageEXT;
typedef struct {
    int index;
    ARGS_glNamedRenderbufferStorageEXT args;
} PACKED_glNamedRenderbufferStorageEXT;
typedef struct {
    GLuint renderbuffer;
    GLsizei coverageSamples;
    GLsizei colorSamples;
    GLenum internalformat;
    GLsizei width;
    GLsizei height;
} ARGS_glNamedRenderbufferStorageMultisampleCoverageEXT;
typedef struct {
    int index;
    ARGS_glNamedRenderbufferStorageMultisampleCoverageEXT args;
} PACKED_glNamedRenderbufferStorageMultisampleCoverageEXT;
typedef struct {
    GLuint renderbuffer;
    GLsizei samples;
    GLenum internalformat;
    GLsizei width;
    GLsizei height;
} ARGS_glNamedRenderbufferStorageMultisampleEXT;
typedef struct {
    int index;
    ARGS_glNamedRenderbufferStorageMultisampleEXT args;
} PACKED_glNamedRenderbufferStorageMultisampleEXT;
typedef struct {
    GLenum type;
    GLint namelen;
    GLchar * name;
    GLint stringlen;
    GLchar * string;
} ARGS_glNamedStringARB;
typedef struct {
    int index;
    ARGS_glNamedStringARB args;
} PACKED_glNamedStringARB;
typedef struct {
    GLuint list;
    GLenum mode;
} ARGS_glNewList;
typedef struct {
    int index;
    ARGS_glNewList args;
} PACKED_glNewList;
typedef struct {
    GLsizei size;
    GLvoid * pointer;
    GLenum usage;
} ARGS_glNewObjectBufferATI;
typedef struct {
    int index;
    ARGS_glNewObjectBufferATI args;
} PACKED_glNewObjectBufferATI;
typedef struct {
    GLbyte nx;
    GLbyte ny;
    GLbyte nz;
} ARGS_glNormal3b;
typedef struct {
    int index;
    ARGS_glNormal3b args;
} PACKED_glNormal3b;
typedef struct {
    GLbyte * v;
} ARGS_glNormal3bv;
typedef struct {
    int index;
    ARGS_glNormal3bv args;
} PACKED_glNormal3bv;
typedef struct {
    GLdouble nx __attribute__ ((aligned(8)));
    GLdouble ny __attribute__ ((aligned(8)));
    GLdouble nz __attribute__ ((aligned(8)));
} ARGS_glNormal3d;
typedef struct {
    int index;
    ARGS_glNormal3d args;
} PACKED_glNormal3d;
typedef struct {
    GLdouble * v;
} ARGS_glNormal3dv;
typedef struct {
    int index;
    ARGS_glNormal3dv args;
} PACKED_glNormal3dv;
typedef struct {
    GLfloat nx;
    GLfloat ny;
    GLfloat nz;
} ARGS_glNormal3f;
typedef struct {
    int index;
    ARGS_glNormal3f args;
} PACKED_glNormal3f;
typedef struct {
    GLfloat nx;
    GLfloat ny;
    GLfloat nz;
    GLfloat x;
    GLfloat y;
    GLfloat z;
} ARGS_glNormal3fVertex3fSUN;
typedef struct {
    int index;
    ARGS_glNormal3fVertex3fSUN args;
} PACKED_glNormal3fVertex3fSUN;
typedef struct {
    GLfloat * n;
    GLfloat * v;
} ARGS_glNormal3fVertex3fvSUN;
typedef struct {
    int index;
    ARGS_glNormal3fVertex3fvSUN args;
} PACKED_glNormal3fVertex3fvSUN;
typedef struct {
    GLfloat * v;
} ARGS_glNormal3fv;
typedef struct {
    int index;
    ARGS_glNormal3fv args;
} PACKED_glNormal3fv;
typedef struct {
    GLhalfNV nx;
    GLhalfNV ny;
    GLhalfNV nz;
} ARGS_glNormal3hNV;
typedef struct {
    int index;
    ARGS_glNormal3hNV args;
} PACKED_glNormal3hNV;
typedef struct {
    GLhalfNV * v;
} ARGS_glNormal3hvNV;
typedef struct {
    int index;
    ARGS_glNormal3hvNV args;
} PACKED_glNormal3hvNV;
typedef struct {
    GLint nx;
    GLint ny;
    GLint nz;
} ARGS_glNormal3i;
typedef struct {
    int index;
    ARGS_glNormal3i args;
} PACKED_glNormal3i;
typedef struct {
    GLint * v;
} ARGS_glNormal3iv;
typedef struct {
    int index;
    ARGS_glNormal3iv args;
} PACKED_glNormal3iv;
typedef struct {
    GLshort nx;
    GLshort ny;
    GLshort nz;
} ARGS_glNormal3s;
typedef struct {
    int index;
    ARGS_glNormal3s args;
} PACKED_glNormal3s;
typedef struct {
    GLshort * v;
} ARGS_glNormal3sv;
typedef struct {
    int index;
    ARGS_glNormal3sv args;
} PACKED_glNormal3sv;
typedef struct {
    GLfixed nx;
    GLfixed ny;
    GLfixed nz;
} ARGS_glNormal3x;
typedef struct {
    int index;
    ARGS_glNormal3x args;
} PACKED_glNormal3x;
typedef struct {
    GLfixed nx;
    GLfixed ny;
    GLfixed nz;
} ARGS_glNormal3xOES;
typedef struct {
    int index;
    ARGS_glNormal3xOES args;
} PACKED_glNormal3xOES;
typedef struct {
    GLfixed * coords;
} ARGS_glNormal3xvOES;
typedef struct {
    int index;
    ARGS_glNormal3xvOES args;
} PACKED_glNormal3xvOES;
typedef struct {
    GLenum type;
    GLsizei stride;
} ARGS_glNormalFormatNV;
typedef struct {
    int index;
    ARGS_glNormalFormatNV args;
} PACKED_glNormalFormatNV;
typedef struct {
    GLenum type;
    GLuint coords;
} ARGS_glNormalP3ui;
typedef struct {
    int index;
    ARGS_glNormalP3ui args;
} PACKED_glNormalP3ui;
typedef struct {
    GLenum type;
    GLuint * coords;
} ARGS_glNormalP3uiv;
typedef struct {
    int index;
    ARGS_glNormalP3uiv args;
} PACKED_glNormalP3uiv;
typedef struct {
    GLenum type;
    GLsizei stride;
    GLvoid * pointer;
} ARGS_glNormalPointer;
typedef struct {
    int index;
    ARGS_glNormalPointer args;
} PACKED_glNormalPointer;
typedef struct {
    GLenum type;
    GLsizei stride;
    GLsizei count;
    GLvoid * pointer;
} ARGS_glNormalPointerEXT;
typedef struct {
    int index;
    ARGS_glNormalPointerEXT args;
} PACKED_glNormalPointerEXT;
typedef struct {
    GLenum type;
    GLint stride;
    GLvoid * pointer;
    GLint ptrstride;
} ARGS_glNormalPointerListIBM;
typedef struct {
    int index;
    ARGS_glNormalPointerListIBM args;
} PACKED_glNormalPointerListIBM;
typedef struct {
    GLenum type;
    GLvoid * pointer;
} ARGS_glNormalPointervINTEL;
typedef struct {
    int index;
    ARGS_glNormalPointervINTEL args;
} PACKED_glNormalPointervINTEL;
typedef struct {
    GLenum stream;
    GLbyte nx;
    GLbyte ny;
    GLbyte nz;
} ARGS_glNormalStream3bATI;
typedef struct {
    int index;
    ARGS_glNormalStream3bATI args;
} PACKED_glNormalStream3bATI;
typedef struct {
    GLenum stream;
    GLbyte * coords;
} ARGS_glNormalStream3bvATI;
typedef struct {
    int index;
    ARGS_glNormalStream3bvATI args;
} PACKED_glNormalStream3bvATI;
typedef struct {
    GLenum stream;
    GLdouble nx __attribute__ ((aligned(8)));
    GLdouble ny __attribute__ ((aligned(8)));
    GLdouble nz __attribute__ ((aligned(8)));
} ARGS_glNormalStream3dATI;
typedef struct {
    int index;
    ARGS_glNormalStream3dATI args;
} PACKED_glNormalStream3dATI;
typedef struct {
    GLenum stream;
    GLdouble * coords;
} ARGS_glNormalStream3dvATI;
typedef struct {
    int index;
    ARGS_glNormalStream3dvATI args;
} PACKED_glNormalStream3dvATI;
typedef struct {
    GLenum stream;
    GLfloat nx;
    GLfloat ny;
    GLfloat nz;
} ARGS_glNormalStream3fATI;
typedef struct {
    int index;
    ARGS_glNormalStream3fATI args;
} PACKED_glNormalStream3fATI;
typedef struct {
    GLenum stream;
    GLfloat * coords;
} ARGS_glNormalStream3fvATI;
typedef struct {
    int index;
    ARGS_glNormalStream3fvATI args;
} PACKED_glNormalStream3fvATI;
typedef struct {
    GLenum stream;
    GLint nx;
    GLint ny;
    GLint nz;
} ARGS_glNormalStream3iATI;
typedef struct {
    int index;
    ARGS_glNormalStream3iATI args;
} PACKED_glNormalStream3iATI;
typedef struct {
    GLenum stream;
    GLint * coords;
} ARGS_glNormalStream3ivATI;
typedef struct {
    int index;
    ARGS_glNormalStream3ivATI args;
} PACKED_glNormalStream3ivATI;
typedef struct {
    GLenum stream;
    GLshort nx;
    GLshort ny;
    GLshort nz;
} ARGS_glNormalStream3sATI;
typedef struct {
    int index;
    ARGS_glNormalStream3sATI args;
} PACKED_glNormalStream3sATI;
typedef struct {
    GLenum stream;
    GLshort * coords;
} ARGS_glNormalStream3svATI;
typedef struct {
    int index;
    ARGS_glNormalStream3svATI args;
} PACKED_glNormalStream3svATI;
typedef struct {
    GLenum identifier;
    GLuint name;
    GLsizei length;
    GLchar * label;
} ARGS_glObjectLabel;
typedef struct {
    int index;
    ARGS_glObjectLabel args;
} PACKED_glObjectLabel;
typedef struct {
    void * ptr;
    GLsizei length;
    GLchar * label;
} ARGS_glObjectPtrLabel;
typedef struct {
    int index;
    ARGS_glObjectPtrLabel args;
} PACKED_glObjectPtrLabel;
typedef struct {
    GLenum objectType;
    GLuint name;
    GLenum option;
} ARGS_glObjectPurgeableAPPLE;
typedef struct {
    int index;
    ARGS_glObjectPurgeableAPPLE args;
} PACKED_glObjectPurgeableAPPLE;
typedef struct {
    GLenum objectType;
    GLuint name;
    GLenum option;
} ARGS_glObjectUnpurgeableAPPLE;
typedef struct {
    int index;
    ARGS_glObjectUnpurgeableAPPLE args;
} PACKED_glObjectUnpurgeableAPPLE;
typedef struct {
    GLdouble left __attribute__ ((aligned(8)));
    GLdouble right __attribute__ ((aligned(8)));
    GLdouble bottom __attribute__ ((aligned(8)));
    GLdouble top __attribute__ ((aligned(8)));
    GLdouble zNear __attribute__ ((aligned(8)));
    GLdouble zFar __attribute__ ((aligned(8)));
} ARGS_glOrtho;
typedef struct {
    int index;
    ARGS_glOrtho args;
} PACKED_glOrtho;
typedef struct {
    GLfloat left;
    GLfloat right;
    GLfloat bottom;
    GLfloat top;
    GLfloat near;
    GLfloat far;
} ARGS_glOrthof;
typedef struct {
    int index;
    ARGS_glOrthof args;
} PACKED_glOrthof;
typedef struct {
    GLfloat l;
    GLfloat r;
    GLfloat b;
    GLfloat t;
    GLfloat n;
    GLfloat f;
} ARGS_glOrthofOES;
typedef struct {
    int index;
    ARGS_glOrthofOES args;
} PACKED_glOrthofOES;
typedef struct {
    GLfixed left;
    GLfixed right;
    GLfixed bottom;
    GLfixed top;
    GLfixed near;
    GLfixed far;
} ARGS_glOrthox;
typedef struct {
    int index;
    ARGS_glOrthox args;
} PACKED_glOrthox;
typedef struct {
    GLfixed l;
    GLfixed r;
    GLfixed b;
    GLfixed t;
    GLfixed n;
    GLfixed f;
} ARGS_glOrthoxOES;
typedef struct {
    int index;
    ARGS_glOrthoxOES args;
} PACKED_glOrthoxOES;
typedef struct {
    GLenum pname;
    GLfloat param;
} ARGS_glPNTrianglesfATI;
typedef struct {
    int index;
    ARGS_glPNTrianglesfATI args;
} PACKED_glPNTrianglesfATI;
typedef struct {
    GLenum pname;
    GLint param;
} ARGS_glPNTrianglesiATI;
typedef struct {
    int index;
    ARGS_glPNTrianglesiATI args;
} PACKED_glPNTrianglesiATI;
typedef struct {
    GLuint dst;
    GLuint coord;
    GLenum swizzle;
} ARGS_glPassTexCoordATI;
typedef struct {
    int index;
    ARGS_glPassTexCoordATI args;
} PACKED_glPassTexCoordATI;
typedef struct {
    GLfloat token;
} ARGS_glPassThrough;
typedef struct {
    int index;
    ARGS_glPassThrough args;
} PACKED_glPassThrough;
typedef struct {
    GLfixed token;
} ARGS_glPassThroughxOES;
typedef struct {
    int index;
    ARGS_glPassThroughxOES args;
} PACKED_glPassThroughxOES;
typedef struct {
    GLenum pname;
    GLfloat * values;
} ARGS_glPatchParameterfv;
typedef struct {
    int index;
    ARGS_glPatchParameterfv args;
} PACKED_glPatchParameterfv;
typedef struct {
    GLenum pname;
    GLint value;
} ARGS_glPatchParameteri;
typedef struct {
    int index;
    ARGS_glPatchParameteri args;
} PACKED_glPatchParameteri;
typedef struct {
    GLenum color;
    GLenum genMode;
    GLenum colorFormat;
    GLfloat * coeffs;
} ARGS_glPathColorGenNV;
typedef struct {
    int index;
    ARGS_glPathColorGenNV args;
} PACKED_glPathColorGenNV;
typedef struct {
    GLuint path;
    GLsizei numCommands;
    GLubyte * commands;
    GLsizei numCoords;
    GLenum coordType;
    GLvoid * coords;
} ARGS_glPathCommandsNV;
typedef struct {
    int index;
    ARGS_glPathCommandsNV args;
} PACKED_glPathCommandsNV;
typedef struct {
    GLuint path;
    GLsizei numCoords;
    GLenum coordType;
    GLvoid * coords;
} ARGS_glPathCoordsNV;
typedef struct {
    int index;
    ARGS_glPathCoordsNV args;
} PACKED_glPathCoordsNV;
typedef struct {
    GLenum func;
} ARGS_glPathCoverDepthFuncNV;
typedef struct {
    int index;
    ARGS_glPathCoverDepthFuncNV args;
} PACKED_glPathCoverDepthFuncNV;
typedef struct {
    GLuint path;
    GLsizei dashCount;
    GLfloat * dashArray;
} ARGS_glPathDashArrayNV;
typedef struct {
    int index;
    ARGS_glPathDashArrayNV args;
} PACKED_glPathDashArrayNV;
typedef struct {
    GLenum genMode;
} ARGS_glPathFogGenNV;
typedef struct {
    int index;
    ARGS_glPathFogGenNV args;
} PACKED_glPathFogGenNV;
typedef struct {
    GLuint firstPathName;
    GLenum fontTarget;
    GLvoid * fontName;
    GLbitfield fontStyle;
    GLuint firstGlyph;
    GLsizei numGlyphs;
    GLenum handleMissingGlyphs;
    GLuint pathParameterTemplate;
    GLfloat emScale;
} ARGS_glPathGlyphRangeNV;
typedef struct {
    int index;
    ARGS_glPathGlyphRangeNV args;
} PACKED_glPathGlyphRangeNV;
typedef struct {
    GLuint firstPathName;
    GLenum fontTarget;
    GLvoid * fontName;
    GLbitfield fontStyle;
    GLsizei numGlyphs;
    GLenum type;
    GLvoid * charcodes;
    GLenum handleMissingGlyphs;
    GLuint pathParameterTemplate;
    GLfloat emScale;
} ARGS_glPathGlyphsNV;
typedef struct {
    int index;
    ARGS_glPathGlyphsNV args;
} PACKED_glPathGlyphsNV;
typedef struct {
    GLuint path;
    GLenum pname;
    GLfloat value;
} ARGS_glPathParameterfNV;
typedef struct {
    int index;
    ARGS_glPathParameterfNV args;
} PACKED_glPathParameterfNV;
typedef struct {
    GLuint path;
    GLenum pname;
    GLfloat * value;
} ARGS_glPathParameterfvNV;
typedef struct {
    int index;
    ARGS_glPathParameterfvNV args;
} PACKED_glPathParameterfvNV;
typedef struct {
    GLuint path;
    GLenum pname;
    GLint value;
} ARGS_glPathParameteriNV;
typedef struct {
    int index;
    ARGS_glPathParameteriNV args;
} PACKED_glPathParameteriNV;
typedef struct {
    GLuint path;
    GLenum pname;
    GLint * value;
} ARGS_glPathParameterivNV;
typedef struct {
    int index;
    ARGS_glPathParameterivNV args;
} PACKED_glPathParameterivNV;
typedef struct {
    GLfloat factor;
    GLfloat units;
} ARGS_glPathStencilDepthOffsetNV;
typedef struct {
    int index;
    ARGS_glPathStencilDepthOffsetNV args;
} PACKED_glPathStencilDepthOffsetNV;
typedef struct {
    GLenum func;
    GLint ref;
    GLuint mask;
} ARGS_glPathStencilFuncNV;
typedef struct {
    int index;
    ARGS_glPathStencilFuncNV args;
} PACKED_glPathStencilFuncNV;
typedef struct {
    GLuint path;
    GLenum format;
    GLsizei length;
    GLvoid * pathString;
} ARGS_glPathStringNV;
typedef struct {
    int index;
    ARGS_glPathStringNV args;
} PACKED_glPathStringNV;
typedef struct {
    GLuint path;
    GLsizei commandStart;
    GLsizei commandsToDelete;
    GLsizei numCommands;
    GLubyte * commands;
    GLsizei numCoords;
    GLenum coordType;
    GLvoid * coords;
} ARGS_glPathSubCommandsNV;
typedef struct {
    int index;
    ARGS_glPathSubCommandsNV args;
} PACKED_glPathSubCommandsNV;
typedef struct {
    GLuint path;
    GLsizei coordStart;
    GLsizei numCoords;
    GLenum coordType;
    GLvoid * coords;
} ARGS_glPathSubCoordsNV;
typedef struct {
    int index;
    ARGS_glPathSubCoordsNV args;
} PACKED_glPathSubCoordsNV;
typedef struct {
    GLenum texCoordSet;
    GLenum genMode;
    GLint components;
    GLfloat * coeffs;
} ARGS_glPathTexGenNV;
typedef struct {
    int index;
    ARGS_glPathTexGenNV args;
} PACKED_glPathTexGenNV;
typedef struct {
    int index;
} PACKED_glPauseTransformFeedback;
typedef struct {
    int index;
} PACKED_glPauseTransformFeedbackNV;
typedef struct {
    GLenum target;
    GLsizei length;
    GLvoid * pointer;
} ARGS_glPixelDataRangeNV;
typedef struct {
    int index;
    ARGS_glPixelDataRangeNV args;
} PACKED_glPixelDataRangeNV;
typedef struct {
    GLenum map;
    GLsizei mapsize;
    GLfloat * values;
} ARGS_glPixelMapfv;
typedef struct {
    int index;
    ARGS_glPixelMapfv args;
} PACKED_glPixelMapfv;
typedef struct {
    GLenum map;
    GLsizei mapsize;
    GLuint * values;
} ARGS_glPixelMapuiv;
typedef struct {
    int index;
    ARGS_glPixelMapuiv args;
} PACKED_glPixelMapuiv;
typedef struct {
    GLenum map;
    GLsizei mapsize;
    GLushort * values;
} ARGS_glPixelMapusv;
typedef struct {
    int index;
    ARGS_glPixelMapusv args;
} PACKED_glPixelMapusv;
typedef struct {
    GLenum map;
    GLint size;
    GLfixed * values;
} ARGS_glPixelMapx;
typedef struct {
    int index;
    ARGS_glPixelMapx args;
} PACKED_glPixelMapx;
typedef struct {
    GLenum pname;
    GLfloat param;
} ARGS_glPixelStoref;
typedef struct {
    int index;
    ARGS_glPixelStoref args;
} PACKED_glPixelStoref;
typedef struct {
    GLenum pname;
    GLint param;
} ARGS_glPixelStorei;
typedef struct {
    int index;
    ARGS_glPixelStorei args;
} PACKED_glPixelStorei;
typedef struct {
    GLenum pname;
    GLfixed param;
} ARGS_glPixelStorex;
typedef struct {
    int index;
    ARGS_glPixelStorex args;
} PACKED_glPixelStorex;
typedef struct {
    GLenum pname;
    GLfloat param;
} ARGS_glPixelTexGenParameterfSGIS;
typedef struct {
    int index;
    ARGS_glPixelTexGenParameterfSGIS args;
} PACKED_glPixelTexGenParameterfSGIS;
typedef struct {
    GLenum pname;
    GLfloat * params;
} ARGS_glPixelTexGenParameterfvSGIS;
typedef struct {
    int index;
    ARGS_glPixelTexGenParameterfvSGIS args;
} PACKED_glPixelTexGenParameterfvSGIS;
typedef struct {
    GLenum pname;
    GLint param;
} ARGS_glPixelTexGenParameteriSGIS;
typedef struct {
    int index;
    ARGS_glPixelTexGenParameteriSGIS args;
} PACKED_glPixelTexGenParameteriSGIS;
typedef struct {
    GLenum pname;
    GLint * params;
} ARGS_glPixelTexGenParameterivSGIS;
typedef struct {
    int index;
    ARGS_glPixelTexGenParameterivSGIS args;
} PACKED_glPixelTexGenParameterivSGIS;
typedef struct {
    GLenum mode;
} ARGS_glPixelTexGenSGIX;
typedef struct {
    int index;
    ARGS_glPixelTexGenSGIX args;
} PACKED_glPixelTexGenSGIX;
typedef struct {
    GLenum pname;
    GLfloat param;
} ARGS_glPixelTransferf;
typedef struct {
    int index;
    ARGS_glPixelTransferf args;
} PACKED_glPixelTransferf;
typedef struct {
    GLenum pname;
    GLint param;
} ARGS_glPixelTransferi;
typedef struct {
    int index;
    ARGS_glPixelTransferi args;
} PACKED_glPixelTransferi;
typedef struct {
    GLenum pname;
    GLfixed param;
} ARGS_glPixelTransferxOES;
typedef struct {
    int index;
    ARGS_glPixelTransferxOES args;
} PACKED_glPixelTransferxOES;
typedef struct {
    GLenum target;
    GLenum pname;
    GLfloat param;
} ARGS_glPixelTransformParameterfEXT;
typedef struct {
    int index;
    ARGS_glPixelTransformParameterfEXT args;
} PACKED_glPixelTransformParameterfEXT;
typedef struct {
    GLenum target;
    GLenum pname;
    GLfloat * params;
} ARGS_glPixelTransformParameterfvEXT;
typedef struct {
    int index;
    ARGS_glPixelTransformParameterfvEXT args;
} PACKED_glPixelTransformParameterfvEXT;
typedef struct {
    GLenum target;
    GLenum pname;
    GLint param;
} ARGS_glPixelTransformParameteriEXT;
typedef struct {
    int index;
    ARGS_glPixelTransformParameteriEXT args;
} PACKED_glPixelTransformParameteriEXT;
typedef struct {
    GLenum target;
    GLenum pname;
    GLint * params;
} ARGS_glPixelTransformParameterivEXT;
typedef struct {
    int index;
    ARGS_glPixelTransformParameterivEXT args;
} PACKED_glPixelTransformParameterivEXT;
typedef struct {
    GLfloat xfactor;
    GLfloat yfactor;
} ARGS_glPixelZoom;
typedef struct {
    int index;
    ARGS_glPixelZoom args;
} PACKED_glPixelZoom;
typedef struct {
    GLfixed xfactor;
    GLfixed yfactor;
} ARGS_glPixelZoomxOES;
typedef struct {
    int index;
    ARGS_glPixelZoomxOES args;
} PACKED_glPixelZoomxOES;
typedef struct {
    GLuint path;
    GLsizei startSegment;
    GLsizei numSegments;
    GLfloat distance;
    GLfloat * x;
    GLfloat * y;
    GLfloat * tangentX;
    GLfloat * tangentY;
} ARGS_glPointAlongPathNV;
typedef struct {
    int index;
    ARGS_glPointAlongPathNV args;
} PACKED_glPointAlongPathNV;
typedef struct {
    GLenum pname;
    GLfloat param;
} ARGS_glPointParameterf;
typedef struct {
    int index;
    ARGS_glPointParameterf args;
} PACKED_glPointParameterf;
typedef struct {
    GLenum pname;
    GLfloat param;
} ARGS_glPointParameterfARB;
typedef struct {
    int index;
    ARGS_glPointParameterfARB args;
} PACKED_glPointParameterfARB;
typedef struct {
    GLenum pname;
    GLfloat param;
} ARGS_glPointParameterfEXT;
typedef struct {
    int index;
    ARGS_glPointParameterfEXT args;
} PACKED_glPointParameterfEXT;
typedef struct {
    GLenum pname;
    GLfloat param;
} ARGS_glPointParameterfSGIS;
typedef struct {
    int index;
    ARGS_glPointParameterfSGIS args;
} PACKED_glPointParameterfSGIS;
typedef struct {
    GLenum pname;
    GLfloat * params;
} ARGS_glPointParameterfv;
typedef struct {
    int index;
    ARGS_glPointParameterfv args;
} PACKED_glPointParameterfv;
typedef struct {
    GLenum pname;
    GLfloat * params;
} ARGS_glPointParameterfvARB;
typedef struct {
    int index;
    ARGS_glPointParameterfvARB args;
} PACKED_glPointParameterfvARB;
typedef struct {
    GLenum pname;
    GLfloat * params;
} ARGS_glPointParameterfvEXT;
typedef struct {
    int index;
    ARGS_glPointParameterfvEXT args;
} PACKED_glPointParameterfvEXT;
typedef struct {
    GLenum pname;
    GLfloat * params;
} ARGS_glPointParameterfvSGIS;
typedef struct {
    int index;
    ARGS_glPointParameterfvSGIS args;
} PACKED_glPointParameterfvSGIS;
typedef struct {
    GLenum pname;
    GLint param;
} ARGS_glPointParameteri;
typedef struct {
    int index;
    ARGS_glPointParameteri args;
} PACKED_glPointParameteri;
typedef struct {
    GLenum pname;
    GLint param;
} ARGS_glPointParameteriNV;
typedef struct {
    int index;
    ARGS_glPointParameteriNV args;
} PACKED_glPointParameteriNV;
typedef struct {
    GLenum pname;
    GLint * params;
} ARGS_glPointParameteriv;
typedef struct {
    int index;
    ARGS_glPointParameteriv args;
} PACKED_glPointParameteriv;
typedef struct {
    GLenum pname;
    GLint * params;
} ARGS_glPointParameterivNV;
typedef struct {
    int index;
    ARGS_glPointParameterivNV args;
} PACKED_glPointParameterivNV;
typedef struct {
    GLenum pname;
    GLfixed param;
} ARGS_glPointParameterx;
typedef struct {
    int index;
    ARGS_glPointParameterx args;
} PACKED_glPointParameterx;
typedef struct {
    GLenum pname;
    GLfixed * params;
} ARGS_glPointParameterxv;
typedef struct {
    int index;
    ARGS_glPointParameterxv args;
} PACKED_glPointParameterxv;
typedef struct {
    GLenum pname;
    GLfixed * params;
} ARGS_glPointParameterxvOES;
typedef struct {
    int index;
    ARGS_glPointParameterxvOES args;
} PACKED_glPointParameterxvOES;
typedef struct {
    GLfloat size;
} ARGS_glPointSize;
typedef struct {
    int index;
    ARGS_glPointSize args;
} PACKED_glPointSize;
typedef struct {
    GLenum type;
    GLsizei stride;
    GLvoid * pointer;
} ARGS_glPointSizePointerOES;
typedef struct {
    int index;
    ARGS_glPointSizePointerOES args;
} PACKED_glPointSizePointerOES;
typedef struct {
    GLfixed size;
} ARGS_glPointSizex;
typedef struct {
    int index;
    ARGS_glPointSizex args;
} PACKED_glPointSizex;
typedef struct {
    GLfixed size;
} ARGS_glPointSizexOES;
typedef struct {
    int index;
    ARGS_glPointSizexOES args;
} PACKED_glPointSizexOES;
typedef struct {
    GLuint * markerp;
} ARGS_glPollAsyncSGIX;
typedef struct {
    int index;
    ARGS_glPollAsyncSGIX args;
} PACKED_glPollAsyncSGIX;
typedef struct {
    GLint * marker_p;
} ARGS_glPollInstrumentsSGIX;
typedef struct {
    int index;
    ARGS_glPollInstrumentsSGIX args;
} PACKED_glPollInstrumentsSGIX;
typedef struct {
    GLenum face;
    GLenum mode;
} ARGS_glPolygonMode;
typedef struct {
    int index;
    ARGS_glPolygonMode args;
} PACKED_glPolygonMode;
typedef struct {
    GLfloat factor;
    GLfloat units;
} ARGS_glPolygonOffset;
typedef struct {
    int index;
    ARGS_glPolygonOffset args;
} PACKED_glPolygonOffset;
typedef struct {
    GLfloat factor;
    GLfloat bias;
} ARGS_glPolygonOffsetEXT;
typedef struct {
    int index;
    ARGS_glPolygonOffsetEXT args;
} PACKED_glPolygonOffsetEXT;
typedef struct {
    GLfixed factor;
    GLfixed units;
} ARGS_glPolygonOffsetx;
typedef struct {
    int index;
    ARGS_glPolygonOffsetx args;
} PACKED_glPolygonOffsetx;
typedef struct {
    GLfixed factor;
    GLfixed units;
} ARGS_glPolygonOffsetxOES;
typedef struct {
    int index;
    ARGS_glPolygonOffsetxOES args;
} PACKED_glPolygonOffsetxOES;
typedef struct {
    GLubyte * mask;
} ARGS_glPolygonStipple;
typedef struct {
    int index;
    ARGS_glPolygonStipple args;
} PACKED_glPolygonStipple;
typedef struct {
    int index;
} PACKED_glPopAttrib;
typedef struct {
    int index;
} PACKED_glPopClientAttrib;
typedef struct {
    int index;
} PACKED_glPopDebugGroup;
typedef struct {
    int index;
} PACKED_glPopMatrix;
typedef struct {
    int index;
} PACKED_glPopName;
typedef struct {
    GLuint video_slot;
    GLuint64EXT minPresentTime;
    GLuint beginPresentTimeId;
    GLuint presentDurationId;
    GLenum type;
    GLenum target0;
    GLuint fill0;
    GLenum target1;
    GLuint fill1;
    GLenum target2;
    GLuint fill2;
    GLenum target3;
    GLuint fill3;
} ARGS_glPresentFrameDualFillNV;
typedef struct {
    int index;
    ARGS_glPresentFrameDualFillNV args;
} PACKED_glPresentFrameDualFillNV;
typedef struct {
    GLuint video_slot;
    GLuint64EXT minPresentTime;
    GLuint beginPresentTimeId;
    GLuint presentDurationId;
    GLenum type;
    GLenum target0;
    GLuint fill0;
    GLuint key0;
    GLenum target1;
    GLuint fill1;
    GLuint key1;
} ARGS_glPresentFrameKeyedNV;
typedef struct {
    int index;
    ARGS_glPresentFrameKeyedNV args;
} PACKED_glPresentFrameKeyedNV;
typedef struct {
    GLuint index;
} ARGS_glPrimitiveRestartIndex;
typedef struct {
    int index;
    ARGS_glPrimitiveRestartIndex args;
} PACKED_glPrimitiveRestartIndex;
typedef struct {
    GLuint index;
} ARGS_glPrimitiveRestartIndexNV;
typedef struct {
    int index;
    ARGS_glPrimitiveRestartIndexNV args;
} PACKED_glPrimitiveRestartIndexNV;
typedef struct {
    int index;
} PACKED_glPrimitiveRestartNV;
typedef struct {
    GLsizei n;
    GLuint * textures;
    GLfloat * priorities;
} ARGS_glPrioritizeTextures;
typedef struct {
    int index;
    ARGS_glPrioritizeTextures args;
} PACKED_glPrioritizeTextures;
typedef struct {
    GLsizei n;
    GLuint * textures;
    GLclampf * priorities;
} ARGS_glPrioritizeTexturesEXT;
typedef struct {
    int index;
    ARGS_glPrioritizeTexturesEXT args;
} PACKED_glPrioritizeTexturesEXT;
typedef struct {
    GLsizei n;
    GLuint * textures;
    GLfixed * priorities;
} ARGS_glPrioritizeTexturesxOES;
typedef struct {
    int index;
    ARGS_glPrioritizeTexturesxOES args;
} PACKED_glPrioritizeTexturesxOES;
typedef struct {
    GLuint program;
    GLenum binaryFormat;
    GLvoid * binary;
    GLsizei length;
} ARGS_glProgramBinary;
typedef struct {
    int index;
    ARGS_glProgramBinary args;
} PACKED_glProgramBinary;
typedef struct {
    GLenum target;
    GLuint bindingIndex;
    GLuint wordIndex;
    GLsizei count;
    GLint * params;
} ARGS_glProgramBufferParametersIivNV;
typedef struct {
    int index;
    ARGS_glProgramBufferParametersIivNV args;
} PACKED_glProgramBufferParametersIivNV;
typedef struct {
    GLenum target;
    GLuint bindingIndex;
    GLuint wordIndex;
    GLsizei count;
    GLuint * params;
} ARGS_glProgramBufferParametersIuivNV;
typedef struct {
    int index;
    ARGS_glProgramBufferParametersIuivNV args;
} PACKED_glProgramBufferParametersIuivNV;
typedef struct {
    GLenum target;
    GLuint bindingIndex;
    GLuint wordIndex;
    GLsizei count;
    GLfloat * params;
} ARGS_glProgramBufferParametersfvNV;
typedef struct {
    int index;
    ARGS_glProgramBufferParametersfvNV args;
} PACKED_glProgramBufferParametersfvNV;
typedef struct {
    GLenum target;
    GLuint index;
    GLdouble x __attribute__ ((aligned(8)));
    GLdouble y __attribute__ ((aligned(8)));
    GLdouble z __attribute__ ((aligned(8)));
    GLdouble w __attribute__ ((aligned(8)));
} ARGS_glProgramEnvParameter4dARB;
typedef struct {
    int index;
    ARGS_glProgramEnvParameter4dARB args;
} PACKED_glProgramEnvParameter4dARB;
typedef struct {
    GLenum target;
    GLuint index;
    GLdouble * params;
} ARGS_glProgramEnvParameter4dvARB;
typedef struct {
    int index;
    ARGS_glProgramEnvParameter4dvARB args;
} PACKED_glProgramEnvParameter4dvARB;
typedef struct {
    GLenum target;
    GLuint index;
    GLfloat x;
    GLfloat y;
    GLfloat z;
    GLfloat w;
} ARGS_glProgramEnvParameter4fARB;
typedef struct {
    int index;
    ARGS_glProgramEnvParameter4fARB args;
} PACKED_glProgramEnvParameter4fARB;
typedef struct {
    GLenum target;
    GLuint index;
    GLfloat * params;
} ARGS_glProgramEnvParameter4fvARB;
typedef struct {
    int index;
    ARGS_glProgramEnvParameter4fvARB args;
} PACKED_glProgramEnvParameter4fvARB;
typedef struct {
    GLenum target;
    GLuint index;
    GLint x;
    GLint y;
    GLint z;
    GLint w;
} ARGS_glProgramEnvParameterI4iNV;
typedef struct {
    int index;
    ARGS_glProgramEnvParameterI4iNV args;
} PACKED_glProgramEnvParameterI4iNV;
typedef struct {
    GLenum target;
    GLuint index;
    GLint * params;
} ARGS_glProgramEnvParameterI4ivNV;
typedef struct {
    int index;
    ARGS_glProgramEnvParameterI4ivNV args;
} PACKED_glProgramEnvParameterI4ivNV;
typedef struct {
    GLenum target;
    GLuint index;
    GLuint x;
    GLuint y;
    GLuint z;
    GLuint w;
} ARGS_glProgramEnvParameterI4uiNV;
typedef struct {
    int index;
    ARGS_glProgramEnvParameterI4uiNV args;
} PACKED_glProgramEnvParameterI4uiNV;
typedef struct {
    GLenum target;
    GLuint index;
    GLuint * params;
} ARGS_glProgramEnvParameterI4uivNV;
typedef struct {
    int index;
    ARGS_glProgramEnvParameterI4uivNV args;
} PACKED_glProgramEnvParameterI4uivNV;
typedef struct {
    GLenum target;
    GLuint index;
    GLsizei count;
    GLfloat * params;
} ARGS_glProgramEnvParameters4fvEXT;
typedef struct {
    int index;
    ARGS_glProgramEnvParameters4fvEXT args;
} PACKED_glProgramEnvParameters4fvEXT;
typedef struct {
    GLenum target;
    GLuint index;
    GLsizei count;
    GLint * params;
} ARGS_glProgramEnvParametersI4ivNV;
typedef struct {
    int index;
    ARGS_glProgramEnvParametersI4ivNV args;
} PACKED_glProgramEnvParametersI4ivNV;
typedef struct {
    GLenum target;
    GLuint index;
    GLsizei count;
    GLuint * params;
} ARGS_glProgramEnvParametersI4uivNV;
typedef struct {
    int index;
    ARGS_glProgramEnvParametersI4uivNV args;
} PACKED_glProgramEnvParametersI4uivNV;
typedef struct {
    GLenum target;
    GLuint index;
    GLdouble x __attribute__ ((aligned(8)));
    GLdouble y __attribute__ ((aligned(8)));
    GLdouble z __attribute__ ((aligned(8)));
    GLdouble w __attribute__ ((aligned(8)));
} ARGS_glProgramLocalParameter4dARB;
typedef struct {
    int index;
    ARGS_glProgramLocalParameter4dARB args;
} PACKED_glProgramLocalParameter4dARB;
typedef struct {
    GLenum target;
    GLuint index;
    GLdouble * params;
} ARGS_glProgramLocalParameter4dvARB;
typedef struct {
    int index;
    ARGS_glProgramLocalParameter4dvARB args;
} PACKED_glProgramLocalParameter4dvARB;
typedef struct {
    GLenum target;
    GLuint index;
    GLfloat x;
    GLfloat y;
    GLfloat z;
    GLfloat w;
} ARGS_glProgramLocalParameter4fARB;
typedef struct {
    int index;
    ARGS_glProgramLocalParameter4fARB args;
} PACKED_glProgramLocalParameter4fARB;
typedef struct {
    GLenum target;
    GLuint index;
    GLfloat * params;
} ARGS_glProgramLocalParameter4fvARB;
typedef struct {
    int index;
    ARGS_glProgramLocalParameter4fvARB args;
} PACKED_glProgramLocalParameter4fvARB;
typedef struct {
    GLenum target;
    GLuint index;
    GLint x;
    GLint y;
    GLint z;
    GLint w;
} ARGS_glProgramLocalParameterI4iNV;
typedef struct {
    int index;
    ARGS_glProgramLocalParameterI4iNV args;
} PACKED_glProgramLocalParameterI4iNV;
typedef struct {
    GLenum target;
    GLuint index;
    GLint * params;
} ARGS_glProgramLocalParameterI4ivNV;
typedef struct {
    int index;
    ARGS_glProgramLocalParameterI4ivNV args;
} PACKED_glProgramLocalParameterI4ivNV;
typedef struct {
    GLenum target;
    GLuint index;
    GLuint x;
    GLuint y;
    GLuint z;
    GLuint w;
} ARGS_glProgramLocalParameterI4uiNV;
typedef struct {
    int index;
    ARGS_glProgramLocalParameterI4uiNV args;
} PACKED_glProgramLocalParameterI4uiNV;
typedef struct {
    GLenum target;
    GLuint index;
    GLuint * params;
} ARGS_glProgramLocalParameterI4uivNV;
typedef struct {
    int index;
    ARGS_glProgramLocalParameterI4uivNV args;
} PACKED_glProgramLocalParameterI4uivNV;
typedef struct {
    GLenum target;
    GLuint index;
    GLsizei count;
    GLfloat * params;
} ARGS_glProgramLocalParameters4fvEXT;
typedef struct {
    int index;
    ARGS_glProgramLocalParameters4fvEXT args;
} PACKED_glProgramLocalParameters4fvEXT;
typedef struct {
    GLenum target;
    GLuint index;
    GLsizei count;
    GLint * params;
} ARGS_glProgramLocalParametersI4ivNV;
typedef struct {
    int index;
    ARGS_glProgramLocalParametersI4ivNV args;
} PACKED_glProgramLocalParametersI4ivNV;
typedef struct {
    GLenum target;
    GLuint index;
    GLsizei count;
    GLuint * params;
} ARGS_glProgramLocalParametersI4uivNV;
typedef struct {
    int index;
    ARGS_glProgramLocalParametersI4uivNV args;
} PACKED_glProgramLocalParametersI4uivNV;
typedef struct {
    GLuint id;
    GLsizei len;
    GLubyte * name;
    GLdouble x __attribute__ ((aligned(8)));
    GLdouble y __attribute__ ((aligned(8)));
    GLdouble z __attribute__ ((aligned(8)));
    GLdouble w __attribute__ ((aligned(8)));
} ARGS_glProgramNamedParameter4dNV;
typedef struct {
    int index;
    ARGS_glProgramNamedParameter4dNV args;
} PACKED_glProgramNamedParameter4dNV;
typedef struct {
    GLuint id;
    GLsizei len;
    GLubyte * name;
    GLdouble * v;
} ARGS_glProgramNamedParameter4dvNV;
typedef struct {
    int index;
    ARGS_glProgramNamedParameter4dvNV args;
} PACKED_glProgramNamedParameter4dvNV;
typedef struct {
    GLuint id;
    GLsizei len;
    GLubyte * name;
    GLfloat x;
    GLfloat y;
    GLfloat z;
    GLfloat w;
} ARGS_glProgramNamedParameter4fNV;
typedef struct {
    int index;
    ARGS_glProgramNamedParameter4fNV args;
} PACKED_glProgramNamedParameter4fNV;
typedef struct {
    GLuint id;
    GLsizei len;
    GLubyte * name;
    GLfloat * v;
} ARGS_glProgramNamedParameter4fvNV;
typedef struct {
    int index;
    ARGS_glProgramNamedParameter4fvNV args;
} PACKED_glProgramNamedParameter4fvNV;
typedef struct {
    GLenum target;
    GLuint index;
    GLdouble x __attribute__ ((aligned(8)));
    GLdouble y __attribute__ ((aligned(8)));
    GLdouble z __attribute__ ((aligned(8)));
    GLdouble w __attribute__ ((aligned(8)));
} ARGS_glProgramParameter4dNV;
typedef struct {
    int index;
    ARGS_glProgramParameter4dNV args;
} PACKED_glProgramParameter4dNV;
typedef struct {
    GLenum target;
    GLuint index;
    GLdouble * v;
} ARGS_glProgramParameter4dvNV;
typedef struct {
    int index;
    ARGS_glProgramParameter4dvNV args;
} PACKED_glProgramParameter4dvNV;
typedef struct {
    GLenum target;
    GLuint index;
    GLfloat x;
    GLfloat y;
    GLfloat z;
    GLfloat w;
} ARGS_glProgramParameter4fNV;
typedef struct {
    int index;
    ARGS_glProgramParameter4fNV args;
} PACKED_glProgramParameter4fNV;
typedef struct {
    GLenum target;
    GLuint index;
    GLfloat * v;
} ARGS_glProgramParameter4fvNV;
typedef struct {
    int index;
    ARGS_glProgramParameter4fvNV args;
} PACKED_glProgramParameter4fvNV;
typedef struct {
    GLuint program;
    GLenum pname;
    GLint value;
} ARGS_glProgramParameteri;
typedef struct {
    int index;
    ARGS_glProgramParameteri args;
} PACKED_glProgramParameteri;
typedef struct {
    GLuint program;
    GLenum pname;
    GLint value;
} ARGS_glProgramParameteriARB;
typedef struct {
    int index;
    ARGS_glProgramParameteriARB args;
} PACKED_glProgramParameteriARB;
typedef struct {
    GLuint program;
    GLenum pname;
    GLint value;
} ARGS_glProgramParameteriEXT;
typedef struct {
    int index;
    ARGS_glProgramParameteriEXT args;
} PACKED_glProgramParameteriEXT;
typedef struct {
    GLenum target;
    GLuint index;
    GLsizei count;
    GLdouble * v;
} ARGS_glProgramParameters4dvNV;
typedef struct {
    int index;
    ARGS_glProgramParameters4dvNV args;
} PACKED_glProgramParameters4dvNV;
typedef struct {
    GLenum target;
    GLuint index;
    GLsizei count;
    GLfloat * v;
} ARGS_glProgramParameters4fvNV;
typedef struct {
    int index;
    ARGS_glProgramParameters4fvNV args;
} PACKED_glProgramParameters4fvNV;
typedef struct {
    GLenum target;
    GLenum format;
    GLsizei len;
    GLvoid * string;
} ARGS_glProgramStringARB;
typedef struct {
    int index;
    ARGS_glProgramStringARB args;
} PACKED_glProgramStringARB;
typedef struct {
    GLenum target;
    GLsizei count;
    GLuint * params;
} ARGS_glProgramSubroutineParametersuivNV;
typedef struct {
    int index;
    ARGS_glProgramSubroutineParametersuivNV args;
} PACKED_glProgramSubroutineParametersuivNV;
typedef struct {
    GLuint program;
    GLint location;
    GLdouble v0 __attribute__ ((aligned(8)));
} ARGS_glProgramUniform1d;
typedef struct {
    int index;
    ARGS_glProgramUniform1d args;
} PACKED_glProgramUniform1d;
typedef struct {
    GLuint program;
    GLint location;
    GLdouble x __attribute__ ((aligned(8)));
} ARGS_glProgramUniform1dEXT;
typedef struct {
    int index;
    ARGS_glProgramUniform1dEXT args;
} PACKED_glProgramUniform1dEXT;
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLdouble * value;
} ARGS_glProgramUniform1dv;
typedef struct {
    int index;
    ARGS_glProgramUniform1dv args;
} PACKED_glProgramUniform1dv;
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLdouble * value;
} ARGS_glProgramUniform1dvEXT;
typedef struct {
    int index;
    ARGS_glProgramUniform1dvEXT args;
} PACKED_glProgramUniform1dvEXT;
typedef struct {
    GLuint program;
    GLint location;
    GLfloat v0;
} ARGS_glProgramUniform1f;
typedef struct {
    int index;
    ARGS_glProgramUniform1f args;
} PACKED_glProgramUniform1f;
typedef struct {
    GLuint program;
    GLint location;
    GLfloat v0;
} ARGS_glProgramUniform1fEXT;
typedef struct {
    int index;
    ARGS_glProgramUniform1fEXT args;
} PACKED_glProgramUniform1fEXT;
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLfloat * value;
} ARGS_glProgramUniform1fv;
typedef struct {
    int index;
    ARGS_glProgramUniform1fv args;
} PACKED_glProgramUniform1fv;
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLfloat * value;
} ARGS_glProgramUniform1fvEXT;
typedef struct {
    int index;
    ARGS_glProgramUniform1fvEXT args;
} PACKED_glProgramUniform1fvEXT;
typedef struct {
    GLuint program;
    GLint location;
    GLint v0;
} ARGS_glProgramUniform1i;
typedef struct {
    int index;
    ARGS_glProgramUniform1i args;
} PACKED_glProgramUniform1i;
typedef struct {
    GLuint program;
    GLint location;
    GLint64EXT x;
} ARGS_glProgramUniform1i64NV;
typedef struct {
    int index;
    ARGS_glProgramUniform1i64NV args;
} PACKED_glProgramUniform1i64NV;
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLint64EXT * value;
} ARGS_glProgramUniform1i64vNV;
typedef struct {
    int index;
    ARGS_glProgramUniform1i64vNV args;
} PACKED_glProgramUniform1i64vNV;
typedef struct {
    GLuint program;
    GLint location;
    GLint v0;
} ARGS_glProgramUniform1iEXT;
typedef struct {
    int index;
    ARGS_glProgramUniform1iEXT args;
} PACKED_glProgramUniform1iEXT;
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLint * value;
} ARGS_glProgramUniform1iv;
typedef struct {
    int index;
    ARGS_glProgramUniform1iv args;
} PACKED_glProgramUniform1iv;
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLint * value;
} ARGS_glProgramUniform1ivEXT;
typedef struct {
    int index;
    ARGS_glProgramUniform1ivEXT args;
} PACKED_glProgramUniform1ivEXT;
typedef struct {
    GLuint program;
    GLint location;
    GLuint v0;
} ARGS_glProgramUniform1ui;
typedef struct {
    int index;
    ARGS_glProgramUniform1ui args;
} PACKED_glProgramUniform1ui;
typedef struct {
    GLuint program;
    GLint location;
    GLuint64EXT x;
} ARGS_glProgramUniform1ui64NV;
typedef struct {
    int index;
    ARGS_glProgramUniform1ui64NV args;
} PACKED_glProgramUniform1ui64NV;
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLuint64EXT * value;
} ARGS_glProgramUniform1ui64vNV;
typedef struct {
    int index;
    ARGS_glProgramUniform1ui64vNV args;
} PACKED_glProgramUniform1ui64vNV;
typedef struct {
    GLuint program;
    GLint location;
    GLuint v0;
} ARGS_glProgramUniform1uiEXT;
typedef struct {
    int index;
    ARGS_glProgramUniform1uiEXT args;
} PACKED_glProgramUniform1uiEXT;
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLuint * value;
} ARGS_glProgramUniform1uiv;
typedef struct {
    int index;
    ARGS_glProgramUniform1uiv args;
} PACKED_glProgramUniform1uiv;
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLuint * value;
} ARGS_glProgramUniform1uivEXT;
typedef struct {
    int index;
    ARGS_glProgramUniform1uivEXT args;
} PACKED_glProgramUniform1uivEXT;
typedef struct {
    GLuint program;
    GLint location;
    GLdouble v0 __attribute__ ((aligned(8)));
    GLdouble v1 __attribute__ ((aligned(8)));
} ARGS_glProgramUniform2d;
typedef struct {
    int index;
    ARGS_glProgramUniform2d args;
} PACKED_glProgramUniform2d;
typedef struct {
    GLuint program;
    GLint location;
    GLdouble x __attribute__ ((aligned(8)));
    GLdouble y __attribute__ ((aligned(8)));
} ARGS_glProgramUniform2dEXT;
typedef struct {
    int index;
    ARGS_glProgramUniform2dEXT args;
} PACKED_glProgramUniform2dEXT;
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLdouble * value;
} ARGS_glProgramUniform2dv;
typedef struct {
    int index;
    ARGS_glProgramUniform2dv args;
} PACKED_glProgramUniform2dv;
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLdouble * value;
} ARGS_glProgramUniform2dvEXT;
typedef struct {
    int index;
    ARGS_glProgramUniform2dvEXT args;
} PACKED_glProgramUniform2dvEXT;
typedef struct {
    GLuint program;
    GLint location;
    GLfloat v0;
    GLfloat v1;
} ARGS_glProgramUniform2f;
typedef struct {
    int index;
    ARGS_glProgramUniform2f args;
} PACKED_glProgramUniform2f;
typedef struct {
    GLuint program;
    GLint location;
    GLfloat v0;
    GLfloat v1;
} ARGS_glProgramUniform2fEXT;
typedef struct {
    int index;
    ARGS_glProgramUniform2fEXT args;
} PACKED_glProgramUniform2fEXT;
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLfloat * value;
} ARGS_glProgramUniform2fv;
typedef struct {
    int index;
    ARGS_glProgramUniform2fv args;
} PACKED_glProgramUniform2fv;
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLfloat * value;
} ARGS_glProgramUniform2fvEXT;
typedef struct {
    int index;
    ARGS_glProgramUniform2fvEXT args;
} PACKED_glProgramUniform2fvEXT;
typedef struct {
    GLuint program;
    GLint location;
    GLint v0;
    GLint v1;
} ARGS_glProgramUniform2i;
typedef struct {
    int index;
    ARGS_glProgramUniform2i args;
} PACKED_glProgramUniform2i;
typedef struct {
    GLuint program;
    GLint location;
    GLint64EXT x;
    GLint64EXT y;
} ARGS_glProgramUniform2i64NV;
typedef struct {
    int index;
    ARGS_glProgramUniform2i64NV args;
} PACKED_glProgramUniform2i64NV;
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLint64EXT * value;
} ARGS_glProgramUniform2i64vNV;
typedef struct {
    int index;
    ARGS_glProgramUniform2i64vNV args;
} PACKED_glProgramUniform2i64vNV;
typedef struct {
    GLuint program;
    GLint location;
    GLint v0;
    GLint v1;
} ARGS_glProgramUniform2iEXT;
typedef struct {
    int index;
    ARGS_glProgramUniform2iEXT args;
} PACKED_glProgramUniform2iEXT;
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLint * value;
} ARGS_glProgramUniform2iv;
typedef struct {
    int index;
    ARGS_glProgramUniform2iv args;
} PACKED_glProgramUniform2iv;
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLint * value;
} ARGS_glProgramUniform2ivEXT;
typedef struct {
    int index;
    ARGS_glProgramUniform2ivEXT args;
} PACKED_glProgramUniform2ivEXT;
typedef struct {
    GLuint program;
    GLint location;
    GLuint v0;
    GLuint v1;
} ARGS_glProgramUniform2ui;
typedef struct {
    int index;
    ARGS_glProgramUniform2ui args;
} PACKED_glProgramUniform2ui;
typedef struct {
    GLuint program;
    GLint location;
    GLuint64EXT x;
    GLuint64EXT y;
} ARGS_glProgramUniform2ui64NV;
typedef struct {
    int index;
    ARGS_glProgramUniform2ui64NV args;
} PACKED_glProgramUniform2ui64NV;
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLuint64EXT * value;
} ARGS_glProgramUniform2ui64vNV;
typedef struct {
    int index;
    ARGS_glProgramUniform2ui64vNV args;
} PACKED_glProgramUniform2ui64vNV;
typedef struct {
    GLuint program;
    GLint location;
    GLuint v0;
    GLuint v1;
} ARGS_glProgramUniform2uiEXT;
typedef struct {
    int index;
    ARGS_glProgramUniform2uiEXT args;
} PACKED_glProgramUniform2uiEXT;
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLuint * value;
} ARGS_glProgramUniform2uiv;
typedef struct {
    int index;
    ARGS_glProgramUniform2uiv args;
} PACKED_glProgramUniform2uiv;
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLuint * value;
} ARGS_glProgramUniform2uivEXT;
typedef struct {
    int index;
    ARGS_glProgramUniform2uivEXT args;
} PACKED_glProgramUniform2uivEXT;
typedef struct {
    GLuint program;
    GLint location;
    GLdouble v0 __attribute__ ((aligned(8)));
    GLdouble v1 __attribute__ ((aligned(8)));
    GLdouble v2 __attribute__ ((aligned(8)));
} ARGS_glProgramUniform3d;
typedef struct {
    int index;
    ARGS_glProgramUniform3d args;
} PACKED_glProgramUniform3d;
typedef struct {
    GLuint program;
    GLint location;
    GLdouble x __attribute__ ((aligned(8)));
    GLdouble y __attribute__ ((aligned(8)));
    GLdouble z __attribute__ ((aligned(8)));
} ARGS_glProgramUniform3dEXT;
typedef struct {
    int index;
    ARGS_glProgramUniform3dEXT args;
} PACKED_glProgramUniform3dEXT;
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLdouble * value;
} ARGS_glProgramUniform3dv;
typedef struct {
    int index;
    ARGS_glProgramUniform3dv args;
} PACKED_glProgramUniform3dv;
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLdouble * value;
} ARGS_glProgramUniform3dvEXT;
typedef struct {
    int index;
    ARGS_glProgramUniform3dvEXT args;
} PACKED_glProgramUniform3dvEXT;
typedef struct {
    GLuint program;
    GLint location;
    GLfloat v0;
    GLfloat v1;
    GLfloat v2;
} ARGS_glProgramUniform3f;
typedef struct {
    int index;
    ARGS_glProgramUniform3f args;
} PACKED_glProgramUniform3f;
typedef struct {
    GLuint program;
    GLint location;
    GLfloat v0;
    GLfloat v1;
    GLfloat v2;
} ARGS_glProgramUniform3fEXT;
typedef struct {
    int index;
    ARGS_glProgramUniform3fEXT args;
} PACKED_glProgramUniform3fEXT;
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLfloat * value;
} ARGS_glProgramUniform3fv;
typedef struct {
    int index;
    ARGS_glProgramUniform3fv args;
} PACKED_glProgramUniform3fv;
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLfloat * value;
} ARGS_glProgramUniform3fvEXT;
typedef struct {
    int index;
    ARGS_glProgramUniform3fvEXT args;
} PACKED_glProgramUniform3fvEXT;
typedef struct {
    GLuint program;
    GLint location;
    GLint v0;
    GLint v1;
    GLint v2;
} ARGS_glProgramUniform3i;
typedef struct {
    int index;
    ARGS_glProgramUniform3i args;
} PACKED_glProgramUniform3i;
typedef struct {
    GLuint program;
    GLint location;
    GLint64EXT x;
    GLint64EXT y;
    GLint64EXT z;
} ARGS_glProgramUniform3i64NV;
typedef struct {
    int index;
    ARGS_glProgramUniform3i64NV args;
} PACKED_glProgramUniform3i64NV;
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLint64EXT * value;
} ARGS_glProgramUniform3i64vNV;
typedef struct {
    int index;
    ARGS_glProgramUniform3i64vNV args;
} PACKED_glProgramUniform3i64vNV;
typedef struct {
    GLuint program;
    GLint location;
    GLint v0;
    GLint v1;
    GLint v2;
} ARGS_glProgramUniform3iEXT;
typedef struct {
    int index;
    ARGS_glProgramUniform3iEXT args;
} PACKED_glProgramUniform3iEXT;
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLint * value;
} ARGS_glProgramUniform3iv;
typedef struct {
    int index;
    ARGS_glProgramUniform3iv args;
} PACKED_glProgramUniform3iv;
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLint * value;
} ARGS_glProgramUniform3ivEXT;
typedef struct {
    int index;
    ARGS_glProgramUniform3ivEXT args;
} PACKED_glProgramUniform3ivEXT;
typedef struct {
    GLuint program;
    GLint location;
    GLuint v0;
    GLuint v1;
    GLuint v2;
} ARGS_glProgramUniform3ui;
typedef struct {
    int index;
    ARGS_glProgramUniform3ui args;
} PACKED_glProgramUniform3ui;
typedef struct {
    GLuint program;
    GLint location;
    GLuint64EXT x;
    GLuint64EXT y;
    GLuint64EXT z;
} ARGS_glProgramUniform3ui64NV;
typedef struct {
    int index;
    ARGS_glProgramUniform3ui64NV args;
} PACKED_glProgramUniform3ui64NV;
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLuint64EXT * value;
} ARGS_glProgramUniform3ui64vNV;
typedef struct {
    int index;
    ARGS_glProgramUniform3ui64vNV args;
} PACKED_glProgramUniform3ui64vNV;
typedef struct {
    GLuint program;
    GLint location;
    GLuint v0;
    GLuint v1;
    GLuint v2;
} ARGS_glProgramUniform3uiEXT;
typedef struct {
    int index;
    ARGS_glProgramUniform3uiEXT args;
} PACKED_glProgramUniform3uiEXT;
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLuint * value;
} ARGS_glProgramUniform3uiv;
typedef struct {
    int index;
    ARGS_glProgramUniform3uiv args;
} PACKED_glProgramUniform3uiv;
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLuint * value;
} ARGS_glProgramUniform3uivEXT;
typedef struct {
    int index;
    ARGS_glProgramUniform3uivEXT args;
} PACKED_glProgramUniform3uivEXT;
typedef struct {
    GLuint program;
    GLint location;
    GLdouble v0 __attribute__ ((aligned(8)));
    GLdouble v1 __attribute__ ((aligned(8)));
    GLdouble v2 __attribute__ ((aligned(8)));
    GLdouble v3 __attribute__ ((aligned(8)));
} ARGS_glProgramUniform4d;
typedef struct {
    int index;
    ARGS_glProgramUniform4d args;
} PACKED_glProgramUniform4d;
typedef struct {
    GLuint program;
    GLint location;
    GLdouble x __attribute__ ((aligned(8)));
    GLdouble y __attribute__ ((aligned(8)));
    GLdouble z __attribute__ ((aligned(8)));
    GLdouble w __attribute__ ((aligned(8)));
} ARGS_glProgramUniform4dEXT;
typedef struct {
    int index;
    ARGS_glProgramUniform4dEXT args;
} PACKED_glProgramUniform4dEXT;
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLdouble * value;
} ARGS_glProgramUniform4dv;
typedef struct {
    int index;
    ARGS_glProgramUniform4dv args;
} PACKED_glProgramUniform4dv;
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLdouble * value;
} ARGS_glProgramUniform4dvEXT;
typedef struct {
    int index;
    ARGS_glProgramUniform4dvEXT args;
} PACKED_glProgramUniform4dvEXT;
typedef struct {
    GLuint program;
    GLint location;
    GLfloat v0;
    GLfloat v1;
    GLfloat v2;
    GLfloat v3;
} ARGS_glProgramUniform4f;
typedef struct {
    int index;
    ARGS_glProgramUniform4f args;
} PACKED_glProgramUniform4f;
typedef struct {
    GLuint program;
    GLint location;
    GLfloat v0;
    GLfloat v1;
    GLfloat v2;
    GLfloat v3;
} ARGS_glProgramUniform4fEXT;
typedef struct {
    int index;
    ARGS_glProgramUniform4fEXT args;
} PACKED_glProgramUniform4fEXT;
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLfloat * value;
} ARGS_glProgramUniform4fv;
typedef struct {
    int index;
    ARGS_glProgramUniform4fv args;
} PACKED_glProgramUniform4fv;
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLfloat * value;
} ARGS_glProgramUniform4fvEXT;
typedef struct {
    int index;
    ARGS_glProgramUniform4fvEXT args;
} PACKED_glProgramUniform4fvEXT;
typedef struct {
    GLuint program;
    GLint location;
    GLint v0;
    GLint v1;
    GLint v2;
    GLint v3;
} ARGS_glProgramUniform4i;
typedef struct {
    int index;
    ARGS_glProgramUniform4i args;
} PACKED_glProgramUniform4i;
typedef struct {
    GLuint program;
    GLint location;
    GLint64EXT x;
    GLint64EXT y;
    GLint64EXT z;
    GLint64EXT w;
} ARGS_glProgramUniform4i64NV;
typedef struct {
    int index;
    ARGS_glProgramUniform4i64NV args;
} PACKED_glProgramUniform4i64NV;
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLint64EXT * value;
} ARGS_glProgramUniform4i64vNV;
typedef struct {
    int index;
    ARGS_glProgramUniform4i64vNV args;
} PACKED_glProgramUniform4i64vNV;
typedef struct {
    GLuint program;
    GLint location;
    GLint v0;
    GLint v1;
    GLint v2;
    GLint v3;
} ARGS_glProgramUniform4iEXT;
typedef struct {
    int index;
    ARGS_glProgramUniform4iEXT args;
} PACKED_glProgramUniform4iEXT;
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLint * value;
} ARGS_glProgramUniform4iv;
typedef struct {
    int index;
    ARGS_glProgramUniform4iv args;
} PACKED_glProgramUniform4iv;
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLint * value;
} ARGS_glProgramUniform4ivEXT;
typedef struct {
    int index;
    ARGS_glProgramUniform4ivEXT args;
} PACKED_glProgramUniform4ivEXT;
typedef struct {
    GLuint program;
    GLint location;
    GLuint v0;
    GLuint v1;
    GLuint v2;
    GLuint v3;
} ARGS_glProgramUniform4ui;
typedef struct {
    int index;
    ARGS_glProgramUniform4ui args;
} PACKED_glProgramUniform4ui;
typedef struct {
    GLuint program;
    GLint location;
    GLuint64EXT x;
    GLuint64EXT y;
    GLuint64EXT z;
    GLuint64EXT w;
} ARGS_glProgramUniform4ui64NV;
typedef struct {
    int index;
    ARGS_glProgramUniform4ui64NV args;
} PACKED_glProgramUniform4ui64NV;
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLuint64EXT * value;
} ARGS_glProgramUniform4ui64vNV;
typedef struct {
    int index;
    ARGS_glProgramUniform4ui64vNV args;
} PACKED_glProgramUniform4ui64vNV;
typedef struct {
    GLuint program;
    GLint location;
    GLuint v0;
    GLuint v1;
    GLuint v2;
    GLuint v3;
} ARGS_glProgramUniform4uiEXT;
typedef struct {
    int index;
    ARGS_glProgramUniform4uiEXT args;
} PACKED_glProgramUniform4uiEXT;
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLuint * value;
} ARGS_glProgramUniform4uiv;
typedef struct {
    int index;
    ARGS_glProgramUniform4uiv args;
} PACKED_glProgramUniform4uiv;
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLuint * value;
} ARGS_glProgramUniform4uivEXT;
typedef struct {
    int index;
    ARGS_glProgramUniform4uivEXT args;
} PACKED_glProgramUniform4uivEXT;
typedef struct {
    GLuint program;
    GLint location;
    GLuint64 value;
} ARGS_glProgramUniformHandleui64NV;
typedef struct {
    int index;
    ARGS_glProgramUniformHandleui64NV args;
} PACKED_glProgramUniformHandleui64NV;
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLuint64 * values;
} ARGS_glProgramUniformHandleui64vNV;
typedef struct {
    int index;
    ARGS_glProgramUniformHandleui64vNV args;
} PACKED_glProgramUniformHandleui64vNV;
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLboolean transpose;
    GLdouble * value;
} ARGS_glProgramUniformMatrix2dv;
typedef struct {
    int index;
    ARGS_glProgramUniformMatrix2dv args;
} PACKED_glProgramUniformMatrix2dv;
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLboolean transpose;
    GLdouble * value;
} ARGS_glProgramUniformMatrix2dvEXT;
typedef struct {
    int index;
    ARGS_glProgramUniformMatrix2dvEXT args;
} PACKED_glProgramUniformMatrix2dvEXT;
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLboolean transpose;
    GLfloat * value;
} ARGS_glProgramUniformMatrix2fv;
typedef struct {
    int index;
    ARGS_glProgramUniformMatrix2fv args;
} PACKED_glProgramUniformMatrix2fv;
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLboolean transpose;
    GLfloat * value;
} ARGS_glProgramUniformMatrix2fvEXT;
typedef struct {
    int index;
    ARGS_glProgramUniformMatrix2fvEXT args;
} PACKED_glProgramUniformMatrix2fvEXT;
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLboolean transpose;
    GLdouble * value;
} ARGS_glProgramUniformMatrix2x3dv;
typedef struct {
    int index;
    ARGS_glProgramUniformMatrix2x3dv args;
} PACKED_glProgramUniformMatrix2x3dv;
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLboolean transpose;
    GLdouble * value;
} ARGS_glProgramUniformMatrix2x3dvEXT;
typedef struct {
    int index;
    ARGS_glProgramUniformMatrix2x3dvEXT args;
} PACKED_glProgramUniformMatrix2x3dvEXT;
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLboolean transpose;
    GLfloat * value;
} ARGS_glProgramUniformMatrix2x3fv;
typedef struct {
    int index;
    ARGS_glProgramUniformMatrix2x3fv args;
} PACKED_glProgramUniformMatrix2x3fv;
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLboolean transpose;
    GLfloat * value;
} ARGS_glProgramUniformMatrix2x3fvEXT;
typedef struct {
    int index;
    ARGS_glProgramUniformMatrix2x3fvEXT args;
} PACKED_glProgramUniformMatrix2x3fvEXT;
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLboolean transpose;
    GLdouble * value;
} ARGS_glProgramUniformMatrix2x4dv;
typedef struct {
    int index;
    ARGS_glProgramUniformMatrix2x4dv args;
} PACKED_glProgramUniformMatrix2x4dv;
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLboolean transpose;
    GLdouble * value;
} ARGS_glProgramUniformMatrix2x4dvEXT;
typedef struct {
    int index;
    ARGS_glProgramUniformMatrix2x4dvEXT args;
} PACKED_glProgramUniformMatrix2x4dvEXT;
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLboolean transpose;
    GLfloat * value;
} ARGS_glProgramUniformMatrix2x4fv;
typedef struct {
    int index;
    ARGS_glProgramUniformMatrix2x4fv args;
} PACKED_glProgramUniformMatrix2x4fv;
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLboolean transpose;
    GLfloat * value;
} ARGS_glProgramUniformMatrix2x4fvEXT;
typedef struct {
    int index;
    ARGS_glProgramUniformMatrix2x4fvEXT args;
} PACKED_glProgramUniformMatrix2x4fvEXT;
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLboolean transpose;
    GLdouble * value;
} ARGS_glProgramUniformMatrix3dv;
typedef struct {
    int index;
    ARGS_glProgramUniformMatrix3dv args;
} PACKED_glProgramUniformMatrix3dv;
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLboolean transpose;
    GLdouble * value;
} ARGS_glProgramUniformMatrix3dvEXT;
typedef struct {
    int index;
    ARGS_glProgramUniformMatrix3dvEXT args;
} PACKED_glProgramUniformMatrix3dvEXT;
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLboolean transpose;
    GLfloat * value;
} ARGS_glProgramUniformMatrix3fv;
typedef struct {
    int index;
    ARGS_glProgramUniformMatrix3fv args;
} PACKED_glProgramUniformMatrix3fv;
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLboolean transpose;
    GLfloat * value;
} ARGS_glProgramUniformMatrix3fvEXT;
typedef struct {
    int index;
    ARGS_glProgramUniformMatrix3fvEXT args;
} PACKED_glProgramUniformMatrix3fvEXT;
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLboolean transpose;
    GLdouble * value;
} ARGS_glProgramUniformMatrix3x2dv;
typedef struct {
    int index;
    ARGS_glProgramUniformMatrix3x2dv args;
} PACKED_glProgramUniformMatrix3x2dv;
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLboolean transpose;
    GLdouble * value;
} ARGS_glProgramUniformMatrix3x2dvEXT;
typedef struct {
    int index;
    ARGS_glProgramUniformMatrix3x2dvEXT args;
} PACKED_glProgramUniformMatrix3x2dvEXT;
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLboolean transpose;
    GLfloat * value;
} ARGS_glProgramUniformMatrix3x2fv;
typedef struct {
    int index;
    ARGS_glProgramUniformMatrix3x2fv args;
} PACKED_glProgramUniformMatrix3x2fv;
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLboolean transpose;
    GLfloat * value;
} ARGS_glProgramUniformMatrix3x2fvEXT;
typedef struct {
    int index;
    ARGS_glProgramUniformMatrix3x2fvEXT args;
} PACKED_glProgramUniformMatrix3x2fvEXT;
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLboolean transpose;
    GLdouble * value;
} ARGS_glProgramUniformMatrix3x4dv;
typedef struct {
    int index;
    ARGS_glProgramUniformMatrix3x4dv args;
} PACKED_glProgramUniformMatrix3x4dv;
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLboolean transpose;
    GLdouble * value;
} ARGS_glProgramUniformMatrix3x4dvEXT;
typedef struct {
    int index;
    ARGS_glProgramUniformMatrix3x4dvEXT args;
} PACKED_glProgramUniformMatrix3x4dvEXT;
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLboolean transpose;
    GLfloat * value;
} ARGS_glProgramUniformMatrix3x4fv;
typedef struct {
    int index;
    ARGS_glProgramUniformMatrix3x4fv args;
} PACKED_glProgramUniformMatrix3x4fv;
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLboolean transpose;
    GLfloat * value;
} ARGS_glProgramUniformMatrix3x4fvEXT;
typedef struct {
    int index;
    ARGS_glProgramUniformMatrix3x4fvEXT args;
} PACKED_glProgramUniformMatrix3x4fvEXT;
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLboolean transpose;
    GLdouble * value;
} ARGS_glProgramUniformMatrix4dv;
typedef struct {
    int index;
    ARGS_glProgramUniformMatrix4dv args;
} PACKED_glProgramUniformMatrix4dv;
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLboolean transpose;
    GLdouble * value;
} ARGS_glProgramUniformMatrix4dvEXT;
typedef struct {
    int index;
    ARGS_glProgramUniformMatrix4dvEXT args;
} PACKED_glProgramUniformMatrix4dvEXT;
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLboolean transpose;
    GLfloat * value;
} ARGS_glProgramUniformMatrix4fv;
typedef struct {
    int index;
    ARGS_glProgramUniformMatrix4fv args;
} PACKED_glProgramUniformMatrix4fv;
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLboolean transpose;
    GLfloat * value;
} ARGS_glProgramUniformMatrix4fvEXT;
typedef struct {
    int index;
    ARGS_glProgramUniformMatrix4fvEXT args;
} PACKED_glProgramUniformMatrix4fvEXT;
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLboolean transpose;
    GLdouble * value;
} ARGS_glProgramUniformMatrix4x2dv;
typedef struct {
    int index;
    ARGS_glProgramUniformMatrix4x2dv args;
} PACKED_glProgramUniformMatrix4x2dv;
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLboolean transpose;
    GLdouble * value;
} ARGS_glProgramUniformMatrix4x2dvEXT;
typedef struct {
    int index;
    ARGS_glProgramUniformMatrix4x2dvEXT args;
} PACKED_glProgramUniformMatrix4x2dvEXT;
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLboolean transpose;
    GLfloat * value;
} ARGS_glProgramUniformMatrix4x2fv;
typedef struct {
    int index;
    ARGS_glProgramUniformMatrix4x2fv args;
} PACKED_glProgramUniformMatrix4x2fv;
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLboolean transpose;
    GLfloat * value;
} ARGS_glProgramUniformMatrix4x2fvEXT;
typedef struct {
    int index;
    ARGS_glProgramUniformMatrix4x2fvEXT args;
} PACKED_glProgramUniformMatrix4x2fvEXT;
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLboolean transpose;
    GLdouble * value;
} ARGS_glProgramUniformMatrix4x3dv;
typedef struct {
    int index;
    ARGS_glProgramUniformMatrix4x3dv args;
} PACKED_glProgramUniformMatrix4x3dv;
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLboolean transpose;
    GLdouble * value;
} ARGS_glProgramUniformMatrix4x3dvEXT;
typedef struct {
    int index;
    ARGS_glProgramUniformMatrix4x3dvEXT args;
} PACKED_glProgramUniformMatrix4x3dvEXT;
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLboolean transpose;
    GLfloat * value;
} ARGS_glProgramUniformMatrix4x3fv;
typedef struct {
    int index;
    ARGS_glProgramUniformMatrix4x3fv args;
} PACKED_glProgramUniformMatrix4x3fv;
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLboolean transpose;
    GLfloat * value;
} ARGS_glProgramUniformMatrix4x3fvEXT;
typedef struct {
    int index;
    ARGS_glProgramUniformMatrix4x3fvEXT args;
} PACKED_glProgramUniformMatrix4x3fvEXT;
typedef struct {
    GLuint program;
    GLint location;
    GLuint64EXT value;
} ARGS_glProgramUniformui64NV;
typedef struct {
    int index;
    ARGS_glProgramUniformui64NV args;
} PACKED_glProgramUniformui64NV;
typedef struct {
    GLuint program;
    GLint location;
    GLsizei count;
    GLuint64EXT * value;
} ARGS_glProgramUniformui64vNV;
typedef struct {
    int index;
    ARGS_glProgramUniformui64vNV args;
} PACKED_glProgramUniformui64vNV;
typedef struct {
    GLenum target;
    GLint limit;
} ARGS_glProgramVertexLimitNV;
typedef struct {
    int index;
    ARGS_glProgramVertexLimitNV args;
} PACKED_glProgramVertexLimitNV;
typedef struct {
    GLenum mode;
} ARGS_glProvokingVertex;
typedef struct {
    int index;
    ARGS_glProvokingVertex args;
} PACKED_glProvokingVertex;
typedef struct {
    GLenum mode;
} ARGS_glProvokingVertexEXT;
typedef struct {
    int index;
    ARGS_glProvokingVertexEXT args;
} PACKED_glProvokingVertexEXT;
typedef struct {
    GLbitfield mask;
} ARGS_glPushAttrib;
typedef struct {
    int index;
    ARGS_glPushAttrib args;
} PACKED_glPushAttrib;
typedef struct {
    GLbitfield mask;
} ARGS_glPushClientAttrib;
typedef struct {
    int index;
    ARGS_glPushClientAttrib args;
} PACKED_glPushClientAttrib;
typedef struct {
    GLbitfield mask;
} ARGS_glPushClientAttribDefaultEXT;
typedef struct {
    int index;
    ARGS_glPushClientAttribDefaultEXT args;
} PACKED_glPushClientAttribDefaultEXT;
typedef struct {
    GLenum source;
    GLuint id;
    GLsizei length;
    GLchar * message;
} ARGS_glPushDebugGroup;
typedef struct {
    int index;
    ARGS_glPushDebugGroup args;
} PACKED_glPushDebugGroup;
typedef struct {
    int index;
} PACKED_glPushMatrix;
typedef struct {
    GLuint name;
} ARGS_glPushName;
typedef struct {
    int index;
    ARGS_glPushName args;
} PACKED_glPushName;
typedef struct {
    GLuint id;
    GLenum target;
} ARGS_glQueryCounter;
typedef struct {
    int index;
    ARGS_glQueryCounter args;
} PACKED_glQueryCounter;
typedef struct {
    GLfixed * mantissa;
    GLint * exponent;
} ARGS_glQueryMatrixxOES;
typedef struct {
    int index;
    ARGS_glQueryMatrixxOES args;
} PACKED_glQueryMatrixxOES;
typedef struct {
    GLdouble x __attribute__ ((aligned(8)));
    GLdouble y __attribute__ ((aligned(8)));
} ARGS_glRasterPos2d;
typedef struct {
    int index;
    ARGS_glRasterPos2d args;
} PACKED_glRasterPos2d;
typedef struct {
    GLdouble * v;
} ARGS_glRasterPos2dv;
typedef struct {
    int index;
    ARGS_glRasterPos2dv args;
} PACKED_glRasterPos2dv;
typedef struct {
    GLfloat x;
    GLfloat y;
} ARGS_glRasterPos2f;
typedef struct {
    int index;
    ARGS_glRasterPos2f args;
} PACKED_glRasterPos2f;
typedef struct {
    GLfloat * v;
} ARGS_glRasterPos2fv;
typedef struct {
    int index;
    ARGS_glRasterPos2fv args;
} PACKED_glRasterPos2fv;
typedef struct {
    GLint x;
    GLint y;
} ARGS_glRasterPos2i;
typedef struct {
    int index;
    ARGS_glRasterPos2i args;
} PACKED_glRasterPos2i;
typedef struct {
    GLint * v;
} ARGS_glRasterPos2iv;
typedef struct {
    int index;
    ARGS_glRasterPos2iv args;
} PACKED_glRasterPos2iv;
typedef struct {
    GLshort x;
    GLshort y;
} ARGS_glRasterPos2s;
typedef struct {
    int index;
    ARGS_glRasterPos2s args;
} PACKED_glRasterPos2s;
typedef struct {
    GLshort * v;
} ARGS_glRasterPos2sv;
typedef struct {
    int index;
    ARGS_glRasterPos2sv args;
} PACKED_glRasterPos2sv;
typedef struct {
    GLfixed x;
    GLfixed y;
} ARGS_glRasterPos2xOES;
typedef struct {
    int index;
    ARGS_glRasterPos2xOES args;
} PACKED_glRasterPos2xOES;
typedef struct {
    GLfixed * coords;
} ARGS_glRasterPos2xvOES;
typedef struct {
    int index;
    ARGS_glRasterPos2xvOES args;
} PACKED_glRasterPos2xvOES;
typedef struct {
    GLdouble x __attribute__ ((aligned(8)));
    GLdouble y __attribute__ ((aligned(8)));
    GLdouble z __attribute__ ((aligned(8)));
} ARGS_glRasterPos3d;
typedef struct {
    int index;
    ARGS_glRasterPos3d args;
} PACKED_glRasterPos3d;
typedef struct {
    GLdouble * v;
} ARGS_glRasterPos3dv;
typedef struct {
    int index;
    ARGS_glRasterPos3dv args;
} PACKED_glRasterPos3dv;
typedef struct {
    GLfloat x;
    GLfloat y;
    GLfloat z;
} ARGS_glRasterPos3f;
typedef struct {
    int index;
    ARGS_glRasterPos3f args;
} PACKED_glRasterPos3f;
typedef struct {
    GLfloat * v;
} ARGS_glRasterPos3fv;
typedef struct {
    int index;
    ARGS_glRasterPos3fv args;
} PACKED_glRasterPos3fv;
typedef struct {
    GLint x;
    GLint y;
    GLint z;
} ARGS_glRasterPos3i;
typedef struct {
    int index;
    ARGS_glRasterPos3i args;
} PACKED_glRasterPos3i;
typedef struct {
    GLint * v;
} ARGS_glRasterPos3iv;
typedef struct {
    int index;
    ARGS_glRasterPos3iv args;
} PACKED_glRasterPos3iv;
typedef struct {
    GLshort x;
    GLshort y;
    GLshort z;
} ARGS_glRasterPos3s;
typedef struct {
    int index;
    ARGS_glRasterPos3s args;
} PACKED_glRasterPos3s;
typedef struct {
    GLshort * v;
} ARGS_glRasterPos3sv;
typedef struct {
    int index;
    ARGS_glRasterPos3sv args;
} PACKED_glRasterPos3sv;
typedef struct {
    GLfixed x;
    GLfixed y;
    GLfixed z;
} ARGS_glRasterPos3xOES;
typedef struct {
    int index;
    ARGS_glRasterPos3xOES args;
} PACKED_glRasterPos3xOES;
typedef struct {
    GLfixed * coords;
} ARGS_glRasterPos3xvOES;
typedef struct {
    int index;
    ARGS_glRasterPos3xvOES args;
} PACKED_glRasterPos3xvOES;
typedef struct {
    GLdouble x __attribute__ ((aligned(8)));
    GLdouble y __attribute__ ((aligned(8)));
    GLdouble z __attribute__ ((aligned(8)));
    GLdouble w __attribute__ ((aligned(8)));
} ARGS_glRasterPos4d;
typedef struct {
    int index;
    ARGS_glRasterPos4d args;
} PACKED_glRasterPos4d;
typedef struct {
    GLdouble * v;
} ARGS_glRasterPos4dv;
typedef struct {
    int index;
    ARGS_glRasterPos4dv args;
} PACKED_glRasterPos4dv;
typedef struct {
    GLfloat x;
    GLfloat y;
    GLfloat z;
    GLfloat w;
} ARGS_glRasterPos4f;
typedef struct {
    int index;
    ARGS_glRasterPos4f args;
} PACKED_glRasterPos4f;
typedef struct {
    GLfloat * v;
} ARGS_glRasterPos4fv;
typedef struct {
    int index;
    ARGS_glRasterPos4fv args;
} PACKED_glRasterPos4fv;
typedef struct {
    GLint x;
    GLint y;
    GLint z;
    GLint w;
} ARGS_glRasterPos4i;
typedef struct {
    int index;
    ARGS_glRasterPos4i args;
} PACKED_glRasterPos4i;
typedef struct {
    GLint * v;
} ARGS_glRasterPos4iv;
typedef struct {
    int index;
    ARGS_glRasterPos4iv args;
} PACKED_glRasterPos4iv;
typedef struct {
    GLshort x;
    GLshort y;
    GLshort z;
    GLshort w;
} ARGS_glRasterPos4s;
typedef struct {
    int index;
    ARGS_glRasterPos4s args;
} PACKED_glRasterPos4s;
typedef struct {
    GLshort * v;
} ARGS_glRasterPos4sv;
typedef struct {
    int index;
    ARGS_glRasterPos4sv args;
} PACKED_glRasterPos4sv;
typedef struct {
    GLfixed x;
    GLfixed y;
    GLfixed z;
    GLfixed w;
} ARGS_glRasterPos4xOES;
typedef struct {
    int index;
    ARGS_glRasterPos4xOES args;
} PACKED_glRasterPos4xOES;
typedef struct {
    GLfixed * coords;
} ARGS_glRasterPos4xvOES;
typedef struct {
    int index;
    ARGS_glRasterPos4xvOES args;
} PACKED_glRasterPos4xvOES;
typedef struct {
    GLenum mode;
} ARGS_glReadBuffer;
typedef struct {
    int index;
    ARGS_glReadBuffer args;
} PACKED_glReadBuffer;
typedef struct {
    GLint marker;
} ARGS_glReadInstrumentsSGIX;
typedef struct {
    int index;
    ARGS_glReadInstrumentsSGIX args;
} PACKED_glReadInstrumentsSGIX;
typedef struct {
    GLint x;
    GLint y;
    GLsizei width;
    GLsizei height;
    GLenum format;
    GLenum type;
    GLvoid * pixels;
} ARGS_glReadPixels;
typedef struct {
    int index;
    ARGS_glReadPixels args;
} PACKED_glReadPixels;
typedef struct {
    GLint x;
    GLint y;
    GLsizei width;
    GLsizei height;
    GLenum format;
    GLenum type;
    GLsizei bufSize;
    GLvoid * data;
} ARGS_glReadnPixelsARB;
typedef struct {
    int index;
    ARGS_glReadnPixelsARB args;
} PACKED_glReadnPixelsARB;
typedef struct {
    GLdouble x1 __attribute__ ((aligned(8)));
    GLdouble y1 __attribute__ ((aligned(8)));
    GLdouble x2 __attribute__ ((aligned(8)));
    GLdouble y2 __attribute__ ((aligned(8)));
} ARGS_glRectd;
typedef struct {
    int index;
    ARGS_glRectd args;
} PACKED_glRectd;
typedef struct {
    GLdouble * v1;
    GLdouble * v2;
} ARGS_glRectdv;
typedef struct {
    int index;
    ARGS_glRectdv args;
} PACKED_glRectdv;
typedef struct {
    GLfloat x1;
    GLfloat y1;
    GLfloat x2;
    GLfloat y2;
} ARGS_glRectf;
typedef struct {
    int index;
    ARGS_glRectf args;
} PACKED_glRectf;
typedef struct {
    GLfloat * v1;
    GLfloat * v2;
} ARGS_glRectfv;
typedef struct {
    int index;
    ARGS_glRectfv args;
} PACKED_glRectfv;
typedef struct {
    GLint x1;
    GLint y1;
    GLint x2;
    GLint y2;
} ARGS_glRecti;
typedef struct {
    int index;
    ARGS_glRecti args;
} PACKED_glRecti;
typedef struct {
    GLint * v1;
    GLint * v2;
} ARGS_glRectiv;
typedef struct {
    int index;
    ARGS_glRectiv args;
} PACKED_glRectiv;
typedef struct {
    GLshort x1;
    GLshort y1;
    GLshort x2;
    GLshort y2;
} ARGS_glRects;
typedef struct {
    int index;
    ARGS_glRects args;
} PACKED_glRects;
typedef struct {
    GLshort * v1;
    GLshort * v2;
} ARGS_glRectsv;
typedef struct {
    int index;
    ARGS_glRectsv args;
} PACKED_glRectsv;
typedef struct {
    GLfixed x1;
    GLfixed y1;
    GLfixed x2;
    GLfixed y2;
} ARGS_glRectxOES;
typedef struct {
    int index;
    ARGS_glRectxOES args;
} PACKED_glRectxOES;
typedef struct {
    GLfixed * v1;
    GLfixed * v2;
} ARGS_glRectxvOES;
typedef struct {
    int index;
    ARGS_glRectxvOES args;
} PACKED_glRectxvOES;
typedef struct {
    GLdouble * equation;
} ARGS_glReferencePlaneSGIX;
typedef struct {
    int index;
    ARGS_glReferencePlaneSGIX args;
} PACKED_glReferencePlaneSGIX;
typedef struct {
    int index;
} PACKED_glReleaseShaderCompiler;
typedef struct {
    GLenum mode;
} ARGS_glRenderMode;
typedef struct {
    int index;
    ARGS_glRenderMode args;
} PACKED_glRenderMode;
typedef struct {
    GLenum target;
    GLenum internalformat;
    GLsizei width;
    GLsizei height;
} ARGS_glRenderbufferStorage;
typedef struct {
    int index;
    ARGS_glRenderbufferStorage args;
} PACKED_glRenderbufferStorage;
typedef struct {
    GLenum target;
    GLenum internalformat;
    GLsizei width;
    GLsizei height;
} ARGS_glRenderbufferStorageEXT;
typedef struct {
    int index;
    ARGS_glRenderbufferStorageEXT args;
} PACKED_glRenderbufferStorageEXT;
typedef struct {
    GLenum target;
    GLsizei samples;
    GLenum internalformat;
    GLsizei width;
    GLsizei height;
} ARGS_glRenderbufferStorageMultisample;
typedef struct {
    int index;
    ARGS_glRenderbufferStorageMultisample args;
} PACKED_glRenderbufferStorageMultisample;
typedef struct {
    GLenum target;
    GLsizei coverageSamples;
    GLsizei colorSamples;
    GLenum internalformat;
    GLsizei width;
    GLsizei height;
} ARGS_glRenderbufferStorageMultisampleCoverageNV;
typedef struct {
    int index;
    ARGS_glRenderbufferStorageMultisampleCoverageNV args;
} PACKED_glRenderbufferStorageMultisampleCoverageNV;
typedef struct {
    GLenum target;
    GLsizei samples;
    GLenum internalformat;
    GLsizei width;
    GLsizei height;
} ARGS_glRenderbufferStorageMultisampleEXT;
typedef struct {
    int index;
    ARGS_glRenderbufferStorageMultisampleEXT args;
} PACKED_glRenderbufferStorageMultisampleEXT;
typedef struct {
    GLenum type;
    GLsizei stride;
    GLvoid * pointer;
} ARGS_glReplacementCodePointerSUN;
typedef struct {
    int index;
    ARGS_glReplacementCodePointerSUN args;
} PACKED_glReplacementCodePointerSUN;
typedef struct {
    GLubyte code;
} ARGS_glReplacementCodeubSUN;
typedef struct {
    int index;
    ARGS_glReplacementCodeubSUN args;
} PACKED_glReplacementCodeubSUN;
typedef struct {
    GLubyte * code;
} ARGS_glReplacementCodeubvSUN;
typedef struct {
    int index;
    ARGS_glReplacementCodeubvSUN args;
} PACKED_glReplacementCodeubvSUN;
typedef struct {
    GLuint rc;
    GLfloat r;
    GLfloat g;
    GLfloat b;
    GLfloat x;
    GLfloat y;
    GLfloat z;
} ARGS_glReplacementCodeuiColor3fVertex3fSUN;
typedef struct {
    int index;
    ARGS_glReplacementCodeuiColor3fVertex3fSUN args;
} PACKED_glReplacementCodeuiColor3fVertex3fSUN;
typedef struct {
    GLuint * rc;
    GLfloat * c;
    GLfloat * v;
} ARGS_glReplacementCodeuiColor3fVertex3fvSUN;
typedef struct {
    int index;
    ARGS_glReplacementCodeuiColor3fVertex3fvSUN args;
} PACKED_glReplacementCodeuiColor3fVertex3fvSUN;
typedef struct {
    GLuint rc;
    GLfloat r;
    GLfloat g;
    GLfloat b;
    GLfloat a;
    GLfloat nx;
    GLfloat ny;
    GLfloat nz;
    GLfloat x;
    GLfloat y;
    GLfloat z;
} ARGS_glReplacementCodeuiColor4fNormal3fVertex3fSUN;
typedef struct {
    int index;
    ARGS_glReplacementCodeuiColor4fNormal3fVertex3fSUN args;
} PACKED_glReplacementCodeuiColor4fNormal3fVertex3fSUN;
typedef struct {
    GLuint * rc;
    GLfloat * c;
    GLfloat * n;
    GLfloat * v;
} ARGS_glReplacementCodeuiColor4fNormal3fVertex3fvSUN;
typedef struct {
    int index;
    ARGS_glReplacementCodeuiColor4fNormal3fVertex3fvSUN args;
} PACKED_glReplacementCodeuiColor4fNormal3fVertex3fvSUN;
typedef struct {
    GLuint rc;
    GLubyte r;
    GLubyte g;
    GLubyte b;
    GLubyte a;
    GLfloat x;
    GLfloat y;
    GLfloat z;
} ARGS_glReplacementCodeuiColor4ubVertex3fSUN;
typedef struct {
    int index;
    ARGS_glReplacementCodeuiColor4ubVertex3fSUN args;
} PACKED_glReplacementCodeuiColor4ubVertex3fSUN;
typedef struct {
    GLuint * rc;
    GLubyte * c;
    GLfloat * v;
} ARGS_glReplacementCodeuiColor4ubVertex3fvSUN;
typedef struct {
    int index;
    ARGS_glReplacementCodeuiColor4ubVertex3fvSUN args;
} PACKED_glReplacementCodeuiColor4ubVertex3fvSUN;
typedef struct {
    GLuint rc;
    GLfloat nx;
    GLfloat ny;
    GLfloat nz;
    GLfloat x;
    GLfloat y;
    GLfloat z;
} ARGS_glReplacementCodeuiNormal3fVertex3fSUN;
typedef struct {
    int index;
    ARGS_glReplacementCodeuiNormal3fVertex3fSUN args;
} PACKED_glReplacementCodeuiNormal3fVertex3fSUN;
typedef struct {
    GLuint * rc;
    GLfloat * n;
    GLfloat * v;
} ARGS_glReplacementCodeuiNormal3fVertex3fvSUN;
typedef struct {
    int index;
    ARGS_glReplacementCodeuiNormal3fVertex3fvSUN args;
} PACKED_glReplacementCodeuiNormal3fVertex3fvSUN;
typedef struct {
    GLuint code;
} ARGS_glReplacementCodeuiSUN;
typedef struct {
    int index;
    ARGS_glReplacementCodeuiSUN args;
} PACKED_glReplacementCodeuiSUN;
typedef struct {
    GLuint rc;
    GLfloat s;
    GLfloat t;
    GLfloat r;
    GLfloat g;
    GLfloat b;
    GLfloat a;
    GLfloat nx;
    GLfloat ny;
    GLfloat nz;
    GLfloat x;
    GLfloat y;
    GLfloat z;
} ARGS_glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN;
typedef struct {
    int index;
    ARGS_glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN args;
} PACKED_glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN;
typedef struct {
    GLuint * rc;
    GLfloat * tc;
    GLfloat * c;
    GLfloat * n;
    GLfloat * v;
} ARGS_glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN;
typedef struct {
    int index;
    ARGS_glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN args;
} PACKED_glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN;
typedef struct {
    GLuint rc;
    GLfloat s;
    GLfloat t;
    GLfloat nx;
    GLfloat ny;
    GLfloat nz;
    GLfloat x;
    GLfloat y;
    GLfloat z;
} ARGS_glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN;
typedef struct {
    int index;
    ARGS_glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN args;
} PACKED_glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN;
typedef struct {
    GLuint * rc;
    GLfloat * tc;
    GLfloat * n;
    GLfloat * v;
} ARGS_glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN;
typedef struct {
    int index;
    ARGS_glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN args;
} PACKED_glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN;
typedef struct {
    GLuint rc;
    GLfloat s;
    GLfloat t;
    GLfloat x;
    GLfloat y;
    GLfloat z;
} ARGS_glReplacementCodeuiTexCoord2fVertex3fSUN;
typedef struct {
    int index;
    ARGS_glReplacementCodeuiTexCoord2fVertex3fSUN args;
} PACKED_glReplacementCodeuiTexCoord2fVertex3fSUN;
typedef struct {
    GLuint * rc;
    GLfloat * tc;
    GLfloat * v;
} ARGS_glReplacementCodeuiTexCoord2fVertex3fvSUN;
typedef struct {
    int index;
    ARGS_glReplacementCodeuiTexCoord2fVertex3fvSUN args;
} PACKED_glReplacementCodeuiTexCoord2fVertex3fvSUN;
typedef struct {
    GLuint rc;
    GLfloat x;
    GLfloat y;
    GLfloat z;
} ARGS_glReplacementCodeuiVertex3fSUN;
typedef struct {
    int index;
    ARGS_glReplacementCodeuiVertex3fSUN args;
} PACKED_glReplacementCodeuiVertex3fSUN;
typedef struct {
    GLuint * rc;
    GLfloat * v;
} ARGS_glReplacementCodeuiVertex3fvSUN;
typedef struct {
    int index;
    ARGS_glReplacementCodeuiVertex3fvSUN args;
} PACKED_glReplacementCodeuiVertex3fvSUN;
typedef struct {
    GLuint * code;
} ARGS_glReplacementCodeuivSUN;
typedef struct {
    int index;
    ARGS_glReplacementCodeuivSUN args;
} PACKED_glReplacementCodeuivSUN;
typedef struct {
    GLushort code;
} ARGS_glReplacementCodeusSUN;
typedef struct {
    int index;
    ARGS_glReplacementCodeusSUN args;
} PACKED_glReplacementCodeusSUN;
typedef struct {
    GLushort * code;
} ARGS_glReplacementCodeusvSUN;
typedef struct {
    int index;
    ARGS_glReplacementCodeusvSUN args;
} PACKED_glReplacementCodeusvSUN;
typedef struct {
    GLsizei n;
    GLuint * programs;
} ARGS_glRequestResidentProgramsNV;
typedef struct {
    int index;
    ARGS_glRequestResidentProgramsNV args;
} PACKED_glRequestResidentProgramsNV;
typedef struct {
    GLenum target;
} ARGS_glResetHistogram;
typedef struct {
    int index;
    ARGS_glResetHistogram args;
} PACKED_glResetHistogram;
typedef struct {
    GLenum target;
} ARGS_glResetHistogramEXT;
typedef struct {
    int index;
    ARGS_glResetHistogramEXT args;
} PACKED_glResetHistogramEXT;
typedef struct {
    GLenum target;
} ARGS_glResetMinmax;
typedef struct {
    int index;
    ARGS_glResetMinmax args;
} PACKED_glResetMinmax;
typedef struct {
    GLenum target;
} ARGS_glResetMinmaxEXT;
typedef struct {
    int index;
    ARGS_glResetMinmaxEXT args;
} PACKED_glResetMinmaxEXT;
typedef struct {
    int index;
} PACKED_glResizeBuffersMESA;
typedef struct {
    int index;
} PACKED_glResumeTransformFeedback;
typedef struct {
    int index;
} PACKED_glResumeTransformFeedbackNV;
typedef struct {
    GLdouble angle __attribute__ ((aligned(8)));
    GLdouble x __attribute__ ((aligned(8)));
    GLdouble y __attribute__ ((aligned(8)));
    GLdouble z __attribute__ ((aligned(8)));
} ARGS_glRotated;
typedef struct {
    int index;
    ARGS_glRotated args;
} PACKED_glRotated;
typedef struct {
    GLfloat angle;
    GLfloat x;
    GLfloat y;
    GLfloat z;
} ARGS_glRotatef;
typedef struct {
    int index;
    ARGS_glRotatef args;
} PACKED_glRotatef;
typedef struct {
    GLfixed angle;
    GLfixed x;
    GLfixed y;
    GLfixed z;
} ARGS_glRotatex;
typedef struct {
    int index;
    ARGS_glRotatex args;
} PACKED_glRotatex;
typedef struct {
    GLfixed angle;
    GLfixed x;
    GLfixed y;
    GLfixed z;
} ARGS_glRotatexOES;
typedef struct {
    int index;
    ARGS_glRotatexOES args;
} PACKED_glRotatexOES;
typedef struct {
    GLclampf value;
    GLboolean invert;
} ARGS_glSampleCoverage;
typedef struct {
    int index;
    ARGS_glSampleCoverage args;
} PACKED_glSampleCoverage;
typedef struct {
    GLfloat value;
    GLboolean invert;
} ARGS_glSampleCoverageARB;
typedef struct {
    int index;
    ARGS_glSampleCoverageARB args;
} PACKED_glSampleCoverageARB;
typedef struct {
    GLfixed value;
    GLboolean invert;
} ARGS_glSampleCoverageOES;
typedef struct {
    int index;
    ARGS_glSampleCoverageOES args;
} PACKED_glSampleCoverageOES;
typedef struct {
    GLclampx value;
    GLboolean invert;
} ARGS_glSampleCoveragex;
typedef struct {
    int index;
    ARGS_glSampleCoveragex args;
} PACKED_glSampleCoveragex;
typedef struct {
    GLuint dst;
    GLuint interp;
    GLenum swizzle;
} ARGS_glSampleMapATI;
typedef struct {
    int index;
    ARGS_glSampleMapATI args;
} PACKED_glSampleMapATI;
typedef struct {
    GLclampf value;
    GLboolean invert;
} ARGS_glSampleMaskEXT;
typedef struct {
    int index;
    ARGS_glSampleMaskEXT args;
} PACKED_glSampleMaskEXT;
typedef struct {
    GLuint index;
    GLbitfield mask;
} ARGS_glSampleMaskIndexedNV;
typedef struct {
    int index;
    ARGS_glSampleMaskIndexedNV args;
} PACKED_glSampleMaskIndexedNV;
typedef struct {
    GLclampf value;
    GLboolean invert;
} ARGS_glSampleMaskSGIS;
typedef struct {
    int index;
    ARGS_glSampleMaskSGIS args;
} PACKED_glSampleMaskSGIS;
typedef struct {
    GLuint index;
    GLbitfield mask;
} ARGS_glSampleMaski;
typedef struct {
    int index;
    ARGS_glSampleMaski args;
} PACKED_glSampleMaski;
typedef struct {
    GLenum pattern;
} ARGS_glSamplePatternEXT;
typedef struct {
    int index;
    ARGS_glSamplePatternEXT args;
} PACKED_glSamplePatternEXT;
typedef struct {
    GLenum pattern;
} ARGS_glSamplePatternSGIS;
typedef struct {
    int index;
    ARGS_glSamplePatternSGIS args;
} PACKED_glSamplePatternSGIS;
typedef struct {
    GLuint sampler;
    GLenum pname;
    GLint * param;
} ARGS_glSamplerParameterIiv;
typedef struct {
    int index;
    ARGS_glSamplerParameterIiv args;
} PACKED_glSamplerParameterIiv;
typedef struct {
    GLuint sampler;
    GLenum pname;
    GLuint * param;
} ARGS_glSamplerParameterIuiv;
typedef struct {
    int index;
    ARGS_glSamplerParameterIuiv args;
} PACKED_glSamplerParameterIuiv;
typedef struct {
    GLuint sampler;
    GLenum pname;
    GLfloat param;
} ARGS_glSamplerParameterf;
typedef struct {
    int index;
    ARGS_glSamplerParameterf args;
} PACKED_glSamplerParameterf;
typedef struct {
    GLuint sampler;
    GLenum pname;
    GLfloat * param;
} ARGS_glSamplerParameterfv;
typedef struct {
    int index;
    ARGS_glSamplerParameterfv args;
} PACKED_glSamplerParameterfv;
typedef struct {
    GLuint sampler;
    GLenum pname;
    GLint param;
} ARGS_glSamplerParameteri;
typedef struct {
    int index;
    ARGS_glSamplerParameteri args;
} PACKED_glSamplerParameteri;
typedef struct {
    GLuint sampler;
    GLenum pname;
    GLint * param;
} ARGS_glSamplerParameteriv;
typedef struct {
    int index;
    ARGS_glSamplerParameteriv args;
} PACKED_glSamplerParameteriv;
typedef struct {
    GLdouble x __attribute__ ((aligned(8)));
    GLdouble y __attribute__ ((aligned(8)));
    GLdouble z __attribute__ ((aligned(8)));
} ARGS_glScaled;
typedef struct {
    int index;
    ARGS_glScaled args;
} PACKED_glScaled;
typedef struct {
    GLfloat x;
    GLfloat y;
    GLfloat z;
} ARGS_glScalef;
typedef struct {
    int index;
    ARGS_glScalef args;
} PACKED_glScalef;
typedef struct {
    GLfixed x;
    GLfixed y;
    GLfixed z;
} ARGS_glScalex;
typedef struct {
    int index;
    ARGS_glScalex args;
} PACKED_glScalex;
typedef struct {
    GLfixed x;
    GLfixed y;
    GLfixed z;
} ARGS_glScalexOES;
typedef struct {
    int index;
    ARGS_glScalexOES args;
} PACKED_glScalexOES;
typedef struct {
    GLint x;
    GLint y;
    GLsizei width;
    GLsizei height;
} ARGS_glScissor;
typedef struct {
    int index;
    ARGS_glScissor args;
} PACKED_glScissor;
typedef struct {
    GLuint first;
    GLsizei count;
    GLint * v;
} ARGS_glScissorArrayv;
typedef struct {
    int index;
    ARGS_glScissorArrayv args;
} PACKED_glScissorArrayv;
typedef struct {
    GLuint index;
    GLint left;
    GLint bottom;
    GLsizei width;
    GLsizei height;
} ARGS_glScissorIndexed;
typedef struct {
    int index;
    ARGS_glScissorIndexed args;
} PACKED_glScissorIndexed;
typedef struct {
    GLuint index;
    GLint * v;
} ARGS_glScissorIndexedv;
typedef struct {
    int index;
    ARGS_glScissorIndexedv args;
} PACKED_glScissorIndexedv;
typedef struct {
    GLbyte red;
    GLbyte green;
    GLbyte blue;
} ARGS_glSecondaryColor3b;
typedef struct {
    int index;
    ARGS_glSecondaryColor3b args;
} PACKED_glSecondaryColor3b;
typedef struct {
    GLbyte red;
    GLbyte green;
    GLbyte blue;
} ARGS_glSecondaryColor3bEXT;
typedef struct {
    int index;
    ARGS_glSecondaryColor3bEXT args;
} PACKED_glSecondaryColor3bEXT;
typedef struct {
    GLbyte * v;
} ARGS_glSecondaryColor3bv;
typedef struct {
    int index;
    ARGS_glSecondaryColor3bv args;
} PACKED_glSecondaryColor3bv;
typedef struct {
    GLbyte * v;
} ARGS_glSecondaryColor3bvEXT;
typedef struct {
    int index;
    ARGS_glSecondaryColor3bvEXT args;
} PACKED_glSecondaryColor3bvEXT;
typedef struct {
    GLdouble red __attribute__ ((aligned(8)));
    GLdouble green __attribute__ ((aligned(8)));
    GLdouble blue __attribute__ ((aligned(8)));
} ARGS_glSecondaryColor3d;
typedef struct {
    int index;
    ARGS_glSecondaryColor3d args;
} PACKED_glSecondaryColor3d;
typedef struct {
    GLdouble red __attribute__ ((aligned(8)));
    GLdouble green __attribute__ ((aligned(8)));
    GLdouble blue __attribute__ ((aligned(8)));
} ARGS_glSecondaryColor3dEXT;
typedef struct {
    int index;
    ARGS_glSecondaryColor3dEXT args;
} PACKED_glSecondaryColor3dEXT;
typedef struct {
    GLdouble * v;
} ARGS_glSecondaryColor3dv;
typedef struct {
    int index;
    ARGS_glSecondaryColor3dv args;
} PACKED_glSecondaryColor3dv;
typedef struct {
    GLdouble * v;
} ARGS_glSecondaryColor3dvEXT;
typedef struct {
    int index;
    ARGS_glSecondaryColor3dvEXT args;
} PACKED_glSecondaryColor3dvEXT;
typedef struct {
    GLfloat red;
    GLfloat green;
    GLfloat blue;
} ARGS_glSecondaryColor3f;
typedef struct {
    int index;
    ARGS_glSecondaryColor3f args;
} PACKED_glSecondaryColor3f;
typedef struct {
    GLfloat red;
    GLfloat green;
    GLfloat blue;
} ARGS_glSecondaryColor3fEXT;
typedef struct {
    int index;
    ARGS_glSecondaryColor3fEXT args;
} PACKED_glSecondaryColor3fEXT;
typedef struct {
    GLfloat * v;
} ARGS_glSecondaryColor3fv;
typedef struct {
    int index;
    ARGS_glSecondaryColor3fv args;
} PACKED_glSecondaryColor3fv;
typedef struct {
    GLfloat * v;
} ARGS_glSecondaryColor3fvEXT;
typedef struct {
    int index;
    ARGS_glSecondaryColor3fvEXT args;
} PACKED_glSecondaryColor3fvEXT;
typedef struct {
    GLhalfNV red;
    GLhalfNV green;
    GLhalfNV blue;
} ARGS_glSecondaryColor3hNV;
typedef struct {
    int index;
    ARGS_glSecondaryColor3hNV args;
} PACKED_glSecondaryColor3hNV;
typedef struct {
    GLhalfNV * v;
} ARGS_glSecondaryColor3hvNV;
typedef struct {
    int index;
    ARGS_glSecondaryColor3hvNV args;
} PACKED_glSecondaryColor3hvNV;
typedef struct {
    GLint red;
    GLint green;
    GLint blue;
} ARGS_glSecondaryColor3i;
typedef struct {
    int index;
    ARGS_glSecondaryColor3i args;
} PACKED_glSecondaryColor3i;
typedef struct {
    GLint red;
    GLint green;
    GLint blue;
} ARGS_glSecondaryColor3iEXT;
typedef struct {
    int index;
    ARGS_glSecondaryColor3iEXT args;
} PACKED_glSecondaryColor3iEXT;
typedef struct {
    GLint * v;
} ARGS_glSecondaryColor3iv;
typedef struct {
    int index;
    ARGS_glSecondaryColor3iv args;
} PACKED_glSecondaryColor3iv;
typedef struct {
    GLint * v;
} ARGS_glSecondaryColor3ivEXT;
typedef struct {
    int index;
    ARGS_glSecondaryColor3ivEXT args;
} PACKED_glSecondaryColor3ivEXT;
typedef struct {
    GLshort red;
    GLshort green;
    GLshort blue;
} ARGS_glSecondaryColor3s;
typedef struct {
    int index;
    ARGS_glSecondaryColor3s args;
} PACKED_glSecondaryColor3s;
typedef struct {
    GLshort red;
    GLshort green;
    GLshort blue;
} ARGS_glSecondaryColor3sEXT;
typedef struct {
    int index;
    ARGS_glSecondaryColor3sEXT args;
} PACKED_glSecondaryColor3sEXT;
typedef struct {
    GLshort * v;
} ARGS_glSecondaryColor3sv;
typedef struct {
    int index;
    ARGS_glSecondaryColor3sv args;
} PACKED_glSecondaryColor3sv;
typedef struct {
    GLshort * v;
} ARGS_glSecondaryColor3svEXT;
typedef struct {
    int index;
    ARGS_glSecondaryColor3svEXT args;
} PACKED_glSecondaryColor3svEXT;
typedef struct {
    GLubyte red;
    GLubyte green;
    GLubyte blue;
} ARGS_glSecondaryColor3ub;
typedef struct {
    int index;
    ARGS_glSecondaryColor3ub args;
} PACKED_glSecondaryColor3ub;
typedef struct {
    GLubyte red;
    GLubyte green;
    GLubyte blue;
} ARGS_glSecondaryColor3ubEXT;
typedef struct {
    int index;
    ARGS_glSecondaryColor3ubEXT args;
} PACKED_glSecondaryColor3ubEXT;
typedef struct {
    GLubyte * v;
} ARGS_glSecondaryColor3ubv;
typedef struct {
    int index;
    ARGS_glSecondaryColor3ubv args;
} PACKED_glSecondaryColor3ubv;
typedef struct {
    GLubyte * v;
} ARGS_glSecondaryColor3ubvEXT;
typedef struct {
    int index;
    ARGS_glSecondaryColor3ubvEXT args;
} PACKED_glSecondaryColor3ubvEXT;
typedef struct {
    GLuint red;
    GLuint green;
    GLuint blue;
} ARGS_glSecondaryColor3ui;
typedef struct {
    int index;
    ARGS_glSecondaryColor3ui args;
} PACKED_glSecondaryColor3ui;
typedef struct {
    GLuint red;
    GLuint green;
    GLuint blue;
} ARGS_glSecondaryColor3uiEXT;
typedef struct {
    int index;
    ARGS_glSecondaryColor3uiEXT args;
} PACKED_glSecondaryColor3uiEXT;
typedef struct {
    GLuint * v;
} ARGS_glSecondaryColor3uiv;
typedef struct {
    int index;
    ARGS_glSecondaryColor3uiv args;
} PACKED_glSecondaryColor3uiv;
typedef struct {
    GLuint * v;
} ARGS_glSecondaryColor3uivEXT;
typedef struct {
    int index;
    ARGS_glSecondaryColor3uivEXT args;
} PACKED_glSecondaryColor3uivEXT;
typedef struct {
    GLushort red;
    GLushort green;
    GLushort blue;
} ARGS_glSecondaryColor3us;
typedef struct {
    int index;
    ARGS_glSecondaryColor3us args;
} PACKED_glSecondaryColor3us;
typedef struct {
    GLushort red;
    GLushort green;
    GLushort blue;
} ARGS_glSecondaryColor3usEXT;
typedef struct {
    int index;
    ARGS_glSecondaryColor3usEXT args;
} PACKED_glSecondaryColor3usEXT;
typedef struct {
    GLushort * v;
} ARGS_glSecondaryColor3usv;
typedef struct {
    int index;
    ARGS_glSecondaryColor3usv args;
} PACKED_glSecondaryColor3usv;
typedef struct {
    GLushort * v;
} ARGS_glSecondaryColor3usvEXT;
typedef struct {
    int index;
    ARGS_glSecondaryColor3usvEXT args;
} PACKED_glSecondaryColor3usvEXT;
typedef struct {
    GLint size;
    GLenum type;
    GLsizei stride;
} ARGS_glSecondaryColorFormatNV;
typedef struct {
    int index;
    ARGS_glSecondaryColorFormatNV args;
} PACKED_glSecondaryColorFormatNV;
typedef struct {
    GLenum type;
    GLuint color;
} ARGS_glSecondaryColorP3ui;
typedef struct {
    int index;
    ARGS_glSecondaryColorP3ui args;
} PACKED_glSecondaryColorP3ui;
typedef struct {
    GLenum type;
    GLuint * color;
} ARGS_glSecondaryColorP3uiv;
typedef struct {
    int index;
    ARGS_glSecondaryColorP3uiv args;
} PACKED_glSecondaryColorP3uiv;
typedef struct {
    GLint size;
    GLenum type;
    GLsizei stride;
    GLvoid * pointer;
} ARGS_glSecondaryColorPointer;
typedef struct {
    int index;
    ARGS_glSecondaryColorPointer args;
} PACKED_glSecondaryColorPointer;
typedef struct {
    GLint size;
    GLenum type;
    GLsizei stride;
    GLvoid * pointer;
} ARGS_glSecondaryColorPointerEXT;
typedef struct {
    int index;
    ARGS_glSecondaryColorPointerEXT args;
} PACKED_glSecondaryColorPointerEXT;
typedef struct {
    GLint size;
    GLenum type;
    GLint stride;
    GLvoid * pointer;
    GLint ptrstride;
} ARGS_glSecondaryColorPointerListIBM;
typedef struct {
    int index;
    ARGS_glSecondaryColorPointerListIBM args;
} PACKED_glSecondaryColorPointerListIBM;
typedef struct {
    GLsizei size;
    GLuint * buffer;
} ARGS_glSelectBuffer;
typedef struct {
    int index;
    ARGS_glSelectBuffer args;
} PACKED_glSelectBuffer;
typedef struct {
    GLuint monitor;
    GLboolean enable;
    GLuint group;
    GLint numCounters;
    GLuint * counterList;
} ARGS_glSelectPerfMonitorCountersAMD;
typedef struct {
    int index;
    ARGS_glSelectPerfMonitorCountersAMD args;
} PACKED_glSelectPerfMonitorCountersAMD;
typedef struct {
    GLenum target;
    GLenum internalformat;
    GLsizei width;
    GLsizei height;
    GLenum format;
    GLenum type;
    GLvoid * row;
    GLvoid * column;
} ARGS_glSeparableFilter2D;
typedef struct {
    int index;
    ARGS_glSeparableFilter2D args;
} PACKED_glSeparableFilter2D;
typedef struct {
    GLenum target;
    GLenum internalformat;
    GLsizei width;
    GLsizei height;
    GLenum format;
    GLenum type;
    GLvoid * row;
    GLvoid * column;
} ARGS_glSeparableFilter2DEXT;
typedef struct {
    int index;
    ARGS_glSeparableFilter2DEXT args;
} PACKED_glSeparableFilter2DEXT;
typedef struct {
    GLuint fence;
} ARGS_glSetFenceAPPLE;
typedef struct {
    int index;
    ARGS_glSetFenceAPPLE args;
} PACKED_glSetFenceAPPLE;
typedef struct {
    GLuint fence;
    GLenum condition;
} ARGS_glSetFenceNV;
typedef struct {
    int index;
    ARGS_glSetFenceNV args;
} PACKED_glSetFenceNV;
typedef struct {
    GLuint dst;
    GLfloat * value;
} ARGS_glSetFragmentShaderConstantATI;
typedef struct {
    int index;
    ARGS_glSetFragmentShaderConstantATI args;
} PACKED_glSetFragmentShaderConstantATI;
typedef struct {
    GLuint id;
    GLenum type;
    GLvoid * addr;
} ARGS_glSetInvariantEXT;
typedef struct {
    int index;
    ARGS_glSetInvariantEXT args;
} PACKED_glSetInvariantEXT;
typedef struct {
    GLuint id;
    GLenum type;
    GLvoid * addr;
} ARGS_glSetLocalConstantEXT;
typedef struct {
    int index;
    ARGS_glSetLocalConstantEXT args;
} PACKED_glSetLocalConstantEXT;
typedef struct {
    GLenum pname;
    GLuint index;
    GLfloat * val;
} ARGS_glSetMultisamplefvAMD;
typedef struct {
    int index;
    ARGS_glSetMultisamplefvAMD args;
} PACKED_glSetMultisamplefvAMD;
typedef struct {
    GLenum mode;
} ARGS_glShadeModel;
typedef struct {
    int index;
    ARGS_glShadeModel args;
} PACKED_glShadeModel;
typedef struct {
    GLsizei count;
    GLuint * shaders;
    GLenum binaryformat;
    GLvoid * binary;
    GLsizei length;
} ARGS_glShaderBinary;
typedef struct {
    int index;
    ARGS_glShaderBinary args;
} PACKED_glShaderBinary;
typedef struct {
    GLenum op;
    GLuint res;
    GLuint arg1;
} ARGS_glShaderOp1EXT;
typedef struct {
    int index;
    ARGS_glShaderOp1EXT args;
} PACKED_glShaderOp1EXT;
typedef struct {
    GLenum op;
    GLuint res;
    GLuint arg1;
    GLuint arg2;
} ARGS_glShaderOp2EXT;
typedef struct {
    int index;
    ARGS_glShaderOp2EXT args;
} PACKED_glShaderOp2EXT;
typedef struct {
    GLenum op;
    GLuint res;
    GLuint arg1;
    GLuint arg2;
    GLuint arg3;
} ARGS_glShaderOp3EXT;
typedef struct {
    int index;
    ARGS_glShaderOp3EXT args;
} PACKED_glShaderOp3EXT;
typedef struct {
    GLuint shader;
    GLsizei count;
    GLchar * * string;
    GLint * length;
} ARGS_glShaderSource;
typedef struct {
    int index;
    ARGS_glShaderSource args;
} PACKED_glShaderSource;
typedef struct {
    GLhandleARB shaderObj;
    GLsizei count;
    GLcharARB * string;
    GLint * length;
} ARGS_glShaderSourceARB;
typedef struct {
    int index;
    ARGS_glShaderSourceARB args;
} PACKED_glShaderSourceARB;
typedef struct {
    GLuint program;
    GLuint storageBlockIndex;
    GLuint storageBlockBinding;
} ARGS_glShaderStorageBlockBinding;
typedef struct {
    int index;
    ARGS_glShaderStorageBlockBinding args;
} PACKED_glShaderStorageBlockBinding;
typedef struct {
    GLenum target;
    GLsizei n;
    GLfloat * points;
} ARGS_glSharpenTexFuncSGIS;
typedef struct {
    int index;
    ARGS_glSharpenTexFuncSGIS args;
} PACKED_glSharpenTexFuncSGIS;
typedef struct {
    GLenum pname;
    GLfloat param;
} ARGS_glSpriteParameterfSGIX;
typedef struct {
    int index;
    ARGS_glSpriteParameterfSGIX args;
} PACKED_glSpriteParameterfSGIX;
typedef struct {
    GLenum pname;
    GLfloat * params;
} ARGS_glSpriteParameterfvSGIX;
typedef struct {
    int index;
    ARGS_glSpriteParameterfvSGIX args;
} PACKED_glSpriteParameterfvSGIX;
typedef struct {
    GLenum pname;
    GLint param;
} ARGS_glSpriteParameteriSGIX;
typedef struct {
    int index;
    ARGS_glSpriteParameteriSGIX args;
} PACKED_glSpriteParameteriSGIX;
typedef struct {
    GLenum pname;
    GLint * params;
} ARGS_glSpriteParameterivSGIX;
typedef struct {
    int index;
    ARGS_glSpriteParameterivSGIX args;
} PACKED_glSpriteParameterivSGIX;
typedef struct {
    int index;
} PACKED_glStartInstrumentsSGIX;
typedef struct {
    GLsizei stencilTagBits;
    GLuint stencilClearTag;
} ARGS_glStencilClearTagEXT;
typedef struct {
    int index;
    ARGS_glStencilClearTagEXT args;
} PACKED_glStencilClearTagEXT;
typedef struct {
    GLsizei numPaths;
    GLenum pathNameType;
    GLvoid * paths;
    GLuint pathBase;
    GLenum fillMode;
    GLuint mask;
    GLenum transformType;
    GLfloat * transformValues;
} ARGS_glStencilFillPathInstancedNV;
typedef struct {
    int index;
    ARGS_glStencilFillPathInstancedNV args;
} PACKED_glStencilFillPathInstancedNV;
typedef struct {
    GLuint path;
    GLenum fillMode;
    GLuint mask;
} ARGS_glStencilFillPathNV;
typedef struct {
    int index;
    ARGS_glStencilFillPathNV args;
} PACKED_glStencilFillPathNV;
typedef struct {
    GLenum func;
    GLint ref;
    GLuint mask;
} ARGS_glStencilFunc;
typedef struct {
    int index;
    ARGS_glStencilFunc args;
} PACKED_glStencilFunc;
typedef struct {
    GLenum face;
    GLenum func;
    GLint ref;
    GLuint mask;
} ARGS_glStencilFuncSeparate;
typedef struct {
    int index;
    ARGS_glStencilFuncSeparate args;
} PACKED_glStencilFuncSeparate;
typedef struct {
    GLenum frontfunc;
    GLenum backfunc;
    GLint ref;
    GLuint mask;
} ARGS_glStencilFuncSeparateATI;
typedef struct {
    int index;
    ARGS_glStencilFuncSeparateATI args;
} PACKED_glStencilFuncSeparateATI;
typedef struct {
    GLuint mask;
} ARGS_glStencilMask;
typedef struct {
    int index;
    ARGS_glStencilMask args;
} PACKED_glStencilMask;
typedef struct {
    GLenum face;
    GLuint mask;
} ARGS_glStencilMaskSeparate;
typedef struct {
    int index;
    ARGS_glStencilMaskSeparate args;
} PACKED_glStencilMaskSeparate;
typedef struct {
    GLenum fail;
    GLenum zfail;
    GLenum zpass;
} ARGS_glStencilOp;
typedef struct {
    int index;
    ARGS_glStencilOp args;
} PACKED_glStencilOp;
typedef struct {
    GLenum face;
    GLenum sfail;
    GLenum dpfail;
    GLenum dppass;
} ARGS_glStencilOpSeparate;
typedef struct {
    int index;
    ARGS_glStencilOpSeparate args;
} PACKED_glStencilOpSeparate;
typedef struct {
    GLenum face;
    GLenum sfail;
    GLenum dpfail;
    GLenum dppass;
} ARGS_glStencilOpSeparateATI;
typedef struct {
    int index;
    ARGS_glStencilOpSeparateATI args;
} PACKED_glStencilOpSeparateATI;
typedef struct {
    GLenum face;
    GLuint value;
} ARGS_glStencilOpValueAMD;
typedef struct {
    int index;
    ARGS_glStencilOpValueAMD args;
} PACKED_glStencilOpValueAMD;
typedef struct {
    GLsizei numPaths;
    GLenum pathNameType;
    GLvoid * paths;
    GLuint pathBase;
    GLint reference;
    GLuint mask;
    GLenum transformType;
    GLfloat * transformValues;
} ARGS_glStencilStrokePathInstancedNV;
typedef struct {
    int index;
    ARGS_glStencilStrokePathInstancedNV args;
} PACKED_glStencilStrokePathInstancedNV;
typedef struct {
    GLuint path;
    GLint reference;
    GLuint mask;
} ARGS_glStencilStrokePathNV;
typedef struct {
    int index;
    ARGS_glStencilStrokePathNV args;
} PACKED_glStencilStrokePathNV;
typedef struct {
    GLint marker;
} ARGS_glStopInstrumentsSGIX;
typedef struct {
    int index;
    ARGS_glStopInstrumentsSGIX args;
} PACKED_glStopInstrumentsSGIX;
typedef struct {
    GLsizei len;
    GLvoid * string;
} ARGS_glStringMarkerGREMEDY;
typedef struct {
    int index;
    ARGS_glStringMarkerGREMEDY args;
} PACKED_glStringMarkerGREMEDY;
typedef struct {
    GLuint res;
    GLuint in;
    GLenum outX;
    GLenum outY;
    GLenum outZ;
    GLenum outW;
} ARGS_glSwizzleEXT;
typedef struct {
    int index;
    ARGS_glSwizzleEXT args;
} PACKED_glSwizzleEXT;
typedef struct {
    GLuint texture;
} ARGS_glSyncTextureINTEL;
typedef struct {
    int index;
    ARGS_glSyncTextureINTEL args;
} PACKED_glSyncTextureINTEL;
typedef struct {
    int index;
} PACKED_glTagSampleBufferSGIX;
typedef struct {
    GLbyte tx;
    GLbyte ty;
    GLbyte tz;
} ARGS_glTangent3bEXT;
typedef struct {
    int index;
    ARGS_glTangent3bEXT args;
} PACKED_glTangent3bEXT;
typedef struct {
    GLbyte * v;
} ARGS_glTangent3bvEXT;
typedef struct {
    int index;
    ARGS_glTangent3bvEXT args;
} PACKED_glTangent3bvEXT;
typedef struct {
    GLdouble tx __attribute__ ((aligned(8)));
    GLdouble ty __attribute__ ((aligned(8)));
    GLdouble tz __attribute__ ((aligned(8)));
} ARGS_glTangent3dEXT;
typedef struct {
    int index;
    ARGS_glTangent3dEXT args;
} PACKED_glTangent3dEXT;
typedef struct {
    GLdouble * v;
} ARGS_glTangent3dvEXT;
typedef struct {
    int index;
    ARGS_glTangent3dvEXT args;
} PACKED_glTangent3dvEXT;
typedef struct {
    GLfloat tx;
    GLfloat ty;
    GLfloat tz;
} ARGS_glTangent3fEXT;
typedef struct {
    int index;
    ARGS_glTangent3fEXT args;
} PACKED_glTangent3fEXT;
typedef struct {
    GLfloat * v;
} ARGS_glTangent3fvEXT;
typedef struct {
    int index;
    ARGS_glTangent3fvEXT args;
} PACKED_glTangent3fvEXT;
typedef struct {
    GLint tx;
    GLint ty;
    GLint tz;
} ARGS_glTangent3iEXT;
typedef struct {
    int index;
    ARGS_glTangent3iEXT args;
} PACKED_glTangent3iEXT;
typedef struct {
    GLint * v;
} ARGS_glTangent3ivEXT;
typedef struct {
    int index;
    ARGS_glTangent3ivEXT args;
} PACKED_glTangent3ivEXT;
typedef struct {
    GLshort tx;
    GLshort ty;
    GLshort tz;
} ARGS_glTangent3sEXT;
typedef struct {
    int index;
    ARGS_glTangent3sEXT args;
} PACKED_glTangent3sEXT;
typedef struct {
    GLshort * v;
} ARGS_glTangent3svEXT;
typedef struct {
    int index;
    ARGS_glTangent3svEXT args;
} PACKED_glTangent3svEXT;
typedef struct {
    GLenum type;
    GLsizei stride;
    GLvoid * pointer;
} ARGS_glTangentPointerEXT;
typedef struct {
    int index;
    ARGS_glTangentPointerEXT args;
} PACKED_glTangentPointerEXT;
typedef struct {
    GLuint mask;
} ARGS_glTbufferMask3DFX;
typedef struct {
    int index;
    ARGS_glTbufferMask3DFX args;
} PACKED_glTbufferMask3DFX;
typedef struct {
    GLfloat factor;
} ARGS_glTessellationFactorAMD;
typedef struct {
    int index;
    ARGS_glTessellationFactorAMD args;
} PACKED_glTessellationFactorAMD;
typedef struct {
    GLenum mode;
} ARGS_glTessellationModeAMD;
typedef struct {
    int index;
    ARGS_glTessellationModeAMD args;
} PACKED_glTessellationModeAMD;
typedef struct {
    GLuint fence;
} ARGS_glTestFenceAPPLE;
typedef struct {
    int index;
    ARGS_glTestFenceAPPLE args;
} PACKED_glTestFenceAPPLE;
typedef struct {
    GLuint fence;
} ARGS_glTestFenceNV;
typedef struct {
    int index;
    ARGS_glTestFenceNV args;
} PACKED_glTestFenceNV;
typedef struct {
    GLenum object;
    GLuint name;
} ARGS_glTestObjectAPPLE;
typedef struct {
    int index;
    ARGS_glTestObjectAPPLE args;
} PACKED_glTestObjectAPPLE;
typedef struct {
    GLenum target;
    GLenum internalformat;
    GLuint buffer;
} ARGS_glTexBuffer;
typedef struct {
    int index;
    ARGS_glTexBuffer args;
} PACKED_glTexBuffer;
typedef struct {
    GLenum target;
    GLenum internalformat;
    GLuint buffer;
} ARGS_glTexBufferARB;
typedef struct {
    int index;
    ARGS_glTexBufferARB args;
} PACKED_glTexBufferARB;
typedef struct {
    GLenum target;
    GLenum internalformat;
    GLuint buffer;
} ARGS_glTexBufferEXT;
typedef struct {
    int index;
    ARGS_glTexBufferEXT args;
} PACKED_glTexBufferEXT;
typedef struct {
    GLenum target;
    GLenum internalformat;
    GLuint buffer;
    GLintptr offset;
    GLsizeiptr size;
} ARGS_glTexBufferRange;
typedef struct {
    int index;
    ARGS_glTexBufferRange args;
} PACKED_glTexBufferRange;
typedef struct {
    GLenum pname;
    GLfloat * param;
} ARGS_glTexBumpParameterfvATI;
typedef struct {
    int index;
    ARGS_glTexBumpParameterfvATI args;
} PACKED_glTexBumpParameterfvATI;
typedef struct {
    GLenum pname;
    GLint * param;
} ARGS_glTexBumpParameterivATI;
typedef struct {
    int index;
    ARGS_glTexBumpParameterivATI args;
} PACKED_glTexBumpParameterivATI;
typedef struct {
    GLbyte s;
} ARGS_glTexCoord1bOES;
typedef struct {
    int index;
    ARGS_glTexCoord1bOES args;
} PACKED_glTexCoord1bOES;
typedef struct {
    GLbyte * coords;
} ARGS_glTexCoord1bvOES;
typedef struct {
    int index;
    ARGS_glTexCoord1bvOES args;
} PACKED_glTexCoord1bvOES;
typedef struct {
    GLdouble s __attribute__ ((aligned(8)));
} ARGS_glTexCoord1d;
typedef struct {
    int index;
    ARGS_glTexCoord1d args;
} PACKED_glTexCoord1d;
typedef struct {
    GLdouble * v;
} ARGS_glTexCoord1dv;
typedef struct {
    int index;
    ARGS_glTexCoord1dv args;
} PACKED_glTexCoord1dv;
typedef struct {
    GLfloat s;
} ARGS_glTexCoord1f;
typedef struct {
    int index;
    ARGS_glTexCoord1f args;
} PACKED_glTexCoord1f;
typedef struct {
    GLfloat * v;
} ARGS_glTexCoord1fv;
typedef struct {
    int index;
    ARGS_glTexCoord1fv args;
} PACKED_glTexCoord1fv;
typedef struct {
    GLhalfNV s;
} ARGS_glTexCoord1hNV;
typedef struct {
    int index;
    ARGS_glTexCoord1hNV args;
} PACKED_glTexCoord1hNV;
typedef struct {
    GLhalfNV * v;
} ARGS_glTexCoord1hvNV;
typedef struct {
    int index;
    ARGS_glTexCoord1hvNV args;
} PACKED_glTexCoord1hvNV;
typedef struct {
    GLint s;
} ARGS_glTexCoord1i;
typedef struct {
    int index;
    ARGS_glTexCoord1i args;
} PACKED_glTexCoord1i;
typedef struct {
    GLint * v;
} ARGS_glTexCoord1iv;
typedef struct {
    int index;
    ARGS_glTexCoord1iv args;
} PACKED_glTexCoord1iv;
typedef struct {
    GLshort s;
} ARGS_glTexCoord1s;
typedef struct {
    int index;
    ARGS_glTexCoord1s args;
} PACKED_glTexCoord1s;
typedef struct {
    GLshort * v;
} ARGS_glTexCoord1sv;
typedef struct {
    int index;
    ARGS_glTexCoord1sv args;
} PACKED_glTexCoord1sv;
typedef struct {
    GLfixed s;
} ARGS_glTexCoord1xOES;
typedef struct {
    int index;
    ARGS_glTexCoord1xOES args;
} PACKED_glTexCoord1xOES;
typedef struct {
    GLfixed * coords;
} ARGS_glTexCoord1xvOES;
typedef struct {
    int index;
    ARGS_glTexCoord1xvOES args;
} PACKED_glTexCoord1xvOES;
typedef struct {
    GLbyte s;
    GLbyte t;
} ARGS_glTexCoord2bOES;
typedef struct {
    int index;
    ARGS_glTexCoord2bOES args;
} PACKED_glTexCoord2bOES;
typedef struct {
    GLbyte * coords;
} ARGS_glTexCoord2bvOES;
typedef struct {
    int index;
    ARGS_glTexCoord2bvOES args;
} PACKED_glTexCoord2bvOES;
typedef struct {
    GLdouble s __attribute__ ((aligned(8)));
    GLdouble t __attribute__ ((aligned(8)));
} ARGS_glTexCoord2d;
typedef struct {
    int index;
    ARGS_glTexCoord2d args;
} PACKED_glTexCoord2d;
typedef struct {
    GLdouble * v;
} ARGS_glTexCoord2dv;
typedef struct {
    int index;
    ARGS_glTexCoord2dv args;
} PACKED_glTexCoord2dv;
typedef struct {
    GLfloat s;
    GLfloat t;
} ARGS_glTexCoord2f;
typedef struct {
    int index;
    ARGS_glTexCoord2f args;
} PACKED_glTexCoord2f;
typedef struct {
    GLfloat s;
    GLfloat t;
    GLfloat r;
    GLfloat g;
    GLfloat b;
    GLfloat x;
    GLfloat y;
    GLfloat z;
} ARGS_glTexCoord2fColor3fVertex3fSUN;
typedef struct {
    int index;
    ARGS_glTexCoord2fColor3fVertex3fSUN args;
} PACKED_glTexCoord2fColor3fVertex3fSUN;
typedef struct {
    GLfloat * tc;
    GLfloat * c;
    GLfloat * v;
} ARGS_glTexCoord2fColor3fVertex3fvSUN;
typedef struct {
    int index;
    ARGS_glTexCoord2fColor3fVertex3fvSUN args;
} PACKED_glTexCoord2fColor3fVertex3fvSUN;
typedef struct {
    GLfloat s;
    GLfloat t;
    GLfloat r;
    GLfloat g;
    GLfloat b;
    GLfloat a;
    GLfloat nx;
    GLfloat ny;
    GLfloat nz;
    GLfloat x;
    GLfloat y;
    GLfloat z;
} ARGS_glTexCoord2fColor4fNormal3fVertex3fSUN;
typedef struct {
    int index;
    ARGS_glTexCoord2fColor4fNormal3fVertex3fSUN args;
} PACKED_glTexCoord2fColor4fNormal3fVertex3fSUN;
typedef struct {
    GLfloat * tc;
    GLfloat * c;
    GLfloat * n;
    GLfloat * v;
} ARGS_glTexCoord2fColor4fNormal3fVertex3fvSUN;
typedef struct {
    int index;
    ARGS_glTexCoord2fColor4fNormal3fVertex3fvSUN args;
} PACKED_glTexCoord2fColor4fNormal3fVertex3fvSUN;
typedef struct {
    GLfloat s;
    GLfloat t;
    GLubyte r;
    GLubyte g;
    GLubyte b;
    GLubyte a;
    GLfloat x;
    GLfloat y;
    GLfloat z;
} ARGS_glTexCoord2fColor4ubVertex3fSUN;
typedef struct {
    int index;
    ARGS_glTexCoord2fColor4ubVertex3fSUN args;
} PACKED_glTexCoord2fColor4ubVertex3fSUN;
typedef struct {
    GLfloat * tc;
    GLubyte * c;
    GLfloat * v;
} ARGS_glTexCoord2fColor4ubVertex3fvSUN;
typedef struct {
    int index;
    ARGS_glTexCoord2fColor4ubVertex3fvSUN args;
} PACKED_glTexCoord2fColor4ubVertex3fvSUN;
typedef struct {
    GLfloat s;
    GLfloat t;
    GLfloat nx;
    GLfloat ny;
    GLfloat nz;
    GLfloat x;
    GLfloat y;
    GLfloat z;
} ARGS_glTexCoord2fNormal3fVertex3fSUN;
typedef struct {
    int index;
    ARGS_glTexCoord2fNormal3fVertex3fSUN args;
} PACKED_glTexCoord2fNormal3fVertex3fSUN;
typedef struct {
    GLfloat * tc;
    GLfloat * n;
    GLfloat * v;
} ARGS_glTexCoord2fNormal3fVertex3fvSUN;
typedef struct {
    int index;
    ARGS_glTexCoord2fNormal3fVertex3fvSUN args;
} PACKED_glTexCoord2fNormal3fVertex3fvSUN;
typedef struct {
    GLfloat s;
    GLfloat t;
    GLfloat x;
    GLfloat y;
    GLfloat z;
} ARGS_glTexCoord2fVertex3fSUN;
typedef struct {
    int index;
    ARGS_glTexCoord2fVertex3fSUN args;
} PACKED_glTexCoord2fVertex3fSUN;
typedef struct {
    GLfloat * tc;
    GLfloat * v;
} ARGS_glTexCoord2fVertex3fvSUN;
typedef struct {
    int index;
    ARGS_glTexCoord2fVertex3fvSUN args;
} PACKED_glTexCoord2fVertex3fvSUN;
typedef struct {
    GLfloat * v;
} ARGS_glTexCoord2fv;
typedef struct {
    int index;
    ARGS_glTexCoord2fv args;
} PACKED_glTexCoord2fv;
typedef struct {
    GLhalfNV s;
    GLhalfNV t;
} ARGS_glTexCoord2hNV;
typedef struct {
    int index;
    ARGS_glTexCoord2hNV args;
} PACKED_glTexCoord2hNV;
typedef struct {
    GLhalfNV * v;
} ARGS_glTexCoord2hvNV;
typedef struct {
    int index;
    ARGS_glTexCoord2hvNV args;
} PACKED_glTexCoord2hvNV;
typedef struct {
    GLint s;
    GLint t;
} ARGS_glTexCoord2i;
typedef struct {
    int index;
    ARGS_glTexCoord2i args;
} PACKED_glTexCoord2i;
typedef struct {
    GLint * v;
} ARGS_glTexCoord2iv;
typedef struct {
    int index;
    ARGS_glTexCoord2iv args;
} PACKED_glTexCoord2iv;
typedef struct {
    GLshort s;
    GLshort t;
} ARGS_glTexCoord2s;
typedef struct {
    int index;
    ARGS_glTexCoord2s args;
} PACKED_glTexCoord2s;
typedef struct {
    GLshort * v;
} ARGS_glTexCoord2sv;
typedef struct {
    int index;
    ARGS_glTexCoord2sv args;
} PACKED_glTexCoord2sv;
typedef struct {
    GLfixed s;
    GLfixed t;
} ARGS_glTexCoord2xOES;
typedef struct {
    int index;
    ARGS_glTexCoord2xOES args;
} PACKED_glTexCoord2xOES;
typedef struct {
    GLfixed * coords;
} ARGS_glTexCoord2xvOES;
typedef struct {
    int index;
    ARGS_glTexCoord2xvOES args;
} PACKED_glTexCoord2xvOES;
typedef struct {
    GLbyte s;
    GLbyte t;
    GLbyte r;
} ARGS_glTexCoord3bOES;
typedef struct {
    int index;
    ARGS_glTexCoord3bOES args;
} PACKED_glTexCoord3bOES;
typedef struct {
    GLbyte * coords;
} ARGS_glTexCoord3bvOES;
typedef struct {
    int index;
    ARGS_glTexCoord3bvOES args;
} PACKED_glTexCoord3bvOES;
typedef struct {
    GLdouble s __attribute__ ((aligned(8)));
    GLdouble t __attribute__ ((aligned(8)));
    GLdouble r __attribute__ ((aligned(8)));
} ARGS_glTexCoord3d;
typedef struct {
    int index;
    ARGS_glTexCoord3d args;
} PACKED_glTexCoord3d;
typedef struct {
    GLdouble * v;
} ARGS_glTexCoord3dv;
typedef struct {
    int index;
    ARGS_glTexCoord3dv args;
} PACKED_glTexCoord3dv;
typedef struct {
    GLfloat s;
    GLfloat t;
    GLfloat r;
} ARGS_glTexCoord3f;
typedef struct {
    int index;
    ARGS_glTexCoord3f args;
} PACKED_glTexCoord3f;
typedef struct {
    GLfloat * v;
} ARGS_glTexCoord3fv;
typedef struct {
    int index;
    ARGS_glTexCoord3fv args;
} PACKED_glTexCoord3fv;
typedef struct {
    GLhalfNV s;
    GLhalfNV t;
    GLhalfNV r;
} ARGS_glTexCoord3hNV;
typedef struct {
    int index;
    ARGS_glTexCoord3hNV args;
} PACKED_glTexCoord3hNV;
typedef struct {
    GLhalfNV * v;
} ARGS_glTexCoord3hvNV;
typedef struct {
    int index;
    ARGS_glTexCoord3hvNV args;
} PACKED_glTexCoord3hvNV;
typedef struct {
    GLint s;
    GLint t;
    GLint r;
} ARGS_glTexCoord3i;
typedef struct {
    int index;
    ARGS_glTexCoord3i args;
} PACKED_glTexCoord3i;
typedef struct {
    GLint * v;
} ARGS_glTexCoord3iv;
typedef struct {
    int index;
    ARGS_glTexCoord3iv args;
} PACKED_glTexCoord3iv;
typedef struct {
    GLshort s;
    GLshort t;
    GLshort r;
} ARGS_glTexCoord3s;
typedef struct {
    int index;
    ARGS_glTexCoord3s args;
} PACKED_glTexCoord3s;
typedef struct {
    GLshort * v;
} ARGS_glTexCoord3sv;
typedef struct {
    int index;
    ARGS_glTexCoord3sv args;
} PACKED_glTexCoord3sv;
typedef struct {
    GLfixed s;
    GLfixed t;
    GLfixed r;
} ARGS_glTexCoord3xOES;
typedef struct {
    int index;
    ARGS_glTexCoord3xOES args;
} PACKED_glTexCoord3xOES;
typedef struct {
    GLfixed * coords;
} ARGS_glTexCoord3xvOES;
typedef struct {
    int index;
    ARGS_glTexCoord3xvOES args;
} PACKED_glTexCoord3xvOES;
typedef struct {
    GLbyte s;
    GLbyte t;
    GLbyte r;
    GLbyte q;
} ARGS_glTexCoord4bOES;
typedef struct {
    int index;
    ARGS_glTexCoord4bOES args;
} PACKED_glTexCoord4bOES;
typedef struct {
    GLbyte * coords;
} ARGS_glTexCoord4bvOES;
typedef struct {
    int index;
    ARGS_glTexCoord4bvOES args;
} PACKED_glTexCoord4bvOES;
typedef struct {
    GLdouble s __attribute__ ((aligned(8)));
    GLdouble t __attribute__ ((aligned(8)));
    GLdouble r __attribute__ ((aligned(8)));
    GLdouble q __attribute__ ((aligned(8)));
} ARGS_glTexCoord4d;
typedef struct {
    int index;
    ARGS_glTexCoord4d args;
} PACKED_glTexCoord4d;
typedef struct {
    GLdouble * v;
} ARGS_glTexCoord4dv;
typedef struct {
    int index;
    ARGS_glTexCoord4dv args;
} PACKED_glTexCoord4dv;
typedef struct {
    GLfloat s;
    GLfloat t;
    GLfloat r;
    GLfloat q;
} ARGS_glTexCoord4f;
typedef struct {
    int index;
    ARGS_glTexCoord4f args;
} PACKED_glTexCoord4f;
typedef struct {
    GLfloat s;
    GLfloat t;
    GLfloat p;
    GLfloat q;
    GLfloat r;
    GLfloat g;
    GLfloat b;
    GLfloat a;
    GLfloat nx;
    GLfloat ny;
    GLfloat nz;
    GLfloat x;
    GLfloat y;
    GLfloat z;
    GLfloat w;
} ARGS_glTexCoord4fColor4fNormal3fVertex4fSUN;
typedef struct {
    int index;
    ARGS_glTexCoord4fColor4fNormal3fVertex4fSUN args;
} PACKED_glTexCoord4fColor4fNormal3fVertex4fSUN;
typedef struct {
    GLfloat * tc;
    GLfloat * c;
    GLfloat * n;
    GLfloat * v;
} ARGS_glTexCoord4fColor4fNormal3fVertex4fvSUN;
typedef struct {
    int index;
    ARGS_glTexCoord4fColor4fNormal3fVertex4fvSUN args;
} PACKED_glTexCoord4fColor4fNormal3fVertex4fvSUN;
typedef struct {
    GLfloat s;
    GLfloat t;
    GLfloat p;
    GLfloat q;
    GLfloat x;
    GLfloat y;
    GLfloat z;
    GLfloat w;
} ARGS_glTexCoord4fVertex4fSUN;
typedef struct {
    int index;
    ARGS_glTexCoord4fVertex4fSUN args;
} PACKED_glTexCoord4fVertex4fSUN;
typedef struct {
    GLfloat * tc;
    GLfloat * v;
} ARGS_glTexCoord4fVertex4fvSUN;
typedef struct {
    int index;
    ARGS_glTexCoord4fVertex4fvSUN args;
} PACKED_glTexCoord4fVertex4fvSUN;
typedef struct {
    GLfloat * v;
} ARGS_glTexCoord4fv;
typedef struct {
    int index;
    ARGS_glTexCoord4fv args;
} PACKED_glTexCoord4fv;
typedef struct {
    GLhalfNV s;
    GLhalfNV t;
    GLhalfNV r;
    GLhalfNV q;
} ARGS_glTexCoord4hNV;
typedef struct {
    int index;
    ARGS_glTexCoord4hNV args;
} PACKED_glTexCoord4hNV;
typedef struct {
    GLhalfNV * v;
} ARGS_glTexCoord4hvNV;
typedef struct {
    int index;
    ARGS_glTexCoord4hvNV args;
} PACKED_glTexCoord4hvNV;
typedef struct {
    GLint s;
    GLint t;
    GLint r;
    GLint q;
} ARGS_glTexCoord4i;
typedef struct {
    int index;
    ARGS_glTexCoord4i args;
} PACKED_glTexCoord4i;
typedef struct {
    GLint * v;
} ARGS_glTexCoord4iv;
typedef struct {
    int index;
    ARGS_glTexCoord4iv args;
} PACKED_glTexCoord4iv;
typedef struct {
    GLshort s;
    GLshort t;
    GLshort r;
    GLshort q;
} ARGS_glTexCoord4s;
typedef struct {
    int index;
    ARGS_glTexCoord4s args;
} PACKED_glTexCoord4s;
typedef struct {
    GLshort * v;
} ARGS_glTexCoord4sv;
typedef struct {
    int index;
    ARGS_glTexCoord4sv args;
} PACKED_glTexCoord4sv;
typedef struct {
    GLfixed s;
    GLfixed t;
    GLfixed r;
    GLfixed q;
} ARGS_glTexCoord4xOES;
typedef struct {
    int index;
    ARGS_glTexCoord4xOES args;
} PACKED_glTexCoord4xOES;
typedef struct {
    GLfixed * coords;
} ARGS_glTexCoord4xvOES;
typedef struct {
    int index;
    ARGS_glTexCoord4xvOES args;
} PACKED_glTexCoord4xvOES;
typedef struct {
    GLint size;
    GLenum type;
    GLsizei stride;
} ARGS_glTexCoordFormatNV;
typedef struct {
    int index;
    ARGS_glTexCoordFormatNV args;
} PACKED_glTexCoordFormatNV;
typedef struct {
    GLenum type;
    GLuint coords;
} ARGS_glTexCoordP1ui;
typedef struct {
    int index;
    ARGS_glTexCoordP1ui args;
} PACKED_glTexCoordP1ui;
typedef struct {
    GLenum type;
    GLuint * coords;
} ARGS_glTexCoordP1uiv;
typedef struct {
    int index;
    ARGS_glTexCoordP1uiv args;
} PACKED_glTexCoordP1uiv;
typedef struct {
    GLenum type;
    GLuint coords;
} ARGS_glTexCoordP2ui;
typedef struct {
    int index;
    ARGS_glTexCoordP2ui args;
} PACKED_glTexCoordP2ui;
typedef struct {
    GLenum type;
    GLuint * coords;
} ARGS_glTexCoordP2uiv;
typedef struct {
    int index;
    ARGS_glTexCoordP2uiv args;
} PACKED_glTexCoordP2uiv;
typedef struct {
    GLenum type;
    GLuint coords;
} ARGS_glTexCoordP3ui;
typedef struct {
    int index;
    ARGS_glTexCoordP3ui args;
} PACKED_glTexCoordP3ui;
typedef struct {
    GLenum type;
    GLuint * coords;
} ARGS_glTexCoordP3uiv;
typedef struct {
    int index;
    ARGS_glTexCoordP3uiv args;
} PACKED_glTexCoordP3uiv;
typedef struct {
    GLenum type;
    GLuint coords;
} ARGS_glTexCoordP4ui;
typedef struct {
    int index;
    ARGS_glTexCoordP4ui args;
} PACKED_glTexCoordP4ui;
typedef struct {
    GLenum type;
    GLuint * coords;
} ARGS_glTexCoordP4uiv;
typedef struct {
    int index;
    ARGS_glTexCoordP4uiv args;
} PACKED_glTexCoordP4uiv;
typedef struct {
    GLint size;
    GLenum type;
    GLsizei stride;
    GLvoid * pointer;
} ARGS_glTexCoordPointer;
typedef struct {
    int index;
    ARGS_glTexCoordPointer args;
} PACKED_glTexCoordPointer;
typedef struct {
    GLint size;
    GLenum type;
    GLsizei stride;
    GLsizei count;
    GLvoid * pointer;
} ARGS_glTexCoordPointerEXT;
typedef struct {
    int index;
    ARGS_glTexCoordPointerEXT args;
} PACKED_glTexCoordPointerEXT;
typedef struct {
    GLint size;
    GLenum type;
    GLint stride;
    GLvoid * pointer;
    GLint ptrstride;
} ARGS_glTexCoordPointerListIBM;
typedef struct {
    int index;
    ARGS_glTexCoordPointerListIBM args;
} PACKED_glTexCoordPointerListIBM;
typedef struct {
    GLint size;
    GLenum type;
    GLvoid * pointer;
} ARGS_glTexCoordPointervINTEL;
typedef struct {
    int index;
    ARGS_glTexCoordPointervINTEL args;
} PACKED_glTexCoordPointervINTEL;
typedef struct {
    GLenum target;
    GLenum pname;
    GLfloat param;
} ARGS_glTexEnvf;
typedef struct {
    int index;
    ARGS_glTexEnvf args;
} PACKED_glTexEnvf;
typedef struct {
    GLenum target;
    GLenum pname;
    GLfloat * params;
} ARGS_glTexEnvfv;
typedef struct {
    int index;
    ARGS_glTexEnvfv args;
} PACKED_glTexEnvfv;
typedef struct {
    GLenum target;
    GLenum pname;
    GLint param;
} ARGS_glTexEnvi;
typedef struct {
    int index;
    ARGS_glTexEnvi args;
} PACKED_glTexEnvi;
typedef struct {
    GLenum target;
    GLenum pname;
    GLint * params;
} ARGS_glTexEnviv;
typedef struct {
    int index;
    ARGS_glTexEnviv args;
} PACKED_glTexEnviv;
typedef struct {
    GLenum target;
    GLenum pname;
    GLfixed param;
} ARGS_glTexEnvx;
typedef struct {
    int index;
    ARGS_glTexEnvx args;
} PACKED_glTexEnvx;
typedef struct {
    GLenum target;
    GLenum pname;
    GLfixed param;
} ARGS_glTexEnvxOES;
typedef struct {
    int index;
    ARGS_glTexEnvxOES args;
} PACKED_glTexEnvxOES;
typedef struct {
    GLenum target;
    GLenum pname;
    GLfixed * params;
} ARGS_glTexEnvxv;
typedef struct {
    int index;
    ARGS_glTexEnvxv args;
} PACKED_glTexEnvxv;
typedef struct {
    GLenum target;
    GLenum pname;
    GLfixed * params;
} ARGS_glTexEnvxvOES;
typedef struct {
    int index;
    ARGS_glTexEnvxvOES args;
} PACKED_glTexEnvxvOES;
typedef struct {
    GLenum target;
    GLenum filter;
    GLsizei n;
    GLfloat * weights;
} ARGS_glTexFilterFuncSGIS;
typedef struct {
    int index;
    ARGS_glTexFilterFuncSGIS args;
} PACKED_glTexFilterFuncSGIS;
typedef struct {
    GLenum coord;
    GLenum pname;
    GLdouble param __attribute__ ((aligned(8)));
} ARGS_glTexGend;
typedef struct {
    int index;
    ARGS_glTexGend args;
} PACKED_glTexGend;
typedef struct {
    GLenum coord;
    GLenum pname;
    GLdouble * params;
} ARGS_glTexGendv;
typedef struct {
    int index;
    ARGS_glTexGendv args;
} PACKED_glTexGendv;
typedef struct {
    GLenum coord;
    GLenum pname;
    GLfloat param;
} ARGS_glTexGenf;
typedef struct {
    int index;
    ARGS_glTexGenf args;
} PACKED_glTexGenf;
typedef struct {
    GLenum coord;
    GLenum pname;
    GLfloat * params;
} ARGS_glTexGenfv;
typedef struct {
    int index;
    ARGS_glTexGenfv args;
} PACKED_glTexGenfv;
typedef struct {
    GLenum coord;
    GLenum pname;
    GLint param;
} ARGS_glTexGeni;
typedef struct {
    int index;
    ARGS_glTexGeni args;
} PACKED_glTexGeni;
typedef struct {
    GLenum coord;
    GLenum pname;
    GLint * params;
} ARGS_glTexGeniv;
typedef struct {
    int index;
    ARGS_glTexGeniv args;
} PACKED_glTexGeniv;
typedef struct {
    GLenum coord;
    GLenum pname;
    GLfixed param;
} ARGS_glTexGenxOES;
typedef struct {
    int index;
    ARGS_glTexGenxOES args;
} PACKED_glTexGenxOES;
typedef struct {
    GLenum coord;
    GLenum pname;
    GLfixed * params;
} ARGS_glTexGenxvOES;
typedef struct {
    int index;
    ARGS_glTexGenxvOES args;
} PACKED_glTexGenxvOES;
typedef struct {
    GLenum target;
    GLint level;
    GLint internalformat;
    GLsizei width;
    GLint border;
    GLenum format;
    GLenum type;
    GLvoid * pixels;
} ARGS_glTexImage1D;
typedef struct {
    int index;
    ARGS_glTexImage1D args;
} PACKED_glTexImage1D;
typedef struct {
    GLenum target;
    GLint level;
    GLint internalformat;
    GLsizei width;
    GLsizei height;
    GLint border;
    GLenum format;
    GLenum type;
    GLvoid * pixels;
} ARGS_glTexImage2D;
typedef struct {
    int index;
    ARGS_glTexImage2D args;
} PACKED_glTexImage2D;
typedef struct {
    GLenum target;
    GLsizei samples;
    GLint internalformat;
    GLsizei width;
    GLsizei height;
    GLboolean fixedsamplelocations;
} ARGS_glTexImage2DMultisample;
typedef struct {
    int index;
    ARGS_glTexImage2DMultisample args;
} PACKED_glTexImage2DMultisample;
typedef struct {
    GLenum target;
    GLsizei coverageSamples;
    GLsizei colorSamples;
    GLint internalFormat;
    GLsizei width;
    GLsizei height;
    GLboolean fixedSampleLocations;
} ARGS_glTexImage2DMultisampleCoverageNV;
typedef struct {
    int index;
    ARGS_glTexImage2DMultisampleCoverageNV args;
} PACKED_glTexImage2DMultisampleCoverageNV;
typedef struct {
    GLenum target;
    GLint level;
    GLint internalformat;
    GLsizei width;
    GLsizei height;
    GLsizei depth;
    GLint border;
    GLenum format;
    GLenum type;
    GLvoid * pixels;
} ARGS_glTexImage3D;
typedef struct {
    int index;
    ARGS_glTexImage3D args;
} PACKED_glTexImage3D;
typedef struct {
    GLenum target;
    GLint level;
    GLenum internalformat;
    GLsizei width;
    GLsizei height;
    GLsizei depth;
    GLint border;
    GLenum format;
    GLenum type;
    GLvoid * pixels;
} ARGS_glTexImage3DEXT;
typedef struct {
    int index;
    ARGS_glTexImage3DEXT args;
} PACKED_glTexImage3DEXT;
typedef struct {
    GLenum target;
    GLsizei samples;
    GLint internalformat;
    GLsizei width;
    GLsizei height;
    GLsizei depth;
    GLboolean fixedsamplelocations;
} ARGS_glTexImage3DMultisample;
typedef struct {
    int index;
    ARGS_glTexImage3DMultisample args;
} PACKED_glTexImage3DMultisample;
typedef struct {
    GLenum target;
    GLsizei coverageSamples;
    GLsizei colorSamples;
    GLint internalFormat;
    GLsizei width;
    GLsizei height;
    GLsizei depth;
    GLboolean fixedSampleLocations;
} ARGS_glTexImage3DMultisampleCoverageNV;
typedef struct {
    int index;
    ARGS_glTexImage3DMultisampleCoverageNV args;
} PACKED_glTexImage3DMultisampleCoverageNV;
typedef struct {
    GLenum target;
    GLint level;
    GLenum internalformat;
    GLsizei width;
    GLsizei height;
    GLsizei depth;
    GLsizei size4d;
    GLint border;
    GLenum format;
    GLenum type;
    GLvoid * pixels;
} ARGS_glTexImage4DSGIS;
typedef struct {
    int index;
    ARGS_glTexImage4DSGIS args;
} PACKED_glTexImage4DSGIS;
typedef struct {
    GLenum target;
    GLenum pname;
    GLint * params;
} ARGS_glTexParameterIiv;
typedef struct {
    int index;
    ARGS_glTexParameterIiv args;
} PACKED_glTexParameterIiv;
typedef struct {
    GLenum target;
    GLenum pname;
    GLint * params;
} ARGS_glTexParameterIivEXT;
typedef struct {
    int index;
    ARGS_glTexParameterIivEXT args;
} PACKED_glTexParameterIivEXT;
typedef struct {
    GLenum target;
    GLenum pname;
    GLuint * params;
} ARGS_glTexParameterIuiv;
typedef struct {
    int index;
    ARGS_glTexParameterIuiv args;
} PACKED_glTexParameterIuiv;
typedef struct {
    GLenum target;
    GLenum pname;
    GLuint * params;
} ARGS_glTexParameterIuivEXT;
typedef struct {
    int index;
    ARGS_glTexParameterIuivEXT args;
} PACKED_glTexParameterIuivEXT;
typedef struct {
    GLenum target;
    GLenum pname;
    GLfloat param;
} ARGS_glTexParameterf;
typedef struct {
    int index;
    ARGS_glTexParameterf args;
} PACKED_glTexParameterf;
typedef struct {
    GLenum target;
    GLenum pname;
    GLfloat * params;
} ARGS_glTexParameterfv;
typedef struct {
    int index;
    ARGS_glTexParameterfv args;
} PACKED_glTexParameterfv;
typedef struct {
    GLenum target;
    GLenum pname;
    GLint param;
} ARGS_glTexParameteri;
typedef struct {
    int index;
    ARGS_glTexParameteri args;
} PACKED_glTexParameteri;
typedef struct {
    GLenum target;
    GLenum pname;
    GLint * params;
} ARGS_glTexParameteriv;
typedef struct {
    int index;
    ARGS_glTexParameteriv args;
} PACKED_glTexParameteriv;
typedef struct {
    GLenum target;
    GLenum pname;
    GLfixed param;
} ARGS_glTexParameterx;
typedef struct {
    int index;
    ARGS_glTexParameterx args;
} PACKED_glTexParameterx;
typedef struct {
    GLenum target;
    GLenum pname;
    GLfixed param;
} ARGS_glTexParameterxOES;
typedef struct {
    int index;
    ARGS_glTexParameterxOES args;
} PACKED_glTexParameterxOES;
typedef struct {
    GLenum target;
    GLenum pname;
    GLfixed * params;
} ARGS_glTexParameterxv;
typedef struct {
    int index;
    ARGS_glTexParameterxv args;
} PACKED_glTexParameterxv;
typedef struct {
    GLenum target;
    GLenum pname;
    GLfixed * params;
} ARGS_glTexParameterxvOES;
typedef struct {
    int index;
    ARGS_glTexParameterxvOES args;
} PACKED_glTexParameterxvOES;
typedef struct {
    GLenum target;
    GLuint renderbuffer;
} ARGS_glTexRenderbufferNV;
typedef struct {
    int index;
    ARGS_glTexRenderbufferNV args;
} PACKED_glTexRenderbufferNV;
typedef struct {
    GLenum target;
    GLsizei levels;
    GLenum internalformat;
    GLsizei width;
} ARGS_glTexStorage1D;
typedef struct {
    int index;
    ARGS_glTexStorage1D args;
} PACKED_glTexStorage1D;
typedef struct {
    GLenum target;
    GLsizei levels;
    GLenum internalformat;
    GLsizei width;
    GLsizei height;
} ARGS_glTexStorage2D;
typedef struct {
    int index;
    ARGS_glTexStorage2D args;
} PACKED_glTexStorage2D;
typedef struct {
    GLenum target;
    GLsizei samples;
    GLenum internalformat;
    GLsizei width;
    GLsizei height;
    GLboolean fixedsamplelocations;
} ARGS_glTexStorage2DMultisample;
typedef struct {
    int index;
    ARGS_glTexStorage2DMultisample args;
} PACKED_glTexStorage2DMultisample;
typedef struct {
    GLenum target;
    GLsizei levels;
    GLenum internalformat;
    GLsizei width;
    GLsizei height;
    GLsizei depth;
} ARGS_glTexStorage3D;
typedef struct {
    int index;
    ARGS_glTexStorage3D args;
} PACKED_glTexStorage3D;
typedef struct {
    GLenum target;
    GLsizei samples;
    GLenum internalformat;
    GLsizei width;
    GLsizei height;
    GLsizei depth;
    GLboolean fixedsamplelocations;
} ARGS_glTexStorage3DMultisample;
typedef struct {
    int index;
    ARGS_glTexStorage3DMultisample args;
} PACKED_glTexStorage3DMultisample;
typedef struct {
    GLenum target;
    GLenum internalFormat;
    GLsizei width;
    GLsizei height;
    GLsizei depth;
    GLsizei layers;
    GLbitfield flags;
} ARGS_glTexStorageSparseAMD;
typedef struct {
    int index;
    ARGS_glTexStorageSparseAMD args;
} PACKED_glTexStorageSparseAMD;
typedef struct {
    GLenum target;
    GLint level;
    GLint xoffset;
    GLsizei width;
    GLenum format;
    GLenum type;
    GLvoid * pixels;
} ARGS_glTexSubImage1D;
typedef struct {
    int index;
    ARGS_glTexSubImage1D args;
} PACKED_glTexSubImage1D;
typedef struct {
    GLenum target;
    GLint level;
    GLint xoffset;
    GLsizei width;
    GLenum format;
    GLenum type;
    GLvoid * pixels;
} ARGS_glTexSubImage1DEXT;
typedef struct {
    int index;
    ARGS_glTexSubImage1DEXT args;
} PACKED_glTexSubImage1DEXT;
typedef struct {
    GLenum target;
    GLint level;
    GLint xoffset;
    GLint yoffset;
    GLsizei width;
    GLsizei height;
    GLenum format;
    GLenum type;
    GLvoid * pixels;
} ARGS_glTexSubImage2D;
typedef struct {
    int index;
    ARGS_glTexSubImage2D args;
} PACKED_glTexSubImage2D;
typedef struct {
    GLenum target;
    GLint level;
    GLint xoffset;
    GLint yoffset;
    GLsizei width;
    GLsizei height;
    GLenum format;
    GLenum type;
    GLvoid * pixels;
} ARGS_glTexSubImage2DEXT;
typedef struct {
    int index;
    ARGS_glTexSubImage2DEXT args;
} PACKED_glTexSubImage2DEXT;
typedef struct {
    GLenum target;
    GLint level;
    GLint xoffset;
    GLint yoffset;
    GLint zoffset;
    GLsizei width;
    GLsizei height;
    GLsizei depth;
    GLenum format;
    GLenum type;
    GLvoid * pixels;
} ARGS_glTexSubImage3D;
typedef struct {
    int index;
    ARGS_glTexSubImage3D args;
} PACKED_glTexSubImage3D;
typedef struct {
    GLenum target;
    GLint level;
    GLint xoffset;
    GLint yoffset;
    GLint zoffset;
    GLsizei width;
    GLsizei height;
    GLsizei depth;
    GLenum format;
    GLenum type;
    GLvoid * pixels;
} ARGS_glTexSubImage3DEXT;
typedef struct {
    int index;
    ARGS_glTexSubImage3DEXT args;
} PACKED_glTexSubImage3DEXT;
typedef struct {
    GLenum target;
    GLint level;
    GLint xoffset;
    GLint yoffset;
    GLint zoffset;
    GLint woffset;
    GLsizei width;
    GLsizei height;
    GLsizei depth;
    GLsizei size4d;
    GLenum format;
    GLenum type;
    GLvoid * pixels;
} ARGS_glTexSubImage4DSGIS;
typedef struct {
    int index;
    ARGS_glTexSubImage4DSGIS args;
} PACKED_glTexSubImage4DSGIS;
typedef struct {
    int index;
} PACKED_glTextureBarrierNV;
typedef struct {
    GLuint texture;
    GLenum target;
    GLenum internalformat;
    GLuint buffer;
} ARGS_glTextureBufferEXT;
typedef struct {
    int index;
    ARGS_glTextureBufferEXT args;
} PACKED_glTextureBufferEXT;
typedef struct {
    GLuint texture;
    GLenum target;
    GLenum internalformat;
    GLuint buffer;
    GLintptr offset;
    GLsizeiptr size;
} ARGS_glTextureBufferRangeEXT;
typedef struct {
    int index;
    ARGS_glTextureBufferRangeEXT args;
} PACKED_glTextureBufferRangeEXT;
typedef struct {
    GLboolean red;
    GLboolean green;
    GLboolean blue;
    GLboolean alpha;
} ARGS_glTextureColorMaskSGIS;
typedef struct {
    int index;
    ARGS_glTextureColorMaskSGIS args;
} PACKED_glTextureColorMaskSGIS;
typedef struct {
    GLuint texture;
    GLenum target;
    GLint level;
    GLenum internalformat;
    GLsizei width;
    GLint border;
    GLenum format;
    GLenum type;
    GLvoid * pixels;
} ARGS_glTextureImage1DEXT;
typedef struct {
    int index;
    ARGS_glTextureImage1DEXT args;
} PACKED_glTextureImage1DEXT;
typedef struct {
    GLuint texture;
    GLenum target;
    GLint level;
    GLenum internalformat;
    GLsizei width;
    GLsizei height;
    GLint border;
    GLenum format;
    GLenum type;
    GLvoid * pixels;
} ARGS_glTextureImage2DEXT;
typedef struct {
    int index;
    ARGS_glTextureImage2DEXT args;
} PACKED_glTextureImage2DEXT;
typedef struct {
    GLuint texture;
    GLenum target;
    GLsizei coverageSamples;
    GLsizei colorSamples;
    GLint internalFormat;
    GLsizei width;
    GLsizei height;
    GLboolean fixedSampleLocations;
} ARGS_glTextureImage2DMultisampleCoverageNV;
typedef struct {
    int index;
    ARGS_glTextureImage2DMultisampleCoverageNV args;
} PACKED_glTextureImage2DMultisampleCoverageNV;
typedef struct {
    GLuint texture;
    GLenum target;
    GLsizei samples;
    GLint internalFormat;
    GLsizei width;
    GLsizei height;
    GLboolean fixedSampleLocations;
} ARGS_glTextureImage2DMultisampleNV;
typedef struct {
    int index;
    ARGS_glTextureImage2DMultisampleNV args;
} PACKED_glTextureImage2DMultisampleNV;
typedef struct {
    GLuint texture;
    GLenum target;
    GLint level;
    GLenum internalformat;
    GLsizei width;
    GLsizei height;
    GLsizei depth;
    GLint border;
    GLenum format;
    GLenum type;
    GLvoid * pixels;
} ARGS_glTextureImage3DEXT;
typedef struct {
    int index;
    ARGS_glTextureImage3DEXT args;
} PACKED_glTextureImage3DEXT;
typedef struct {
    GLuint texture;
    GLenum target;
    GLsizei coverageSamples;
    GLsizei colorSamples;
    GLint internalFormat;
    GLsizei width;
    GLsizei height;
    GLsizei depth;
    GLboolean fixedSampleLocations;
} ARGS_glTextureImage3DMultisampleCoverageNV;
typedef struct {
    int index;
    ARGS_glTextureImage3DMultisampleCoverageNV args;
} PACKED_glTextureImage3DMultisampleCoverageNV;
typedef struct {
    GLuint texture;
    GLenum target;
    GLsizei samples;
    GLint internalFormat;
    GLsizei width;
    GLsizei height;
    GLsizei depth;
    GLboolean fixedSampleLocations;
} ARGS_glTextureImage3DMultisampleNV;
typedef struct {
    int index;
    ARGS_glTextureImage3DMultisampleNV args;
} PACKED_glTextureImage3DMultisampleNV;
typedef struct {
    GLenum pname;
} ARGS_glTextureLightEXT;
typedef struct {
    int index;
    ARGS_glTextureLightEXT args;
} PACKED_glTextureLightEXT;
typedef struct {
    GLenum face;
    GLenum mode;
} ARGS_glTextureMaterialEXT;
typedef struct {
    int index;
    ARGS_glTextureMaterialEXT args;
} PACKED_glTextureMaterialEXT;
typedef struct {
    GLenum mode;
} ARGS_glTextureNormalEXT;
typedef struct {
    int index;
    ARGS_glTextureNormalEXT args;
} PACKED_glTextureNormalEXT;
typedef struct {
    GLuint texture;
    GLenum target;
    GLenum pname;
    GLint * params;
} ARGS_glTextureParameterIivEXT;
typedef struct {
    int index;
    ARGS_glTextureParameterIivEXT args;
} PACKED_glTextureParameterIivEXT;
typedef struct {
    GLuint texture;
    GLenum target;
    GLenum pname;
    GLuint * params;
} ARGS_glTextureParameterIuivEXT;
typedef struct {
    int index;
    ARGS_glTextureParameterIuivEXT args;
} PACKED_glTextureParameterIuivEXT;
typedef struct {
    GLuint texture;
    GLenum target;
    GLenum pname;
    GLfloat param;
} ARGS_glTextureParameterfEXT;
typedef struct {
    int index;
    ARGS_glTextureParameterfEXT args;
} PACKED_glTextureParameterfEXT;
typedef struct {
    GLuint texture;
    GLenum target;
    GLenum pname;
    GLfloat * params;
} ARGS_glTextureParameterfvEXT;
typedef struct {
    int index;
    ARGS_glTextureParameterfvEXT args;
} PACKED_glTextureParameterfvEXT;
typedef struct {
    GLuint texture;
    GLenum target;
    GLenum pname;
    GLint param;
} ARGS_glTextureParameteriEXT;
typedef struct {
    int index;
    ARGS_glTextureParameteriEXT args;
} PACKED_glTextureParameteriEXT;
typedef struct {
    GLuint texture;
    GLenum target;
    GLenum pname;
    GLint * params;
} ARGS_glTextureParameterivEXT;
typedef struct {
    int index;
    ARGS_glTextureParameterivEXT args;
} PACKED_glTextureParameterivEXT;
typedef struct {
    GLenum target;
    GLsizei length;
    GLvoid * pointer;
} ARGS_glTextureRangeAPPLE;
typedef struct {
    int index;
    ARGS_glTextureRangeAPPLE args;
} PACKED_glTextureRangeAPPLE;
typedef struct {
    GLuint texture;
    GLenum target;
    GLuint renderbuffer;
} ARGS_glTextureRenderbufferEXT;
typedef struct {
    int index;
    ARGS_glTextureRenderbufferEXT args;
} PACKED_glTextureRenderbufferEXT;
typedef struct {
    GLuint texture;
    GLenum target;
    GLsizei levels;
    GLenum internalformat;
    GLsizei width;
} ARGS_glTextureStorage1DEXT;
typedef struct {
    int index;
    ARGS_glTextureStorage1DEXT args;
} PACKED_glTextureStorage1DEXT;
typedef struct {
    GLuint texture;
    GLenum target;
    GLsizei levels;
    GLenum internalformat;
    GLsizei width;
    GLsizei height;
} ARGS_glTextureStorage2DEXT;
typedef struct {
    int index;
    ARGS_glTextureStorage2DEXT args;
} PACKED_glTextureStorage2DEXT;
typedef struct {
    GLuint texture;
    GLenum target;
    GLsizei samples;
    GLenum internalformat;
    GLsizei width;
    GLsizei height;
    GLboolean fixedsamplelocations;
} ARGS_glTextureStorage2DMultisampleEXT;
typedef struct {
    int index;
    ARGS_glTextureStorage2DMultisampleEXT args;
} PACKED_glTextureStorage2DMultisampleEXT;
typedef struct {
    GLuint texture;
    GLenum target;
    GLsizei levels;
    GLenum internalformat;
    GLsizei width;
    GLsizei height;
    GLsizei depth;
} ARGS_glTextureStorage3DEXT;
typedef struct {
    int index;
    ARGS_glTextureStorage3DEXT args;
} PACKED_glTextureStorage3DEXT;
typedef struct {
    GLuint texture;
    GLenum target;
    GLsizei samples;
    GLenum internalformat;
    GLsizei width;
    GLsizei height;
    GLsizei depth;
    GLboolean fixedsamplelocations;
} ARGS_glTextureStorage3DMultisampleEXT;
typedef struct {
    int index;
    ARGS_glTextureStorage3DMultisampleEXT args;
} PACKED_glTextureStorage3DMultisampleEXT;
typedef struct {
    GLuint texture;
    GLenum target;
    GLenum internalFormat;
    GLsizei width;
    GLsizei height;
    GLsizei depth;
    GLsizei layers;
    GLbitfield flags;
} ARGS_glTextureStorageSparseAMD;
typedef struct {
    int index;
    ARGS_glTextureStorageSparseAMD args;
} PACKED_glTextureStorageSparseAMD;
typedef struct {
    GLuint texture;
    GLenum target;
    GLint level;
    GLint xoffset;
    GLsizei width;
    GLenum format;
    GLenum type;
    GLvoid * pixels;
} ARGS_glTextureSubImage1DEXT;
typedef struct {
    int index;
    ARGS_glTextureSubImage1DEXT args;
} PACKED_glTextureSubImage1DEXT;
typedef struct {
    GLuint texture;
    GLenum target;
    GLint level;
    GLint xoffset;
    GLint yoffset;
    GLsizei width;
    GLsizei height;
    GLenum format;
    GLenum type;
    GLvoid * pixels;
} ARGS_glTextureSubImage2DEXT;
typedef struct {
    int index;
    ARGS_glTextureSubImage2DEXT args;
} PACKED_glTextureSubImage2DEXT;
typedef struct {
    GLuint texture;
    GLenum target;
    GLint level;
    GLint xoffset;
    GLint yoffset;
    GLint zoffset;
    GLsizei width;
    GLsizei height;
    GLsizei depth;
    GLenum format;
    GLenum type;
    GLvoid * pixels;
} ARGS_glTextureSubImage3DEXT;
typedef struct {
    int index;
    ARGS_glTextureSubImage3DEXT args;
} PACKED_glTextureSubImage3DEXT;
typedef struct {
    GLuint texture;
    GLenum target;
    GLuint origtexture;
    GLenum internalformat;
    GLuint minlevel;
    GLuint numlevels;
    GLuint minlayer;
    GLuint numlayers;
} ARGS_glTextureView;
typedef struct {
    int index;
    ARGS_glTextureView args;
} PACKED_glTextureView;
typedef struct {
    GLenum target;
    GLuint address;
    GLenum matrix;
    GLenum transform;
} ARGS_glTrackMatrixNV;
typedef struct {
    int index;
    ARGS_glTrackMatrixNV args;
} PACKED_glTrackMatrixNV;
typedef struct {
    GLsizei count;
    GLint * attribs;
    GLenum bufferMode;
} ARGS_glTransformFeedbackAttribsNV;
typedef struct {
    int index;
    ARGS_glTransformFeedbackAttribsNV args;
} PACKED_glTransformFeedbackAttribsNV;
typedef struct {
    GLsizei count;
    GLint * attribs;
    GLsizei nbuffers;
    GLint * bufstreams;
    GLenum bufferMode;
} ARGS_glTransformFeedbackStreamAttribsNV;
typedef struct {
    int index;
    ARGS_glTransformFeedbackStreamAttribsNV args;
} PACKED_glTransformFeedbackStreamAttribsNV;
typedef struct {
    GLuint program;
    GLsizei count;
    GLchar*const * varyings;
    GLenum bufferMode;
} ARGS_glTransformFeedbackVaryings;
typedef struct {
    int index;
    ARGS_glTransformFeedbackVaryings args;
} PACKED_glTransformFeedbackVaryings;
typedef struct {
    GLuint program;
    GLsizei count;
    GLchar * varyings;
    GLenum bufferMode;
} ARGS_glTransformFeedbackVaryingsEXT;
typedef struct {
    int index;
    ARGS_glTransformFeedbackVaryingsEXT args;
} PACKED_glTransformFeedbackVaryingsEXT;
typedef struct {
    GLuint program;
    GLsizei count;
    GLint * locations;
    GLenum bufferMode;
} ARGS_glTransformFeedbackVaryingsNV;
typedef struct {
    int index;
    ARGS_glTransformFeedbackVaryingsNV args;
} PACKED_glTransformFeedbackVaryingsNV;
typedef struct {
    GLuint resultPath;
    GLuint srcPath;
    GLenum transformType;
    GLfloat * transformValues;
} ARGS_glTransformPathNV;
typedef struct {
    int index;
    ARGS_glTransformPathNV args;
} PACKED_glTransformPathNV;
typedef struct {
    GLdouble x __attribute__ ((aligned(8)));
    GLdouble y __attribute__ ((aligned(8)));
    GLdouble z __attribute__ ((aligned(8)));
} ARGS_glTranslated;
typedef struct {
    int index;
    ARGS_glTranslated args;
} PACKED_glTranslated;
typedef struct {
    GLfloat x;
    GLfloat y;
    GLfloat z;
} ARGS_glTranslatef;
typedef struct {
    int index;
    ARGS_glTranslatef args;
} PACKED_glTranslatef;
typedef struct {
    GLfixed x;
    GLfixed y;
    GLfixed z;
} ARGS_glTranslatex;
typedef struct {
    int index;
    ARGS_glTranslatex args;
} PACKED_glTranslatex;
typedef struct {
    GLfixed x;
    GLfixed y;
    GLfixed z;
} ARGS_glTranslatexOES;
typedef struct {
    int index;
    ARGS_glTranslatexOES args;
} PACKED_glTranslatexOES;
typedef struct {
    GLint location;
    GLdouble x __attribute__ ((aligned(8)));
} ARGS_glUniform1d;
typedef struct {
    int index;
    ARGS_glUniform1d args;
} PACKED_glUniform1d;
typedef struct {
    GLint location;
    GLsizei count;
    GLdouble * value;
} ARGS_glUniform1dv;
typedef struct {
    int index;
    ARGS_glUniform1dv args;
} PACKED_glUniform1dv;
typedef struct {
    GLint location;
    GLfloat v0;
} ARGS_glUniform1f;
typedef struct {
    int index;
    ARGS_glUniform1f args;
} PACKED_glUniform1f;
typedef struct {
    GLint location;
    GLfloat v0;
} ARGS_glUniform1fARB;
typedef struct {
    int index;
    ARGS_glUniform1fARB args;
} PACKED_glUniform1fARB;
typedef struct {
    GLint location;
    GLsizei count;
    GLfloat * value;
} ARGS_glUniform1fv;
typedef struct {
    int index;
    ARGS_glUniform1fv args;
} PACKED_glUniform1fv;
typedef struct {
    GLint location;
    GLsizei count;
    GLfloat * value;
} ARGS_glUniform1fvARB;
typedef struct {
    int index;
    ARGS_glUniform1fvARB args;
} PACKED_glUniform1fvARB;
typedef struct {
    GLint location;
    GLint v0;
} ARGS_glUniform1i;
typedef struct {
    int index;
    ARGS_glUniform1i args;
} PACKED_glUniform1i;
typedef struct {
    GLint location;
    GLint64EXT x;
} ARGS_glUniform1i64NV;
typedef struct {
    int index;
    ARGS_glUniform1i64NV args;
} PACKED_glUniform1i64NV;
typedef struct {
    GLint location;
    GLsizei count;
    GLint64EXT * value;
} ARGS_glUniform1i64vNV;
typedef struct {
    int index;
    ARGS_glUniform1i64vNV args;
} PACKED_glUniform1i64vNV;
typedef struct {
    GLint location;
    GLint v0;
} ARGS_glUniform1iARB;
typedef struct {
    int index;
    ARGS_glUniform1iARB args;
} PACKED_glUniform1iARB;
typedef struct {
    GLint location;
    GLsizei count;
    GLint * value;
} ARGS_glUniform1iv;
typedef struct {
    int index;
    ARGS_glUniform1iv args;
} PACKED_glUniform1iv;
typedef struct {
    GLint location;
    GLsizei count;
    GLint * value;
} ARGS_glUniform1ivARB;
typedef struct {
    int index;
    ARGS_glUniform1ivARB args;
} PACKED_glUniform1ivARB;
typedef struct {
    GLint location;
    GLuint v0;
} ARGS_glUniform1ui;
typedef struct {
    int index;
    ARGS_glUniform1ui args;
} PACKED_glUniform1ui;
typedef struct {
    GLint location;
    GLuint64EXT x;
} ARGS_glUniform1ui64NV;
typedef struct {
    int index;
    ARGS_glUniform1ui64NV args;
} PACKED_glUniform1ui64NV;
typedef struct {
    GLint location;
    GLsizei count;
    GLuint64EXT * value;
} ARGS_glUniform1ui64vNV;
typedef struct {
    int index;
    ARGS_glUniform1ui64vNV args;
} PACKED_glUniform1ui64vNV;
typedef struct {
    GLint location;
    GLuint v0;
} ARGS_glUniform1uiEXT;
typedef struct {
    int index;
    ARGS_glUniform1uiEXT args;
} PACKED_glUniform1uiEXT;
typedef struct {
    GLint location;
    GLsizei count;
    GLuint * value;
} ARGS_glUniform1uiv;
typedef struct {
    int index;
    ARGS_glUniform1uiv args;
} PACKED_glUniform1uiv;
typedef struct {
    GLint location;
    GLsizei count;
    GLuint * value;
} ARGS_glUniform1uivEXT;
typedef struct {
    int index;
    ARGS_glUniform1uivEXT args;
} PACKED_glUniform1uivEXT;
typedef struct {
    GLint location;
    GLdouble x __attribute__ ((aligned(8)));
    GLdouble y __attribute__ ((aligned(8)));
} ARGS_glUniform2d;
typedef struct {
    int index;
    ARGS_glUniform2d args;
} PACKED_glUniform2d;
typedef struct {
    GLint location;
    GLsizei count;
    GLdouble * value;
} ARGS_glUniform2dv;
typedef struct {
    int index;
    ARGS_glUniform2dv args;
} PACKED_glUniform2dv;
typedef struct {
    GLint location;
    GLfloat v0;
    GLfloat v1;
} ARGS_glUniform2f;
typedef struct {
    int index;
    ARGS_glUniform2f args;
} PACKED_glUniform2f;
typedef struct {
    GLint location;
    GLfloat v0;
    GLfloat v1;
} ARGS_glUniform2fARB;
typedef struct {
    int index;
    ARGS_glUniform2fARB args;
} PACKED_glUniform2fARB;
typedef struct {
    GLint location;
    GLsizei count;
    GLfloat * value;
} ARGS_glUniform2fv;
typedef struct {
    int index;
    ARGS_glUniform2fv args;
} PACKED_glUniform2fv;
typedef struct {
    GLint location;
    GLsizei count;
    GLfloat * value;
} ARGS_glUniform2fvARB;
typedef struct {
    int index;
    ARGS_glUniform2fvARB args;
} PACKED_glUniform2fvARB;
typedef struct {
    GLint location;
    GLint v0;
    GLint v1;
} ARGS_glUniform2i;
typedef struct {
    int index;
    ARGS_glUniform2i args;
} PACKED_glUniform2i;
typedef struct {
    GLint location;
    GLint64EXT x;
    GLint64EXT y;
} ARGS_glUniform2i64NV;
typedef struct {
    int index;
    ARGS_glUniform2i64NV args;
} PACKED_glUniform2i64NV;
typedef struct {
    GLint location;
    GLsizei count;
    GLint64EXT * value;
} ARGS_glUniform2i64vNV;
typedef struct {
    int index;
    ARGS_glUniform2i64vNV args;
} PACKED_glUniform2i64vNV;
typedef struct {
    GLint location;
    GLint v0;
    GLint v1;
} ARGS_glUniform2iARB;
typedef struct {
    int index;
    ARGS_glUniform2iARB args;
} PACKED_glUniform2iARB;
typedef struct {
    GLint location;
    GLsizei count;
    GLint * value;
} ARGS_glUniform2iv;
typedef struct {
    int index;
    ARGS_glUniform2iv args;
} PACKED_glUniform2iv;
typedef struct {
    GLint location;
    GLsizei count;
    GLint * value;
} ARGS_glUniform2ivARB;
typedef struct {
    int index;
    ARGS_glUniform2ivARB args;
} PACKED_glUniform2ivARB;
typedef struct {
    GLint location;
    GLuint v0;
    GLuint v1;
} ARGS_glUniform2ui;
typedef struct {
    int index;
    ARGS_glUniform2ui args;
} PACKED_glUniform2ui;
typedef struct {
    GLint location;
    GLuint64EXT x;
    GLuint64EXT y;
} ARGS_glUniform2ui64NV;
typedef struct {
    int index;
    ARGS_glUniform2ui64NV args;
} PACKED_glUniform2ui64NV;
typedef struct {
    GLint location;
    GLsizei count;
    GLuint64EXT * value;
} ARGS_glUniform2ui64vNV;
typedef struct {
    int index;
    ARGS_glUniform2ui64vNV args;
} PACKED_glUniform2ui64vNV;
typedef struct {
    GLint location;
    GLuint v0;
    GLuint v1;
} ARGS_glUniform2uiEXT;
typedef struct {
    int index;
    ARGS_glUniform2uiEXT args;
} PACKED_glUniform2uiEXT;
typedef struct {
    GLint location;
    GLsizei count;
    GLuint * value;
} ARGS_glUniform2uiv;
typedef struct {
    int index;
    ARGS_glUniform2uiv args;
} PACKED_glUniform2uiv;
typedef struct {
    GLint location;
    GLsizei count;
    GLuint * value;
} ARGS_glUniform2uivEXT;
typedef struct {
    int index;
    ARGS_glUniform2uivEXT args;
} PACKED_glUniform2uivEXT;
typedef struct {
    GLint location;
    GLdouble x __attribute__ ((aligned(8)));
    GLdouble y __attribute__ ((aligned(8)));
    GLdouble z __attribute__ ((aligned(8)));
} ARGS_glUniform3d;
typedef struct {
    int index;
    ARGS_glUniform3d args;
} PACKED_glUniform3d;
typedef struct {
    GLint location;
    GLsizei count;
    GLdouble * value;
} ARGS_glUniform3dv;
typedef struct {
    int index;
    ARGS_glUniform3dv args;
} PACKED_glUniform3dv;
typedef struct {
    GLint location;
    GLfloat v0;
    GLfloat v1;
    GLfloat v2;
} ARGS_glUniform3f;
typedef struct {
    int index;
    ARGS_glUniform3f args;
} PACKED_glUniform3f;
typedef struct {
    GLint location;
    GLfloat v0;
    GLfloat v1;
    GLfloat v2;
} ARGS_glUniform3fARB;
typedef struct {
    int index;
    ARGS_glUniform3fARB args;
} PACKED_glUniform3fARB;
typedef struct {
    GLint location;
    GLsizei count;
    GLfloat * value;
} ARGS_glUniform3fv;
typedef struct {
    int index;
    ARGS_glUniform3fv args;
} PACKED_glUniform3fv;
typedef struct {
    GLint location;
    GLsizei count;
    GLfloat * value;
} ARGS_glUniform3fvARB;
typedef struct {
    int index;
    ARGS_glUniform3fvARB args;
} PACKED_glUniform3fvARB;
typedef struct {
    GLint location;
    GLint v0;
    GLint v1;
    GLint v2;
} ARGS_glUniform3i;
typedef struct {
    int index;
    ARGS_glUniform3i args;
} PACKED_glUniform3i;
typedef struct {
    GLint location;
    GLint64EXT x;
    GLint64EXT y;
    GLint64EXT z;
} ARGS_glUniform3i64NV;
typedef struct {
    int index;
    ARGS_glUniform3i64NV args;
} PACKED_glUniform3i64NV;
typedef struct {
    GLint location;
    GLsizei count;
    GLint64EXT * value;
} ARGS_glUniform3i64vNV;
typedef struct {
    int index;
    ARGS_glUniform3i64vNV args;
} PACKED_glUniform3i64vNV;
typedef struct {
    GLint location;
    GLint v0;
    GLint v1;
    GLint v2;
} ARGS_glUniform3iARB;
typedef struct {
    int index;
    ARGS_glUniform3iARB args;
} PACKED_glUniform3iARB;
typedef struct {
    GLint location;
    GLsizei count;
    GLint * value;
} ARGS_glUniform3iv;
typedef struct {
    int index;
    ARGS_glUniform3iv args;
} PACKED_glUniform3iv;
typedef struct {
    GLint location;
    GLsizei count;
    GLint * value;
} ARGS_glUniform3ivARB;
typedef struct {
    int index;
    ARGS_glUniform3ivARB args;
} PACKED_glUniform3ivARB;
typedef struct {
    GLint location;
    GLuint v0;
    GLuint v1;
    GLuint v2;
} ARGS_glUniform3ui;
typedef struct {
    int index;
    ARGS_glUniform3ui args;
} PACKED_glUniform3ui;
typedef struct {
    GLint location;
    GLuint64EXT x;
    GLuint64EXT y;
    GLuint64EXT z;
} ARGS_glUniform3ui64NV;
typedef struct {
    int index;
    ARGS_glUniform3ui64NV args;
} PACKED_glUniform3ui64NV;
typedef struct {
    GLint location;
    GLsizei count;
    GLuint64EXT * value;
} ARGS_glUniform3ui64vNV;
typedef struct {
    int index;
    ARGS_glUniform3ui64vNV args;
} PACKED_glUniform3ui64vNV;
typedef struct {
    GLint location;
    GLuint v0;
    GLuint v1;
    GLuint v2;
} ARGS_glUniform3uiEXT;
typedef struct {
    int index;
    ARGS_glUniform3uiEXT args;
} PACKED_glUniform3uiEXT;
typedef struct {
    GLint location;
    GLsizei count;
    GLuint * value;
} ARGS_glUniform3uiv;
typedef struct {
    int index;
    ARGS_glUniform3uiv args;
} PACKED_glUniform3uiv;
typedef struct {
    GLint location;
    GLsizei count;
    GLuint * value;
} ARGS_glUniform3uivEXT;
typedef struct {
    int index;
    ARGS_glUniform3uivEXT args;
} PACKED_glUniform3uivEXT;
typedef struct {
    GLint location;
    GLdouble x __attribute__ ((aligned(8)));
    GLdouble y __attribute__ ((aligned(8)));
    GLdouble z __attribute__ ((aligned(8)));
    GLdouble w __attribute__ ((aligned(8)));
} ARGS_glUniform4d;
typedef struct {
    int index;
    ARGS_glUniform4d args;
} PACKED_glUniform4d;
typedef struct {
    GLint location;
    GLsizei count;
    GLdouble * value;
} ARGS_glUniform4dv;
typedef struct {
    int index;
    ARGS_glUniform4dv args;
} PACKED_glUniform4dv;
typedef struct {
    GLint location;
    GLfloat v0;
    GLfloat v1;
    GLfloat v2;
    GLfloat v3;
} ARGS_glUniform4f;
typedef struct {
    int index;
    ARGS_glUniform4f args;
} PACKED_glUniform4f;
typedef struct {
    GLint location;
    GLfloat v0;
    GLfloat v1;
    GLfloat v2;
    GLfloat v3;
} ARGS_glUniform4fARB;
typedef struct {
    int index;
    ARGS_glUniform4fARB args;
} PACKED_glUniform4fARB;
typedef struct {
    GLint location;
    GLsizei count;
    GLfloat * value;
} ARGS_glUniform4fv;
typedef struct {
    int index;
    ARGS_glUniform4fv args;
} PACKED_glUniform4fv;
typedef struct {
    GLint location;
    GLsizei count;
    GLfloat * value;
} ARGS_glUniform4fvARB;
typedef struct {
    int index;
    ARGS_glUniform4fvARB args;
} PACKED_glUniform4fvARB;
typedef struct {
    GLint location;
    GLint v0;
    GLint v1;
    GLint v2;
    GLint v3;
} ARGS_glUniform4i;
typedef struct {
    int index;
    ARGS_glUniform4i args;
} PACKED_glUniform4i;
typedef struct {
    GLint location;
    GLint64EXT x;
    GLint64EXT y;
    GLint64EXT z;
    GLint64EXT w;
} ARGS_glUniform4i64NV;
typedef struct {
    int index;
    ARGS_glUniform4i64NV args;
} PACKED_glUniform4i64NV;
typedef struct {
    GLint location;
    GLsizei count;
    GLint64EXT * value;
} ARGS_glUniform4i64vNV;
typedef struct {
    int index;
    ARGS_glUniform4i64vNV args;
} PACKED_glUniform4i64vNV;
typedef struct {
    GLint location;
    GLint v0;
    GLint v1;
    GLint v2;
    GLint v3;
} ARGS_glUniform4iARB;
typedef struct {
    int index;
    ARGS_glUniform4iARB args;
} PACKED_glUniform4iARB;
typedef struct {
    GLint location;
    GLsizei count;
    GLint * value;
} ARGS_glUniform4iv;
typedef struct {
    int index;
    ARGS_glUniform4iv args;
} PACKED_glUniform4iv;
typedef struct {
    GLint location;
    GLsizei count;
    GLint * value;
} ARGS_glUniform4ivARB;
typedef struct {
    int index;
    ARGS_glUniform4ivARB args;
} PACKED_glUniform4ivARB;
typedef struct {
    GLint location;
    GLuint v0;
    GLuint v1;
    GLuint v2;
    GLuint v3;
} ARGS_glUniform4ui;
typedef struct {
    int index;
    ARGS_glUniform4ui args;
} PACKED_glUniform4ui;
typedef struct {
    GLint location;
    GLuint64EXT x;
    GLuint64EXT y;
    GLuint64EXT z;
    GLuint64EXT w;
} ARGS_glUniform4ui64NV;
typedef struct {
    int index;
    ARGS_glUniform4ui64NV args;
} PACKED_glUniform4ui64NV;
typedef struct {
    GLint location;
    GLsizei count;
    GLuint64EXT * value;
} ARGS_glUniform4ui64vNV;
typedef struct {
    int index;
    ARGS_glUniform4ui64vNV args;
} PACKED_glUniform4ui64vNV;
typedef struct {
    GLint location;
    GLuint v0;
    GLuint v1;
    GLuint v2;
    GLuint v3;
} ARGS_glUniform4uiEXT;
typedef struct {
    int index;
    ARGS_glUniform4uiEXT args;
} PACKED_glUniform4uiEXT;
typedef struct {
    GLint location;
    GLsizei count;
    GLuint * value;
} ARGS_glUniform4uiv;
typedef struct {
    int index;
    ARGS_glUniform4uiv args;
} PACKED_glUniform4uiv;
typedef struct {
    GLint location;
    GLsizei count;
    GLuint * value;
} ARGS_glUniform4uivEXT;
typedef struct {
    int index;
    ARGS_glUniform4uivEXT args;
} PACKED_glUniform4uivEXT;
typedef struct {
    GLuint program;
    GLuint uniformBlockIndex;
    GLuint uniformBlockBinding;
} ARGS_glUniformBlockBinding;
typedef struct {
    int index;
    ARGS_glUniformBlockBinding args;
} PACKED_glUniformBlockBinding;
typedef struct {
    GLuint program;
    GLint location;
    GLuint buffer;
} ARGS_glUniformBufferEXT;
typedef struct {
    int index;
    ARGS_glUniformBufferEXT args;
} PACKED_glUniformBufferEXT;
typedef struct {
    GLint location;
    GLuint64 value;
} ARGS_glUniformHandleui64NV;
typedef struct {
    int index;
    ARGS_glUniformHandleui64NV args;
} PACKED_glUniformHandleui64NV;
typedef struct {
    GLint location;
    GLsizei count;
    GLuint64 * value;
} ARGS_glUniformHandleui64vNV;
typedef struct {
    int index;
    ARGS_glUniformHandleui64vNV args;
} PACKED_glUniformHandleui64vNV;
typedef struct {
    GLint location;
    GLsizei count;
    GLboolean transpose;
    GLdouble * value;
} ARGS_glUniformMatrix2dv;
typedef struct {
    int index;
    ARGS_glUniformMatrix2dv args;
} PACKED_glUniformMatrix2dv;
typedef struct {
    GLint location;
    GLsizei count;
    GLboolean transpose;
    GLfloat * value;
} ARGS_glUniformMatrix2fv;
typedef struct {
    int index;
    ARGS_glUniformMatrix2fv args;
} PACKED_glUniformMatrix2fv;
typedef struct {
    GLint location;
    GLsizei count;
    GLboolean transpose;
    GLfloat * value;
} ARGS_glUniformMatrix2fvARB;
typedef struct {
    int index;
    ARGS_glUniformMatrix2fvARB args;
} PACKED_glUniformMatrix2fvARB;
typedef struct {
    GLint location;
    GLsizei count;
    GLboolean transpose;
    GLdouble * value;
} ARGS_glUniformMatrix2x3dv;
typedef struct {
    int index;
    ARGS_glUniformMatrix2x3dv args;
} PACKED_glUniformMatrix2x3dv;
typedef struct {
    GLint location;
    GLsizei count;
    GLboolean transpose;
    GLfloat * value;
} ARGS_glUniformMatrix2x3fv;
typedef struct {
    int index;
    ARGS_glUniformMatrix2x3fv args;
} PACKED_glUniformMatrix2x3fv;
typedef struct {
    GLint location;
    GLsizei count;
    GLboolean transpose;
    GLdouble * value;
} ARGS_glUniformMatrix2x4dv;
typedef struct {
    int index;
    ARGS_glUniformMatrix2x4dv args;
} PACKED_glUniformMatrix2x4dv;
typedef struct {
    GLint location;
    GLsizei count;
    GLboolean transpose;
    GLfloat * value;
} ARGS_glUniformMatrix2x4fv;
typedef struct {
    int index;
    ARGS_glUniformMatrix2x4fv args;
} PACKED_glUniformMatrix2x4fv;
typedef struct {
    GLint location;
    GLsizei count;
    GLboolean transpose;
    GLdouble * value;
} ARGS_glUniformMatrix3dv;
typedef struct {
    int index;
    ARGS_glUniformMatrix3dv args;
} PACKED_glUniformMatrix3dv;
typedef struct {
    GLint location;
    GLsizei count;
    GLboolean transpose;
    GLfloat * value;
} ARGS_glUniformMatrix3fv;
typedef struct {
    int index;
    ARGS_glUniformMatrix3fv args;
} PACKED_glUniformMatrix3fv;
typedef struct {
    GLint location;
    GLsizei count;
    GLboolean transpose;
    GLfloat * value;
} ARGS_glUniformMatrix3fvARB;
typedef struct {
    int index;
    ARGS_glUniformMatrix3fvARB args;
} PACKED_glUniformMatrix3fvARB;
typedef struct {
    GLint location;
    GLsizei count;
    GLboolean transpose;
    GLdouble * value;
} ARGS_glUniformMatrix3x2dv;
typedef struct {
    int index;
    ARGS_glUniformMatrix3x2dv args;
} PACKED_glUniformMatrix3x2dv;
typedef struct {
    GLint location;
    GLsizei count;
    GLboolean transpose;
    GLfloat * value;
} ARGS_glUniformMatrix3x2fv;
typedef struct {
    int index;
    ARGS_glUniformMatrix3x2fv args;
} PACKED_glUniformMatrix3x2fv;
typedef struct {
    GLint location;
    GLsizei count;
    GLboolean transpose;
    GLdouble * value;
} ARGS_glUniformMatrix3x4dv;
typedef struct {
    int index;
    ARGS_glUniformMatrix3x4dv args;
} PACKED_glUniformMatrix3x4dv;
typedef struct {
    GLint location;
    GLsizei count;
    GLboolean transpose;
    GLfloat * value;
} ARGS_glUniformMatrix3x4fv;
typedef struct {
    int index;
    ARGS_glUniformMatrix3x4fv args;
} PACKED_glUniformMatrix3x4fv;
typedef struct {
    GLint location;
    GLsizei count;
    GLboolean transpose;
    GLdouble * value;
} ARGS_glUniformMatrix4dv;
typedef struct {
    int index;
    ARGS_glUniformMatrix4dv args;
} PACKED_glUniformMatrix4dv;
typedef struct {
    GLint location;
    GLsizei count;
    GLboolean transpose;
    GLfloat * value;
} ARGS_glUniformMatrix4fv;
typedef struct {
    int index;
    ARGS_glUniformMatrix4fv args;
} PACKED_glUniformMatrix4fv;
typedef struct {
    GLint location;
    GLsizei count;
    GLboolean transpose;
    GLfloat * value;
} ARGS_glUniformMatrix4fvARB;
typedef struct {
    int index;
    ARGS_glUniformMatrix4fvARB args;
} PACKED_glUniformMatrix4fvARB;
typedef struct {
    GLint location;
    GLsizei count;
    GLboolean transpose;
    GLdouble * value;
} ARGS_glUniformMatrix4x2dv;
typedef struct {
    int index;
    ARGS_glUniformMatrix4x2dv args;
} PACKED_glUniformMatrix4x2dv;
typedef struct {
    GLint location;
    GLsizei count;
    GLboolean transpose;
    GLfloat * value;
} ARGS_glUniformMatrix4x2fv;
typedef struct {
    int index;
    ARGS_glUniformMatrix4x2fv args;
} PACKED_glUniformMatrix4x2fv;
typedef struct {
    GLint location;
    GLsizei count;
    GLboolean transpose;
    GLdouble * value;
} ARGS_glUniformMatrix4x3dv;
typedef struct {
    int index;
    ARGS_glUniformMatrix4x3dv args;
} PACKED_glUniformMatrix4x3dv;
typedef struct {
    GLint location;
    GLsizei count;
    GLboolean transpose;
    GLfloat * value;
} ARGS_glUniformMatrix4x3fv;
typedef struct {
    int index;
    ARGS_glUniformMatrix4x3fv args;
} PACKED_glUniformMatrix4x3fv;
typedef struct {
    GLenum shadertype;
    GLsizei count;
    GLuint * indices;
} ARGS_glUniformSubroutinesuiv;
typedef struct {
    int index;
    ARGS_glUniformSubroutinesuiv args;
} PACKED_glUniformSubroutinesuiv;
typedef struct {
    GLint location;
    GLuint64EXT value;
} ARGS_glUniformui64NV;
typedef struct {
    int index;
    ARGS_glUniformui64NV args;
} PACKED_glUniformui64NV;
typedef struct {
    GLint location;
    GLsizei count;
    GLuint64EXT * value;
} ARGS_glUniformui64vNV;
typedef struct {
    int index;
    ARGS_glUniformui64vNV args;
} PACKED_glUniformui64vNV;
typedef struct {
    int index;
} PACKED_glUnlockArraysEXT;
typedef struct {
    GLenum target;
} ARGS_glUnmapBuffer;
typedef struct {
    int index;
    ARGS_glUnmapBuffer args;
} PACKED_glUnmapBuffer;
typedef struct {
    GLenum target;
} ARGS_glUnmapBufferARB;
typedef struct {
    int index;
    ARGS_glUnmapBufferARB args;
} PACKED_glUnmapBufferARB;
typedef struct {
    GLuint buffer;
} ARGS_glUnmapNamedBufferEXT;
typedef struct {
    int index;
    ARGS_glUnmapNamedBufferEXT args;
} PACKED_glUnmapNamedBufferEXT;
typedef struct {
    GLuint buffer;
} ARGS_glUnmapObjectBufferATI;
typedef struct {
    int index;
    ARGS_glUnmapObjectBufferATI args;
} PACKED_glUnmapObjectBufferATI;
typedef struct {
    GLuint texture;
    GLint level;
} ARGS_glUnmapTexture2DINTEL;
typedef struct {
    int index;
    ARGS_glUnmapTexture2DINTEL args;
} PACKED_glUnmapTexture2DINTEL;
typedef struct {
    GLuint buffer;
    GLuint offset;
    GLsizei size;
    GLvoid * pointer;
    GLenum preserve;
} ARGS_glUpdateObjectBufferATI;
typedef struct {
    int index;
    ARGS_glUpdateObjectBufferATI args;
} PACKED_glUpdateObjectBufferATI;
typedef struct {
    GLuint program;
} ARGS_glUseProgram;
typedef struct {
    int index;
    ARGS_glUseProgram args;
} PACKED_glUseProgram;
typedef struct {
    GLhandleARB programObj;
} ARGS_glUseProgramObjectARB;
typedef struct {
    int index;
    ARGS_glUseProgramObjectARB args;
} PACKED_glUseProgramObjectARB;
typedef struct {
    GLuint pipeline;
    GLbitfield stages;
    GLuint program;
} ARGS_glUseProgramStages;
typedef struct {
    int index;
    ARGS_glUseProgramStages args;
} PACKED_glUseProgramStages;
typedef struct {
    GLenum type;
    GLuint program;
} ARGS_glUseShaderProgramEXT;
typedef struct {
    int index;
    ARGS_glUseShaderProgramEXT args;
} PACKED_glUseShaderProgramEXT;
typedef struct {
    int index;
} PACKED_glVDPAUFiniNV;
typedef struct {
    GLvdpauSurfaceNV surface;
    GLenum pname;
    GLsizei bufSize;
    GLsizei * length;
    GLint * values;
} ARGS_glVDPAUGetSurfaceivNV;
typedef struct {
    int index;
    ARGS_glVDPAUGetSurfaceivNV args;
} PACKED_glVDPAUGetSurfaceivNV;
typedef struct {
    GLvoid * vdpDevice;
    GLvoid * getProcAddress;
} ARGS_glVDPAUInitNV;
typedef struct {
    int index;
    ARGS_glVDPAUInitNV args;
} PACKED_glVDPAUInitNV;
typedef struct {
    GLvdpauSurfaceNV surface;
} ARGS_glVDPAUIsSurfaceNV;
typedef struct {
    int index;
    ARGS_glVDPAUIsSurfaceNV args;
} PACKED_glVDPAUIsSurfaceNV;
typedef struct {
    GLsizei numSurfaces;
    GLvdpauSurfaceNV * surfaces;
} ARGS_glVDPAUMapSurfacesNV;
typedef struct {
    int index;
    ARGS_glVDPAUMapSurfacesNV args;
} PACKED_glVDPAUMapSurfacesNV;
typedef struct {
    GLvoid * vdpSurface;
    GLenum target;
    GLsizei numTextureNames;
    GLuint * textureNames;
} ARGS_glVDPAURegisterOutputSurfaceNV;
typedef struct {
    int index;
    ARGS_glVDPAURegisterOutputSurfaceNV args;
} PACKED_glVDPAURegisterOutputSurfaceNV;
typedef struct {
    GLvoid * vdpSurface;
    GLenum target;
    GLsizei numTextureNames;
    GLuint * textureNames;
} ARGS_glVDPAURegisterVideoSurfaceNV;
typedef struct {
    int index;
    ARGS_glVDPAURegisterVideoSurfaceNV args;
} PACKED_glVDPAURegisterVideoSurfaceNV;
typedef struct {
    GLvdpauSurfaceNV surface;
    GLenum access;
} ARGS_glVDPAUSurfaceAccessNV;
typedef struct {
    int index;
    ARGS_glVDPAUSurfaceAccessNV args;
} PACKED_glVDPAUSurfaceAccessNV;
typedef struct {
    GLsizei numSurface;
    GLvdpauSurfaceNV * surfaces;
} ARGS_glVDPAUUnmapSurfacesNV;
typedef struct {
    int index;
    ARGS_glVDPAUUnmapSurfacesNV args;
} PACKED_glVDPAUUnmapSurfacesNV;
typedef struct {
    GLvdpauSurfaceNV surface;
} ARGS_glVDPAUUnregisterSurfaceNV;
typedef struct {
    int index;
    ARGS_glVDPAUUnregisterSurfaceNV args;
} PACKED_glVDPAUUnregisterSurfaceNV;
typedef struct {
    GLuint program;
} ARGS_glValidateProgram;
typedef struct {
    int index;
    ARGS_glValidateProgram args;
} PACKED_glValidateProgram;
typedef struct {
    GLhandleARB programObj;
} ARGS_glValidateProgramARB;
typedef struct {
    int index;
    ARGS_glValidateProgramARB args;
} PACKED_glValidateProgramARB;
typedef struct {
    GLuint pipeline;
} ARGS_glValidateProgramPipeline;
typedef struct {
    int index;
    ARGS_glValidateProgramPipeline args;
} PACKED_glValidateProgramPipeline;
typedef struct {
    GLuint id;
    GLenum type;
    GLsizei stride;
    GLuint buffer;
    GLuint offset;
} ARGS_glVariantArrayObjectATI;
typedef struct {
    int index;
    ARGS_glVariantArrayObjectATI args;
} PACKED_glVariantArrayObjectATI;
typedef struct {
    GLuint id;
    GLenum type;
    GLuint stride;
    GLvoid * addr;
} ARGS_glVariantPointerEXT;
typedef struct {
    int index;
    ARGS_glVariantPointerEXT args;
} PACKED_glVariantPointerEXT;
typedef struct {
    GLuint id;
    GLbyte * addr;
} ARGS_glVariantbvEXT;
typedef struct {
    int index;
    ARGS_glVariantbvEXT args;
} PACKED_glVariantbvEXT;
typedef struct {
    GLuint id;
    GLdouble * addr;
} ARGS_glVariantdvEXT;
typedef struct {
    int index;
    ARGS_glVariantdvEXT args;
} PACKED_glVariantdvEXT;
typedef struct {
    GLuint id;
    GLfloat * addr;
} ARGS_glVariantfvEXT;
typedef struct {
    int index;
    ARGS_glVariantfvEXT args;
} PACKED_glVariantfvEXT;
typedef struct {
    GLuint id;
    GLint * addr;
} ARGS_glVariantivEXT;
typedef struct {
    int index;
    ARGS_glVariantivEXT args;
} PACKED_glVariantivEXT;
typedef struct {
    GLuint id;
    GLshort * addr;
} ARGS_glVariantsvEXT;
typedef struct {
    int index;
    ARGS_glVariantsvEXT args;
} PACKED_glVariantsvEXT;
typedef struct {
    GLuint id;
    GLubyte * addr;
} ARGS_glVariantubvEXT;
typedef struct {
    int index;
    ARGS_glVariantubvEXT args;
} PACKED_glVariantubvEXT;
typedef struct {
    GLuint id;
    GLuint * addr;
} ARGS_glVariantuivEXT;
typedef struct {
    int index;
    ARGS_glVariantuivEXT args;
} PACKED_glVariantuivEXT;
typedef struct {
    GLuint id;
    GLushort * addr;
} ARGS_glVariantusvEXT;
typedef struct {
    int index;
    ARGS_glVariantusvEXT args;
} PACKED_glVariantusvEXT;
typedef struct {
    GLbyte x;
} ARGS_glVertex2bOES;
typedef struct {
    int index;
    ARGS_glVertex2bOES args;
} PACKED_glVertex2bOES;
typedef struct {
    GLbyte * coords;
} ARGS_glVertex2bvOES;
typedef struct {
    int index;
    ARGS_glVertex2bvOES args;
} PACKED_glVertex2bvOES;
typedef struct {
    GLdouble x __attribute__ ((aligned(8)));
    GLdouble y __attribute__ ((aligned(8)));
} ARGS_glVertex2d;
typedef struct {
    int index;
    ARGS_glVertex2d args;
} PACKED_glVertex2d;
typedef struct {
    GLdouble * v;
} ARGS_glVertex2dv;
typedef struct {
    int index;
    ARGS_glVertex2dv args;
} PACKED_glVertex2dv;
typedef struct {
    GLfloat x;
    GLfloat y;
} ARGS_glVertex2f;
typedef struct {
    int index;
    ARGS_glVertex2f args;
} PACKED_glVertex2f;
typedef struct {
    GLfloat * v;
} ARGS_glVertex2fv;
typedef struct {
    int index;
    ARGS_glVertex2fv args;
} PACKED_glVertex2fv;
typedef struct {
    GLhalfNV x;
    GLhalfNV y;
} ARGS_glVertex2hNV;
typedef struct {
    int index;
    ARGS_glVertex2hNV args;
} PACKED_glVertex2hNV;
typedef struct {
    GLhalfNV * v;
} ARGS_glVertex2hvNV;
typedef struct {
    int index;
    ARGS_glVertex2hvNV args;
} PACKED_glVertex2hvNV;
typedef struct {
    GLint x;
    GLint y;
} ARGS_glVertex2i;
typedef struct {
    int index;
    ARGS_glVertex2i args;
} PACKED_glVertex2i;
typedef struct {
    GLint * v;
} ARGS_glVertex2iv;
typedef struct {
    int index;
    ARGS_glVertex2iv args;
} PACKED_glVertex2iv;
typedef struct {
    GLshort x;
    GLshort y;
} ARGS_glVertex2s;
typedef struct {
    int index;
    ARGS_glVertex2s args;
} PACKED_glVertex2s;
typedef struct {
    GLshort * v;
} ARGS_glVertex2sv;
typedef struct {
    int index;
    ARGS_glVertex2sv args;
} PACKED_glVertex2sv;
typedef struct {
    GLfixed x;
} ARGS_glVertex2xOES;
typedef struct {
    int index;
    ARGS_glVertex2xOES args;
} PACKED_glVertex2xOES;
typedef struct {
    GLfixed * coords;
} ARGS_glVertex2xvOES;
typedef struct {
    int index;
    ARGS_glVertex2xvOES args;
} PACKED_glVertex2xvOES;
typedef struct {
    GLbyte x;
    GLbyte y;
} ARGS_glVertex3bOES;
typedef struct {
    int index;
    ARGS_glVertex3bOES args;
} PACKED_glVertex3bOES;
typedef struct {
    GLbyte * coords;
} ARGS_glVertex3bvOES;
typedef struct {
    int index;
    ARGS_glVertex3bvOES args;
} PACKED_glVertex3bvOES;
typedef struct {
    GLdouble x __attribute__ ((aligned(8)));
    GLdouble y __attribute__ ((aligned(8)));
    GLdouble z __attribute__ ((aligned(8)));
} ARGS_glVertex3d;
typedef struct {
    int index;
    ARGS_glVertex3d args;
} PACKED_glVertex3d;
typedef struct {
    GLdouble * v;
} ARGS_glVertex3dv;
typedef struct {
    int index;
    ARGS_glVertex3dv args;
} PACKED_glVertex3dv;
typedef struct {
    GLfloat x;
    GLfloat y;
    GLfloat z;
} ARGS_glVertex3f;
typedef struct {
    int index;
    ARGS_glVertex3f args;
} PACKED_glVertex3f;
typedef struct {
    GLfloat * v;
} ARGS_glVertex3fv;
typedef struct {
    int index;
    ARGS_glVertex3fv args;
} PACKED_glVertex3fv;
typedef struct {
    GLhalfNV x;
    GLhalfNV y;
    GLhalfNV z;
} ARGS_glVertex3hNV;
typedef struct {
    int index;
    ARGS_glVertex3hNV args;
} PACKED_glVertex3hNV;
typedef struct {
    GLhalfNV * v;
} ARGS_glVertex3hvNV;
typedef struct {
    int index;
    ARGS_glVertex3hvNV args;
} PACKED_glVertex3hvNV;
typedef struct {
    GLint x;
    GLint y;
    GLint z;
} ARGS_glVertex3i;
typedef struct {
    int index;
    ARGS_glVertex3i args;
} PACKED_glVertex3i;
typedef struct {
    GLint * v;
} ARGS_glVertex3iv;
typedef struct {
    int index;
    ARGS_glVertex3iv args;
} PACKED_glVertex3iv;
typedef struct {
    GLshort x;
    GLshort y;
    GLshort z;
} ARGS_glVertex3s;
typedef struct {
    int index;
    ARGS_glVertex3s args;
} PACKED_glVertex3s;
typedef struct {
    GLshort * v;
} ARGS_glVertex3sv;
typedef struct {
    int index;
    ARGS_glVertex3sv args;
} PACKED_glVertex3sv;
typedef struct {
    GLfixed x;
    GLfixed y;
} ARGS_glVertex3xOES;
typedef struct {
    int index;
    ARGS_glVertex3xOES args;
} PACKED_glVertex3xOES;
typedef struct {
    GLfixed * coords;
} ARGS_glVertex3xvOES;
typedef struct {
    int index;
    ARGS_glVertex3xvOES args;
} PACKED_glVertex3xvOES;
typedef struct {
    GLbyte x;
    GLbyte y;
    GLbyte z;
} ARGS_glVertex4bOES;
typedef struct {
    int index;
    ARGS_glVertex4bOES args;
} PACKED_glVertex4bOES;
typedef struct {
    GLbyte * coords;
} ARGS_glVertex4bvOES;
typedef struct {
    int index;
    ARGS_glVertex4bvOES args;
} PACKED_glVertex4bvOES;
typedef struct {
    GLdouble x __attribute__ ((aligned(8)));
    GLdouble y __attribute__ ((aligned(8)));
    GLdouble z __attribute__ ((aligned(8)));
    GLdouble w __attribute__ ((aligned(8)));
} ARGS_glVertex4d;
typedef struct {
    int index;
    ARGS_glVertex4d args;
} PACKED_glVertex4d;
typedef struct {
    GLdouble * v;
} ARGS_glVertex4dv;
typedef struct {
    int index;
    ARGS_glVertex4dv args;
} PACKED_glVertex4dv;
typedef struct {
    GLfloat x;
    GLfloat y;
    GLfloat z;
    GLfloat w;
} ARGS_glVertex4f;
typedef struct {
    int index;
    ARGS_glVertex4f args;
} PACKED_glVertex4f;
typedef struct {
    GLfloat * v;
} ARGS_glVertex4fv;
typedef struct {
    int index;
    ARGS_glVertex4fv args;
} PACKED_glVertex4fv;
typedef struct {
    GLhalfNV x;
    GLhalfNV y;
    GLhalfNV z;
    GLhalfNV w;
} ARGS_glVertex4hNV;
typedef struct {
    int index;
    ARGS_glVertex4hNV args;
} PACKED_glVertex4hNV;
typedef struct {
    GLhalfNV * v;
} ARGS_glVertex4hvNV;
typedef struct {
    int index;
    ARGS_glVertex4hvNV args;
} PACKED_glVertex4hvNV;
typedef struct {
    GLint x;
    GLint y;
    GLint z;
    GLint w;
} ARGS_glVertex4i;
typedef struct {
    int index;
    ARGS_glVertex4i args;
} PACKED_glVertex4i;
typedef struct {
    GLint * v;
} ARGS_glVertex4iv;
typedef struct {
    int index;
    ARGS_glVertex4iv args;
} PACKED_glVertex4iv;
typedef struct {
    GLshort x;
    GLshort y;
    GLshort z;
    GLshort w;
} ARGS_glVertex4s;
typedef struct {
    int index;
    ARGS_glVertex4s args;
} PACKED_glVertex4s;
typedef struct {
    GLshort * v;
} ARGS_glVertex4sv;
typedef struct {
    int index;
    ARGS_glVertex4sv args;
} PACKED_glVertex4sv;
typedef struct {
    GLfixed x;
    GLfixed y;
    GLfixed z;
} ARGS_glVertex4xOES;
typedef struct {
    int index;
    ARGS_glVertex4xOES args;
} PACKED_glVertex4xOES;
typedef struct {
    GLfixed * coords;
} ARGS_glVertex4xvOES;
typedef struct {
    int index;
    ARGS_glVertex4xvOES args;
} PACKED_glVertex4xvOES;
typedef struct {
    GLuint vaobj;
    GLuint bindingindex;
    GLuint buffer;
    GLintptr offset;
    GLsizei stride;
} ARGS_glVertexArrayBindVertexBufferEXT;
typedef struct {
    int index;
    ARGS_glVertexArrayBindVertexBufferEXT args;
} PACKED_glVertexArrayBindVertexBufferEXT;
typedef struct {
    GLuint vaobj;
    GLuint buffer;
    GLint size;
    GLenum type;
    GLsizei stride;
    GLintptr offset;
} ARGS_glVertexArrayColorOffsetEXT;
typedef struct {
    int index;
    ARGS_glVertexArrayColorOffsetEXT args;
} PACKED_glVertexArrayColorOffsetEXT;
typedef struct {
    GLuint vaobj;
    GLuint buffer;
    GLsizei stride;
    GLintptr offset;
} ARGS_glVertexArrayEdgeFlagOffsetEXT;
typedef struct {
    int index;
    ARGS_glVertexArrayEdgeFlagOffsetEXT args;
} PACKED_glVertexArrayEdgeFlagOffsetEXT;
typedef struct {
    GLuint vaobj;
    GLuint buffer;
    GLenum type;
    GLsizei stride;
    GLintptr offset;
} ARGS_glVertexArrayFogCoordOffsetEXT;
typedef struct {
    int index;
    ARGS_glVertexArrayFogCoordOffsetEXT args;
} PACKED_glVertexArrayFogCoordOffsetEXT;
typedef struct {
    GLuint vaobj;
    GLuint buffer;
    GLenum type;
    GLsizei stride;
    GLintptr offset;
} ARGS_glVertexArrayIndexOffsetEXT;
typedef struct {
    int index;
    ARGS_glVertexArrayIndexOffsetEXT args;
} PACKED_glVertexArrayIndexOffsetEXT;
typedef struct {
    GLuint vaobj;
    GLuint buffer;
    GLenum texunit;
    GLint size;
    GLenum type;
    GLsizei stride;
    GLintptr offset;
} ARGS_glVertexArrayMultiTexCoordOffsetEXT;
typedef struct {
    int index;
    ARGS_glVertexArrayMultiTexCoordOffsetEXT args;
} PACKED_glVertexArrayMultiTexCoordOffsetEXT;
typedef struct {
    GLuint vaobj;
    GLuint buffer;
    GLenum type;
    GLsizei stride;
    GLintptr offset;
} ARGS_glVertexArrayNormalOffsetEXT;
typedef struct {
    int index;
    ARGS_glVertexArrayNormalOffsetEXT args;
} PACKED_glVertexArrayNormalOffsetEXT;
typedef struct {
    GLenum pname;
    GLint param;
} ARGS_glVertexArrayParameteriAPPLE;
typedef struct {
    int index;
    ARGS_glVertexArrayParameteriAPPLE args;
} PACKED_glVertexArrayParameteriAPPLE;
typedef struct {
    GLsizei length;
    GLvoid * pointer;
} ARGS_glVertexArrayRangeAPPLE;
typedef struct {
    int index;
    ARGS_glVertexArrayRangeAPPLE args;
} PACKED_glVertexArrayRangeAPPLE;
typedef struct {
    GLsizei length;
    GLvoid * pointer;
} ARGS_glVertexArrayRangeNV;
typedef struct {
    int index;
    ARGS_glVertexArrayRangeNV args;
} PACKED_glVertexArrayRangeNV;
typedef struct {
    GLuint vaobj;
    GLuint buffer;
    GLint size;
    GLenum type;
    GLsizei stride;
    GLintptr offset;
} ARGS_glVertexArraySecondaryColorOffsetEXT;
typedef struct {
    int index;
    ARGS_glVertexArraySecondaryColorOffsetEXT args;
} PACKED_glVertexArraySecondaryColorOffsetEXT;
typedef struct {
    GLuint vaobj;
    GLuint buffer;
    GLint size;
    GLenum type;
    GLsizei stride;
    GLintptr offset;
} ARGS_glVertexArrayTexCoordOffsetEXT;
typedef struct {
    int index;
    ARGS_glVertexArrayTexCoordOffsetEXT args;
} PACKED_glVertexArrayTexCoordOffsetEXT;
typedef struct {
    GLuint vaobj;
    GLuint attribindex;
    GLuint bindingindex;
} ARGS_glVertexArrayVertexAttribBindingEXT;
typedef struct {
    int index;
    ARGS_glVertexArrayVertexAttribBindingEXT args;
} PACKED_glVertexArrayVertexAttribBindingEXT;
typedef struct {
    GLuint vaobj;
    GLuint attribindex;
    GLint size;
    GLenum type;
    GLboolean normalized;
    GLuint relativeoffset;
} ARGS_glVertexArrayVertexAttribFormatEXT;
typedef struct {
    int index;
    ARGS_glVertexArrayVertexAttribFormatEXT args;
} PACKED_glVertexArrayVertexAttribFormatEXT;
typedef struct {
    GLuint vaobj;
    GLuint attribindex;
    GLint size;
    GLenum type;
    GLuint relativeoffset;
} ARGS_glVertexArrayVertexAttribIFormatEXT;
typedef struct {
    int index;
    ARGS_glVertexArrayVertexAttribIFormatEXT args;
} PACKED_glVertexArrayVertexAttribIFormatEXT;
typedef struct {
    GLuint vaobj;
    GLuint buffer;
    GLuint index;
    GLint size;
    GLenum type;
    GLsizei stride;
    GLintptr offset;
} ARGS_glVertexArrayVertexAttribIOffsetEXT;
typedef struct {
    int index;
    ARGS_glVertexArrayVertexAttribIOffsetEXT args;
} PACKED_glVertexArrayVertexAttribIOffsetEXT;
typedef struct {
    GLuint vaobj;
    GLuint attribindex;
    GLint size;
    GLenum type;
    GLuint relativeoffset;
} ARGS_glVertexArrayVertexAttribLFormatEXT;
typedef struct {
    int index;
    ARGS_glVertexArrayVertexAttribLFormatEXT args;
} PACKED_glVertexArrayVertexAttribLFormatEXT;
typedef struct {
    GLuint vaobj;
    GLuint buffer;
    GLuint index;
    GLint size;
    GLenum type;
    GLsizei stride;
    GLintptr offset;
} ARGS_glVertexArrayVertexAttribLOffsetEXT;
typedef struct {
    int index;
    ARGS_glVertexArrayVertexAttribLOffsetEXT args;
} PACKED_glVertexArrayVertexAttribLOffsetEXT;
typedef struct {
    GLuint vaobj;
    GLuint buffer;
    GLuint index;
    GLint size;
    GLenum type;
    GLboolean normalized;
    GLsizei stride;
    GLintptr offset;
} ARGS_glVertexArrayVertexAttribOffsetEXT;
typedef struct {
    int index;
    ARGS_glVertexArrayVertexAttribOffsetEXT args;
} PACKED_glVertexArrayVertexAttribOffsetEXT;
typedef struct {
    GLuint vaobj;
    GLuint bindingindex;
    GLuint divisor;
} ARGS_glVertexArrayVertexBindingDivisorEXT;
typedef struct {
    int index;
    ARGS_glVertexArrayVertexBindingDivisorEXT args;
} PACKED_glVertexArrayVertexBindingDivisorEXT;
typedef struct {
    GLuint vaobj;
    GLuint buffer;
    GLint size;
    GLenum type;
    GLsizei stride;
    GLintptr offset;
} ARGS_glVertexArrayVertexOffsetEXT;
typedef struct {
    int index;
    ARGS_glVertexArrayVertexOffsetEXT args;
} PACKED_glVertexArrayVertexOffsetEXT;
typedef struct {
    GLuint index;
    GLdouble x __attribute__ ((aligned(8)));
} ARGS_glVertexAttrib1d;
typedef struct {
    int index;
    ARGS_glVertexAttrib1d args;
} PACKED_glVertexAttrib1d;
typedef struct {
    GLuint index;
    GLdouble x __attribute__ ((aligned(8)));
} ARGS_glVertexAttrib1dARB;
typedef struct {
    int index;
    ARGS_glVertexAttrib1dARB args;
} PACKED_glVertexAttrib1dARB;
typedef struct {
    GLuint index;
    GLdouble x __attribute__ ((aligned(8)));
} ARGS_glVertexAttrib1dNV;
typedef struct {
    int index;
    ARGS_glVertexAttrib1dNV args;
} PACKED_glVertexAttrib1dNV;
typedef struct {
    GLuint index;
    GLdouble * v;
} ARGS_glVertexAttrib1dv;
typedef struct {
    int index;
    ARGS_glVertexAttrib1dv args;
} PACKED_glVertexAttrib1dv;
typedef struct {
    GLuint index;
    GLdouble * v;
} ARGS_glVertexAttrib1dvARB;
typedef struct {
    int index;
    ARGS_glVertexAttrib1dvARB args;
} PACKED_glVertexAttrib1dvARB;
typedef struct {
    GLuint index;
    GLdouble * v;
} ARGS_glVertexAttrib1dvNV;
typedef struct {
    int index;
    ARGS_glVertexAttrib1dvNV args;
} PACKED_glVertexAttrib1dvNV;
typedef struct {
    GLuint index;
    GLfloat x;
} ARGS_glVertexAttrib1f;
typedef struct {
    int index;
    ARGS_glVertexAttrib1f args;
} PACKED_glVertexAttrib1f;
typedef struct {
    GLuint index;
    GLfloat x;
} ARGS_glVertexAttrib1fARB;
typedef struct {
    int index;
    ARGS_glVertexAttrib1fARB args;
} PACKED_glVertexAttrib1fARB;
typedef struct {
    GLuint index;
    GLfloat x;
} ARGS_glVertexAttrib1fNV;
typedef struct {
    int index;
    ARGS_glVertexAttrib1fNV args;
} PACKED_glVertexAttrib1fNV;
typedef struct {
    GLuint index;
    GLfloat * v;
} ARGS_glVertexAttrib1fv;
typedef struct {
    int index;
    ARGS_glVertexAttrib1fv args;
} PACKED_glVertexAttrib1fv;
typedef struct {
    GLuint index;
    GLfloat * v;
} ARGS_glVertexAttrib1fvARB;
typedef struct {
    int index;
    ARGS_glVertexAttrib1fvARB args;
} PACKED_glVertexAttrib1fvARB;
typedef struct {
    GLuint index;
    GLfloat * v;
} ARGS_glVertexAttrib1fvNV;
typedef struct {
    int index;
    ARGS_glVertexAttrib1fvNV args;
} PACKED_glVertexAttrib1fvNV;
typedef struct {
    GLuint index;
    GLhalfNV x;
} ARGS_glVertexAttrib1hNV;
typedef struct {
    int index;
    ARGS_glVertexAttrib1hNV args;
} PACKED_glVertexAttrib1hNV;
typedef struct {
    GLuint index;
    GLhalfNV * v;
} ARGS_glVertexAttrib1hvNV;
typedef struct {
    int index;
    ARGS_glVertexAttrib1hvNV args;
} PACKED_glVertexAttrib1hvNV;
typedef struct {
    GLuint index;
    GLshort x;
} ARGS_glVertexAttrib1s;
typedef struct {
    int index;
    ARGS_glVertexAttrib1s args;
} PACKED_glVertexAttrib1s;
typedef struct {
    GLuint index;
    GLshort x;
} ARGS_glVertexAttrib1sARB;
typedef struct {
    int index;
    ARGS_glVertexAttrib1sARB args;
} PACKED_glVertexAttrib1sARB;
typedef struct {
    GLuint index;
    GLshort x;
} ARGS_glVertexAttrib1sNV;
typedef struct {
    int index;
    ARGS_glVertexAttrib1sNV args;
} PACKED_glVertexAttrib1sNV;
typedef struct {
    GLuint index;
    GLshort * v;
} ARGS_glVertexAttrib1sv;
typedef struct {
    int index;
    ARGS_glVertexAttrib1sv args;
} PACKED_glVertexAttrib1sv;
typedef struct {
    GLuint index;
    GLshort * v;
} ARGS_glVertexAttrib1svARB;
typedef struct {
    int index;
    ARGS_glVertexAttrib1svARB args;
} PACKED_glVertexAttrib1svARB;
typedef struct {
    GLuint index;
    GLshort * v;
} ARGS_glVertexAttrib1svNV;
typedef struct {
    int index;
    ARGS_glVertexAttrib1svNV args;
} PACKED_glVertexAttrib1svNV;
typedef struct {
    GLuint index;
    GLdouble x __attribute__ ((aligned(8)));
    GLdouble y __attribute__ ((aligned(8)));
} ARGS_glVertexAttrib2d;
typedef struct {
    int index;
    ARGS_glVertexAttrib2d args;
} PACKED_glVertexAttrib2d;
typedef struct {
    GLuint index;
    GLdouble x __attribute__ ((aligned(8)));
    GLdouble y __attribute__ ((aligned(8)));
} ARGS_glVertexAttrib2dARB;
typedef struct {
    int index;
    ARGS_glVertexAttrib2dARB args;
} PACKED_glVertexAttrib2dARB;
typedef struct {
    GLuint index;
    GLdouble x __attribute__ ((aligned(8)));
    GLdouble y __attribute__ ((aligned(8)));
} ARGS_glVertexAttrib2dNV;
typedef struct {
    int index;
    ARGS_glVertexAttrib2dNV args;
} PACKED_glVertexAttrib2dNV;
typedef struct {
    GLuint index;
    GLdouble * v;
} ARGS_glVertexAttrib2dv;
typedef struct {
    int index;
    ARGS_glVertexAttrib2dv args;
} PACKED_glVertexAttrib2dv;
typedef struct {
    GLuint index;
    GLdouble * v;
} ARGS_glVertexAttrib2dvARB;
typedef struct {
    int index;
    ARGS_glVertexAttrib2dvARB args;
} PACKED_glVertexAttrib2dvARB;
typedef struct {
    GLuint index;
    GLdouble * v;
} ARGS_glVertexAttrib2dvNV;
typedef struct {
    int index;
    ARGS_glVertexAttrib2dvNV args;
} PACKED_glVertexAttrib2dvNV;
typedef struct {
    GLuint index;
    GLfloat x;
    GLfloat y;
} ARGS_glVertexAttrib2f;
typedef struct {
    int index;
    ARGS_glVertexAttrib2f args;
} PACKED_glVertexAttrib2f;
typedef struct {
    GLuint index;
    GLfloat x;
    GLfloat y;
} ARGS_glVertexAttrib2fARB;
typedef struct {
    int index;
    ARGS_glVertexAttrib2fARB args;
} PACKED_glVertexAttrib2fARB;
typedef struct {
    GLuint index;
    GLfloat x;
    GLfloat y;
} ARGS_glVertexAttrib2fNV;
typedef struct {
    int index;
    ARGS_glVertexAttrib2fNV args;
} PACKED_glVertexAttrib2fNV;
typedef struct {
    GLuint index;
    GLfloat * v;
} ARGS_glVertexAttrib2fv;
typedef struct {
    int index;
    ARGS_glVertexAttrib2fv args;
} PACKED_glVertexAttrib2fv;
typedef struct {
    GLuint index;
    GLfloat * v;
} ARGS_glVertexAttrib2fvARB;
typedef struct {
    int index;
    ARGS_glVertexAttrib2fvARB args;
} PACKED_glVertexAttrib2fvARB;
typedef struct {
    GLuint index;
    GLfloat * v;
} ARGS_glVertexAttrib2fvNV;
typedef struct {
    int index;
    ARGS_glVertexAttrib2fvNV args;
} PACKED_glVertexAttrib2fvNV;
typedef struct {
    GLuint index;
    GLhalfNV x;
    GLhalfNV y;
} ARGS_glVertexAttrib2hNV;
typedef struct {
    int index;
    ARGS_glVertexAttrib2hNV args;
} PACKED_glVertexAttrib2hNV;
typedef struct {
    GLuint index;
    GLhalfNV * v;
} ARGS_glVertexAttrib2hvNV;
typedef struct {
    int index;
    ARGS_glVertexAttrib2hvNV args;
} PACKED_glVertexAttrib2hvNV;
typedef struct {
    GLuint index;
    GLshort x;
    GLshort y;
} ARGS_glVertexAttrib2s;
typedef struct {
    int index;
    ARGS_glVertexAttrib2s args;
} PACKED_glVertexAttrib2s;
typedef struct {
    GLuint index;
    GLshort x;
    GLshort y;
} ARGS_glVertexAttrib2sARB;
typedef struct {
    int index;
    ARGS_glVertexAttrib2sARB args;
} PACKED_glVertexAttrib2sARB;
typedef struct {
    GLuint index;
    GLshort x;
    GLshort y;
} ARGS_glVertexAttrib2sNV;
typedef struct {
    int index;
    ARGS_glVertexAttrib2sNV args;
} PACKED_glVertexAttrib2sNV;
typedef struct {
    GLuint index;
    GLshort * v;
} ARGS_glVertexAttrib2sv;
typedef struct {
    int index;
    ARGS_glVertexAttrib2sv args;
} PACKED_glVertexAttrib2sv;
typedef struct {
    GLuint index;
    GLshort * v;
} ARGS_glVertexAttrib2svARB;
typedef struct {
    int index;
    ARGS_glVertexAttrib2svARB args;
} PACKED_glVertexAttrib2svARB;
typedef struct {
    GLuint index;
    GLshort * v;
} ARGS_glVertexAttrib2svNV;
typedef struct {
    int index;
    ARGS_glVertexAttrib2svNV args;
} PACKED_glVertexAttrib2svNV;
typedef struct {
    GLuint index;
    GLdouble x __attribute__ ((aligned(8)));
    GLdouble y __attribute__ ((aligned(8)));
    GLdouble z __attribute__ ((aligned(8)));
} ARGS_glVertexAttrib3d;
typedef struct {
    int index;
    ARGS_glVertexAttrib3d args;
} PACKED_glVertexAttrib3d;
typedef struct {
    GLuint index;
    GLdouble x __attribute__ ((aligned(8)));
    GLdouble y __attribute__ ((aligned(8)));
    GLdouble z __attribute__ ((aligned(8)));
} ARGS_glVertexAttrib3dARB;
typedef struct {
    int index;
    ARGS_glVertexAttrib3dARB args;
} PACKED_glVertexAttrib3dARB;
typedef struct {
    GLuint index;
    GLdouble x __attribute__ ((aligned(8)));
    GLdouble y __attribute__ ((aligned(8)));
    GLdouble z __attribute__ ((aligned(8)));
} ARGS_glVertexAttrib3dNV;
typedef struct {
    int index;
    ARGS_glVertexAttrib3dNV args;
} PACKED_glVertexAttrib3dNV;
typedef struct {
    GLuint index;
    GLdouble * v;
} ARGS_glVertexAttrib3dv;
typedef struct {
    int index;
    ARGS_glVertexAttrib3dv args;
} PACKED_glVertexAttrib3dv;
typedef struct {
    GLuint index;
    GLdouble * v;
} ARGS_glVertexAttrib3dvARB;
typedef struct {
    int index;
    ARGS_glVertexAttrib3dvARB args;
} PACKED_glVertexAttrib3dvARB;
typedef struct {
    GLuint index;
    GLdouble * v;
} ARGS_glVertexAttrib3dvNV;
typedef struct {
    int index;
    ARGS_glVertexAttrib3dvNV args;
} PACKED_glVertexAttrib3dvNV;
typedef struct {
    GLuint index;
    GLfloat x;
    GLfloat y;
    GLfloat z;
} ARGS_glVertexAttrib3f;
typedef struct {
    int index;
    ARGS_glVertexAttrib3f args;
} PACKED_glVertexAttrib3f;
typedef struct {
    GLuint index;
    GLfloat x;
    GLfloat y;
    GLfloat z;
} ARGS_glVertexAttrib3fARB;
typedef struct {
    int index;
    ARGS_glVertexAttrib3fARB args;
} PACKED_glVertexAttrib3fARB;
typedef struct {
    GLuint index;
    GLfloat x;
    GLfloat y;
    GLfloat z;
} ARGS_glVertexAttrib3fNV;
typedef struct {
    int index;
    ARGS_glVertexAttrib3fNV args;
} PACKED_glVertexAttrib3fNV;
typedef struct {
    GLuint index;
    GLfloat * v;
} ARGS_glVertexAttrib3fv;
typedef struct {
    int index;
    ARGS_glVertexAttrib3fv args;
} PACKED_glVertexAttrib3fv;
typedef struct {
    GLuint index;
    GLfloat * v;
} ARGS_glVertexAttrib3fvARB;
typedef struct {
    int index;
    ARGS_glVertexAttrib3fvARB args;
} PACKED_glVertexAttrib3fvARB;
typedef struct {
    GLuint index;
    GLfloat * v;
} ARGS_glVertexAttrib3fvNV;
typedef struct {
    int index;
    ARGS_glVertexAttrib3fvNV args;
} PACKED_glVertexAttrib3fvNV;
typedef struct {
    GLuint index;
    GLhalfNV x;
    GLhalfNV y;
    GLhalfNV z;
} ARGS_glVertexAttrib3hNV;
typedef struct {
    int index;
    ARGS_glVertexAttrib3hNV args;
} PACKED_glVertexAttrib3hNV;
typedef struct {
    GLuint index;
    GLhalfNV * v;
} ARGS_glVertexAttrib3hvNV;
typedef struct {
    int index;
    ARGS_glVertexAttrib3hvNV args;
} PACKED_glVertexAttrib3hvNV;
typedef struct {
    GLuint index;
    GLshort x;
    GLshort y;
    GLshort z;
} ARGS_glVertexAttrib3s;
typedef struct {
    int index;
    ARGS_glVertexAttrib3s args;
} PACKED_glVertexAttrib3s;
typedef struct {
    GLuint index;
    GLshort x;
    GLshort y;
    GLshort z;
} ARGS_glVertexAttrib3sARB;
typedef struct {
    int index;
    ARGS_glVertexAttrib3sARB args;
} PACKED_glVertexAttrib3sARB;
typedef struct {
    GLuint index;
    GLshort x;
    GLshort y;
    GLshort z;
} ARGS_glVertexAttrib3sNV;
typedef struct {
    int index;
    ARGS_glVertexAttrib3sNV args;
} PACKED_glVertexAttrib3sNV;
typedef struct {
    GLuint index;
    GLshort * v;
} ARGS_glVertexAttrib3sv;
typedef struct {
    int index;
    ARGS_glVertexAttrib3sv args;
} PACKED_glVertexAttrib3sv;
typedef struct {
    GLuint index;
    GLshort * v;
} ARGS_glVertexAttrib3svARB;
typedef struct {
    int index;
    ARGS_glVertexAttrib3svARB args;
} PACKED_glVertexAttrib3svARB;
typedef struct {
    GLuint index;
    GLshort * v;
} ARGS_glVertexAttrib3svNV;
typedef struct {
    int index;
    ARGS_glVertexAttrib3svNV args;
} PACKED_glVertexAttrib3svNV;
typedef struct {
    GLuint index;
    GLbyte * v;
} ARGS_glVertexAttrib4Nbv;
typedef struct {
    int index;
    ARGS_glVertexAttrib4Nbv args;
} PACKED_glVertexAttrib4Nbv;
typedef struct {
    GLuint index;
    GLbyte * v;
} ARGS_glVertexAttrib4NbvARB;
typedef struct {
    int index;
    ARGS_glVertexAttrib4NbvARB args;
} PACKED_glVertexAttrib4NbvARB;
typedef struct {
    GLuint index;
    GLint * v;
} ARGS_glVertexAttrib4Niv;
typedef struct {
    int index;
    ARGS_glVertexAttrib4Niv args;
} PACKED_glVertexAttrib4Niv;
typedef struct {
    GLuint index;
    GLint * v;
} ARGS_glVertexAttrib4NivARB;
typedef struct {
    int index;
    ARGS_glVertexAttrib4NivARB args;
} PACKED_glVertexAttrib4NivARB;
typedef struct {
    GLuint index;
    GLshort * v;
} ARGS_glVertexAttrib4Nsv;
typedef struct {
    int index;
    ARGS_glVertexAttrib4Nsv args;
} PACKED_glVertexAttrib4Nsv;
typedef struct {
    GLuint index;
    GLshort * v;
} ARGS_glVertexAttrib4NsvARB;
typedef struct {
    int index;
    ARGS_glVertexAttrib4NsvARB args;
} PACKED_glVertexAttrib4NsvARB;
typedef struct {
    GLuint index;
    GLubyte x;
    GLubyte y;
    GLubyte z;
    GLubyte w;
} ARGS_glVertexAttrib4Nub;
typedef struct {
    int index;
    ARGS_glVertexAttrib4Nub args;
} PACKED_glVertexAttrib4Nub;
typedef struct {
    GLuint index;
    GLubyte x;
    GLubyte y;
    GLubyte z;
    GLubyte w;
} ARGS_glVertexAttrib4NubARB;
typedef struct {
    int index;
    ARGS_glVertexAttrib4NubARB args;
} PACKED_glVertexAttrib4NubARB;
typedef struct {
    GLuint index;
    GLubyte * v;
} ARGS_glVertexAttrib4Nubv;
typedef struct {
    int index;
    ARGS_glVertexAttrib4Nubv args;
} PACKED_glVertexAttrib4Nubv;
typedef struct {
    GLuint index;
    GLubyte * v;
} ARGS_glVertexAttrib4NubvARB;
typedef struct {
    int index;
    ARGS_glVertexAttrib4NubvARB args;
} PACKED_glVertexAttrib4NubvARB;
typedef struct {
    GLuint index;
    GLuint * v;
} ARGS_glVertexAttrib4Nuiv;
typedef struct {
    int index;
    ARGS_glVertexAttrib4Nuiv args;
} PACKED_glVertexAttrib4Nuiv;
typedef struct {
    GLuint index;
    GLuint * v;
} ARGS_glVertexAttrib4NuivARB;
typedef struct {
    int index;
    ARGS_glVertexAttrib4NuivARB args;
} PACKED_glVertexAttrib4NuivARB;
typedef struct {
    GLuint index;
    GLushort * v;
} ARGS_glVertexAttrib4Nusv;
typedef struct {
    int index;
    ARGS_glVertexAttrib4Nusv args;
} PACKED_glVertexAttrib4Nusv;
typedef struct {
    GLuint index;
    GLushort * v;
} ARGS_glVertexAttrib4NusvARB;
typedef struct {
    int index;
    ARGS_glVertexAttrib4NusvARB args;
} PACKED_glVertexAttrib4NusvARB;
typedef struct {
    GLuint index;
    GLbyte * v;
} ARGS_glVertexAttrib4bv;
typedef struct {
    int index;
    ARGS_glVertexAttrib4bv args;
} PACKED_glVertexAttrib4bv;
typedef struct {
    GLuint index;
    GLbyte * v;
} ARGS_glVertexAttrib4bvARB;
typedef struct {
    int index;
    ARGS_glVertexAttrib4bvARB args;
} PACKED_glVertexAttrib4bvARB;
typedef struct {
    GLuint index;
    GLdouble x __attribute__ ((aligned(8)));
    GLdouble y __attribute__ ((aligned(8)));
    GLdouble z __attribute__ ((aligned(8)));
    GLdouble w __attribute__ ((aligned(8)));
} ARGS_glVertexAttrib4d;
typedef struct {
    int index;
    ARGS_glVertexAttrib4d args;
} PACKED_glVertexAttrib4d;
typedef struct {
    GLuint index;
    GLdouble x __attribute__ ((aligned(8)));
    GLdouble y __attribute__ ((aligned(8)));
    GLdouble z __attribute__ ((aligned(8)));
    GLdouble w __attribute__ ((aligned(8)));
} ARGS_glVertexAttrib4dARB;
typedef struct {
    int index;
    ARGS_glVertexAttrib4dARB args;
} PACKED_glVertexAttrib4dARB;
typedef struct {
    GLuint index;
    GLdouble x __attribute__ ((aligned(8)));
    GLdouble y __attribute__ ((aligned(8)));
    GLdouble z __attribute__ ((aligned(8)));
    GLdouble w __attribute__ ((aligned(8)));
} ARGS_glVertexAttrib4dNV;
typedef struct {
    int index;
    ARGS_glVertexAttrib4dNV args;
} PACKED_glVertexAttrib4dNV;
typedef struct {
    GLuint index;
    GLdouble * v;
} ARGS_glVertexAttrib4dv;
typedef struct {
    int index;
    ARGS_glVertexAttrib4dv args;
} PACKED_glVertexAttrib4dv;
typedef struct {
    GLuint index;
    GLdouble * v;
} ARGS_glVertexAttrib4dvARB;
typedef struct {
    int index;
    ARGS_glVertexAttrib4dvARB args;
} PACKED_glVertexAttrib4dvARB;
typedef struct {
    GLuint index;
    GLdouble * v;
} ARGS_glVertexAttrib4dvNV;
typedef struct {
    int index;
    ARGS_glVertexAttrib4dvNV args;
} PACKED_glVertexAttrib4dvNV;
typedef struct {
    GLuint index;
    GLfloat x;
    GLfloat y;
    GLfloat z;
    GLfloat w;
} ARGS_glVertexAttrib4f;
typedef struct {
    int index;
    ARGS_glVertexAttrib4f args;
} PACKED_glVertexAttrib4f;
typedef struct {
    GLuint index;
    GLfloat x;
    GLfloat y;
    GLfloat z;
    GLfloat w;
} ARGS_glVertexAttrib4fARB;
typedef struct {
    int index;
    ARGS_glVertexAttrib4fARB args;
} PACKED_glVertexAttrib4fARB;
typedef struct {
    GLuint index;
    GLfloat x;
    GLfloat y;
    GLfloat z;
    GLfloat w;
} ARGS_glVertexAttrib4fNV;
typedef struct {
    int index;
    ARGS_glVertexAttrib4fNV args;
} PACKED_glVertexAttrib4fNV;
typedef struct {
    GLuint index;
    GLfloat * v;
} ARGS_glVertexAttrib4fv;
typedef struct {
    int index;
    ARGS_glVertexAttrib4fv args;
} PACKED_glVertexAttrib4fv;
typedef struct {
    GLuint index;
    GLfloat * v;
} ARGS_glVertexAttrib4fvARB;
typedef struct {
    int index;
    ARGS_glVertexAttrib4fvARB args;
} PACKED_glVertexAttrib4fvARB;
typedef struct {
    GLuint index;
    GLfloat * v;
} ARGS_glVertexAttrib4fvNV;
typedef struct {
    int index;
    ARGS_glVertexAttrib4fvNV args;
} PACKED_glVertexAttrib4fvNV;
typedef struct {
    GLuint index;
    GLhalfNV x;
    GLhalfNV y;
    GLhalfNV z;
    GLhalfNV w;
} ARGS_glVertexAttrib4hNV;
typedef struct {
    int index;
    ARGS_glVertexAttrib4hNV args;
} PACKED_glVertexAttrib4hNV;
typedef struct {
    GLuint index;
    GLhalfNV * v;
} ARGS_glVertexAttrib4hvNV;
typedef struct {
    int index;
    ARGS_glVertexAttrib4hvNV args;
} PACKED_glVertexAttrib4hvNV;
typedef struct {
    GLuint index;
    GLint * v;
} ARGS_glVertexAttrib4iv;
typedef struct {
    int index;
    ARGS_glVertexAttrib4iv args;
} PACKED_glVertexAttrib4iv;
typedef struct {
    GLuint index;
    GLint * v;
} ARGS_glVertexAttrib4ivARB;
typedef struct {
    int index;
    ARGS_glVertexAttrib4ivARB args;
} PACKED_glVertexAttrib4ivARB;
typedef struct {
    GLuint index;
    GLshort x;
    GLshort y;
    GLshort z;
    GLshort w;
} ARGS_glVertexAttrib4s;
typedef struct {
    int index;
    ARGS_glVertexAttrib4s args;
} PACKED_glVertexAttrib4s;
typedef struct {
    GLuint index;
    GLshort x;
    GLshort y;
    GLshort z;
    GLshort w;
} ARGS_glVertexAttrib4sARB;
typedef struct {
    int index;
    ARGS_glVertexAttrib4sARB args;
} PACKED_glVertexAttrib4sARB;
typedef struct {
    GLuint index;
    GLshort x;
    GLshort y;
    GLshort z;
    GLshort w;
} ARGS_glVertexAttrib4sNV;
typedef struct {
    int index;
    ARGS_glVertexAttrib4sNV args;
} PACKED_glVertexAttrib4sNV;
typedef struct {
    GLuint index;
    GLshort * v;
} ARGS_glVertexAttrib4sv;
typedef struct {
    int index;
    ARGS_glVertexAttrib4sv args;
} PACKED_glVertexAttrib4sv;
typedef struct {
    GLuint index;
    GLshort * v;
} ARGS_glVertexAttrib4svARB;
typedef struct {
    int index;
    ARGS_glVertexAttrib4svARB args;
} PACKED_glVertexAttrib4svARB;
typedef struct {
    GLuint index;
    GLshort * v;
} ARGS_glVertexAttrib4svNV;
typedef struct {
    int index;
    ARGS_glVertexAttrib4svNV args;
} PACKED_glVertexAttrib4svNV;
typedef struct {
    GLuint index;
    GLubyte x;
    GLubyte y;
    GLubyte z;
    GLubyte w;
} ARGS_glVertexAttrib4ubNV;
typedef struct {
    int index;
    ARGS_glVertexAttrib4ubNV args;
} PACKED_glVertexAttrib4ubNV;
typedef struct {
    GLuint index;
    GLubyte * v;
} ARGS_glVertexAttrib4ubv;
typedef struct {
    int index;
    ARGS_glVertexAttrib4ubv args;
} PACKED_glVertexAttrib4ubv;
typedef struct {
    GLuint index;
    GLubyte * v;
} ARGS_glVertexAttrib4ubvARB;
typedef struct {
    int index;
    ARGS_glVertexAttrib4ubvARB args;
} PACKED_glVertexAttrib4ubvARB;
typedef struct {
    GLuint index;
    GLubyte * v;
} ARGS_glVertexAttrib4ubvNV;
typedef struct {
    int index;
    ARGS_glVertexAttrib4ubvNV args;
} PACKED_glVertexAttrib4ubvNV;
typedef struct {
    GLuint index;
    GLuint * v;
} ARGS_glVertexAttrib4uiv;
typedef struct {
    int index;
    ARGS_glVertexAttrib4uiv args;
} PACKED_glVertexAttrib4uiv;
typedef struct {
    GLuint index;
    GLuint * v;
} ARGS_glVertexAttrib4uivARB;
typedef struct {
    int index;
    ARGS_glVertexAttrib4uivARB args;
} PACKED_glVertexAttrib4uivARB;
typedef struct {
    GLuint index;
    GLushort * v;
} ARGS_glVertexAttrib4usv;
typedef struct {
    int index;
    ARGS_glVertexAttrib4usv args;
} PACKED_glVertexAttrib4usv;
typedef struct {
    GLuint index;
    GLushort * v;
} ARGS_glVertexAttrib4usvARB;
typedef struct {
    int index;
    ARGS_glVertexAttrib4usvARB args;
} PACKED_glVertexAttrib4usvARB;
typedef struct {
    GLuint index;
    GLint size;
    GLenum type;
    GLboolean normalized;
    GLsizei stride;
    GLuint buffer;
    GLuint offset;
} ARGS_glVertexAttribArrayObjectATI;
typedef struct {
    int index;
    ARGS_glVertexAttribArrayObjectATI args;
} PACKED_glVertexAttribArrayObjectATI;
typedef struct {
    GLuint attribindex;
    GLuint bindingindex;
} ARGS_glVertexAttribBinding;
typedef struct {
    int index;
    ARGS_glVertexAttribBinding args;
} PACKED_glVertexAttribBinding;
typedef struct {
    GLuint index;
    GLuint divisor;
} ARGS_glVertexAttribDivisor;
typedef struct {
    int index;
    ARGS_glVertexAttribDivisor args;
} PACKED_glVertexAttribDivisor;
typedef struct {
    GLuint index;
    GLuint divisor;
} ARGS_glVertexAttribDivisorARB;
typedef struct {
    int index;
    ARGS_glVertexAttribDivisorARB args;
} PACKED_glVertexAttribDivisorARB;
typedef struct {
    GLuint attribindex;
    GLint size;
    GLenum type;
    GLboolean normalized;
    GLuint relativeoffset;
} ARGS_glVertexAttribFormat;
typedef struct {
    int index;
    ARGS_glVertexAttribFormat args;
} PACKED_glVertexAttribFormat;
typedef struct {
    GLuint index;
    GLint size;
    GLenum type;
    GLboolean normalized;
    GLsizei stride;
} ARGS_glVertexAttribFormatNV;
typedef struct {
    int index;
    ARGS_glVertexAttribFormatNV args;
} PACKED_glVertexAttribFormatNV;
typedef struct {
    GLuint index;
    GLint x;
} ARGS_glVertexAttribI1i;
typedef struct {
    int index;
    ARGS_glVertexAttribI1i args;
} PACKED_glVertexAttribI1i;
typedef struct {
    GLuint index;
    GLint x;
} ARGS_glVertexAttribI1iEXT;
typedef struct {
    int index;
    ARGS_glVertexAttribI1iEXT args;
} PACKED_glVertexAttribI1iEXT;
typedef struct {
    GLuint index;
    GLint * v;
} ARGS_glVertexAttribI1iv;
typedef struct {
    int index;
    ARGS_glVertexAttribI1iv args;
} PACKED_glVertexAttribI1iv;
typedef struct {
    GLuint index;
    GLint * v;
} ARGS_glVertexAttribI1ivEXT;
typedef struct {
    int index;
    ARGS_glVertexAttribI1ivEXT args;
} PACKED_glVertexAttribI1ivEXT;
typedef struct {
    GLuint index;
    GLuint x;
} ARGS_glVertexAttribI1ui;
typedef struct {
    int index;
    ARGS_glVertexAttribI1ui args;
} PACKED_glVertexAttribI1ui;
typedef struct {
    GLuint index;
    GLuint x;
} ARGS_glVertexAttribI1uiEXT;
typedef struct {
    int index;
    ARGS_glVertexAttribI1uiEXT args;
} PACKED_glVertexAttribI1uiEXT;
typedef struct {
    GLuint index;
    GLuint * v;
} ARGS_glVertexAttribI1uiv;
typedef struct {
    int index;
    ARGS_glVertexAttribI1uiv args;
} PACKED_glVertexAttribI1uiv;
typedef struct {
    GLuint index;
    GLuint * v;
} ARGS_glVertexAttribI1uivEXT;
typedef struct {
    int index;
    ARGS_glVertexAttribI1uivEXT args;
} PACKED_glVertexAttribI1uivEXT;
typedef struct {
    GLuint index;
    GLint x;
    GLint y;
} ARGS_glVertexAttribI2i;
typedef struct {
    int index;
    ARGS_glVertexAttribI2i args;
} PACKED_glVertexAttribI2i;
typedef struct {
    GLuint index;
    GLint x;
    GLint y;
} ARGS_glVertexAttribI2iEXT;
typedef struct {
    int index;
    ARGS_glVertexAttribI2iEXT args;
} PACKED_glVertexAttribI2iEXT;
typedef struct {
    GLuint index;
    GLint * v;
} ARGS_glVertexAttribI2iv;
typedef struct {
    int index;
    ARGS_glVertexAttribI2iv args;
} PACKED_glVertexAttribI2iv;
typedef struct {
    GLuint index;
    GLint * v;
} ARGS_glVertexAttribI2ivEXT;
typedef struct {
    int index;
    ARGS_glVertexAttribI2ivEXT args;
} PACKED_glVertexAttribI2ivEXT;
typedef struct {
    GLuint index;
    GLuint x;
    GLuint y;
} ARGS_glVertexAttribI2ui;
typedef struct {
    int index;
    ARGS_glVertexAttribI2ui args;
} PACKED_glVertexAttribI2ui;
typedef struct {
    GLuint index;
    GLuint x;
    GLuint y;
} ARGS_glVertexAttribI2uiEXT;
typedef struct {
    int index;
    ARGS_glVertexAttribI2uiEXT args;
} PACKED_glVertexAttribI2uiEXT;
typedef struct {
    GLuint index;
    GLuint * v;
} ARGS_glVertexAttribI2uiv;
typedef struct {
    int index;
    ARGS_glVertexAttribI2uiv args;
} PACKED_glVertexAttribI2uiv;
typedef struct {
    GLuint index;
    GLuint * v;
} ARGS_glVertexAttribI2uivEXT;
typedef struct {
    int index;
    ARGS_glVertexAttribI2uivEXT args;
} PACKED_glVertexAttribI2uivEXT;
typedef struct {
    GLuint index;
    GLint x;
    GLint y;
    GLint z;
} ARGS_glVertexAttribI3i;
typedef struct {
    int index;
    ARGS_glVertexAttribI3i args;
} PACKED_glVertexAttribI3i;
typedef struct {
    GLuint index;
    GLint x;
    GLint y;
    GLint z;
} ARGS_glVertexAttribI3iEXT;
typedef struct {
    int index;
    ARGS_glVertexAttribI3iEXT args;
} PACKED_glVertexAttribI3iEXT;
typedef struct {
    GLuint index;
    GLint * v;
} ARGS_glVertexAttribI3iv;
typedef struct {
    int index;
    ARGS_glVertexAttribI3iv args;
} PACKED_glVertexAttribI3iv;
typedef struct {
    GLuint index;
    GLint * v;
} ARGS_glVertexAttribI3ivEXT;
typedef struct {
    int index;
    ARGS_glVertexAttribI3ivEXT args;
} PACKED_glVertexAttribI3ivEXT;
typedef struct {
    GLuint index;
    GLuint x;
    GLuint y;
    GLuint z;
} ARGS_glVertexAttribI3ui;
typedef struct {
    int index;
    ARGS_glVertexAttribI3ui args;
} PACKED_glVertexAttribI3ui;
typedef struct {
    GLuint index;
    GLuint x;
    GLuint y;
    GLuint z;
} ARGS_glVertexAttribI3uiEXT;
typedef struct {
    int index;
    ARGS_glVertexAttribI3uiEXT args;
} PACKED_glVertexAttribI3uiEXT;
typedef struct {
    GLuint index;
    GLuint * v;
} ARGS_glVertexAttribI3uiv;
typedef struct {
    int index;
    ARGS_glVertexAttribI3uiv args;
} PACKED_glVertexAttribI3uiv;
typedef struct {
    GLuint index;
    GLuint * v;
} ARGS_glVertexAttribI3uivEXT;
typedef struct {
    int index;
    ARGS_glVertexAttribI3uivEXT args;
} PACKED_glVertexAttribI3uivEXT;
typedef struct {
    GLuint index;
    GLbyte * v;
} ARGS_glVertexAttribI4bv;
typedef struct {
    int index;
    ARGS_glVertexAttribI4bv args;
} PACKED_glVertexAttribI4bv;
typedef struct {
    GLuint index;
    GLbyte * v;
} ARGS_glVertexAttribI4bvEXT;
typedef struct {
    int index;
    ARGS_glVertexAttribI4bvEXT args;
} PACKED_glVertexAttribI4bvEXT;
typedef struct {
    GLuint index;
    GLint x;
    GLint y;
    GLint z;
    GLint w;
} ARGS_glVertexAttribI4i;
typedef struct {
    int index;
    ARGS_glVertexAttribI4i args;
} PACKED_glVertexAttribI4i;
typedef struct {
    GLuint index;
    GLint x;
    GLint y;
    GLint z;
    GLint w;
} ARGS_glVertexAttribI4iEXT;
typedef struct {
    int index;
    ARGS_glVertexAttribI4iEXT args;
} PACKED_glVertexAttribI4iEXT;
typedef struct {
    GLuint index;
    GLint * v;
} ARGS_glVertexAttribI4iv;
typedef struct {
    int index;
    ARGS_glVertexAttribI4iv args;
} PACKED_glVertexAttribI4iv;
typedef struct {
    GLuint index;
    GLint * v;
} ARGS_glVertexAttribI4ivEXT;
typedef struct {
    int index;
    ARGS_glVertexAttribI4ivEXT args;
} PACKED_glVertexAttribI4ivEXT;
typedef struct {
    GLuint index;
    GLshort * v;
} ARGS_glVertexAttribI4sv;
typedef struct {
    int index;
    ARGS_glVertexAttribI4sv args;
} PACKED_glVertexAttribI4sv;
typedef struct {
    GLuint index;
    GLshort * v;
} ARGS_glVertexAttribI4svEXT;
typedef struct {
    int index;
    ARGS_glVertexAttribI4svEXT args;
} PACKED_glVertexAttribI4svEXT;
typedef struct {
    GLuint index;
    GLubyte * v;
} ARGS_glVertexAttribI4ubv;
typedef struct {
    int index;
    ARGS_glVertexAttribI4ubv args;
} PACKED_glVertexAttribI4ubv;
typedef struct {
    GLuint index;
    GLubyte * v;
} ARGS_glVertexAttribI4ubvEXT;
typedef struct {
    int index;
    ARGS_glVertexAttribI4ubvEXT args;
} PACKED_glVertexAttribI4ubvEXT;
typedef struct {
    GLuint index;
    GLuint x;
    GLuint y;
    GLuint z;
    GLuint w;
} ARGS_glVertexAttribI4ui;
typedef struct {
    int index;
    ARGS_glVertexAttribI4ui args;
} PACKED_glVertexAttribI4ui;
typedef struct {
    GLuint index;
    GLuint x;
    GLuint y;
    GLuint z;
    GLuint w;
} ARGS_glVertexAttribI4uiEXT;
typedef struct {
    int index;
    ARGS_glVertexAttribI4uiEXT args;
} PACKED_glVertexAttribI4uiEXT;
typedef struct {
    GLuint index;
    GLuint * v;
} ARGS_glVertexAttribI4uiv;
typedef struct {
    int index;
    ARGS_glVertexAttribI4uiv args;
} PACKED_glVertexAttribI4uiv;
typedef struct {
    GLuint index;
    GLuint * v;
} ARGS_glVertexAttribI4uivEXT;
typedef struct {
    int index;
    ARGS_glVertexAttribI4uivEXT args;
} PACKED_glVertexAttribI4uivEXT;
typedef struct {
    GLuint index;
    GLushort * v;
} ARGS_glVertexAttribI4usv;
typedef struct {
    int index;
    ARGS_glVertexAttribI4usv args;
} PACKED_glVertexAttribI4usv;
typedef struct {
    GLuint index;
    GLushort * v;
} ARGS_glVertexAttribI4usvEXT;
typedef struct {
    int index;
    ARGS_glVertexAttribI4usvEXT args;
} PACKED_glVertexAttribI4usvEXT;
typedef struct {
    GLuint attribindex;
    GLint size;
    GLenum type;
    GLuint relativeoffset;
} ARGS_glVertexAttribIFormat;
typedef struct {
    int index;
    ARGS_glVertexAttribIFormat args;
} PACKED_glVertexAttribIFormat;
typedef struct {
    GLuint index;
    GLint size;
    GLenum type;
    GLsizei stride;
} ARGS_glVertexAttribIFormatNV;
typedef struct {
    int index;
    ARGS_glVertexAttribIFormatNV args;
} PACKED_glVertexAttribIFormatNV;
typedef struct {
    GLuint index;
    GLint size;
    GLenum type;
    GLsizei stride;
    GLvoid * pointer;
} ARGS_glVertexAttribIPointer;
typedef struct {
    int index;
    ARGS_glVertexAttribIPointer args;
} PACKED_glVertexAttribIPointer;
typedef struct {
    GLuint index;
    GLint size;
    GLenum type;
    GLsizei stride;
    GLvoid * pointer;
} ARGS_glVertexAttribIPointerEXT;
typedef struct {
    int index;
    ARGS_glVertexAttribIPointerEXT args;
} PACKED_glVertexAttribIPointerEXT;
typedef struct {
    GLuint index;
    GLdouble x __attribute__ ((aligned(8)));
} ARGS_glVertexAttribL1d;
typedef struct {
    int index;
    ARGS_glVertexAttribL1d args;
} PACKED_glVertexAttribL1d;
typedef struct {
    GLuint index;
    GLdouble x __attribute__ ((aligned(8)));
} ARGS_glVertexAttribL1dEXT;
typedef struct {
    int index;
    ARGS_glVertexAttribL1dEXT args;
} PACKED_glVertexAttribL1dEXT;
typedef struct {
    GLuint index;
    GLdouble * v;
} ARGS_glVertexAttribL1dv;
typedef struct {
    int index;
    ARGS_glVertexAttribL1dv args;
} PACKED_glVertexAttribL1dv;
typedef struct {
    GLuint index;
    GLdouble * v;
} ARGS_glVertexAttribL1dvEXT;
typedef struct {
    int index;
    ARGS_glVertexAttribL1dvEXT args;
} PACKED_glVertexAttribL1dvEXT;
typedef struct {
    GLuint index;
    GLint64EXT x;
} ARGS_glVertexAttribL1i64NV;
typedef struct {
    int index;
    ARGS_glVertexAttribL1i64NV args;
} PACKED_glVertexAttribL1i64NV;
typedef struct {
    GLuint index;
    GLint64EXT * v;
} ARGS_glVertexAttribL1i64vNV;
typedef struct {
    int index;
    ARGS_glVertexAttribL1i64vNV args;
} PACKED_glVertexAttribL1i64vNV;
typedef struct {
    GLuint index;
    GLuint64EXT x;
} ARGS_glVertexAttribL1ui64NV;
typedef struct {
    int index;
    ARGS_glVertexAttribL1ui64NV args;
} PACKED_glVertexAttribL1ui64NV;
typedef struct {
    GLuint index;
    GLuint64EXT * v;
} ARGS_glVertexAttribL1ui64vNV;
typedef struct {
    int index;
    ARGS_glVertexAttribL1ui64vNV args;
} PACKED_glVertexAttribL1ui64vNV;
typedef struct {
    GLuint index;
    GLdouble x __attribute__ ((aligned(8)));
    GLdouble y __attribute__ ((aligned(8)));
} ARGS_glVertexAttribL2d;
typedef struct {
    int index;
    ARGS_glVertexAttribL2d args;
} PACKED_glVertexAttribL2d;
typedef struct {
    GLuint index;
    GLdouble x __attribute__ ((aligned(8)));
    GLdouble y __attribute__ ((aligned(8)));
} ARGS_glVertexAttribL2dEXT;
typedef struct {
    int index;
    ARGS_glVertexAttribL2dEXT args;
} PACKED_glVertexAttribL2dEXT;
typedef struct {
    GLuint index;
    GLdouble * v;
} ARGS_glVertexAttribL2dv;
typedef struct {
    int index;
    ARGS_glVertexAttribL2dv args;
} PACKED_glVertexAttribL2dv;
typedef struct {
    GLuint index;
    GLdouble * v;
} ARGS_glVertexAttribL2dvEXT;
typedef struct {
    int index;
    ARGS_glVertexAttribL2dvEXT args;
} PACKED_glVertexAttribL2dvEXT;
typedef struct {
    GLuint index;
    GLint64EXT x;
    GLint64EXT y;
} ARGS_glVertexAttribL2i64NV;
typedef struct {
    int index;
    ARGS_glVertexAttribL2i64NV args;
} PACKED_glVertexAttribL2i64NV;
typedef struct {
    GLuint index;
    GLint64EXT * v;
} ARGS_glVertexAttribL2i64vNV;
typedef struct {
    int index;
    ARGS_glVertexAttribL2i64vNV args;
} PACKED_glVertexAttribL2i64vNV;
typedef struct {
    GLuint index;
    GLuint64EXT x;
    GLuint64EXT y;
} ARGS_glVertexAttribL2ui64NV;
typedef struct {
    int index;
    ARGS_glVertexAttribL2ui64NV args;
} PACKED_glVertexAttribL2ui64NV;
typedef struct {
    GLuint index;
    GLuint64EXT * v;
} ARGS_glVertexAttribL2ui64vNV;
typedef struct {
    int index;
    ARGS_glVertexAttribL2ui64vNV args;
} PACKED_glVertexAttribL2ui64vNV;
typedef struct {
    GLuint index;
    GLdouble x __attribute__ ((aligned(8)));
    GLdouble y __attribute__ ((aligned(8)));
    GLdouble z __attribute__ ((aligned(8)));
} ARGS_glVertexAttribL3d;
typedef struct {
    int index;
    ARGS_glVertexAttribL3d args;
} PACKED_glVertexAttribL3d;
typedef struct {
    GLuint index;
    GLdouble x __attribute__ ((aligned(8)));
    GLdouble y __attribute__ ((aligned(8)));
    GLdouble z __attribute__ ((aligned(8)));
} ARGS_glVertexAttribL3dEXT;
typedef struct {
    int index;
    ARGS_glVertexAttribL3dEXT args;
} PACKED_glVertexAttribL3dEXT;
typedef struct {
    GLuint index;
    GLdouble * v;
} ARGS_glVertexAttribL3dv;
typedef struct {
    int index;
    ARGS_glVertexAttribL3dv args;
} PACKED_glVertexAttribL3dv;
typedef struct {
    GLuint index;
    GLdouble * v;
} ARGS_glVertexAttribL3dvEXT;
typedef struct {
    int index;
    ARGS_glVertexAttribL3dvEXT args;
} PACKED_glVertexAttribL3dvEXT;
typedef struct {
    GLuint index;
    GLint64EXT x;
    GLint64EXT y;
    GLint64EXT z;
} ARGS_glVertexAttribL3i64NV;
typedef struct {
    int index;
    ARGS_glVertexAttribL3i64NV args;
} PACKED_glVertexAttribL3i64NV;
typedef struct {
    GLuint index;
    GLint64EXT * v;
} ARGS_glVertexAttribL3i64vNV;
typedef struct {
    int index;
    ARGS_glVertexAttribL3i64vNV args;
} PACKED_glVertexAttribL3i64vNV;
typedef struct {
    GLuint index;
    GLuint64EXT x;
    GLuint64EXT y;
    GLuint64EXT z;
} ARGS_glVertexAttribL3ui64NV;
typedef struct {
    int index;
    ARGS_glVertexAttribL3ui64NV args;
} PACKED_glVertexAttribL3ui64NV;
typedef struct {
    GLuint index;
    GLuint64EXT * v;
} ARGS_glVertexAttribL3ui64vNV;
typedef struct {
    int index;
    ARGS_glVertexAttribL3ui64vNV args;
} PACKED_glVertexAttribL3ui64vNV;
typedef struct {
    GLuint index;
    GLdouble x __attribute__ ((aligned(8)));
    GLdouble y __attribute__ ((aligned(8)));
    GLdouble z __attribute__ ((aligned(8)));
    GLdouble w __attribute__ ((aligned(8)));
} ARGS_glVertexAttribL4d;
typedef struct {
    int index;
    ARGS_glVertexAttribL4d args;
} PACKED_glVertexAttribL4d;
typedef struct {
    GLuint index;
    GLdouble x __attribute__ ((aligned(8)));
    GLdouble y __attribute__ ((aligned(8)));
    GLdouble z __attribute__ ((aligned(8)));
    GLdouble w __attribute__ ((aligned(8)));
} ARGS_glVertexAttribL4dEXT;
typedef struct {
    int index;
    ARGS_glVertexAttribL4dEXT args;
} PACKED_glVertexAttribL4dEXT;
typedef struct {
    GLuint index;
    GLdouble * v;
} ARGS_glVertexAttribL4dv;
typedef struct {
    int index;
    ARGS_glVertexAttribL4dv args;
} PACKED_glVertexAttribL4dv;
typedef struct {
    GLuint index;
    GLdouble * v;
} ARGS_glVertexAttribL4dvEXT;
typedef struct {
    int index;
    ARGS_glVertexAttribL4dvEXT args;
} PACKED_glVertexAttribL4dvEXT;
typedef struct {
    GLuint index;
    GLint64EXT x;
    GLint64EXT y;
    GLint64EXT z;
    GLint64EXT w;
} ARGS_glVertexAttribL4i64NV;
typedef struct {
    int index;
    ARGS_glVertexAttribL4i64NV args;
} PACKED_glVertexAttribL4i64NV;
typedef struct {
    GLuint index;
    GLint64EXT * v;
} ARGS_glVertexAttribL4i64vNV;
typedef struct {
    int index;
    ARGS_glVertexAttribL4i64vNV args;
} PACKED_glVertexAttribL4i64vNV;
typedef struct {
    GLuint index;
    GLuint64EXT x;
    GLuint64EXT y;
    GLuint64EXT z;
    GLuint64EXT w;
} ARGS_glVertexAttribL4ui64NV;
typedef struct {
    int index;
    ARGS_glVertexAttribL4ui64NV args;
} PACKED_glVertexAttribL4ui64NV;
typedef struct {
    GLuint index;
    GLuint64EXT * v;
} ARGS_glVertexAttribL4ui64vNV;
typedef struct {
    int index;
    ARGS_glVertexAttribL4ui64vNV args;
} PACKED_glVertexAttribL4ui64vNV;
typedef struct {
    GLuint attribindex;
    GLint size;
    GLenum type;
    GLuint relativeoffset;
} ARGS_glVertexAttribLFormat;
typedef struct {
    int index;
    ARGS_glVertexAttribLFormat args;
} PACKED_glVertexAttribLFormat;
typedef struct {
    GLuint index;
    GLint size;
    GLenum type;
    GLsizei stride;
} ARGS_glVertexAttribLFormatNV;
typedef struct {
    int index;
    ARGS_glVertexAttribLFormatNV args;
} PACKED_glVertexAttribLFormatNV;
typedef struct {
    GLuint index;
    GLint size;
    GLenum type;
    GLsizei stride;
    GLvoid * pointer;
} ARGS_glVertexAttribLPointer;
typedef struct {
    int index;
    ARGS_glVertexAttribLPointer args;
} PACKED_glVertexAttribLPointer;
typedef struct {
    GLuint index;
    GLint size;
    GLenum type;
    GLsizei stride;
    GLvoid * pointer;
} ARGS_glVertexAttribLPointerEXT;
typedef struct {
    int index;
    ARGS_glVertexAttribLPointerEXT args;
} PACKED_glVertexAttribLPointerEXT;
typedef struct {
    GLuint index;
    GLenum type;
    GLboolean normalized;
    GLuint value;
} ARGS_glVertexAttribP1ui;
typedef struct {
    int index;
    ARGS_glVertexAttribP1ui args;
} PACKED_glVertexAttribP1ui;
typedef struct {
    GLuint index;
    GLenum type;
    GLboolean normalized;
    GLuint * value;
} ARGS_glVertexAttribP1uiv;
typedef struct {
    int index;
    ARGS_glVertexAttribP1uiv args;
} PACKED_glVertexAttribP1uiv;
typedef struct {
    GLuint index;
    GLenum type;
    GLboolean normalized;
    GLuint value;
} ARGS_glVertexAttribP2ui;
typedef struct {
    int index;
    ARGS_glVertexAttribP2ui args;
} PACKED_glVertexAttribP2ui;
typedef struct {
    GLuint index;
    GLenum type;
    GLboolean normalized;
    GLuint * value;
} ARGS_glVertexAttribP2uiv;
typedef struct {
    int index;
    ARGS_glVertexAttribP2uiv args;
} PACKED_glVertexAttribP2uiv;
typedef struct {
    GLuint index;
    GLenum type;
    GLboolean normalized;
    GLuint value;
} ARGS_glVertexAttribP3ui;
typedef struct {
    int index;
    ARGS_glVertexAttribP3ui args;
} PACKED_glVertexAttribP3ui;
typedef struct {
    GLuint index;
    GLenum type;
    GLboolean normalized;
    GLuint * value;
} ARGS_glVertexAttribP3uiv;
typedef struct {
    int index;
    ARGS_glVertexAttribP3uiv args;
} PACKED_glVertexAttribP3uiv;
typedef struct {
    GLuint index;
    GLenum type;
    GLboolean normalized;
    GLuint value;
} ARGS_glVertexAttribP4ui;
typedef struct {
    int index;
    ARGS_glVertexAttribP4ui args;
} PACKED_glVertexAttribP4ui;
typedef struct {
    GLuint index;
    GLenum type;
    GLboolean normalized;
    GLuint * value;
} ARGS_glVertexAttribP4uiv;
typedef struct {
    int index;
    ARGS_glVertexAttribP4uiv args;
} PACKED_glVertexAttribP4uiv;
typedef struct {
    GLuint index;
    GLint size;
    GLenum type;
    GLboolean normalized;
    GLsizei stride;
    GLvoid * pointer;
} ARGS_glVertexAttribPointer;
typedef struct {
    int index;
    ARGS_glVertexAttribPointer args;
} PACKED_glVertexAttribPointer;
typedef struct {
    GLuint index;
    GLint size;
    GLenum type;
    GLboolean normalized;
    GLsizei stride;
    GLvoid * pointer;
} ARGS_glVertexAttribPointerARB;
typedef struct {
    int index;
    ARGS_glVertexAttribPointerARB args;
} PACKED_glVertexAttribPointerARB;
typedef struct {
    GLuint index;
    GLint fsize;
    GLenum type;
    GLsizei stride;
    GLvoid * pointer;
} ARGS_glVertexAttribPointerNV;
typedef struct {
    int index;
    ARGS_glVertexAttribPointerNV args;
} PACKED_glVertexAttribPointerNV;
typedef struct {
    GLuint index;
    GLsizei count;
    GLdouble * v;
} ARGS_glVertexAttribs1dvNV;
typedef struct {
    int index;
    ARGS_glVertexAttribs1dvNV args;
} PACKED_glVertexAttribs1dvNV;
typedef struct {
    GLuint index;
    GLsizei count;
    GLfloat * v;
} ARGS_glVertexAttribs1fvNV;
typedef struct {
    int index;
    ARGS_glVertexAttribs1fvNV args;
} PACKED_glVertexAttribs1fvNV;
typedef struct {
    GLuint index;
    GLsizei n;
    GLhalfNV * v;
} ARGS_glVertexAttribs1hvNV;
typedef struct {
    int index;
    ARGS_glVertexAttribs1hvNV args;
} PACKED_glVertexAttribs1hvNV;
typedef struct {
    GLuint index;
    GLsizei count;
    GLshort * v;
} ARGS_glVertexAttribs1svNV;
typedef struct {
    int index;
    ARGS_glVertexAttribs1svNV args;
} PACKED_glVertexAttribs1svNV;
typedef struct {
    GLuint index;
    GLsizei count;
    GLdouble * v;
} ARGS_glVertexAttribs2dvNV;
typedef struct {
    int index;
    ARGS_glVertexAttribs2dvNV args;
} PACKED_glVertexAttribs2dvNV;
typedef struct {
    GLuint index;
    GLsizei count;
    GLfloat * v;
} ARGS_glVertexAttribs2fvNV;
typedef struct {
    int index;
    ARGS_glVertexAttribs2fvNV args;
} PACKED_glVertexAttribs2fvNV;
typedef struct {
    GLuint index;
    GLsizei n;
    GLhalfNV * v;
} ARGS_glVertexAttribs2hvNV;
typedef struct {
    int index;
    ARGS_glVertexAttribs2hvNV args;
} PACKED_glVertexAttribs2hvNV;
typedef struct {
    GLuint index;
    GLsizei count;
    GLshort * v;
} ARGS_glVertexAttribs2svNV;
typedef struct {
    int index;
    ARGS_glVertexAttribs2svNV args;
} PACKED_glVertexAttribs2svNV;
typedef struct {
    GLuint index;
    GLsizei count;
    GLdouble * v;
} ARGS_glVertexAttribs3dvNV;
typedef struct {
    int index;
    ARGS_glVertexAttribs3dvNV args;
} PACKED_glVertexAttribs3dvNV;
typedef struct {
    GLuint index;
    GLsizei count;
    GLfloat * v;
} ARGS_glVertexAttribs3fvNV;
typedef struct {
    int index;
    ARGS_glVertexAttribs3fvNV args;
} PACKED_glVertexAttribs3fvNV;
typedef struct {
    GLuint index;
    GLsizei n;
    GLhalfNV * v;
} ARGS_glVertexAttribs3hvNV;
typedef struct {
    int index;
    ARGS_glVertexAttribs3hvNV args;
} PACKED_glVertexAttribs3hvNV;
typedef struct {
    GLuint index;
    GLsizei count;
    GLshort * v;
} ARGS_glVertexAttribs3svNV;
typedef struct {
    int index;
    ARGS_glVertexAttribs3svNV args;
} PACKED_glVertexAttribs3svNV;
typedef struct {
    GLuint index;
    GLsizei count;
    GLdouble * v;
} ARGS_glVertexAttribs4dvNV;
typedef struct {
    int index;
    ARGS_glVertexAttribs4dvNV args;
} PACKED_glVertexAttribs4dvNV;
typedef struct {
    GLuint index;
    GLsizei count;
    GLfloat * v;
} ARGS_glVertexAttribs4fvNV;
typedef struct {
    int index;
    ARGS_glVertexAttribs4fvNV args;
} PACKED_glVertexAttribs4fvNV;
typedef struct {
    GLuint index;
    GLsizei n;
    GLhalfNV * v;
} ARGS_glVertexAttribs4hvNV;
typedef struct {
    int index;
    ARGS_glVertexAttribs4hvNV args;
} PACKED_glVertexAttribs4hvNV;
typedef struct {
    GLuint index;
    GLsizei count;
    GLshort * v;
} ARGS_glVertexAttribs4svNV;
typedef struct {
    int index;
    ARGS_glVertexAttribs4svNV args;
} PACKED_glVertexAttribs4svNV;
typedef struct {
    GLuint index;
    GLsizei count;
    GLubyte * v;
} ARGS_glVertexAttribs4ubvNV;
typedef struct {
    int index;
    ARGS_glVertexAttribs4ubvNV args;
} PACKED_glVertexAttribs4ubvNV;
typedef struct {
    GLuint bindingindex;
    GLuint divisor;
} ARGS_glVertexBindingDivisor;
typedef struct {
    int index;
    ARGS_glVertexBindingDivisor args;
} PACKED_glVertexBindingDivisor;
typedef struct {
    GLint count;
} ARGS_glVertexBlendARB;
typedef struct {
    int index;
    ARGS_glVertexBlendARB args;
} PACKED_glVertexBlendARB;
typedef struct {
    GLenum pname;
    GLfloat param;
} ARGS_glVertexBlendEnvfATI;
typedef struct {
    int index;
    ARGS_glVertexBlendEnvfATI args;
} PACKED_glVertexBlendEnvfATI;
typedef struct {
    GLenum pname;
    GLint param;
} ARGS_glVertexBlendEnviATI;
typedef struct {
    int index;
    ARGS_glVertexBlendEnviATI args;
} PACKED_glVertexBlendEnviATI;
typedef struct {
    GLint size;
    GLenum type;
    GLsizei stride;
} ARGS_glVertexFormatNV;
typedef struct {
    int index;
    ARGS_glVertexFormatNV args;
} PACKED_glVertexFormatNV;
typedef struct {
    GLenum type;
    GLuint value;
} ARGS_glVertexP2ui;
typedef struct {
    int index;
    ARGS_glVertexP2ui args;
} PACKED_glVertexP2ui;
typedef struct {
    GLenum type;
    GLuint * value;
} ARGS_glVertexP2uiv;
typedef struct {
    int index;
    ARGS_glVertexP2uiv args;
} PACKED_glVertexP2uiv;
typedef struct {
    GLenum type;
    GLuint value;
} ARGS_glVertexP3ui;
typedef struct {
    int index;
    ARGS_glVertexP3ui args;
} PACKED_glVertexP3ui;
typedef struct {
    GLenum type;
    GLuint * value;
} ARGS_glVertexP3uiv;
typedef struct {
    int index;
    ARGS_glVertexP3uiv args;
} PACKED_glVertexP3uiv;
typedef struct {
    GLenum type;
    GLuint value;
} ARGS_glVertexP4ui;
typedef struct {
    int index;
    ARGS_glVertexP4ui args;
} PACKED_glVertexP4ui;
typedef struct {
    GLenum type;
    GLuint * value;
} ARGS_glVertexP4uiv;
typedef struct {
    int index;
    ARGS_glVertexP4uiv args;
} PACKED_glVertexP4uiv;
typedef struct {
    GLint size;
    GLenum type;
    GLsizei stride;
    GLvoid * pointer;
} ARGS_glVertexPointer;
typedef struct {
    int index;
    ARGS_glVertexPointer args;
} PACKED_glVertexPointer;
typedef struct {
    GLint size;
    GLenum type;
    GLsizei stride;
    GLsizei count;
    GLvoid * pointer;
} ARGS_glVertexPointerEXT;
typedef struct {
    int index;
    ARGS_glVertexPointerEXT args;
} PACKED_glVertexPointerEXT;
typedef struct {
    GLint size;
    GLenum type;
    GLint stride;
    GLvoid * pointer;
    GLint ptrstride;
} ARGS_glVertexPointerListIBM;
typedef struct {
    int index;
    ARGS_glVertexPointerListIBM args;
} PACKED_glVertexPointerListIBM;
typedef struct {
    GLint size;
    GLenum type;
    GLvoid * pointer;
} ARGS_glVertexPointervINTEL;
typedef struct {
    int index;
    ARGS_glVertexPointervINTEL args;
} PACKED_glVertexPointervINTEL;
typedef struct {
    GLenum stream;
    GLdouble x __attribute__ ((aligned(8)));
} ARGS_glVertexStream1dATI;
typedef struct {
    int index;
    ARGS_glVertexStream1dATI args;
} PACKED_glVertexStream1dATI;
typedef struct {
    GLenum stream;
    GLdouble * coords;
} ARGS_glVertexStream1dvATI;
typedef struct {
    int index;
    ARGS_glVertexStream1dvATI args;
} PACKED_glVertexStream1dvATI;
typedef struct {
    GLenum stream;
    GLfloat x;
} ARGS_glVertexStream1fATI;
typedef struct {
    int index;
    ARGS_glVertexStream1fATI args;
} PACKED_glVertexStream1fATI;
typedef struct {
    GLenum stream;
    GLfloat * coords;
} ARGS_glVertexStream1fvATI;
typedef struct {
    int index;
    ARGS_glVertexStream1fvATI args;
} PACKED_glVertexStream1fvATI;
typedef struct {
    GLenum stream;
    GLint x;
} ARGS_glVertexStream1iATI;
typedef struct {
    int index;
    ARGS_glVertexStream1iATI args;
} PACKED_glVertexStream1iATI;
typedef struct {
    GLenum stream;
    GLint * coords;
} ARGS_glVertexStream1ivATI;
typedef struct {
    int index;
    ARGS_glVertexStream1ivATI args;
} PACKED_glVertexStream1ivATI;
typedef struct {
    GLenum stream;
    GLshort x;
} ARGS_glVertexStream1sATI;
typedef struct {
    int index;
    ARGS_glVertexStream1sATI args;
} PACKED_glVertexStream1sATI;
typedef struct {
    GLenum stream;
    GLshort * coords;
} ARGS_glVertexStream1svATI;
typedef struct {
    int index;
    ARGS_glVertexStream1svATI args;
} PACKED_glVertexStream1svATI;
typedef struct {
    GLenum stream;
    GLdouble x __attribute__ ((aligned(8)));
    GLdouble y __attribute__ ((aligned(8)));
} ARGS_glVertexStream2dATI;
typedef struct {
    int index;
    ARGS_glVertexStream2dATI args;
} PACKED_glVertexStream2dATI;
typedef struct {
    GLenum stream;
    GLdouble * coords;
} ARGS_glVertexStream2dvATI;
typedef struct {
    int index;
    ARGS_glVertexStream2dvATI args;
} PACKED_glVertexStream2dvATI;
typedef struct {
    GLenum stream;
    GLfloat x;
    GLfloat y;
} ARGS_glVertexStream2fATI;
typedef struct {
    int index;
    ARGS_glVertexStream2fATI args;
} PACKED_glVertexStream2fATI;
typedef struct {
    GLenum stream;
    GLfloat * coords;
} ARGS_glVertexStream2fvATI;
typedef struct {
    int index;
    ARGS_glVertexStream2fvATI args;
} PACKED_glVertexStream2fvATI;
typedef struct {
    GLenum stream;
    GLint x;
    GLint y;
} ARGS_glVertexStream2iATI;
typedef struct {
    int index;
    ARGS_glVertexStream2iATI args;
} PACKED_glVertexStream2iATI;
typedef struct {
    GLenum stream;
    GLint * coords;
} ARGS_glVertexStream2ivATI;
typedef struct {
    int index;
    ARGS_glVertexStream2ivATI args;
} PACKED_glVertexStream2ivATI;
typedef struct {
    GLenum stream;
    GLshort x;
    GLshort y;
} ARGS_glVertexStream2sATI;
typedef struct {
    int index;
    ARGS_glVertexStream2sATI args;
} PACKED_glVertexStream2sATI;
typedef struct {
    GLenum stream;
    GLshort * coords;
} ARGS_glVertexStream2svATI;
typedef struct {
    int index;
    ARGS_glVertexStream2svATI args;
} PACKED_glVertexStream2svATI;
typedef struct {
    GLenum stream;
    GLdouble x __attribute__ ((aligned(8)));
    GLdouble y __attribute__ ((aligned(8)));
    GLdouble z __attribute__ ((aligned(8)));
} ARGS_glVertexStream3dATI;
typedef struct {
    int index;
    ARGS_glVertexStream3dATI args;
} PACKED_glVertexStream3dATI;
typedef struct {
    GLenum stream;
    GLdouble * coords;
} ARGS_glVertexStream3dvATI;
typedef struct {
    int index;
    ARGS_glVertexStream3dvATI args;
} PACKED_glVertexStream3dvATI;
typedef struct {
    GLenum stream;
    GLfloat x;
    GLfloat y;
    GLfloat z;
} ARGS_glVertexStream3fATI;
typedef struct {
    int index;
    ARGS_glVertexStream3fATI args;
} PACKED_glVertexStream3fATI;
typedef struct {
    GLenum stream;
    GLfloat * coords;
} ARGS_glVertexStream3fvATI;
typedef struct {
    int index;
    ARGS_glVertexStream3fvATI args;
} PACKED_glVertexStream3fvATI;
typedef struct {
    GLenum stream;
    GLint x;
    GLint y;
    GLint z;
} ARGS_glVertexStream3iATI;
typedef struct {
    int index;
    ARGS_glVertexStream3iATI args;
} PACKED_glVertexStream3iATI;
typedef struct {
    GLenum stream;
    GLint * coords;
} ARGS_glVertexStream3ivATI;
typedef struct {
    int index;
    ARGS_glVertexStream3ivATI args;
} PACKED_glVertexStream3ivATI;
typedef struct {
    GLenum stream;
    GLshort x;
    GLshort y;
    GLshort z;
} ARGS_glVertexStream3sATI;
typedef struct {
    int index;
    ARGS_glVertexStream3sATI args;
} PACKED_glVertexStream3sATI;
typedef struct {
    GLenum stream;
    GLshort * coords;
} ARGS_glVertexStream3svATI;
typedef struct {
    int index;
    ARGS_glVertexStream3svATI args;
} PACKED_glVertexStream3svATI;
typedef struct {
    GLenum stream;
    GLdouble x __attribute__ ((aligned(8)));
    GLdouble y __attribute__ ((aligned(8)));
    GLdouble z __attribute__ ((aligned(8)));
    GLdouble w __attribute__ ((aligned(8)));
} ARGS_glVertexStream4dATI;
typedef struct {
    int index;
    ARGS_glVertexStream4dATI args;
} PACKED_glVertexStream4dATI;
typedef struct {
    GLenum stream;
    GLdouble * coords;
} ARGS_glVertexStream4dvATI;
typedef struct {
    int index;
    ARGS_glVertexStream4dvATI args;
} PACKED_glVertexStream4dvATI;
typedef struct {
    GLenum stream;
    GLfloat x;
    GLfloat y;
    GLfloat z;
    GLfloat w;
} ARGS_glVertexStream4fATI;
typedef struct {
    int index;
    ARGS_glVertexStream4fATI args;
} PACKED_glVertexStream4fATI;
typedef struct {
    GLenum stream;
    GLfloat * coords;
} ARGS_glVertexStream4fvATI;
typedef struct {
    int index;
    ARGS_glVertexStream4fvATI args;
} PACKED_glVertexStream4fvATI;
typedef struct {
    GLenum stream;
    GLint x;
    GLint y;
    GLint z;
    GLint w;
} ARGS_glVertexStream4iATI;
typedef struct {
    int index;
    ARGS_glVertexStream4iATI args;
} PACKED_glVertexStream4iATI;
typedef struct {
    GLenum stream;
    GLint * coords;
} ARGS_glVertexStream4ivATI;
typedef struct {
    int index;
    ARGS_glVertexStream4ivATI args;
} PACKED_glVertexStream4ivATI;
typedef struct {
    GLenum stream;
    GLshort x;
    GLshort y;
    GLshort z;
    GLshort w;
} ARGS_glVertexStream4sATI;
typedef struct {
    int index;
    ARGS_glVertexStream4sATI args;
} PACKED_glVertexStream4sATI;
typedef struct {
    GLenum stream;
    GLshort * coords;
} ARGS_glVertexStream4svATI;
typedef struct {
    int index;
    ARGS_glVertexStream4svATI args;
} PACKED_glVertexStream4svATI;
typedef struct {
    GLint size;
    GLenum type;
    GLsizei stride;
    GLvoid * pointer;
} ARGS_glVertexWeightPointerEXT;
typedef struct {
    int index;
    ARGS_glVertexWeightPointerEXT args;
} PACKED_glVertexWeightPointerEXT;
typedef struct {
    GLfloat weight;
} ARGS_glVertexWeightfEXT;
typedef struct {
    int index;
    ARGS_glVertexWeightfEXT args;
} PACKED_glVertexWeightfEXT;
typedef struct {
    GLfloat * weight;
} ARGS_glVertexWeightfvEXT;
typedef struct {
    int index;
    ARGS_glVertexWeightfvEXT args;
} PACKED_glVertexWeightfvEXT;
typedef struct {
    GLhalfNV weight;
} ARGS_glVertexWeighthNV;
typedef struct {
    int index;
    ARGS_glVertexWeighthNV args;
} PACKED_glVertexWeighthNV;
typedef struct {
    GLhalfNV * weight;
} ARGS_glVertexWeighthvNV;
typedef struct {
    int index;
    ARGS_glVertexWeighthvNV args;
} PACKED_glVertexWeighthvNV;
typedef struct {
    GLuint video_capture_slot;
    GLuint * sequence_num;
    GLuint64EXT * capture_time;
} ARGS_glVideoCaptureNV;
typedef struct {
    int index;
    ARGS_glVideoCaptureNV args;
} PACKED_glVideoCaptureNV;
typedef struct {
    GLuint video_capture_slot;
    GLuint stream;
    GLenum pname;
    GLdouble * params;
} ARGS_glVideoCaptureStreamParameterdvNV;
typedef struct {
    int index;
    ARGS_glVideoCaptureStreamParameterdvNV args;
} PACKED_glVideoCaptureStreamParameterdvNV;
typedef struct {
    GLuint video_capture_slot;
    GLuint stream;
    GLenum pname;
    GLfloat * params;
} ARGS_glVideoCaptureStreamParameterfvNV;
typedef struct {
    int index;
    ARGS_glVideoCaptureStreamParameterfvNV args;
} PACKED_glVideoCaptureStreamParameterfvNV;
typedef struct {
    GLuint video_capture_slot;
    GLuint stream;
    GLenum pname;
    GLint * params;
} ARGS_glVideoCaptureStreamParameterivNV;
typedef struct {
    int index;
    ARGS_glVideoCaptureStreamParameterivNV args;
} PACKED_glVideoCaptureStreamParameterivNV;
typedef struct {
    GLint x;
    GLint y;
    GLsizei width;
    GLsizei height;
} ARGS_glViewport;
typedef struct {
    int index;
    ARGS_glViewport args;
} PACKED_glViewport;
typedef struct {
    GLuint first;
    GLsizei count;
    GLfloat * v;
} ARGS_glViewportArrayv;
typedef struct {
    int index;
    ARGS_glViewportArrayv args;
} PACKED_glViewportArrayv;
typedef struct {
    GLuint index;
    GLfloat x;
    GLfloat y;
    GLfloat w;
    GLfloat h;
} ARGS_glViewportIndexedf;
typedef struct {
    int index;
    ARGS_glViewportIndexedf args;
} PACKED_glViewportIndexedf;
typedef struct {
    GLuint index;
    GLfloat * v;
} ARGS_glViewportIndexedfv;
typedef struct {
    int index;
    ARGS_glViewportIndexedfv args;
} PACKED_glViewportIndexedfv;
typedef struct {
    GLsync sync;
    GLbitfield flags;
    GLuint64 timeout;
} ARGS_glWaitSync;
typedef struct {
    int index;
    ARGS_glWaitSync args;
} PACKED_glWaitSync;
typedef struct {
    GLuint resultPath;
    GLsizei numPaths;
    GLuint * paths;
    GLfloat * weights;
} ARGS_glWeightPathsNV;
typedef struct {
    int index;
    ARGS_glWeightPathsNV args;
} PACKED_glWeightPathsNV;
typedef struct {
    GLint size;
    GLenum type;
    GLsizei stride;
    GLvoid * pointer;
} ARGS_glWeightPointerARB;
typedef struct {
    int index;
    ARGS_glWeightPointerARB args;
} PACKED_glWeightPointerARB;
typedef struct {
    GLint size;
    GLbyte * weights;
} ARGS_glWeightbvARB;
typedef struct {
    int index;
    ARGS_glWeightbvARB args;
} PACKED_glWeightbvARB;
typedef struct {
    GLint size;
    GLdouble * weights;
} ARGS_glWeightdvARB;
typedef struct {
    int index;
    ARGS_glWeightdvARB args;
} PACKED_glWeightdvARB;
typedef struct {
    GLint size;
    GLfloat * weights;
} ARGS_glWeightfvARB;
typedef struct {
    int index;
    ARGS_glWeightfvARB args;
} PACKED_glWeightfvARB;
typedef struct {
    GLint size;
    GLint * weights;
} ARGS_glWeightivARB;
typedef struct {
    int index;
    ARGS_glWeightivARB args;
} PACKED_glWeightivARB;
typedef struct {
    GLint size;
    GLshort * weights;
} ARGS_glWeightsvARB;
typedef struct {
    int index;
    ARGS_glWeightsvARB args;
} PACKED_glWeightsvARB;
typedef struct {
    GLint size;
    GLubyte * weights;
} ARGS_glWeightubvARB;
typedef struct {
    int index;
    ARGS_glWeightubvARB args;
} PACKED_glWeightubvARB;
typedef struct {
    GLint size;
    GLuint * weights;
} ARGS_glWeightuivARB;
typedef struct {
    int index;
    ARGS_glWeightuivARB args;
} PACKED_glWeightuivARB;
typedef struct {
    GLint size;
    GLushort * weights;
} ARGS_glWeightusvARB;
typedef struct {
    int index;
    ARGS_glWeightusvARB args;
} PACKED_glWeightusvARB;
typedef struct {
    GLdouble x __attribute__ ((aligned(8)));
    GLdouble y __attribute__ ((aligned(8)));
} ARGS_glWindowPos2d;
typedef struct {
    int index;
    ARGS_glWindowPos2d args;
} PACKED_glWindowPos2d;
typedef struct {
    GLdouble x __attribute__ ((aligned(8)));
    GLdouble y __attribute__ ((aligned(8)));
} ARGS_glWindowPos2dARB;
typedef struct {
    int index;
    ARGS_glWindowPos2dARB args;
} PACKED_glWindowPos2dARB;
typedef struct {
    GLdouble x __attribute__ ((aligned(8)));
    GLdouble y __attribute__ ((aligned(8)));
} ARGS_glWindowPos2dMESA;
typedef struct {
    int index;
    ARGS_glWindowPos2dMESA args;
} PACKED_glWindowPos2dMESA;
typedef struct {
    GLdouble * v;
} ARGS_glWindowPos2dv;
typedef struct {
    int index;
    ARGS_glWindowPos2dv args;
} PACKED_glWindowPos2dv;
typedef struct {
    GLdouble * v;
} ARGS_glWindowPos2dvARB;
typedef struct {
    int index;
    ARGS_glWindowPos2dvARB args;
} PACKED_glWindowPos2dvARB;
typedef struct {
    GLdouble * v;
} ARGS_glWindowPos2dvMESA;
typedef struct {
    int index;
    ARGS_glWindowPos2dvMESA args;
} PACKED_glWindowPos2dvMESA;
typedef struct {
    GLfloat x;
    GLfloat y;
} ARGS_glWindowPos2f;
typedef struct {
    int index;
    ARGS_glWindowPos2f args;
} PACKED_glWindowPos2f;
typedef struct {
    GLfloat x;
    GLfloat y;
} ARGS_glWindowPos2fARB;
typedef struct {
    int index;
    ARGS_glWindowPos2fARB args;
} PACKED_glWindowPos2fARB;
typedef struct {
    GLfloat x;
    GLfloat y;
} ARGS_glWindowPos2fMESA;
typedef struct {
    int index;
    ARGS_glWindowPos2fMESA args;
} PACKED_glWindowPos2fMESA;
typedef struct {
    GLfloat * v;
} ARGS_glWindowPos2fv;
typedef struct {
    int index;
    ARGS_glWindowPos2fv args;
} PACKED_glWindowPos2fv;
typedef struct {
    GLfloat * v;
} ARGS_glWindowPos2fvARB;
typedef struct {
    int index;
    ARGS_glWindowPos2fvARB args;
} PACKED_glWindowPos2fvARB;
typedef struct {
    GLfloat * v;
} ARGS_glWindowPos2fvMESA;
typedef struct {
    int index;
    ARGS_glWindowPos2fvMESA args;
} PACKED_glWindowPos2fvMESA;
typedef struct {
    GLint x;
    GLint y;
} ARGS_glWindowPos2i;
typedef struct {
    int index;
    ARGS_glWindowPos2i args;
} PACKED_glWindowPos2i;
typedef struct {
    GLint x;
    GLint y;
} ARGS_glWindowPos2iARB;
typedef struct {
    int index;
    ARGS_glWindowPos2iARB args;
} PACKED_glWindowPos2iARB;
typedef struct {
    GLint x;
    GLint y;
} ARGS_glWindowPos2iMESA;
typedef struct {
    int index;
    ARGS_glWindowPos2iMESA args;
} PACKED_glWindowPos2iMESA;
typedef struct {
    GLint * v;
} ARGS_glWindowPos2iv;
typedef struct {
    int index;
    ARGS_glWindowPos2iv args;
} PACKED_glWindowPos2iv;
typedef struct {
    GLint * v;
} ARGS_glWindowPos2ivARB;
typedef struct {
    int index;
    ARGS_glWindowPos2ivARB args;
} PACKED_glWindowPos2ivARB;
typedef struct {
    GLint * v;
} ARGS_glWindowPos2ivMESA;
typedef struct {
    int index;
    ARGS_glWindowPos2ivMESA args;
} PACKED_glWindowPos2ivMESA;
typedef struct {
    GLshort x;
    GLshort y;
} ARGS_glWindowPos2s;
typedef struct {
    int index;
    ARGS_glWindowPos2s args;
} PACKED_glWindowPos2s;
typedef struct {
    GLshort x;
    GLshort y;
} ARGS_glWindowPos2sARB;
typedef struct {
    int index;
    ARGS_glWindowPos2sARB args;
} PACKED_glWindowPos2sARB;
typedef struct {
    GLshort x;
    GLshort y;
} ARGS_glWindowPos2sMESA;
typedef struct {
    int index;
    ARGS_glWindowPos2sMESA args;
} PACKED_glWindowPos2sMESA;
typedef struct {
    GLshort * v;
} ARGS_glWindowPos2sv;
typedef struct {
    int index;
    ARGS_glWindowPos2sv args;
} PACKED_glWindowPos2sv;
typedef struct {
    GLshort * v;
} ARGS_glWindowPos2svARB;
typedef struct {
    int index;
    ARGS_glWindowPos2svARB args;
} PACKED_glWindowPos2svARB;
typedef struct {
    GLshort * v;
} ARGS_glWindowPos2svMESA;
typedef struct {
    int index;
    ARGS_glWindowPos2svMESA args;
} PACKED_glWindowPos2svMESA;
typedef struct {
    GLdouble x __attribute__ ((aligned(8)));
    GLdouble y __attribute__ ((aligned(8)));
    GLdouble z __attribute__ ((aligned(8)));
} ARGS_glWindowPos3d;
typedef struct {
    int index;
    ARGS_glWindowPos3d args;
} PACKED_glWindowPos3d;
typedef struct {
    GLdouble x __attribute__ ((aligned(8)));
    GLdouble y __attribute__ ((aligned(8)));
    GLdouble z __attribute__ ((aligned(8)));
} ARGS_glWindowPos3dARB;
typedef struct {
    int index;
    ARGS_glWindowPos3dARB args;
} PACKED_glWindowPos3dARB;
typedef struct {
    GLdouble x __attribute__ ((aligned(8)));
    GLdouble y __attribute__ ((aligned(8)));
    GLdouble z __attribute__ ((aligned(8)));
} ARGS_glWindowPos3dMESA;
typedef struct {
    int index;
    ARGS_glWindowPos3dMESA args;
} PACKED_glWindowPos3dMESA;
typedef struct {
    GLdouble * v;
} ARGS_glWindowPos3dv;
typedef struct {
    int index;
    ARGS_glWindowPos3dv args;
} PACKED_glWindowPos3dv;
typedef struct {
    GLdouble * v;
} ARGS_glWindowPos3dvARB;
typedef struct {
    int index;
    ARGS_glWindowPos3dvARB args;
} PACKED_glWindowPos3dvARB;
typedef struct {
    GLdouble * v;
} ARGS_glWindowPos3dvMESA;
typedef struct {
    int index;
    ARGS_glWindowPos3dvMESA args;
} PACKED_glWindowPos3dvMESA;
typedef struct {
    GLfloat x;
    GLfloat y;
    GLfloat z;
} ARGS_glWindowPos3f;
typedef struct {
    int index;
    ARGS_glWindowPos3f args;
} PACKED_glWindowPos3f;
typedef struct {
    GLfloat x;
    GLfloat y;
    GLfloat z;
} ARGS_glWindowPos3fARB;
typedef struct {
    int index;
    ARGS_glWindowPos3fARB args;
} PACKED_glWindowPos3fARB;
typedef struct {
    GLfloat x;
    GLfloat y;
    GLfloat z;
} ARGS_glWindowPos3fMESA;
typedef struct {
    int index;
    ARGS_glWindowPos3fMESA args;
} PACKED_glWindowPos3fMESA;
typedef struct {
    GLfloat * v;
} ARGS_glWindowPos3fv;
typedef struct {
    int index;
    ARGS_glWindowPos3fv args;
} PACKED_glWindowPos3fv;
typedef struct {
    GLfloat * v;
} ARGS_glWindowPos3fvARB;
typedef struct {
    int index;
    ARGS_glWindowPos3fvARB args;
} PACKED_glWindowPos3fvARB;
typedef struct {
    GLfloat * v;
} ARGS_glWindowPos3fvMESA;
typedef struct {
    int index;
    ARGS_glWindowPos3fvMESA args;
} PACKED_glWindowPos3fvMESA;
typedef struct {
    GLint x;
    GLint y;
    GLint z;
} ARGS_glWindowPos3i;
typedef struct {
    int index;
    ARGS_glWindowPos3i args;
} PACKED_glWindowPos3i;
typedef struct {
    GLint x;
    GLint y;
    GLint z;
} ARGS_glWindowPos3iARB;
typedef struct {
    int index;
    ARGS_glWindowPos3iARB args;
} PACKED_glWindowPos3iARB;
typedef struct {
    GLint x;
    GLint y;
    GLint z;
} ARGS_glWindowPos3iMESA;
typedef struct {
    int index;
    ARGS_glWindowPos3iMESA args;
} PACKED_glWindowPos3iMESA;
typedef struct {
    GLint * v;
} ARGS_glWindowPos3iv;
typedef struct {
    int index;
    ARGS_glWindowPos3iv args;
} PACKED_glWindowPos3iv;
typedef struct {
    GLint * v;
} ARGS_glWindowPos3ivARB;
typedef struct {
    int index;
    ARGS_glWindowPos3ivARB args;
} PACKED_glWindowPos3ivARB;
typedef struct {
    GLint * v;
} ARGS_glWindowPos3ivMESA;
typedef struct {
    int index;
    ARGS_glWindowPos3ivMESA args;
} PACKED_glWindowPos3ivMESA;
typedef struct {
    GLshort x;
    GLshort y;
    GLshort z;
} ARGS_glWindowPos3s;
typedef struct {
    int index;
    ARGS_glWindowPos3s args;
} PACKED_glWindowPos3s;
typedef struct {
    GLshort x;
    GLshort y;
    GLshort z;
} ARGS_glWindowPos3sARB;
typedef struct {
    int index;
    ARGS_glWindowPos3sARB args;
} PACKED_glWindowPos3sARB;
typedef struct {
    GLshort x;
    GLshort y;
    GLshort z;
} ARGS_glWindowPos3sMESA;
typedef struct {
    int index;
    ARGS_glWindowPos3sMESA args;
} PACKED_glWindowPos3sMESA;
typedef struct {
    GLshort * v;
} ARGS_glWindowPos3sv;
typedef struct {
    int index;
    ARGS_glWindowPos3sv args;
} PACKED_glWindowPos3sv;
typedef struct {
    GLshort * v;
} ARGS_glWindowPos3svARB;
typedef struct {
    int index;
    ARGS_glWindowPos3svARB args;
} PACKED_glWindowPos3svARB;
typedef struct {
    GLshort * v;
} ARGS_glWindowPos3svMESA;
typedef struct {
    int index;
    ARGS_glWindowPos3svMESA args;
} PACKED_glWindowPos3svMESA;
typedef struct {
    GLdouble x __attribute__ ((aligned(8)));
    GLdouble y __attribute__ ((aligned(8)));
    GLdouble z __attribute__ ((aligned(8)));
    GLdouble w __attribute__ ((aligned(8)));
} ARGS_glWindowPos4dMESA;
typedef struct {
    int index;
    ARGS_glWindowPos4dMESA args;
} PACKED_glWindowPos4dMESA;
typedef struct {
    GLdouble * v;
} ARGS_glWindowPos4dvMESA;
typedef struct {
    int index;
    ARGS_glWindowPos4dvMESA args;
} PACKED_glWindowPos4dvMESA;
typedef struct {
    GLfloat x;
    GLfloat y;
    GLfloat z;
    GLfloat w;
} ARGS_glWindowPos4fMESA;
typedef struct {
    int index;
    ARGS_glWindowPos4fMESA args;
} PACKED_glWindowPos4fMESA;
typedef struct {
    GLfloat * v;
} ARGS_glWindowPos4fvMESA;
typedef struct {
    int index;
    ARGS_glWindowPos4fvMESA args;
} PACKED_glWindowPos4fvMESA;
typedef struct {
    GLint x;
    GLint y;
    GLint z;
    GLint w;
} ARGS_glWindowPos4iMESA;
typedef struct {
    int index;
    ARGS_glWindowPos4iMESA args;
} PACKED_glWindowPos4iMESA;
typedef struct {
    GLint * v;
} ARGS_glWindowPos4ivMESA;
typedef struct {
    int index;
    ARGS_glWindowPos4ivMESA args;
} PACKED_glWindowPos4ivMESA;
typedef struct {
    GLshort x;
    GLshort y;
    GLshort z;
    GLshort w;
} ARGS_glWindowPos4sMESA;
typedef struct {
    int index;
    ARGS_glWindowPos4sMESA args;
} PACKED_glWindowPos4sMESA;
typedef struct {
    GLshort * v;
} ARGS_glWindowPos4svMESA;
typedef struct {
    int index;
    ARGS_glWindowPos4svMESA args;
} PACKED_glWindowPos4svMESA;
typedef struct {
    GLuint res;
    GLuint in;
    GLenum outX;
    GLenum outY;
    GLenum outZ;
    GLenum outW;
} ARGS_glWriteMaskEXT;
typedef struct {
    int index;
    ARGS_glWriteMaskEXT args;
} PACKED_glWriteMaskEXT;
typedef struct {
    Display * dpy;
    GLXPbufferSGIX pbuffer;
    DMparams * params;
    DMbuffer dmbuffer;
} ARGS_glXAssociateDMPbufferSGIX;
typedef struct {
    int index;
    ARGS_glXAssociateDMPbufferSGIX args;
} PACKED_glXAssociateDMPbufferSGIX;
typedef struct {
    Display * display;
    int screen;
    int channel;
    Window window;
} ARGS_glXBindChannelToWindowSGIX;
typedef struct {
    int index;
    ARGS_glXBindChannelToWindowSGIX args;
} PACKED_glXBindChannelToWindowSGIX;
typedef struct {
    Display * dpy;
    int hpId;
} ARGS_glXBindHyperpipeSGIX;
typedef struct {
    int index;
    ARGS_glXBindHyperpipeSGIX args;
} PACKED_glXBindHyperpipeSGIX;
typedef struct {
    Display * dpy;
    GLuint group;
    GLuint barrier;
} ARGS_glXBindSwapBarrierNV;
typedef struct {
    int index;
    ARGS_glXBindSwapBarrierNV args;
} PACKED_glXBindSwapBarrierNV;
typedef struct {
    Display * dpy;
    GLXDrawable drawable;
    int barrier;
} ARGS_glXBindSwapBarrierSGIX;
typedef struct {
    int index;
    ARGS_glXBindSwapBarrierSGIX args;
} PACKED_glXBindSwapBarrierSGIX;
typedef struct {
    Display * dpy;
    GLXDrawable drawable;
    int buffer;
    int * attrib_list;
} ARGS_glXBindTexImageEXT;
typedef struct {
    int index;
    ARGS_glXBindTexImageEXT args;
} PACKED_glXBindTexImageEXT;
typedef struct {
    Display * dpy;
    unsigned int video_capture_slot;
    GLXVideoCaptureDeviceNV device;
} ARGS_glXBindVideoCaptureDeviceNV;
typedef struct {
    int index;
    ARGS_glXBindVideoCaptureDeviceNV args;
} PACKED_glXBindVideoCaptureDeviceNV;
typedef struct {
    Display * dpy;
    unsigned int video_slot;
    unsigned int video_device;
    int * attrib_list;
} ARGS_glXBindVideoDeviceNV;
typedef struct {
    int index;
    ARGS_glXBindVideoDeviceNV args;
} PACKED_glXBindVideoDeviceNV;
typedef struct {
    Display * dpy;
    GLXVideoDeviceNV VideoDevice;
    GLXPbuffer pbuf;
    int iVideoBuffer;
} ARGS_glXBindVideoImageNV;
typedef struct {
    int index;
    ARGS_glXBindVideoImageNV args;
} PACKED_glXBindVideoImageNV;
typedef struct {
    uint32_t drawable;
} ARGS_glXChangeDrawableAttributes;
typedef struct {
    int index;
    ARGS_glXChangeDrawableAttributes args;
} PACKED_glXChangeDrawableAttributes;
typedef struct {
    uint32_t drawable;
} ARGS_glXChangeDrawableAttributesSGIX;
typedef struct {
    int index;
    ARGS_glXChangeDrawableAttributesSGIX args;
} PACKED_glXChangeDrawableAttributesSGIX;
typedef struct {
    Display * display;
    int screen;
    int channel;
    int x;
    int y;
    int w;
    int h;
} ARGS_glXChannelRectSGIX;
typedef struct {
    int index;
    ARGS_glXChannelRectSGIX args;
} PACKED_glXChannelRectSGIX;
typedef struct {
    Display * display;
    int screen;
    int channel;
    GLenum synctype;
} ARGS_glXChannelRectSyncSGIX;
typedef struct {
    int index;
    ARGS_glXChannelRectSyncSGIX args;
} PACKED_glXChannelRectSyncSGIX;
typedef struct {
    Display * dpy;
    int screen;
    int * attrib_list;
    int * nelements;
} ARGS_glXChooseFBConfig;
typedef struct {
    int index;
    ARGS_glXChooseFBConfig args;
} PACKED_glXChooseFBConfig;
typedef struct {
    Display * dpy;
    int screen;
    int * attrib_list;
    int * nelements;
} ARGS_glXChooseFBConfigSGIX;
typedef struct {
    int index;
    ARGS_glXChooseFBConfigSGIX args;
} PACKED_glXChooseFBConfigSGIX;
typedef struct {
    Display * dpy;
    int screen;
    int * attribList;
} ARGS_glXChooseVisual;
typedef struct {
    int index;
    ARGS_glXChooseVisual args;
} PACKED_glXChooseVisual;
typedef struct {
    int index;
} PACKED_glXClientInfo;
typedef struct {
    Display * dpy;
    GLXContext src;
    GLXContext dst;
    unsigned long mask;
} ARGS_glXCopyContext;
typedef struct {
    int index;
    ARGS_glXCopyContext args;
} PACKED_glXCopyContext;
typedef struct {
    Display * dpy;
    GLXContext srcCtx;
    GLuint srcName;
    GLenum srcTarget;
    GLint srcLevel;
    GLint srcX;
    GLint srcY;
    GLint srcZ;
    GLXContext dstCtx;
    GLuint dstName;
    GLenum dstTarget;
    GLint dstLevel;
    GLint dstX;
    GLint dstY;
    GLint dstZ;
    GLsizei width;
    GLsizei height;
    GLsizei depth;
} ARGS_glXCopyImageSubDataNV;
typedef struct {
    int index;
    ARGS_glXCopyImageSubDataNV args;
} PACKED_glXCopyImageSubDataNV;
typedef struct {
    Display * dpy;
    GLXDrawable drawable;
    int x;
    int y;
    int width;
    int height;
} ARGS_glXCopySubBufferMESA;
typedef struct {
    int index;
    ARGS_glXCopySubBufferMESA args;
} PACKED_glXCopySubBufferMESA;
typedef struct {
    Display * dpy;
    XVisualInfo * vis;
    GLXContext shareList;
    Bool direct;
} ARGS_glXCreateContext;
typedef struct {
    int index;
    ARGS_glXCreateContext args;
} PACKED_glXCreateContext;
typedef struct {
    Display * dpy;
    GLXFBConfig config;
    GLXContext share_context;
    Bool direct;
    int * attrib_list;
} ARGS_glXCreateContextAttribsARB;
typedef struct {
    int index;
    ARGS_glXCreateContextAttribsARB args;
} PACKED_glXCreateContextAttribsARB;
typedef struct {
    Display * dpy;
    GLXFBConfigSGIX config;
    int render_type;
    GLXContext share_list;
    Bool direct;
} ARGS_glXCreateContextWithConfigSGIX;
typedef struct {
    int index;
    ARGS_glXCreateContextWithConfigSGIX args;
} PACKED_glXCreateContextWithConfigSGIX;
typedef struct {
    Display * dpy;
    GLXFBConfigSGIX config;
    unsigned int width;
    unsigned int height;
    int * attrib_list;
} ARGS_glXCreateGLXPbufferSGIX;
typedef struct {
    int index;
    ARGS_glXCreateGLXPbufferSGIX args;
} PACKED_glXCreateGLXPbufferSGIX;
typedef struct {
    Display * dpy;
    XVisualInfo * visual;
    Pixmap pixmap;
} ARGS_glXCreateGLXPixmap;
typedef struct {
    int index;
    ARGS_glXCreateGLXPixmap args;
} PACKED_glXCreateGLXPixmap;
typedef struct {
    Display * dpy;
    XVisualInfo * visual;
    Pixmap pixmap;
    Colormap cmap;
} ARGS_glXCreateGLXPixmapMESA;
typedef struct {
    int index;
    ARGS_glXCreateGLXPixmapMESA args;
} PACKED_glXCreateGLXPixmapMESA;
typedef struct {
    Display * dpy;
    GLXFBConfigSGIX config;
    Pixmap pixmap;
} ARGS_glXCreateGLXPixmapWithConfigSGIX;
typedef struct {
    int index;
    ARGS_glXCreateGLXPixmapWithConfigSGIX args;
} PACKED_glXCreateGLXPixmapWithConfigSGIX;
typedef struct {
    Display * display;
    int screen;
    VLServer server;
    VLPath path;
    int nodeClass;
    VLNode drainNode;
} ARGS_glXCreateGLXVideoSourceSGIX;
typedef struct {
    int index;
    ARGS_glXCreateGLXVideoSourceSGIX args;
} PACKED_glXCreateGLXVideoSourceSGIX;
typedef struct {
    Display * dpy;
    GLXFBConfig config;
    int render_type;
    GLXContext share_list;
    Bool direct;
} ARGS_glXCreateNewContext;
typedef struct {
    int index;
    ARGS_glXCreateNewContext args;
} PACKED_glXCreateNewContext;
typedef struct {
    Display * dpy;
    GLXFBConfig config;
    int * attrib_list;
} ARGS_glXCreatePbuffer;
typedef struct {
    int index;
    ARGS_glXCreatePbuffer args;
} PACKED_glXCreatePbuffer;
typedef struct {
    Display * dpy;
    GLXFBConfig config;
    Pixmap pixmap;
    int * attrib_list;
} ARGS_glXCreatePixmap;
typedef struct {
    int index;
    ARGS_glXCreatePixmap args;
} PACKED_glXCreatePixmap;
typedef struct {
    Display * dpy;
    GLXFBConfig config;
    Window win;
    int * attrib_list;
} ARGS_glXCreateWindow;
typedef struct {
    int index;
    ARGS_glXCreateWindow args;
} PACKED_glXCreateWindow;
typedef struct {
    Display * dpy;
    Window window;
    float cushion;
} ARGS_glXCushionSGI;
typedef struct {
    int index;
    ARGS_glXCushionSGI args;
} PACKED_glXCushionSGI;
typedef struct {
    Display * dpy;
    GLXContext ctx;
} ARGS_glXDestroyContext;
typedef struct {
    int index;
    ARGS_glXDestroyContext args;
} PACKED_glXDestroyContext;
typedef struct {
    Display * dpy;
    GLXPbufferSGIX pbuf;
} ARGS_glXDestroyGLXPbufferSGIX;
typedef struct {
    int index;
    ARGS_glXDestroyGLXPbufferSGIX args;
} PACKED_glXDestroyGLXPbufferSGIX;
typedef struct {
    Display * dpy;
    GLXPixmap pixmap;
} ARGS_glXDestroyGLXPixmap;
typedef struct {
    int index;
    ARGS_glXDestroyGLXPixmap args;
} PACKED_glXDestroyGLXPixmap;
typedef struct {
    Display * dpy;
    GLXVideoSourceSGIX glxvideosource;
} ARGS_glXDestroyGLXVideoSourceSGIX;
typedef struct {
    int index;
    ARGS_glXDestroyGLXVideoSourceSGIX args;
} PACKED_glXDestroyGLXVideoSourceSGIX;
typedef struct {
    Display * dpy;
    int hpId;
} ARGS_glXDestroyHyperpipeConfigSGIX;
typedef struct {
    int index;
    ARGS_glXDestroyHyperpipeConfigSGIX args;
} PACKED_glXDestroyHyperpipeConfigSGIX;
typedef struct {
    Display * dpy;
    GLXPbuffer pbuf;
} ARGS_glXDestroyPbuffer;
typedef struct {
    int index;
    ARGS_glXDestroyPbuffer args;
} PACKED_glXDestroyPbuffer;
typedef struct {
    Display * dpy;
    GLXPixmap pixmap;
} ARGS_glXDestroyPixmap;
typedef struct {
    int index;
    ARGS_glXDestroyPixmap args;
} PACKED_glXDestroyPixmap;
typedef struct {
    Display * dpy;
    GLXWindow win;
} ARGS_glXDestroyWindow;
typedef struct {
    int index;
    ARGS_glXDestroyWindow args;
} PACKED_glXDestroyWindow;
typedef struct {
    Display * dpy;
    int screen;
    int * nelements;
} ARGS_glXEnumerateVideoCaptureDevicesNV;
typedef struct {
    int index;
    ARGS_glXEnumerateVideoCaptureDevicesNV args;
} PACKED_glXEnumerateVideoCaptureDevicesNV;
typedef struct {
    Display * dpy;
    int screen;
    int * nelements;
} ARGS_glXEnumerateVideoDevicesNV;
typedef struct {
    int index;
    ARGS_glXEnumerateVideoDevicesNV args;
} PACKED_glXEnumerateVideoDevicesNV;
typedef struct {
    Display * dpy;
    GLXContext context;
} ARGS_glXFreeContextEXT;
typedef struct {
    int index;
    ARGS_glXFreeContextEXT args;
} PACKED_glXFreeContextEXT;
typedef struct {
    void * pointer;
} ARGS_glXGetAGPOffsetMESA;
typedef struct {
    int index;
    ARGS_glXGetAGPOffsetMESA args;
} PACKED_glXGetAGPOffsetMESA;
typedef struct {
    Display * display;
    int name;
} ARGS_glXGetClientString;
typedef struct {
    int index;
    ARGS_glXGetClientString args;
} PACKED_glXGetClientString;
typedef struct {
    Display * display;
    XVisualInfo * visual;
    int attribute;
    int * value;
} ARGS_glXGetConfig;
typedef struct {
    int index;
    ARGS_glXGetConfig args;
} PACKED_glXGetConfig;
typedef struct {
    GLXContext context;
} ARGS_glXGetContextIDEXT;
typedef struct {
    int index;
    ARGS_glXGetContextIDEXT args;
} PACKED_glXGetContextIDEXT;
typedef struct {
    int index;
} PACKED_glXGetCurrentContext;
typedef struct {
    int index;
} PACKED_glXGetCurrentDisplay;
typedef struct {
    int index;
} PACKED_glXGetCurrentDisplayEXT;
typedef struct {
    int index;
} PACKED_glXGetCurrentDrawable;
typedef struct {
    int index;
} PACKED_glXGetCurrentReadDrawable;
typedef struct {
    int index;
} PACKED_glXGetCurrentReadDrawableSGI;
typedef struct {
    uint32_t drawable;
} ARGS_glXGetDrawableAttributes;
typedef struct {
    int index;
    ARGS_glXGetDrawableAttributes args;
} PACKED_glXGetDrawableAttributes;
typedef struct {
    uint32_t drawable;
} ARGS_glXGetDrawableAttributesSGIX;
typedef struct {
    int index;
    ARGS_glXGetDrawableAttributesSGIX args;
} PACKED_glXGetDrawableAttributesSGIX;
typedef struct {
    Display * dpy;
    GLXFBConfig config;
    int attribute;
    int * value;
} ARGS_glXGetFBConfigAttrib;
typedef struct {
    int index;
    ARGS_glXGetFBConfigAttrib args;
} PACKED_glXGetFBConfigAttrib;
typedef struct {
    Display * dpy;
    GLXFBConfigSGIX config;
    int attribute;
    int * value;
} ARGS_glXGetFBConfigAttribSGIX;
typedef struct {
    int index;
    ARGS_glXGetFBConfigAttribSGIX args;
} PACKED_glXGetFBConfigAttribSGIX;
typedef struct {
    Display * dpy;
    XVisualInfo * vis;
} ARGS_glXGetFBConfigFromVisualSGIX;
typedef struct {
    int index;
    ARGS_glXGetFBConfigFromVisualSGIX args;
} PACKED_glXGetFBConfigFromVisualSGIX;
typedef struct {
    Display * dpy;
    int screen;
    int * nelements;
} ARGS_glXGetFBConfigs;
typedef struct {
    int index;
    ARGS_glXGetFBConfigs args;
} PACKED_glXGetFBConfigs;
typedef struct {
    int index;
} PACKED_glXGetFBConfigsSGIX;
typedef struct {
    Display * dpy;
    GLXDrawable drawable;
    int32_t * numerator;
    int32_t * denominator;
} ARGS_glXGetMscRateOML;
typedef struct {
    int index;
    ARGS_glXGetMscRateOML args;
} PACKED_glXGetMscRateOML;
typedef struct {
    GLubyte * procName;
} ARGS_glXGetProcAddress;
typedef struct {
    int index;
    ARGS_glXGetProcAddress args;
} PACKED_glXGetProcAddress;
typedef struct {
    GLubyte * procName;
} ARGS_glXGetProcAddressARB;
typedef struct {
    int index;
    ARGS_glXGetProcAddressARB args;
} PACKED_glXGetProcAddressARB;
typedef struct {
    Display * dpy;
    GLXDrawable draw;
    unsigned long * event_mask;
} ARGS_glXGetSelectedEvent;
typedef struct {
    int index;
    ARGS_glXGetSelectedEvent args;
} PACKED_glXGetSelectedEvent;
typedef struct {
    Display * dpy;
    GLXDrawable drawable;
    unsigned long * mask;
} ARGS_glXGetSelectedEventSGIX;
typedef struct {
    int index;
    ARGS_glXGetSelectedEventSGIX args;
} PACKED_glXGetSelectedEventSGIX;
typedef struct {
    Display * dpy;
    GLXDrawable drawable;
    int64_t * ust;
    int64_t * msc;
    int64_t * sbc;
} ARGS_glXGetSyncValuesOML;
typedef struct {
    int index;
    ARGS_glXGetSyncValuesOML args;
} PACKED_glXGetSyncValuesOML;
typedef struct {
    Display * dpy;
    Window overlay;
    Window underlay;
    long * pTransparentIndex;
} ARGS_glXGetTransparentIndexSUN;
typedef struct {
    int index;
    ARGS_glXGetTransparentIndexSUN args;
} PACKED_glXGetTransparentIndexSUN;
typedef struct {
    Display * dpy;
    int screen;
    int numVideoDevices;
    GLXVideoDeviceNV * pVideoDevice;
} ARGS_glXGetVideoDeviceNV;
typedef struct {
    int index;
    ARGS_glXGetVideoDeviceNV args;
} PACKED_glXGetVideoDeviceNV;
typedef struct {
    Display * dpy;
    int screen;
    GLXVideoDeviceNV VideoDevice;
    unsigned long * pulCounterOutputPbuffer;
    unsigned long * pulCounterOutputVideo;
} ARGS_glXGetVideoInfoNV;
typedef struct {
    int index;
    ARGS_glXGetVideoInfoNV args;
} PACKED_glXGetVideoInfoNV;
typedef struct {
    unsigned int * count;
} ARGS_glXGetVideoSyncSGI;
typedef struct {
    int index;
    ARGS_glXGetVideoSyncSGI args;
} PACKED_glXGetVideoSyncSGI;
typedef struct {
    int index;
} PACKED_glXGetVisualConfigs;
typedef struct {
    Display * dpy;
    GLXFBConfig config;
} ARGS_glXGetVisualFromFBConfig;
typedef struct {
    int index;
    ARGS_glXGetVisualFromFBConfig args;
} PACKED_glXGetVisualFromFBConfig;
typedef struct {
    Display * dpy;
    GLXFBConfigSGIX config;
} ARGS_glXGetVisualFromFBConfigSGIX;
typedef struct {
    int index;
    ARGS_glXGetVisualFromFBConfigSGIX args;
} PACKED_glXGetVisualFromFBConfigSGIX;
typedef struct {
    Display * dpy;
    int timeSlice;
    int attrib;
    int size;
    void * attribList;
} ARGS_glXHyperpipeAttribSGIX;
typedef struct {
    int index;
    ARGS_glXHyperpipeAttribSGIX args;
} PACKED_glXHyperpipeAttribSGIX;
typedef struct {
    Display * dpy;
    int networkId;
    int npipes;
    GLXHyperpipeConfigSGIX * cfg;
    int * hpId;
} ARGS_glXHyperpipeConfigSGIX;
typedef struct {
    int index;
    ARGS_glXHyperpipeConfigSGIX args;
} PACKED_glXHyperpipeConfigSGIX;
typedef struct {
    Display * dpy;
    GLXContextID contextID;
} ARGS_glXImportContextEXT;
typedef struct {
    int index;
    ARGS_glXImportContextEXT args;
} PACKED_glXImportContextEXT;
typedef struct {
    Display * dpy;
    GLXContext ctx;
} ARGS_glXIsDirect;
typedef struct {
    int index;
    ARGS_glXIsDirect args;
} PACKED_glXIsDirect;
typedef struct {
    Display * dpy;
    GLXDrawable drawable;
    GLuint group;
} ARGS_glXJoinSwapGroupNV;
typedef struct {
    int index;
    ARGS_glXJoinSwapGroupNV args;
} PACKED_glXJoinSwapGroupNV;
typedef struct {
    Display * dpy;
    GLXDrawable drawable;
    GLXDrawable member;
} ARGS_glXJoinSwapGroupSGIX;
typedef struct {
    int index;
    ARGS_glXJoinSwapGroupSGIX args;
} PACKED_glXJoinSwapGroupSGIX;
typedef struct {
    Display * dpy;
    GLXVideoCaptureDeviceNV device;
} ARGS_glXLockVideoCaptureDeviceNV;
typedef struct {
    int index;
    ARGS_glXLockVideoCaptureDeviceNV args;
} PACKED_glXLockVideoCaptureDeviceNV;
typedef struct {
    Display * dpy;
    GLXDrawable draw;
    GLXDrawable read;
    GLXContext ctx;
} ARGS_glXMakeContextCurrent;
typedef struct {
    int index;
    ARGS_glXMakeContextCurrent args;
} PACKED_glXMakeContextCurrent;
typedef struct {
    Display * dpy;
    GLXDrawable drawable;
    GLXContext ctx;
} ARGS_glXMakeCurrent;
typedef struct {
    int index;
    ARGS_glXMakeCurrent args;
} PACKED_glXMakeCurrent;
typedef struct {
    Display * dpy;
    GLXDrawable draw;
    GLXDrawable read;
    GLXContext ctx;
} ARGS_glXMakeCurrentReadSGI;
typedef struct {
    int index;
    ARGS_glXMakeCurrentReadSGI args;
} PACKED_glXMakeCurrentReadSGI;
typedef struct {
    Display * display;
    int screen;
    int channel;
    int * x;
    int * y;
    int * w;
    int * h;
} ARGS_glXQueryChannelDeltasSGIX;
typedef struct {
    int index;
    ARGS_glXQueryChannelDeltasSGIX args;
} PACKED_glXQueryChannelDeltasSGIX;
typedef struct {
    Display * display;
    int screen;
    int channel;
    int * dx;
    int * dy;
    int * dw;
    int * dh;
} ARGS_glXQueryChannelRectSGIX;
typedef struct {
    int index;
    ARGS_glXQueryChannelRectSGIX args;
} PACKED_glXQueryChannelRectSGIX;
typedef struct {
    Display * dpy;
    GLXContext ctx;
    int attribute;
    int * value;
} ARGS_glXQueryContext;
typedef struct {
    int index;
    ARGS_glXQueryContext args;
} PACKED_glXQueryContext;
typedef struct {
    Display * dpy;
    GLXContext context;
    int attribute;
    int * value;
} ARGS_glXQueryContextInfoEXT;
typedef struct {
    int index;
    ARGS_glXQueryContextInfoEXT args;
} PACKED_glXQueryContextInfoEXT;
typedef struct {
    Display * dpy;
    GLXDrawable draw;
    int attribute;
    unsigned int * value;
} ARGS_glXQueryDrawable;
typedef struct {
    int index;
    ARGS_glXQueryDrawable args;
} PACKED_glXQueryDrawable;
typedef struct {
    Display * display;
    int * errorBase;
    int * eventBase;
} ARGS_glXQueryExtension;
typedef struct {
    int index;
    ARGS_glXQueryExtension args;
} PACKED_glXQueryExtension;
typedef struct {
    Display * dpy;
    int screen;
} ARGS_glXQueryExtensionsString;
typedef struct {
    int index;
    ARGS_glXQueryExtensionsString args;
} PACKED_glXQueryExtensionsString;
typedef struct {
    Display * dpy;
    int screen;
    GLuint * count;
} ARGS_glXQueryFrameCountNV;
typedef struct {
    int index;
    ARGS_glXQueryFrameCountNV args;
} PACKED_glXQueryFrameCountNV;
typedef struct {
    Display * dpy;
    GLXPbufferSGIX pbuf;
    int attribute;
    unsigned int * value;
} ARGS_glXQueryGLXPbufferSGIX;
typedef struct {
    int index;
    ARGS_glXQueryGLXPbufferSGIX args;
} PACKED_glXQueryGLXPbufferSGIX;
typedef struct {
    Display * dpy;
    int timeSlice;
    int attrib;
    int size;
    void * returnAttribList;
} ARGS_glXQueryHyperpipeAttribSGIX;
typedef struct {
    int index;
    ARGS_glXQueryHyperpipeAttribSGIX args;
} PACKED_glXQueryHyperpipeAttribSGIX;
typedef struct {
    Display * dpy;
    int timeSlice;
    int attrib;
    int size;
    void * attribList;
    void * returnAttribList;
} ARGS_glXQueryHyperpipeBestAttribSGIX;
typedef struct {
    int index;
    ARGS_glXQueryHyperpipeBestAttribSGIX args;
} PACKED_glXQueryHyperpipeBestAttribSGIX;
typedef struct {
    Display * dpy;
    int hpId;
    int * npipes;
} ARGS_glXQueryHyperpipeConfigSGIX;
typedef struct {
    int index;
    ARGS_glXQueryHyperpipeConfigSGIX args;
} PACKED_glXQueryHyperpipeConfigSGIX;
typedef struct {
    Display * dpy;
    int * npipes;
} ARGS_glXQueryHyperpipeNetworkSGIX;
typedef struct {
    int index;
    ARGS_glXQueryHyperpipeNetworkSGIX args;
} PACKED_glXQueryHyperpipeNetworkSGIX;
typedef struct {
    Display * dpy;
    int screen;
    int * max;
} ARGS_glXQueryMaxSwapBarriersSGIX;
typedef struct {
    int index;
    ARGS_glXQueryMaxSwapBarriersSGIX args;
} PACKED_glXQueryMaxSwapBarriersSGIX;
typedef struct {
    Display * dpy;
    int screen;
    GLuint * maxGroups;
    GLuint * maxBarriers;
} ARGS_glXQueryMaxSwapGroupsNV;
typedef struct {
    int index;
    ARGS_glXQueryMaxSwapGroupsNV args;
} PACKED_glXQueryMaxSwapGroupsNV;
typedef struct {
    Display * dpy;
    int screen;
    int name;
} ARGS_glXQueryServerString;
typedef struct {
    int index;
    ARGS_glXQueryServerString args;
} PACKED_glXQueryServerString;
typedef struct {
    Display * dpy;
    GLXDrawable drawable;
    GLuint * group;
    GLuint * barrier;
} ARGS_glXQuerySwapGroupNV;
typedef struct {
    int index;
    ARGS_glXQuerySwapGroupNV args;
} PACKED_glXQuerySwapGroupNV;
typedef struct {
    Display * dpy;
    int * maj;
    int * min;
} ARGS_glXQueryVersion;
typedef struct {
    int index;
    ARGS_glXQueryVersion args;
} PACKED_glXQueryVersion;
typedef struct {
    Display * dpy;
    GLXVideoCaptureDeviceNV device;
    int attribute;
    int * value;
} ARGS_glXQueryVideoCaptureDeviceNV;
typedef struct {
    int index;
    ARGS_glXQueryVideoCaptureDeviceNV args;
} PACKED_glXQueryVideoCaptureDeviceNV;
typedef struct {
    Display * dpy;
    GLXDrawable drawable;
} ARGS_glXReleaseBuffersMESA;
typedef struct {
    int index;
    ARGS_glXReleaseBuffersMESA args;
} PACKED_glXReleaseBuffersMESA;
typedef struct {
    Display * dpy;
    GLXDrawable drawable;
    int buffer;
} ARGS_glXReleaseTexImageEXT;
typedef struct {
    int index;
    ARGS_glXReleaseTexImageEXT args;
} PACKED_glXReleaseTexImageEXT;
typedef struct {
    Display * dpy;
    GLXVideoCaptureDeviceNV device;
} ARGS_glXReleaseVideoCaptureDeviceNV;
typedef struct {
    int index;
    ARGS_glXReleaseVideoCaptureDeviceNV args;
} PACKED_glXReleaseVideoCaptureDeviceNV;
typedef struct {
    Display * dpy;
    int screen;
    GLXVideoDeviceNV VideoDevice;
} ARGS_glXReleaseVideoDeviceNV;
typedef struct {
    int index;
    ARGS_glXReleaseVideoDeviceNV args;
} PACKED_glXReleaseVideoDeviceNV;
typedef struct {
    Display * dpy;
    GLXPbuffer pbuf;
} ARGS_glXReleaseVideoImageNV;
typedef struct {
    int index;
    ARGS_glXReleaseVideoImageNV args;
} PACKED_glXReleaseVideoImageNV;
typedef struct {
    int index;
} PACKED_glXRender;
typedef struct {
    int index;
} PACKED_glXRenderLarge;
typedef struct {
    Display * dpy;
    int screen;
} ARGS_glXResetFrameCountNV;
typedef struct {
    int index;
    ARGS_glXResetFrameCountNV args;
} PACKED_glXResetFrameCountNV;
typedef struct {
    Display * dpy;
    GLXDrawable draw;
    unsigned long event_mask;
} ARGS_glXSelectEvent;
typedef struct {
    int index;
    ARGS_glXSelectEvent args;
} PACKED_glXSelectEvent;
typedef struct {
    Display * dpy;
    GLXDrawable drawable;
    unsigned long mask;
} ARGS_glXSelectEventSGIX;
typedef struct {
    int index;
    ARGS_glXSelectEventSGIX args;
} PACKED_glXSelectEventSGIX;
typedef struct {
    Display * dpy;
    GLXPbuffer pbuf;
    int iBufferType;
    unsigned long * pulCounterPbuffer;
    GLboolean bBlock;
} ARGS_glXSendPbufferToVideoNV;
typedef struct {
    int index;
    ARGS_glXSendPbufferToVideoNV args;
} PACKED_glXSendPbufferToVideoNV;
typedef struct {
    int mode;
} ARGS_glXSet3DfxModeMESA;
typedef struct {
    int index;
    ARGS_glXSet3DfxModeMESA args;
} PACKED_glXSet3DfxModeMESA;
typedef struct {
    Display * dpy;
    GLXDrawable drawable;
} ARGS_glXSwapBuffers;
typedef struct {
    int index;
    ARGS_glXSwapBuffers args;
} PACKED_glXSwapBuffers;
typedef struct {
    Display * dpy;
    GLXDrawable drawable;
    int64_t target_msc;
    int64_t divisor;
    int64_t remainder;
} ARGS_glXSwapBuffersMscOML;
typedef struct {
    int index;
    ARGS_glXSwapBuffersMscOML args;
} PACKED_glXSwapBuffersMscOML;
typedef struct {
    Display * dpy;
    GLXDrawable drawable;
    int interval;
} ARGS_glXSwapIntervalEXT;
typedef struct {
    int index;
    ARGS_glXSwapIntervalEXT args;
} PACKED_glXSwapIntervalEXT;
typedef struct {
    unsigned int interval;
} ARGS_glXSwapIntervalMESA;
typedef struct {
    int index;
    ARGS_glXSwapIntervalMESA args;
} PACKED_glXSwapIntervalMESA;
typedef struct {
    int interval;
} ARGS_glXSwapIntervalSGI;
typedef struct {
    int index;
    ARGS_glXSwapIntervalSGI args;
} PACKED_glXSwapIntervalSGI;
typedef struct {
    Font font;
    int first;
    int count;
    int listBase;
} ARGS_glXUseXFont;
typedef struct {
    int index;
    ARGS_glXUseXFont args;
} PACKED_glXUseXFont;
typedef struct {
    int index;
} PACKED_glXVendorPrivate;
typedef struct {
    int index;
} PACKED_glXVendorPrivateWithReply;
typedef struct {
    Display * dpy;
    GLXDrawable drawable;
    int64_t target_msc;
    int64_t divisor;
    int64_t remainder;
    int64_t * ust;
    int64_t * msc;
    int64_t * sbc;
} ARGS_glXWaitForMscOML;
typedef struct {
    int index;
    ARGS_glXWaitForMscOML args;
} PACKED_glXWaitForMscOML;
typedef struct {
    Display * dpy;
    GLXDrawable drawable;
    int64_t target_sbc;
    int64_t * ust;
    int64_t * msc;
    int64_t * sbc;
} ARGS_glXWaitForSbcOML;
typedef struct {
    int index;
    ARGS_glXWaitForSbcOML args;
} PACKED_glXWaitForSbcOML;
typedef struct {
    int index;
} PACKED_glXWaitGL;
typedef struct {
    int divisor;
    int remainder;
    unsigned int * count;
} ARGS_glXWaitVideoSyncSGI;
typedef struct {
    int index;
    ARGS_glXWaitVideoSyncSGI args;
} PACKED_glXWaitVideoSyncSGI;
typedef struct {
    int index;
} PACKED_glXWaitX;

extern const int INDEX_RET_SIZE[];
extern const int INDEX_PACKED_SIZE[];
extern const char *INDEX_NAME[];
extern void glPushCall(void *data);
void glIndexedCall(const packed_call_t *packed, void *ret_v);
void glIndexedPrint(const packed_call_t *packed);

#define eglBindAPI_INDEX 1
#define eglBindAPI_RETURN EGLBoolean
#define eglBindAPI_ARG_NAMES api
#define eglBindAPI_ARG_EXPAND EGLenum api
#define eglBindAPI_PACKED PACKED_eglBindAPI
#define eglBindAPI_VOID_ONLY_WRAP(...) {}
#define eglBindAPI_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_eglBindAPI(_api) ({ \
    eglBindAPI_PACKED *packed_data = malloc(sizeof(eglBindAPI_PACKED)); \
    packed_data->index = eglBindAPI_INDEX; \
    packed_data->args.api = (EGLenum)_api; \
    (packed_call_t *)packed_data; \
})
#define call_eglBindAPI(packed, ret_v) do { \
    PACKED_eglBindAPI *unpacked = (PACKED_eglBindAPI *)packed; \
    ARGS_eglBindAPI *args = (ARGS_eglBindAPI *)&unpacked->args; \
    EGLBoolean *ret = (EGLBoolean *)ret_v; \
    if (ret != NULL) { \
        *ret = eglBindAPI(args->api);; \
    } else { \
        eglBindAPI(args->api);; \
    } \
} while(0)
EGLBoolean eglBindAPI(eglBindAPI_ARG_EXPAND);
typedef EGLBoolean (*eglBindAPI_PTR)(eglBindAPI_ARG_EXPAND);
#define eglBindTexImage_INDEX 2
#define eglBindTexImage_RETURN EGLBoolean
#define eglBindTexImage_ARG_NAMES dpy, surface, buffer
#define eglBindTexImage_ARG_EXPAND EGLDisplay dpy, EGLSurface surface, EGLint buffer
#define eglBindTexImage_PACKED PACKED_eglBindTexImage
#define eglBindTexImage_VOID_ONLY_WRAP(...) {}
#define eglBindTexImage_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_eglBindTexImage(_dpy, _surface, _buffer) ({ \
    eglBindTexImage_PACKED *packed_data = malloc(sizeof(eglBindTexImage_PACKED)); \
    packed_data->index = eglBindTexImage_INDEX; \
    packed_data->args.dpy = (EGLDisplay)_dpy; \
    packed_data->args.surface = (EGLSurface)_surface; \
    packed_data->args.buffer = (EGLint)_buffer; \
    (packed_call_t *)packed_data; \
})
#define call_eglBindTexImage(packed, ret_v) do { \
    PACKED_eglBindTexImage *unpacked = (PACKED_eglBindTexImage *)packed; \
    ARGS_eglBindTexImage *args = (ARGS_eglBindTexImage *)&unpacked->args; \
    EGLBoolean *ret = (EGLBoolean *)ret_v; \
    if (ret != NULL) { \
        *ret = eglBindTexImage(args->dpy, args->surface, args->buffer);; \
    } else { \
        eglBindTexImage(args->dpy, args->surface, args->buffer);; \
    } \
} while(0)
EGLBoolean eglBindTexImage(eglBindTexImage_ARG_EXPAND);
typedef EGLBoolean (*eglBindTexImage_PTR)(eglBindTexImage_ARG_EXPAND);
#define eglChooseConfig_INDEX 3
#define eglChooseConfig_RETURN EGLBoolean
#define eglChooseConfig_ARG_NAMES dpy, attrib_list, configs, config_size, num_config
#define eglChooseConfig_ARG_EXPAND EGLDisplay dpy, const EGLint * attrib_list, EGLConfig * configs, EGLint config_size, EGLint * num_config
#define eglChooseConfig_PACKED PACKED_eglChooseConfig
#define eglChooseConfig_VOID_ONLY_WRAP(...) {}
#define eglChooseConfig_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_eglChooseConfig(_dpy, _attrib_list, _configs, _config_size, _num_config) ({ \
    eglChooseConfig_PACKED *packed_data = malloc(sizeof(eglChooseConfig_PACKED)); \
    packed_data->index = eglChooseConfig_INDEX; \
    packed_data->args.dpy = (EGLDisplay)_dpy; \
    packed_data->args.attrib_list = (EGLint *)_attrib_list; \
    packed_data->args.configs = (EGLConfig *)_configs; \
    packed_data->args.config_size = (EGLint)_config_size; \
    packed_data->args.num_config = (EGLint *)_num_config; \
    (packed_call_t *)packed_data; \
})
#define call_eglChooseConfig(packed, ret_v) do { \
    PACKED_eglChooseConfig *unpacked = (PACKED_eglChooseConfig *)packed; \
    ARGS_eglChooseConfig *args = (ARGS_eglChooseConfig *)&unpacked->args; \
    EGLBoolean *ret = (EGLBoolean *)ret_v; \
    if (ret != NULL) { \
        *ret = eglChooseConfig(args->dpy, args->attrib_list, args->configs, args->config_size, args->num_config);; \
    } else { \
        eglChooseConfig(args->dpy, args->attrib_list, args->configs, args->config_size, args->num_config);; \
    } \
} while(0)
EGLBoolean eglChooseConfig(eglChooseConfig_ARG_EXPAND);
typedef EGLBoolean (*eglChooseConfig_PTR)(eglChooseConfig_ARG_EXPAND);
#define eglClientWaitSyncKHR_INDEX 4
#define eglClientWaitSyncKHR_RETURN EGLint
#define eglClientWaitSyncKHR_ARG_NAMES dpy, sync, flags, timeout
#define eglClientWaitSyncKHR_ARG_EXPAND EGLDisplay dpy, EGLSyncKHR sync, EGLint flags, EGLTimeKHR timeout
#define eglClientWaitSyncKHR_PACKED PACKED_eglClientWaitSyncKHR
#define eglClientWaitSyncKHR_VOID_ONLY_WRAP(...) {}
#define eglClientWaitSyncKHR_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_eglClientWaitSyncKHR(_dpy, _sync, _flags, _timeout) ({ \
    eglClientWaitSyncKHR_PACKED *packed_data = malloc(sizeof(eglClientWaitSyncKHR_PACKED)); \
    packed_data->index = eglClientWaitSyncKHR_INDEX; \
    packed_data->args.dpy = (EGLDisplay)_dpy; \
    packed_data->args.sync = (EGLSyncKHR)_sync; \
    packed_data->args.flags = (EGLint)_flags; \
    packed_data->args.timeout = (EGLTimeKHR)_timeout; \
    (packed_call_t *)packed_data; \
})
#define call_eglClientWaitSyncKHR(packed, ret_v) do { \
    PACKED_eglClientWaitSyncKHR *unpacked = (PACKED_eglClientWaitSyncKHR *)packed; \
    ARGS_eglClientWaitSyncKHR *args = (ARGS_eglClientWaitSyncKHR *)&unpacked->args; \
    EGLint *ret = (EGLint *)ret_v; \
    if (ret != NULL) { \
        *ret = eglClientWaitSyncKHR(args->dpy, args->sync, args->flags, args->timeout);; \
    } else { \
        eglClientWaitSyncKHR(args->dpy, args->sync, args->flags, args->timeout);; \
    } \
} while(0)
EGLint eglClientWaitSyncKHR(eglClientWaitSyncKHR_ARG_EXPAND);
typedef EGLint (*eglClientWaitSyncKHR_PTR)(eglClientWaitSyncKHR_ARG_EXPAND);
#define eglClientWaitSyncNV_INDEX 5
#define eglClientWaitSyncNV_RETURN EGLint
#define eglClientWaitSyncNV_ARG_NAMES sync, flags, timeout
#define eglClientWaitSyncNV_ARG_EXPAND EGLSyncNV sync, EGLint flags, EGLTimeNV timeout
#define eglClientWaitSyncNV_PACKED PACKED_eglClientWaitSyncNV
#define eglClientWaitSyncNV_VOID_ONLY_WRAP(...) {}
#define eglClientWaitSyncNV_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_eglClientWaitSyncNV(_sync, _flags, _timeout) ({ \
    eglClientWaitSyncNV_PACKED *packed_data = malloc(sizeof(eglClientWaitSyncNV_PACKED)); \
    packed_data->index = eglClientWaitSyncNV_INDEX; \
    packed_data->args.sync = (EGLSyncNV)_sync; \
    packed_data->args.flags = (EGLint)_flags; \
    packed_data->args.timeout = (EGLTimeNV)_timeout; \
    (packed_call_t *)packed_data; \
})
#define call_eglClientWaitSyncNV(packed, ret_v) do { \
    PACKED_eglClientWaitSyncNV *unpacked = (PACKED_eglClientWaitSyncNV *)packed; \
    ARGS_eglClientWaitSyncNV *args = (ARGS_eglClientWaitSyncNV *)&unpacked->args; \
    EGLint *ret = (EGLint *)ret_v; \
    if (ret != NULL) { \
        *ret = eglClientWaitSyncNV(args->sync, args->flags, args->timeout);; \
    } else { \
        eglClientWaitSyncNV(args->sync, args->flags, args->timeout);; \
    } \
} while(0)
EGLint eglClientWaitSyncNV(eglClientWaitSyncNV_ARG_EXPAND);
typedef EGLint (*eglClientWaitSyncNV_PTR)(eglClientWaitSyncNV_ARG_EXPAND);
#define eglCopyBuffers_INDEX 6
#define eglCopyBuffers_RETURN EGLBoolean
#define eglCopyBuffers_ARG_NAMES dpy, surface, target
#define eglCopyBuffers_ARG_EXPAND EGLDisplay dpy, EGLSurface surface, EGLNativePixmapType target
#define eglCopyBuffers_PACKED PACKED_eglCopyBuffers
#define eglCopyBuffers_VOID_ONLY_WRAP(...) {}
#define eglCopyBuffers_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_eglCopyBuffers(_dpy, _surface, _target) ({ \
    eglCopyBuffers_PACKED *packed_data = malloc(sizeof(eglCopyBuffers_PACKED)); \
    packed_data->index = eglCopyBuffers_INDEX; \
    packed_data->args.dpy = (EGLDisplay)_dpy; \
    packed_data->args.surface = (EGLSurface)_surface; \
    packed_data->args.target = (EGLNativePixmapType)_target; \
    (packed_call_t *)packed_data; \
})
#define call_eglCopyBuffers(packed, ret_v) do { \
    PACKED_eglCopyBuffers *unpacked = (PACKED_eglCopyBuffers *)packed; \
    ARGS_eglCopyBuffers *args = (ARGS_eglCopyBuffers *)&unpacked->args; \
    EGLBoolean *ret = (EGLBoolean *)ret_v; \
    if (ret != NULL) { \
        *ret = eglCopyBuffers(args->dpy, args->surface, args->target);; \
    } else { \
        eglCopyBuffers(args->dpy, args->surface, args->target);; \
    } \
} while(0)
EGLBoolean eglCopyBuffers(eglCopyBuffers_ARG_EXPAND);
typedef EGLBoolean (*eglCopyBuffers_PTR)(eglCopyBuffers_ARG_EXPAND);
#define eglCreateContext_INDEX 7
#define eglCreateContext_RETURN EGLContext
#define eglCreateContext_ARG_NAMES dpy, config, share_context, attrib_list
#define eglCreateContext_ARG_EXPAND EGLDisplay dpy, EGLConfig config, EGLContext share_context, const EGLint * attrib_list
#define eglCreateContext_PACKED PACKED_eglCreateContext
#define eglCreateContext_VOID_ONLY_WRAP(...) {}
#define eglCreateContext_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_eglCreateContext(_dpy, _config, _share_context, _attrib_list) ({ \
    eglCreateContext_PACKED *packed_data = malloc(sizeof(eglCreateContext_PACKED)); \
    packed_data->index = eglCreateContext_INDEX; \
    packed_data->args.dpy = (EGLDisplay)_dpy; \
    packed_data->args.config = (EGLConfig)_config; \
    packed_data->args.share_context = (EGLContext)_share_context; \
    packed_data->args.attrib_list = (EGLint *)_attrib_list; \
    (packed_call_t *)packed_data; \
})
#define call_eglCreateContext(packed, ret_v) do { \
    PACKED_eglCreateContext *unpacked = (PACKED_eglCreateContext *)packed; \
    ARGS_eglCreateContext *args = (ARGS_eglCreateContext *)&unpacked->args; \
    EGLContext *ret = (EGLContext *)ret_v; \
    if (ret != NULL) { \
        *ret = eglCreateContext(args->dpy, args->config, args->share_context, args->attrib_list);; \
    } else { \
        eglCreateContext(args->dpy, args->config, args->share_context, args->attrib_list);; \
    } \
} while(0)
EGLContext eglCreateContext(eglCreateContext_ARG_EXPAND);
typedef EGLContext (*eglCreateContext_PTR)(eglCreateContext_ARG_EXPAND);
#define eglCreateDRMImageMESA_INDEX 8
#define eglCreateDRMImageMESA_RETURN EGLImageKHR
#define eglCreateDRMImageMESA_ARG_NAMES dpy, attrib_list
#define eglCreateDRMImageMESA_ARG_EXPAND EGLDisplay dpy, const EGLint * attrib_list
#define eglCreateDRMImageMESA_PACKED PACKED_eglCreateDRMImageMESA
#define eglCreateDRMImageMESA_VOID_ONLY_WRAP(...) {}
#define eglCreateDRMImageMESA_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_eglCreateDRMImageMESA(_dpy, _attrib_list) ({ \
    eglCreateDRMImageMESA_PACKED *packed_data = malloc(sizeof(eglCreateDRMImageMESA_PACKED)); \
    packed_data->index = eglCreateDRMImageMESA_INDEX; \
    packed_data->args.dpy = (EGLDisplay)_dpy; \
    packed_data->args.attrib_list = (EGLint *)_attrib_list; \
    (packed_call_t *)packed_data; \
})
#define call_eglCreateDRMImageMESA(packed, ret_v) do { \
    PACKED_eglCreateDRMImageMESA *unpacked = (PACKED_eglCreateDRMImageMESA *)packed; \
    ARGS_eglCreateDRMImageMESA *args = (ARGS_eglCreateDRMImageMESA *)&unpacked->args; \
    EGLImageKHR *ret = (EGLImageKHR *)ret_v; \
    if (ret != NULL) { \
        *ret = eglCreateDRMImageMESA(args->dpy, args->attrib_list);; \
    } else { \
        eglCreateDRMImageMESA(args->dpy, args->attrib_list);; \
    } \
} while(0)
EGLImageKHR eglCreateDRMImageMESA(eglCreateDRMImageMESA_ARG_EXPAND);
typedef EGLImageKHR (*eglCreateDRMImageMESA_PTR)(eglCreateDRMImageMESA_ARG_EXPAND);
#define eglCreateFenceSyncNV_INDEX 9
#define eglCreateFenceSyncNV_RETURN EGLSyncNV
#define eglCreateFenceSyncNV_ARG_NAMES dpy, condition, attrib_list
#define eglCreateFenceSyncNV_ARG_EXPAND EGLDisplay dpy, EGLenum condition, const EGLint * attrib_list
#define eglCreateFenceSyncNV_PACKED PACKED_eglCreateFenceSyncNV
#define eglCreateFenceSyncNV_VOID_ONLY_WRAP(...) {}
#define eglCreateFenceSyncNV_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_eglCreateFenceSyncNV(_dpy, _condition, _attrib_list) ({ \
    eglCreateFenceSyncNV_PACKED *packed_data = malloc(sizeof(eglCreateFenceSyncNV_PACKED)); \
    packed_data->index = eglCreateFenceSyncNV_INDEX; \
    packed_data->args.dpy = (EGLDisplay)_dpy; \
    packed_data->args.condition = (EGLenum)_condition; \
    packed_data->args.attrib_list = (EGLint *)_attrib_list; \
    (packed_call_t *)packed_data; \
})
#define call_eglCreateFenceSyncNV(packed, ret_v) do { \
    PACKED_eglCreateFenceSyncNV *unpacked = (PACKED_eglCreateFenceSyncNV *)packed; \
    ARGS_eglCreateFenceSyncNV *args = (ARGS_eglCreateFenceSyncNV *)&unpacked->args; \
    EGLSyncNV *ret = (EGLSyncNV *)ret_v; \
    if (ret != NULL) { \
        *ret = eglCreateFenceSyncNV(args->dpy, args->condition, args->attrib_list);; \
    } else { \
        eglCreateFenceSyncNV(args->dpy, args->condition, args->attrib_list);; \
    } \
} while(0)
EGLSyncNV eglCreateFenceSyncNV(eglCreateFenceSyncNV_ARG_EXPAND);
typedef EGLSyncNV (*eglCreateFenceSyncNV_PTR)(eglCreateFenceSyncNV_ARG_EXPAND);
#define eglCreateImageKHR_INDEX 10
#define eglCreateImageKHR_RETURN EGLImageKHR
#define eglCreateImageKHR_ARG_NAMES dpy, ctx, target, buffer, attrib_list
#define eglCreateImageKHR_ARG_EXPAND EGLDisplay dpy, EGLContext ctx, EGLenum target, EGLClientBuffer buffer, const EGLint * attrib_list
#define eglCreateImageKHR_PACKED PACKED_eglCreateImageKHR
#define eglCreateImageKHR_VOID_ONLY_WRAP(...) {}
#define eglCreateImageKHR_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_eglCreateImageKHR(_dpy, _ctx, _target, _buffer, _attrib_list) ({ \
    eglCreateImageKHR_PACKED *packed_data = malloc(sizeof(eglCreateImageKHR_PACKED)); \
    packed_data->index = eglCreateImageKHR_INDEX; \
    packed_data->args.dpy = (EGLDisplay)_dpy; \
    packed_data->args.ctx = (EGLContext)_ctx; \
    packed_data->args.target = (EGLenum)_target; \
    packed_data->args.buffer = (EGLClientBuffer)_buffer; \
    packed_data->args.attrib_list = (EGLint *)_attrib_list; \
    (packed_call_t *)packed_data; \
})
#define call_eglCreateImageKHR(packed, ret_v) do { \
    PACKED_eglCreateImageKHR *unpacked = (PACKED_eglCreateImageKHR *)packed; \
    ARGS_eglCreateImageKHR *args = (ARGS_eglCreateImageKHR *)&unpacked->args; \
    EGLImageKHR *ret = (EGLImageKHR *)ret_v; \
    if (ret != NULL) { \
        *ret = eglCreateImageKHR(args->dpy, args->ctx, args->target, args->buffer, args->attrib_list);; \
    } else { \
        eglCreateImageKHR(args->dpy, args->ctx, args->target, args->buffer, args->attrib_list);; \
    } \
} while(0)
EGLImageKHR eglCreateImageKHR(eglCreateImageKHR_ARG_EXPAND);
typedef EGLImageKHR (*eglCreateImageKHR_PTR)(eglCreateImageKHR_ARG_EXPAND);
#define eglCreatePbufferFromClientBuffer_INDEX 11
#define eglCreatePbufferFromClientBuffer_RETURN EGLSurface
#define eglCreatePbufferFromClientBuffer_ARG_NAMES dpy, buftype, buffer, config, attrib_list
#define eglCreatePbufferFromClientBuffer_ARG_EXPAND EGLDisplay dpy, EGLenum buftype, EGLClientBuffer buffer, EGLConfig config, const EGLint * attrib_list
#define eglCreatePbufferFromClientBuffer_PACKED PACKED_eglCreatePbufferFromClientBuffer
#define eglCreatePbufferFromClientBuffer_VOID_ONLY_WRAP(...) {}
#define eglCreatePbufferFromClientBuffer_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_eglCreatePbufferFromClientBuffer(_dpy, _buftype, _buffer, _config, _attrib_list) ({ \
    eglCreatePbufferFromClientBuffer_PACKED *packed_data = malloc(sizeof(eglCreatePbufferFromClientBuffer_PACKED)); \
    packed_data->index = eglCreatePbufferFromClientBuffer_INDEX; \
    packed_data->args.dpy = (EGLDisplay)_dpy; \
    packed_data->args.buftype = (EGLenum)_buftype; \
    packed_data->args.buffer = (EGLClientBuffer)_buffer; \
    packed_data->args.config = (EGLConfig)_config; \
    packed_data->args.attrib_list = (EGLint *)_attrib_list; \
    (packed_call_t *)packed_data; \
})
#define call_eglCreatePbufferFromClientBuffer(packed, ret_v) do { \
    PACKED_eglCreatePbufferFromClientBuffer *unpacked = (PACKED_eglCreatePbufferFromClientBuffer *)packed; \
    ARGS_eglCreatePbufferFromClientBuffer *args = (ARGS_eglCreatePbufferFromClientBuffer *)&unpacked->args; \
    EGLSurface *ret = (EGLSurface *)ret_v; \
    if (ret != NULL) { \
        *ret = eglCreatePbufferFromClientBuffer(args->dpy, args->buftype, args->buffer, args->config, args->attrib_list);; \
    } else { \
        eglCreatePbufferFromClientBuffer(args->dpy, args->buftype, args->buffer, args->config, args->attrib_list);; \
    } \
} while(0)
EGLSurface eglCreatePbufferFromClientBuffer(eglCreatePbufferFromClientBuffer_ARG_EXPAND);
typedef EGLSurface (*eglCreatePbufferFromClientBuffer_PTR)(eglCreatePbufferFromClientBuffer_ARG_EXPAND);
#define eglCreatePbufferSurface_INDEX 12
#define eglCreatePbufferSurface_RETURN EGLSurface
#define eglCreatePbufferSurface_ARG_NAMES dpy, config, attrib_list
#define eglCreatePbufferSurface_ARG_EXPAND EGLDisplay dpy, EGLConfig config, const EGLint * attrib_list
#define eglCreatePbufferSurface_PACKED PACKED_eglCreatePbufferSurface
#define eglCreatePbufferSurface_VOID_ONLY_WRAP(...) {}
#define eglCreatePbufferSurface_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_eglCreatePbufferSurface(_dpy, _config, _attrib_list) ({ \
    eglCreatePbufferSurface_PACKED *packed_data = malloc(sizeof(eglCreatePbufferSurface_PACKED)); \
    packed_data->index = eglCreatePbufferSurface_INDEX; \
    packed_data->args.dpy = (EGLDisplay)_dpy; \
    packed_data->args.config = (EGLConfig)_config; \
    packed_data->args.attrib_list = (EGLint *)_attrib_list; \
    (packed_call_t *)packed_data; \
})
#define call_eglCreatePbufferSurface(packed, ret_v) do { \
    PACKED_eglCreatePbufferSurface *unpacked = (PACKED_eglCreatePbufferSurface *)packed; \
    ARGS_eglCreatePbufferSurface *args = (ARGS_eglCreatePbufferSurface *)&unpacked->args; \
    EGLSurface *ret = (EGLSurface *)ret_v; \
    if (ret != NULL) { \
        *ret = eglCreatePbufferSurface(args->dpy, args->config, args->attrib_list);; \
    } else { \
        eglCreatePbufferSurface(args->dpy, args->config, args->attrib_list);; \
    } \
} while(0)
EGLSurface eglCreatePbufferSurface(eglCreatePbufferSurface_ARG_EXPAND);
typedef EGLSurface (*eglCreatePbufferSurface_PTR)(eglCreatePbufferSurface_ARG_EXPAND);
#define eglCreatePixmapSurface_INDEX 13
#define eglCreatePixmapSurface_RETURN EGLSurface
#define eglCreatePixmapSurface_ARG_NAMES dpy, config, pixmap, attrib_list
#define eglCreatePixmapSurface_ARG_EXPAND EGLDisplay dpy, EGLConfig config, EGLNativePixmapType pixmap, const EGLint * attrib_list
#define eglCreatePixmapSurface_PACKED PACKED_eglCreatePixmapSurface
#define eglCreatePixmapSurface_VOID_ONLY_WRAP(...) {}
#define eglCreatePixmapSurface_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_eglCreatePixmapSurface(_dpy, _config, _pixmap, _attrib_list) ({ \
    eglCreatePixmapSurface_PACKED *packed_data = malloc(sizeof(eglCreatePixmapSurface_PACKED)); \
    packed_data->index = eglCreatePixmapSurface_INDEX; \
    packed_data->args.dpy = (EGLDisplay)_dpy; \
    packed_data->args.config = (EGLConfig)_config; \
    packed_data->args.pixmap = (EGLNativePixmapType)_pixmap; \
    packed_data->args.attrib_list = (EGLint *)_attrib_list; \
    (packed_call_t *)packed_data; \
})
#define call_eglCreatePixmapSurface(packed, ret_v) do { \
    PACKED_eglCreatePixmapSurface *unpacked = (PACKED_eglCreatePixmapSurface *)packed; \
    ARGS_eglCreatePixmapSurface *args = (ARGS_eglCreatePixmapSurface *)&unpacked->args; \
    EGLSurface *ret = (EGLSurface *)ret_v; \
    if (ret != NULL) { \
        *ret = eglCreatePixmapSurface(args->dpy, args->config, args->pixmap, args->attrib_list);; \
    } else { \
        eglCreatePixmapSurface(args->dpy, args->config, args->pixmap, args->attrib_list);; \
    } \
} while(0)
EGLSurface eglCreatePixmapSurface(eglCreatePixmapSurface_ARG_EXPAND);
typedef EGLSurface (*eglCreatePixmapSurface_PTR)(eglCreatePixmapSurface_ARG_EXPAND);
#define eglCreatePixmapSurfaceHI_INDEX 14
#define eglCreatePixmapSurfaceHI_RETURN EGLSurface
#define eglCreatePixmapSurfaceHI_ARG_NAMES dpy, config, pixmap
#define eglCreatePixmapSurfaceHI_ARG_EXPAND EGLDisplay dpy, EGLConfig config, struct EGLClientPixmapHI * pixmap
#define eglCreatePixmapSurfaceHI_PACKED PACKED_eglCreatePixmapSurfaceHI
#define eglCreatePixmapSurfaceHI_VOID_ONLY_WRAP(...) {}
#define eglCreatePixmapSurfaceHI_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_eglCreatePixmapSurfaceHI(_dpy, _config, _pixmap) ({ \
    eglCreatePixmapSurfaceHI_PACKED *packed_data = malloc(sizeof(eglCreatePixmapSurfaceHI_PACKED)); \
    packed_data->index = eglCreatePixmapSurfaceHI_INDEX; \
    packed_data->args.dpy = (EGLDisplay)_dpy; \
    packed_data->args.config = (EGLConfig)_config; \
    packed_data->args.pixmap = (struct EGLClientPixmapHI *)_pixmap; \
    (packed_call_t *)packed_data; \
})
#define call_eglCreatePixmapSurfaceHI(packed, ret_v) do { \
    PACKED_eglCreatePixmapSurfaceHI *unpacked = (PACKED_eglCreatePixmapSurfaceHI *)packed; \
    ARGS_eglCreatePixmapSurfaceHI *args = (ARGS_eglCreatePixmapSurfaceHI *)&unpacked->args; \
    EGLSurface *ret = (EGLSurface *)ret_v; \
    if (ret != NULL) { \
        *ret = eglCreatePixmapSurfaceHI(args->dpy, args->config, args->pixmap);; \
    } else { \
        eglCreatePixmapSurfaceHI(args->dpy, args->config, args->pixmap);; \
    } \
} while(0)
EGLSurface eglCreatePixmapSurfaceHI(eglCreatePixmapSurfaceHI_ARG_EXPAND);
typedef EGLSurface (*eglCreatePixmapSurfaceHI_PTR)(eglCreatePixmapSurfaceHI_ARG_EXPAND);
#define eglCreateStreamFromFileDescriptorKHR_INDEX 15
#define eglCreateStreamFromFileDescriptorKHR_RETURN EGLStreamKHR
#define eglCreateStreamFromFileDescriptorKHR_ARG_NAMES dpy, file_descriptor
#define eglCreateStreamFromFileDescriptorKHR_ARG_EXPAND EGLDisplay dpy, EGLNativeFileDescriptorKHR file_descriptor
#define eglCreateStreamFromFileDescriptorKHR_PACKED PACKED_eglCreateStreamFromFileDescriptorKHR
#define eglCreateStreamFromFileDescriptorKHR_VOID_ONLY_WRAP(...) {}
#define eglCreateStreamFromFileDescriptorKHR_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_eglCreateStreamFromFileDescriptorKHR(_dpy, _file_descriptor) ({ \
    eglCreateStreamFromFileDescriptorKHR_PACKED *packed_data = malloc(sizeof(eglCreateStreamFromFileDescriptorKHR_PACKED)); \
    packed_data->index = eglCreateStreamFromFileDescriptorKHR_INDEX; \
    packed_data->args.dpy = (EGLDisplay)_dpy; \
    packed_data->args.file_descriptor = (EGLNativeFileDescriptorKHR)_file_descriptor; \
    (packed_call_t *)packed_data; \
})
#define call_eglCreateStreamFromFileDescriptorKHR(packed, ret_v) do { \
    PACKED_eglCreateStreamFromFileDescriptorKHR *unpacked = (PACKED_eglCreateStreamFromFileDescriptorKHR *)packed; \
    ARGS_eglCreateStreamFromFileDescriptorKHR *args = (ARGS_eglCreateStreamFromFileDescriptorKHR *)&unpacked->args; \
    EGLStreamKHR *ret = (EGLStreamKHR *)ret_v; \
    if (ret != NULL) { \
        *ret = eglCreateStreamFromFileDescriptorKHR(args->dpy, args->file_descriptor);; \
    } else { \
        eglCreateStreamFromFileDescriptorKHR(args->dpy, args->file_descriptor);; \
    } \
} while(0)
EGLStreamKHR eglCreateStreamFromFileDescriptorKHR(eglCreateStreamFromFileDescriptorKHR_ARG_EXPAND);
typedef EGLStreamKHR (*eglCreateStreamFromFileDescriptorKHR_PTR)(eglCreateStreamFromFileDescriptorKHR_ARG_EXPAND);
#define eglCreateStreamKHR_INDEX 16
#define eglCreateStreamKHR_RETURN EGLStreamKHR
#define eglCreateStreamKHR_ARG_NAMES dpy, attrib_list
#define eglCreateStreamKHR_ARG_EXPAND EGLDisplay dpy, const EGLint * attrib_list
#define eglCreateStreamKHR_PACKED PACKED_eglCreateStreamKHR
#define eglCreateStreamKHR_VOID_ONLY_WRAP(...) {}
#define eglCreateStreamKHR_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_eglCreateStreamKHR(_dpy, _attrib_list) ({ \
    eglCreateStreamKHR_PACKED *packed_data = malloc(sizeof(eglCreateStreamKHR_PACKED)); \
    packed_data->index = eglCreateStreamKHR_INDEX; \
    packed_data->args.dpy = (EGLDisplay)_dpy; \
    packed_data->args.attrib_list = (EGLint *)_attrib_list; \
    (packed_call_t *)packed_data; \
})
#define call_eglCreateStreamKHR(packed, ret_v) do { \
    PACKED_eglCreateStreamKHR *unpacked = (PACKED_eglCreateStreamKHR *)packed; \
    ARGS_eglCreateStreamKHR *args = (ARGS_eglCreateStreamKHR *)&unpacked->args; \
    EGLStreamKHR *ret = (EGLStreamKHR *)ret_v; \
    if (ret != NULL) { \
        *ret = eglCreateStreamKHR(args->dpy, args->attrib_list);; \
    } else { \
        eglCreateStreamKHR(args->dpy, args->attrib_list);; \
    } \
} while(0)
EGLStreamKHR eglCreateStreamKHR(eglCreateStreamKHR_ARG_EXPAND);
typedef EGLStreamKHR (*eglCreateStreamKHR_PTR)(eglCreateStreamKHR_ARG_EXPAND);
#define eglCreateStreamProducerSurfaceKHR_INDEX 17
#define eglCreateStreamProducerSurfaceKHR_RETURN EGLSurface
#define eglCreateStreamProducerSurfaceKHR_ARG_NAMES dpy, config, stream, attrib_list
#define eglCreateStreamProducerSurfaceKHR_ARG_EXPAND EGLDisplay dpy, EGLConfig config, EGLStreamKHR stream, const EGLint * attrib_list
#define eglCreateStreamProducerSurfaceKHR_PACKED PACKED_eglCreateStreamProducerSurfaceKHR
#define eglCreateStreamProducerSurfaceKHR_VOID_ONLY_WRAP(...) {}
#define eglCreateStreamProducerSurfaceKHR_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_eglCreateStreamProducerSurfaceKHR(_dpy, _config, _stream, _attrib_list) ({ \
    eglCreateStreamProducerSurfaceKHR_PACKED *packed_data = malloc(sizeof(eglCreateStreamProducerSurfaceKHR_PACKED)); \
    packed_data->index = eglCreateStreamProducerSurfaceKHR_INDEX; \
    packed_data->args.dpy = (EGLDisplay)_dpy; \
    packed_data->args.config = (EGLConfig)_config; \
    packed_data->args.stream = (EGLStreamKHR)_stream; \
    packed_data->args.attrib_list = (EGLint *)_attrib_list; \
    (packed_call_t *)packed_data; \
})
#define call_eglCreateStreamProducerSurfaceKHR(packed, ret_v) do { \
    PACKED_eglCreateStreamProducerSurfaceKHR *unpacked = (PACKED_eglCreateStreamProducerSurfaceKHR *)packed; \
    ARGS_eglCreateStreamProducerSurfaceKHR *args = (ARGS_eglCreateStreamProducerSurfaceKHR *)&unpacked->args; \
    EGLSurface *ret = (EGLSurface *)ret_v; \
    if (ret != NULL) { \
        *ret = eglCreateStreamProducerSurfaceKHR(args->dpy, args->config, args->stream, args->attrib_list);; \
    } else { \
        eglCreateStreamProducerSurfaceKHR(args->dpy, args->config, args->stream, args->attrib_list);; \
    } \
} while(0)
EGLSurface eglCreateStreamProducerSurfaceKHR(eglCreateStreamProducerSurfaceKHR_ARG_EXPAND);
typedef EGLSurface (*eglCreateStreamProducerSurfaceKHR_PTR)(eglCreateStreamProducerSurfaceKHR_ARG_EXPAND);
#define eglCreateSyncKHR_INDEX 18
#define eglCreateSyncKHR_RETURN EGLSyncKHR
#define eglCreateSyncKHR_ARG_NAMES dpy, type, attrib_list
#define eglCreateSyncKHR_ARG_EXPAND EGLDisplay dpy, EGLenum type, const EGLint * attrib_list
#define eglCreateSyncKHR_PACKED PACKED_eglCreateSyncKHR
#define eglCreateSyncKHR_VOID_ONLY_WRAP(...) {}
#define eglCreateSyncKHR_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_eglCreateSyncKHR(_dpy, _type, _attrib_list) ({ \
    eglCreateSyncKHR_PACKED *packed_data = malloc(sizeof(eglCreateSyncKHR_PACKED)); \
    packed_data->index = eglCreateSyncKHR_INDEX; \
    packed_data->args.dpy = (EGLDisplay)_dpy; \
    packed_data->args.type = (EGLenum)_type; \
    packed_data->args.attrib_list = (EGLint *)_attrib_list; \
    (packed_call_t *)packed_data; \
})
#define call_eglCreateSyncKHR(packed, ret_v) do { \
    PACKED_eglCreateSyncKHR *unpacked = (PACKED_eglCreateSyncKHR *)packed; \
    ARGS_eglCreateSyncKHR *args = (ARGS_eglCreateSyncKHR *)&unpacked->args; \
    EGLSyncKHR *ret = (EGLSyncKHR *)ret_v; \
    if (ret != NULL) { \
        *ret = eglCreateSyncKHR(args->dpy, args->type, args->attrib_list);; \
    } else { \
        eglCreateSyncKHR(args->dpy, args->type, args->attrib_list);; \
    } \
} while(0)
EGLSyncKHR eglCreateSyncKHR(eglCreateSyncKHR_ARG_EXPAND);
typedef EGLSyncKHR (*eglCreateSyncKHR_PTR)(eglCreateSyncKHR_ARG_EXPAND);
#define eglCreateWindowSurface_INDEX 19
#define eglCreateWindowSurface_RETURN EGLSurface
#define eglCreateWindowSurface_ARG_NAMES dpy, config, win, attrib_list
#define eglCreateWindowSurface_ARG_EXPAND EGLDisplay dpy, EGLConfig config, EGLNativeWindowType win, const EGLint * attrib_list
#define eglCreateWindowSurface_PACKED PACKED_eglCreateWindowSurface
#define eglCreateWindowSurface_VOID_ONLY_WRAP(...) {}
#define eglCreateWindowSurface_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_eglCreateWindowSurface(_dpy, _config, _win, _attrib_list) ({ \
    eglCreateWindowSurface_PACKED *packed_data = malloc(sizeof(eglCreateWindowSurface_PACKED)); \
    packed_data->index = eglCreateWindowSurface_INDEX; \
    packed_data->args.dpy = (EGLDisplay)_dpy; \
    packed_data->args.config = (EGLConfig)_config; \
    packed_data->args.win = (EGLNativeWindowType)_win; \
    packed_data->args.attrib_list = (EGLint *)_attrib_list; \
    (packed_call_t *)packed_data; \
})
#define call_eglCreateWindowSurface(packed, ret_v) do { \
    PACKED_eglCreateWindowSurface *unpacked = (PACKED_eglCreateWindowSurface *)packed; \
    ARGS_eglCreateWindowSurface *args = (ARGS_eglCreateWindowSurface *)&unpacked->args; \
    EGLSurface *ret = (EGLSurface *)ret_v; \
    if (ret != NULL) { \
        *ret = eglCreateWindowSurface(args->dpy, args->config, args->win, args->attrib_list);; \
    } else { \
        eglCreateWindowSurface(args->dpy, args->config, args->win, args->attrib_list);; \
    } \
} while(0)
EGLSurface eglCreateWindowSurface(eglCreateWindowSurface_ARG_EXPAND);
typedef EGLSurface (*eglCreateWindowSurface_PTR)(eglCreateWindowSurface_ARG_EXPAND);
#define eglDestroyContext_INDEX 20
#define eglDestroyContext_RETURN EGLBoolean
#define eglDestroyContext_ARG_NAMES dpy, ctx
#define eglDestroyContext_ARG_EXPAND EGLDisplay dpy, EGLContext ctx
#define eglDestroyContext_PACKED PACKED_eglDestroyContext
#define eglDestroyContext_VOID_ONLY_WRAP(...) {}
#define eglDestroyContext_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_eglDestroyContext(_dpy, _ctx) ({ \
    eglDestroyContext_PACKED *packed_data = malloc(sizeof(eglDestroyContext_PACKED)); \
    packed_data->index = eglDestroyContext_INDEX; \
    packed_data->args.dpy = (EGLDisplay)_dpy; \
    packed_data->args.ctx = (EGLContext)_ctx; \
    (packed_call_t *)packed_data; \
})
#define call_eglDestroyContext(packed, ret_v) do { \
    PACKED_eglDestroyContext *unpacked = (PACKED_eglDestroyContext *)packed; \
    ARGS_eglDestroyContext *args = (ARGS_eglDestroyContext *)&unpacked->args; \
    EGLBoolean *ret = (EGLBoolean *)ret_v; \
    if (ret != NULL) { \
        *ret = eglDestroyContext(args->dpy, args->ctx);; \
    } else { \
        eglDestroyContext(args->dpy, args->ctx);; \
    } \
} while(0)
EGLBoolean eglDestroyContext(eglDestroyContext_ARG_EXPAND);
typedef EGLBoolean (*eglDestroyContext_PTR)(eglDestroyContext_ARG_EXPAND);
#define eglDestroyImageKHR_INDEX 21
#define eglDestroyImageKHR_RETURN EGLBoolean
#define eglDestroyImageKHR_ARG_NAMES dpy, image
#define eglDestroyImageKHR_ARG_EXPAND EGLDisplay dpy, EGLImageKHR image
#define eglDestroyImageKHR_PACKED PACKED_eglDestroyImageKHR
#define eglDestroyImageKHR_VOID_ONLY_WRAP(...) {}
#define eglDestroyImageKHR_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_eglDestroyImageKHR(_dpy, _image) ({ \
    eglDestroyImageKHR_PACKED *packed_data = malloc(sizeof(eglDestroyImageKHR_PACKED)); \
    packed_data->index = eglDestroyImageKHR_INDEX; \
    packed_data->args.dpy = (EGLDisplay)_dpy; \
    packed_data->args.image = (EGLImageKHR)_image; \
    (packed_call_t *)packed_data; \
})
#define call_eglDestroyImageKHR(packed, ret_v) do { \
    PACKED_eglDestroyImageKHR *unpacked = (PACKED_eglDestroyImageKHR *)packed; \
    ARGS_eglDestroyImageKHR *args = (ARGS_eglDestroyImageKHR *)&unpacked->args; \
    EGLBoolean *ret = (EGLBoolean *)ret_v; \
    if (ret != NULL) { \
        *ret = eglDestroyImageKHR(args->dpy, args->image);; \
    } else { \
        eglDestroyImageKHR(args->dpy, args->image);; \
    } \
} while(0)
EGLBoolean eglDestroyImageKHR(eglDestroyImageKHR_ARG_EXPAND);
typedef EGLBoolean (*eglDestroyImageKHR_PTR)(eglDestroyImageKHR_ARG_EXPAND);
#define eglDestroyStreamKHR_INDEX 22
#define eglDestroyStreamKHR_RETURN EGLBoolean
#define eglDestroyStreamKHR_ARG_NAMES dpy, stream
#define eglDestroyStreamKHR_ARG_EXPAND EGLDisplay dpy, EGLStreamKHR stream
#define eglDestroyStreamKHR_PACKED PACKED_eglDestroyStreamKHR
#define eglDestroyStreamKHR_VOID_ONLY_WRAP(...) {}
#define eglDestroyStreamKHR_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_eglDestroyStreamKHR(_dpy, _stream) ({ \
    eglDestroyStreamKHR_PACKED *packed_data = malloc(sizeof(eglDestroyStreamKHR_PACKED)); \
    packed_data->index = eglDestroyStreamKHR_INDEX; \
    packed_data->args.dpy = (EGLDisplay)_dpy; \
    packed_data->args.stream = (EGLStreamKHR)_stream; \
    (packed_call_t *)packed_data; \
})
#define call_eglDestroyStreamKHR(packed, ret_v) do { \
    PACKED_eglDestroyStreamKHR *unpacked = (PACKED_eglDestroyStreamKHR *)packed; \
    ARGS_eglDestroyStreamKHR *args = (ARGS_eglDestroyStreamKHR *)&unpacked->args; \
    EGLBoolean *ret = (EGLBoolean *)ret_v; \
    if (ret != NULL) { \
        *ret = eglDestroyStreamKHR(args->dpy, args->stream);; \
    } else { \
        eglDestroyStreamKHR(args->dpy, args->stream);; \
    } \
} while(0)
EGLBoolean eglDestroyStreamKHR(eglDestroyStreamKHR_ARG_EXPAND);
typedef EGLBoolean (*eglDestroyStreamKHR_PTR)(eglDestroyStreamKHR_ARG_EXPAND);
#define eglDestroySurface_INDEX 23
#define eglDestroySurface_RETURN EGLBoolean
#define eglDestroySurface_ARG_NAMES dpy, surface
#define eglDestroySurface_ARG_EXPAND EGLDisplay dpy, EGLSurface surface
#define eglDestroySurface_PACKED PACKED_eglDestroySurface
#define eglDestroySurface_VOID_ONLY_WRAP(...) {}
#define eglDestroySurface_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_eglDestroySurface(_dpy, _surface) ({ \
    eglDestroySurface_PACKED *packed_data = malloc(sizeof(eglDestroySurface_PACKED)); \
    packed_data->index = eglDestroySurface_INDEX; \
    packed_data->args.dpy = (EGLDisplay)_dpy; \
    packed_data->args.surface = (EGLSurface)_surface; \
    (packed_call_t *)packed_data; \
})
#define call_eglDestroySurface(packed, ret_v) do { \
    PACKED_eglDestroySurface *unpacked = (PACKED_eglDestroySurface *)packed; \
    ARGS_eglDestroySurface *args = (ARGS_eglDestroySurface *)&unpacked->args; \
    EGLBoolean *ret = (EGLBoolean *)ret_v; \
    if (ret != NULL) { \
        *ret = eglDestroySurface(args->dpy, args->surface);; \
    } else { \
        eglDestroySurface(args->dpy, args->surface);; \
    } \
} while(0)
EGLBoolean eglDestroySurface(eglDestroySurface_ARG_EXPAND);
typedef EGLBoolean (*eglDestroySurface_PTR)(eglDestroySurface_ARG_EXPAND);
#define eglDestroySyncKHR_INDEX 24
#define eglDestroySyncKHR_RETURN EGLBoolean
#define eglDestroySyncKHR_ARG_NAMES dpy, sync
#define eglDestroySyncKHR_ARG_EXPAND EGLDisplay dpy, EGLSyncKHR sync
#define eglDestroySyncKHR_PACKED PACKED_eglDestroySyncKHR
#define eglDestroySyncKHR_VOID_ONLY_WRAP(...) {}
#define eglDestroySyncKHR_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_eglDestroySyncKHR(_dpy, _sync) ({ \
    eglDestroySyncKHR_PACKED *packed_data = malloc(sizeof(eglDestroySyncKHR_PACKED)); \
    packed_data->index = eglDestroySyncKHR_INDEX; \
    packed_data->args.dpy = (EGLDisplay)_dpy; \
    packed_data->args.sync = (EGLSyncKHR)_sync; \
    (packed_call_t *)packed_data; \
})
#define call_eglDestroySyncKHR(packed, ret_v) do { \
    PACKED_eglDestroySyncKHR *unpacked = (PACKED_eglDestroySyncKHR *)packed; \
    ARGS_eglDestroySyncKHR *args = (ARGS_eglDestroySyncKHR *)&unpacked->args; \
    EGLBoolean *ret = (EGLBoolean *)ret_v; \
    if (ret != NULL) { \
        *ret = eglDestroySyncKHR(args->dpy, args->sync);; \
    } else { \
        eglDestroySyncKHR(args->dpy, args->sync);; \
    } \
} while(0)
EGLBoolean eglDestroySyncKHR(eglDestroySyncKHR_ARG_EXPAND);
typedef EGLBoolean (*eglDestroySyncKHR_PTR)(eglDestroySyncKHR_ARG_EXPAND);
#define eglDestroySyncNV_INDEX 25
#define eglDestroySyncNV_RETURN EGLBoolean
#define eglDestroySyncNV_ARG_NAMES sync
#define eglDestroySyncNV_ARG_EXPAND EGLSyncNV sync
#define eglDestroySyncNV_PACKED PACKED_eglDestroySyncNV
#define eglDestroySyncNV_VOID_ONLY_WRAP(...) {}
#define eglDestroySyncNV_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_eglDestroySyncNV(_sync) ({ \
    eglDestroySyncNV_PACKED *packed_data = malloc(sizeof(eglDestroySyncNV_PACKED)); \
    packed_data->index = eglDestroySyncNV_INDEX; \
    packed_data->args.sync = (EGLSyncNV)_sync; \
    (packed_call_t *)packed_data; \
})
#define call_eglDestroySyncNV(packed, ret_v) do { \
    PACKED_eglDestroySyncNV *unpacked = (PACKED_eglDestroySyncNV *)packed; \
    ARGS_eglDestroySyncNV *args = (ARGS_eglDestroySyncNV *)&unpacked->args; \
    EGLBoolean *ret = (EGLBoolean *)ret_v; \
    if (ret != NULL) { \
        *ret = eglDestroySyncNV(args->sync);; \
    } else { \
        eglDestroySyncNV(args->sync);; \
    } \
} while(0)
EGLBoolean eglDestroySyncNV(eglDestroySyncNV_ARG_EXPAND);
typedef EGLBoolean (*eglDestroySyncNV_PTR)(eglDestroySyncNV_ARG_EXPAND);
#define eglDupNativeFenceFDANDROID_INDEX 26
#define eglDupNativeFenceFDANDROID_RETURN EGLint
#define eglDupNativeFenceFDANDROID_ARG_NAMES dpy, sync
#define eglDupNativeFenceFDANDROID_ARG_EXPAND EGLDisplay dpy, EGLSyncKHR sync
#define eglDupNativeFenceFDANDROID_PACKED PACKED_eglDupNativeFenceFDANDROID
#define eglDupNativeFenceFDANDROID_VOID_ONLY_WRAP(...) {}
#define eglDupNativeFenceFDANDROID_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_eglDupNativeFenceFDANDROID(_dpy, _sync) ({ \
    eglDupNativeFenceFDANDROID_PACKED *packed_data = malloc(sizeof(eglDupNativeFenceFDANDROID_PACKED)); \
    packed_data->index = eglDupNativeFenceFDANDROID_INDEX; \
    packed_data->args.dpy = (EGLDisplay)_dpy; \
    packed_data->args.sync = (EGLSyncKHR)_sync; \
    (packed_call_t *)packed_data; \
})
#define call_eglDupNativeFenceFDANDROID(packed, ret_v) do { \
    PACKED_eglDupNativeFenceFDANDROID *unpacked = (PACKED_eglDupNativeFenceFDANDROID *)packed; \
    ARGS_eglDupNativeFenceFDANDROID *args = (ARGS_eglDupNativeFenceFDANDROID *)&unpacked->args; \
    EGLint *ret = (EGLint *)ret_v; \
    if (ret != NULL) { \
        *ret = eglDupNativeFenceFDANDROID(args->dpy, args->sync);; \
    } else { \
        eglDupNativeFenceFDANDROID(args->dpy, args->sync);; \
    } \
} while(0)
EGLint eglDupNativeFenceFDANDROID(eglDupNativeFenceFDANDROID_ARG_EXPAND);
typedef EGLint (*eglDupNativeFenceFDANDROID_PTR)(eglDupNativeFenceFDANDROID_ARG_EXPAND);
#define eglExportDRMImageMESA_INDEX 27
#define eglExportDRMImageMESA_RETURN EGLBoolean
#define eglExportDRMImageMESA_ARG_NAMES dpy, image, name, handle, stride
#define eglExportDRMImageMESA_ARG_EXPAND EGLDisplay dpy, EGLImageKHR image, EGLint * name, EGLint * handle, EGLint * stride
#define eglExportDRMImageMESA_PACKED PACKED_eglExportDRMImageMESA
#define eglExportDRMImageMESA_VOID_ONLY_WRAP(...) {}
#define eglExportDRMImageMESA_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_eglExportDRMImageMESA(_dpy, _image, _name, _handle, _stride) ({ \
    eglExportDRMImageMESA_PACKED *packed_data = malloc(sizeof(eglExportDRMImageMESA_PACKED)); \
    packed_data->index = eglExportDRMImageMESA_INDEX; \
    packed_data->args.dpy = (EGLDisplay)_dpy; \
    packed_data->args.image = (EGLImageKHR)_image; \
    packed_data->args.name = (EGLint *)_name; \
    packed_data->args.handle = (EGLint *)_handle; \
    packed_data->args.stride = (EGLint *)_stride; \
    (packed_call_t *)packed_data; \
})
#define call_eglExportDRMImageMESA(packed, ret_v) do { \
    PACKED_eglExportDRMImageMESA *unpacked = (PACKED_eglExportDRMImageMESA *)packed; \
    ARGS_eglExportDRMImageMESA *args = (ARGS_eglExportDRMImageMESA *)&unpacked->args; \
    EGLBoolean *ret = (EGLBoolean *)ret_v; \
    if (ret != NULL) { \
        *ret = eglExportDRMImageMESA(args->dpy, args->image, args->name, args->handle, args->stride);; \
    } else { \
        eglExportDRMImageMESA(args->dpy, args->image, args->name, args->handle, args->stride);; \
    } \
} while(0)
EGLBoolean eglExportDRMImageMESA(eglExportDRMImageMESA_ARG_EXPAND);
typedef EGLBoolean (*eglExportDRMImageMESA_PTR)(eglExportDRMImageMESA_ARG_EXPAND);
#define eglFenceNV_INDEX 28
#define eglFenceNV_RETURN EGLBoolean
#define eglFenceNV_ARG_NAMES sync
#define eglFenceNV_ARG_EXPAND EGLSyncNV sync
#define eglFenceNV_PACKED PACKED_eglFenceNV
#define eglFenceNV_VOID_ONLY_WRAP(...) {}
#define eglFenceNV_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_eglFenceNV(_sync) ({ \
    eglFenceNV_PACKED *packed_data = malloc(sizeof(eglFenceNV_PACKED)); \
    packed_data->index = eglFenceNV_INDEX; \
    packed_data->args.sync = (EGLSyncNV)_sync; \
    (packed_call_t *)packed_data; \
})
#define call_eglFenceNV(packed, ret_v) do { \
    PACKED_eglFenceNV *unpacked = (PACKED_eglFenceNV *)packed; \
    ARGS_eglFenceNV *args = (ARGS_eglFenceNV *)&unpacked->args; \
    EGLBoolean *ret = (EGLBoolean *)ret_v; \
    if (ret != NULL) { \
        *ret = eglFenceNV(args->sync);; \
    } else { \
        eglFenceNV(args->sync);; \
    } \
} while(0)
EGLBoolean eglFenceNV(eglFenceNV_ARG_EXPAND);
typedef EGLBoolean (*eglFenceNV_PTR)(eglFenceNV_ARG_EXPAND);
#define eglGetConfigAttrib_INDEX 29
#define eglGetConfigAttrib_RETURN EGLBoolean
#define eglGetConfigAttrib_ARG_NAMES dpy, config, attribute, value
#define eglGetConfigAttrib_ARG_EXPAND EGLDisplay dpy, EGLConfig config, EGLint attribute, EGLint * value
#define eglGetConfigAttrib_PACKED PACKED_eglGetConfigAttrib
#define eglGetConfigAttrib_VOID_ONLY_WRAP(...) {}
#define eglGetConfigAttrib_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_eglGetConfigAttrib(_dpy, _config, _attribute, _value) ({ \
    eglGetConfigAttrib_PACKED *packed_data = malloc(sizeof(eglGetConfigAttrib_PACKED)); \
    packed_data->index = eglGetConfigAttrib_INDEX; \
    packed_data->args.dpy = (EGLDisplay)_dpy; \
    packed_data->args.config = (EGLConfig)_config; \
    packed_data->args.attribute = (EGLint)_attribute; \
    packed_data->args.value = (EGLint *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_eglGetConfigAttrib(packed, ret_v) do { \
    PACKED_eglGetConfigAttrib *unpacked = (PACKED_eglGetConfigAttrib *)packed; \
    ARGS_eglGetConfigAttrib *args = (ARGS_eglGetConfigAttrib *)&unpacked->args; \
    EGLBoolean *ret = (EGLBoolean *)ret_v; \
    if (ret != NULL) { \
        *ret = eglGetConfigAttrib(args->dpy, args->config, args->attribute, args->value);; \
    } else { \
        eglGetConfigAttrib(args->dpy, args->config, args->attribute, args->value);; \
    } \
} while(0)
EGLBoolean eglGetConfigAttrib(eglGetConfigAttrib_ARG_EXPAND);
typedef EGLBoolean (*eglGetConfigAttrib_PTR)(eglGetConfigAttrib_ARG_EXPAND);
#define eglGetConfigs_INDEX 30
#define eglGetConfigs_RETURN EGLBoolean
#define eglGetConfigs_ARG_NAMES dpy, configs, config_size, num_config
#define eglGetConfigs_ARG_EXPAND EGLDisplay dpy, EGLConfig * configs, EGLint config_size, EGLint * num_config
#define eglGetConfigs_PACKED PACKED_eglGetConfigs
#define eglGetConfigs_VOID_ONLY_WRAP(...) {}
#define eglGetConfigs_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_eglGetConfigs(_dpy, _configs, _config_size, _num_config) ({ \
    eglGetConfigs_PACKED *packed_data = malloc(sizeof(eglGetConfigs_PACKED)); \
    packed_data->index = eglGetConfigs_INDEX; \
    packed_data->args.dpy = (EGLDisplay)_dpy; \
    packed_data->args.configs = (EGLConfig *)_configs; \
    packed_data->args.config_size = (EGLint)_config_size; \
    packed_data->args.num_config = (EGLint *)_num_config; \
    (packed_call_t *)packed_data; \
})
#define call_eglGetConfigs(packed, ret_v) do { \
    PACKED_eglGetConfigs *unpacked = (PACKED_eglGetConfigs *)packed; \
    ARGS_eglGetConfigs *args = (ARGS_eglGetConfigs *)&unpacked->args; \
    EGLBoolean *ret = (EGLBoolean *)ret_v; \
    if (ret != NULL) { \
        *ret = eglGetConfigs(args->dpy, args->configs, args->config_size, args->num_config);; \
    } else { \
        eglGetConfigs(args->dpy, args->configs, args->config_size, args->num_config);; \
    } \
} while(0)
EGLBoolean eglGetConfigs(eglGetConfigs_ARG_EXPAND);
typedef EGLBoolean (*eglGetConfigs_PTR)(eglGetConfigs_ARG_EXPAND);
#define eglGetCurrentContext_INDEX 31
#define eglGetCurrentContext_RETURN EGLContext
#define eglGetCurrentContext_ARG_NAMES 
#define eglGetCurrentContext_ARG_EXPAND 
#define eglGetCurrentContext_PACKED PACKED_eglGetCurrentContext
#define eglGetCurrentContext_VOID_ONLY_WRAP(...) {}
#define eglGetCurrentContext_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_eglGetCurrentContext() ({ \
    eglGetCurrentContext_PACKED *packed_data = malloc(sizeof(eglGetCurrentContext_PACKED)); \
    packed_data->index = eglGetCurrentContext_INDEX; \
    (packed_call_t *)packed_data; \
})
#define call_eglGetCurrentContext(packed, ret_v) do { \
    EGLContext *ret = (EGLContext *)ret_v; \
    if (ret != NULL) { \
        *ret = eglGetCurrentContext();; \
    } else { \
        eglGetCurrentContext();; \
    } \
} while(0)
EGLContext eglGetCurrentContext(eglGetCurrentContext_ARG_EXPAND);
typedef EGLContext (*eglGetCurrentContext_PTR)(eglGetCurrentContext_ARG_EXPAND);
#define eglGetCurrentDisplay_INDEX 32
#define eglGetCurrentDisplay_RETURN EGLDisplay
#define eglGetCurrentDisplay_ARG_NAMES 
#define eglGetCurrentDisplay_ARG_EXPAND 
#define eglGetCurrentDisplay_PACKED PACKED_eglGetCurrentDisplay
#define eglGetCurrentDisplay_VOID_ONLY_WRAP(...) {}
#define eglGetCurrentDisplay_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_eglGetCurrentDisplay() ({ \
    eglGetCurrentDisplay_PACKED *packed_data = malloc(sizeof(eglGetCurrentDisplay_PACKED)); \
    packed_data->index = eglGetCurrentDisplay_INDEX; \
    (packed_call_t *)packed_data; \
})
#define call_eglGetCurrentDisplay(packed, ret_v) do { \
    EGLDisplay *ret = (EGLDisplay *)ret_v; \
    if (ret != NULL) { \
        *ret = eglGetCurrentDisplay();; \
    } else { \
        eglGetCurrentDisplay();; \
    } \
} while(0)
EGLDisplay eglGetCurrentDisplay(eglGetCurrentDisplay_ARG_EXPAND);
typedef EGLDisplay (*eglGetCurrentDisplay_PTR)(eglGetCurrentDisplay_ARG_EXPAND);
#define eglGetCurrentSurface_INDEX 33
#define eglGetCurrentSurface_RETURN EGLSurface
#define eglGetCurrentSurface_ARG_NAMES readdraw
#define eglGetCurrentSurface_ARG_EXPAND EGLint readdraw
#define eglGetCurrentSurface_PACKED PACKED_eglGetCurrentSurface
#define eglGetCurrentSurface_VOID_ONLY_WRAP(...) {}
#define eglGetCurrentSurface_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_eglGetCurrentSurface(_readdraw) ({ \
    eglGetCurrentSurface_PACKED *packed_data = malloc(sizeof(eglGetCurrentSurface_PACKED)); \
    packed_data->index = eglGetCurrentSurface_INDEX; \
    packed_data->args.readdraw = (EGLint)_readdraw; \
    (packed_call_t *)packed_data; \
})
#define call_eglGetCurrentSurface(packed, ret_v) do { \
    PACKED_eglGetCurrentSurface *unpacked = (PACKED_eglGetCurrentSurface *)packed; \
    ARGS_eglGetCurrentSurface *args = (ARGS_eglGetCurrentSurface *)&unpacked->args; \
    EGLSurface *ret = (EGLSurface *)ret_v; \
    if (ret != NULL) { \
        *ret = eglGetCurrentSurface(args->readdraw);; \
    } else { \
        eglGetCurrentSurface(args->readdraw);; \
    } \
} while(0)
EGLSurface eglGetCurrentSurface(eglGetCurrentSurface_ARG_EXPAND);
typedef EGLSurface (*eglGetCurrentSurface_PTR)(eglGetCurrentSurface_ARG_EXPAND);
#define eglGetDisplay_INDEX 34
#define eglGetDisplay_RETURN EGLDisplay
#define eglGetDisplay_ARG_NAMES display_id
#define eglGetDisplay_ARG_EXPAND EGLNativeDisplayType display_id
#define eglGetDisplay_PACKED PACKED_eglGetDisplay
#define eglGetDisplay_VOID_ONLY_WRAP(...) {}
#define eglGetDisplay_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_eglGetDisplay(_display_id) ({ \
    eglGetDisplay_PACKED *packed_data = malloc(sizeof(eglGetDisplay_PACKED)); \
    packed_data->index = eglGetDisplay_INDEX; \
    packed_data->args.display_id = (EGLNativeDisplayType)_display_id; \
    (packed_call_t *)packed_data; \
})
#define call_eglGetDisplay(packed, ret_v) do { \
    PACKED_eglGetDisplay *unpacked = (PACKED_eglGetDisplay *)packed; \
    ARGS_eglGetDisplay *args = (ARGS_eglGetDisplay *)&unpacked->args; \
    EGLDisplay *ret = (EGLDisplay *)ret_v; \
    if (ret != NULL) { \
        *ret = eglGetDisplay(args->display_id);; \
    } else { \
        eglGetDisplay(args->display_id);; \
    } \
} while(0)
EGLDisplay eglGetDisplay(eglGetDisplay_ARG_EXPAND);
typedef EGLDisplay (*eglGetDisplay_PTR)(eglGetDisplay_ARG_EXPAND);
#define eglGetError_INDEX 35
#define eglGetError_RETURN EGLint
#define eglGetError_ARG_NAMES 
#define eglGetError_ARG_EXPAND 
#define eglGetError_PACKED PACKED_eglGetError
#define eglGetError_VOID_ONLY_WRAP(...) {}
#define eglGetError_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_eglGetError() ({ \
    eglGetError_PACKED *packed_data = malloc(sizeof(eglGetError_PACKED)); \
    packed_data->index = eglGetError_INDEX; \
    (packed_call_t *)packed_data; \
})
#define call_eglGetError(packed, ret_v) do { \
    EGLint *ret = (EGLint *)ret_v; \
    if (ret != NULL) { \
        *ret = eglGetError();; \
    } else { \
        eglGetError();; \
    } \
} while(0)
EGLint eglGetError(eglGetError_ARG_EXPAND);
typedef EGLint (*eglGetError_PTR)(eglGetError_ARG_EXPAND);
#define eglGetProcAddress_INDEX 36
#define eglGetProcAddress_RETURN __eglMustCastToProperFunctionPointerType
#define eglGetProcAddress_ARG_NAMES procname
#define eglGetProcAddress_ARG_EXPAND const char * procname
#define eglGetProcAddress_PACKED PACKED_eglGetProcAddress
#define eglGetProcAddress_VOID_ONLY_WRAP(...) {}
#define eglGetProcAddress_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_eglGetProcAddress(_procname) ({ \
    eglGetProcAddress_PACKED *packed_data = malloc(sizeof(eglGetProcAddress_PACKED)); \
    packed_data->index = eglGetProcAddress_INDEX; \
    packed_data->args.procname = (char *)_procname; \
    (packed_call_t *)packed_data; \
})
#define call_eglGetProcAddress(packed, ret_v) do { \
    PACKED_eglGetProcAddress *unpacked = (PACKED_eglGetProcAddress *)packed; \
    ARGS_eglGetProcAddress *args = (ARGS_eglGetProcAddress *)&unpacked->args; \
    __eglMustCastToProperFunctionPointerType *ret = (__eglMustCastToProperFunctionPointerType *)ret_v; \
    if (ret != NULL) { \
        *ret = eglGetProcAddress(args->procname);; \
    } else { \
        eglGetProcAddress(args->procname);; \
    } \
} while(0)
__eglMustCastToProperFunctionPointerType eglGetProcAddress(eglGetProcAddress_ARG_EXPAND);
typedef __eglMustCastToProperFunctionPointerType (*eglGetProcAddress_PTR)(eglGetProcAddress_ARG_EXPAND);
#define eglGetStreamFileDescriptorKHR_INDEX 37
#define eglGetStreamFileDescriptorKHR_RETURN EGLNativeFileDescriptorKHR
#define eglGetStreamFileDescriptorKHR_ARG_NAMES dpy, stream
#define eglGetStreamFileDescriptorKHR_ARG_EXPAND EGLDisplay dpy, EGLStreamKHR stream
#define eglGetStreamFileDescriptorKHR_PACKED PACKED_eglGetStreamFileDescriptorKHR
#define eglGetStreamFileDescriptorKHR_VOID_ONLY_WRAP(...) {}
#define eglGetStreamFileDescriptorKHR_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_eglGetStreamFileDescriptorKHR(_dpy, _stream) ({ \
    eglGetStreamFileDescriptorKHR_PACKED *packed_data = malloc(sizeof(eglGetStreamFileDescriptorKHR_PACKED)); \
    packed_data->index = eglGetStreamFileDescriptorKHR_INDEX; \
    packed_data->args.dpy = (EGLDisplay)_dpy; \
    packed_data->args.stream = (EGLStreamKHR)_stream; \
    (packed_call_t *)packed_data; \
})
#define call_eglGetStreamFileDescriptorKHR(packed, ret_v) do { \
    PACKED_eglGetStreamFileDescriptorKHR *unpacked = (PACKED_eglGetStreamFileDescriptorKHR *)packed; \
    ARGS_eglGetStreamFileDescriptorKHR *args = (ARGS_eglGetStreamFileDescriptorKHR *)&unpacked->args; \
    EGLNativeFileDescriptorKHR *ret = (EGLNativeFileDescriptorKHR *)ret_v; \
    if (ret != NULL) { \
        *ret = eglGetStreamFileDescriptorKHR(args->dpy, args->stream);; \
    } else { \
        eglGetStreamFileDescriptorKHR(args->dpy, args->stream);; \
    } \
} while(0)
EGLNativeFileDescriptorKHR eglGetStreamFileDescriptorKHR(eglGetStreamFileDescriptorKHR_ARG_EXPAND);
typedef EGLNativeFileDescriptorKHR (*eglGetStreamFileDescriptorKHR_PTR)(eglGetStreamFileDescriptorKHR_ARG_EXPAND);
#define eglGetSyncAttribKHR_INDEX 38
#define eglGetSyncAttribKHR_RETURN EGLBoolean
#define eglGetSyncAttribKHR_ARG_NAMES dpy, sync, attribute, value
#define eglGetSyncAttribKHR_ARG_EXPAND EGLDisplay dpy, EGLSyncKHR sync, EGLint attribute, EGLint * value
#define eglGetSyncAttribKHR_PACKED PACKED_eglGetSyncAttribKHR
#define eglGetSyncAttribKHR_VOID_ONLY_WRAP(...) {}
#define eglGetSyncAttribKHR_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_eglGetSyncAttribKHR(_dpy, _sync, _attribute, _value) ({ \
    eglGetSyncAttribKHR_PACKED *packed_data = malloc(sizeof(eglGetSyncAttribKHR_PACKED)); \
    packed_data->index = eglGetSyncAttribKHR_INDEX; \
    packed_data->args.dpy = (EGLDisplay)_dpy; \
    packed_data->args.sync = (EGLSyncKHR)_sync; \
    packed_data->args.attribute = (EGLint)_attribute; \
    packed_data->args.value = (EGLint *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_eglGetSyncAttribKHR(packed, ret_v) do { \
    PACKED_eglGetSyncAttribKHR *unpacked = (PACKED_eglGetSyncAttribKHR *)packed; \
    ARGS_eglGetSyncAttribKHR *args = (ARGS_eglGetSyncAttribKHR *)&unpacked->args; \
    EGLBoolean *ret = (EGLBoolean *)ret_v; \
    if (ret != NULL) { \
        *ret = eglGetSyncAttribKHR(args->dpy, args->sync, args->attribute, args->value);; \
    } else { \
        eglGetSyncAttribKHR(args->dpy, args->sync, args->attribute, args->value);; \
    } \
} while(0)
EGLBoolean eglGetSyncAttribKHR(eglGetSyncAttribKHR_ARG_EXPAND);
typedef EGLBoolean (*eglGetSyncAttribKHR_PTR)(eglGetSyncAttribKHR_ARG_EXPAND);
#define eglGetSyncAttribNV_INDEX 39
#define eglGetSyncAttribNV_RETURN EGLBoolean
#define eglGetSyncAttribNV_ARG_NAMES sync, attribute, value
#define eglGetSyncAttribNV_ARG_EXPAND EGLSyncNV sync, EGLint attribute, EGLint * value
#define eglGetSyncAttribNV_PACKED PACKED_eglGetSyncAttribNV
#define eglGetSyncAttribNV_VOID_ONLY_WRAP(...) {}
#define eglGetSyncAttribNV_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_eglGetSyncAttribNV(_sync, _attribute, _value) ({ \
    eglGetSyncAttribNV_PACKED *packed_data = malloc(sizeof(eglGetSyncAttribNV_PACKED)); \
    packed_data->index = eglGetSyncAttribNV_INDEX; \
    packed_data->args.sync = (EGLSyncNV)_sync; \
    packed_data->args.attribute = (EGLint)_attribute; \
    packed_data->args.value = (EGLint *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_eglGetSyncAttribNV(packed, ret_v) do { \
    PACKED_eglGetSyncAttribNV *unpacked = (PACKED_eglGetSyncAttribNV *)packed; \
    ARGS_eglGetSyncAttribNV *args = (ARGS_eglGetSyncAttribNV *)&unpacked->args; \
    EGLBoolean *ret = (EGLBoolean *)ret_v; \
    if (ret != NULL) { \
        *ret = eglGetSyncAttribNV(args->sync, args->attribute, args->value);; \
    } else { \
        eglGetSyncAttribNV(args->sync, args->attribute, args->value);; \
    } \
} while(0)
EGLBoolean eglGetSyncAttribNV(eglGetSyncAttribNV_ARG_EXPAND);
typedef EGLBoolean (*eglGetSyncAttribNV_PTR)(eglGetSyncAttribNV_ARG_EXPAND);
#define eglGetSystemTimeFrequencyNV_INDEX 40
#define eglGetSystemTimeFrequencyNV_RETURN EGLuint64NV
#define eglGetSystemTimeFrequencyNV_ARG_NAMES 
#define eglGetSystemTimeFrequencyNV_ARG_EXPAND 
#define eglGetSystemTimeFrequencyNV_PACKED PACKED_eglGetSystemTimeFrequencyNV
#define eglGetSystemTimeFrequencyNV_VOID_ONLY_WRAP(...) {}
#define eglGetSystemTimeFrequencyNV_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_eglGetSystemTimeFrequencyNV() ({ \
    eglGetSystemTimeFrequencyNV_PACKED *packed_data = malloc(sizeof(eglGetSystemTimeFrequencyNV_PACKED)); \
    packed_data->index = eglGetSystemTimeFrequencyNV_INDEX; \
    (packed_call_t *)packed_data; \
})
#define call_eglGetSystemTimeFrequencyNV(packed, ret_v) do { \
    EGLuint64NV *ret = (EGLuint64NV *)ret_v; \
    if (ret != NULL) { \
        *ret = eglGetSystemTimeFrequencyNV();; \
    } else { \
        eglGetSystemTimeFrequencyNV();; \
    } \
} while(0)
EGLuint64NV eglGetSystemTimeFrequencyNV(eglGetSystemTimeFrequencyNV_ARG_EXPAND);
typedef EGLuint64NV (*eglGetSystemTimeFrequencyNV_PTR)(eglGetSystemTimeFrequencyNV_ARG_EXPAND);
#define eglGetSystemTimeNV_INDEX 41
#define eglGetSystemTimeNV_RETURN EGLuint64NV
#define eglGetSystemTimeNV_ARG_NAMES 
#define eglGetSystemTimeNV_ARG_EXPAND 
#define eglGetSystemTimeNV_PACKED PACKED_eglGetSystemTimeNV
#define eglGetSystemTimeNV_VOID_ONLY_WRAP(...) {}
#define eglGetSystemTimeNV_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_eglGetSystemTimeNV() ({ \
    eglGetSystemTimeNV_PACKED *packed_data = malloc(sizeof(eglGetSystemTimeNV_PACKED)); \
    packed_data->index = eglGetSystemTimeNV_INDEX; \
    (packed_call_t *)packed_data; \
})
#define call_eglGetSystemTimeNV(packed, ret_v) do { \
    EGLuint64NV *ret = (EGLuint64NV *)ret_v; \
    if (ret != NULL) { \
        *ret = eglGetSystemTimeNV();; \
    } else { \
        eglGetSystemTimeNV();; \
    } \
} while(0)
EGLuint64NV eglGetSystemTimeNV(eglGetSystemTimeNV_ARG_EXPAND);
typedef EGLuint64NV (*eglGetSystemTimeNV_PTR)(eglGetSystemTimeNV_ARG_EXPAND);
#define eglInitialize_INDEX 42
#define eglInitialize_RETURN EGLBoolean
#define eglInitialize_ARG_NAMES dpy, major, minor
#define eglInitialize_ARG_EXPAND EGLDisplay dpy, EGLint * major, EGLint * minor
#define eglInitialize_PACKED PACKED_eglInitialize
#define eglInitialize_VOID_ONLY_WRAP(...) {}
#define eglInitialize_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_eglInitialize(_dpy, _major, _minor) ({ \
    eglInitialize_PACKED *packed_data = malloc(sizeof(eglInitialize_PACKED)); \
    packed_data->index = eglInitialize_INDEX; \
    packed_data->args.dpy = (EGLDisplay)_dpy; \
    packed_data->args.major = (EGLint *)_major; \
    packed_data->args.minor = (EGLint *)_minor; \
    (packed_call_t *)packed_data; \
})
#define call_eglInitialize(packed, ret_v) do { \
    PACKED_eglInitialize *unpacked = (PACKED_eglInitialize *)packed; \
    ARGS_eglInitialize *args = (ARGS_eglInitialize *)&unpacked->args; \
    EGLBoolean *ret = (EGLBoolean *)ret_v; \
    if (ret != NULL) { \
        *ret = eglInitialize(args->dpy, args->major, args->minor);; \
    } else { \
        eglInitialize(args->dpy, args->major, args->minor);; \
    } \
} while(0)
EGLBoolean eglInitialize(eglInitialize_ARG_EXPAND);
typedef EGLBoolean (*eglInitialize_PTR)(eglInitialize_ARG_EXPAND);
#define eglLockSurfaceKHR_INDEX 43
#define eglLockSurfaceKHR_RETURN EGLBoolean
#define eglLockSurfaceKHR_ARG_NAMES display, surface, attrib_list
#define eglLockSurfaceKHR_ARG_EXPAND EGLDisplay display, EGLSurface surface, const EGLint * attrib_list
#define eglLockSurfaceKHR_PACKED PACKED_eglLockSurfaceKHR
#define eglLockSurfaceKHR_VOID_ONLY_WRAP(...) {}
#define eglLockSurfaceKHR_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_eglLockSurfaceKHR(_display, _surface, _attrib_list) ({ \
    eglLockSurfaceKHR_PACKED *packed_data = malloc(sizeof(eglLockSurfaceKHR_PACKED)); \
    packed_data->index = eglLockSurfaceKHR_INDEX; \
    packed_data->args.display = (EGLDisplay)_display; \
    packed_data->args.surface = (EGLSurface)_surface; \
    packed_data->args.attrib_list = (EGLint *)_attrib_list; \
    (packed_call_t *)packed_data; \
})
#define call_eglLockSurfaceKHR(packed, ret_v) do { \
    PACKED_eglLockSurfaceKHR *unpacked = (PACKED_eglLockSurfaceKHR *)packed; \
    ARGS_eglLockSurfaceKHR *args = (ARGS_eglLockSurfaceKHR *)&unpacked->args; \
    EGLBoolean *ret = (EGLBoolean *)ret_v; \
    if (ret != NULL) { \
        *ret = eglLockSurfaceKHR(args->display, args->surface, args->attrib_list);; \
    } else { \
        eglLockSurfaceKHR(args->display, args->surface, args->attrib_list);; \
    } \
} while(0)
EGLBoolean eglLockSurfaceKHR(eglLockSurfaceKHR_ARG_EXPAND);
typedef EGLBoolean (*eglLockSurfaceKHR_PTR)(eglLockSurfaceKHR_ARG_EXPAND);
#define eglMakeCurrent_INDEX 44
#define eglMakeCurrent_RETURN EGLBoolean
#define eglMakeCurrent_ARG_NAMES dpy, draw, read, ctx
#define eglMakeCurrent_ARG_EXPAND EGLDisplay dpy, EGLSurface draw, EGLSurface read, EGLContext ctx
#define eglMakeCurrent_PACKED PACKED_eglMakeCurrent
#define eglMakeCurrent_VOID_ONLY_WRAP(...) {}
#define eglMakeCurrent_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_eglMakeCurrent(_dpy, _draw, _read, _ctx) ({ \
    eglMakeCurrent_PACKED *packed_data = malloc(sizeof(eglMakeCurrent_PACKED)); \
    packed_data->index = eglMakeCurrent_INDEX; \
    packed_data->args.dpy = (EGLDisplay)_dpy; \
    packed_data->args.draw = (EGLSurface)_draw; \
    packed_data->args.read = (EGLSurface)_read; \
    packed_data->args.ctx = (EGLContext)_ctx; \
    (packed_call_t *)packed_data; \
})
#define call_eglMakeCurrent(packed, ret_v) do { \
    PACKED_eglMakeCurrent *unpacked = (PACKED_eglMakeCurrent *)packed; \
    ARGS_eglMakeCurrent *args = (ARGS_eglMakeCurrent *)&unpacked->args; \
    EGLBoolean *ret = (EGLBoolean *)ret_v; \
    if (ret != NULL) { \
        *ret = eglMakeCurrent(args->dpy, args->draw, args->read, args->ctx);; \
    } else { \
        eglMakeCurrent(args->dpy, args->draw, args->read, args->ctx);; \
    } \
} while(0)
EGLBoolean eglMakeCurrent(eglMakeCurrent_ARG_EXPAND);
typedef EGLBoolean (*eglMakeCurrent_PTR)(eglMakeCurrent_ARG_EXPAND);
#define eglPostSubBufferNV_INDEX 45
#define eglPostSubBufferNV_RETURN EGLBoolean
#define eglPostSubBufferNV_ARG_NAMES dpy, surface, x, y, width, height
#define eglPostSubBufferNV_ARG_EXPAND EGLDisplay dpy, EGLSurface surface, EGLint x, EGLint y, EGLint width, EGLint height
#define eglPostSubBufferNV_PACKED PACKED_eglPostSubBufferNV
#define eglPostSubBufferNV_VOID_ONLY_WRAP(...) {}
#define eglPostSubBufferNV_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_eglPostSubBufferNV(_dpy, _surface, _x, _y, _width, _height) ({ \
    eglPostSubBufferNV_PACKED *packed_data = malloc(sizeof(eglPostSubBufferNV_PACKED)); \
    packed_data->index = eglPostSubBufferNV_INDEX; \
    packed_data->args.dpy = (EGLDisplay)_dpy; \
    packed_data->args.surface = (EGLSurface)_surface; \
    packed_data->args.x = (EGLint)_x; \
    packed_data->args.y = (EGLint)_y; \
    packed_data->args.width = (EGLint)_width; \
    packed_data->args.height = (EGLint)_height; \
    (packed_call_t *)packed_data; \
})
#define call_eglPostSubBufferNV(packed, ret_v) do { \
    PACKED_eglPostSubBufferNV *unpacked = (PACKED_eglPostSubBufferNV *)packed; \
    ARGS_eglPostSubBufferNV *args = (ARGS_eglPostSubBufferNV *)&unpacked->args; \
    EGLBoolean *ret = (EGLBoolean *)ret_v; \
    if (ret != NULL) { \
        *ret = eglPostSubBufferNV(args->dpy, args->surface, args->x, args->y, args->width, args->height);; \
    } else { \
        eglPostSubBufferNV(args->dpy, args->surface, args->x, args->y, args->width, args->height);; \
    } \
} while(0)
EGLBoolean eglPostSubBufferNV(eglPostSubBufferNV_ARG_EXPAND);
typedef EGLBoolean (*eglPostSubBufferNV_PTR)(eglPostSubBufferNV_ARG_EXPAND);
#define eglQueryAPI_INDEX 46
#define eglQueryAPI_RETURN EGLenum
#define eglQueryAPI_ARG_NAMES 
#define eglQueryAPI_ARG_EXPAND 
#define eglQueryAPI_PACKED PACKED_eglQueryAPI
#define eglQueryAPI_VOID_ONLY_WRAP(...) {}
#define eglQueryAPI_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_eglQueryAPI() ({ \
    eglQueryAPI_PACKED *packed_data = malloc(sizeof(eglQueryAPI_PACKED)); \
    packed_data->index = eglQueryAPI_INDEX; \
    (packed_call_t *)packed_data; \
})
#define call_eglQueryAPI(packed, ret_v) do { \
    EGLenum *ret = (EGLenum *)ret_v; \
    if (ret != NULL) { \
        *ret = eglQueryAPI();; \
    } else { \
        eglQueryAPI();; \
    } \
} while(0)
EGLenum eglQueryAPI(eglQueryAPI_ARG_EXPAND);
typedef EGLenum (*eglQueryAPI_PTR)(eglQueryAPI_ARG_EXPAND);
#define eglQueryContext_INDEX 47
#define eglQueryContext_RETURN EGLBoolean
#define eglQueryContext_ARG_NAMES dpy, ctx, attribute, value
#define eglQueryContext_ARG_EXPAND EGLDisplay dpy, EGLContext ctx, EGLint attribute, EGLint * value
#define eglQueryContext_PACKED PACKED_eglQueryContext
#define eglQueryContext_VOID_ONLY_WRAP(...) {}
#define eglQueryContext_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_eglQueryContext(_dpy, _ctx, _attribute, _value) ({ \
    eglQueryContext_PACKED *packed_data = malloc(sizeof(eglQueryContext_PACKED)); \
    packed_data->index = eglQueryContext_INDEX; \
    packed_data->args.dpy = (EGLDisplay)_dpy; \
    packed_data->args.ctx = (EGLContext)_ctx; \
    packed_data->args.attribute = (EGLint)_attribute; \
    packed_data->args.value = (EGLint *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_eglQueryContext(packed, ret_v) do { \
    PACKED_eglQueryContext *unpacked = (PACKED_eglQueryContext *)packed; \
    ARGS_eglQueryContext *args = (ARGS_eglQueryContext *)&unpacked->args; \
    EGLBoolean *ret = (EGLBoolean *)ret_v; \
    if (ret != NULL) { \
        *ret = eglQueryContext(args->dpy, args->ctx, args->attribute, args->value);; \
    } else { \
        eglQueryContext(args->dpy, args->ctx, args->attribute, args->value);; \
    } \
} while(0)
EGLBoolean eglQueryContext(eglQueryContext_ARG_EXPAND);
typedef EGLBoolean (*eglQueryContext_PTR)(eglQueryContext_ARG_EXPAND);
#define eglQueryNativeDisplayNV_INDEX 48
#define eglQueryNativeDisplayNV_RETURN EGLBoolean
#define eglQueryNativeDisplayNV_ARG_NAMES dpy, display_id
#define eglQueryNativeDisplayNV_ARG_EXPAND EGLDisplay dpy, EGLNativeDisplayType * display_id
#define eglQueryNativeDisplayNV_PACKED PACKED_eglQueryNativeDisplayNV
#define eglQueryNativeDisplayNV_VOID_ONLY_WRAP(...) {}
#define eglQueryNativeDisplayNV_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_eglQueryNativeDisplayNV(_dpy, _display_id) ({ \
    eglQueryNativeDisplayNV_PACKED *packed_data = malloc(sizeof(eglQueryNativeDisplayNV_PACKED)); \
    packed_data->index = eglQueryNativeDisplayNV_INDEX; \
    packed_data->args.dpy = (EGLDisplay)_dpy; \
    packed_data->args.display_id = (EGLNativeDisplayType *)_display_id; \
    (packed_call_t *)packed_data; \
})
#define call_eglQueryNativeDisplayNV(packed, ret_v) do { \
    PACKED_eglQueryNativeDisplayNV *unpacked = (PACKED_eglQueryNativeDisplayNV *)packed; \
    ARGS_eglQueryNativeDisplayNV *args = (ARGS_eglQueryNativeDisplayNV *)&unpacked->args; \
    EGLBoolean *ret = (EGLBoolean *)ret_v; \
    if (ret != NULL) { \
        *ret = eglQueryNativeDisplayNV(args->dpy, args->display_id);; \
    } else { \
        eglQueryNativeDisplayNV(args->dpy, args->display_id);; \
    } \
} while(0)
EGLBoolean eglQueryNativeDisplayNV(eglQueryNativeDisplayNV_ARG_EXPAND);
typedef EGLBoolean (*eglQueryNativeDisplayNV_PTR)(eglQueryNativeDisplayNV_ARG_EXPAND);
#define eglQueryNativePixmapNV_INDEX 49
#define eglQueryNativePixmapNV_RETURN EGLBoolean
#define eglQueryNativePixmapNV_ARG_NAMES dpy, surf, pixmap
#define eglQueryNativePixmapNV_ARG_EXPAND EGLDisplay dpy, EGLSurface surf, EGLNativePixmapType * pixmap
#define eglQueryNativePixmapNV_PACKED PACKED_eglQueryNativePixmapNV
#define eglQueryNativePixmapNV_VOID_ONLY_WRAP(...) {}
#define eglQueryNativePixmapNV_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_eglQueryNativePixmapNV(_dpy, _surf, _pixmap) ({ \
    eglQueryNativePixmapNV_PACKED *packed_data = malloc(sizeof(eglQueryNativePixmapNV_PACKED)); \
    packed_data->index = eglQueryNativePixmapNV_INDEX; \
    packed_data->args.dpy = (EGLDisplay)_dpy; \
    packed_data->args.surf = (EGLSurface)_surf; \
    packed_data->args.pixmap = (EGLNativePixmapType *)_pixmap; \
    (packed_call_t *)packed_data; \
})
#define call_eglQueryNativePixmapNV(packed, ret_v) do { \
    PACKED_eglQueryNativePixmapNV *unpacked = (PACKED_eglQueryNativePixmapNV *)packed; \
    ARGS_eglQueryNativePixmapNV *args = (ARGS_eglQueryNativePixmapNV *)&unpacked->args; \
    EGLBoolean *ret = (EGLBoolean *)ret_v; \
    if (ret != NULL) { \
        *ret = eglQueryNativePixmapNV(args->dpy, args->surf, args->pixmap);; \
    } else { \
        eglQueryNativePixmapNV(args->dpy, args->surf, args->pixmap);; \
    } \
} while(0)
EGLBoolean eglQueryNativePixmapNV(eglQueryNativePixmapNV_ARG_EXPAND);
typedef EGLBoolean (*eglQueryNativePixmapNV_PTR)(eglQueryNativePixmapNV_ARG_EXPAND);
#define eglQueryNativeWindowNV_INDEX 50
#define eglQueryNativeWindowNV_RETURN EGLBoolean
#define eglQueryNativeWindowNV_ARG_NAMES dpy, surf, window
#define eglQueryNativeWindowNV_ARG_EXPAND EGLDisplay dpy, EGLSurface surf, EGLNativeWindowType * window
#define eglQueryNativeWindowNV_PACKED PACKED_eglQueryNativeWindowNV
#define eglQueryNativeWindowNV_VOID_ONLY_WRAP(...) {}
#define eglQueryNativeWindowNV_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_eglQueryNativeWindowNV(_dpy, _surf, _window) ({ \
    eglQueryNativeWindowNV_PACKED *packed_data = malloc(sizeof(eglQueryNativeWindowNV_PACKED)); \
    packed_data->index = eglQueryNativeWindowNV_INDEX; \
    packed_data->args.dpy = (EGLDisplay)_dpy; \
    packed_data->args.surf = (EGLSurface)_surf; \
    packed_data->args.window = (EGLNativeWindowType *)_window; \
    (packed_call_t *)packed_data; \
})
#define call_eglQueryNativeWindowNV(packed, ret_v) do { \
    PACKED_eglQueryNativeWindowNV *unpacked = (PACKED_eglQueryNativeWindowNV *)packed; \
    ARGS_eglQueryNativeWindowNV *args = (ARGS_eglQueryNativeWindowNV *)&unpacked->args; \
    EGLBoolean *ret = (EGLBoolean *)ret_v; \
    if (ret != NULL) { \
        *ret = eglQueryNativeWindowNV(args->dpy, args->surf, args->window);; \
    } else { \
        eglQueryNativeWindowNV(args->dpy, args->surf, args->window);; \
    } \
} while(0)
EGLBoolean eglQueryNativeWindowNV(eglQueryNativeWindowNV_ARG_EXPAND);
typedef EGLBoolean (*eglQueryNativeWindowNV_PTR)(eglQueryNativeWindowNV_ARG_EXPAND);
#define eglQueryStreamKHR_INDEX 51
#define eglQueryStreamKHR_RETURN EGLBoolean
#define eglQueryStreamKHR_ARG_NAMES dpy, stream, attribute, value
#define eglQueryStreamKHR_ARG_EXPAND EGLDisplay dpy, EGLStreamKHR stream, EGLenum attribute, EGLint * value
#define eglQueryStreamKHR_PACKED PACKED_eglQueryStreamKHR
#define eglQueryStreamKHR_VOID_ONLY_WRAP(...) {}
#define eglQueryStreamKHR_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_eglQueryStreamKHR(_dpy, _stream, _attribute, _value) ({ \
    eglQueryStreamKHR_PACKED *packed_data = malloc(sizeof(eglQueryStreamKHR_PACKED)); \
    packed_data->index = eglQueryStreamKHR_INDEX; \
    packed_data->args.dpy = (EGLDisplay)_dpy; \
    packed_data->args.stream = (EGLStreamKHR)_stream; \
    packed_data->args.attribute = (EGLenum)_attribute; \
    packed_data->args.value = (EGLint *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_eglQueryStreamKHR(packed, ret_v) do { \
    PACKED_eglQueryStreamKHR *unpacked = (PACKED_eglQueryStreamKHR *)packed; \
    ARGS_eglQueryStreamKHR *args = (ARGS_eglQueryStreamKHR *)&unpacked->args; \
    EGLBoolean *ret = (EGLBoolean *)ret_v; \
    if (ret != NULL) { \
        *ret = eglQueryStreamKHR(args->dpy, args->stream, args->attribute, args->value);; \
    } else { \
        eglQueryStreamKHR(args->dpy, args->stream, args->attribute, args->value);; \
    } \
} while(0)
EGLBoolean eglQueryStreamKHR(eglQueryStreamKHR_ARG_EXPAND);
typedef EGLBoolean (*eglQueryStreamKHR_PTR)(eglQueryStreamKHR_ARG_EXPAND);
#define eglQueryStreamTimeKHR_INDEX 52
#define eglQueryStreamTimeKHR_RETURN EGLBoolean
#define eglQueryStreamTimeKHR_ARG_NAMES dpy, stream, attribute, value
#define eglQueryStreamTimeKHR_ARG_EXPAND EGLDisplay dpy, EGLStreamKHR stream, EGLenum attribute, EGLTimeKHR * value
#define eglQueryStreamTimeKHR_PACKED PACKED_eglQueryStreamTimeKHR
#define eglQueryStreamTimeKHR_VOID_ONLY_WRAP(...) {}
#define eglQueryStreamTimeKHR_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_eglQueryStreamTimeKHR(_dpy, _stream, _attribute, _value) ({ \
    eglQueryStreamTimeKHR_PACKED *packed_data = malloc(sizeof(eglQueryStreamTimeKHR_PACKED)); \
    packed_data->index = eglQueryStreamTimeKHR_INDEX; \
    packed_data->args.dpy = (EGLDisplay)_dpy; \
    packed_data->args.stream = (EGLStreamKHR)_stream; \
    packed_data->args.attribute = (EGLenum)_attribute; \
    packed_data->args.value = (EGLTimeKHR *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_eglQueryStreamTimeKHR(packed, ret_v) do { \
    PACKED_eglQueryStreamTimeKHR *unpacked = (PACKED_eglQueryStreamTimeKHR *)packed; \
    ARGS_eglQueryStreamTimeKHR *args = (ARGS_eglQueryStreamTimeKHR *)&unpacked->args; \
    EGLBoolean *ret = (EGLBoolean *)ret_v; \
    if (ret != NULL) { \
        *ret = eglQueryStreamTimeKHR(args->dpy, args->stream, args->attribute, args->value);; \
    } else { \
        eglQueryStreamTimeKHR(args->dpy, args->stream, args->attribute, args->value);; \
    } \
} while(0)
EGLBoolean eglQueryStreamTimeKHR(eglQueryStreamTimeKHR_ARG_EXPAND);
typedef EGLBoolean (*eglQueryStreamTimeKHR_PTR)(eglQueryStreamTimeKHR_ARG_EXPAND);
#define eglQueryStreamu64KHR_INDEX 53
#define eglQueryStreamu64KHR_RETURN EGLBoolean
#define eglQueryStreamu64KHR_ARG_NAMES dpy, stream, attribute, value
#define eglQueryStreamu64KHR_ARG_EXPAND EGLDisplay dpy, EGLStreamKHR stream, EGLenum attribute, EGLuint64KHR * value
#define eglQueryStreamu64KHR_PACKED PACKED_eglQueryStreamu64KHR
#define eglQueryStreamu64KHR_VOID_ONLY_WRAP(...) {}
#define eglQueryStreamu64KHR_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_eglQueryStreamu64KHR(_dpy, _stream, _attribute, _value) ({ \
    eglQueryStreamu64KHR_PACKED *packed_data = malloc(sizeof(eglQueryStreamu64KHR_PACKED)); \
    packed_data->index = eglQueryStreamu64KHR_INDEX; \
    packed_data->args.dpy = (EGLDisplay)_dpy; \
    packed_data->args.stream = (EGLStreamKHR)_stream; \
    packed_data->args.attribute = (EGLenum)_attribute; \
    packed_data->args.value = (EGLuint64KHR *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_eglQueryStreamu64KHR(packed, ret_v) do { \
    PACKED_eglQueryStreamu64KHR *unpacked = (PACKED_eglQueryStreamu64KHR *)packed; \
    ARGS_eglQueryStreamu64KHR *args = (ARGS_eglQueryStreamu64KHR *)&unpacked->args; \
    EGLBoolean *ret = (EGLBoolean *)ret_v; \
    if (ret != NULL) { \
        *ret = eglQueryStreamu64KHR(args->dpy, args->stream, args->attribute, args->value);; \
    } else { \
        eglQueryStreamu64KHR(args->dpy, args->stream, args->attribute, args->value);; \
    } \
} while(0)
EGLBoolean eglQueryStreamu64KHR(eglQueryStreamu64KHR_ARG_EXPAND);
typedef EGLBoolean (*eglQueryStreamu64KHR_PTR)(eglQueryStreamu64KHR_ARG_EXPAND);
#define eglQueryString_INDEX 54
#define eglQueryString_RETURN const char *
#define eglQueryString_ARG_NAMES dpy, name
#define eglQueryString_ARG_EXPAND EGLDisplay dpy, EGLint name
#define eglQueryString_PACKED PACKED_eglQueryString
#define eglQueryString_VOID_ONLY_WRAP(...) {}
#define eglQueryString_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_eglQueryString(_dpy, _name) ({ \
    eglQueryString_PACKED *packed_data = malloc(sizeof(eglQueryString_PACKED)); \
    packed_data->index = eglQueryString_INDEX; \
    packed_data->args.dpy = (EGLDisplay)_dpy; \
    packed_data->args.name = (EGLint)_name; \
    (packed_call_t *)packed_data; \
})
#define call_eglQueryString(packed, ret_v) do { \
    PACKED_eglQueryString *unpacked = (PACKED_eglQueryString *)packed; \
    ARGS_eglQueryString *args = (ARGS_eglQueryString *)&unpacked->args; \
    const char * *ret = (const char * *)ret_v; \
    if (ret != NULL) { \
        *ret = eglQueryString(args->dpy, args->name);; \
    } else { \
        eglQueryString(args->dpy, args->name);; \
    } \
} while(0)
const char * eglQueryString(eglQueryString_ARG_EXPAND);
typedef const char * (*eglQueryString_PTR)(eglQueryString_ARG_EXPAND);
#define eglQuerySurface_INDEX 55
#define eglQuerySurface_RETURN EGLBoolean
#define eglQuerySurface_ARG_NAMES dpy, surface, attribute, value
#define eglQuerySurface_ARG_EXPAND EGLDisplay dpy, EGLSurface surface, EGLint attribute, EGLint * value
#define eglQuerySurface_PACKED PACKED_eglQuerySurface
#define eglQuerySurface_VOID_ONLY_WRAP(...) {}
#define eglQuerySurface_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_eglQuerySurface(_dpy, _surface, _attribute, _value) ({ \
    eglQuerySurface_PACKED *packed_data = malloc(sizeof(eglQuerySurface_PACKED)); \
    packed_data->index = eglQuerySurface_INDEX; \
    packed_data->args.dpy = (EGLDisplay)_dpy; \
    packed_data->args.surface = (EGLSurface)_surface; \
    packed_data->args.attribute = (EGLint)_attribute; \
    packed_data->args.value = (EGLint *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_eglQuerySurface(packed, ret_v) do { \
    PACKED_eglQuerySurface *unpacked = (PACKED_eglQuerySurface *)packed; \
    ARGS_eglQuerySurface *args = (ARGS_eglQuerySurface *)&unpacked->args; \
    EGLBoolean *ret = (EGLBoolean *)ret_v; \
    if (ret != NULL) { \
        *ret = eglQuerySurface(args->dpy, args->surface, args->attribute, args->value);; \
    } else { \
        eglQuerySurface(args->dpy, args->surface, args->attribute, args->value);; \
    } \
} while(0)
EGLBoolean eglQuerySurface(eglQuerySurface_ARG_EXPAND);
typedef EGLBoolean (*eglQuerySurface_PTR)(eglQuerySurface_ARG_EXPAND);
#define eglQuerySurfacePointerANGLE_INDEX 56
#define eglQuerySurfacePointerANGLE_RETURN EGLBoolean
#define eglQuerySurfacePointerANGLE_ARG_NAMES dpy, surface, attribute, value
#define eglQuerySurfacePointerANGLE_ARG_EXPAND EGLDisplay dpy, EGLSurface surface, EGLint attribute, void ** value
#define eglQuerySurfacePointerANGLE_PACKED PACKED_eglQuerySurfacePointerANGLE
#define eglQuerySurfacePointerANGLE_VOID_ONLY_WRAP(...) {}
#define eglQuerySurfacePointerANGLE_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_eglQuerySurfacePointerANGLE(_dpy, _surface, _attribute, _value) ({ \
    eglQuerySurfacePointerANGLE_PACKED *packed_data = malloc(sizeof(eglQuerySurfacePointerANGLE_PACKED)); \
    packed_data->index = eglQuerySurfacePointerANGLE_INDEX; \
    packed_data->args.dpy = (EGLDisplay)_dpy; \
    packed_data->args.surface = (EGLSurface)_surface; \
    packed_data->args.attribute = (EGLint)_attribute; \
    packed_data->args.value = (void **)_value; \
    (packed_call_t *)packed_data; \
})
#define call_eglQuerySurfacePointerANGLE(packed, ret_v) do { \
    PACKED_eglQuerySurfacePointerANGLE *unpacked = (PACKED_eglQuerySurfacePointerANGLE *)packed; \
    ARGS_eglQuerySurfacePointerANGLE *args = (ARGS_eglQuerySurfacePointerANGLE *)&unpacked->args; \
    EGLBoolean *ret = (EGLBoolean *)ret_v; \
    if (ret != NULL) { \
        *ret = eglQuerySurfacePointerANGLE(args->dpy, args->surface, args->attribute, args->value);; \
    } else { \
        eglQuerySurfacePointerANGLE(args->dpy, args->surface, args->attribute, args->value);; \
    } \
} while(0)
EGLBoolean eglQuerySurfacePointerANGLE(eglQuerySurfacePointerANGLE_ARG_EXPAND);
typedef EGLBoolean (*eglQuerySurfacePointerANGLE_PTR)(eglQuerySurfacePointerANGLE_ARG_EXPAND);
#define eglReleaseTexImage_INDEX 57
#define eglReleaseTexImage_RETURN EGLBoolean
#define eglReleaseTexImage_ARG_NAMES dpy, surface, buffer
#define eglReleaseTexImage_ARG_EXPAND EGLDisplay dpy, EGLSurface surface, EGLint buffer
#define eglReleaseTexImage_PACKED PACKED_eglReleaseTexImage
#define eglReleaseTexImage_VOID_ONLY_WRAP(...) {}
#define eglReleaseTexImage_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_eglReleaseTexImage(_dpy, _surface, _buffer) ({ \
    eglReleaseTexImage_PACKED *packed_data = malloc(sizeof(eglReleaseTexImage_PACKED)); \
    packed_data->index = eglReleaseTexImage_INDEX; \
    packed_data->args.dpy = (EGLDisplay)_dpy; \
    packed_data->args.surface = (EGLSurface)_surface; \
    packed_data->args.buffer = (EGLint)_buffer; \
    (packed_call_t *)packed_data; \
})
#define call_eglReleaseTexImage(packed, ret_v) do { \
    PACKED_eglReleaseTexImage *unpacked = (PACKED_eglReleaseTexImage *)packed; \
    ARGS_eglReleaseTexImage *args = (ARGS_eglReleaseTexImage *)&unpacked->args; \
    EGLBoolean *ret = (EGLBoolean *)ret_v; \
    if (ret != NULL) { \
        *ret = eglReleaseTexImage(args->dpy, args->surface, args->buffer);; \
    } else { \
        eglReleaseTexImage(args->dpy, args->surface, args->buffer);; \
    } \
} while(0)
EGLBoolean eglReleaseTexImage(eglReleaseTexImage_ARG_EXPAND);
typedef EGLBoolean (*eglReleaseTexImage_PTR)(eglReleaseTexImage_ARG_EXPAND);
#define eglReleaseThread_INDEX 58
#define eglReleaseThread_RETURN EGLBoolean
#define eglReleaseThread_ARG_NAMES 
#define eglReleaseThread_ARG_EXPAND 
#define eglReleaseThread_PACKED PACKED_eglReleaseThread
#define eglReleaseThread_VOID_ONLY_WRAP(...) {}
#define eglReleaseThread_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_eglReleaseThread() ({ \
    eglReleaseThread_PACKED *packed_data = malloc(sizeof(eglReleaseThread_PACKED)); \
    packed_data->index = eglReleaseThread_INDEX; \
    (packed_call_t *)packed_data; \
})
#define call_eglReleaseThread(packed, ret_v) do { \
    EGLBoolean *ret = (EGLBoolean *)ret_v; \
    if (ret != NULL) { \
        *ret = eglReleaseThread();; \
    } else { \
        eglReleaseThread();; \
    } \
} while(0)
EGLBoolean eglReleaseThread(eglReleaseThread_ARG_EXPAND);
typedef EGLBoolean (*eglReleaseThread_PTR)(eglReleaseThread_ARG_EXPAND);
#define eglSignalSyncKHR_INDEX 59
#define eglSignalSyncKHR_RETURN EGLBoolean
#define eglSignalSyncKHR_ARG_NAMES dpy, sync, mode
#define eglSignalSyncKHR_ARG_EXPAND EGLDisplay dpy, EGLSyncKHR sync, EGLenum mode
#define eglSignalSyncKHR_PACKED PACKED_eglSignalSyncKHR
#define eglSignalSyncKHR_VOID_ONLY_WRAP(...) {}
#define eglSignalSyncKHR_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_eglSignalSyncKHR(_dpy, _sync, _mode) ({ \
    eglSignalSyncKHR_PACKED *packed_data = malloc(sizeof(eglSignalSyncKHR_PACKED)); \
    packed_data->index = eglSignalSyncKHR_INDEX; \
    packed_data->args.dpy = (EGLDisplay)_dpy; \
    packed_data->args.sync = (EGLSyncKHR)_sync; \
    packed_data->args.mode = (EGLenum)_mode; \
    (packed_call_t *)packed_data; \
})
#define call_eglSignalSyncKHR(packed, ret_v) do { \
    PACKED_eglSignalSyncKHR *unpacked = (PACKED_eglSignalSyncKHR *)packed; \
    ARGS_eglSignalSyncKHR *args = (ARGS_eglSignalSyncKHR *)&unpacked->args; \
    EGLBoolean *ret = (EGLBoolean *)ret_v; \
    if (ret != NULL) { \
        *ret = eglSignalSyncKHR(args->dpy, args->sync, args->mode);; \
    } else { \
        eglSignalSyncKHR(args->dpy, args->sync, args->mode);; \
    } \
} while(0)
EGLBoolean eglSignalSyncKHR(eglSignalSyncKHR_ARG_EXPAND);
typedef EGLBoolean (*eglSignalSyncKHR_PTR)(eglSignalSyncKHR_ARG_EXPAND);
#define eglSignalSyncNV_INDEX 60
#define eglSignalSyncNV_RETURN EGLBoolean
#define eglSignalSyncNV_ARG_NAMES sync, mode
#define eglSignalSyncNV_ARG_EXPAND EGLSyncNV sync, EGLenum mode
#define eglSignalSyncNV_PACKED PACKED_eglSignalSyncNV
#define eglSignalSyncNV_VOID_ONLY_WRAP(...) {}
#define eglSignalSyncNV_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_eglSignalSyncNV(_sync, _mode) ({ \
    eglSignalSyncNV_PACKED *packed_data = malloc(sizeof(eglSignalSyncNV_PACKED)); \
    packed_data->index = eglSignalSyncNV_INDEX; \
    packed_data->args.sync = (EGLSyncNV)_sync; \
    packed_data->args.mode = (EGLenum)_mode; \
    (packed_call_t *)packed_data; \
})
#define call_eglSignalSyncNV(packed, ret_v) do { \
    PACKED_eglSignalSyncNV *unpacked = (PACKED_eglSignalSyncNV *)packed; \
    ARGS_eglSignalSyncNV *args = (ARGS_eglSignalSyncNV *)&unpacked->args; \
    EGLBoolean *ret = (EGLBoolean *)ret_v; \
    if (ret != NULL) { \
        *ret = eglSignalSyncNV(args->sync, args->mode);; \
    } else { \
        eglSignalSyncNV(args->sync, args->mode);; \
    } \
} while(0)
EGLBoolean eglSignalSyncNV(eglSignalSyncNV_ARG_EXPAND);
typedef EGLBoolean (*eglSignalSyncNV_PTR)(eglSignalSyncNV_ARG_EXPAND);
#define eglStreamAttribKHR_INDEX 61
#define eglStreamAttribKHR_RETURN EGLBoolean
#define eglStreamAttribKHR_ARG_NAMES dpy, stream, attribute, value
#define eglStreamAttribKHR_ARG_EXPAND EGLDisplay dpy, EGLStreamKHR stream, EGLenum attribute, EGLint value
#define eglStreamAttribKHR_PACKED PACKED_eglStreamAttribKHR
#define eglStreamAttribKHR_VOID_ONLY_WRAP(...) {}
#define eglStreamAttribKHR_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_eglStreamAttribKHR(_dpy, _stream, _attribute, _value) ({ \
    eglStreamAttribKHR_PACKED *packed_data = malloc(sizeof(eglStreamAttribKHR_PACKED)); \
    packed_data->index = eglStreamAttribKHR_INDEX; \
    packed_data->args.dpy = (EGLDisplay)_dpy; \
    packed_data->args.stream = (EGLStreamKHR)_stream; \
    packed_data->args.attribute = (EGLenum)_attribute; \
    packed_data->args.value = (EGLint)_value; \
    (packed_call_t *)packed_data; \
})
#define call_eglStreamAttribKHR(packed, ret_v) do { \
    PACKED_eglStreamAttribKHR *unpacked = (PACKED_eglStreamAttribKHR *)packed; \
    ARGS_eglStreamAttribKHR *args = (ARGS_eglStreamAttribKHR *)&unpacked->args; \
    EGLBoolean *ret = (EGLBoolean *)ret_v; \
    if (ret != NULL) { \
        *ret = eglStreamAttribKHR(args->dpy, args->stream, args->attribute, args->value);; \
    } else { \
        eglStreamAttribKHR(args->dpy, args->stream, args->attribute, args->value);; \
    } \
} while(0)
EGLBoolean eglStreamAttribKHR(eglStreamAttribKHR_ARG_EXPAND);
typedef EGLBoolean (*eglStreamAttribKHR_PTR)(eglStreamAttribKHR_ARG_EXPAND);
#define eglStreamConsumerAcquireKHR_INDEX 62
#define eglStreamConsumerAcquireKHR_RETURN EGLBoolean
#define eglStreamConsumerAcquireKHR_ARG_NAMES dpy, stream
#define eglStreamConsumerAcquireKHR_ARG_EXPAND EGLDisplay dpy, EGLStreamKHR stream
#define eglStreamConsumerAcquireKHR_PACKED PACKED_eglStreamConsumerAcquireKHR
#define eglStreamConsumerAcquireKHR_VOID_ONLY_WRAP(...) {}
#define eglStreamConsumerAcquireKHR_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_eglStreamConsumerAcquireKHR(_dpy, _stream) ({ \
    eglStreamConsumerAcquireKHR_PACKED *packed_data = malloc(sizeof(eglStreamConsumerAcquireKHR_PACKED)); \
    packed_data->index = eglStreamConsumerAcquireKHR_INDEX; \
    packed_data->args.dpy = (EGLDisplay)_dpy; \
    packed_data->args.stream = (EGLStreamKHR)_stream; \
    (packed_call_t *)packed_data; \
})
#define call_eglStreamConsumerAcquireKHR(packed, ret_v) do { \
    PACKED_eglStreamConsumerAcquireKHR *unpacked = (PACKED_eglStreamConsumerAcquireKHR *)packed; \
    ARGS_eglStreamConsumerAcquireKHR *args = (ARGS_eglStreamConsumerAcquireKHR *)&unpacked->args; \
    EGLBoolean *ret = (EGLBoolean *)ret_v; \
    if (ret != NULL) { \
        *ret = eglStreamConsumerAcquireKHR(args->dpy, args->stream);; \
    } else { \
        eglStreamConsumerAcquireKHR(args->dpy, args->stream);; \
    } \
} while(0)
EGLBoolean eglStreamConsumerAcquireKHR(eglStreamConsumerAcquireKHR_ARG_EXPAND);
typedef EGLBoolean (*eglStreamConsumerAcquireKHR_PTR)(eglStreamConsumerAcquireKHR_ARG_EXPAND);
#define eglStreamConsumerGLTextureExternalKHR_INDEX 63
#define eglStreamConsumerGLTextureExternalKHR_RETURN EGLBoolean
#define eglStreamConsumerGLTextureExternalKHR_ARG_NAMES dpy, stream
#define eglStreamConsumerGLTextureExternalKHR_ARG_EXPAND EGLDisplay dpy, EGLStreamKHR stream
#define eglStreamConsumerGLTextureExternalKHR_PACKED PACKED_eglStreamConsumerGLTextureExternalKHR
#define eglStreamConsumerGLTextureExternalKHR_VOID_ONLY_WRAP(...) {}
#define eglStreamConsumerGLTextureExternalKHR_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_eglStreamConsumerGLTextureExternalKHR(_dpy, _stream) ({ \
    eglStreamConsumerGLTextureExternalKHR_PACKED *packed_data = malloc(sizeof(eglStreamConsumerGLTextureExternalKHR_PACKED)); \
    packed_data->index = eglStreamConsumerGLTextureExternalKHR_INDEX; \
    packed_data->args.dpy = (EGLDisplay)_dpy; \
    packed_data->args.stream = (EGLStreamKHR)_stream; \
    (packed_call_t *)packed_data; \
})
#define call_eglStreamConsumerGLTextureExternalKHR(packed, ret_v) do { \
    PACKED_eglStreamConsumerGLTextureExternalKHR *unpacked = (PACKED_eglStreamConsumerGLTextureExternalKHR *)packed; \
    ARGS_eglStreamConsumerGLTextureExternalKHR *args = (ARGS_eglStreamConsumerGLTextureExternalKHR *)&unpacked->args; \
    EGLBoolean *ret = (EGLBoolean *)ret_v; \
    if (ret != NULL) { \
        *ret = eglStreamConsumerGLTextureExternalKHR(args->dpy, args->stream);; \
    } else { \
        eglStreamConsumerGLTextureExternalKHR(args->dpy, args->stream);; \
    } \
} while(0)
EGLBoolean eglStreamConsumerGLTextureExternalKHR(eglStreamConsumerGLTextureExternalKHR_ARG_EXPAND);
typedef EGLBoolean (*eglStreamConsumerGLTextureExternalKHR_PTR)(eglStreamConsumerGLTextureExternalKHR_ARG_EXPAND);
#define eglStreamConsumerReleaseKHR_INDEX 64
#define eglStreamConsumerReleaseKHR_RETURN EGLBoolean
#define eglStreamConsumerReleaseKHR_ARG_NAMES dpy, stream
#define eglStreamConsumerReleaseKHR_ARG_EXPAND EGLDisplay dpy, EGLStreamKHR stream
#define eglStreamConsumerReleaseKHR_PACKED PACKED_eglStreamConsumerReleaseKHR
#define eglStreamConsumerReleaseKHR_VOID_ONLY_WRAP(...) {}
#define eglStreamConsumerReleaseKHR_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_eglStreamConsumerReleaseKHR(_dpy, _stream) ({ \
    eglStreamConsumerReleaseKHR_PACKED *packed_data = malloc(sizeof(eglStreamConsumerReleaseKHR_PACKED)); \
    packed_data->index = eglStreamConsumerReleaseKHR_INDEX; \
    packed_data->args.dpy = (EGLDisplay)_dpy; \
    packed_data->args.stream = (EGLStreamKHR)_stream; \
    (packed_call_t *)packed_data; \
})
#define call_eglStreamConsumerReleaseKHR(packed, ret_v) do { \
    PACKED_eglStreamConsumerReleaseKHR *unpacked = (PACKED_eglStreamConsumerReleaseKHR *)packed; \
    ARGS_eglStreamConsumerReleaseKHR *args = (ARGS_eglStreamConsumerReleaseKHR *)&unpacked->args; \
    EGLBoolean *ret = (EGLBoolean *)ret_v; \
    if (ret != NULL) { \
        *ret = eglStreamConsumerReleaseKHR(args->dpy, args->stream);; \
    } else { \
        eglStreamConsumerReleaseKHR(args->dpy, args->stream);; \
    } \
} while(0)
EGLBoolean eglStreamConsumerReleaseKHR(eglStreamConsumerReleaseKHR_ARG_EXPAND);
typedef EGLBoolean (*eglStreamConsumerReleaseKHR_PTR)(eglStreamConsumerReleaseKHR_ARG_EXPAND);
#define eglSurfaceAttrib_INDEX 65
#define eglSurfaceAttrib_RETURN EGLBoolean
#define eglSurfaceAttrib_ARG_NAMES dpy, surface, attribute, value
#define eglSurfaceAttrib_ARG_EXPAND EGLDisplay dpy, EGLSurface surface, EGLint attribute, EGLint value
#define eglSurfaceAttrib_PACKED PACKED_eglSurfaceAttrib
#define eglSurfaceAttrib_VOID_ONLY_WRAP(...) {}
#define eglSurfaceAttrib_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_eglSurfaceAttrib(_dpy, _surface, _attribute, _value) ({ \
    eglSurfaceAttrib_PACKED *packed_data = malloc(sizeof(eglSurfaceAttrib_PACKED)); \
    packed_data->index = eglSurfaceAttrib_INDEX; \
    packed_data->args.dpy = (EGLDisplay)_dpy; \
    packed_data->args.surface = (EGLSurface)_surface; \
    packed_data->args.attribute = (EGLint)_attribute; \
    packed_data->args.value = (EGLint)_value; \
    (packed_call_t *)packed_data; \
})
#define call_eglSurfaceAttrib(packed, ret_v) do { \
    PACKED_eglSurfaceAttrib *unpacked = (PACKED_eglSurfaceAttrib *)packed; \
    ARGS_eglSurfaceAttrib *args = (ARGS_eglSurfaceAttrib *)&unpacked->args; \
    EGLBoolean *ret = (EGLBoolean *)ret_v; \
    if (ret != NULL) { \
        *ret = eglSurfaceAttrib(args->dpy, args->surface, args->attribute, args->value);; \
    } else { \
        eglSurfaceAttrib(args->dpy, args->surface, args->attribute, args->value);; \
    } \
} while(0)
EGLBoolean eglSurfaceAttrib(eglSurfaceAttrib_ARG_EXPAND);
typedef EGLBoolean (*eglSurfaceAttrib_PTR)(eglSurfaceAttrib_ARG_EXPAND);
#define eglSwapBuffers_INDEX 66
#define eglSwapBuffers_RETURN EGLBoolean
#define eglSwapBuffers_ARG_NAMES dpy, surface
#define eglSwapBuffers_ARG_EXPAND EGLDisplay dpy, EGLSurface surface
#define eglSwapBuffers_PACKED PACKED_eglSwapBuffers
#define eglSwapBuffers_VOID_ONLY_WRAP(...) {}
#define eglSwapBuffers_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_eglSwapBuffers(_dpy, _surface) ({ \
    eglSwapBuffers_PACKED *packed_data = malloc(sizeof(eglSwapBuffers_PACKED)); \
    packed_data->index = eglSwapBuffers_INDEX; \
    packed_data->args.dpy = (EGLDisplay)_dpy; \
    packed_data->args.surface = (EGLSurface)_surface; \
    (packed_call_t *)packed_data; \
})
#define call_eglSwapBuffers(packed, ret_v) do { \
    PACKED_eglSwapBuffers *unpacked = (PACKED_eglSwapBuffers *)packed; \
    ARGS_eglSwapBuffers *args = (ARGS_eglSwapBuffers *)&unpacked->args; \
    EGLBoolean *ret = (EGLBoolean *)ret_v; \
    if (ret != NULL) { \
        *ret = eglSwapBuffers(args->dpy, args->surface);; \
    } else { \
        eglSwapBuffers(args->dpy, args->surface);; \
    } \
} while(0)
EGLBoolean eglSwapBuffers(eglSwapBuffers_ARG_EXPAND);
typedef EGLBoolean (*eglSwapBuffers_PTR)(eglSwapBuffers_ARG_EXPAND);
#define eglSwapBuffersWithDamageEXT_INDEX 67
#define eglSwapBuffersWithDamageEXT_RETURN EGLBoolean
#define eglSwapBuffersWithDamageEXT_ARG_NAMES dpy, surface, rects, n_rects
#define eglSwapBuffersWithDamageEXT_ARG_EXPAND EGLDisplay dpy, EGLSurface surface, EGLint * rects, EGLint n_rects
#define eglSwapBuffersWithDamageEXT_PACKED PACKED_eglSwapBuffersWithDamageEXT
#define eglSwapBuffersWithDamageEXT_VOID_ONLY_WRAP(...) {}
#define eglSwapBuffersWithDamageEXT_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_eglSwapBuffersWithDamageEXT(_dpy, _surface, _rects, _n_rects) ({ \
    eglSwapBuffersWithDamageEXT_PACKED *packed_data = malloc(sizeof(eglSwapBuffersWithDamageEXT_PACKED)); \
    packed_data->index = eglSwapBuffersWithDamageEXT_INDEX; \
    packed_data->args.dpy = (EGLDisplay)_dpy; \
    packed_data->args.surface = (EGLSurface)_surface; \
    packed_data->args.rects = (EGLint *)_rects; \
    packed_data->args.n_rects = (EGLint)_n_rects; \
    (packed_call_t *)packed_data; \
})
#define call_eglSwapBuffersWithDamageEXT(packed, ret_v) do { \
    PACKED_eglSwapBuffersWithDamageEXT *unpacked = (PACKED_eglSwapBuffersWithDamageEXT *)packed; \
    ARGS_eglSwapBuffersWithDamageEXT *args = (ARGS_eglSwapBuffersWithDamageEXT *)&unpacked->args; \
    EGLBoolean *ret = (EGLBoolean *)ret_v; \
    if (ret != NULL) { \
        *ret = eglSwapBuffersWithDamageEXT(args->dpy, args->surface, args->rects, args->n_rects);; \
    } else { \
        eglSwapBuffersWithDamageEXT(args->dpy, args->surface, args->rects, args->n_rects);; \
    } \
} while(0)
EGLBoolean eglSwapBuffersWithDamageEXT(eglSwapBuffersWithDamageEXT_ARG_EXPAND);
typedef EGLBoolean (*eglSwapBuffersWithDamageEXT_PTR)(eglSwapBuffersWithDamageEXT_ARG_EXPAND);
#define eglSwapInterval_INDEX 68
#define eglSwapInterval_RETURN EGLBoolean
#define eglSwapInterval_ARG_NAMES dpy, interval
#define eglSwapInterval_ARG_EXPAND EGLDisplay dpy, EGLint interval
#define eglSwapInterval_PACKED PACKED_eglSwapInterval
#define eglSwapInterval_VOID_ONLY_WRAP(...) {}
#define eglSwapInterval_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_eglSwapInterval(_dpy, _interval) ({ \
    eglSwapInterval_PACKED *packed_data = malloc(sizeof(eglSwapInterval_PACKED)); \
    packed_data->index = eglSwapInterval_INDEX; \
    packed_data->args.dpy = (EGLDisplay)_dpy; \
    packed_data->args.interval = (EGLint)_interval; \
    (packed_call_t *)packed_data; \
})
#define call_eglSwapInterval(packed, ret_v) do { \
    PACKED_eglSwapInterval *unpacked = (PACKED_eglSwapInterval *)packed; \
    ARGS_eglSwapInterval *args = (ARGS_eglSwapInterval *)&unpacked->args; \
    EGLBoolean *ret = (EGLBoolean *)ret_v; \
    if (ret != NULL) { \
        *ret = eglSwapInterval(args->dpy, args->interval);; \
    } else { \
        eglSwapInterval(args->dpy, args->interval);; \
    } \
} while(0)
EGLBoolean eglSwapInterval(eglSwapInterval_ARG_EXPAND);
typedef EGLBoolean (*eglSwapInterval_PTR)(eglSwapInterval_ARG_EXPAND);
#define eglTerminate_INDEX 69
#define eglTerminate_RETURN EGLBoolean
#define eglTerminate_ARG_NAMES dpy
#define eglTerminate_ARG_EXPAND EGLDisplay dpy
#define eglTerminate_PACKED PACKED_eglTerminate
#define eglTerminate_VOID_ONLY_WRAP(...) {}
#define eglTerminate_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_eglTerminate(_dpy) ({ \
    eglTerminate_PACKED *packed_data = malloc(sizeof(eglTerminate_PACKED)); \
    packed_data->index = eglTerminate_INDEX; \
    packed_data->args.dpy = (EGLDisplay)_dpy; \
    (packed_call_t *)packed_data; \
})
#define call_eglTerminate(packed, ret_v) do { \
    PACKED_eglTerminate *unpacked = (PACKED_eglTerminate *)packed; \
    ARGS_eglTerminate *args = (ARGS_eglTerminate *)&unpacked->args; \
    EGLBoolean *ret = (EGLBoolean *)ret_v; \
    if (ret != NULL) { \
        *ret = eglTerminate(args->dpy);; \
    } else { \
        eglTerminate(args->dpy);; \
    } \
} while(0)
EGLBoolean eglTerminate(eglTerminate_ARG_EXPAND);
typedef EGLBoolean (*eglTerminate_PTR)(eglTerminate_ARG_EXPAND);
#define eglUnlockSurfaceKHR_INDEX 70
#define eglUnlockSurfaceKHR_RETURN EGLBoolean
#define eglUnlockSurfaceKHR_ARG_NAMES display, surface
#define eglUnlockSurfaceKHR_ARG_EXPAND EGLDisplay display, EGLSurface surface
#define eglUnlockSurfaceKHR_PACKED PACKED_eglUnlockSurfaceKHR
#define eglUnlockSurfaceKHR_VOID_ONLY_WRAP(...) {}
#define eglUnlockSurfaceKHR_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_eglUnlockSurfaceKHR(_display, _surface) ({ \
    eglUnlockSurfaceKHR_PACKED *packed_data = malloc(sizeof(eglUnlockSurfaceKHR_PACKED)); \
    packed_data->index = eglUnlockSurfaceKHR_INDEX; \
    packed_data->args.display = (EGLDisplay)_display; \
    packed_data->args.surface = (EGLSurface)_surface; \
    (packed_call_t *)packed_data; \
})
#define call_eglUnlockSurfaceKHR(packed, ret_v) do { \
    PACKED_eglUnlockSurfaceKHR *unpacked = (PACKED_eglUnlockSurfaceKHR *)packed; \
    ARGS_eglUnlockSurfaceKHR *args = (ARGS_eglUnlockSurfaceKHR *)&unpacked->args; \
    EGLBoolean *ret = (EGLBoolean *)ret_v; \
    if (ret != NULL) { \
        *ret = eglUnlockSurfaceKHR(args->display, args->surface);; \
    } else { \
        eglUnlockSurfaceKHR(args->display, args->surface);; \
    } \
} while(0)
EGLBoolean eglUnlockSurfaceKHR(eglUnlockSurfaceKHR_ARG_EXPAND);
typedef EGLBoolean (*eglUnlockSurfaceKHR_PTR)(eglUnlockSurfaceKHR_ARG_EXPAND);
#define eglWaitClient_INDEX 71
#define eglWaitClient_RETURN EGLBoolean
#define eglWaitClient_ARG_NAMES 
#define eglWaitClient_ARG_EXPAND 
#define eglWaitClient_PACKED PACKED_eglWaitClient
#define eglWaitClient_VOID_ONLY_WRAP(...) {}
#define eglWaitClient_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_eglWaitClient() ({ \
    eglWaitClient_PACKED *packed_data = malloc(sizeof(eglWaitClient_PACKED)); \
    packed_data->index = eglWaitClient_INDEX; \
    (packed_call_t *)packed_data; \
})
#define call_eglWaitClient(packed, ret_v) do { \
    EGLBoolean *ret = (EGLBoolean *)ret_v; \
    if (ret != NULL) { \
        *ret = eglWaitClient();; \
    } else { \
        eglWaitClient();; \
    } \
} while(0)
EGLBoolean eglWaitClient(eglWaitClient_ARG_EXPAND);
typedef EGLBoolean (*eglWaitClient_PTR)(eglWaitClient_ARG_EXPAND);
#define eglWaitGL_INDEX 72
#define eglWaitGL_RETURN EGLBoolean
#define eglWaitGL_ARG_NAMES 
#define eglWaitGL_ARG_EXPAND 
#define eglWaitGL_PACKED PACKED_eglWaitGL
#define eglWaitGL_VOID_ONLY_WRAP(...) {}
#define eglWaitGL_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_eglWaitGL() ({ \
    eglWaitGL_PACKED *packed_data = malloc(sizeof(eglWaitGL_PACKED)); \
    packed_data->index = eglWaitGL_INDEX; \
    (packed_call_t *)packed_data; \
})
#define call_eglWaitGL(packed, ret_v) do { \
    EGLBoolean *ret = (EGLBoolean *)ret_v; \
    if (ret != NULL) { \
        *ret = eglWaitGL();; \
    } else { \
        eglWaitGL();; \
    } \
} while(0)
EGLBoolean eglWaitGL(eglWaitGL_ARG_EXPAND);
typedef EGLBoolean (*eglWaitGL_PTR)(eglWaitGL_ARG_EXPAND);
#define eglWaitNative_INDEX 73
#define eglWaitNative_RETURN EGLBoolean
#define eglWaitNative_ARG_NAMES engine
#define eglWaitNative_ARG_EXPAND EGLint engine
#define eglWaitNative_PACKED PACKED_eglWaitNative
#define eglWaitNative_VOID_ONLY_WRAP(...) {}
#define eglWaitNative_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_eglWaitNative(_engine) ({ \
    eglWaitNative_PACKED *packed_data = malloc(sizeof(eglWaitNative_PACKED)); \
    packed_data->index = eglWaitNative_INDEX; \
    packed_data->args.engine = (EGLint)_engine; \
    (packed_call_t *)packed_data; \
})
#define call_eglWaitNative(packed, ret_v) do { \
    PACKED_eglWaitNative *unpacked = (PACKED_eglWaitNative *)packed; \
    ARGS_eglWaitNative *args = (ARGS_eglWaitNative *)&unpacked->args; \
    EGLBoolean *ret = (EGLBoolean *)ret_v; \
    if (ret != NULL) { \
        *ret = eglWaitNative(args->engine);; \
    } else { \
        eglWaitNative(args->engine);; \
    } \
} while(0)
EGLBoolean eglWaitNative(eglWaitNative_ARG_EXPAND);
typedef EGLBoolean (*eglWaitNative_PTR)(eglWaitNative_ARG_EXPAND);
#define eglWaitSyncKHR_INDEX 74
#define eglWaitSyncKHR_RETURN EGLint
#define eglWaitSyncKHR_ARG_NAMES dpy, sync, flags
#define eglWaitSyncKHR_ARG_EXPAND EGLDisplay dpy, EGLSyncKHR sync, EGLint flags
#define eglWaitSyncKHR_PACKED PACKED_eglWaitSyncKHR
#define eglWaitSyncKHR_VOID_ONLY_WRAP(...) {}
#define eglWaitSyncKHR_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_eglWaitSyncKHR(_dpy, _sync, _flags) ({ \
    eglWaitSyncKHR_PACKED *packed_data = malloc(sizeof(eglWaitSyncKHR_PACKED)); \
    packed_data->index = eglWaitSyncKHR_INDEX; \
    packed_data->args.dpy = (EGLDisplay)_dpy; \
    packed_data->args.sync = (EGLSyncKHR)_sync; \
    packed_data->args.flags = (EGLint)_flags; \
    (packed_call_t *)packed_data; \
})
#define call_eglWaitSyncKHR(packed, ret_v) do { \
    PACKED_eglWaitSyncKHR *unpacked = (PACKED_eglWaitSyncKHR *)packed; \
    ARGS_eglWaitSyncKHR *args = (ARGS_eglWaitSyncKHR *)&unpacked->args; \
    EGLint *ret = (EGLint *)ret_v; \
    if (ret != NULL) { \
        *ret = eglWaitSyncKHR(args->dpy, args->sync, args->flags);; \
    } else { \
        eglWaitSyncKHR(args->dpy, args->sync, args->flags);; \
    } \
} while(0)
EGLint eglWaitSyncKHR(eglWaitSyncKHR_ARG_EXPAND);
typedef EGLint (*eglWaitSyncKHR_PTR)(eglWaitSyncKHR_ARG_EXPAND);
#define glAccum_INDEX 75
#define glAccum_RETURN void
#define glAccum_ARG_NAMES op, value
#define glAccum_ARG_EXPAND GLenum op, GLfloat value
#define glAccum_PACKED PACKED_glAccum
#define glAccum_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glAccum_NOT_VOID_WRAP(...) {}
#define pack_glAccum(_op, _value) ({ \
    glAccum_PACKED *packed_data = malloc(sizeof(glAccum_PACKED)); \
    packed_data->index = glAccum_INDEX; \
    packed_data->args.op = (GLenum)_op; \
    packed_data->args.value = (GLfloat)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glAccum(packed, ret_v) do { \
    PACKED_glAccum *unpacked = (PACKED_glAccum *)packed; \
    ARGS_glAccum *args = (ARGS_glAccum *)&unpacked->args; \
    glAccum(args->op, args->value);; \
} while(0)
void glAccum(glAccum_ARG_EXPAND);
typedef void (*glAccum_PTR)(glAccum_ARG_EXPAND);
#define glAccumxOES_INDEX 76
#define glAccumxOES_RETURN void
#define glAccumxOES_ARG_NAMES op, value
#define glAccumxOES_ARG_EXPAND GLenum op, GLfixed value
#define glAccumxOES_PACKED PACKED_glAccumxOES
#define glAccumxOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glAccumxOES_NOT_VOID_WRAP(...) {}
#define pack_glAccumxOES(_op, _value) ({ \
    glAccumxOES_PACKED *packed_data = malloc(sizeof(glAccumxOES_PACKED)); \
    packed_data->index = glAccumxOES_INDEX; \
    packed_data->args.op = (GLenum)_op; \
    packed_data->args.value = (GLfixed)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glAccumxOES(packed, ret_v) do { \
    PACKED_glAccumxOES *unpacked = (PACKED_glAccumxOES *)packed; \
    ARGS_glAccumxOES *args = (ARGS_glAccumxOES *)&unpacked->args; \
    glAccumxOES(args->op, args->value);; \
} while(0)
void glAccumxOES(glAccumxOES_ARG_EXPAND);
typedef void (*glAccumxOES_PTR)(glAccumxOES_ARG_EXPAND);
#define glActiveProgramEXT_INDEX 77
#define glActiveProgramEXT_RETURN void
#define glActiveProgramEXT_ARG_NAMES program
#define glActiveProgramEXT_ARG_EXPAND GLuint program
#define glActiveProgramEXT_PACKED PACKED_glActiveProgramEXT
#define glActiveProgramEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glActiveProgramEXT_NOT_VOID_WRAP(...) {}
#define pack_glActiveProgramEXT(_program) ({ \
    glActiveProgramEXT_PACKED *packed_data = malloc(sizeof(glActiveProgramEXT_PACKED)); \
    packed_data->index = glActiveProgramEXT_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    (packed_call_t *)packed_data; \
})
#define call_glActiveProgramEXT(packed, ret_v) do { \
    PACKED_glActiveProgramEXT *unpacked = (PACKED_glActiveProgramEXT *)packed; \
    ARGS_glActiveProgramEXT *args = (ARGS_glActiveProgramEXT *)&unpacked->args; \
    glActiveProgramEXT(args->program);; \
} while(0)
void glActiveProgramEXT(glActiveProgramEXT_ARG_EXPAND);
typedef void (*glActiveProgramEXT_PTR)(glActiveProgramEXT_ARG_EXPAND);
#define glActiveShaderProgram_INDEX 78
#define glActiveShaderProgram_RETURN void
#define glActiveShaderProgram_ARG_NAMES pipeline, program
#define glActiveShaderProgram_ARG_EXPAND GLuint pipeline, GLuint program
#define glActiveShaderProgram_PACKED PACKED_glActiveShaderProgram
#define glActiveShaderProgram_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glActiveShaderProgram_NOT_VOID_WRAP(...) {}
#define pack_glActiveShaderProgram(_pipeline, _program) ({ \
    glActiveShaderProgram_PACKED *packed_data = malloc(sizeof(glActiveShaderProgram_PACKED)); \
    packed_data->index = glActiveShaderProgram_INDEX; \
    packed_data->args.pipeline = (GLuint)_pipeline; \
    packed_data->args.program = (GLuint)_program; \
    (packed_call_t *)packed_data; \
})
#define call_glActiveShaderProgram(packed, ret_v) do { \
    PACKED_glActiveShaderProgram *unpacked = (PACKED_glActiveShaderProgram *)packed; \
    ARGS_glActiveShaderProgram *args = (ARGS_glActiveShaderProgram *)&unpacked->args; \
    glActiveShaderProgram(args->pipeline, args->program);; \
} while(0)
void glActiveShaderProgram(glActiveShaderProgram_ARG_EXPAND);
typedef void (*glActiveShaderProgram_PTR)(glActiveShaderProgram_ARG_EXPAND);
#define glActiveStencilFaceEXT_INDEX 79
#define glActiveStencilFaceEXT_RETURN void
#define glActiveStencilFaceEXT_ARG_NAMES face
#define glActiveStencilFaceEXT_ARG_EXPAND GLenum face
#define glActiveStencilFaceEXT_PACKED PACKED_glActiveStencilFaceEXT
#define glActiveStencilFaceEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glActiveStencilFaceEXT_NOT_VOID_WRAP(...) {}
#define pack_glActiveStencilFaceEXT(_face) ({ \
    glActiveStencilFaceEXT_PACKED *packed_data = malloc(sizeof(glActiveStencilFaceEXT_PACKED)); \
    packed_data->index = glActiveStencilFaceEXT_INDEX; \
    packed_data->args.face = (GLenum)_face; \
    (packed_call_t *)packed_data; \
})
#define call_glActiveStencilFaceEXT(packed, ret_v) do { \
    PACKED_glActiveStencilFaceEXT *unpacked = (PACKED_glActiveStencilFaceEXT *)packed; \
    ARGS_glActiveStencilFaceEXT *args = (ARGS_glActiveStencilFaceEXT *)&unpacked->args; \
    glActiveStencilFaceEXT(args->face);; \
} while(0)
void glActiveStencilFaceEXT(glActiveStencilFaceEXT_ARG_EXPAND);
typedef void (*glActiveStencilFaceEXT_PTR)(glActiveStencilFaceEXT_ARG_EXPAND);
#define glActiveTexture_INDEX 80
#define glActiveTexture_RETURN void
#define glActiveTexture_ARG_NAMES texture
#define glActiveTexture_ARG_EXPAND GLenum texture
#define glActiveTexture_PACKED PACKED_glActiveTexture
#define glActiveTexture_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glActiveTexture_NOT_VOID_WRAP(...) {}
#define pack_glActiveTexture(_texture) ({ \
    glActiveTexture_PACKED *packed_data = malloc(sizeof(glActiveTexture_PACKED)); \
    packed_data->index = glActiveTexture_INDEX; \
    packed_data->args.texture = (GLenum)_texture; \
    (packed_call_t *)packed_data; \
})
#define call_glActiveTexture(packed, ret_v) do { \
    PACKED_glActiveTexture *unpacked = (PACKED_glActiveTexture *)packed; \
    ARGS_glActiveTexture *args = (ARGS_glActiveTexture *)&unpacked->args; \
    glActiveTexture(args->texture);; \
} while(0)
void glActiveTexture(glActiveTexture_ARG_EXPAND);
typedef void (*glActiveTexture_PTR)(glActiveTexture_ARG_EXPAND);
#define glActiveTextureARB_INDEX 81
#define glActiveTextureARB_RETURN void
#define glActiveTextureARB_ARG_NAMES texture
#define glActiveTextureARB_ARG_EXPAND GLenum texture
#define glActiveTextureARB_PACKED PACKED_glActiveTextureARB
#define glActiveTextureARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glActiveTextureARB_NOT_VOID_WRAP(...) {}
#define pack_glActiveTextureARB(_texture) ({ \
    glActiveTextureARB_PACKED *packed_data = malloc(sizeof(glActiveTextureARB_PACKED)); \
    packed_data->index = glActiveTextureARB_INDEX; \
    packed_data->args.texture = (GLenum)_texture; \
    (packed_call_t *)packed_data; \
})
#define call_glActiveTextureARB(packed, ret_v) do { \
    PACKED_glActiveTextureARB *unpacked = (PACKED_glActiveTextureARB *)packed; \
    ARGS_glActiveTextureARB *args = (ARGS_glActiveTextureARB *)&unpacked->args; \
    glActiveTextureARB(args->texture);; \
} while(0)
void glActiveTextureARB(glActiveTextureARB_ARG_EXPAND);
typedef void (*glActiveTextureARB_PTR)(glActiveTextureARB_ARG_EXPAND);
#define glActiveVaryingNV_INDEX 82
#define glActiveVaryingNV_RETURN void
#define glActiveVaryingNV_ARG_NAMES program, name
#define glActiveVaryingNV_ARG_EXPAND GLuint program, const GLchar * name
#define glActiveVaryingNV_PACKED PACKED_glActiveVaryingNV
#define glActiveVaryingNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glActiveVaryingNV_NOT_VOID_WRAP(...) {}
#define pack_glActiveVaryingNV(_program, _name) ({ \
    glActiveVaryingNV_PACKED *packed_data = malloc(sizeof(glActiveVaryingNV_PACKED)); \
    packed_data->index = glActiveVaryingNV_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.name = (GLchar *)_name; \
    (packed_call_t *)packed_data; \
})
#define call_glActiveVaryingNV(packed, ret_v) do { \
    PACKED_glActiveVaryingNV *unpacked = (PACKED_glActiveVaryingNV *)packed; \
    ARGS_glActiveVaryingNV *args = (ARGS_glActiveVaryingNV *)&unpacked->args; \
    glActiveVaryingNV(args->program, args->name);; \
} while(0)
void glActiveVaryingNV(glActiveVaryingNV_ARG_EXPAND);
typedef void (*glActiveVaryingNV_PTR)(glActiveVaryingNV_ARG_EXPAND);
#define glAlphaFragmentOp1ATI_INDEX 83
#define glAlphaFragmentOp1ATI_RETURN void
#define glAlphaFragmentOp1ATI_ARG_NAMES op, dst, dstMod, arg1, arg1Rep, arg1Mod
#define glAlphaFragmentOp1ATI_ARG_EXPAND GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod
#define glAlphaFragmentOp1ATI_PACKED PACKED_glAlphaFragmentOp1ATI
#define glAlphaFragmentOp1ATI_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glAlphaFragmentOp1ATI_NOT_VOID_WRAP(...) {}
#define pack_glAlphaFragmentOp1ATI(_op, _dst, _dstMod, _arg1, _arg1Rep, _arg1Mod) ({ \
    glAlphaFragmentOp1ATI_PACKED *packed_data = malloc(sizeof(glAlphaFragmentOp1ATI_PACKED)); \
    packed_data->index = glAlphaFragmentOp1ATI_INDEX; \
    packed_data->args.op = (GLenum)_op; \
    packed_data->args.dst = (GLuint)_dst; \
    packed_data->args.dstMod = (GLuint)_dstMod; \
    packed_data->args.arg1 = (GLuint)_arg1; \
    packed_data->args.arg1Rep = (GLuint)_arg1Rep; \
    packed_data->args.arg1Mod = (GLuint)_arg1Mod; \
    (packed_call_t *)packed_data; \
})
#define call_glAlphaFragmentOp1ATI(packed, ret_v) do { \
    PACKED_glAlphaFragmentOp1ATI *unpacked = (PACKED_glAlphaFragmentOp1ATI *)packed; \
    ARGS_glAlphaFragmentOp1ATI *args = (ARGS_glAlphaFragmentOp1ATI *)&unpacked->args; \
    glAlphaFragmentOp1ATI(args->op, args->dst, args->dstMod, args->arg1, args->arg1Rep, args->arg1Mod);; \
} while(0)
void glAlphaFragmentOp1ATI(glAlphaFragmentOp1ATI_ARG_EXPAND);
typedef void (*glAlphaFragmentOp1ATI_PTR)(glAlphaFragmentOp1ATI_ARG_EXPAND);
#define glAlphaFragmentOp2ATI_INDEX 84
#define glAlphaFragmentOp2ATI_RETURN void
#define glAlphaFragmentOp2ATI_ARG_NAMES op, dst, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod
#define glAlphaFragmentOp2ATI_ARG_EXPAND GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod
#define glAlphaFragmentOp2ATI_PACKED PACKED_glAlphaFragmentOp2ATI
#define glAlphaFragmentOp2ATI_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glAlphaFragmentOp2ATI_NOT_VOID_WRAP(...) {}
#define pack_glAlphaFragmentOp2ATI(_op, _dst, _dstMod, _arg1, _arg1Rep, _arg1Mod, _arg2, _arg2Rep, _arg2Mod) ({ \
    glAlphaFragmentOp2ATI_PACKED *packed_data = malloc(sizeof(glAlphaFragmentOp2ATI_PACKED)); \
    packed_data->index = glAlphaFragmentOp2ATI_INDEX; \
    packed_data->args.op = (GLenum)_op; \
    packed_data->args.dst = (GLuint)_dst; \
    packed_data->args.dstMod = (GLuint)_dstMod; \
    packed_data->args.arg1 = (GLuint)_arg1; \
    packed_data->args.arg1Rep = (GLuint)_arg1Rep; \
    packed_data->args.arg1Mod = (GLuint)_arg1Mod; \
    packed_data->args.arg2 = (GLuint)_arg2; \
    packed_data->args.arg2Rep = (GLuint)_arg2Rep; \
    packed_data->args.arg2Mod = (GLuint)_arg2Mod; \
    (packed_call_t *)packed_data; \
})
#define call_glAlphaFragmentOp2ATI(packed, ret_v) do { \
    PACKED_glAlphaFragmentOp2ATI *unpacked = (PACKED_glAlphaFragmentOp2ATI *)packed; \
    ARGS_glAlphaFragmentOp2ATI *args = (ARGS_glAlphaFragmentOp2ATI *)&unpacked->args; \
    glAlphaFragmentOp2ATI(args->op, args->dst, args->dstMod, args->arg1, args->arg1Rep, args->arg1Mod, args->arg2, args->arg2Rep, args->arg2Mod);; \
} while(0)
void glAlphaFragmentOp2ATI(glAlphaFragmentOp2ATI_ARG_EXPAND);
typedef void (*glAlphaFragmentOp2ATI_PTR)(glAlphaFragmentOp2ATI_ARG_EXPAND);
#define glAlphaFragmentOp3ATI_INDEX 85
#define glAlphaFragmentOp3ATI_RETURN void
#define glAlphaFragmentOp3ATI_ARG_NAMES op, dst, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod, arg3, arg3Rep, arg3Mod
#define glAlphaFragmentOp3ATI_ARG_EXPAND GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod, GLuint arg3, GLuint arg3Rep, GLuint arg3Mod
#define glAlphaFragmentOp3ATI_PACKED PACKED_glAlphaFragmentOp3ATI
#define glAlphaFragmentOp3ATI_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glAlphaFragmentOp3ATI_NOT_VOID_WRAP(...) {}
#define pack_glAlphaFragmentOp3ATI(_op, _dst, _dstMod, _arg1, _arg1Rep, _arg1Mod, _arg2, _arg2Rep, _arg2Mod, _arg3, _arg3Rep, _arg3Mod) ({ \
    glAlphaFragmentOp3ATI_PACKED *packed_data = malloc(sizeof(glAlphaFragmentOp3ATI_PACKED)); \
    packed_data->index = glAlphaFragmentOp3ATI_INDEX; \
    packed_data->args.op = (GLenum)_op; \
    packed_data->args.dst = (GLuint)_dst; \
    packed_data->args.dstMod = (GLuint)_dstMod; \
    packed_data->args.arg1 = (GLuint)_arg1; \
    packed_data->args.arg1Rep = (GLuint)_arg1Rep; \
    packed_data->args.arg1Mod = (GLuint)_arg1Mod; \
    packed_data->args.arg2 = (GLuint)_arg2; \
    packed_data->args.arg2Rep = (GLuint)_arg2Rep; \
    packed_data->args.arg2Mod = (GLuint)_arg2Mod; \
    packed_data->args.arg3 = (GLuint)_arg3; \
    packed_data->args.arg3Rep = (GLuint)_arg3Rep; \
    packed_data->args.arg3Mod = (GLuint)_arg3Mod; \
    (packed_call_t *)packed_data; \
})
#define call_glAlphaFragmentOp3ATI(packed, ret_v) do { \
    PACKED_glAlphaFragmentOp3ATI *unpacked = (PACKED_glAlphaFragmentOp3ATI *)packed; \
    ARGS_glAlphaFragmentOp3ATI *args = (ARGS_glAlphaFragmentOp3ATI *)&unpacked->args; \
    glAlphaFragmentOp3ATI(args->op, args->dst, args->dstMod, args->arg1, args->arg1Rep, args->arg1Mod, args->arg2, args->arg2Rep, args->arg2Mod, args->arg3, args->arg3Rep, args->arg3Mod);; \
} while(0)
void glAlphaFragmentOp3ATI(glAlphaFragmentOp3ATI_ARG_EXPAND);
typedef void (*glAlphaFragmentOp3ATI_PTR)(glAlphaFragmentOp3ATI_ARG_EXPAND);
#define glAlphaFunc_INDEX 86
#define glAlphaFunc_RETURN void
#define glAlphaFunc_ARG_NAMES func, ref
#define glAlphaFunc_ARG_EXPAND GLenum func, GLclampf ref
#define glAlphaFunc_PACKED PACKED_glAlphaFunc
#define glAlphaFunc_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glAlphaFunc_NOT_VOID_WRAP(...) {}
#define pack_glAlphaFunc(_func, _ref) ({ \
    glAlphaFunc_PACKED *packed_data = malloc(sizeof(glAlphaFunc_PACKED)); \
    packed_data->index = glAlphaFunc_INDEX; \
    packed_data->args.func = (GLenum)_func; \
    packed_data->args.ref = (GLclampf)_ref; \
    (packed_call_t *)packed_data; \
})
#define call_glAlphaFunc(packed, ret_v) do { \
    PACKED_glAlphaFunc *unpacked = (PACKED_glAlphaFunc *)packed; \
    ARGS_glAlphaFunc *args = (ARGS_glAlphaFunc *)&unpacked->args; \
    glAlphaFunc(args->func, args->ref);; \
} while(0)
void glAlphaFunc(glAlphaFunc_ARG_EXPAND);
typedef void (*glAlphaFunc_PTR)(glAlphaFunc_ARG_EXPAND);
#define glAlphaFuncx_INDEX 87
#define glAlphaFuncx_RETURN void
#define glAlphaFuncx_ARG_NAMES func, ref
#define glAlphaFuncx_ARG_EXPAND GLenum func, GLclampx ref
#define glAlphaFuncx_PACKED PACKED_glAlphaFuncx
#define glAlphaFuncx_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glAlphaFuncx_NOT_VOID_WRAP(...) {}
#define pack_glAlphaFuncx(_func, _ref) ({ \
    glAlphaFuncx_PACKED *packed_data = malloc(sizeof(glAlphaFuncx_PACKED)); \
    packed_data->index = glAlphaFuncx_INDEX; \
    packed_data->args.func = (GLenum)_func; \
    packed_data->args.ref = (GLclampx)_ref; \
    (packed_call_t *)packed_data; \
})
#define call_glAlphaFuncx(packed, ret_v) do { \
    PACKED_glAlphaFuncx *unpacked = (PACKED_glAlphaFuncx *)packed; \
    ARGS_glAlphaFuncx *args = (ARGS_glAlphaFuncx *)&unpacked->args; \
    glAlphaFuncx(args->func, args->ref);; \
} while(0)
void glAlphaFuncx(glAlphaFuncx_ARG_EXPAND);
typedef void (*glAlphaFuncx_PTR)(glAlphaFuncx_ARG_EXPAND);
#define glAlphaFuncxOES_INDEX 88
#define glAlphaFuncxOES_RETURN void
#define glAlphaFuncxOES_ARG_NAMES func, ref
#define glAlphaFuncxOES_ARG_EXPAND GLenum func, GLfixed ref
#define glAlphaFuncxOES_PACKED PACKED_glAlphaFuncxOES
#define glAlphaFuncxOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glAlphaFuncxOES_NOT_VOID_WRAP(...) {}
#define pack_glAlphaFuncxOES(_func, _ref) ({ \
    glAlphaFuncxOES_PACKED *packed_data = malloc(sizeof(glAlphaFuncxOES_PACKED)); \
    packed_data->index = glAlphaFuncxOES_INDEX; \
    packed_data->args.func = (GLenum)_func; \
    packed_data->args.ref = (GLfixed)_ref; \
    (packed_call_t *)packed_data; \
})
#define call_glAlphaFuncxOES(packed, ret_v) do { \
    PACKED_glAlphaFuncxOES *unpacked = (PACKED_glAlphaFuncxOES *)packed; \
    ARGS_glAlphaFuncxOES *args = (ARGS_glAlphaFuncxOES *)&unpacked->args; \
    glAlphaFuncxOES(args->func, args->ref);; \
} while(0)
void glAlphaFuncxOES(glAlphaFuncxOES_ARG_EXPAND);
typedef void (*glAlphaFuncxOES_PTR)(glAlphaFuncxOES_ARG_EXPAND);
#define glApplyTextureEXT_INDEX 89
#define glApplyTextureEXT_RETURN void
#define glApplyTextureEXT_ARG_NAMES mode
#define glApplyTextureEXT_ARG_EXPAND GLenum mode
#define glApplyTextureEXT_PACKED PACKED_glApplyTextureEXT
#define glApplyTextureEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glApplyTextureEXT_NOT_VOID_WRAP(...) {}
#define pack_glApplyTextureEXT(_mode) ({ \
    glApplyTextureEXT_PACKED *packed_data = malloc(sizeof(glApplyTextureEXT_PACKED)); \
    packed_data->index = glApplyTextureEXT_INDEX; \
    packed_data->args.mode = (GLenum)_mode; \
    (packed_call_t *)packed_data; \
})
#define call_glApplyTextureEXT(packed, ret_v) do { \
    PACKED_glApplyTextureEXT *unpacked = (PACKED_glApplyTextureEXT *)packed; \
    ARGS_glApplyTextureEXT *args = (ARGS_glApplyTextureEXT *)&unpacked->args; \
    glApplyTextureEXT(args->mode);; \
} while(0)
void glApplyTextureEXT(glApplyTextureEXT_ARG_EXPAND);
typedef void (*glApplyTextureEXT_PTR)(glApplyTextureEXT_ARG_EXPAND);
#define glAreProgramsResidentNV_INDEX 90
#define glAreProgramsResidentNV_RETURN GLboolean
#define glAreProgramsResidentNV_ARG_NAMES n, programs, residences
#define glAreProgramsResidentNV_ARG_EXPAND GLsizei n, const GLuint * programs, GLboolean * residences
#define glAreProgramsResidentNV_PACKED PACKED_glAreProgramsResidentNV
#define glAreProgramsResidentNV_VOID_ONLY_WRAP(...) {}
#define glAreProgramsResidentNV_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glAreProgramsResidentNV(_n, _programs, _residences) ({ \
    glAreProgramsResidentNV_PACKED *packed_data = malloc(sizeof(glAreProgramsResidentNV_PACKED)); \
    packed_data->index = glAreProgramsResidentNV_INDEX; \
    packed_data->args.n = (GLsizei)_n; \
    packed_data->args.programs = (GLuint *)_programs; \
    packed_data->args.residences = (GLboolean *)_residences; \
    (packed_call_t *)packed_data; \
})
#define call_glAreProgramsResidentNV(packed, ret_v) do { \
    PACKED_glAreProgramsResidentNV *unpacked = (PACKED_glAreProgramsResidentNV *)packed; \
    ARGS_glAreProgramsResidentNV *args = (ARGS_glAreProgramsResidentNV *)&unpacked->args; \
    GLboolean *ret = (GLboolean *)ret_v; \
    if (ret != NULL) { \
        *ret = glAreProgramsResidentNV(args->n, args->programs, args->residences);; \
    } else { \
        glAreProgramsResidentNV(args->n, args->programs, args->residences);; \
    } \
} while(0)
GLboolean glAreProgramsResidentNV(glAreProgramsResidentNV_ARG_EXPAND);
typedef GLboolean (*glAreProgramsResidentNV_PTR)(glAreProgramsResidentNV_ARG_EXPAND);
#define glAreTexturesResident_INDEX 91
#define glAreTexturesResident_RETURN GLboolean
#define glAreTexturesResident_ARG_NAMES n, textures, residences
#define glAreTexturesResident_ARG_EXPAND GLsizei n, const GLuint * textures, GLboolean * residences
#define glAreTexturesResident_PACKED PACKED_glAreTexturesResident
#define glAreTexturesResident_VOID_ONLY_WRAP(...) {}
#define glAreTexturesResident_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glAreTexturesResident(_n, _textures, _residences) ({ \
    glAreTexturesResident_PACKED *packed_data = malloc(sizeof(glAreTexturesResident_PACKED)); \
    packed_data->index = glAreTexturesResident_INDEX; \
    packed_data->args.n = (GLsizei)_n; \
    packed_data->args.textures = (GLuint *)_textures; \
    packed_data->args.residences = (GLboolean *)_residences; \
    (packed_call_t *)packed_data; \
})
#define call_glAreTexturesResident(packed, ret_v) do { \
    PACKED_glAreTexturesResident *unpacked = (PACKED_glAreTexturesResident *)packed; \
    ARGS_glAreTexturesResident *args = (ARGS_glAreTexturesResident *)&unpacked->args; \
    GLboolean *ret = (GLboolean *)ret_v; \
    if (ret != NULL) { \
        *ret = glAreTexturesResident(args->n, args->textures, args->residences);; \
    } else { \
        glAreTexturesResident(args->n, args->textures, args->residences);; \
    } \
} while(0)
GLboolean glAreTexturesResident(glAreTexturesResident_ARG_EXPAND);
typedef GLboolean (*glAreTexturesResident_PTR)(glAreTexturesResident_ARG_EXPAND);
#define glAreTexturesResidentEXT_INDEX 92
#define glAreTexturesResidentEXT_RETURN GLboolean
#define glAreTexturesResidentEXT_ARG_NAMES n, textures, residences
#define glAreTexturesResidentEXT_ARG_EXPAND GLsizei n, const GLuint * textures, GLboolean * residences
#define glAreTexturesResidentEXT_PACKED PACKED_glAreTexturesResidentEXT
#define glAreTexturesResidentEXT_VOID_ONLY_WRAP(...) {}
#define glAreTexturesResidentEXT_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glAreTexturesResidentEXT(_n, _textures, _residences) ({ \
    glAreTexturesResidentEXT_PACKED *packed_data = malloc(sizeof(glAreTexturesResidentEXT_PACKED)); \
    packed_data->index = glAreTexturesResidentEXT_INDEX; \
    packed_data->args.n = (GLsizei)_n; \
    packed_data->args.textures = (GLuint *)_textures; \
    packed_data->args.residences = (GLboolean *)_residences; \
    (packed_call_t *)packed_data; \
})
#define call_glAreTexturesResidentEXT(packed, ret_v) do { \
    PACKED_glAreTexturesResidentEXT *unpacked = (PACKED_glAreTexturesResidentEXT *)packed; \
    ARGS_glAreTexturesResidentEXT *args = (ARGS_glAreTexturesResidentEXT *)&unpacked->args; \
    GLboolean *ret = (GLboolean *)ret_v; \
    if (ret != NULL) { \
        *ret = glAreTexturesResidentEXT(args->n, args->textures, args->residences);; \
    } else { \
        glAreTexturesResidentEXT(args->n, args->textures, args->residences);; \
    } \
} while(0)
GLboolean glAreTexturesResidentEXT(glAreTexturesResidentEXT_ARG_EXPAND);
typedef GLboolean (*glAreTexturesResidentEXT_PTR)(glAreTexturesResidentEXT_ARG_EXPAND);
#define glArrayElement_INDEX 93
#define glArrayElement_RETURN void
#define glArrayElement_ARG_NAMES i
#define glArrayElement_ARG_EXPAND GLint i
#define glArrayElement_PACKED PACKED_glArrayElement
#define glArrayElement_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glArrayElement_NOT_VOID_WRAP(...) {}
#define pack_glArrayElement(_i) ({ \
    glArrayElement_PACKED *packed_data = malloc(sizeof(glArrayElement_PACKED)); \
    packed_data->index = glArrayElement_INDEX; \
    packed_data->args.i = (GLint)_i; \
    (packed_call_t *)packed_data; \
})
#define call_glArrayElement(packed, ret_v) do { \
    PACKED_glArrayElement *unpacked = (PACKED_glArrayElement *)packed; \
    ARGS_glArrayElement *args = (ARGS_glArrayElement *)&unpacked->args; \
    glArrayElement(args->i);; \
} while(0)
void glArrayElement(glArrayElement_ARG_EXPAND);
typedef void (*glArrayElement_PTR)(glArrayElement_ARG_EXPAND);
#define glArrayElementEXT_INDEX 94
#define glArrayElementEXT_RETURN void
#define glArrayElementEXT_ARG_NAMES i
#define glArrayElementEXT_ARG_EXPAND GLint i
#define glArrayElementEXT_PACKED PACKED_glArrayElementEXT
#define glArrayElementEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glArrayElementEXT_NOT_VOID_WRAP(...) {}
#define pack_glArrayElementEXT(_i) ({ \
    glArrayElementEXT_PACKED *packed_data = malloc(sizeof(glArrayElementEXT_PACKED)); \
    packed_data->index = glArrayElementEXT_INDEX; \
    packed_data->args.i = (GLint)_i; \
    (packed_call_t *)packed_data; \
})
#define call_glArrayElementEXT(packed, ret_v) do { \
    PACKED_glArrayElementEXT *unpacked = (PACKED_glArrayElementEXT *)packed; \
    ARGS_glArrayElementEXT *args = (ARGS_glArrayElementEXT *)&unpacked->args; \
    glArrayElementEXT(args->i);; \
} while(0)
void glArrayElementEXT(glArrayElementEXT_ARG_EXPAND);
typedef void (*glArrayElementEXT_PTR)(glArrayElementEXT_ARG_EXPAND);
#define glArrayObjectATI_INDEX 95
#define glArrayObjectATI_RETURN void
#define glArrayObjectATI_ARG_NAMES array, size, type, stride, buffer, offset
#define glArrayObjectATI_ARG_EXPAND GLenum array, GLint size, GLenum type, GLsizei stride, GLuint buffer, GLuint offset
#define glArrayObjectATI_PACKED PACKED_glArrayObjectATI
#define glArrayObjectATI_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glArrayObjectATI_NOT_VOID_WRAP(...) {}
#define pack_glArrayObjectATI(_array, _size, _type, _stride, _buffer, _offset) ({ \
    glArrayObjectATI_PACKED *packed_data = malloc(sizeof(glArrayObjectATI_PACKED)); \
    packed_data->index = glArrayObjectATI_INDEX; \
    packed_data->args.array = (GLenum)_array; \
    packed_data->args.size = (GLint)_size; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.stride = (GLsizei)_stride; \
    packed_data->args.buffer = (GLuint)_buffer; \
    packed_data->args.offset = (GLuint)_offset; \
    (packed_call_t *)packed_data; \
})
#define call_glArrayObjectATI(packed, ret_v) do { \
    PACKED_glArrayObjectATI *unpacked = (PACKED_glArrayObjectATI *)packed; \
    ARGS_glArrayObjectATI *args = (ARGS_glArrayObjectATI *)&unpacked->args; \
    glArrayObjectATI(args->array, args->size, args->type, args->stride, args->buffer, args->offset);; \
} while(0)
void glArrayObjectATI(glArrayObjectATI_ARG_EXPAND);
typedef void (*glArrayObjectATI_PTR)(glArrayObjectATI_ARG_EXPAND);
#define glAsyncMarkerSGIX_INDEX 96
#define glAsyncMarkerSGIX_RETURN void
#define glAsyncMarkerSGIX_ARG_NAMES marker
#define glAsyncMarkerSGIX_ARG_EXPAND GLuint marker
#define glAsyncMarkerSGIX_PACKED PACKED_glAsyncMarkerSGIX
#define glAsyncMarkerSGIX_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glAsyncMarkerSGIX_NOT_VOID_WRAP(...) {}
#define pack_glAsyncMarkerSGIX(_marker) ({ \
    glAsyncMarkerSGIX_PACKED *packed_data = malloc(sizeof(glAsyncMarkerSGIX_PACKED)); \
    packed_data->index = glAsyncMarkerSGIX_INDEX; \
    packed_data->args.marker = (GLuint)_marker; \
    (packed_call_t *)packed_data; \
})
#define call_glAsyncMarkerSGIX(packed, ret_v) do { \
    PACKED_glAsyncMarkerSGIX *unpacked = (PACKED_glAsyncMarkerSGIX *)packed; \
    ARGS_glAsyncMarkerSGIX *args = (ARGS_glAsyncMarkerSGIX *)&unpacked->args; \
    glAsyncMarkerSGIX(args->marker);; \
} while(0)
void glAsyncMarkerSGIX(glAsyncMarkerSGIX_ARG_EXPAND);
typedef void (*glAsyncMarkerSGIX_PTR)(glAsyncMarkerSGIX_ARG_EXPAND);
#define glAttachObjectARB_INDEX 97
#define glAttachObjectARB_RETURN void
#define glAttachObjectARB_ARG_NAMES containerObj, obj
#define glAttachObjectARB_ARG_EXPAND GLhandleARB containerObj, GLhandleARB obj
#define glAttachObjectARB_PACKED PACKED_glAttachObjectARB
#define glAttachObjectARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glAttachObjectARB_NOT_VOID_WRAP(...) {}
#define pack_glAttachObjectARB(_containerObj, _obj) ({ \
    glAttachObjectARB_PACKED *packed_data = malloc(sizeof(glAttachObjectARB_PACKED)); \
    packed_data->index = glAttachObjectARB_INDEX; \
    packed_data->args.containerObj = (GLhandleARB)_containerObj; \
    packed_data->args.obj = (GLhandleARB)_obj; \
    (packed_call_t *)packed_data; \
})
#define call_glAttachObjectARB(packed, ret_v) do { \
    PACKED_glAttachObjectARB *unpacked = (PACKED_glAttachObjectARB *)packed; \
    ARGS_glAttachObjectARB *args = (ARGS_glAttachObjectARB *)&unpacked->args; \
    glAttachObjectARB(args->containerObj, args->obj);; \
} while(0)
void glAttachObjectARB(glAttachObjectARB_ARG_EXPAND);
typedef void (*glAttachObjectARB_PTR)(glAttachObjectARB_ARG_EXPAND);
#define glAttachShader_INDEX 98
#define glAttachShader_RETURN void
#define glAttachShader_ARG_NAMES program, shader
#define glAttachShader_ARG_EXPAND GLuint program, GLuint shader
#define glAttachShader_PACKED PACKED_glAttachShader
#define glAttachShader_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glAttachShader_NOT_VOID_WRAP(...) {}
#define pack_glAttachShader(_program, _shader) ({ \
    glAttachShader_PACKED *packed_data = malloc(sizeof(glAttachShader_PACKED)); \
    packed_data->index = glAttachShader_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.shader = (GLuint)_shader; \
    (packed_call_t *)packed_data; \
})
#define call_glAttachShader(packed, ret_v) do { \
    PACKED_glAttachShader *unpacked = (PACKED_glAttachShader *)packed; \
    ARGS_glAttachShader *args = (ARGS_glAttachShader *)&unpacked->args; \
    glAttachShader(args->program, args->shader);; \
} while(0)
void glAttachShader(glAttachShader_ARG_EXPAND);
typedef void (*glAttachShader_PTR)(glAttachShader_ARG_EXPAND);
#define glBegin_INDEX 99
#define glBegin_RETURN void
#define glBegin_ARG_NAMES mode
#define glBegin_ARG_EXPAND GLenum mode
#define glBegin_PACKED PACKED_glBegin
#define glBegin_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glBegin_NOT_VOID_WRAP(...) {}
#define pack_glBegin(_mode) ({ \
    glBegin_PACKED *packed_data = malloc(sizeof(glBegin_PACKED)); \
    packed_data->index = glBegin_INDEX; \
    packed_data->args.mode = (GLenum)_mode; \
    (packed_call_t *)packed_data; \
})
#define call_glBegin(packed, ret_v) do { \
    PACKED_glBegin *unpacked = (PACKED_glBegin *)packed; \
    ARGS_glBegin *args = (ARGS_glBegin *)&unpacked->args; \
    glBegin(args->mode);; \
} while(0)
void glBegin(glBegin_ARG_EXPAND);
typedef void (*glBegin_PTR)(glBegin_ARG_EXPAND);
#define glBeginConditionalRender_INDEX 100
#define glBeginConditionalRender_RETURN void
#define glBeginConditionalRender_ARG_NAMES id, mode
#define glBeginConditionalRender_ARG_EXPAND GLuint id, GLenum mode
#define glBeginConditionalRender_PACKED PACKED_glBeginConditionalRender
#define glBeginConditionalRender_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glBeginConditionalRender_NOT_VOID_WRAP(...) {}
#define pack_glBeginConditionalRender(_id, _mode) ({ \
    glBeginConditionalRender_PACKED *packed_data = malloc(sizeof(glBeginConditionalRender_PACKED)); \
    packed_data->index = glBeginConditionalRender_INDEX; \
    packed_data->args.id = (GLuint)_id; \
    packed_data->args.mode = (GLenum)_mode; \
    (packed_call_t *)packed_data; \
})
#define call_glBeginConditionalRender(packed, ret_v) do { \
    PACKED_glBeginConditionalRender *unpacked = (PACKED_glBeginConditionalRender *)packed; \
    ARGS_glBeginConditionalRender *args = (ARGS_glBeginConditionalRender *)&unpacked->args; \
    glBeginConditionalRender(args->id, args->mode);; \
} while(0)
void glBeginConditionalRender(glBeginConditionalRender_ARG_EXPAND);
typedef void (*glBeginConditionalRender_PTR)(glBeginConditionalRender_ARG_EXPAND);
#define glBeginConditionalRenderNV_INDEX 101
#define glBeginConditionalRenderNV_RETURN void
#define glBeginConditionalRenderNV_ARG_NAMES id, mode
#define glBeginConditionalRenderNV_ARG_EXPAND GLuint id, GLenum mode
#define glBeginConditionalRenderNV_PACKED PACKED_glBeginConditionalRenderNV
#define glBeginConditionalRenderNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glBeginConditionalRenderNV_NOT_VOID_WRAP(...) {}
#define pack_glBeginConditionalRenderNV(_id, _mode) ({ \
    glBeginConditionalRenderNV_PACKED *packed_data = malloc(sizeof(glBeginConditionalRenderNV_PACKED)); \
    packed_data->index = glBeginConditionalRenderNV_INDEX; \
    packed_data->args.id = (GLuint)_id; \
    packed_data->args.mode = (GLenum)_mode; \
    (packed_call_t *)packed_data; \
})
#define call_glBeginConditionalRenderNV(packed, ret_v) do { \
    PACKED_glBeginConditionalRenderNV *unpacked = (PACKED_glBeginConditionalRenderNV *)packed; \
    ARGS_glBeginConditionalRenderNV *args = (ARGS_glBeginConditionalRenderNV *)&unpacked->args; \
    glBeginConditionalRenderNV(args->id, args->mode);; \
} while(0)
void glBeginConditionalRenderNV(glBeginConditionalRenderNV_ARG_EXPAND);
typedef void (*glBeginConditionalRenderNV_PTR)(glBeginConditionalRenderNV_ARG_EXPAND);
#define glBeginConditionalRenderNVX_INDEX 102
#define glBeginConditionalRenderNVX_RETURN void
#define glBeginConditionalRenderNVX_ARG_NAMES id
#define glBeginConditionalRenderNVX_ARG_EXPAND GLuint id
#define glBeginConditionalRenderNVX_PACKED PACKED_glBeginConditionalRenderNVX
#define glBeginConditionalRenderNVX_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glBeginConditionalRenderNVX_NOT_VOID_WRAP(...) {}
#define pack_glBeginConditionalRenderNVX(_id) ({ \
    glBeginConditionalRenderNVX_PACKED *packed_data = malloc(sizeof(glBeginConditionalRenderNVX_PACKED)); \
    packed_data->index = glBeginConditionalRenderNVX_INDEX; \
    packed_data->args.id = (GLuint)_id; \
    (packed_call_t *)packed_data; \
})
#define call_glBeginConditionalRenderNVX(packed, ret_v) do { \
    PACKED_glBeginConditionalRenderNVX *unpacked = (PACKED_glBeginConditionalRenderNVX *)packed; \
    ARGS_glBeginConditionalRenderNVX *args = (ARGS_glBeginConditionalRenderNVX *)&unpacked->args; \
    glBeginConditionalRenderNVX(args->id);; \
} while(0)
void glBeginConditionalRenderNVX(glBeginConditionalRenderNVX_ARG_EXPAND);
typedef void (*glBeginConditionalRenderNVX_PTR)(glBeginConditionalRenderNVX_ARG_EXPAND);
#define glBeginFragmentShaderATI_INDEX 103
#define glBeginFragmentShaderATI_RETURN void
#define glBeginFragmentShaderATI_ARG_NAMES 
#define glBeginFragmentShaderATI_ARG_EXPAND 
#define glBeginFragmentShaderATI_PACKED PACKED_glBeginFragmentShaderATI
#define glBeginFragmentShaderATI_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glBeginFragmentShaderATI_NOT_VOID_WRAP(...) {}
#define pack_glBeginFragmentShaderATI() ({ \
    glBeginFragmentShaderATI_PACKED *packed_data = malloc(sizeof(glBeginFragmentShaderATI_PACKED)); \
    packed_data->index = glBeginFragmentShaderATI_INDEX; \
    (packed_call_t *)packed_data; \
})
#define call_glBeginFragmentShaderATI(packed, ret_v) do { \
    glBeginFragmentShaderATI();; \
} while(0)
void glBeginFragmentShaderATI(glBeginFragmentShaderATI_ARG_EXPAND);
typedef void (*glBeginFragmentShaderATI_PTR)(glBeginFragmentShaderATI_ARG_EXPAND);
#define glBeginOcclusionQueryNV_INDEX 104
#define glBeginOcclusionQueryNV_RETURN void
#define glBeginOcclusionQueryNV_ARG_NAMES id
#define glBeginOcclusionQueryNV_ARG_EXPAND GLuint id
#define glBeginOcclusionQueryNV_PACKED PACKED_glBeginOcclusionQueryNV
#define glBeginOcclusionQueryNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glBeginOcclusionQueryNV_NOT_VOID_WRAP(...) {}
#define pack_glBeginOcclusionQueryNV(_id) ({ \
    glBeginOcclusionQueryNV_PACKED *packed_data = malloc(sizeof(glBeginOcclusionQueryNV_PACKED)); \
    packed_data->index = glBeginOcclusionQueryNV_INDEX; \
    packed_data->args.id = (GLuint)_id; \
    (packed_call_t *)packed_data; \
})
#define call_glBeginOcclusionQueryNV(packed, ret_v) do { \
    PACKED_glBeginOcclusionQueryNV *unpacked = (PACKED_glBeginOcclusionQueryNV *)packed; \
    ARGS_glBeginOcclusionQueryNV *args = (ARGS_glBeginOcclusionQueryNV *)&unpacked->args; \
    glBeginOcclusionQueryNV(args->id);; \
} while(0)
void glBeginOcclusionQueryNV(glBeginOcclusionQueryNV_ARG_EXPAND);
typedef void (*glBeginOcclusionQueryNV_PTR)(glBeginOcclusionQueryNV_ARG_EXPAND);
#define glBeginPerfMonitorAMD_INDEX 105
#define glBeginPerfMonitorAMD_RETURN void
#define glBeginPerfMonitorAMD_ARG_NAMES monitor
#define glBeginPerfMonitorAMD_ARG_EXPAND GLuint monitor
#define glBeginPerfMonitorAMD_PACKED PACKED_glBeginPerfMonitorAMD
#define glBeginPerfMonitorAMD_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glBeginPerfMonitorAMD_NOT_VOID_WRAP(...) {}
#define pack_glBeginPerfMonitorAMD(_monitor) ({ \
    glBeginPerfMonitorAMD_PACKED *packed_data = malloc(sizeof(glBeginPerfMonitorAMD_PACKED)); \
    packed_data->index = glBeginPerfMonitorAMD_INDEX; \
    packed_data->args.monitor = (GLuint)_monitor; \
    (packed_call_t *)packed_data; \
})
#define call_glBeginPerfMonitorAMD(packed, ret_v) do { \
    PACKED_glBeginPerfMonitorAMD *unpacked = (PACKED_glBeginPerfMonitorAMD *)packed; \
    ARGS_glBeginPerfMonitorAMD *args = (ARGS_glBeginPerfMonitorAMD *)&unpacked->args; \
    glBeginPerfMonitorAMD(args->monitor);; \
} while(0)
void glBeginPerfMonitorAMD(glBeginPerfMonitorAMD_ARG_EXPAND);
typedef void (*glBeginPerfMonitorAMD_PTR)(glBeginPerfMonitorAMD_ARG_EXPAND);
#define glBeginQuery_INDEX 106
#define glBeginQuery_RETURN void
#define glBeginQuery_ARG_NAMES target, id
#define glBeginQuery_ARG_EXPAND GLenum target, GLuint id
#define glBeginQuery_PACKED PACKED_glBeginQuery
#define glBeginQuery_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glBeginQuery_NOT_VOID_WRAP(...) {}
#define pack_glBeginQuery(_target, _id) ({ \
    glBeginQuery_PACKED *packed_data = malloc(sizeof(glBeginQuery_PACKED)); \
    packed_data->index = glBeginQuery_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.id = (GLuint)_id; \
    (packed_call_t *)packed_data; \
})
#define call_glBeginQuery(packed, ret_v) do { \
    PACKED_glBeginQuery *unpacked = (PACKED_glBeginQuery *)packed; \
    ARGS_glBeginQuery *args = (ARGS_glBeginQuery *)&unpacked->args; \
    glBeginQuery(args->target, args->id);; \
} while(0)
void glBeginQuery(glBeginQuery_ARG_EXPAND);
typedef void (*glBeginQuery_PTR)(glBeginQuery_ARG_EXPAND);
#define glBeginQueryARB_INDEX 107
#define glBeginQueryARB_RETURN void
#define glBeginQueryARB_ARG_NAMES target, id
#define glBeginQueryARB_ARG_EXPAND GLenum target, GLuint id
#define glBeginQueryARB_PACKED PACKED_glBeginQueryARB
#define glBeginQueryARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glBeginQueryARB_NOT_VOID_WRAP(...) {}
#define pack_glBeginQueryARB(_target, _id) ({ \
    glBeginQueryARB_PACKED *packed_data = malloc(sizeof(glBeginQueryARB_PACKED)); \
    packed_data->index = glBeginQueryARB_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.id = (GLuint)_id; \
    (packed_call_t *)packed_data; \
})
#define call_glBeginQueryARB(packed, ret_v) do { \
    PACKED_glBeginQueryARB *unpacked = (PACKED_glBeginQueryARB *)packed; \
    ARGS_glBeginQueryARB *args = (ARGS_glBeginQueryARB *)&unpacked->args; \
    glBeginQueryARB(args->target, args->id);; \
} while(0)
void glBeginQueryARB(glBeginQueryARB_ARG_EXPAND);
typedef void (*glBeginQueryARB_PTR)(glBeginQueryARB_ARG_EXPAND);
#define glBeginQueryIndexed_INDEX 108
#define glBeginQueryIndexed_RETURN void
#define glBeginQueryIndexed_ARG_NAMES target, index, id
#define glBeginQueryIndexed_ARG_EXPAND GLenum target, GLuint index, GLuint id
#define glBeginQueryIndexed_PACKED PACKED_glBeginQueryIndexed
#define glBeginQueryIndexed_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glBeginQueryIndexed_NOT_VOID_WRAP(...) {}
#define pack_glBeginQueryIndexed(_target, _index, _id) ({ \
    glBeginQueryIndexed_PACKED *packed_data = malloc(sizeof(glBeginQueryIndexed_PACKED)); \
    packed_data->index = glBeginQueryIndexed_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.id = (GLuint)_id; \
    (packed_call_t *)packed_data; \
})
#define call_glBeginQueryIndexed(packed, ret_v) do { \
    PACKED_glBeginQueryIndexed *unpacked = (PACKED_glBeginQueryIndexed *)packed; \
    ARGS_glBeginQueryIndexed *args = (ARGS_glBeginQueryIndexed *)&unpacked->args; \
    glBeginQueryIndexed(args->target, args->index, args->id);; \
} while(0)
void glBeginQueryIndexed(glBeginQueryIndexed_ARG_EXPAND);
typedef void (*glBeginQueryIndexed_PTR)(glBeginQueryIndexed_ARG_EXPAND);
#define glBeginTransformFeedback_INDEX 109
#define glBeginTransformFeedback_RETURN void
#define glBeginTransformFeedback_ARG_NAMES primitiveMode
#define glBeginTransformFeedback_ARG_EXPAND GLenum primitiveMode
#define glBeginTransformFeedback_PACKED PACKED_glBeginTransformFeedback
#define glBeginTransformFeedback_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glBeginTransformFeedback_NOT_VOID_WRAP(...) {}
#define pack_glBeginTransformFeedback(_primitiveMode) ({ \
    glBeginTransformFeedback_PACKED *packed_data = malloc(sizeof(glBeginTransformFeedback_PACKED)); \
    packed_data->index = glBeginTransformFeedback_INDEX; \
    packed_data->args.primitiveMode = (GLenum)_primitiveMode; \
    (packed_call_t *)packed_data; \
})
#define call_glBeginTransformFeedback(packed, ret_v) do { \
    PACKED_glBeginTransformFeedback *unpacked = (PACKED_glBeginTransformFeedback *)packed; \
    ARGS_glBeginTransformFeedback *args = (ARGS_glBeginTransformFeedback *)&unpacked->args; \
    glBeginTransformFeedback(args->primitiveMode);; \
} while(0)
void glBeginTransformFeedback(glBeginTransformFeedback_ARG_EXPAND);
typedef void (*glBeginTransformFeedback_PTR)(glBeginTransformFeedback_ARG_EXPAND);
#define glBeginTransformFeedbackEXT_INDEX 110
#define glBeginTransformFeedbackEXT_RETURN void
#define glBeginTransformFeedbackEXT_ARG_NAMES primitiveMode
#define glBeginTransformFeedbackEXT_ARG_EXPAND GLenum primitiveMode
#define glBeginTransformFeedbackEXT_PACKED PACKED_glBeginTransformFeedbackEXT
#define glBeginTransformFeedbackEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glBeginTransformFeedbackEXT_NOT_VOID_WRAP(...) {}
#define pack_glBeginTransformFeedbackEXT(_primitiveMode) ({ \
    glBeginTransformFeedbackEXT_PACKED *packed_data = malloc(sizeof(glBeginTransformFeedbackEXT_PACKED)); \
    packed_data->index = glBeginTransformFeedbackEXT_INDEX; \
    packed_data->args.primitiveMode = (GLenum)_primitiveMode; \
    (packed_call_t *)packed_data; \
})
#define call_glBeginTransformFeedbackEXT(packed, ret_v) do { \
    PACKED_glBeginTransformFeedbackEXT *unpacked = (PACKED_glBeginTransformFeedbackEXT *)packed; \
    ARGS_glBeginTransformFeedbackEXT *args = (ARGS_glBeginTransformFeedbackEXT *)&unpacked->args; \
    glBeginTransformFeedbackEXT(args->primitiveMode);; \
} while(0)
void glBeginTransformFeedbackEXT(glBeginTransformFeedbackEXT_ARG_EXPAND);
typedef void (*glBeginTransformFeedbackEXT_PTR)(glBeginTransformFeedbackEXT_ARG_EXPAND);
#define glBeginTransformFeedbackNV_INDEX 111
#define glBeginTransformFeedbackNV_RETURN void
#define glBeginTransformFeedbackNV_ARG_NAMES primitiveMode
#define glBeginTransformFeedbackNV_ARG_EXPAND GLenum primitiveMode
#define glBeginTransformFeedbackNV_PACKED PACKED_glBeginTransformFeedbackNV
#define glBeginTransformFeedbackNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glBeginTransformFeedbackNV_NOT_VOID_WRAP(...) {}
#define pack_glBeginTransformFeedbackNV(_primitiveMode) ({ \
    glBeginTransformFeedbackNV_PACKED *packed_data = malloc(sizeof(glBeginTransformFeedbackNV_PACKED)); \
    packed_data->index = glBeginTransformFeedbackNV_INDEX; \
    packed_data->args.primitiveMode = (GLenum)_primitiveMode; \
    (packed_call_t *)packed_data; \
})
#define call_glBeginTransformFeedbackNV(packed, ret_v) do { \
    PACKED_glBeginTransformFeedbackNV *unpacked = (PACKED_glBeginTransformFeedbackNV *)packed; \
    ARGS_glBeginTransformFeedbackNV *args = (ARGS_glBeginTransformFeedbackNV *)&unpacked->args; \
    glBeginTransformFeedbackNV(args->primitiveMode);; \
} while(0)
void glBeginTransformFeedbackNV(glBeginTransformFeedbackNV_ARG_EXPAND);
typedef void (*glBeginTransformFeedbackNV_PTR)(glBeginTransformFeedbackNV_ARG_EXPAND);
#define glBeginVertexShaderEXT_INDEX 112
#define glBeginVertexShaderEXT_RETURN void
#define glBeginVertexShaderEXT_ARG_NAMES 
#define glBeginVertexShaderEXT_ARG_EXPAND 
#define glBeginVertexShaderEXT_PACKED PACKED_glBeginVertexShaderEXT
#define glBeginVertexShaderEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glBeginVertexShaderEXT_NOT_VOID_WRAP(...) {}
#define pack_glBeginVertexShaderEXT() ({ \
    glBeginVertexShaderEXT_PACKED *packed_data = malloc(sizeof(glBeginVertexShaderEXT_PACKED)); \
    packed_data->index = glBeginVertexShaderEXT_INDEX; \
    (packed_call_t *)packed_data; \
})
#define call_glBeginVertexShaderEXT(packed, ret_v) do { \
    glBeginVertexShaderEXT();; \
} while(0)
void glBeginVertexShaderEXT(glBeginVertexShaderEXT_ARG_EXPAND);
typedef void (*glBeginVertexShaderEXT_PTR)(glBeginVertexShaderEXT_ARG_EXPAND);
#define glBeginVideoCaptureNV_INDEX 113
#define glBeginVideoCaptureNV_RETURN void
#define glBeginVideoCaptureNV_ARG_NAMES video_capture_slot
#define glBeginVideoCaptureNV_ARG_EXPAND GLuint video_capture_slot
#define glBeginVideoCaptureNV_PACKED PACKED_glBeginVideoCaptureNV
#define glBeginVideoCaptureNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glBeginVideoCaptureNV_NOT_VOID_WRAP(...) {}
#define pack_glBeginVideoCaptureNV(_video_capture_slot) ({ \
    glBeginVideoCaptureNV_PACKED *packed_data = malloc(sizeof(glBeginVideoCaptureNV_PACKED)); \
    packed_data->index = glBeginVideoCaptureNV_INDEX; \
    packed_data->args.video_capture_slot = (GLuint)_video_capture_slot; \
    (packed_call_t *)packed_data; \
})
#define call_glBeginVideoCaptureNV(packed, ret_v) do { \
    PACKED_glBeginVideoCaptureNV *unpacked = (PACKED_glBeginVideoCaptureNV *)packed; \
    ARGS_glBeginVideoCaptureNV *args = (ARGS_glBeginVideoCaptureNV *)&unpacked->args; \
    glBeginVideoCaptureNV(args->video_capture_slot);; \
} while(0)
void glBeginVideoCaptureNV(glBeginVideoCaptureNV_ARG_EXPAND);
typedef void (*glBeginVideoCaptureNV_PTR)(glBeginVideoCaptureNV_ARG_EXPAND);
#define glBindAttribLocation_INDEX 114
#define glBindAttribLocation_RETURN void
#define glBindAttribLocation_ARG_NAMES program, index, name
#define glBindAttribLocation_ARG_EXPAND GLuint program, GLuint index, const GLchar * name
#define glBindAttribLocation_PACKED PACKED_glBindAttribLocation
#define glBindAttribLocation_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glBindAttribLocation_NOT_VOID_WRAP(...) {}
#define pack_glBindAttribLocation(_program, _index, _name) ({ \
    glBindAttribLocation_PACKED *packed_data = malloc(sizeof(glBindAttribLocation_PACKED)); \
    packed_data->index = glBindAttribLocation_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.name = (GLchar *)_name; \
    (packed_call_t *)packed_data; \
})
#define call_glBindAttribLocation(packed, ret_v) do { \
    PACKED_glBindAttribLocation *unpacked = (PACKED_glBindAttribLocation *)packed; \
    ARGS_glBindAttribLocation *args = (ARGS_glBindAttribLocation *)&unpacked->args; \
    glBindAttribLocation(args->program, args->index, args->name);; \
} while(0)
void glBindAttribLocation(glBindAttribLocation_ARG_EXPAND);
typedef void (*glBindAttribLocation_PTR)(glBindAttribLocation_ARG_EXPAND);
#define glBindAttribLocationARB_INDEX 115
#define glBindAttribLocationARB_RETURN void
#define glBindAttribLocationARB_ARG_NAMES programObj, index, name
#define glBindAttribLocationARB_ARG_EXPAND GLhandleARB programObj, GLuint index, const GLcharARB * name
#define glBindAttribLocationARB_PACKED PACKED_glBindAttribLocationARB
#define glBindAttribLocationARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glBindAttribLocationARB_NOT_VOID_WRAP(...) {}
#define pack_glBindAttribLocationARB(_programObj, _index, _name) ({ \
    glBindAttribLocationARB_PACKED *packed_data = malloc(sizeof(glBindAttribLocationARB_PACKED)); \
    packed_data->index = glBindAttribLocationARB_INDEX; \
    packed_data->args.programObj = (GLhandleARB)_programObj; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.name = (GLcharARB *)_name; \
    (packed_call_t *)packed_data; \
})
#define call_glBindAttribLocationARB(packed, ret_v) do { \
    PACKED_glBindAttribLocationARB *unpacked = (PACKED_glBindAttribLocationARB *)packed; \
    ARGS_glBindAttribLocationARB *args = (ARGS_glBindAttribLocationARB *)&unpacked->args; \
    glBindAttribLocationARB(args->programObj, args->index, args->name);; \
} while(0)
void glBindAttribLocationARB(glBindAttribLocationARB_ARG_EXPAND);
typedef void (*glBindAttribLocationARB_PTR)(glBindAttribLocationARB_ARG_EXPAND);
#define glBindBuffer_INDEX 116
#define glBindBuffer_RETURN void
#define glBindBuffer_ARG_NAMES target, buffer
#define glBindBuffer_ARG_EXPAND GLenum target, GLuint buffer
#define glBindBuffer_PACKED PACKED_glBindBuffer
#define glBindBuffer_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glBindBuffer_NOT_VOID_WRAP(...) {}
#define pack_glBindBuffer(_target, _buffer) ({ \
    glBindBuffer_PACKED *packed_data = malloc(sizeof(glBindBuffer_PACKED)); \
    packed_data->index = glBindBuffer_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.buffer = (GLuint)_buffer; \
    (packed_call_t *)packed_data; \
})
#define call_glBindBuffer(packed, ret_v) do { \
    PACKED_glBindBuffer *unpacked = (PACKED_glBindBuffer *)packed; \
    ARGS_glBindBuffer *args = (ARGS_glBindBuffer *)&unpacked->args; \
    glBindBuffer(args->target, args->buffer);; \
} while(0)
void glBindBuffer(glBindBuffer_ARG_EXPAND);
typedef void (*glBindBuffer_PTR)(glBindBuffer_ARG_EXPAND);
#define glBindBufferARB_INDEX 117
#define glBindBufferARB_RETURN void
#define glBindBufferARB_ARG_NAMES target, buffer
#define glBindBufferARB_ARG_EXPAND GLenum target, GLuint buffer
#define glBindBufferARB_PACKED PACKED_glBindBufferARB
#define glBindBufferARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glBindBufferARB_NOT_VOID_WRAP(...) {}
#define pack_glBindBufferARB(_target, _buffer) ({ \
    glBindBufferARB_PACKED *packed_data = malloc(sizeof(glBindBufferARB_PACKED)); \
    packed_data->index = glBindBufferARB_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.buffer = (GLuint)_buffer; \
    (packed_call_t *)packed_data; \
})
#define call_glBindBufferARB(packed, ret_v) do { \
    PACKED_glBindBufferARB *unpacked = (PACKED_glBindBufferARB *)packed; \
    ARGS_glBindBufferARB *args = (ARGS_glBindBufferARB *)&unpacked->args; \
    glBindBufferARB(args->target, args->buffer);; \
} while(0)
void glBindBufferARB(glBindBufferARB_ARG_EXPAND);
typedef void (*glBindBufferARB_PTR)(glBindBufferARB_ARG_EXPAND);
#define glBindBufferBase_INDEX 118
#define glBindBufferBase_RETURN void
#define glBindBufferBase_ARG_NAMES target, index, buffer
#define glBindBufferBase_ARG_EXPAND GLenum target, GLuint index, GLuint buffer
#define glBindBufferBase_PACKED PACKED_glBindBufferBase
#define glBindBufferBase_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glBindBufferBase_NOT_VOID_WRAP(...) {}
#define pack_glBindBufferBase(_target, _index, _buffer) ({ \
    glBindBufferBase_PACKED *packed_data = malloc(sizeof(glBindBufferBase_PACKED)); \
    packed_data->index = glBindBufferBase_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.buffer = (GLuint)_buffer; \
    (packed_call_t *)packed_data; \
})
#define call_glBindBufferBase(packed, ret_v) do { \
    PACKED_glBindBufferBase *unpacked = (PACKED_glBindBufferBase *)packed; \
    ARGS_glBindBufferBase *args = (ARGS_glBindBufferBase *)&unpacked->args; \
    glBindBufferBase(args->target, args->index, args->buffer);; \
} while(0)
void glBindBufferBase(glBindBufferBase_ARG_EXPAND);
typedef void (*glBindBufferBase_PTR)(glBindBufferBase_ARG_EXPAND);
#define glBindBufferBaseEXT_INDEX 119
#define glBindBufferBaseEXT_RETURN void
#define glBindBufferBaseEXT_ARG_NAMES target, index, buffer
#define glBindBufferBaseEXT_ARG_EXPAND GLenum target, GLuint index, GLuint buffer
#define glBindBufferBaseEXT_PACKED PACKED_glBindBufferBaseEXT
#define glBindBufferBaseEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glBindBufferBaseEXT_NOT_VOID_WRAP(...) {}
#define pack_glBindBufferBaseEXT(_target, _index, _buffer) ({ \
    glBindBufferBaseEXT_PACKED *packed_data = malloc(sizeof(glBindBufferBaseEXT_PACKED)); \
    packed_data->index = glBindBufferBaseEXT_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.buffer = (GLuint)_buffer; \
    (packed_call_t *)packed_data; \
})
#define call_glBindBufferBaseEXT(packed, ret_v) do { \
    PACKED_glBindBufferBaseEXT *unpacked = (PACKED_glBindBufferBaseEXT *)packed; \
    ARGS_glBindBufferBaseEXT *args = (ARGS_glBindBufferBaseEXT *)&unpacked->args; \
    glBindBufferBaseEXT(args->target, args->index, args->buffer);; \
} while(0)
void glBindBufferBaseEXT(glBindBufferBaseEXT_ARG_EXPAND);
typedef void (*glBindBufferBaseEXT_PTR)(glBindBufferBaseEXT_ARG_EXPAND);
#define glBindBufferBaseNV_INDEX 120
#define glBindBufferBaseNV_RETURN void
#define glBindBufferBaseNV_ARG_NAMES target, index, buffer
#define glBindBufferBaseNV_ARG_EXPAND GLenum target, GLuint index, GLuint buffer
#define glBindBufferBaseNV_PACKED PACKED_glBindBufferBaseNV
#define glBindBufferBaseNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glBindBufferBaseNV_NOT_VOID_WRAP(...) {}
#define pack_glBindBufferBaseNV(_target, _index, _buffer) ({ \
    glBindBufferBaseNV_PACKED *packed_data = malloc(sizeof(glBindBufferBaseNV_PACKED)); \
    packed_data->index = glBindBufferBaseNV_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.buffer = (GLuint)_buffer; \
    (packed_call_t *)packed_data; \
})
#define call_glBindBufferBaseNV(packed, ret_v) do { \
    PACKED_glBindBufferBaseNV *unpacked = (PACKED_glBindBufferBaseNV *)packed; \
    ARGS_glBindBufferBaseNV *args = (ARGS_glBindBufferBaseNV *)&unpacked->args; \
    glBindBufferBaseNV(args->target, args->index, args->buffer);; \
} while(0)
void glBindBufferBaseNV(glBindBufferBaseNV_ARG_EXPAND);
typedef void (*glBindBufferBaseNV_PTR)(glBindBufferBaseNV_ARG_EXPAND);
#define glBindBufferOffsetEXT_INDEX 121
#define glBindBufferOffsetEXT_RETURN void
#define glBindBufferOffsetEXT_ARG_NAMES target, index, buffer, offset
#define glBindBufferOffsetEXT_ARG_EXPAND GLenum target, GLuint index, GLuint buffer, GLintptr offset
#define glBindBufferOffsetEXT_PACKED PACKED_glBindBufferOffsetEXT
#define glBindBufferOffsetEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glBindBufferOffsetEXT_NOT_VOID_WRAP(...) {}
#define pack_glBindBufferOffsetEXT(_target, _index, _buffer, _offset) ({ \
    glBindBufferOffsetEXT_PACKED *packed_data = malloc(sizeof(glBindBufferOffsetEXT_PACKED)); \
    packed_data->index = glBindBufferOffsetEXT_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.buffer = (GLuint)_buffer; \
    packed_data->args.offset = (GLintptr)_offset; \
    (packed_call_t *)packed_data; \
})
#define call_glBindBufferOffsetEXT(packed, ret_v) do { \
    PACKED_glBindBufferOffsetEXT *unpacked = (PACKED_glBindBufferOffsetEXT *)packed; \
    ARGS_glBindBufferOffsetEXT *args = (ARGS_glBindBufferOffsetEXT *)&unpacked->args; \
    glBindBufferOffsetEXT(args->target, args->index, args->buffer, args->offset);; \
} while(0)
void glBindBufferOffsetEXT(glBindBufferOffsetEXT_ARG_EXPAND);
typedef void (*glBindBufferOffsetEXT_PTR)(glBindBufferOffsetEXT_ARG_EXPAND);
#define glBindBufferOffsetNV_INDEX 122
#define glBindBufferOffsetNV_RETURN void
#define glBindBufferOffsetNV_ARG_NAMES target, index, buffer, offset
#define glBindBufferOffsetNV_ARG_EXPAND GLenum target, GLuint index, GLuint buffer, GLintptr offset
#define glBindBufferOffsetNV_PACKED PACKED_glBindBufferOffsetNV
#define glBindBufferOffsetNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glBindBufferOffsetNV_NOT_VOID_WRAP(...) {}
#define pack_glBindBufferOffsetNV(_target, _index, _buffer, _offset) ({ \
    glBindBufferOffsetNV_PACKED *packed_data = malloc(sizeof(glBindBufferOffsetNV_PACKED)); \
    packed_data->index = glBindBufferOffsetNV_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.buffer = (GLuint)_buffer; \
    packed_data->args.offset = (GLintptr)_offset; \
    (packed_call_t *)packed_data; \
})
#define call_glBindBufferOffsetNV(packed, ret_v) do { \
    PACKED_glBindBufferOffsetNV *unpacked = (PACKED_glBindBufferOffsetNV *)packed; \
    ARGS_glBindBufferOffsetNV *args = (ARGS_glBindBufferOffsetNV *)&unpacked->args; \
    glBindBufferOffsetNV(args->target, args->index, args->buffer, args->offset);; \
} while(0)
void glBindBufferOffsetNV(glBindBufferOffsetNV_ARG_EXPAND);
typedef void (*glBindBufferOffsetNV_PTR)(glBindBufferOffsetNV_ARG_EXPAND);
#define glBindBufferRange_INDEX 123
#define glBindBufferRange_RETURN void
#define glBindBufferRange_ARG_NAMES target, index, buffer, offset, size
#define glBindBufferRange_ARG_EXPAND GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size
#define glBindBufferRange_PACKED PACKED_glBindBufferRange
#define glBindBufferRange_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glBindBufferRange_NOT_VOID_WRAP(...) {}
#define pack_glBindBufferRange(_target, _index, _buffer, _offset, _size) ({ \
    glBindBufferRange_PACKED *packed_data = malloc(sizeof(glBindBufferRange_PACKED)); \
    packed_data->index = glBindBufferRange_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.buffer = (GLuint)_buffer; \
    packed_data->args.offset = (GLintptr)_offset; \
    packed_data->args.size = (GLsizeiptr)_size; \
    (packed_call_t *)packed_data; \
})
#define call_glBindBufferRange(packed, ret_v) do { \
    PACKED_glBindBufferRange *unpacked = (PACKED_glBindBufferRange *)packed; \
    ARGS_glBindBufferRange *args = (ARGS_glBindBufferRange *)&unpacked->args; \
    glBindBufferRange(args->target, args->index, args->buffer, args->offset, args->size);; \
} while(0)
void glBindBufferRange(glBindBufferRange_ARG_EXPAND);
typedef void (*glBindBufferRange_PTR)(glBindBufferRange_ARG_EXPAND);
#define glBindBufferRangeEXT_INDEX 124
#define glBindBufferRangeEXT_RETURN void
#define glBindBufferRangeEXT_ARG_NAMES target, index, buffer, offset, size
#define glBindBufferRangeEXT_ARG_EXPAND GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size
#define glBindBufferRangeEXT_PACKED PACKED_glBindBufferRangeEXT
#define glBindBufferRangeEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glBindBufferRangeEXT_NOT_VOID_WRAP(...) {}
#define pack_glBindBufferRangeEXT(_target, _index, _buffer, _offset, _size) ({ \
    glBindBufferRangeEXT_PACKED *packed_data = malloc(sizeof(glBindBufferRangeEXT_PACKED)); \
    packed_data->index = glBindBufferRangeEXT_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.buffer = (GLuint)_buffer; \
    packed_data->args.offset = (GLintptr)_offset; \
    packed_data->args.size = (GLsizeiptr)_size; \
    (packed_call_t *)packed_data; \
})
#define call_glBindBufferRangeEXT(packed, ret_v) do { \
    PACKED_glBindBufferRangeEXT *unpacked = (PACKED_glBindBufferRangeEXT *)packed; \
    ARGS_glBindBufferRangeEXT *args = (ARGS_glBindBufferRangeEXT *)&unpacked->args; \
    glBindBufferRangeEXT(args->target, args->index, args->buffer, args->offset, args->size);; \
} while(0)
void glBindBufferRangeEXT(glBindBufferRangeEXT_ARG_EXPAND);
typedef void (*glBindBufferRangeEXT_PTR)(glBindBufferRangeEXT_ARG_EXPAND);
#define glBindBufferRangeNV_INDEX 125
#define glBindBufferRangeNV_RETURN void
#define glBindBufferRangeNV_ARG_NAMES target, index, buffer, offset, size
#define glBindBufferRangeNV_ARG_EXPAND GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size
#define glBindBufferRangeNV_PACKED PACKED_glBindBufferRangeNV
#define glBindBufferRangeNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glBindBufferRangeNV_NOT_VOID_WRAP(...) {}
#define pack_glBindBufferRangeNV(_target, _index, _buffer, _offset, _size) ({ \
    glBindBufferRangeNV_PACKED *packed_data = malloc(sizeof(glBindBufferRangeNV_PACKED)); \
    packed_data->index = glBindBufferRangeNV_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.buffer = (GLuint)_buffer; \
    packed_data->args.offset = (GLintptr)_offset; \
    packed_data->args.size = (GLsizeiptr)_size; \
    (packed_call_t *)packed_data; \
})
#define call_glBindBufferRangeNV(packed, ret_v) do { \
    PACKED_glBindBufferRangeNV *unpacked = (PACKED_glBindBufferRangeNV *)packed; \
    ARGS_glBindBufferRangeNV *args = (ARGS_glBindBufferRangeNV *)&unpacked->args; \
    glBindBufferRangeNV(args->target, args->index, args->buffer, args->offset, args->size);; \
} while(0)
void glBindBufferRangeNV(glBindBufferRangeNV_ARG_EXPAND);
typedef void (*glBindBufferRangeNV_PTR)(glBindBufferRangeNV_ARG_EXPAND);
#define glBindFragDataLocation_INDEX 126
#define glBindFragDataLocation_RETURN void
#define glBindFragDataLocation_ARG_NAMES program, color, name
#define glBindFragDataLocation_ARG_EXPAND GLuint program, GLuint color, const GLchar * name
#define glBindFragDataLocation_PACKED PACKED_glBindFragDataLocation
#define glBindFragDataLocation_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glBindFragDataLocation_NOT_VOID_WRAP(...) {}
#define pack_glBindFragDataLocation(_program, _color, _name) ({ \
    glBindFragDataLocation_PACKED *packed_data = malloc(sizeof(glBindFragDataLocation_PACKED)); \
    packed_data->index = glBindFragDataLocation_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.color = (GLuint)_color; \
    packed_data->args.name = (GLchar *)_name; \
    (packed_call_t *)packed_data; \
})
#define call_glBindFragDataLocation(packed, ret_v) do { \
    PACKED_glBindFragDataLocation *unpacked = (PACKED_glBindFragDataLocation *)packed; \
    ARGS_glBindFragDataLocation *args = (ARGS_glBindFragDataLocation *)&unpacked->args; \
    glBindFragDataLocation(args->program, args->color, args->name);; \
} while(0)
void glBindFragDataLocation(glBindFragDataLocation_ARG_EXPAND);
typedef void (*glBindFragDataLocation_PTR)(glBindFragDataLocation_ARG_EXPAND);
#define glBindFragDataLocationEXT_INDEX 127
#define glBindFragDataLocationEXT_RETURN void
#define glBindFragDataLocationEXT_ARG_NAMES program, color, name
#define glBindFragDataLocationEXT_ARG_EXPAND GLuint program, GLuint color, const GLchar * name
#define glBindFragDataLocationEXT_PACKED PACKED_glBindFragDataLocationEXT
#define glBindFragDataLocationEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glBindFragDataLocationEXT_NOT_VOID_WRAP(...) {}
#define pack_glBindFragDataLocationEXT(_program, _color, _name) ({ \
    glBindFragDataLocationEXT_PACKED *packed_data = malloc(sizeof(glBindFragDataLocationEXT_PACKED)); \
    packed_data->index = glBindFragDataLocationEXT_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.color = (GLuint)_color; \
    packed_data->args.name = (GLchar *)_name; \
    (packed_call_t *)packed_data; \
})
#define call_glBindFragDataLocationEXT(packed, ret_v) do { \
    PACKED_glBindFragDataLocationEXT *unpacked = (PACKED_glBindFragDataLocationEXT *)packed; \
    ARGS_glBindFragDataLocationEXT *args = (ARGS_glBindFragDataLocationEXT *)&unpacked->args; \
    glBindFragDataLocationEXT(args->program, args->color, args->name);; \
} while(0)
void glBindFragDataLocationEXT(glBindFragDataLocationEXT_ARG_EXPAND);
typedef void (*glBindFragDataLocationEXT_PTR)(glBindFragDataLocationEXT_ARG_EXPAND);
#define glBindFragDataLocationIndexed_INDEX 128
#define glBindFragDataLocationIndexed_RETURN void
#define glBindFragDataLocationIndexed_ARG_NAMES program, colorNumber, index, name
#define glBindFragDataLocationIndexed_ARG_EXPAND GLuint program, GLuint colorNumber, GLuint index, const GLchar * name
#define glBindFragDataLocationIndexed_PACKED PACKED_glBindFragDataLocationIndexed
#define glBindFragDataLocationIndexed_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glBindFragDataLocationIndexed_NOT_VOID_WRAP(...) {}
#define pack_glBindFragDataLocationIndexed(_program, _colorNumber, _index, _name) ({ \
    glBindFragDataLocationIndexed_PACKED *packed_data = malloc(sizeof(glBindFragDataLocationIndexed_PACKED)); \
    packed_data->index = glBindFragDataLocationIndexed_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.colorNumber = (GLuint)_colorNumber; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.name = (GLchar *)_name; \
    (packed_call_t *)packed_data; \
})
#define call_glBindFragDataLocationIndexed(packed, ret_v) do { \
    PACKED_glBindFragDataLocationIndexed *unpacked = (PACKED_glBindFragDataLocationIndexed *)packed; \
    ARGS_glBindFragDataLocationIndexed *args = (ARGS_glBindFragDataLocationIndexed *)&unpacked->args; \
    glBindFragDataLocationIndexed(args->program, args->colorNumber, args->index, args->name);; \
} while(0)
void glBindFragDataLocationIndexed(glBindFragDataLocationIndexed_ARG_EXPAND);
typedef void (*glBindFragDataLocationIndexed_PTR)(glBindFragDataLocationIndexed_ARG_EXPAND);
#define glBindFragmentShaderATI_INDEX 129
#define glBindFragmentShaderATI_RETURN void
#define glBindFragmentShaderATI_ARG_NAMES id
#define glBindFragmentShaderATI_ARG_EXPAND GLuint id
#define glBindFragmentShaderATI_PACKED PACKED_glBindFragmentShaderATI
#define glBindFragmentShaderATI_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glBindFragmentShaderATI_NOT_VOID_WRAP(...) {}
#define pack_glBindFragmentShaderATI(_id) ({ \
    glBindFragmentShaderATI_PACKED *packed_data = malloc(sizeof(glBindFragmentShaderATI_PACKED)); \
    packed_data->index = glBindFragmentShaderATI_INDEX; \
    packed_data->args.id = (GLuint)_id; \
    (packed_call_t *)packed_data; \
})
#define call_glBindFragmentShaderATI(packed, ret_v) do { \
    PACKED_glBindFragmentShaderATI *unpacked = (PACKED_glBindFragmentShaderATI *)packed; \
    ARGS_glBindFragmentShaderATI *args = (ARGS_glBindFragmentShaderATI *)&unpacked->args; \
    glBindFragmentShaderATI(args->id);; \
} while(0)
void glBindFragmentShaderATI(glBindFragmentShaderATI_ARG_EXPAND);
typedef void (*glBindFragmentShaderATI_PTR)(glBindFragmentShaderATI_ARG_EXPAND);
#define glBindFramebuffer_INDEX 130
#define glBindFramebuffer_RETURN void
#define glBindFramebuffer_ARG_NAMES target, framebuffer
#define glBindFramebuffer_ARG_EXPAND GLenum target, GLuint framebuffer
#define glBindFramebuffer_PACKED PACKED_glBindFramebuffer
#define glBindFramebuffer_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glBindFramebuffer_NOT_VOID_WRAP(...) {}
#define pack_glBindFramebuffer(_target, _framebuffer) ({ \
    glBindFramebuffer_PACKED *packed_data = malloc(sizeof(glBindFramebuffer_PACKED)); \
    packed_data->index = glBindFramebuffer_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.framebuffer = (GLuint)_framebuffer; \
    (packed_call_t *)packed_data; \
})
#define call_glBindFramebuffer(packed, ret_v) do { \
    PACKED_glBindFramebuffer *unpacked = (PACKED_glBindFramebuffer *)packed; \
    ARGS_glBindFramebuffer *args = (ARGS_glBindFramebuffer *)&unpacked->args; \
    glBindFramebuffer(args->target, args->framebuffer);; \
} while(0)
void glBindFramebuffer(glBindFramebuffer_ARG_EXPAND);
typedef void (*glBindFramebuffer_PTR)(glBindFramebuffer_ARG_EXPAND);
#define glBindFramebufferEXT_INDEX 131
#define glBindFramebufferEXT_RETURN void
#define glBindFramebufferEXT_ARG_NAMES target, framebuffer
#define glBindFramebufferEXT_ARG_EXPAND GLenum target, GLuint framebuffer
#define glBindFramebufferEXT_PACKED PACKED_glBindFramebufferEXT
#define glBindFramebufferEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glBindFramebufferEXT_NOT_VOID_WRAP(...) {}
#define pack_glBindFramebufferEXT(_target, _framebuffer) ({ \
    glBindFramebufferEXT_PACKED *packed_data = malloc(sizeof(glBindFramebufferEXT_PACKED)); \
    packed_data->index = glBindFramebufferEXT_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.framebuffer = (GLuint)_framebuffer; \
    (packed_call_t *)packed_data; \
})
#define call_glBindFramebufferEXT(packed, ret_v) do { \
    PACKED_glBindFramebufferEXT *unpacked = (PACKED_glBindFramebufferEXT *)packed; \
    ARGS_glBindFramebufferEXT *args = (ARGS_glBindFramebufferEXT *)&unpacked->args; \
    glBindFramebufferEXT(args->target, args->framebuffer);; \
} while(0)
void glBindFramebufferEXT(glBindFramebufferEXT_ARG_EXPAND);
typedef void (*glBindFramebufferEXT_PTR)(glBindFramebufferEXT_ARG_EXPAND);
#define glBindImageTexture_INDEX 132
#define glBindImageTexture_RETURN void
#define glBindImageTexture_ARG_NAMES unit, texture, level, layered, layer, access, format
#define glBindImageTexture_ARG_EXPAND GLuint unit, GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum access, GLenum format
#define glBindImageTexture_PACKED PACKED_glBindImageTexture
#define glBindImageTexture_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glBindImageTexture_NOT_VOID_WRAP(...) {}
#define pack_glBindImageTexture(_unit, _texture, _level, _layered, _layer, _access, _format) ({ \
    glBindImageTexture_PACKED *packed_data = malloc(sizeof(glBindImageTexture_PACKED)); \
    packed_data->index = glBindImageTexture_INDEX; \
    packed_data->args.unit = (GLuint)_unit; \
    packed_data->args.texture = (GLuint)_texture; \
    packed_data->args.level = (GLint)_level; \
    packed_data->args.layered = (GLboolean)_layered; \
    packed_data->args.layer = (GLint)_layer; \
    packed_data->args.access = (GLenum)_access; \
    packed_data->args.format = (GLenum)_format; \
    (packed_call_t *)packed_data; \
})
#define call_glBindImageTexture(packed, ret_v) do { \
    PACKED_glBindImageTexture *unpacked = (PACKED_glBindImageTexture *)packed; \
    ARGS_glBindImageTexture *args = (ARGS_glBindImageTexture *)&unpacked->args; \
    glBindImageTexture(args->unit, args->texture, args->level, args->layered, args->layer, args->access, args->format);; \
} while(0)
void glBindImageTexture(glBindImageTexture_ARG_EXPAND);
typedef void (*glBindImageTexture_PTR)(glBindImageTexture_ARG_EXPAND);
#define glBindImageTextureEXT_INDEX 133
#define glBindImageTextureEXT_RETURN void
#define glBindImageTextureEXT_ARG_NAMES index, texture, level, layered, layer, access, format
#define glBindImageTextureEXT_ARG_EXPAND GLuint index, GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum access, GLint format
#define glBindImageTextureEXT_PACKED PACKED_glBindImageTextureEXT
#define glBindImageTextureEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glBindImageTextureEXT_NOT_VOID_WRAP(...) {}
#define pack_glBindImageTextureEXT(_index, _texture, _level, _layered, _layer, _access, _format) ({ \
    glBindImageTextureEXT_PACKED *packed_data = malloc(sizeof(glBindImageTextureEXT_PACKED)); \
    packed_data->index = glBindImageTextureEXT_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.texture = (GLuint)_texture; \
    packed_data->args.level = (GLint)_level; \
    packed_data->args.layered = (GLboolean)_layered; \
    packed_data->args.layer = (GLint)_layer; \
    packed_data->args.access = (GLenum)_access; \
    packed_data->args.format = (GLint)_format; \
    (packed_call_t *)packed_data; \
})
#define call_glBindImageTextureEXT(packed, ret_v) do { \
    PACKED_glBindImageTextureEXT *unpacked = (PACKED_glBindImageTextureEXT *)packed; \
    ARGS_glBindImageTextureEXT *args = (ARGS_glBindImageTextureEXT *)&unpacked->args; \
    glBindImageTextureEXT(args->index, args->texture, args->level, args->layered, args->layer, args->access, args->format);; \
} while(0)
void glBindImageTextureEXT(glBindImageTextureEXT_ARG_EXPAND);
typedef void (*glBindImageTextureEXT_PTR)(glBindImageTextureEXT_ARG_EXPAND);
#define glBindLightParameterEXT_INDEX 134
#define glBindLightParameterEXT_RETURN GLuint
#define glBindLightParameterEXT_ARG_NAMES light, value
#define glBindLightParameterEXT_ARG_EXPAND GLenum light, GLenum value
#define glBindLightParameterEXT_PACKED PACKED_glBindLightParameterEXT
#define glBindLightParameterEXT_VOID_ONLY_WRAP(...) {}
#define glBindLightParameterEXT_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glBindLightParameterEXT(_light, _value) ({ \
    glBindLightParameterEXT_PACKED *packed_data = malloc(sizeof(glBindLightParameterEXT_PACKED)); \
    packed_data->index = glBindLightParameterEXT_INDEX; \
    packed_data->args.light = (GLenum)_light; \
    packed_data->args.value = (GLenum)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glBindLightParameterEXT(packed, ret_v) do { \
    PACKED_glBindLightParameterEXT *unpacked = (PACKED_glBindLightParameterEXT *)packed; \
    ARGS_glBindLightParameterEXT *args = (ARGS_glBindLightParameterEXT *)&unpacked->args; \
    GLuint *ret = (GLuint *)ret_v; \
    if (ret != NULL) { \
        *ret = glBindLightParameterEXT(args->light, args->value);; \
    } else { \
        glBindLightParameterEXT(args->light, args->value);; \
    } \
} while(0)
GLuint glBindLightParameterEXT(glBindLightParameterEXT_ARG_EXPAND);
typedef GLuint (*glBindLightParameterEXT_PTR)(glBindLightParameterEXT_ARG_EXPAND);
#define glBindMaterialParameterEXT_INDEX 135
#define glBindMaterialParameterEXT_RETURN GLuint
#define glBindMaterialParameterEXT_ARG_NAMES face, value
#define glBindMaterialParameterEXT_ARG_EXPAND GLenum face, GLenum value
#define glBindMaterialParameterEXT_PACKED PACKED_glBindMaterialParameterEXT
#define glBindMaterialParameterEXT_VOID_ONLY_WRAP(...) {}
#define glBindMaterialParameterEXT_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glBindMaterialParameterEXT(_face, _value) ({ \
    glBindMaterialParameterEXT_PACKED *packed_data = malloc(sizeof(glBindMaterialParameterEXT_PACKED)); \
    packed_data->index = glBindMaterialParameterEXT_INDEX; \
    packed_data->args.face = (GLenum)_face; \
    packed_data->args.value = (GLenum)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glBindMaterialParameterEXT(packed, ret_v) do { \
    PACKED_glBindMaterialParameterEXT *unpacked = (PACKED_glBindMaterialParameterEXT *)packed; \
    ARGS_glBindMaterialParameterEXT *args = (ARGS_glBindMaterialParameterEXT *)&unpacked->args; \
    GLuint *ret = (GLuint *)ret_v; \
    if (ret != NULL) { \
        *ret = glBindMaterialParameterEXT(args->face, args->value);; \
    } else { \
        glBindMaterialParameterEXT(args->face, args->value);; \
    } \
} while(0)
GLuint glBindMaterialParameterEXT(glBindMaterialParameterEXT_ARG_EXPAND);
typedef GLuint (*glBindMaterialParameterEXT_PTR)(glBindMaterialParameterEXT_ARG_EXPAND);
#define glBindMultiTextureEXT_INDEX 136
#define glBindMultiTextureEXT_RETURN void
#define glBindMultiTextureEXT_ARG_NAMES texunit, target, texture
#define glBindMultiTextureEXT_ARG_EXPAND GLenum texunit, GLenum target, GLuint texture
#define glBindMultiTextureEXT_PACKED PACKED_glBindMultiTextureEXT
#define glBindMultiTextureEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glBindMultiTextureEXT_NOT_VOID_WRAP(...) {}
#define pack_glBindMultiTextureEXT(_texunit, _target, _texture) ({ \
    glBindMultiTextureEXT_PACKED *packed_data = malloc(sizeof(glBindMultiTextureEXT_PACKED)); \
    packed_data->index = glBindMultiTextureEXT_INDEX; \
    packed_data->args.texunit = (GLenum)_texunit; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.texture = (GLuint)_texture; \
    (packed_call_t *)packed_data; \
})
#define call_glBindMultiTextureEXT(packed, ret_v) do { \
    PACKED_glBindMultiTextureEXT *unpacked = (PACKED_glBindMultiTextureEXT *)packed; \
    ARGS_glBindMultiTextureEXT *args = (ARGS_glBindMultiTextureEXT *)&unpacked->args; \
    glBindMultiTextureEXT(args->texunit, args->target, args->texture);; \
} while(0)
void glBindMultiTextureEXT(glBindMultiTextureEXT_ARG_EXPAND);
typedef void (*glBindMultiTextureEXT_PTR)(glBindMultiTextureEXT_ARG_EXPAND);
#define glBindParameterEXT_INDEX 137
#define glBindParameterEXT_RETURN GLuint
#define glBindParameterEXT_ARG_NAMES value
#define glBindParameterEXT_ARG_EXPAND GLenum value
#define glBindParameterEXT_PACKED PACKED_glBindParameterEXT
#define glBindParameterEXT_VOID_ONLY_WRAP(...) {}
#define glBindParameterEXT_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glBindParameterEXT(_value) ({ \
    glBindParameterEXT_PACKED *packed_data = malloc(sizeof(glBindParameterEXT_PACKED)); \
    packed_data->index = glBindParameterEXT_INDEX; \
    packed_data->args.value = (GLenum)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glBindParameterEXT(packed, ret_v) do { \
    PACKED_glBindParameterEXT *unpacked = (PACKED_glBindParameterEXT *)packed; \
    ARGS_glBindParameterEXT *args = (ARGS_glBindParameterEXT *)&unpacked->args; \
    GLuint *ret = (GLuint *)ret_v; \
    if (ret != NULL) { \
        *ret = glBindParameterEXT(args->value);; \
    } else { \
        glBindParameterEXT(args->value);; \
    } \
} while(0)
GLuint glBindParameterEXT(glBindParameterEXT_ARG_EXPAND);
typedef GLuint (*glBindParameterEXT_PTR)(glBindParameterEXT_ARG_EXPAND);
#define glBindProgramARB_INDEX 138
#define glBindProgramARB_RETURN void
#define glBindProgramARB_ARG_NAMES target, program
#define glBindProgramARB_ARG_EXPAND GLenum target, GLuint program
#define glBindProgramARB_PACKED PACKED_glBindProgramARB
#define glBindProgramARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glBindProgramARB_NOT_VOID_WRAP(...) {}
#define pack_glBindProgramARB(_target, _program) ({ \
    glBindProgramARB_PACKED *packed_data = malloc(sizeof(glBindProgramARB_PACKED)); \
    packed_data->index = glBindProgramARB_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.program = (GLuint)_program; \
    (packed_call_t *)packed_data; \
})
#define call_glBindProgramARB(packed, ret_v) do { \
    PACKED_glBindProgramARB *unpacked = (PACKED_glBindProgramARB *)packed; \
    ARGS_glBindProgramARB *args = (ARGS_glBindProgramARB *)&unpacked->args; \
    glBindProgramARB(args->target, args->program);; \
} while(0)
void glBindProgramARB(glBindProgramARB_ARG_EXPAND);
typedef void (*glBindProgramARB_PTR)(glBindProgramARB_ARG_EXPAND);
#define glBindProgramNV_INDEX 139
#define glBindProgramNV_RETURN void
#define glBindProgramNV_ARG_NAMES target, id
#define glBindProgramNV_ARG_EXPAND GLenum target, GLuint id
#define glBindProgramNV_PACKED PACKED_glBindProgramNV
#define glBindProgramNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glBindProgramNV_NOT_VOID_WRAP(...) {}
#define pack_glBindProgramNV(_target, _id) ({ \
    glBindProgramNV_PACKED *packed_data = malloc(sizeof(glBindProgramNV_PACKED)); \
    packed_data->index = glBindProgramNV_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.id = (GLuint)_id; \
    (packed_call_t *)packed_data; \
})
#define call_glBindProgramNV(packed, ret_v) do { \
    PACKED_glBindProgramNV *unpacked = (PACKED_glBindProgramNV *)packed; \
    ARGS_glBindProgramNV *args = (ARGS_glBindProgramNV *)&unpacked->args; \
    glBindProgramNV(args->target, args->id);; \
} while(0)
void glBindProgramNV(glBindProgramNV_ARG_EXPAND);
typedef void (*glBindProgramNV_PTR)(glBindProgramNV_ARG_EXPAND);
#define glBindProgramPipeline_INDEX 140
#define glBindProgramPipeline_RETURN void
#define glBindProgramPipeline_ARG_NAMES pipeline
#define glBindProgramPipeline_ARG_EXPAND GLuint pipeline
#define glBindProgramPipeline_PACKED PACKED_glBindProgramPipeline
#define glBindProgramPipeline_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glBindProgramPipeline_NOT_VOID_WRAP(...) {}
#define pack_glBindProgramPipeline(_pipeline) ({ \
    glBindProgramPipeline_PACKED *packed_data = malloc(sizeof(glBindProgramPipeline_PACKED)); \
    packed_data->index = glBindProgramPipeline_INDEX; \
    packed_data->args.pipeline = (GLuint)_pipeline; \
    (packed_call_t *)packed_data; \
})
#define call_glBindProgramPipeline(packed, ret_v) do { \
    PACKED_glBindProgramPipeline *unpacked = (PACKED_glBindProgramPipeline *)packed; \
    ARGS_glBindProgramPipeline *args = (ARGS_glBindProgramPipeline *)&unpacked->args; \
    glBindProgramPipeline(args->pipeline);; \
} while(0)
void glBindProgramPipeline(glBindProgramPipeline_ARG_EXPAND);
typedef void (*glBindProgramPipeline_PTR)(glBindProgramPipeline_ARG_EXPAND);
#define glBindRenderbuffer_INDEX 141
#define glBindRenderbuffer_RETURN void
#define glBindRenderbuffer_ARG_NAMES target, renderbuffer
#define glBindRenderbuffer_ARG_EXPAND GLenum target, GLuint renderbuffer
#define glBindRenderbuffer_PACKED PACKED_glBindRenderbuffer
#define glBindRenderbuffer_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glBindRenderbuffer_NOT_VOID_WRAP(...) {}
#define pack_glBindRenderbuffer(_target, _renderbuffer) ({ \
    glBindRenderbuffer_PACKED *packed_data = malloc(sizeof(glBindRenderbuffer_PACKED)); \
    packed_data->index = glBindRenderbuffer_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.renderbuffer = (GLuint)_renderbuffer; \
    (packed_call_t *)packed_data; \
})
#define call_glBindRenderbuffer(packed, ret_v) do { \
    PACKED_glBindRenderbuffer *unpacked = (PACKED_glBindRenderbuffer *)packed; \
    ARGS_glBindRenderbuffer *args = (ARGS_glBindRenderbuffer *)&unpacked->args; \
    glBindRenderbuffer(args->target, args->renderbuffer);; \
} while(0)
void glBindRenderbuffer(glBindRenderbuffer_ARG_EXPAND);
typedef void (*glBindRenderbuffer_PTR)(glBindRenderbuffer_ARG_EXPAND);
#define glBindRenderbufferEXT_INDEX 142
#define glBindRenderbufferEXT_RETURN void
#define glBindRenderbufferEXT_ARG_NAMES target, renderbuffer
#define glBindRenderbufferEXT_ARG_EXPAND GLenum target, GLuint renderbuffer
#define glBindRenderbufferEXT_PACKED PACKED_glBindRenderbufferEXT
#define glBindRenderbufferEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glBindRenderbufferEXT_NOT_VOID_WRAP(...) {}
#define pack_glBindRenderbufferEXT(_target, _renderbuffer) ({ \
    glBindRenderbufferEXT_PACKED *packed_data = malloc(sizeof(glBindRenderbufferEXT_PACKED)); \
    packed_data->index = glBindRenderbufferEXT_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.renderbuffer = (GLuint)_renderbuffer; \
    (packed_call_t *)packed_data; \
})
#define call_glBindRenderbufferEXT(packed, ret_v) do { \
    PACKED_glBindRenderbufferEXT *unpacked = (PACKED_glBindRenderbufferEXT *)packed; \
    ARGS_glBindRenderbufferEXT *args = (ARGS_glBindRenderbufferEXT *)&unpacked->args; \
    glBindRenderbufferEXT(args->target, args->renderbuffer);; \
} while(0)
void glBindRenderbufferEXT(glBindRenderbufferEXT_ARG_EXPAND);
typedef void (*glBindRenderbufferEXT_PTR)(glBindRenderbufferEXT_ARG_EXPAND);
#define glBindSampler_INDEX 143
#define glBindSampler_RETURN void
#define glBindSampler_ARG_NAMES unit, sampler
#define glBindSampler_ARG_EXPAND GLuint unit, GLuint sampler
#define glBindSampler_PACKED PACKED_glBindSampler
#define glBindSampler_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glBindSampler_NOT_VOID_WRAP(...) {}
#define pack_glBindSampler(_unit, _sampler) ({ \
    glBindSampler_PACKED *packed_data = malloc(sizeof(glBindSampler_PACKED)); \
    packed_data->index = glBindSampler_INDEX; \
    packed_data->args.unit = (GLuint)_unit; \
    packed_data->args.sampler = (GLuint)_sampler; \
    (packed_call_t *)packed_data; \
})
#define call_glBindSampler(packed, ret_v) do { \
    PACKED_glBindSampler *unpacked = (PACKED_glBindSampler *)packed; \
    ARGS_glBindSampler *args = (ARGS_glBindSampler *)&unpacked->args; \
    glBindSampler(args->unit, args->sampler);; \
} while(0)
void glBindSampler(glBindSampler_ARG_EXPAND);
typedef void (*glBindSampler_PTR)(glBindSampler_ARG_EXPAND);
#define glBindTexGenParameterEXT_INDEX 144
#define glBindTexGenParameterEXT_RETURN GLuint
#define glBindTexGenParameterEXT_ARG_NAMES unit, coord, value
#define glBindTexGenParameterEXT_ARG_EXPAND GLenum unit, GLenum coord, GLenum value
#define glBindTexGenParameterEXT_PACKED PACKED_glBindTexGenParameterEXT
#define glBindTexGenParameterEXT_VOID_ONLY_WRAP(...) {}
#define glBindTexGenParameterEXT_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glBindTexGenParameterEXT(_unit, _coord, _value) ({ \
    glBindTexGenParameterEXT_PACKED *packed_data = malloc(sizeof(glBindTexGenParameterEXT_PACKED)); \
    packed_data->index = glBindTexGenParameterEXT_INDEX; \
    packed_data->args.unit = (GLenum)_unit; \
    packed_data->args.coord = (GLenum)_coord; \
    packed_data->args.value = (GLenum)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glBindTexGenParameterEXT(packed, ret_v) do { \
    PACKED_glBindTexGenParameterEXT *unpacked = (PACKED_glBindTexGenParameterEXT *)packed; \
    ARGS_glBindTexGenParameterEXT *args = (ARGS_glBindTexGenParameterEXT *)&unpacked->args; \
    GLuint *ret = (GLuint *)ret_v; \
    if (ret != NULL) { \
        *ret = glBindTexGenParameterEXT(args->unit, args->coord, args->value);; \
    } else { \
        glBindTexGenParameterEXT(args->unit, args->coord, args->value);; \
    } \
} while(0)
GLuint glBindTexGenParameterEXT(glBindTexGenParameterEXT_ARG_EXPAND);
typedef GLuint (*glBindTexGenParameterEXT_PTR)(glBindTexGenParameterEXT_ARG_EXPAND);
#define glBindTexture_INDEX 145
#define glBindTexture_RETURN void
#define glBindTexture_ARG_NAMES target, texture
#define glBindTexture_ARG_EXPAND GLenum target, GLuint texture
#define glBindTexture_PACKED PACKED_glBindTexture
#define glBindTexture_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glBindTexture_NOT_VOID_WRAP(...) {}
#define pack_glBindTexture(_target, _texture) ({ \
    glBindTexture_PACKED *packed_data = malloc(sizeof(glBindTexture_PACKED)); \
    packed_data->index = glBindTexture_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.texture = (GLuint)_texture; \
    (packed_call_t *)packed_data; \
})
#define call_glBindTexture(packed, ret_v) do { \
    PACKED_glBindTexture *unpacked = (PACKED_glBindTexture *)packed; \
    ARGS_glBindTexture *args = (ARGS_glBindTexture *)&unpacked->args; \
    glBindTexture(args->target, args->texture);; \
} while(0)
void glBindTexture(glBindTexture_ARG_EXPAND);
typedef void (*glBindTexture_PTR)(glBindTexture_ARG_EXPAND);
#define glBindTextureEXT_INDEX 146
#define glBindTextureEXT_RETURN void
#define glBindTextureEXT_ARG_NAMES target, texture
#define glBindTextureEXT_ARG_EXPAND GLenum target, GLuint texture
#define glBindTextureEXT_PACKED PACKED_glBindTextureEXT
#define glBindTextureEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glBindTextureEXT_NOT_VOID_WRAP(...) {}
#define pack_glBindTextureEXT(_target, _texture) ({ \
    glBindTextureEXT_PACKED *packed_data = malloc(sizeof(glBindTextureEXT_PACKED)); \
    packed_data->index = glBindTextureEXT_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.texture = (GLuint)_texture; \
    (packed_call_t *)packed_data; \
})
#define call_glBindTextureEXT(packed, ret_v) do { \
    PACKED_glBindTextureEXT *unpacked = (PACKED_glBindTextureEXT *)packed; \
    ARGS_glBindTextureEXT *args = (ARGS_glBindTextureEXT *)&unpacked->args; \
    glBindTextureEXT(args->target, args->texture);; \
} while(0)
void glBindTextureEXT(glBindTextureEXT_ARG_EXPAND);
typedef void (*glBindTextureEXT_PTR)(glBindTextureEXT_ARG_EXPAND);
#define glBindTextureUnitParameterEXT_INDEX 147
#define glBindTextureUnitParameterEXT_RETURN GLuint
#define glBindTextureUnitParameterEXT_ARG_NAMES unit, value
#define glBindTextureUnitParameterEXT_ARG_EXPAND GLenum unit, GLenum value
#define glBindTextureUnitParameterEXT_PACKED PACKED_glBindTextureUnitParameterEXT
#define glBindTextureUnitParameterEXT_VOID_ONLY_WRAP(...) {}
#define glBindTextureUnitParameterEXT_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glBindTextureUnitParameterEXT(_unit, _value) ({ \
    glBindTextureUnitParameterEXT_PACKED *packed_data = malloc(sizeof(glBindTextureUnitParameterEXT_PACKED)); \
    packed_data->index = glBindTextureUnitParameterEXT_INDEX; \
    packed_data->args.unit = (GLenum)_unit; \
    packed_data->args.value = (GLenum)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glBindTextureUnitParameterEXT(packed, ret_v) do { \
    PACKED_glBindTextureUnitParameterEXT *unpacked = (PACKED_glBindTextureUnitParameterEXT *)packed; \
    ARGS_glBindTextureUnitParameterEXT *args = (ARGS_glBindTextureUnitParameterEXT *)&unpacked->args; \
    GLuint *ret = (GLuint *)ret_v; \
    if (ret != NULL) { \
        *ret = glBindTextureUnitParameterEXT(args->unit, args->value);; \
    } else { \
        glBindTextureUnitParameterEXT(args->unit, args->value);; \
    } \
} while(0)
GLuint glBindTextureUnitParameterEXT(glBindTextureUnitParameterEXT_ARG_EXPAND);
typedef GLuint (*glBindTextureUnitParameterEXT_PTR)(glBindTextureUnitParameterEXT_ARG_EXPAND);
#define glBindTransformFeedback_INDEX 148
#define glBindTransformFeedback_RETURN void
#define glBindTransformFeedback_ARG_NAMES target, id
#define glBindTransformFeedback_ARG_EXPAND GLenum target, GLuint id
#define glBindTransformFeedback_PACKED PACKED_glBindTransformFeedback
#define glBindTransformFeedback_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glBindTransformFeedback_NOT_VOID_WRAP(...) {}
#define pack_glBindTransformFeedback(_target, _id) ({ \
    glBindTransformFeedback_PACKED *packed_data = malloc(sizeof(glBindTransformFeedback_PACKED)); \
    packed_data->index = glBindTransformFeedback_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.id = (GLuint)_id; \
    (packed_call_t *)packed_data; \
})
#define call_glBindTransformFeedback(packed, ret_v) do { \
    PACKED_glBindTransformFeedback *unpacked = (PACKED_glBindTransformFeedback *)packed; \
    ARGS_glBindTransformFeedback *args = (ARGS_glBindTransformFeedback *)&unpacked->args; \
    glBindTransformFeedback(args->target, args->id);; \
} while(0)
void glBindTransformFeedback(glBindTransformFeedback_ARG_EXPAND);
typedef void (*glBindTransformFeedback_PTR)(glBindTransformFeedback_ARG_EXPAND);
#define glBindTransformFeedbackNV_INDEX 149
#define glBindTransformFeedbackNV_RETURN void
#define glBindTransformFeedbackNV_ARG_NAMES target, id
#define glBindTransformFeedbackNV_ARG_EXPAND GLenum target, GLuint id
#define glBindTransformFeedbackNV_PACKED PACKED_glBindTransformFeedbackNV
#define glBindTransformFeedbackNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glBindTransformFeedbackNV_NOT_VOID_WRAP(...) {}
#define pack_glBindTransformFeedbackNV(_target, _id) ({ \
    glBindTransformFeedbackNV_PACKED *packed_data = malloc(sizeof(glBindTransformFeedbackNV_PACKED)); \
    packed_data->index = glBindTransformFeedbackNV_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.id = (GLuint)_id; \
    (packed_call_t *)packed_data; \
})
#define call_glBindTransformFeedbackNV(packed, ret_v) do { \
    PACKED_glBindTransformFeedbackNV *unpacked = (PACKED_glBindTransformFeedbackNV *)packed; \
    ARGS_glBindTransformFeedbackNV *args = (ARGS_glBindTransformFeedbackNV *)&unpacked->args; \
    glBindTransformFeedbackNV(args->target, args->id);; \
} while(0)
void glBindTransformFeedbackNV(glBindTransformFeedbackNV_ARG_EXPAND);
typedef void (*glBindTransformFeedbackNV_PTR)(glBindTransformFeedbackNV_ARG_EXPAND);
#define glBindVertexArray_INDEX 150
#define glBindVertexArray_RETURN void
#define glBindVertexArray_ARG_NAMES array
#define glBindVertexArray_ARG_EXPAND GLuint array
#define glBindVertexArray_PACKED PACKED_glBindVertexArray
#define glBindVertexArray_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glBindVertexArray_NOT_VOID_WRAP(...) {}
#define pack_glBindVertexArray(_array) ({ \
    glBindVertexArray_PACKED *packed_data = malloc(sizeof(glBindVertexArray_PACKED)); \
    packed_data->index = glBindVertexArray_INDEX; \
    packed_data->args.array = (GLuint)_array; \
    (packed_call_t *)packed_data; \
})
#define call_glBindVertexArray(packed, ret_v) do { \
    PACKED_glBindVertexArray *unpacked = (PACKED_glBindVertexArray *)packed; \
    ARGS_glBindVertexArray *args = (ARGS_glBindVertexArray *)&unpacked->args; \
    glBindVertexArray(args->array);; \
} while(0)
void glBindVertexArray(glBindVertexArray_ARG_EXPAND);
typedef void (*glBindVertexArray_PTR)(glBindVertexArray_ARG_EXPAND);
#define glBindVertexArrayAPPLE_INDEX 151
#define glBindVertexArrayAPPLE_RETURN void
#define glBindVertexArrayAPPLE_ARG_NAMES array
#define glBindVertexArrayAPPLE_ARG_EXPAND GLuint array
#define glBindVertexArrayAPPLE_PACKED PACKED_glBindVertexArrayAPPLE
#define glBindVertexArrayAPPLE_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glBindVertexArrayAPPLE_NOT_VOID_WRAP(...) {}
#define pack_glBindVertexArrayAPPLE(_array) ({ \
    glBindVertexArrayAPPLE_PACKED *packed_data = malloc(sizeof(glBindVertexArrayAPPLE_PACKED)); \
    packed_data->index = glBindVertexArrayAPPLE_INDEX; \
    packed_data->args.array = (GLuint)_array; \
    (packed_call_t *)packed_data; \
})
#define call_glBindVertexArrayAPPLE(packed, ret_v) do { \
    PACKED_glBindVertexArrayAPPLE *unpacked = (PACKED_glBindVertexArrayAPPLE *)packed; \
    ARGS_glBindVertexArrayAPPLE *args = (ARGS_glBindVertexArrayAPPLE *)&unpacked->args; \
    glBindVertexArrayAPPLE(args->array);; \
} while(0)
void glBindVertexArrayAPPLE(glBindVertexArrayAPPLE_ARG_EXPAND);
typedef void (*glBindVertexArrayAPPLE_PTR)(glBindVertexArrayAPPLE_ARG_EXPAND);
#define glBindVertexBuffer_INDEX 152
#define glBindVertexBuffer_RETURN void
#define glBindVertexBuffer_ARG_NAMES bindingindex, buffer, offset, stride
#define glBindVertexBuffer_ARG_EXPAND GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride
#define glBindVertexBuffer_PACKED PACKED_glBindVertexBuffer
#define glBindVertexBuffer_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glBindVertexBuffer_NOT_VOID_WRAP(...) {}
#define pack_glBindVertexBuffer(_bindingindex, _buffer, _offset, _stride) ({ \
    glBindVertexBuffer_PACKED *packed_data = malloc(sizeof(glBindVertexBuffer_PACKED)); \
    packed_data->index = glBindVertexBuffer_INDEX; \
    packed_data->args.bindingindex = (GLuint)_bindingindex; \
    packed_data->args.buffer = (GLuint)_buffer; \
    packed_data->args.offset = (GLintptr)_offset; \
    packed_data->args.stride = (GLsizei)_stride; \
    (packed_call_t *)packed_data; \
})
#define call_glBindVertexBuffer(packed, ret_v) do { \
    PACKED_glBindVertexBuffer *unpacked = (PACKED_glBindVertexBuffer *)packed; \
    ARGS_glBindVertexBuffer *args = (ARGS_glBindVertexBuffer *)&unpacked->args; \
    glBindVertexBuffer(args->bindingindex, args->buffer, args->offset, args->stride);; \
} while(0)
void glBindVertexBuffer(glBindVertexBuffer_ARG_EXPAND);
typedef void (*glBindVertexBuffer_PTR)(glBindVertexBuffer_ARG_EXPAND);
#define glBindVertexShaderEXT_INDEX 153
#define glBindVertexShaderEXT_RETURN void
#define glBindVertexShaderEXT_ARG_NAMES id
#define glBindVertexShaderEXT_ARG_EXPAND GLuint id
#define glBindVertexShaderEXT_PACKED PACKED_glBindVertexShaderEXT
#define glBindVertexShaderEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glBindVertexShaderEXT_NOT_VOID_WRAP(...) {}
#define pack_glBindVertexShaderEXT(_id) ({ \
    glBindVertexShaderEXT_PACKED *packed_data = malloc(sizeof(glBindVertexShaderEXT_PACKED)); \
    packed_data->index = glBindVertexShaderEXT_INDEX; \
    packed_data->args.id = (GLuint)_id; \
    (packed_call_t *)packed_data; \
})
#define call_glBindVertexShaderEXT(packed, ret_v) do { \
    PACKED_glBindVertexShaderEXT *unpacked = (PACKED_glBindVertexShaderEXT *)packed; \
    ARGS_glBindVertexShaderEXT *args = (ARGS_glBindVertexShaderEXT *)&unpacked->args; \
    glBindVertexShaderEXT(args->id);; \
} while(0)
void glBindVertexShaderEXT(glBindVertexShaderEXT_ARG_EXPAND);
typedef void (*glBindVertexShaderEXT_PTR)(glBindVertexShaderEXT_ARG_EXPAND);
#define glBindVideoCaptureStreamBufferNV_INDEX 154
#define glBindVideoCaptureStreamBufferNV_RETURN void
#define glBindVideoCaptureStreamBufferNV_ARG_NAMES video_capture_slot, stream, frame_region, offset
#define glBindVideoCaptureStreamBufferNV_ARG_EXPAND GLuint video_capture_slot, GLuint stream, GLenum frame_region, GLintptrARB offset
#define glBindVideoCaptureStreamBufferNV_PACKED PACKED_glBindVideoCaptureStreamBufferNV
#define glBindVideoCaptureStreamBufferNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glBindVideoCaptureStreamBufferNV_NOT_VOID_WRAP(...) {}
#define pack_glBindVideoCaptureStreamBufferNV(_video_capture_slot, _stream, _frame_region, _offset) ({ \
    glBindVideoCaptureStreamBufferNV_PACKED *packed_data = malloc(sizeof(glBindVideoCaptureStreamBufferNV_PACKED)); \
    packed_data->index = glBindVideoCaptureStreamBufferNV_INDEX; \
    packed_data->args.video_capture_slot = (GLuint)_video_capture_slot; \
    packed_data->args.stream = (GLuint)_stream; \
    packed_data->args.frame_region = (GLenum)_frame_region; \
    packed_data->args.offset = (GLintptrARB)_offset; \
    (packed_call_t *)packed_data; \
})
#define call_glBindVideoCaptureStreamBufferNV(packed, ret_v) do { \
    PACKED_glBindVideoCaptureStreamBufferNV *unpacked = (PACKED_glBindVideoCaptureStreamBufferNV *)packed; \
    ARGS_glBindVideoCaptureStreamBufferNV *args = (ARGS_glBindVideoCaptureStreamBufferNV *)&unpacked->args; \
    glBindVideoCaptureStreamBufferNV(args->video_capture_slot, args->stream, args->frame_region, args->offset);; \
} while(0)
void glBindVideoCaptureStreamBufferNV(glBindVideoCaptureStreamBufferNV_ARG_EXPAND);
typedef void (*glBindVideoCaptureStreamBufferNV_PTR)(glBindVideoCaptureStreamBufferNV_ARG_EXPAND);
#define glBindVideoCaptureStreamTextureNV_INDEX 155
#define glBindVideoCaptureStreamTextureNV_RETURN void
#define glBindVideoCaptureStreamTextureNV_ARG_NAMES video_capture_slot, stream, frame_region, target, texture
#define glBindVideoCaptureStreamTextureNV_ARG_EXPAND GLuint video_capture_slot, GLuint stream, GLenum frame_region, GLenum target, GLuint texture
#define glBindVideoCaptureStreamTextureNV_PACKED PACKED_glBindVideoCaptureStreamTextureNV
#define glBindVideoCaptureStreamTextureNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glBindVideoCaptureStreamTextureNV_NOT_VOID_WRAP(...) {}
#define pack_glBindVideoCaptureStreamTextureNV(_video_capture_slot, _stream, _frame_region, _target, _texture) ({ \
    glBindVideoCaptureStreamTextureNV_PACKED *packed_data = malloc(sizeof(glBindVideoCaptureStreamTextureNV_PACKED)); \
    packed_data->index = glBindVideoCaptureStreamTextureNV_INDEX; \
    packed_data->args.video_capture_slot = (GLuint)_video_capture_slot; \
    packed_data->args.stream = (GLuint)_stream; \
    packed_data->args.frame_region = (GLenum)_frame_region; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.texture = (GLuint)_texture; \
    (packed_call_t *)packed_data; \
})
#define call_glBindVideoCaptureStreamTextureNV(packed, ret_v) do { \
    PACKED_glBindVideoCaptureStreamTextureNV *unpacked = (PACKED_glBindVideoCaptureStreamTextureNV *)packed; \
    ARGS_glBindVideoCaptureStreamTextureNV *args = (ARGS_glBindVideoCaptureStreamTextureNV *)&unpacked->args; \
    glBindVideoCaptureStreamTextureNV(args->video_capture_slot, args->stream, args->frame_region, args->target, args->texture);; \
} while(0)
void glBindVideoCaptureStreamTextureNV(glBindVideoCaptureStreamTextureNV_ARG_EXPAND);
typedef void (*glBindVideoCaptureStreamTextureNV_PTR)(glBindVideoCaptureStreamTextureNV_ARG_EXPAND);
#define glBinormal3bEXT_INDEX 156
#define glBinormal3bEXT_RETURN void
#define glBinormal3bEXT_ARG_NAMES bx, by, bz
#define glBinormal3bEXT_ARG_EXPAND GLbyte bx, GLbyte by, GLbyte bz
#define glBinormal3bEXT_PACKED PACKED_glBinormal3bEXT
#define glBinormal3bEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glBinormal3bEXT_NOT_VOID_WRAP(...) {}
#define pack_glBinormal3bEXT(_bx, _by, _bz) ({ \
    glBinormal3bEXT_PACKED *packed_data = malloc(sizeof(glBinormal3bEXT_PACKED)); \
    packed_data->index = glBinormal3bEXT_INDEX; \
    packed_data->args.bx = (GLbyte)_bx; \
    packed_data->args.by = (GLbyte)_by; \
    packed_data->args.bz = (GLbyte)_bz; \
    (packed_call_t *)packed_data; \
})
#define call_glBinormal3bEXT(packed, ret_v) do { \
    PACKED_glBinormal3bEXT *unpacked = (PACKED_glBinormal3bEXT *)packed; \
    ARGS_glBinormal3bEXT *args = (ARGS_glBinormal3bEXT *)&unpacked->args; \
    glBinormal3bEXT(args->bx, args->by, args->bz);; \
} while(0)
void glBinormal3bEXT(glBinormal3bEXT_ARG_EXPAND);
typedef void (*glBinormal3bEXT_PTR)(glBinormal3bEXT_ARG_EXPAND);
#define glBinormal3bvEXT_INDEX 157
#define glBinormal3bvEXT_RETURN void
#define glBinormal3bvEXT_ARG_NAMES v
#define glBinormal3bvEXT_ARG_EXPAND const GLbyte * v
#define glBinormal3bvEXT_PACKED PACKED_glBinormal3bvEXT
#define glBinormal3bvEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glBinormal3bvEXT_NOT_VOID_WRAP(...) {}
#define pack_glBinormal3bvEXT(_v) ({ \
    glBinormal3bvEXT_PACKED *packed_data = malloc(sizeof(glBinormal3bvEXT_PACKED)); \
    packed_data->index = glBinormal3bvEXT_INDEX; \
    packed_data->args.v = (GLbyte *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glBinormal3bvEXT(packed, ret_v) do { \
    PACKED_glBinormal3bvEXT *unpacked = (PACKED_glBinormal3bvEXT *)packed; \
    ARGS_glBinormal3bvEXT *args = (ARGS_glBinormal3bvEXT *)&unpacked->args; \
    glBinormal3bvEXT(args->v);; \
} while(0)
void glBinormal3bvEXT(glBinormal3bvEXT_ARG_EXPAND);
typedef void (*glBinormal3bvEXT_PTR)(glBinormal3bvEXT_ARG_EXPAND);
#define glBinormal3dEXT_INDEX 158
#define glBinormal3dEXT_RETURN void
#define glBinormal3dEXT_ARG_NAMES bx, by, bz
#define glBinormal3dEXT_ARG_EXPAND GLdouble bx, GLdouble by, GLdouble bz
#define glBinormal3dEXT_PACKED PACKED_glBinormal3dEXT
#define glBinormal3dEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glBinormal3dEXT_NOT_VOID_WRAP(...) {}
#define pack_glBinormal3dEXT(_bx, _by, _bz) ({ \
    glBinormal3dEXT_PACKED *packed_data = malloc(sizeof(glBinormal3dEXT_PACKED)); \
    packed_data->index = glBinormal3dEXT_INDEX; \
    packed_data->args.bx = (GLdouble)_bx; \
    packed_data->args.by = (GLdouble)_by; \
    packed_data->args.bz = (GLdouble)_bz; \
    (packed_call_t *)packed_data; \
})
#define call_glBinormal3dEXT(packed, ret_v) do { \
    PACKED_glBinormal3dEXT *unpacked = (PACKED_glBinormal3dEXT *)packed; \
    ARGS_glBinormal3dEXT *args = (ARGS_glBinormal3dEXT *)&unpacked->args; \
    glBinormal3dEXT(args->bx, args->by, args->bz);; \
} while(0)
void glBinormal3dEXT(glBinormal3dEXT_ARG_EXPAND);
typedef void (*glBinormal3dEXT_PTR)(glBinormal3dEXT_ARG_EXPAND);
#define glBinormal3dvEXT_INDEX 159
#define glBinormal3dvEXT_RETURN void
#define glBinormal3dvEXT_ARG_NAMES v
#define glBinormal3dvEXT_ARG_EXPAND const GLdouble * v
#define glBinormal3dvEXT_PACKED PACKED_glBinormal3dvEXT
#define glBinormal3dvEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glBinormal3dvEXT_NOT_VOID_WRAP(...) {}
#define pack_glBinormal3dvEXT(_v) ({ \
    glBinormal3dvEXT_PACKED *packed_data = malloc(sizeof(glBinormal3dvEXT_PACKED)); \
    packed_data->index = glBinormal3dvEXT_INDEX; \
    packed_data->args.v = (GLdouble *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glBinormal3dvEXT(packed, ret_v) do { \
    PACKED_glBinormal3dvEXT *unpacked = (PACKED_glBinormal3dvEXT *)packed; \
    ARGS_glBinormal3dvEXT *args = (ARGS_glBinormal3dvEXT *)&unpacked->args; \
    glBinormal3dvEXT(args->v);; \
} while(0)
void glBinormal3dvEXT(glBinormal3dvEXT_ARG_EXPAND);
typedef void (*glBinormal3dvEXT_PTR)(glBinormal3dvEXT_ARG_EXPAND);
#define glBinormal3fEXT_INDEX 160
#define glBinormal3fEXT_RETURN void
#define glBinormal3fEXT_ARG_NAMES bx, by, bz
#define glBinormal3fEXT_ARG_EXPAND GLfloat bx, GLfloat by, GLfloat bz
#define glBinormal3fEXT_PACKED PACKED_glBinormal3fEXT
#define glBinormal3fEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glBinormal3fEXT_NOT_VOID_WRAP(...) {}
#define pack_glBinormal3fEXT(_bx, _by, _bz) ({ \
    glBinormal3fEXT_PACKED *packed_data = malloc(sizeof(glBinormal3fEXT_PACKED)); \
    packed_data->index = glBinormal3fEXT_INDEX; \
    packed_data->args.bx = (GLfloat)_bx; \
    packed_data->args.by = (GLfloat)_by; \
    packed_data->args.bz = (GLfloat)_bz; \
    (packed_call_t *)packed_data; \
})
#define call_glBinormal3fEXT(packed, ret_v) do { \
    PACKED_glBinormal3fEXT *unpacked = (PACKED_glBinormal3fEXT *)packed; \
    ARGS_glBinormal3fEXT *args = (ARGS_glBinormal3fEXT *)&unpacked->args; \
    glBinormal3fEXT(args->bx, args->by, args->bz);; \
} while(0)
void glBinormal3fEXT(glBinormal3fEXT_ARG_EXPAND);
typedef void (*glBinormal3fEXT_PTR)(glBinormal3fEXT_ARG_EXPAND);
#define glBinormal3fvEXT_INDEX 161
#define glBinormal3fvEXT_RETURN void
#define glBinormal3fvEXT_ARG_NAMES v
#define glBinormal3fvEXT_ARG_EXPAND const GLfloat * v
#define glBinormal3fvEXT_PACKED PACKED_glBinormal3fvEXT
#define glBinormal3fvEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glBinormal3fvEXT_NOT_VOID_WRAP(...) {}
#define pack_glBinormal3fvEXT(_v) ({ \
    glBinormal3fvEXT_PACKED *packed_data = malloc(sizeof(glBinormal3fvEXT_PACKED)); \
    packed_data->index = glBinormal3fvEXT_INDEX; \
    packed_data->args.v = (GLfloat *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glBinormal3fvEXT(packed, ret_v) do { \
    PACKED_glBinormal3fvEXT *unpacked = (PACKED_glBinormal3fvEXT *)packed; \
    ARGS_glBinormal3fvEXT *args = (ARGS_glBinormal3fvEXT *)&unpacked->args; \
    glBinormal3fvEXT(args->v);; \
} while(0)
void glBinormal3fvEXT(glBinormal3fvEXT_ARG_EXPAND);
typedef void (*glBinormal3fvEXT_PTR)(glBinormal3fvEXT_ARG_EXPAND);
#define glBinormal3iEXT_INDEX 162
#define glBinormal3iEXT_RETURN void
#define glBinormal3iEXT_ARG_NAMES bx, by, bz
#define glBinormal3iEXT_ARG_EXPAND GLint bx, GLint by, GLint bz
#define glBinormal3iEXT_PACKED PACKED_glBinormal3iEXT
#define glBinormal3iEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glBinormal3iEXT_NOT_VOID_WRAP(...) {}
#define pack_glBinormal3iEXT(_bx, _by, _bz) ({ \
    glBinormal3iEXT_PACKED *packed_data = malloc(sizeof(glBinormal3iEXT_PACKED)); \
    packed_data->index = glBinormal3iEXT_INDEX; \
    packed_data->args.bx = (GLint)_bx; \
    packed_data->args.by = (GLint)_by; \
    packed_data->args.bz = (GLint)_bz; \
    (packed_call_t *)packed_data; \
})
#define call_glBinormal3iEXT(packed, ret_v) do { \
    PACKED_glBinormal3iEXT *unpacked = (PACKED_glBinormal3iEXT *)packed; \
    ARGS_glBinormal3iEXT *args = (ARGS_glBinormal3iEXT *)&unpacked->args; \
    glBinormal3iEXT(args->bx, args->by, args->bz);; \
} while(0)
void glBinormal3iEXT(glBinormal3iEXT_ARG_EXPAND);
typedef void (*glBinormal3iEXT_PTR)(glBinormal3iEXT_ARG_EXPAND);
#define glBinormal3ivEXT_INDEX 163
#define glBinormal3ivEXT_RETURN void
#define glBinormal3ivEXT_ARG_NAMES v
#define glBinormal3ivEXT_ARG_EXPAND const GLint * v
#define glBinormal3ivEXT_PACKED PACKED_glBinormal3ivEXT
#define glBinormal3ivEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glBinormal3ivEXT_NOT_VOID_WRAP(...) {}
#define pack_glBinormal3ivEXT(_v) ({ \
    glBinormal3ivEXT_PACKED *packed_data = malloc(sizeof(glBinormal3ivEXT_PACKED)); \
    packed_data->index = glBinormal3ivEXT_INDEX; \
    packed_data->args.v = (GLint *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glBinormal3ivEXT(packed, ret_v) do { \
    PACKED_glBinormal3ivEXT *unpacked = (PACKED_glBinormal3ivEXT *)packed; \
    ARGS_glBinormal3ivEXT *args = (ARGS_glBinormal3ivEXT *)&unpacked->args; \
    glBinormal3ivEXT(args->v);; \
} while(0)
void glBinormal3ivEXT(glBinormal3ivEXT_ARG_EXPAND);
typedef void (*glBinormal3ivEXT_PTR)(glBinormal3ivEXT_ARG_EXPAND);
#define glBinormal3sEXT_INDEX 164
#define glBinormal3sEXT_RETURN void
#define glBinormal3sEXT_ARG_NAMES bx, by, bz
#define glBinormal3sEXT_ARG_EXPAND GLshort bx, GLshort by, GLshort bz
#define glBinormal3sEXT_PACKED PACKED_glBinormal3sEXT
#define glBinormal3sEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glBinormal3sEXT_NOT_VOID_WRAP(...) {}
#define pack_glBinormal3sEXT(_bx, _by, _bz) ({ \
    glBinormal3sEXT_PACKED *packed_data = malloc(sizeof(glBinormal3sEXT_PACKED)); \
    packed_data->index = glBinormal3sEXT_INDEX; \
    packed_data->args.bx = (GLshort)_bx; \
    packed_data->args.by = (GLshort)_by; \
    packed_data->args.bz = (GLshort)_bz; \
    (packed_call_t *)packed_data; \
})
#define call_glBinormal3sEXT(packed, ret_v) do { \
    PACKED_glBinormal3sEXT *unpacked = (PACKED_glBinormal3sEXT *)packed; \
    ARGS_glBinormal3sEXT *args = (ARGS_glBinormal3sEXT *)&unpacked->args; \
    glBinormal3sEXT(args->bx, args->by, args->bz);; \
} while(0)
void glBinormal3sEXT(glBinormal3sEXT_ARG_EXPAND);
typedef void (*glBinormal3sEXT_PTR)(glBinormal3sEXT_ARG_EXPAND);
#define glBinormal3svEXT_INDEX 165
#define glBinormal3svEXT_RETURN void
#define glBinormal3svEXT_ARG_NAMES v
#define glBinormal3svEXT_ARG_EXPAND const GLshort * v
#define glBinormal3svEXT_PACKED PACKED_glBinormal3svEXT
#define glBinormal3svEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glBinormal3svEXT_NOT_VOID_WRAP(...) {}
#define pack_glBinormal3svEXT(_v) ({ \
    glBinormal3svEXT_PACKED *packed_data = malloc(sizeof(glBinormal3svEXT_PACKED)); \
    packed_data->index = glBinormal3svEXT_INDEX; \
    packed_data->args.v = (GLshort *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glBinormal3svEXT(packed, ret_v) do { \
    PACKED_glBinormal3svEXT *unpacked = (PACKED_glBinormal3svEXT *)packed; \
    ARGS_glBinormal3svEXT *args = (ARGS_glBinormal3svEXT *)&unpacked->args; \
    glBinormal3svEXT(args->v);; \
} while(0)
void glBinormal3svEXT(glBinormal3svEXT_ARG_EXPAND);
typedef void (*glBinormal3svEXT_PTR)(glBinormal3svEXT_ARG_EXPAND);
#define glBinormalPointerEXT_INDEX 166
#define glBinormalPointerEXT_RETURN void
#define glBinormalPointerEXT_ARG_NAMES type, stride, pointer
#define glBinormalPointerEXT_ARG_EXPAND GLenum type, GLsizei stride, const GLvoid * pointer
#define glBinormalPointerEXT_PACKED PACKED_glBinormalPointerEXT
#define glBinormalPointerEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glBinormalPointerEXT_NOT_VOID_WRAP(...) {}
#define pack_glBinormalPointerEXT(_type, _stride, _pointer) ({ \
    glBinormalPointerEXT_PACKED *packed_data = malloc(sizeof(glBinormalPointerEXT_PACKED)); \
    packed_data->index = glBinormalPointerEXT_INDEX; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.stride = (GLsizei)_stride; \
    packed_data->args.pointer = (GLvoid *)_pointer; \
    (packed_call_t *)packed_data; \
})
#define call_glBinormalPointerEXT(packed, ret_v) do { \
    PACKED_glBinormalPointerEXT *unpacked = (PACKED_glBinormalPointerEXT *)packed; \
    ARGS_glBinormalPointerEXT *args = (ARGS_glBinormalPointerEXT *)&unpacked->args; \
    glBinormalPointerEXT(args->type, args->stride, args->pointer);; \
} while(0)
void glBinormalPointerEXT(glBinormalPointerEXT_ARG_EXPAND);
typedef void (*glBinormalPointerEXT_PTR)(glBinormalPointerEXT_ARG_EXPAND);
#define glBitmap_INDEX 167
#define glBitmap_RETURN void
#define glBitmap_ARG_NAMES width, height, xorig, yorig, xmove, ymove, bitmap
#define glBitmap_ARG_EXPAND GLsizei width, GLsizei height, GLfloat xorig, GLfloat yorig, GLfloat xmove, GLfloat ymove, const GLubyte * bitmap
#define glBitmap_PACKED PACKED_glBitmap
#define glBitmap_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glBitmap_NOT_VOID_WRAP(...) {}
#define pack_glBitmap(_width, _height, _xorig, _yorig, _xmove, _ymove, _bitmap) ({ \
    glBitmap_PACKED *packed_data = malloc(sizeof(glBitmap_PACKED)); \
    packed_data->index = glBitmap_INDEX; \
    packed_data->args.width = (GLsizei)_width; \
    packed_data->args.height = (GLsizei)_height; \
    packed_data->args.xorig = (GLfloat)_xorig; \
    packed_data->args.yorig = (GLfloat)_yorig; \
    packed_data->args.xmove = (GLfloat)_xmove; \
    packed_data->args.ymove = (GLfloat)_ymove; \
    packed_data->args.bitmap = (GLubyte *)_bitmap; \
    (packed_call_t *)packed_data; \
})
#define call_glBitmap(packed, ret_v) do { \
    PACKED_glBitmap *unpacked = (PACKED_glBitmap *)packed; \
    ARGS_glBitmap *args = (ARGS_glBitmap *)&unpacked->args; \
    glBitmap(args->width, args->height, args->xorig, args->yorig, args->xmove, args->ymove, args->bitmap);; \
} while(0)
void glBitmap(glBitmap_ARG_EXPAND);
typedef void (*glBitmap_PTR)(glBitmap_ARG_EXPAND);
#define glBitmapxOES_INDEX 168
#define glBitmapxOES_RETURN void
#define glBitmapxOES_ARG_NAMES width, height, xorig, yorig, xmove, ymove, bitmap
#define glBitmapxOES_ARG_EXPAND GLsizei width, GLsizei height, GLfixed xorig, GLfixed yorig, GLfixed xmove, GLfixed ymove, const GLubyte * bitmap
#define glBitmapxOES_PACKED PACKED_glBitmapxOES
#define glBitmapxOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glBitmapxOES_NOT_VOID_WRAP(...) {}
#define pack_glBitmapxOES(_width, _height, _xorig, _yorig, _xmove, _ymove, _bitmap) ({ \
    glBitmapxOES_PACKED *packed_data = malloc(sizeof(glBitmapxOES_PACKED)); \
    packed_data->index = glBitmapxOES_INDEX; \
    packed_data->args.width = (GLsizei)_width; \
    packed_data->args.height = (GLsizei)_height; \
    packed_data->args.xorig = (GLfixed)_xorig; \
    packed_data->args.yorig = (GLfixed)_yorig; \
    packed_data->args.xmove = (GLfixed)_xmove; \
    packed_data->args.ymove = (GLfixed)_ymove; \
    packed_data->args.bitmap = (GLubyte *)_bitmap; \
    (packed_call_t *)packed_data; \
})
#define call_glBitmapxOES(packed, ret_v) do { \
    PACKED_glBitmapxOES *unpacked = (PACKED_glBitmapxOES *)packed; \
    ARGS_glBitmapxOES *args = (ARGS_glBitmapxOES *)&unpacked->args; \
    glBitmapxOES(args->width, args->height, args->xorig, args->yorig, args->xmove, args->ymove, args->bitmap);; \
} while(0)
void glBitmapxOES(glBitmapxOES_ARG_EXPAND);
typedef void (*glBitmapxOES_PTR)(glBitmapxOES_ARG_EXPAND);
#define glBlendColor_INDEX 169
#define glBlendColor_RETURN void
#define glBlendColor_ARG_NAMES red, green, blue, alpha
#define glBlendColor_ARG_EXPAND GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha
#define glBlendColor_PACKED PACKED_glBlendColor
#define glBlendColor_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glBlendColor_NOT_VOID_WRAP(...) {}
#define pack_glBlendColor(_red, _green, _blue, _alpha) ({ \
    glBlendColor_PACKED *packed_data = malloc(sizeof(glBlendColor_PACKED)); \
    packed_data->index = glBlendColor_INDEX; \
    packed_data->args.red = (GLclampf)_red; \
    packed_data->args.green = (GLclampf)_green; \
    packed_data->args.blue = (GLclampf)_blue; \
    packed_data->args.alpha = (GLclampf)_alpha; \
    (packed_call_t *)packed_data; \
})
#define call_glBlendColor(packed, ret_v) do { \
    PACKED_glBlendColor *unpacked = (PACKED_glBlendColor *)packed; \
    ARGS_glBlendColor *args = (ARGS_glBlendColor *)&unpacked->args; \
    glBlendColor(args->red, args->green, args->blue, args->alpha);; \
} while(0)
void glBlendColor(glBlendColor_ARG_EXPAND);
typedef void (*glBlendColor_PTR)(glBlendColor_ARG_EXPAND);
#define glBlendColorEXT_INDEX 170
#define glBlendColorEXT_RETURN void
#define glBlendColorEXT_ARG_NAMES red, green, blue, alpha
#define glBlendColorEXT_ARG_EXPAND GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha
#define glBlendColorEXT_PACKED PACKED_glBlendColorEXT
#define glBlendColorEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glBlendColorEXT_NOT_VOID_WRAP(...) {}
#define pack_glBlendColorEXT(_red, _green, _blue, _alpha) ({ \
    glBlendColorEXT_PACKED *packed_data = malloc(sizeof(glBlendColorEXT_PACKED)); \
    packed_data->index = glBlendColorEXT_INDEX; \
    packed_data->args.red = (GLfloat)_red; \
    packed_data->args.green = (GLfloat)_green; \
    packed_data->args.blue = (GLfloat)_blue; \
    packed_data->args.alpha = (GLfloat)_alpha; \
    (packed_call_t *)packed_data; \
})
#define call_glBlendColorEXT(packed, ret_v) do { \
    PACKED_glBlendColorEXT *unpacked = (PACKED_glBlendColorEXT *)packed; \
    ARGS_glBlendColorEXT *args = (ARGS_glBlendColorEXT *)&unpacked->args; \
    glBlendColorEXT(args->red, args->green, args->blue, args->alpha);; \
} while(0)
void glBlendColorEXT(glBlendColorEXT_ARG_EXPAND);
typedef void (*glBlendColorEXT_PTR)(glBlendColorEXT_ARG_EXPAND);
#define glBlendColorOES_INDEX 171
#define glBlendColorOES_RETURN void
#define glBlendColorOES_ARG_NAMES red, green, blue, alpha
#define glBlendColorOES_ARG_EXPAND GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha
#define glBlendColorOES_PACKED PACKED_glBlendColorOES
#define glBlendColorOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glBlendColorOES_NOT_VOID_WRAP(...) {}
#define pack_glBlendColorOES(_red, _green, _blue, _alpha) ({ \
    glBlendColorOES_PACKED *packed_data = malloc(sizeof(glBlendColorOES_PACKED)); \
    packed_data->index = glBlendColorOES_INDEX; \
    packed_data->args.red = (GLclampf)_red; \
    packed_data->args.green = (GLclampf)_green; \
    packed_data->args.blue = (GLclampf)_blue; \
    packed_data->args.alpha = (GLclampf)_alpha; \
    (packed_call_t *)packed_data; \
})
#define call_glBlendColorOES(packed, ret_v) do { \
    PACKED_glBlendColorOES *unpacked = (PACKED_glBlendColorOES *)packed; \
    ARGS_glBlendColorOES *args = (ARGS_glBlendColorOES *)&unpacked->args; \
    glBlendColorOES(args->red, args->green, args->blue, args->alpha);; \
} while(0)
void glBlendColorOES(glBlendColorOES_ARG_EXPAND);
typedef void (*glBlendColorOES_PTR)(glBlendColorOES_ARG_EXPAND);
#define glBlendColorxOES_INDEX 172
#define glBlendColorxOES_RETURN void
#define glBlendColorxOES_ARG_NAMES red, green, blue, alpha
#define glBlendColorxOES_ARG_EXPAND GLfixed red, GLfixed green, GLfixed blue, GLfixed alpha
#define glBlendColorxOES_PACKED PACKED_glBlendColorxOES
#define glBlendColorxOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glBlendColorxOES_NOT_VOID_WRAP(...) {}
#define pack_glBlendColorxOES(_red, _green, _blue, _alpha) ({ \
    glBlendColorxOES_PACKED *packed_data = malloc(sizeof(glBlendColorxOES_PACKED)); \
    packed_data->index = glBlendColorxOES_INDEX; \
    packed_data->args.red = (GLfixed)_red; \
    packed_data->args.green = (GLfixed)_green; \
    packed_data->args.blue = (GLfixed)_blue; \
    packed_data->args.alpha = (GLfixed)_alpha; \
    (packed_call_t *)packed_data; \
})
#define call_glBlendColorxOES(packed, ret_v) do { \
    PACKED_glBlendColorxOES *unpacked = (PACKED_glBlendColorxOES *)packed; \
    ARGS_glBlendColorxOES *args = (ARGS_glBlendColorxOES *)&unpacked->args; \
    glBlendColorxOES(args->red, args->green, args->blue, args->alpha);; \
} while(0)
void glBlendColorxOES(glBlendColorxOES_ARG_EXPAND);
typedef void (*glBlendColorxOES_PTR)(glBlendColorxOES_ARG_EXPAND);
#define glBlendEquation_INDEX 173
#define glBlendEquation_RETURN void
#define glBlendEquation_ARG_NAMES mode
#define glBlendEquation_ARG_EXPAND GLenum mode
#define glBlendEquation_PACKED PACKED_glBlendEquation
#define glBlendEquation_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glBlendEquation_NOT_VOID_WRAP(...) {}
#define pack_glBlendEquation(_mode) ({ \
    glBlendEquation_PACKED *packed_data = malloc(sizeof(glBlendEquation_PACKED)); \
    packed_data->index = glBlendEquation_INDEX; \
    packed_data->args.mode = (GLenum)_mode; \
    (packed_call_t *)packed_data; \
})
#define call_glBlendEquation(packed, ret_v) do { \
    PACKED_glBlendEquation *unpacked = (PACKED_glBlendEquation *)packed; \
    ARGS_glBlendEquation *args = (ARGS_glBlendEquation *)&unpacked->args; \
    glBlendEquation(args->mode);; \
} while(0)
void glBlendEquation(glBlendEquation_ARG_EXPAND);
typedef void (*glBlendEquation_PTR)(glBlendEquation_ARG_EXPAND);
#define glBlendEquationEXT_INDEX 174
#define glBlendEquationEXT_RETURN void
#define glBlendEquationEXT_ARG_NAMES mode
#define glBlendEquationEXT_ARG_EXPAND GLenum mode
#define glBlendEquationEXT_PACKED PACKED_glBlendEquationEXT
#define glBlendEquationEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glBlendEquationEXT_NOT_VOID_WRAP(...) {}
#define pack_glBlendEquationEXT(_mode) ({ \
    glBlendEquationEXT_PACKED *packed_data = malloc(sizeof(glBlendEquationEXT_PACKED)); \
    packed_data->index = glBlendEquationEXT_INDEX; \
    packed_data->args.mode = (GLenum)_mode; \
    (packed_call_t *)packed_data; \
})
#define call_glBlendEquationEXT(packed, ret_v) do { \
    PACKED_glBlendEquationEXT *unpacked = (PACKED_glBlendEquationEXT *)packed; \
    ARGS_glBlendEquationEXT *args = (ARGS_glBlendEquationEXT *)&unpacked->args; \
    glBlendEquationEXT(args->mode);; \
} while(0)
void glBlendEquationEXT(glBlendEquationEXT_ARG_EXPAND);
typedef void (*glBlendEquationEXT_PTR)(glBlendEquationEXT_ARG_EXPAND);
#define glBlendEquationIndexedAMD_INDEX 175
#define glBlendEquationIndexedAMD_RETURN void
#define glBlendEquationIndexedAMD_ARG_NAMES buf, mode
#define glBlendEquationIndexedAMD_ARG_EXPAND GLuint buf, GLenum mode
#define glBlendEquationIndexedAMD_PACKED PACKED_glBlendEquationIndexedAMD
#define glBlendEquationIndexedAMD_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glBlendEquationIndexedAMD_NOT_VOID_WRAP(...) {}
#define pack_glBlendEquationIndexedAMD(_buf, _mode) ({ \
    glBlendEquationIndexedAMD_PACKED *packed_data = malloc(sizeof(glBlendEquationIndexedAMD_PACKED)); \
    packed_data->index = glBlendEquationIndexedAMD_INDEX; \
    packed_data->args.buf = (GLuint)_buf; \
    packed_data->args.mode = (GLenum)_mode; \
    (packed_call_t *)packed_data; \
})
#define call_glBlendEquationIndexedAMD(packed, ret_v) do { \
    PACKED_glBlendEquationIndexedAMD *unpacked = (PACKED_glBlendEquationIndexedAMD *)packed; \
    ARGS_glBlendEquationIndexedAMD *args = (ARGS_glBlendEquationIndexedAMD *)&unpacked->args; \
    glBlendEquationIndexedAMD(args->buf, args->mode);; \
} while(0)
void glBlendEquationIndexedAMD(glBlendEquationIndexedAMD_ARG_EXPAND);
typedef void (*glBlendEquationIndexedAMD_PTR)(glBlendEquationIndexedAMD_ARG_EXPAND);
#define glBlendEquationOES_INDEX 176
#define glBlendEquationOES_RETURN void
#define glBlendEquationOES_ARG_NAMES mode
#define glBlendEquationOES_ARG_EXPAND GLenum mode
#define glBlendEquationOES_PACKED PACKED_glBlendEquationOES
#define glBlendEquationOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glBlendEquationOES_NOT_VOID_WRAP(...) {}
#define pack_glBlendEquationOES(_mode) ({ \
    glBlendEquationOES_PACKED *packed_data = malloc(sizeof(glBlendEquationOES_PACKED)); \
    packed_data->index = glBlendEquationOES_INDEX; \
    packed_data->args.mode = (GLenum)_mode; \
    (packed_call_t *)packed_data; \
})
#define call_glBlendEquationOES(packed, ret_v) do { \
    PACKED_glBlendEquationOES *unpacked = (PACKED_glBlendEquationOES *)packed; \
    ARGS_glBlendEquationOES *args = (ARGS_glBlendEquationOES *)&unpacked->args; \
    glBlendEquationOES(args->mode);; \
} while(0)
void glBlendEquationOES(glBlendEquationOES_ARG_EXPAND);
typedef void (*glBlendEquationOES_PTR)(glBlendEquationOES_ARG_EXPAND);
#define glBlendEquationSeparate_INDEX 177
#define glBlendEquationSeparate_RETURN void
#define glBlendEquationSeparate_ARG_NAMES modeRGB, modeAlpha
#define glBlendEquationSeparate_ARG_EXPAND GLenum modeRGB, GLenum modeAlpha
#define glBlendEquationSeparate_PACKED PACKED_glBlendEquationSeparate
#define glBlendEquationSeparate_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glBlendEquationSeparate_NOT_VOID_WRAP(...) {}
#define pack_glBlendEquationSeparate(_modeRGB, _modeAlpha) ({ \
    glBlendEquationSeparate_PACKED *packed_data = malloc(sizeof(glBlendEquationSeparate_PACKED)); \
    packed_data->index = glBlendEquationSeparate_INDEX; \
    packed_data->args.modeRGB = (GLenum)_modeRGB; \
    packed_data->args.modeAlpha = (GLenum)_modeAlpha; \
    (packed_call_t *)packed_data; \
})
#define call_glBlendEquationSeparate(packed, ret_v) do { \
    PACKED_glBlendEquationSeparate *unpacked = (PACKED_glBlendEquationSeparate *)packed; \
    ARGS_glBlendEquationSeparate *args = (ARGS_glBlendEquationSeparate *)&unpacked->args; \
    glBlendEquationSeparate(args->modeRGB, args->modeAlpha);; \
} while(0)
void glBlendEquationSeparate(glBlendEquationSeparate_ARG_EXPAND);
typedef void (*glBlendEquationSeparate_PTR)(glBlendEquationSeparate_ARG_EXPAND);
#define glBlendEquationSeparateEXT_INDEX 178
#define glBlendEquationSeparateEXT_RETURN void
#define glBlendEquationSeparateEXT_ARG_NAMES modeRGB, modeAlpha
#define glBlendEquationSeparateEXT_ARG_EXPAND GLenum modeRGB, GLenum modeAlpha
#define glBlendEquationSeparateEXT_PACKED PACKED_glBlendEquationSeparateEXT
#define glBlendEquationSeparateEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glBlendEquationSeparateEXT_NOT_VOID_WRAP(...) {}
#define pack_glBlendEquationSeparateEXT(_modeRGB, _modeAlpha) ({ \
    glBlendEquationSeparateEXT_PACKED *packed_data = malloc(sizeof(glBlendEquationSeparateEXT_PACKED)); \
    packed_data->index = glBlendEquationSeparateEXT_INDEX; \
    packed_data->args.modeRGB = (GLenum)_modeRGB; \
    packed_data->args.modeAlpha = (GLenum)_modeAlpha; \
    (packed_call_t *)packed_data; \
})
#define call_glBlendEquationSeparateEXT(packed, ret_v) do { \
    PACKED_glBlendEquationSeparateEXT *unpacked = (PACKED_glBlendEquationSeparateEXT *)packed; \
    ARGS_glBlendEquationSeparateEXT *args = (ARGS_glBlendEquationSeparateEXT *)&unpacked->args; \
    glBlendEquationSeparateEXT(args->modeRGB, args->modeAlpha);; \
} while(0)
void glBlendEquationSeparateEXT(glBlendEquationSeparateEXT_ARG_EXPAND);
typedef void (*glBlendEquationSeparateEXT_PTR)(glBlendEquationSeparateEXT_ARG_EXPAND);
#define glBlendEquationSeparateIndexedAMD_INDEX 179
#define glBlendEquationSeparateIndexedAMD_RETURN void
#define glBlendEquationSeparateIndexedAMD_ARG_NAMES buf, modeRGB, modeAlpha
#define glBlendEquationSeparateIndexedAMD_ARG_EXPAND GLuint buf, GLenum modeRGB, GLenum modeAlpha
#define glBlendEquationSeparateIndexedAMD_PACKED PACKED_glBlendEquationSeparateIndexedAMD
#define glBlendEquationSeparateIndexedAMD_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glBlendEquationSeparateIndexedAMD_NOT_VOID_WRAP(...) {}
#define pack_glBlendEquationSeparateIndexedAMD(_buf, _modeRGB, _modeAlpha) ({ \
    glBlendEquationSeparateIndexedAMD_PACKED *packed_data = malloc(sizeof(glBlendEquationSeparateIndexedAMD_PACKED)); \
    packed_data->index = glBlendEquationSeparateIndexedAMD_INDEX; \
    packed_data->args.buf = (GLuint)_buf; \
    packed_data->args.modeRGB = (GLenum)_modeRGB; \
    packed_data->args.modeAlpha = (GLenum)_modeAlpha; \
    (packed_call_t *)packed_data; \
})
#define call_glBlendEquationSeparateIndexedAMD(packed, ret_v) do { \
    PACKED_glBlendEquationSeparateIndexedAMD *unpacked = (PACKED_glBlendEquationSeparateIndexedAMD *)packed; \
    ARGS_glBlendEquationSeparateIndexedAMD *args = (ARGS_glBlendEquationSeparateIndexedAMD *)&unpacked->args; \
    glBlendEquationSeparateIndexedAMD(args->buf, args->modeRGB, args->modeAlpha);; \
} while(0)
void glBlendEquationSeparateIndexedAMD(glBlendEquationSeparateIndexedAMD_ARG_EXPAND);
typedef void (*glBlendEquationSeparateIndexedAMD_PTR)(glBlendEquationSeparateIndexedAMD_ARG_EXPAND);
#define glBlendEquationSeparateOES_INDEX 180
#define glBlendEquationSeparateOES_RETURN void
#define glBlendEquationSeparateOES_ARG_NAMES modeRGB, modeAlpha
#define glBlendEquationSeparateOES_ARG_EXPAND GLenum modeRGB, GLenum modeAlpha
#define glBlendEquationSeparateOES_PACKED PACKED_glBlendEquationSeparateOES
#define glBlendEquationSeparateOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glBlendEquationSeparateOES_NOT_VOID_WRAP(...) {}
#define pack_glBlendEquationSeparateOES(_modeRGB, _modeAlpha) ({ \
    glBlendEquationSeparateOES_PACKED *packed_data = malloc(sizeof(glBlendEquationSeparateOES_PACKED)); \
    packed_data->index = glBlendEquationSeparateOES_INDEX; \
    packed_data->args.modeRGB = (GLenum)_modeRGB; \
    packed_data->args.modeAlpha = (GLenum)_modeAlpha; \
    (packed_call_t *)packed_data; \
})
#define call_glBlendEquationSeparateOES(packed, ret_v) do { \
    PACKED_glBlendEquationSeparateOES *unpacked = (PACKED_glBlendEquationSeparateOES *)packed; \
    ARGS_glBlendEquationSeparateOES *args = (ARGS_glBlendEquationSeparateOES *)&unpacked->args; \
    glBlendEquationSeparateOES(args->modeRGB, args->modeAlpha);; \
} while(0)
void glBlendEquationSeparateOES(glBlendEquationSeparateOES_ARG_EXPAND);
typedef void (*glBlendEquationSeparateOES_PTR)(glBlendEquationSeparateOES_ARG_EXPAND);
#define glBlendEquationSeparatei_INDEX 181
#define glBlendEquationSeparatei_RETURN void
#define glBlendEquationSeparatei_ARG_NAMES buf, modeRGB, modeAlpha
#define glBlendEquationSeparatei_ARG_EXPAND GLuint buf, GLenum modeRGB, GLenum modeAlpha
#define glBlendEquationSeparatei_PACKED PACKED_glBlendEquationSeparatei
#define glBlendEquationSeparatei_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glBlendEquationSeparatei_NOT_VOID_WRAP(...) {}
#define pack_glBlendEquationSeparatei(_buf, _modeRGB, _modeAlpha) ({ \
    glBlendEquationSeparatei_PACKED *packed_data = malloc(sizeof(glBlendEquationSeparatei_PACKED)); \
    packed_data->index = glBlendEquationSeparatei_INDEX; \
    packed_data->args.buf = (GLuint)_buf; \
    packed_data->args.modeRGB = (GLenum)_modeRGB; \
    packed_data->args.modeAlpha = (GLenum)_modeAlpha; \
    (packed_call_t *)packed_data; \
})
#define call_glBlendEquationSeparatei(packed, ret_v) do { \
    PACKED_glBlendEquationSeparatei *unpacked = (PACKED_glBlendEquationSeparatei *)packed; \
    ARGS_glBlendEquationSeparatei *args = (ARGS_glBlendEquationSeparatei *)&unpacked->args; \
    glBlendEquationSeparatei(args->buf, args->modeRGB, args->modeAlpha);; \
} while(0)
void glBlendEquationSeparatei(glBlendEquationSeparatei_ARG_EXPAND);
typedef void (*glBlendEquationSeparatei_PTR)(glBlendEquationSeparatei_ARG_EXPAND);
#define glBlendEquationSeparateiARB_INDEX 182
#define glBlendEquationSeparateiARB_RETURN void
#define glBlendEquationSeparateiARB_ARG_NAMES buf, modeRGB, modeAlpha
#define glBlendEquationSeparateiARB_ARG_EXPAND GLuint buf, GLenum modeRGB, GLenum modeAlpha
#define glBlendEquationSeparateiARB_PACKED PACKED_glBlendEquationSeparateiARB
#define glBlendEquationSeparateiARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glBlendEquationSeparateiARB_NOT_VOID_WRAP(...) {}
#define pack_glBlendEquationSeparateiARB(_buf, _modeRGB, _modeAlpha) ({ \
    glBlendEquationSeparateiARB_PACKED *packed_data = malloc(sizeof(glBlendEquationSeparateiARB_PACKED)); \
    packed_data->index = glBlendEquationSeparateiARB_INDEX; \
    packed_data->args.buf = (GLuint)_buf; \
    packed_data->args.modeRGB = (GLenum)_modeRGB; \
    packed_data->args.modeAlpha = (GLenum)_modeAlpha; \
    (packed_call_t *)packed_data; \
})
#define call_glBlendEquationSeparateiARB(packed, ret_v) do { \
    PACKED_glBlendEquationSeparateiARB *unpacked = (PACKED_glBlendEquationSeparateiARB *)packed; \
    ARGS_glBlendEquationSeparateiARB *args = (ARGS_glBlendEquationSeparateiARB *)&unpacked->args; \
    glBlendEquationSeparateiARB(args->buf, args->modeRGB, args->modeAlpha);; \
} while(0)
void glBlendEquationSeparateiARB(glBlendEquationSeparateiARB_ARG_EXPAND);
typedef void (*glBlendEquationSeparateiARB_PTR)(glBlendEquationSeparateiARB_ARG_EXPAND);
#define glBlendEquationi_INDEX 183
#define glBlendEquationi_RETURN void
#define glBlendEquationi_ARG_NAMES buf, mode
#define glBlendEquationi_ARG_EXPAND GLuint buf, GLenum mode
#define glBlendEquationi_PACKED PACKED_glBlendEquationi
#define glBlendEquationi_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glBlendEquationi_NOT_VOID_WRAP(...) {}
#define pack_glBlendEquationi(_buf, _mode) ({ \
    glBlendEquationi_PACKED *packed_data = malloc(sizeof(glBlendEquationi_PACKED)); \
    packed_data->index = glBlendEquationi_INDEX; \
    packed_data->args.buf = (GLuint)_buf; \
    packed_data->args.mode = (GLenum)_mode; \
    (packed_call_t *)packed_data; \
})
#define call_glBlendEquationi(packed, ret_v) do { \
    PACKED_glBlendEquationi *unpacked = (PACKED_glBlendEquationi *)packed; \
    ARGS_glBlendEquationi *args = (ARGS_glBlendEquationi *)&unpacked->args; \
    glBlendEquationi(args->buf, args->mode);; \
} while(0)
void glBlendEquationi(glBlendEquationi_ARG_EXPAND);
typedef void (*glBlendEquationi_PTR)(glBlendEquationi_ARG_EXPAND);
#define glBlendEquationiARB_INDEX 184
#define glBlendEquationiARB_RETURN void
#define glBlendEquationiARB_ARG_NAMES buf, mode
#define glBlendEquationiARB_ARG_EXPAND GLuint buf, GLenum mode
#define glBlendEquationiARB_PACKED PACKED_glBlendEquationiARB
#define glBlendEquationiARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glBlendEquationiARB_NOT_VOID_WRAP(...) {}
#define pack_glBlendEquationiARB(_buf, _mode) ({ \
    glBlendEquationiARB_PACKED *packed_data = malloc(sizeof(glBlendEquationiARB_PACKED)); \
    packed_data->index = glBlendEquationiARB_INDEX; \
    packed_data->args.buf = (GLuint)_buf; \
    packed_data->args.mode = (GLenum)_mode; \
    (packed_call_t *)packed_data; \
})
#define call_glBlendEquationiARB(packed, ret_v) do { \
    PACKED_glBlendEquationiARB *unpacked = (PACKED_glBlendEquationiARB *)packed; \
    ARGS_glBlendEquationiARB *args = (ARGS_glBlendEquationiARB *)&unpacked->args; \
    glBlendEquationiARB(args->buf, args->mode);; \
} while(0)
void glBlendEquationiARB(glBlendEquationiARB_ARG_EXPAND);
typedef void (*glBlendEquationiARB_PTR)(glBlendEquationiARB_ARG_EXPAND);
#define glBlendFunc_INDEX 185
#define glBlendFunc_RETURN void
#define glBlendFunc_ARG_NAMES sfactor, dfactor
#define glBlendFunc_ARG_EXPAND GLenum sfactor, GLenum dfactor
#define glBlendFunc_PACKED PACKED_glBlendFunc
#define glBlendFunc_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glBlendFunc_NOT_VOID_WRAP(...) {}
#define pack_glBlendFunc(_sfactor, _dfactor) ({ \
    glBlendFunc_PACKED *packed_data = malloc(sizeof(glBlendFunc_PACKED)); \
    packed_data->index = glBlendFunc_INDEX; \
    packed_data->args.sfactor = (GLenum)_sfactor; \
    packed_data->args.dfactor = (GLenum)_dfactor; \
    (packed_call_t *)packed_data; \
})
#define call_glBlendFunc(packed, ret_v) do { \
    PACKED_glBlendFunc *unpacked = (PACKED_glBlendFunc *)packed; \
    ARGS_glBlendFunc *args = (ARGS_glBlendFunc *)&unpacked->args; \
    glBlendFunc(args->sfactor, args->dfactor);; \
} while(0)
void glBlendFunc(glBlendFunc_ARG_EXPAND);
typedef void (*glBlendFunc_PTR)(glBlendFunc_ARG_EXPAND);
#define glBlendFuncIndexedAMD_INDEX 186
#define glBlendFuncIndexedAMD_RETURN void
#define glBlendFuncIndexedAMD_ARG_NAMES buf, src, dst
#define glBlendFuncIndexedAMD_ARG_EXPAND GLuint buf, GLenum src, GLenum dst
#define glBlendFuncIndexedAMD_PACKED PACKED_glBlendFuncIndexedAMD
#define glBlendFuncIndexedAMD_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glBlendFuncIndexedAMD_NOT_VOID_WRAP(...) {}
#define pack_glBlendFuncIndexedAMD(_buf, _src, _dst) ({ \
    glBlendFuncIndexedAMD_PACKED *packed_data = malloc(sizeof(glBlendFuncIndexedAMD_PACKED)); \
    packed_data->index = glBlendFuncIndexedAMD_INDEX; \
    packed_data->args.buf = (GLuint)_buf; \
    packed_data->args.src = (GLenum)_src; \
    packed_data->args.dst = (GLenum)_dst; \
    (packed_call_t *)packed_data; \
})
#define call_glBlendFuncIndexedAMD(packed, ret_v) do { \
    PACKED_glBlendFuncIndexedAMD *unpacked = (PACKED_glBlendFuncIndexedAMD *)packed; \
    ARGS_glBlendFuncIndexedAMD *args = (ARGS_glBlendFuncIndexedAMD *)&unpacked->args; \
    glBlendFuncIndexedAMD(args->buf, args->src, args->dst);; \
} while(0)
void glBlendFuncIndexedAMD(glBlendFuncIndexedAMD_ARG_EXPAND);
typedef void (*glBlendFuncIndexedAMD_PTR)(glBlendFuncIndexedAMD_ARG_EXPAND);
#define glBlendFuncSeparate_INDEX 187
#define glBlendFuncSeparate_RETURN void
#define glBlendFuncSeparate_ARG_NAMES sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha
#define glBlendFuncSeparate_ARG_EXPAND GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha
#define glBlendFuncSeparate_PACKED PACKED_glBlendFuncSeparate
#define glBlendFuncSeparate_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glBlendFuncSeparate_NOT_VOID_WRAP(...) {}
#define pack_glBlendFuncSeparate(_sfactorRGB, _dfactorRGB, _sfactorAlpha, _dfactorAlpha) ({ \
    glBlendFuncSeparate_PACKED *packed_data = malloc(sizeof(glBlendFuncSeparate_PACKED)); \
    packed_data->index = glBlendFuncSeparate_INDEX; \
    packed_data->args.sfactorRGB = (GLenum)_sfactorRGB; \
    packed_data->args.dfactorRGB = (GLenum)_dfactorRGB; \
    packed_data->args.sfactorAlpha = (GLenum)_sfactorAlpha; \
    packed_data->args.dfactorAlpha = (GLenum)_dfactorAlpha; \
    (packed_call_t *)packed_data; \
})
#define call_glBlendFuncSeparate(packed, ret_v) do { \
    PACKED_glBlendFuncSeparate *unpacked = (PACKED_glBlendFuncSeparate *)packed; \
    ARGS_glBlendFuncSeparate *args = (ARGS_glBlendFuncSeparate *)&unpacked->args; \
    glBlendFuncSeparate(args->sfactorRGB, args->dfactorRGB, args->sfactorAlpha, args->dfactorAlpha);; \
} while(0)
void glBlendFuncSeparate(glBlendFuncSeparate_ARG_EXPAND);
typedef void (*glBlendFuncSeparate_PTR)(glBlendFuncSeparate_ARG_EXPAND);
#define glBlendFuncSeparateEXT_INDEX 188
#define glBlendFuncSeparateEXT_RETURN void
#define glBlendFuncSeparateEXT_ARG_NAMES sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha
#define glBlendFuncSeparateEXT_ARG_EXPAND GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha
#define glBlendFuncSeparateEXT_PACKED PACKED_glBlendFuncSeparateEXT
#define glBlendFuncSeparateEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glBlendFuncSeparateEXT_NOT_VOID_WRAP(...) {}
#define pack_glBlendFuncSeparateEXT(_sfactorRGB, _dfactorRGB, _sfactorAlpha, _dfactorAlpha) ({ \
    glBlendFuncSeparateEXT_PACKED *packed_data = malloc(sizeof(glBlendFuncSeparateEXT_PACKED)); \
    packed_data->index = glBlendFuncSeparateEXT_INDEX; \
    packed_data->args.sfactorRGB = (GLenum)_sfactorRGB; \
    packed_data->args.dfactorRGB = (GLenum)_dfactorRGB; \
    packed_data->args.sfactorAlpha = (GLenum)_sfactorAlpha; \
    packed_data->args.dfactorAlpha = (GLenum)_dfactorAlpha; \
    (packed_call_t *)packed_data; \
})
#define call_glBlendFuncSeparateEXT(packed, ret_v) do { \
    PACKED_glBlendFuncSeparateEXT *unpacked = (PACKED_glBlendFuncSeparateEXT *)packed; \
    ARGS_glBlendFuncSeparateEXT *args = (ARGS_glBlendFuncSeparateEXT *)&unpacked->args; \
    glBlendFuncSeparateEXT(args->sfactorRGB, args->dfactorRGB, args->sfactorAlpha, args->dfactorAlpha);; \
} while(0)
void glBlendFuncSeparateEXT(glBlendFuncSeparateEXT_ARG_EXPAND);
typedef void (*glBlendFuncSeparateEXT_PTR)(glBlendFuncSeparateEXT_ARG_EXPAND);
#define glBlendFuncSeparateINGR_INDEX 189
#define glBlendFuncSeparateINGR_RETURN void
#define glBlendFuncSeparateINGR_ARG_NAMES sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha
#define glBlendFuncSeparateINGR_ARG_EXPAND GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha
#define glBlendFuncSeparateINGR_PACKED PACKED_glBlendFuncSeparateINGR
#define glBlendFuncSeparateINGR_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glBlendFuncSeparateINGR_NOT_VOID_WRAP(...) {}
#define pack_glBlendFuncSeparateINGR(_sfactorRGB, _dfactorRGB, _sfactorAlpha, _dfactorAlpha) ({ \
    glBlendFuncSeparateINGR_PACKED *packed_data = malloc(sizeof(glBlendFuncSeparateINGR_PACKED)); \
    packed_data->index = glBlendFuncSeparateINGR_INDEX; \
    packed_data->args.sfactorRGB = (GLenum)_sfactorRGB; \
    packed_data->args.dfactorRGB = (GLenum)_dfactorRGB; \
    packed_data->args.sfactorAlpha = (GLenum)_sfactorAlpha; \
    packed_data->args.dfactorAlpha = (GLenum)_dfactorAlpha; \
    (packed_call_t *)packed_data; \
})
#define call_glBlendFuncSeparateINGR(packed, ret_v) do { \
    PACKED_glBlendFuncSeparateINGR *unpacked = (PACKED_glBlendFuncSeparateINGR *)packed; \
    ARGS_glBlendFuncSeparateINGR *args = (ARGS_glBlendFuncSeparateINGR *)&unpacked->args; \
    glBlendFuncSeparateINGR(args->sfactorRGB, args->dfactorRGB, args->sfactorAlpha, args->dfactorAlpha);; \
} while(0)
void glBlendFuncSeparateINGR(glBlendFuncSeparateINGR_ARG_EXPAND);
typedef void (*glBlendFuncSeparateINGR_PTR)(glBlendFuncSeparateINGR_ARG_EXPAND);
#define glBlendFuncSeparateIndexedAMD_INDEX 190
#define glBlendFuncSeparateIndexedAMD_RETURN void
#define glBlendFuncSeparateIndexedAMD_ARG_NAMES buf, srcRGB, dstRGB, srcAlpha, dstAlpha
#define glBlendFuncSeparateIndexedAMD_ARG_EXPAND GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha
#define glBlendFuncSeparateIndexedAMD_PACKED PACKED_glBlendFuncSeparateIndexedAMD
#define glBlendFuncSeparateIndexedAMD_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glBlendFuncSeparateIndexedAMD_NOT_VOID_WRAP(...) {}
#define pack_glBlendFuncSeparateIndexedAMD(_buf, _srcRGB, _dstRGB, _srcAlpha, _dstAlpha) ({ \
    glBlendFuncSeparateIndexedAMD_PACKED *packed_data = malloc(sizeof(glBlendFuncSeparateIndexedAMD_PACKED)); \
    packed_data->index = glBlendFuncSeparateIndexedAMD_INDEX; \
    packed_data->args.buf = (GLuint)_buf; \
    packed_data->args.srcRGB = (GLenum)_srcRGB; \
    packed_data->args.dstRGB = (GLenum)_dstRGB; \
    packed_data->args.srcAlpha = (GLenum)_srcAlpha; \
    packed_data->args.dstAlpha = (GLenum)_dstAlpha; \
    (packed_call_t *)packed_data; \
})
#define call_glBlendFuncSeparateIndexedAMD(packed, ret_v) do { \
    PACKED_glBlendFuncSeparateIndexedAMD *unpacked = (PACKED_glBlendFuncSeparateIndexedAMD *)packed; \
    ARGS_glBlendFuncSeparateIndexedAMD *args = (ARGS_glBlendFuncSeparateIndexedAMD *)&unpacked->args; \
    glBlendFuncSeparateIndexedAMD(args->buf, args->srcRGB, args->dstRGB, args->srcAlpha, args->dstAlpha);; \
} while(0)
void glBlendFuncSeparateIndexedAMD(glBlendFuncSeparateIndexedAMD_ARG_EXPAND);
typedef void (*glBlendFuncSeparateIndexedAMD_PTR)(glBlendFuncSeparateIndexedAMD_ARG_EXPAND);
#define glBlendFuncSeparateOES_INDEX 191
#define glBlendFuncSeparateOES_RETURN void
#define glBlendFuncSeparateOES_ARG_NAMES sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha
#define glBlendFuncSeparateOES_ARG_EXPAND GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha
#define glBlendFuncSeparateOES_PACKED PACKED_glBlendFuncSeparateOES
#define glBlendFuncSeparateOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glBlendFuncSeparateOES_NOT_VOID_WRAP(...) {}
#define pack_glBlendFuncSeparateOES(_sfactorRGB, _dfactorRGB, _sfactorAlpha, _dfactorAlpha) ({ \
    glBlendFuncSeparateOES_PACKED *packed_data = malloc(sizeof(glBlendFuncSeparateOES_PACKED)); \
    packed_data->index = glBlendFuncSeparateOES_INDEX; \
    packed_data->args.sfactorRGB = (GLenum)_sfactorRGB; \
    packed_data->args.dfactorRGB = (GLenum)_dfactorRGB; \
    packed_data->args.sfactorAlpha = (GLenum)_sfactorAlpha; \
    packed_data->args.dfactorAlpha = (GLenum)_dfactorAlpha; \
    (packed_call_t *)packed_data; \
})
#define call_glBlendFuncSeparateOES(packed, ret_v) do { \
    PACKED_glBlendFuncSeparateOES *unpacked = (PACKED_glBlendFuncSeparateOES *)packed; \
    ARGS_glBlendFuncSeparateOES *args = (ARGS_glBlendFuncSeparateOES *)&unpacked->args; \
    glBlendFuncSeparateOES(args->sfactorRGB, args->dfactorRGB, args->sfactorAlpha, args->dfactorAlpha);; \
} while(0)
void glBlendFuncSeparateOES(glBlendFuncSeparateOES_ARG_EXPAND);
typedef void (*glBlendFuncSeparateOES_PTR)(glBlendFuncSeparateOES_ARG_EXPAND);
#define glBlendFuncSeparatei_INDEX 192
#define glBlendFuncSeparatei_RETURN void
#define glBlendFuncSeparatei_ARG_NAMES buf, srcRGB, dstRGB, srcAlpha, dstAlpha
#define glBlendFuncSeparatei_ARG_EXPAND GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha
#define glBlendFuncSeparatei_PACKED PACKED_glBlendFuncSeparatei
#define glBlendFuncSeparatei_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glBlendFuncSeparatei_NOT_VOID_WRAP(...) {}
#define pack_glBlendFuncSeparatei(_buf, _srcRGB, _dstRGB, _srcAlpha, _dstAlpha) ({ \
    glBlendFuncSeparatei_PACKED *packed_data = malloc(sizeof(glBlendFuncSeparatei_PACKED)); \
    packed_data->index = glBlendFuncSeparatei_INDEX; \
    packed_data->args.buf = (GLuint)_buf; \
    packed_data->args.srcRGB = (GLenum)_srcRGB; \
    packed_data->args.dstRGB = (GLenum)_dstRGB; \
    packed_data->args.srcAlpha = (GLenum)_srcAlpha; \
    packed_data->args.dstAlpha = (GLenum)_dstAlpha; \
    (packed_call_t *)packed_data; \
})
#define call_glBlendFuncSeparatei(packed, ret_v) do { \
    PACKED_glBlendFuncSeparatei *unpacked = (PACKED_glBlendFuncSeparatei *)packed; \
    ARGS_glBlendFuncSeparatei *args = (ARGS_glBlendFuncSeparatei *)&unpacked->args; \
    glBlendFuncSeparatei(args->buf, args->srcRGB, args->dstRGB, args->srcAlpha, args->dstAlpha);; \
} while(0)
void glBlendFuncSeparatei(glBlendFuncSeparatei_ARG_EXPAND);
typedef void (*glBlendFuncSeparatei_PTR)(glBlendFuncSeparatei_ARG_EXPAND);
#define glBlendFuncSeparateiARB_INDEX 193
#define glBlendFuncSeparateiARB_RETURN void
#define glBlendFuncSeparateiARB_ARG_NAMES buf, srcRGB, dstRGB, srcAlpha, dstAlpha
#define glBlendFuncSeparateiARB_ARG_EXPAND GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha
#define glBlendFuncSeparateiARB_PACKED PACKED_glBlendFuncSeparateiARB
#define glBlendFuncSeparateiARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glBlendFuncSeparateiARB_NOT_VOID_WRAP(...) {}
#define pack_glBlendFuncSeparateiARB(_buf, _srcRGB, _dstRGB, _srcAlpha, _dstAlpha) ({ \
    glBlendFuncSeparateiARB_PACKED *packed_data = malloc(sizeof(glBlendFuncSeparateiARB_PACKED)); \
    packed_data->index = glBlendFuncSeparateiARB_INDEX; \
    packed_data->args.buf = (GLuint)_buf; \
    packed_data->args.srcRGB = (GLenum)_srcRGB; \
    packed_data->args.dstRGB = (GLenum)_dstRGB; \
    packed_data->args.srcAlpha = (GLenum)_srcAlpha; \
    packed_data->args.dstAlpha = (GLenum)_dstAlpha; \
    (packed_call_t *)packed_data; \
})
#define call_glBlendFuncSeparateiARB(packed, ret_v) do { \
    PACKED_glBlendFuncSeparateiARB *unpacked = (PACKED_glBlendFuncSeparateiARB *)packed; \
    ARGS_glBlendFuncSeparateiARB *args = (ARGS_glBlendFuncSeparateiARB *)&unpacked->args; \
    glBlendFuncSeparateiARB(args->buf, args->srcRGB, args->dstRGB, args->srcAlpha, args->dstAlpha);; \
} while(0)
void glBlendFuncSeparateiARB(glBlendFuncSeparateiARB_ARG_EXPAND);
typedef void (*glBlendFuncSeparateiARB_PTR)(glBlendFuncSeparateiARB_ARG_EXPAND);
#define glBlendFunci_INDEX 194
#define glBlendFunci_RETURN void
#define glBlendFunci_ARG_NAMES buf, src, dst
#define glBlendFunci_ARG_EXPAND GLuint buf, GLenum src, GLenum dst
#define glBlendFunci_PACKED PACKED_glBlendFunci
#define glBlendFunci_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glBlendFunci_NOT_VOID_WRAP(...) {}
#define pack_glBlendFunci(_buf, _src, _dst) ({ \
    glBlendFunci_PACKED *packed_data = malloc(sizeof(glBlendFunci_PACKED)); \
    packed_data->index = glBlendFunci_INDEX; \
    packed_data->args.buf = (GLuint)_buf; \
    packed_data->args.src = (GLenum)_src; \
    packed_data->args.dst = (GLenum)_dst; \
    (packed_call_t *)packed_data; \
})
#define call_glBlendFunci(packed, ret_v) do { \
    PACKED_glBlendFunci *unpacked = (PACKED_glBlendFunci *)packed; \
    ARGS_glBlendFunci *args = (ARGS_glBlendFunci *)&unpacked->args; \
    glBlendFunci(args->buf, args->src, args->dst);; \
} while(0)
void glBlendFunci(glBlendFunci_ARG_EXPAND);
typedef void (*glBlendFunci_PTR)(glBlendFunci_ARG_EXPAND);
#define glBlendFunciARB_INDEX 195
#define glBlendFunciARB_RETURN void
#define glBlendFunciARB_ARG_NAMES buf, src, dst
#define glBlendFunciARB_ARG_EXPAND GLuint buf, GLenum src, GLenum dst
#define glBlendFunciARB_PACKED PACKED_glBlendFunciARB
#define glBlendFunciARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glBlendFunciARB_NOT_VOID_WRAP(...) {}
#define pack_glBlendFunciARB(_buf, _src, _dst) ({ \
    glBlendFunciARB_PACKED *packed_data = malloc(sizeof(glBlendFunciARB_PACKED)); \
    packed_data->index = glBlendFunciARB_INDEX; \
    packed_data->args.buf = (GLuint)_buf; \
    packed_data->args.src = (GLenum)_src; \
    packed_data->args.dst = (GLenum)_dst; \
    (packed_call_t *)packed_data; \
})
#define call_glBlendFunciARB(packed, ret_v) do { \
    PACKED_glBlendFunciARB *unpacked = (PACKED_glBlendFunciARB *)packed; \
    ARGS_glBlendFunciARB *args = (ARGS_glBlendFunciARB *)&unpacked->args; \
    glBlendFunciARB(args->buf, args->src, args->dst);; \
} while(0)
void glBlendFunciARB(glBlendFunciARB_ARG_EXPAND);
typedef void (*glBlendFunciARB_PTR)(glBlendFunciARB_ARG_EXPAND);
#define glBlitFramebuffer_INDEX 196
#define glBlitFramebuffer_RETURN void
#define glBlitFramebuffer_ARG_NAMES srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter
#define glBlitFramebuffer_ARG_EXPAND GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter
#define glBlitFramebuffer_PACKED PACKED_glBlitFramebuffer
#define glBlitFramebuffer_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glBlitFramebuffer_NOT_VOID_WRAP(...) {}
#define pack_glBlitFramebuffer(_srcX0, _srcY0, _srcX1, _srcY1, _dstX0, _dstY0, _dstX1, _dstY1, _mask, _filter) ({ \
    glBlitFramebuffer_PACKED *packed_data = malloc(sizeof(glBlitFramebuffer_PACKED)); \
    packed_data->index = glBlitFramebuffer_INDEX; \
    packed_data->args.srcX0 = (GLint)_srcX0; \
    packed_data->args.srcY0 = (GLint)_srcY0; \
    packed_data->args.srcX1 = (GLint)_srcX1; \
    packed_data->args.srcY1 = (GLint)_srcY1; \
    packed_data->args.dstX0 = (GLint)_dstX0; \
    packed_data->args.dstY0 = (GLint)_dstY0; \
    packed_data->args.dstX1 = (GLint)_dstX1; \
    packed_data->args.dstY1 = (GLint)_dstY1; \
    packed_data->args.mask = (GLbitfield)_mask; \
    packed_data->args.filter = (GLenum)_filter; \
    (packed_call_t *)packed_data; \
})
#define call_glBlitFramebuffer(packed, ret_v) do { \
    PACKED_glBlitFramebuffer *unpacked = (PACKED_glBlitFramebuffer *)packed; \
    ARGS_glBlitFramebuffer *args = (ARGS_glBlitFramebuffer *)&unpacked->args; \
    glBlitFramebuffer(args->srcX0, args->srcY0, args->srcX1, args->srcY1, args->dstX0, args->dstY0, args->dstX1, args->dstY1, args->mask, args->filter);; \
} while(0)
void glBlitFramebuffer(glBlitFramebuffer_ARG_EXPAND);
typedef void (*glBlitFramebuffer_PTR)(glBlitFramebuffer_ARG_EXPAND);
#define glBlitFramebufferEXT_INDEX 197
#define glBlitFramebufferEXT_RETURN void
#define glBlitFramebufferEXT_ARG_NAMES srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter
#define glBlitFramebufferEXT_ARG_EXPAND GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter
#define glBlitFramebufferEXT_PACKED PACKED_glBlitFramebufferEXT
#define glBlitFramebufferEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glBlitFramebufferEXT_NOT_VOID_WRAP(...) {}
#define pack_glBlitFramebufferEXT(_srcX0, _srcY0, _srcX1, _srcY1, _dstX0, _dstY0, _dstX1, _dstY1, _mask, _filter) ({ \
    glBlitFramebufferEXT_PACKED *packed_data = malloc(sizeof(glBlitFramebufferEXT_PACKED)); \
    packed_data->index = glBlitFramebufferEXT_INDEX; \
    packed_data->args.srcX0 = (GLint)_srcX0; \
    packed_data->args.srcY0 = (GLint)_srcY0; \
    packed_data->args.srcX1 = (GLint)_srcX1; \
    packed_data->args.srcY1 = (GLint)_srcY1; \
    packed_data->args.dstX0 = (GLint)_dstX0; \
    packed_data->args.dstY0 = (GLint)_dstY0; \
    packed_data->args.dstX1 = (GLint)_dstX1; \
    packed_data->args.dstY1 = (GLint)_dstY1; \
    packed_data->args.mask = (GLbitfield)_mask; \
    packed_data->args.filter = (GLenum)_filter; \
    (packed_call_t *)packed_data; \
})
#define call_glBlitFramebufferEXT(packed, ret_v) do { \
    PACKED_glBlitFramebufferEXT *unpacked = (PACKED_glBlitFramebufferEXT *)packed; \
    ARGS_glBlitFramebufferEXT *args = (ARGS_glBlitFramebufferEXT *)&unpacked->args; \
    glBlitFramebufferEXT(args->srcX0, args->srcY0, args->srcX1, args->srcY1, args->dstX0, args->dstY0, args->dstX1, args->dstY1, args->mask, args->filter);; \
} while(0)
void glBlitFramebufferEXT(glBlitFramebufferEXT_ARG_EXPAND);
typedef void (*glBlitFramebufferEXT_PTR)(glBlitFramebufferEXT_ARG_EXPAND);
#define glBufferAddressRangeNV_INDEX 198
#define glBufferAddressRangeNV_RETURN void
#define glBufferAddressRangeNV_ARG_NAMES pname, index, address, length
#define glBufferAddressRangeNV_ARG_EXPAND GLenum pname, GLuint index, GLuint64EXT address, GLsizeiptr length
#define glBufferAddressRangeNV_PACKED PACKED_glBufferAddressRangeNV
#define glBufferAddressRangeNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glBufferAddressRangeNV_NOT_VOID_WRAP(...) {}
#define pack_glBufferAddressRangeNV(_pname, _index, _address, _length) ({ \
    glBufferAddressRangeNV_PACKED *packed_data = malloc(sizeof(glBufferAddressRangeNV_PACKED)); \
    packed_data->index = glBufferAddressRangeNV_INDEX; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.address = (GLuint64EXT)_address; \
    packed_data->args.length = (GLsizeiptr)_length; \
    (packed_call_t *)packed_data; \
})
#define call_glBufferAddressRangeNV(packed, ret_v) do { \
    PACKED_glBufferAddressRangeNV *unpacked = (PACKED_glBufferAddressRangeNV *)packed; \
    ARGS_glBufferAddressRangeNV *args = (ARGS_glBufferAddressRangeNV *)&unpacked->args; \
    glBufferAddressRangeNV(args->pname, args->index, args->address, args->length);; \
} while(0)
void glBufferAddressRangeNV(glBufferAddressRangeNV_ARG_EXPAND);
typedef void (*glBufferAddressRangeNV_PTR)(glBufferAddressRangeNV_ARG_EXPAND);
#define glBufferData_INDEX 199
#define glBufferData_RETURN void
#define glBufferData_ARG_NAMES target, size, data, usage
#define glBufferData_ARG_EXPAND GLenum target, GLsizeiptr size, const GLvoid * data, GLenum usage
#define glBufferData_PACKED PACKED_glBufferData
#define glBufferData_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glBufferData_NOT_VOID_WRAP(...) {}
#define pack_glBufferData(_target, _size, _data, _usage) ({ \
    glBufferData_PACKED *packed_data = malloc(sizeof(glBufferData_PACKED)); \
    packed_data->index = glBufferData_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.size = (GLsizeiptr)_size; \
    packed_data->args.data = (GLvoid *)_data; \
    packed_data->args.usage = (GLenum)_usage; \
    (packed_call_t *)packed_data; \
})
#define call_glBufferData(packed, ret_v) do { \
    PACKED_glBufferData *unpacked = (PACKED_glBufferData *)packed; \
    ARGS_glBufferData *args = (ARGS_glBufferData *)&unpacked->args; \
    glBufferData(args->target, args->size, args->data, args->usage);; \
} while(0)
void glBufferData(glBufferData_ARG_EXPAND);
typedef void (*glBufferData_PTR)(glBufferData_ARG_EXPAND);
#define glBufferDataARB_INDEX 200
#define glBufferDataARB_RETURN void
#define glBufferDataARB_ARG_NAMES target, size, data, usage
#define glBufferDataARB_ARG_EXPAND GLenum target, GLsizeiptrARB size, const GLvoid * data, GLenum usage
#define glBufferDataARB_PACKED PACKED_glBufferDataARB
#define glBufferDataARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glBufferDataARB_NOT_VOID_WRAP(...) {}
#define pack_glBufferDataARB(_target, _size, _data, _usage) ({ \
    glBufferDataARB_PACKED *packed_data = malloc(sizeof(glBufferDataARB_PACKED)); \
    packed_data->index = glBufferDataARB_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.size = (GLsizeiptrARB)_size; \
    packed_data->args.data = (GLvoid *)_data; \
    packed_data->args.usage = (GLenum)_usage; \
    (packed_call_t *)packed_data; \
})
#define call_glBufferDataARB(packed, ret_v) do { \
    PACKED_glBufferDataARB *unpacked = (PACKED_glBufferDataARB *)packed; \
    ARGS_glBufferDataARB *args = (ARGS_glBufferDataARB *)&unpacked->args; \
    glBufferDataARB(args->target, args->size, args->data, args->usage);; \
} while(0)
void glBufferDataARB(glBufferDataARB_ARG_EXPAND);
typedef void (*glBufferDataARB_PTR)(glBufferDataARB_ARG_EXPAND);
#define glBufferParameteriAPPLE_INDEX 201
#define glBufferParameteriAPPLE_RETURN void
#define glBufferParameteriAPPLE_ARG_NAMES target, pname, param
#define glBufferParameteriAPPLE_ARG_EXPAND GLenum target, GLenum pname, GLint param
#define glBufferParameteriAPPLE_PACKED PACKED_glBufferParameteriAPPLE
#define glBufferParameteriAPPLE_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glBufferParameteriAPPLE_NOT_VOID_WRAP(...) {}
#define pack_glBufferParameteriAPPLE(_target, _pname, _param) ({ \
    glBufferParameteriAPPLE_PACKED *packed_data = malloc(sizeof(glBufferParameteriAPPLE_PACKED)); \
    packed_data->index = glBufferParameteriAPPLE_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.param = (GLint)_param; \
    (packed_call_t *)packed_data; \
})
#define call_glBufferParameteriAPPLE(packed, ret_v) do { \
    PACKED_glBufferParameteriAPPLE *unpacked = (PACKED_glBufferParameteriAPPLE *)packed; \
    ARGS_glBufferParameteriAPPLE *args = (ARGS_glBufferParameteriAPPLE *)&unpacked->args; \
    glBufferParameteriAPPLE(args->target, args->pname, args->param);; \
} while(0)
void glBufferParameteriAPPLE(glBufferParameteriAPPLE_ARG_EXPAND);
typedef void (*glBufferParameteriAPPLE_PTR)(glBufferParameteriAPPLE_ARG_EXPAND);
#define glBufferSubData_INDEX 202
#define glBufferSubData_RETURN void
#define glBufferSubData_ARG_NAMES target, offset, size, data
#define glBufferSubData_ARG_EXPAND GLenum target, GLintptr offset, GLsizeiptr size, const GLvoid * data
#define glBufferSubData_PACKED PACKED_glBufferSubData
#define glBufferSubData_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glBufferSubData_NOT_VOID_WRAP(...) {}
#define pack_glBufferSubData(_target, _offset, _size, _data) ({ \
    glBufferSubData_PACKED *packed_data = malloc(sizeof(glBufferSubData_PACKED)); \
    packed_data->index = glBufferSubData_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.offset = (GLintptr)_offset; \
    packed_data->args.size = (GLsizeiptr)_size; \
    packed_data->args.data = (GLvoid *)_data; \
    (packed_call_t *)packed_data; \
})
#define call_glBufferSubData(packed, ret_v) do { \
    PACKED_glBufferSubData *unpacked = (PACKED_glBufferSubData *)packed; \
    ARGS_glBufferSubData *args = (ARGS_glBufferSubData *)&unpacked->args; \
    glBufferSubData(args->target, args->offset, args->size, args->data);; \
} while(0)
void glBufferSubData(glBufferSubData_ARG_EXPAND);
typedef void (*glBufferSubData_PTR)(glBufferSubData_ARG_EXPAND);
#define glBufferSubDataARB_INDEX 203
#define glBufferSubDataARB_RETURN void
#define glBufferSubDataARB_ARG_NAMES target, offset, size, data
#define glBufferSubDataARB_ARG_EXPAND GLenum target, GLintptrARB offset, GLsizeiptrARB size, const GLvoid * data
#define glBufferSubDataARB_PACKED PACKED_glBufferSubDataARB
#define glBufferSubDataARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glBufferSubDataARB_NOT_VOID_WRAP(...) {}
#define pack_glBufferSubDataARB(_target, _offset, _size, _data) ({ \
    glBufferSubDataARB_PACKED *packed_data = malloc(sizeof(glBufferSubDataARB_PACKED)); \
    packed_data->index = glBufferSubDataARB_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.offset = (GLintptrARB)_offset; \
    packed_data->args.size = (GLsizeiptrARB)_size; \
    packed_data->args.data = (GLvoid *)_data; \
    (packed_call_t *)packed_data; \
})
#define call_glBufferSubDataARB(packed, ret_v) do { \
    PACKED_glBufferSubDataARB *unpacked = (PACKED_glBufferSubDataARB *)packed; \
    ARGS_glBufferSubDataARB *args = (ARGS_glBufferSubDataARB *)&unpacked->args; \
    glBufferSubDataARB(args->target, args->offset, args->size, args->data);; \
} while(0)
void glBufferSubDataARB(glBufferSubDataARB_ARG_EXPAND);
typedef void (*glBufferSubDataARB_PTR)(glBufferSubDataARB_ARG_EXPAND);
#define glCallList_INDEX 204
#define glCallList_RETURN void
#define glCallList_ARG_NAMES list
#define glCallList_ARG_EXPAND GLuint list
#define glCallList_PACKED PACKED_glCallList
#define glCallList_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glCallList_NOT_VOID_WRAP(...) {}
#define pack_glCallList(_list) ({ \
    glCallList_PACKED *packed_data = malloc(sizeof(glCallList_PACKED)); \
    packed_data->index = glCallList_INDEX; \
    packed_data->args.list = (GLuint)_list; \
    (packed_call_t *)packed_data; \
})
#define call_glCallList(packed, ret_v) do { \
    PACKED_glCallList *unpacked = (PACKED_glCallList *)packed; \
    ARGS_glCallList *args = (ARGS_glCallList *)&unpacked->args; \
    glCallList(args->list);; \
} while(0)
void glCallList(glCallList_ARG_EXPAND);
typedef void (*glCallList_PTR)(glCallList_ARG_EXPAND);
#define glCallLists_INDEX 205
#define glCallLists_RETURN void
#define glCallLists_ARG_NAMES n, type, lists
#define glCallLists_ARG_EXPAND GLsizei n, GLenum type, const GLvoid * lists
#define glCallLists_PACKED PACKED_glCallLists
#define glCallLists_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glCallLists_NOT_VOID_WRAP(...) {}
#define pack_glCallLists(_n, _type, _lists) ({ \
    glCallLists_PACKED *packed_data = malloc(sizeof(glCallLists_PACKED)); \
    packed_data->index = glCallLists_INDEX; \
    packed_data->args.n = (GLsizei)_n; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.lists = (GLvoid *)_lists; \
    (packed_call_t *)packed_data; \
})
#define call_glCallLists(packed, ret_v) do { \
    PACKED_glCallLists *unpacked = (PACKED_glCallLists *)packed; \
    ARGS_glCallLists *args = (ARGS_glCallLists *)&unpacked->args; \
    glCallLists(args->n, args->type, args->lists);; \
} while(0)
void glCallLists(glCallLists_ARG_EXPAND);
typedef void (*glCallLists_PTR)(glCallLists_ARG_EXPAND);
#define glCheckFramebufferStatus_INDEX 206
#define glCheckFramebufferStatus_RETURN GLenum
#define glCheckFramebufferStatus_ARG_NAMES target
#define glCheckFramebufferStatus_ARG_EXPAND GLenum target
#define glCheckFramebufferStatus_PACKED PACKED_glCheckFramebufferStatus
#define glCheckFramebufferStatus_VOID_ONLY_WRAP(...) {}
#define glCheckFramebufferStatus_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glCheckFramebufferStatus(_target) ({ \
    glCheckFramebufferStatus_PACKED *packed_data = malloc(sizeof(glCheckFramebufferStatus_PACKED)); \
    packed_data->index = glCheckFramebufferStatus_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    (packed_call_t *)packed_data; \
})
#define call_glCheckFramebufferStatus(packed, ret_v) do { \
    PACKED_glCheckFramebufferStatus *unpacked = (PACKED_glCheckFramebufferStatus *)packed; \
    ARGS_glCheckFramebufferStatus *args = (ARGS_glCheckFramebufferStatus *)&unpacked->args; \
    GLenum *ret = (GLenum *)ret_v; \
    if (ret != NULL) { \
        *ret = glCheckFramebufferStatus(args->target);; \
    } else { \
        glCheckFramebufferStatus(args->target);; \
    } \
} while(0)
GLenum glCheckFramebufferStatus(glCheckFramebufferStatus_ARG_EXPAND);
typedef GLenum (*glCheckFramebufferStatus_PTR)(glCheckFramebufferStatus_ARG_EXPAND);
#define glCheckFramebufferStatusEXT_INDEX 207
#define glCheckFramebufferStatusEXT_RETURN GLenum
#define glCheckFramebufferStatusEXT_ARG_NAMES target
#define glCheckFramebufferStatusEXT_ARG_EXPAND GLenum target
#define glCheckFramebufferStatusEXT_PACKED PACKED_glCheckFramebufferStatusEXT
#define glCheckFramebufferStatusEXT_VOID_ONLY_WRAP(...) {}
#define glCheckFramebufferStatusEXT_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glCheckFramebufferStatusEXT(_target) ({ \
    glCheckFramebufferStatusEXT_PACKED *packed_data = malloc(sizeof(glCheckFramebufferStatusEXT_PACKED)); \
    packed_data->index = glCheckFramebufferStatusEXT_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    (packed_call_t *)packed_data; \
})
#define call_glCheckFramebufferStatusEXT(packed, ret_v) do { \
    PACKED_glCheckFramebufferStatusEXT *unpacked = (PACKED_glCheckFramebufferStatusEXT *)packed; \
    ARGS_glCheckFramebufferStatusEXT *args = (ARGS_glCheckFramebufferStatusEXT *)&unpacked->args; \
    GLenum *ret = (GLenum *)ret_v; \
    if (ret != NULL) { \
        *ret = glCheckFramebufferStatusEXT(args->target);; \
    } else { \
        glCheckFramebufferStatusEXT(args->target);; \
    } \
} while(0)
GLenum glCheckFramebufferStatusEXT(glCheckFramebufferStatusEXT_ARG_EXPAND);
typedef GLenum (*glCheckFramebufferStatusEXT_PTR)(glCheckFramebufferStatusEXT_ARG_EXPAND);
#define glCheckNamedFramebufferStatusEXT_INDEX 208
#define glCheckNamedFramebufferStatusEXT_RETURN GLenum
#define glCheckNamedFramebufferStatusEXT_ARG_NAMES framebuffer, target
#define glCheckNamedFramebufferStatusEXT_ARG_EXPAND GLuint framebuffer, GLenum target
#define glCheckNamedFramebufferStatusEXT_PACKED PACKED_glCheckNamedFramebufferStatusEXT
#define glCheckNamedFramebufferStatusEXT_VOID_ONLY_WRAP(...) {}
#define glCheckNamedFramebufferStatusEXT_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glCheckNamedFramebufferStatusEXT(_framebuffer, _target) ({ \
    glCheckNamedFramebufferStatusEXT_PACKED *packed_data = malloc(sizeof(glCheckNamedFramebufferStatusEXT_PACKED)); \
    packed_data->index = glCheckNamedFramebufferStatusEXT_INDEX; \
    packed_data->args.framebuffer = (GLuint)_framebuffer; \
    packed_data->args.target = (GLenum)_target; \
    (packed_call_t *)packed_data; \
})
#define call_glCheckNamedFramebufferStatusEXT(packed, ret_v) do { \
    PACKED_glCheckNamedFramebufferStatusEXT *unpacked = (PACKED_glCheckNamedFramebufferStatusEXT *)packed; \
    ARGS_glCheckNamedFramebufferStatusEXT *args = (ARGS_glCheckNamedFramebufferStatusEXT *)&unpacked->args; \
    GLenum *ret = (GLenum *)ret_v; \
    if (ret != NULL) { \
        *ret = glCheckNamedFramebufferStatusEXT(args->framebuffer, args->target);; \
    } else { \
        glCheckNamedFramebufferStatusEXT(args->framebuffer, args->target);; \
    } \
} while(0)
GLenum glCheckNamedFramebufferStatusEXT(glCheckNamedFramebufferStatusEXT_ARG_EXPAND);
typedef GLenum (*glCheckNamedFramebufferStatusEXT_PTR)(glCheckNamedFramebufferStatusEXT_ARG_EXPAND);
#define glClampColor_INDEX 209
#define glClampColor_RETURN void
#define glClampColor_ARG_NAMES target, clamp
#define glClampColor_ARG_EXPAND GLenum target, GLenum clamp
#define glClampColor_PACKED PACKED_glClampColor
#define glClampColor_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glClampColor_NOT_VOID_WRAP(...) {}
#define pack_glClampColor(_target, _clamp) ({ \
    glClampColor_PACKED *packed_data = malloc(sizeof(glClampColor_PACKED)); \
    packed_data->index = glClampColor_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.clamp = (GLenum)_clamp; \
    (packed_call_t *)packed_data; \
})
#define call_glClampColor(packed, ret_v) do { \
    PACKED_glClampColor *unpacked = (PACKED_glClampColor *)packed; \
    ARGS_glClampColor *args = (ARGS_glClampColor *)&unpacked->args; \
    glClampColor(args->target, args->clamp);; \
} while(0)
void glClampColor(glClampColor_ARG_EXPAND);
typedef void (*glClampColor_PTR)(glClampColor_ARG_EXPAND);
#define glClampColorARB_INDEX 210
#define glClampColorARB_RETURN void
#define glClampColorARB_ARG_NAMES target, clamp
#define glClampColorARB_ARG_EXPAND GLenum target, GLenum clamp
#define glClampColorARB_PACKED PACKED_glClampColorARB
#define glClampColorARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glClampColorARB_NOT_VOID_WRAP(...) {}
#define pack_glClampColorARB(_target, _clamp) ({ \
    glClampColorARB_PACKED *packed_data = malloc(sizeof(glClampColorARB_PACKED)); \
    packed_data->index = glClampColorARB_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.clamp = (GLenum)_clamp; \
    (packed_call_t *)packed_data; \
})
#define call_glClampColorARB(packed, ret_v) do { \
    PACKED_glClampColorARB *unpacked = (PACKED_glClampColorARB *)packed; \
    ARGS_glClampColorARB *args = (ARGS_glClampColorARB *)&unpacked->args; \
    glClampColorARB(args->target, args->clamp);; \
} while(0)
void glClampColorARB(glClampColorARB_ARG_EXPAND);
typedef void (*glClampColorARB_PTR)(glClampColorARB_ARG_EXPAND);
#define glClear_INDEX 211
#define glClear_RETURN void
#define glClear_ARG_NAMES mask
#define glClear_ARG_EXPAND GLbitfield mask
#define glClear_PACKED PACKED_glClear
#define glClear_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glClear_NOT_VOID_WRAP(...) {}
#define pack_glClear(_mask) ({ \
    glClear_PACKED *packed_data = malloc(sizeof(glClear_PACKED)); \
    packed_data->index = glClear_INDEX; \
    packed_data->args.mask = (GLbitfield)_mask; \
    (packed_call_t *)packed_data; \
})
#define call_glClear(packed, ret_v) do { \
    PACKED_glClear *unpacked = (PACKED_glClear *)packed; \
    ARGS_glClear *args = (ARGS_glClear *)&unpacked->args; \
    glClear(args->mask);; \
} while(0)
void glClear(glClear_ARG_EXPAND);
typedef void (*glClear_PTR)(glClear_ARG_EXPAND);
#define glClearAccum_INDEX 212
#define glClearAccum_RETURN void
#define glClearAccum_ARG_NAMES red, green, blue, alpha
#define glClearAccum_ARG_EXPAND GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha
#define glClearAccum_PACKED PACKED_glClearAccum
#define glClearAccum_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glClearAccum_NOT_VOID_WRAP(...) {}
#define pack_glClearAccum(_red, _green, _blue, _alpha) ({ \
    glClearAccum_PACKED *packed_data = malloc(sizeof(glClearAccum_PACKED)); \
    packed_data->index = glClearAccum_INDEX; \
    packed_data->args.red = (GLfloat)_red; \
    packed_data->args.green = (GLfloat)_green; \
    packed_data->args.blue = (GLfloat)_blue; \
    packed_data->args.alpha = (GLfloat)_alpha; \
    (packed_call_t *)packed_data; \
})
#define call_glClearAccum(packed, ret_v) do { \
    PACKED_glClearAccum *unpacked = (PACKED_glClearAccum *)packed; \
    ARGS_glClearAccum *args = (ARGS_glClearAccum *)&unpacked->args; \
    glClearAccum(args->red, args->green, args->blue, args->alpha);; \
} while(0)
void glClearAccum(glClearAccum_ARG_EXPAND);
typedef void (*glClearAccum_PTR)(glClearAccum_ARG_EXPAND);
#define glClearAccumxOES_INDEX 213
#define glClearAccumxOES_RETURN void
#define glClearAccumxOES_ARG_NAMES red, green, blue, alpha
#define glClearAccumxOES_ARG_EXPAND GLfixed red, GLfixed green, GLfixed blue, GLfixed alpha
#define glClearAccumxOES_PACKED PACKED_glClearAccumxOES
#define glClearAccumxOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glClearAccumxOES_NOT_VOID_WRAP(...) {}
#define pack_glClearAccumxOES(_red, _green, _blue, _alpha) ({ \
    glClearAccumxOES_PACKED *packed_data = malloc(sizeof(glClearAccumxOES_PACKED)); \
    packed_data->index = glClearAccumxOES_INDEX; \
    packed_data->args.red = (GLfixed)_red; \
    packed_data->args.green = (GLfixed)_green; \
    packed_data->args.blue = (GLfixed)_blue; \
    packed_data->args.alpha = (GLfixed)_alpha; \
    (packed_call_t *)packed_data; \
})
#define call_glClearAccumxOES(packed, ret_v) do { \
    PACKED_glClearAccumxOES *unpacked = (PACKED_glClearAccumxOES *)packed; \
    ARGS_glClearAccumxOES *args = (ARGS_glClearAccumxOES *)&unpacked->args; \
    glClearAccumxOES(args->red, args->green, args->blue, args->alpha);; \
} while(0)
void glClearAccumxOES(glClearAccumxOES_ARG_EXPAND);
typedef void (*glClearAccumxOES_PTR)(glClearAccumxOES_ARG_EXPAND);
#define glClearBufferData_INDEX 214
#define glClearBufferData_RETURN void
#define glClearBufferData_ARG_NAMES target, internalformat, format, type, data
#define glClearBufferData_ARG_EXPAND GLenum target, GLenum internalformat, GLenum format, GLenum type, const void * data
#define glClearBufferData_PACKED PACKED_glClearBufferData
#define glClearBufferData_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glClearBufferData_NOT_VOID_WRAP(...) {}
#define pack_glClearBufferData(_target, _internalformat, _format, _type, _data) ({ \
    glClearBufferData_PACKED *packed_data = malloc(sizeof(glClearBufferData_PACKED)); \
    packed_data->index = glClearBufferData_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.internalformat = (GLenum)_internalformat; \
    packed_data->args.format = (GLenum)_format; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.data = (void *)_data; \
    (packed_call_t *)packed_data; \
})
#define call_glClearBufferData(packed, ret_v) do { \
    PACKED_glClearBufferData *unpacked = (PACKED_glClearBufferData *)packed; \
    ARGS_glClearBufferData *args = (ARGS_glClearBufferData *)&unpacked->args; \
    glClearBufferData(args->target, args->internalformat, args->format, args->type, args->data);; \
} while(0)
void glClearBufferData(glClearBufferData_ARG_EXPAND);
typedef void (*glClearBufferData_PTR)(glClearBufferData_ARG_EXPAND);
#define glClearBufferSubData_INDEX 215
#define glClearBufferSubData_RETURN void
#define glClearBufferSubData_ARG_NAMES target, internalformat, offset, size, format, type, data
#define glClearBufferSubData_ARG_EXPAND GLenum target, GLenum internalformat, GLintptr offset, GLsizeiptr size, GLenum format, GLenum type, const void * data
#define glClearBufferSubData_PACKED PACKED_glClearBufferSubData
#define glClearBufferSubData_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glClearBufferSubData_NOT_VOID_WRAP(...) {}
#define pack_glClearBufferSubData(_target, _internalformat, _offset, _size, _format, _type, _data) ({ \
    glClearBufferSubData_PACKED *packed_data = malloc(sizeof(glClearBufferSubData_PACKED)); \
    packed_data->index = glClearBufferSubData_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.internalformat = (GLenum)_internalformat; \
    packed_data->args.offset = (GLintptr)_offset; \
    packed_data->args.size = (GLsizeiptr)_size; \
    packed_data->args.format = (GLenum)_format; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.data = (void *)_data; \
    (packed_call_t *)packed_data; \
})
#define call_glClearBufferSubData(packed, ret_v) do { \
    PACKED_glClearBufferSubData *unpacked = (PACKED_glClearBufferSubData *)packed; \
    ARGS_glClearBufferSubData *args = (ARGS_glClearBufferSubData *)&unpacked->args; \
    glClearBufferSubData(args->target, args->internalformat, args->offset, args->size, args->format, args->type, args->data);; \
} while(0)
void glClearBufferSubData(glClearBufferSubData_ARG_EXPAND);
typedef void (*glClearBufferSubData_PTR)(glClearBufferSubData_ARG_EXPAND);
#define glClearBufferfi_INDEX 216
#define glClearBufferfi_RETURN void
#define glClearBufferfi_ARG_NAMES buffer, drawbuffer, depth, stencil
#define glClearBufferfi_ARG_EXPAND GLenum buffer, GLint drawbuffer, GLfloat depth, GLint stencil
#define glClearBufferfi_PACKED PACKED_glClearBufferfi
#define glClearBufferfi_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glClearBufferfi_NOT_VOID_WRAP(...) {}
#define pack_glClearBufferfi(_buffer, _drawbuffer, _depth, _stencil) ({ \
    glClearBufferfi_PACKED *packed_data = malloc(sizeof(glClearBufferfi_PACKED)); \
    packed_data->index = glClearBufferfi_INDEX; \
    packed_data->args.buffer = (GLenum)_buffer; \
    packed_data->args.drawbuffer = (GLint)_drawbuffer; \
    packed_data->args.depth = (GLfloat)_depth; \
    packed_data->args.stencil = (GLint)_stencil; \
    (packed_call_t *)packed_data; \
})
#define call_glClearBufferfi(packed, ret_v) do { \
    PACKED_glClearBufferfi *unpacked = (PACKED_glClearBufferfi *)packed; \
    ARGS_glClearBufferfi *args = (ARGS_glClearBufferfi *)&unpacked->args; \
    glClearBufferfi(args->buffer, args->drawbuffer, args->depth, args->stencil);; \
} while(0)
void glClearBufferfi(glClearBufferfi_ARG_EXPAND);
typedef void (*glClearBufferfi_PTR)(glClearBufferfi_ARG_EXPAND);
#define glClearBufferfv_INDEX 217
#define glClearBufferfv_RETURN void
#define glClearBufferfv_ARG_NAMES buffer, drawbuffer, value
#define glClearBufferfv_ARG_EXPAND GLenum buffer, GLint drawbuffer, const GLfloat * value
#define glClearBufferfv_PACKED PACKED_glClearBufferfv
#define glClearBufferfv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glClearBufferfv_NOT_VOID_WRAP(...) {}
#define pack_glClearBufferfv(_buffer, _drawbuffer, _value) ({ \
    glClearBufferfv_PACKED *packed_data = malloc(sizeof(glClearBufferfv_PACKED)); \
    packed_data->index = glClearBufferfv_INDEX; \
    packed_data->args.buffer = (GLenum)_buffer; \
    packed_data->args.drawbuffer = (GLint)_drawbuffer; \
    packed_data->args.value = (GLfloat *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glClearBufferfv(packed, ret_v) do { \
    PACKED_glClearBufferfv *unpacked = (PACKED_glClearBufferfv *)packed; \
    ARGS_glClearBufferfv *args = (ARGS_glClearBufferfv *)&unpacked->args; \
    glClearBufferfv(args->buffer, args->drawbuffer, args->value);; \
} while(0)
void glClearBufferfv(glClearBufferfv_ARG_EXPAND);
typedef void (*glClearBufferfv_PTR)(glClearBufferfv_ARG_EXPAND);
#define glClearBufferiv_INDEX 218
#define glClearBufferiv_RETURN void
#define glClearBufferiv_ARG_NAMES buffer, drawbuffer, value
#define glClearBufferiv_ARG_EXPAND GLenum buffer, GLint drawbuffer, const GLint * value
#define glClearBufferiv_PACKED PACKED_glClearBufferiv
#define glClearBufferiv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glClearBufferiv_NOT_VOID_WRAP(...) {}
#define pack_glClearBufferiv(_buffer, _drawbuffer, _value) ({ \
    glClearBufferiv_PACKED *packed_data = malloc(sizeof(glClearBufferiv_PACKED)); \
    packed_data->index = glClearBufferiv_INDEX; \
    packed_data->args.buffer = (GLenum)_buffer; \
    packed_data->args.drawbuffer = (GLint)_drawbuffer; \
    packed_data->args.value = (GLint *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glClearBufferiv(packed, ret_v) do { \
    PACKED_glClearBufferiv *unpacked = (PACKED_glClearBufferiv *)packed; \
    ARGS_glClearBufferiv *args = (ARGS_glClearBufferiv *)&unpacked->args; \
    glClearBufferiv(args->buffer, args->drawbuffer, args->value);; \
} while(0)
void glClearBufferiv(glClearBufferiv_ARG_EXPAND);
typedef void (*glClearBufferiv_PTR)(glClearBufferiv_ARG_EXPAND);
#define glClearBufferuiv_INDEX 219
#define glClearBufferuiv_RETURN void
#define glClearBufferuiv_ARG_NAMES buffer, drawbuffer, value
#define glClearBufferuiv_ARG_EXPAND GLenum buffer, GLint drawbuffer, const GLuint * value
#define glClearBufferuiv_PACKED PACKED_glClearBufferuiv
#define glClearBufferuiv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glClearBufferuiv_NOT_VOID_WRAP(...) {}
#define pack_glClearBufferuiv(_buffer, _drawbuffer, _value) ({ \
    glClearBufferuiv_PACKED *packed_data = malloc(sizeof(glClearBufferuiv_PACKED)); \
    packed_data->index = glClearBufferuiv_INDEX; \
    packed_data->args.buffer = (GLenum)_buffer; \
    packed_data->args.drawbuffer = (GLint)_drawbuffer; \
    packed_data->args.value = (GLuint *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glClearBufferuiv(packed, ret_v) do { \
    PACKED_glClearBufferuiv *unpacked = (PACKED_glClearBufferuiv *)packed; \
    ARGS_glClearBufferuiv *args = (ARGS_glClearBufferuiv *)&unpacked->args; \
    glClearBufferuiv(args->buffer, args->drawbuffer, args->value);; \
} while(0)
void glClearBufferuiv(glClearBufferuiv_ARG_EXPAND);
typedef void (*glClearBufferuiv_PTR)(glClearBufferuiv_ARG_EXPAND);
#define glClearColor_INDEX 220
#define glClearColor_RETURN void
#define glClearColor_ARG_NAMES red, green, blue, alpha
#define glClearColor_ARG_EXPAND GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha
#define glClearColor_PACKED PACKED_glClearColor
#define glClearColor_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glClearColor_NOT_VOID_WRAP(...) {}
#define pack_glClearColor(_red, _green, _blue, _alpha) ({ \
    glClearColor_PACKED *packed_data = malloc(sizeof(glClearColor_PACKED)); \
    packed_data->index = glClearColor_INDEX; \
    packed_data->args.red = (GLclampf)_red; \
    packed_data->args.green = (GLclampf)_green; \
    packed_data->args.blue = (GLclampf)_blue; \
    packed_data->args.alpha = (GLclampf)_alpha; \
    (packed_call_t *)packed_data; \
})
#define call_glClearColor(packed, ret_v) do { \
    PACKED_glClearColor *unpacked = (PACKED_glClearColor *)packed; \
    ARGS_glClearColor *args = (ARGS_glClearColor *)&unpacked->args; \
    glClearColor(args->red, args->green, args->blue, args->alpha);; \
} while(0)
void glClearColor(glClearColor_ARG_EXPAND);
typedef void (*glClearColor_PTR)(glClearColor_ARG_EXPAND);
#define glClearColorIiEXT_INDEX 221
#define glClearColorIiEXT_RETURN void
#define glClearColorIiEXT_ARG_NAMES red, green, blue, alpha
#define glClearColorIiEXT_ARG_EXPAND GLint red, GLint green, GLint blue, GLint alpha
#define glClearColorIiEXT_PACKED PACKED_glClearColorIiEXT
#define glClearColorIiEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glClearColorIiEXT_NOT_VOID_WRAP(...) {}
#define pack_glClearColorIiEXT(_red, _green, _blue, _alpha) ({ \
    glClearColorIiEXT_PACKED *packed_data = malloc(sizeof(glClearColorIiEXT_PACKED)); \
    packed_data->index = glClearColorIiEXT_INDEX; \
    packed_data->args.red = (GLint)_red; \
    packed_data->args.green = (GLint)_green; \
    packed_data->args.blue = (GLint)_blue; \
    packed_data->args.alpha = (GLint)_alpha; \
    (packed_call_t *)packed_data; \
})
#define call_glClearColorIiEXT(packed, ret_v) do { \
    PACKED_glClearColorIiEXT *unpacked = (PACKED_glClearColorIiEXT *)packed; \
    ARGS_glClearColorIiEXT *args = (ARGS_glClearColorIiEXT *)&unpacked->args; \
    glClearColorIiEXT(args->red, args->green, args->blue, args->alpha);; \
} while(0)
void glClearColorIiEXT(glClearColorIiEXT_ARG_EXPAND);
typedef void (*glClearColorIiEXT_PTR)(glClearColorIiEXT_ARG_EXPAND);
#define glClearColorIuiEXT_INDEX 222
#define glClearColorIuiEXT_RETURN void
#define glClearColorIuiEXT_ARG_NAMES red, green, blue, alpha
#define glClearColorIuiEXT_ARG_EXPAND GLuint red, GLuint green, GLuint blue, GLuint alpha
#define glClearColorIuiEXT_PACKED PACKED_glClearColorIuiEXT
#define glClearColorIuiEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glClearColorIuiEXT_NOT_VOID_WRAP(...) {}
#define pack_glClearColorIuiEXT(_red, _green, _blue, _alpha) ({ \
    glClearColorIuiEXT_PACKED *packed_data = malloc(sizeof(glClearColorIuiEXT_PACKED)); \
    packed_data->index = glClearColorIuiEXT_INDEX; \
    packed_data->args.red = (GLuint)_red; \
    packed_data->args.green = (GLuint)_green; \
    packed_data->args.blue = (GLuint)_blue; \
    packed_data->args.alpha = (GLuint)_alpha; \
    (packed_call_t *)packed_data; \
})
#define call_glClearColorIuiEXT(packed, ret_v) do { \
    PACKED_glClearColorIuiEXT *unpacked = (PACKED_glClearColorIuiEXT *)packed; \
    ARGS_glClearColorIuiEXT *args = (ARGS_glClearColorIuiEXT *)&unpacked->args; \
    glClearColorIuiEXT(args->red, args->green, args->blue, args->alpha);; \
} while(0)
void glClearColorIuiEXT(glClearColorIuiEXT_ARG_EXPAND);
typedef void (*glClearColorIuiEXT_PTR)(glClearColorIuiEXT_ARG_EXPAND);
#define glClearColorx_INDEX 223
#define glClearColorx_RETURN void
#define glClearColorx_ARG_NAMES red, green, blue, alpha
#define glClearColorx_ARG_EXPAND GLclampx red, GLclampx green, GLclampx blue, GLclampx alpha
#define glClearColorx_PACKED PACKED_glClearColorx
#define glClearColorx_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glClearColorx_NOT_VOID_WRAP(...) {}
#define pack_glClearColorx(_red, _green, _blue, _alpha) ({ \
    glClearColorx_PACKED *packed_data = malloc(sizeof(glClearColorx_PACKED)); \
    packed_data->index = glClearColorx_INDEX; \
    packed_data->args.red = (GLclampx)_red; \
    packed_data->args.green = (GLclampx)_green; \
    packed_data->args.blue = (GLclampx)_blue; \
    packed_data->args.alpha = (GLclampx)_alpha; \
    (packed_call_t *)packed_data; \
})
#define call_glClearColorx(packed, ret_v) do { \
    PACKED_glClearColorx *unpacked = (PACKED_glClearColorx *)packed; \
    ARGS_glClearColorx *args = (ARGS_glClearColorx *)&unpacked->args; \
    glClearColorx(args->red, args->green, args->blue, args->alpha);; \
} while(0)
void glClearColorx(glClearColorx_ARG_EXPAND);
typedef void (*glClearColorx_PTR)(glClearColorx_ARG_EXPAND);
#define glClearColorxOES_INDEX 224
#define glClearColorxOES_RETURN void
#define glClearColorxOES_ARG_NAMES red, green, blue, alpha
#define glClearColorxOES_ARG_EXPAND GLfixed red, GLfixed green, GLfixed blue, GLfixed alpha
#define glClearColorxOES_PACKED PACKED_glClearColorxOES
#define glClearColorxOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glClearColorxOES_NOT_VOID_WRAP(...) {}
#define pack_glClearColorxOES(_red, _green, _blue, _alpha) ({ \
    glClearColorxOES_PACKED *packed_data = malloc(sizeof(glClearColorxOES_PACKED)); \
    packed_data->index = glClearColorxOES_INDEX; \
    packed_data->args.red = (GLfixed)_red; \
    packed_data->args.green = (GLfixed)_green; \
    packed_data->args.blue = (GLfixed)_blue; \
    packed_data->args.alpha = (GLfixed)_alpha; \
    (packed_call_t *)packed_data; \
})
#define call_glClearColorxOES(packed, ret_v) do { \
    PACKED_glClearColorxOES *unpacked = (PACKED_glClearColorxOES *)packed; \
    ARGS_glClearColorxOES *args = (ARGS_glClearColorxOES *)&unpacked->args; \
    glClearColorxOES(args->red, args->green, args->blue, args->alpha);; \
} while(0)
void glClearColorxOES(glClearColorxOES_ARG_EXPAND);
typedef void (*glClearColorxOES_PTR)(glClearColorxOES_ARG_EXPAND);
#define glClearDepth_INDEX 225
#define glClearDepth_RETURN void
#define glClearDepth_ARG_NAMES depth
#define glClearDepth_ARG_EXPAND GLdouble depth
#define glClearDepth_PACKED PACKED_glClearDepth
#define glClearDepth_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glClearDepth_NOT_VOID_WRAP(...) {}
#define pack_glClearDepth(_depth) ({ \
    glClearDepth_PACKED *packed_data = malloc(sizeof(glClearDepth_PACKED)); \
    packed_data->index = glClearDepth_INDEX; \
    packed_data->args.depth = (GLdouble)_depth; \
    (packed_call_t *)packed_data; \
})
#define call_glClearDepth(packed, ret_v) do { \
    PACKED_glClearDepth *unpacked = (PACKED_glClearDepth *)packed; \
    ARGS_glClearDepth *args = (ARGS_glClearDepth *)&unpacked->args; \
    glClearDepth(args->depth);; \
} while(0)
void glClearDepth(glClearDepth_ARG_EXPAND);
typedef void (*glClearDepth_PTR)(glClearDepth_ARG_EXPAND);
#define glClearDepthdNV_INDEX 226
#define glClearDepthdNV_RETURN void
#define glClearDepthdNV_ARG_NAMES depth
#define glClearDepthdNV_ARG_EXPAND GLdouble depth
#define glClearDepthdNV_PACKED PACKED_glClearDepthdNV
#define glClearDepthdNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glClearDepthdNV_NOT_VOID_WRAP(...) {}
#define pack_glClearDepthdNV(_depth) ({ \
    glClearDepthdNV_PACKED *packed_data = malloc(sizeof(glClearDepthdNV_PACKED)); \
    packed_data->index = glClearDepthdNV_INDEX; \
    packed_data->args.depth = (GLdouble)_depth; \
    (packed_call_t *)packed_data; \
})
#define call_glClearDepthdNV(packed, ret_v) do { \
    PACKED_glClearDepthdNV *unpacked = (PACKED_glClearDepthdNV *)packed; \
    ARGS_glClearDepthdNV *args = (ARGS_glClearDepthdNV *)&unpacked->args; \
    glClearDepthdNV(args->depth);; \
} while(0)
void glClearDepthdNV(glClearDepthdNV_ARG_EXPAND);
typedef void (*glClearDepthdNV_PTR)(glClearDepthdNV_ARG_EXPAND);
#define glClearDepthf_INDEX 227
#define glClearDepthf_RETURN void
#define glClearDepthf_ARG_NAMES depth
#define glClearDepthf_ARG_EXPAND GLclampf depth
#define glClearDepthf_PACKED PACKED_glClearDepthf
#define glClearDepthf_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glClearDepthf_NOT_VOID_WRAP(...) {}
#define pack_glClearDepthf(_depth) ({ \
    glClearDepthf_PACKED *packed_data = malloc(sizeof(glClearDepthf_PACKED)); \
    packed_data->index = glClearDepthf_INDEX; \
    packed_data->args.depth = (GLclampf)_depth; \
    (packed_call_t *)packed_data; \
})
#define call_glClearDepthf(packed, ret_v) do { \
    PACKED_glClearDepthf *unpacked = (PACKED_glClearDepthf *)packed; \
    ARGS_glClearDepthf *args = (ARGS_glClearDepthf *)&unpacked->args; \
    glClearDepthf(args->depth);; \
} while(0)
void glClearDepthf(glClearDepthf_ARG_EXPAND);
typedef void (*glClearDepthf_PTR)(glClearDepthf_ARG_EXPAND);
#define glClearDepthfOES_INDEX 228
#define glClearDepthfOES_RETURN void
#define glClearDepthfOES_ARG_NAMES depth
#define glClearDepthfOES_ARG_EXPAND GLclampf depth
#define glClearDepthfOES_PACKED PACKED_glClearDepthfOES
#define glClearDepthfOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glClearDepthfOES_NOT_VOID_WRAP(...) {}
#define pack_glClearDepthfOES(_depth) ({ \
    glClearDepthfOES_PACKED *packed_data = malloc(sizeof(glClearDepthfOES_PACKED)); \
    packed_data->index = glClearDepthfOES_INDEX; \
    packed_data->args.depth = (GLclampf)_depth; \
    (packed_call_t *)packed_data; \
})
#define call_glClearDepthfOES(packed, ret_v) do { \
    PACKED_glClearDepthfOES *unpacked = (PACKED_glClearDepthfOES *)packed; \
    ARGS_glClearDepthfOES *args = (ARGS_glClearDepthfOES *)&unpacked->args; \
    glClearDepthfOES(args->depth);; \
} while(0)
void glClearDepthfOES(glClearDepthfOES_ARG_EXPAND);
typedef void (*glClearDepthfOES_PTR)(glClearDepthfOES_ARG_EXPAND);
#define glClearDepthx_INDEX 229
#define glClearDepthx_RETURN void
#define glClearDepthx_ARG_NAMES depth
#define glClearDepthx_ARG_EXPAND GLclampx depth
#define glClearDepthx_PACKED PACKED_glClearDepthx
#define glClearDepthx_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glClearDepthx_NOT_VOID_WRAP(...) {}
#define pack_glClearDepthx(_depth) ({ \
    glClearDepthx_PACKED *packed_data = malloc(sizeof(glClearDepthx_PACKED)); \
    packed_data->index = glClearDepthx_INDEX; \
    packed_data->args.depth = (GLclampx)_depth; \
    (packed_call_t *)packed_data; \
})
#define call_glClearDepthx(packed, ret_v) do { \
    PACKED_glClearDepthx *unpacked = (PACKED_glClearDepthx *)packed; \
    ARGS_glClearDepthx *args = (ARGS_glClearDepthx *)&unpacked->args; \
    glClearDepthx(args->depth);; \
} while(0)
void glClearDepthx(glClearDepthx_ARG_EXPAND);
typedef void (*glClearDepthx_PTR)(glClearDepthx_ARG_EXPAND);
#define glClearDepthxOES_INDEX 230
#define glClearDepthxOES_RETURN void
#define glClearDepthxOES_ARG_NAMES depth
#define glClearDepthxOES_ARG_EXPAND GLfixed depth
#define glClearDepthxOES_PACKED PACKED_glClearDepthxOES
#define glClearDepthxOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glClearDepthxOES_NOT_VOID_WRAP(...) {}
#define pack_glClearDepthxOES(_depth) ({ \
    glClearDepthxOES_PACKED *packed_data = malloc(sizeof(glClearDepthxOES_PACKED)); \
    packed_data->index = glClearDepthxOES_INDEX; \
    packed_data->args.depth = (GLfixed)_depth; \
    (packed_call_t *)packed_data; \
})
#define call_glClearDepthxOES(packed, ret_v) do { \
    PACKED_glClearDepthxOES *unpacked = (PACKED_glClearDepthxOES *)packed; \
    ARGS_glClearDepthxOES *args = (ARGS_glClearDepthxOES *)&unpacked->args; \
    glClearDepthxOES(args->depth);; \
} while(0)
void glClearDepthxOES(glClearDepthxOES_ARG_EXPAND);
typedef void (*glClearDepthxOES_PTR)(glClearDepthxOES_ARG_EXPAND);
#define glClearIndex_INDEX 231
#define glClearIndex_RETURN void
#define glClearIndex_ARG_NAMES c
#define glClearIndex_ARG_EXPAND GLfloat c
#define glClearIndex_PACKED PACKED_glClearIndex
#define glClearIndex_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glClearIndex_NOT_VOID_WRAP(...) {}
#define pack_glClearIndex(_c) ({ \
    glClearIndex_PACKED *packed_data = malloc(sizeof(glClearIndex_PACKED)); \
    packed_data->index = glClearIndex_INDEX; \
    packed_data->args.c = (GLfloat)_c; \
    (packed_call_t *)packed_data; \
})
#define call_glClearIndex(packed, ret_v) do { \
    PACKED_glClearIndex *unpacked = (PACKED_glClearIndex *)packed; \
    ARGS_glClearIndex *args = (ARGS_glClearIndex *)&unpacked->args; \
    glClearIndex(args->c);; \
} while(0)
void glClearIndex(glClearIndex_ARG_EXPAND);
typedef void (*glClearIndex_PTR)(glClearIndex_ARG_EXPAND);
#define glClearNamedBufferDataEXT_INDEX 232
#define glClearNamedBufferDataEXT_RETURN void
#define glClearNamedBufferDataEXT_ARG_NAMES buffer, internalformat, format, type, data
#define glClearNamedBufferDataEXT_ARG_EXPAND GLuint buffer, GLenum internalformat, GLenum format, GLenum type, const void * data
#define glClearNamedBufferDataEXT_PACKED PACKED_glClearNamedBufferDataEXT
#define glClearNamedBufferDataEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glClearNamedBufferDataEXT_NOT_VOID_WRAP(...) {}
#define pack_glClearNamedBufferDataEXT(_buffer, _internalformat, _format, _type, _data) ({ \
    glClearNamedBufferDataEXT_PACKED *packed_data = malloc(sizeof(glClearNamedBufferDataEXT_PACKED)); \
    packed_data->index = glClearNamedBufferDataEXT_INDEX; \
    packed_data->args.buffer = (GLuint)_buffer; \
    packed_data->args.internalformat = (GLenum)_internalformat; \
    packed_data->args.format = (GLenum)_format; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.data = (void *)_data; \
    (packed_call_t *)packed_data; \
})
#define call_glClearNamedBufferDataEXT(packed, ret_v) do { \
    PACKED_glClearNamedBufferDataEXT *unpacked = (PACKED_glClearNamedBufferDataEXT *)packed; \
    ARGS_glClearNamedBufferDataEXT *args = (ARGS_glClearNamedBufferDataEXT *)&unpacked->args; \
    glClearNamedBufferDataEXT(args->buffer, args->internalformat, args->format, args->type, args->data);; \
} while(0)
void glClearNamedBufferDataEXT(glClearNamedBufferDataEXT_ARG_EXPAND);
typedef void (*glClearNamedBufferDataEXT_PTR)(glClearNamedBufferDataEXT_ARG_EXPAND);
#define glClearNamedBufferSubDataEXT_INDEX 233
#define glClearNamedBufferSubDataEXT_RETURN void
#define glClearNamedBufferSubDataEXT_ARG_NAMES buffer, internalformat, format, type, offset, size, data
#define glClearNamedBufferSubDataEXT_ARG_EXPAND GLuint buffer, GLenum internalformat, GLenum format, GLenum type, GLsizeiptr offset, GLsizeiptr size, const void * data
#define glClearNamedBufferSubDataEXT_PACKED PACKED_glClearNamedBufferSubDataEXT
#define glClearNamedBufferSubDataEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glClearNamedBufferSubDataEXT_NOT_VOID_WRAP(...) {}
#define pack_glClearNamedBufferSubDataEXT(_buffer, _internalformat, _format, _type, _offset, _size, _data) ({ \
    glClearNamedBufferSubDataEXT_PACKED *packed_data = malloc(sizeof(glClearNamedBufferSubDataEXT_PACKED)); \
    packed_data->index = glClearNamedBufferSubDataEXT_INDEX; \
    packed_data->args.buffer = (GLuint)_buffer; \
    packed_data->args.internalformat = (GLenum)_internalformat; \
    packed_data->args.format = (GLenum)_format; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.offset = (GLsizeiptr)_offset; \
    packed_data->args.size = (GLsizeiptr)_size; \
    packed_data->args.data = (void *)_data; \
    (packed_call_t *)packed_data; \
})
#define call_glClearNamedBufferSubDataEXT(packed, ret_v) do { \
    PACKED_glClearNamedBufferSubDataEXT *unpacked = (PACKED_glClearNamedBufferSubDataEXT *)packed; \
    ARGS_glClearNamedBufferSubDataEXT *args = (ARGS_glClearNamedBufferSubDataEXT *)&unpacked->args; \
    glClearNamedBufferSubDataEXT(args->buffer, args->internalformat, args->format, args->type, args->offset, args->size, args->data);; \
} while(0)
void glClearNamedBufferSubDataEXT(glClearNamedBufferSubDataEXT_ARG_EXPAND);
typedef void (*glClearNamedBufferSubDataEXT_PTR)(glClearNamedBufferSubDataEXT_ARG_EXPAND);
#define glClearStencil_INDEX 234
#define glClearStencil_RETURN void
#define glClearStencil_ARG_NAMES s
#define glClearStencil_ARG_EXPAND GLint s
#define glClearStencil_PACKED PACKED_glClearStencil
#define glClearStencil_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glClearStencil_NOT_VOID_WRAP(...) {}
#define pack_glClearStencil(_s) ({ \
    glClearStencil_PACKED *packed_data = malloc(sizeof(glClearStencil_PACKED)); \
    packed_data->index = glClearStencil_INDEX; \
    packed_data->args.s = (GLint)_s; \
    (packed_call_t *)packed_data; \
})
#define call_glClearStencil(packed, ret_v) do { \
    PACKED_glClearStencil *unpacked = (PACKED_glClearStencil *)packed; \
    ARGS_glClearStencil *args = (ARGS_glClearStencil *)&unpacked->args; \
    glClearStencil(args->s);; \
} while(0)
void glClearStencil(glClearStencil_ARG_EXPAND);
typedef void (*glClearStencil_PTR)(glClearStencil_ARG_EXPAND);
#define glClientActiveTexture_INDEX 235
#define glClientActiveTexture_RETURN void
#define glClientActiveTexture_ARG_NAMES texture
#define glClientActiveTexture_ARG_EXPAND GLenum texture
#define glClientActiveTexture_PACKED PACKED_glClientActiveTexture
#define glClientActiveTexture_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glClientActiveTexture_NOT_VOID_WRAP(...) {}
#define pack_glClientActiveTexture(_texture) ({ \
    glClientActiveTexture_PACKED *packed_data = malloc(sizeof(glClientActiveTexture_PACKED)); \
    packed_data->index = glClientActiveTexture_INDEX; \
    packed_data->args.texture = (GLenum)_texture; \
    (packed_call_t *)packed_data; \
})
#define call_glClientActiveTexture(packed, ret_v) do { \
    PACKED_glClientActiveTexture *unpacked = (PACKED_glClientActiveTexture *)packed; \
    ARGS_glClientActiveTexture *args = (ARGS_glClientActiveTexture *)&unpacked->args; \
    glClientActiveTexture(args->texture);; \
} while(0)
void glClientActiveTexture(glClientActiveTexture_ARG_EXPAND);
typedef void (*glClientActiveTexture_PTR)(glClientActiveTexture_ARG_EXPAND);
#define glClientActiveTextureARB_INDEX 236
#define glClientActiveTextureARB_RETURN void
#define glClientActiveTextureARB_ARG_NAMES texture
#define glClientActiveTextureARB_ARG_EXPAND GLenum texture
#define glClientActiveTextureARB_PACKED PACKED_glClientActiveTextureARB
#define glClientActiveTextureARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glClientActiveTextureARB_NOT_VOID_WRAP(...) {}
#define pack_glClientActiveTextureARB(_texture) ({ \
    glClientActiveTextureARB_PACKED *packed_data = malloc(sizeof(glClientActiveTextureARB_PACKED)); \
    packed_data->index = glClientActiveTextureARB_INDEX; \
    packed_data->args.texture = (GLenum)_texture; \
    (packed_call_t *)packed_data; \
})
#define call_glClientActiveTextureARB(packed, ret_v) do { \
    PACKED_glClientActiveTextureARB *unpacked = (PACKED_glClientActiveTextureARB *)packed; \
    ARGS_glClientActiveTextureARB *args = (ARGS_glClientActiveTextureARB *)&unpacked->args; \
    glClientActiveTextureARB(args->texture);; \
} while(0)
void glClientActiveTextureARB(glClientActiveTextureARB_ARG_EXPAND);
typedef void (*glClientActiveTextureARB_PTR)(glClientActiveTextureARB_ARG_EXPAND);
#define glClientActiveVertexStreamATI_INDEX 237
#define glClientActiveVertexStreamATI_RETURN void
#define glClientActiveVertexStreamATI_ARG_NAMES stream
#define glClientActiveVertexStreamATI_ARG_EXPAND GLenum stream
#define glClientActiveVertexStreamATI_PACKED PACKED_glClientActiveVertexStreamATI
#define glClientActiveVertexStreamATI_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glClientActiveVertexStreamATI_NOT_VOID_WRAP(...) {}
#define pack_glClientActiveVertexStreamATI(_stream) ({ \
    glClientActiveVertexStreamATI_PACKED *packed_data = malloc(sizeof(glClientActiveVertexStreamATI_PACKED)); \
    packed_data->index = glClientActiveVertexStreamATI_INDEX; \
    packed_data->args.stream = (GLenum)_stream; \
    (packed_call_t *)packed_data; \
})
#define call_glClientActiveVertexStreamATI(packed, ret_v) do { \
    PACKED_glClientActiveVertexStreamATI *unpacked = (PACKED_glClientActiveVertexStreamATI *)packed; \
    ARGS_glClientActiveVertexStreamATI *args = (ARGS_glClientActiveVertexStreamATI *)&unpacked->args; \
    glClientActiveVertexStreamATI(args->stream);; \
} while(0)
void glClientActiveVertexStreamATI(glClientActiveVertexStreamATI_ARG_EXPAND);
typedef void (*glClientActiveVertexStreamATI_PTR)(glClientActiveVertexStreamATI_ARG_EXPAND);
#define glClientAttribDefaultEXT_INDEX 238
#define glClientAttribDefaultEXT_RETURN void
#define glClientAttribDefaultEXT_ARG_NAMES mask
#define glClientAttribDefaultEXT_ARG_EXPAND GLbitfield mask
#define glClientAttribDefaultEXT_PACKED PACKED_glClientAttribDefaultEXT
#define glClientAttribDefaultEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glClientAttribDefaultEXT_NOT_VOID_WRAP(...) {}
#define pack_glClientAttribDefaultEXT(_mask) ({ \
    glClientAttribDefaultEXT_PACKED *packed_data = malloc(sizeof(glClientAttribDefaultEXT_PACKED)); \
    packed_data->index = glClientAttribDefaultEXT_INDEX; \
    packed_data->args.mask = (GLbitfield)_mask; \
    (packed_call_t *)packed_data; \
})
#define call_glClientAttribDefaultEXT(packed, ret_v) do { \
    PACKED_glClientAttribDefaultEXT *unpacked = (PACKED_glClientAttribDefaultEXT *)packed; \
    ARGS_glClientAttribDefaultEXT *args = (ARGS_glClientAttribDefaultEXT *)&unpacked->args; \
    glClientAttribDefaultEXT(args->mask);; \
} while(0)
void glClientAttribDefaultEXT(glClientAttribDefaultEXT_ARG_EXPAND);
typedef void (*glClientAttribDefaultEXT_PTR)(glClientAttribDefaultEXT_ARG_EXPAND);
#define glClientWaitSync_INDEX 239
#define glClientWaitSync_RETURN GLenum
#define glClientWaitSync_ARG_NAMES sync, flags, timeout
#define glClientWaitSync_ARG_EXPAND GLsync sync, GLbitfield flags, GLuint64 timeout
#define glClientWaitSync_PACKED PACKED_glClientWaitSync
#define glClientWaitSync_VOID_ONLY_WRAP(...) {}
#define glClientWaitSync_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glClientWaitSync(_sync, _flags, _timeout) ({ \
    glClientWaitSync_PACKED *packed_data = malloc(sizeof(glClientWaitSync_PACKED)); \
    packed_data->index = glClientWaitSync_INDEX; \
    packed_data->args.sync = (GLsync)_sync; \
    packed_data->args.flags = (GLbitfield)_flags; \
    packed_data->args.timeout = (GLuint64)_timeout; \
    (packed_call_t *)packed_data; \
})
#define call_glClientWaitSync(packed, ret_v) do { \
    PACKED_glClientWaitSync *unpacked = (PACKED_glClientWaitSync *)packed; \
    ARGS_glClientWaitSync *args = (ARGS_glClientWaitSync *)&unpacked->args; \
    GLenum *ret = (GLenum *)ret_v; \
    if (ret != NULL) { \
        *ret = glClientWaitSync(args->sync, args->flags, args->timeout);; \
    } else { \
        glClientWaitSync(args->sync, args->flags, args->timeout);; \
    } \
} while(0)
GLenum glClientWaitSync(glClientWaitSync_ARG_EXPAND);
typedef GLenum (*glClientWaitSync_PTR)(glClientWaitSync_ARG_EXPAND);
#define glClipPlane_INDEX 240
#define glClipPlane_RETURN void
#define glClipPlane_ARG_NAMES plane, equation
#define glClipPlane_ARG_EXPAND GLenum plane, const GLdouble * equation
#define glClipPlane_PACKED PACKED_glClipPlane
#define glClipPlane_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glClipPlane_NOT_VOID_WRAP(...) {}
#define pack_glClipPlane(_plane, _equation) ({ \
    glClipPlane_PACKED *packed_data = malloc(sizeof(glClipPlane_PACKED)); \
    packed_data->index = glClipPlane_INDEX; \
    packed_data->args.plane = (GLenum)_plane; \
    packed_data->args.equation = (GLdouble *)_equation; \
    (packed_call_t *)packed_data; \
})
#define call_glClipPlane(packed, ret_v) do { \
    PACKED_glClipPlane *unpacked = (PACKED_glClipPlane *)packed; \
    ARGS_glClipPlane *args = (ARGS_glClipPlane *)&unpacked->args; \
    glClipPlane(args->plane, args->equation);; \
} while(0)
void glClipPlane(glClipPlane_ARG_EXPAND);
typedef void (*glClipPlane_PTR)(glClipPlane_ARG_EXPAND);
#define glClipPlanef_INDEX 241
#define glClipPlanef_RETURN void
#define glClipPlanef_ARG_NAMES plane, equation
#define glClipPlanef_ARG_EXPAND GLenum plane, const GLfloat * equation
#define glClipPlanef_PACKED PACKED_glClipPlanef
#define glClipPlanef_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glClipPlanef_NOT_VOID_WRAP(...) {}
#define pack_glClipPlanef(_plane, _equation) ({ \
    glClipPlanef_PACKED *packed_data = malloc(sizeof(glClipPlanef_PACKED)); \
    packed_data->index = glClipPlanef_INDEX; \
    packed_data->args.plane = (GLenum)_plane; \
    packed_data->args.equation = (GLfloat *)_equation; \
    (packed_call_t *)packed_data; \
})
#define call_glClipPlanef(packed, ret_v) do { \
    PACKED_glClipPlanef *unpacked = (PACKED_glClipPlanef *)packed; \
    ARGS_glClipPlanef *args = (ARGS_glClipPlanef *)&unpacked->args; \
    glClipPlanef(args->plane, args->equation);; \
} while(0)
void glClipPlanef(glClipPlanef_ARG_EXPAND);
typedef void (*glClipPlanef_PTR)(glClipPlanef_ARG_EXPAND);
#define glClipPlanefOES_INDEX 242
#define glClipPlanefOES_RETURN void
#define glClipPlanefOES_ARG_NAMES plane, equation
#define glClipPlanefOES_ARG_EXPAND GLenum plane, const GLfloat * equation
#define glClipPlanefOES_PACKED PACKED_glClipPlanefOES
#define glClipPlanefOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glClipPlanefOES_NOT_VOID_WRAP(...) {}
#define pack_glClipPlanefOES(_plane, _equation) ({ \
    glClipPlanefOES_PACKED *packed_data = malloc(sizeof(glClipPlanefOES_PACKED)); \
    packed_data->index = glClipPlanefOES_INDEX; \
    packed_data->args.plane = (GLenum)_plane; \
    packed_data->args.equation = (GLfloat *)_equation; \
    (packed_call_t *)packed_data; \
})
#define call_glClipPlanefOES(packed, ret_v) do { \
    PACKED_glClipPlanefOES *unpacked = (PACKED_glClipPlanefOES *)packed; \
    ARGS_glClipPlanefOES *args = (ARGS_glClipPlanefOES *)&unpacked->args; \
    glClipPlanefOES(args->plane, args->equation);; \
} while(0)
void glClipPlanefOES(glClipPlanefOES_ARG_EXPAND);
typedef void (*glClipPlanefOES_PTR)(glClipPlanefOES_ARG_EXPAND);
#define glClipPlanex_INDEX 243
#define glClipPlanex_RETURN void
#define glClipPlanex_ARG_NAMES plane, equation
#define glClipPlanex_ARG_EXPAND GLenum plane, const GLfixed * equation
#define glClipPlanex_PACKED PACKED_glClipPlanex
#define glClipPlanex_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glClipPlanex_NOT_VOID_WRAP(...) {}
#define pack_glClipPlanex(_plane, _equation) ({ \
    glClipPlanex_PACKED *packed_data = malloc(sizeof(glClipPlanex_PACKED)); \
    packed_data->index = glClipPlanex_INDEX; \
    packed_data->args.plane = (GLenum)_plane; \
    packed_data->args.equation = (GLfixed *)_equation; \
    (packed_call_t *)packed_data; \
})
#define call_glClipPlanex(packed, ret_v) do { \
    PACKED_glClipPlanex *unpacked = (PACKED_glClipPlanex *)packed; \
    ARGS_glClipPlanex *args = (ARGS_glClipPlanex *)&unpacked->args; \
    glClipPlanex(args->plane, args->equation);; \
} while(0)
void glClipPlanex(glClipPlanex_ARG_EXPAND);
typedef void (*glClipPlanex_PTR)(glClipPlanex_ARG_EXPAND);
#define glClipPlanexOES_INDEX 244
#define glClipPlanexOES_RETURN void
#define glClipPlanexOES_ARG_NAMES plane, equation
#define glClipPlanexOES_ARG_EXPAND GLenum plane, const GLfixed * equation
#define glClipPlanexOES_PACKED PACKED_glClipPlanexOES
#define glClipPlanexOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glClipPlanexOES_NOT_VOID_WRAP(...) {}
#define pack_glClipPlanexOES(_plane, _equation) ({ \
    glClipPlanexOES_PACKED *packed_data = malloc(sizeof(glClipPlanexOES_PACKED)); \
    packed_data->index = glClipPlanexOES_INDEX; \
    packed_data->args.plane = (GLenum)_plane; \
    packed_data->args.equation = (GLfixed *)_equation; \
    (packed_call_t *)packed_data; \
})
#define call_glClipPlanexOES(packed, ret_v) do { \
    PACKED_glClipPlanexOES *unpacked = (PACKED_glClipPlanexOES *)packed; \
    ARGS_glClipPlanexOES *args = (ARGS_glClipPlanexOES *)&unpacked->args; \
    glClipPlanexOES(args->plane, args->equation);; \
} while(0)
void glClipPlanexOES(glClipPlanexOES_ARG_EXPAND);
typedef void (*glClipPlanexOES_PTR)(glClipPlanexOES_ARG_EXPAND);
#define glColor3b_INDEX 245
#define glColor3b_RETURN void
#define glColor3b_ARG_NAMES red, green, blue
#define glColor3b_ARG_EXPAND GLbyte red, GLbyte green, GLbyte blue
#define glColor3b_PACKED PACKED_glColor3b
#define glColor3b_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glColor3b_NOT_VOID_WRAP(...) {}
#define pack_glColor3b(_red, _green, _blue) ({ \
    glColor3b_PACKED *packed_data = malloc(sizeof(glColor3b_PACKED)); \
    packed_data->index = glColor3b_INDEX; \
    packed_data->args.red = (GLbyte)_red; \
    packed_data->args.green = (GLbyte)_green; \
    packed_data->args.blue = (GLbyte)_blue; \
    (packed_call_t *)packed_data; \
})
#define call_glColor3b(packed, ret_v) do { \
    PACKED_glColor3b *unpacked = (PACKED_glColor3b *)packed; \
    ARGS_glColor3b *args = (ARGS_glColor3b *)&unpacked->args; \
    glColor3b(args->red, args->green, args->blue);; \
} while(0)
void glColor3b(glColor3b_ARG_EXPAND);
typedef void (*glColor3b_PTR)(glColor3b_ARG_EXPAND);
#define glColor3bv_INDEX 246
#define glColor3bv_RETURN void
#define glColor3bv_ARG_NAMES v
#define glColor3bv_ARG_EXPAND const GLbyte * v
#define glColor3bv_PACKED PACKED_glColor3bv
#define glColor3bv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glColor3bv_NOT_VOID_WRAP(...) {}
#define pack_glColor3bv(_v) ({ \
    glColor3bv_PACKED *packed_data = malloc(sizeof(glColor3bv_PACKED)); \
    packed_data->index = glColor3bv_INDEX; \
    packed_data->args.v = (GLbyte *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glColor3bv(packed, ret_v) do { \
    PACKED_glColor3bv *unpacked = (PACKED_glColor3bv *)packed; \
    ARGS_glColor3bv *args = (ARGS_glColor3bv *)&unpacked->args; \
    glColor3bv(args->v);; \
} while(0)
void glColor3bv(glColor3bv_ARG_EXPAND);
typedef void (*glColor3bv_PTR)(glColor3bv_ARG_EXPAND);
#define glColor3d_INDEX 247
#define glColor3d_RETURN void
#define glColor3d_ARG_NAMES red, green, blue
#define glColor3d_ARG_EXPAND GLdouble red, GLdouble green, GLdouble blue
#define glColor3d_PACKED PACKED_glColor3d
#define glColor3d_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glColor3d_NOT_VOID_WRAP(...) {}
#define pack_glColor3d(_red, _green, _blue) ({ \
    glColor3d_PACKED *packed_data = malloc(sizeof(glColor3d_PACKED)); \
    packed_data->index = glColor3d_INDEX; \
    packed_data->args.red = (GLdouble)_red; \
    packed_data->args.green = (GLdouble)_green; \
    packed_data->args.blue = (GLdouble)_blue; \
    (packed_call_t *)packed_data; \
})
#define call_glColor3d(packed, ret_v) do { \
    PACKED_glColor3d *unpacked = (PACKED_glColor3d *)packed; \
    ARGS_glColor3d *args = (ARGS_glColor3d *)&unpacked->args; \
    glColor3d(args->red, args->green, args->blue);; \
} while(0)
void glColor3d(glColor3d_ARG_EXPAND);
typedef void (*glColor3d_PTR)(glColor3d_ARG_EXPAND);
#define glColor3dv_INDEX 248
#define glColor3dv_RETURN void
#define glColor3dv_ARG_NAMES v
#define glColor3dv_ARG_EXPAND const GLdouble * v
#define glColor3dv_PACKED PACKED_glColor3dv
#define glColor3dv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glColor3dv_NOT_VOID_WRAP(...) {}
#define pack_glColor3dv(_v) ({ \
    glColor3dv_PACKED *packed_data = malloc(sizeof(glColor3dv_PACKED)); \
    packed_data->index = glColor3dv_INDEX; \
    packed_data->args.v = (GLdouble *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glColor3dv(packed, ret_v) do { \
    PACKED_glColor3dv *unpacked = (PACKED_glColor3dv *)packed; \
    ARGS_glColor3dv *args = (ARGS_glColor3dv *)&unpacked->args; \
    glColor3dv(args->v);; \
} while(0)
void glColor3dv(glColor3dv_ARG_EXPAND);
typedef void (*glColor3dv_PTR)(glColor3dv_ARG_EXPAND);
#define glColor3f_INDEX 249
#define glColor3f_RETURN void
#define glColor3f_ARG_NAMES red, green, blue
#define glColor3f_ARG_EXPAND GLfloat red, GLfloat green, GLfloat blue
#define glColor3f_PACKED PACKED_glColor3f
#define glColor3f_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glColor3f_NOT_VOID_WRAP(...) {}
#define pack_glColor3f(_red, _green, _blue) ({ \
    glColor3f_PACKED *packed_data = malloc(sizeof(glColor3f_PACKED)); \
    packed_data->index = glColor3f_INDEX; \
    packed_data->args.red = (GLfloat)_red; \
    packed_data->args.green = (GLfloat)_green; \
    packed_data->args.blue = (GLfloat)_blue; \
    (packed_call_t *)packed_data; \
})
#define call_glColor3f(packed, ret_v) do { \
    PACKED_glColor3f *unpacked = (PACKED_glColor3f *)packed; \
    ARGS_glColor3f *args = (ARGS_glColor3f *)&unpacked->args; \
    glColor3f(args->red, args->green, args->blue);; \
} while(0)
void glColor3f(glColor3f_ARG_EXPAND);
typedef void (*glColor3f_PTR)(glColor3f_ARG_EXPAND);
#define glColor3fVertex3fSUN_INDEX 250
#define glColor3fVertex3fSUN_RETURN void
#define glColor3fVertex3fSUN_ARG_NAMES r, g, b, x, y, z
#define glColor3fVertex3fSUN_ARG_EXPAND GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z
#define glColor3fVertex3fSUN_PACKED PACKED_glColor3fVertex3fSUN
#define glColor3fVertex3fSUN_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glColor3fVertex3fSUN_NOT_VOID_WRAP(...) {}
#define pack_glColor3fVertex3fSUN(_r, _g, _b, _x, _y, _z) ({ \
    glColor3fVertex3fSUN_PACKED *packed_data = malloc(sizeof(glColor3fVertex3fSUN_PACKED)); \
    packed_data->index = glColor3fVertex3fSUN_INDEX; \
    packed_data->args.r = (GLfloat)_r; \
    packed_data->args.g = (GLfloat)_g; \
    packed_data->args.b = (GLfloat)_b; \
    packed_data->args.x = (GLfloat)_x; \
    packed_data->args.y = (GLfloat)_y; \
    packed_data->args.z = (GLfloat)_z; \
    (packed_call_t *)packed_data; \
})
#define call_glColor3fVertex3fSUN(packed, ret_v) do { \
    PACKED_glColor3fVertex3fSUN *unpacked = (PACKED_glColor3fVertex3fSUN *)packed; \
    ARGS_glColor3fVertex3fSUN *args = (ARGS_glColor3fVertex3fSUN *)&unpacked->args; \
    glColor3fVertex3fSUN(args->r, args->g, args->b, args->x, args->y, args->z);; \
} while(0)
void glColor3fVertex3fSUN(glColor3fVertex3fSUN_ARG_EXPAND);
typedef void (*glColor3fVertex3fSUN_PTR)(glColor3fVertex3fSUN_ARG_EXPAND);
#define glColor3fVertex3fvSUN_INDEX 251
#define glColor3fVertex3fvSUN_RETURN void
#define glColor3fVertex3fvSUN_ARG_NAMES c, v
#define glColor3fVertex3fvSUN_ARG_EXPAND const GLfloat * c, const GLfloat * v
#define glColor3fVertex3fvSUN_PACKED PACKED_glColor3fVertex3fvSUN
#define glColor3fVertex3fvSUN_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glColor3fVertex3fvSUN_NOT_VOID_WRAP(...) {}
#define pack_glColor3fVertex3fvSUN(_c, _v) ({ \
    glColor3fVertex3fvSUN_PACKED *packed_data = malloc(sizeof(glColor3fVertex3fvSUN_PACKED)); \
    packed_data->index = glColor3fVertex3fvSUN_INDEX; \
    packed_data->args.c = (GLfloat *)_c; \
    packed_data->args.v = (GLfloat *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glColor3fVertex3fvSUN(packed, ret_v) do { \
    PACKED_glColor3fVertex3fvSUN *unpacked = (PACKED_glColor3fVertex3fvSUN *)packed; \
    ARGS_glColor3fVertex3fvSUN *args = (ARGS_glColor3fVertex3fvSUN *)&unpacked->args; \
    glColor3fVertex3fvSUN(args->c, args->v);; \
} while(0)
void glColor3fVertex3fvSUN(glColor3fVertex3fvSUN_ARG_EXPAND);
typedef void (*glColor3fVertex3fvSUN_PTR)(glColor3fVertex3fvSUN_ARG_EXPAND);
#define glColor3fv_INDEX 252
#define glColor3fv_RETURN void
#define glColor3fv_ARG_NAMES v
#define glColor3fv_ARG_EXPAND const GLfloat * v
#define glColor3fv_PACKED PACKED_glColor3fv
#define glColor3fv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glColor3fv_NOT_VOID_WRAP(...) {}
#define pack_glColor3fv(_v) ({ \
    glColor3fv_PACKED *packed_data = malloc(sizeof(glColor3fv_PACKED)); \
    packed_data->index = glColor3fv_INDEX; \
    packed_data->args.v = (GLfloat *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glColor3fv(packed, ret_v) do { \
    PACKED_glColor3fv *unpacked = (PACKED_glColor3fv *)packed; \
    ARGS_glColor3fv *args = (ARGS_glColor3fv *)&unpacked->args; \
    glColor3fv(args->v);; \
} while(0)
void glColor3fv(glColor3fv_ARG_EXPAND);
typedef void (*glColor3fv_PTR)(glColor3fv_ARG_EXPAND);
#define glColor3hNV_INDEX 253
#define glColor3hNV_RETURN void
#define glColor3hNV_ARG_NAMES red, green, blue
#define glColor3hNV_ARG_EXPAND GLhalfNV red, GLhalfNV green, GLhalfNV blue
#define glColor3hNV_PACKED PACKED_glColor3hNV
#define glColor3hNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glColor3hNV_NOT_VOID_WRAP(...) {}
#define pack_glColor3hNV(_red, _green, _blue) ({ \
    glColor3hNV_PACKED *packed_data = malloc(sizeof(glColor3hNV_PACKED)); \
    packed_data->index = glColor3hNV_INDEX; \
    packed_data->args.red = (GLhalfNV)_red; \
    packed_data->args.green = (GLhalfNV)_green; \
    packed_data->args.blue = (GLhalfNV)_blue; \
    (packed_call_t *)packed_data; \
})
#define call_glColor3hNV(packed, ret_v) do { \
    PACKED_glColor3hNV *unpacked = (PACKED_glColor3hNV *)packed; \
    ARGS_glColor3hNV *args = (ARGS_glColor3hNV *)&unpacked->args; \
    glColor3hNV(args->red, args->green, args->blue);; \
} while(0)
void glColor3hNV(glColor3hNV_ARG_EXPAND);
typedef void (*glColor3hNV_PTR)(glColor3hNV_ARG_EXPAND);
#define glColor3hvNV_INDEX 254
#define glColor3hvNV_RETURN void
#define glColor3hvNV_ARG_NAMES v
#define glColor3hvNV_ARG_EXPAND const GLhalfNV * v
#define glColor3hvNV_PACKED PACKED_glColor3hvNV
#define glColor3hvNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glColor3hvNV_NOT_VOID_WRAP(...) {}
#define pack_glColor3hvNV(_v) ({ \
    glColor3hvNV_PACKED *packed_data = malloc(sizeof(glColor3hvNV_PACKED)); \
    packed_data->index = glColor3hvNV_INDEX; \
    packed_data->args.v = (GLhalfNV *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glColor3hvNV(packed, ret_v) do { \
    PACKED_glColor3hvNV *unpacked = (PACKED_glColor3hvNV *)packed; \
    ARGS_glColor3hvNV *args = (ARGS_glColor3hvNV *)&unpacked->args; \
    glColor3hvNV(args->v);; \
} while(0)
void glColor3hvNV(glColor3hvNV_ARG_EXPAND);
typedef void (*glColor3hvNV_PTR)(glColor3hvNV_ARG_EXPAND);
#define glColor3i_INDEX 255
#define glColor3i_RETURN void
#define glColor3i_ARG_NAMES red, green, blue
#define glColor3i_ARG_EXPAND GLint red, GLint green, GLint blue
#define glColor3i_PACKED PACKED_glColor3i
#define glColor3i_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glColor3i_NOT_VOID_WRAP(...) {}
#define pack_glColor3i(_red, _green, _blue) ({ \
    glColor3i_PACKED *packed_data = malloc(sizeof(glColor3i_PACKED)); \
    packed_data->index = glColor3i_INDEX; \
    packed_data->args.red = (GLint)_red; \
    packed_data->args.green = (GLint)_green; \
    packed_data->args.blue = (GLint)_blue; \
    (packed_call_t *)packed_data; \
})
#define call_glColor3i(packed, ret_v) do { \
    PACKED_glColor3i *unpacked = (PACKED_glColor3i *)packed; \
    ARGS_glColor3i *args = (ARGS_glColor3i *)&unpacked->args; \
    glColor3i(args->red, args->green, args->blue);; \
} while(0)
void glColor3i(glColor3i_ARG_EXPAND);
typedef void (*glColor3i_PTR)(glColor3i_ARG_EXPAND);
#define glColor3iv_INDEX 256
#define glColor3iv_RETURN void
#define glColor3iv_ARG_NAMES v
#define glColor3iv_ARG_EXPAND const GLint * v
#define glColor3iv_PACKED PACKED_glColor3iv
#define glColor3iv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glColor3iv_NOT_VOID_WRAP(...) {}
#define pack_glColor3iv(_v) ({ \
    glColor3iv_PACKED *packed_data = malloc(sizeof(glColor3iv_PACKED)); \
    packed_data->index = glColor3iv_INDEX; \
    packed_data->args.v = (GLint *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glColor3iv(packed, ret_v) do { \
    PACKED_glColor3iv *unpacked = (PACKED_glColor3iv *)packed; \
    ARGS_glColor3iv *args = (ARGS_glColor3iv *)&unpacked->args; \
    glColor3iv(args->v);; \
} while(0)
void glColor3iv(glColor3iv_ARG_EXPAND);
typedef void (*glColor3iv_PTR)(glColor3iv_ARG_EXPAND);
#define glColor3s_INDEX 257
#define glColor3s_RETURN void
#define glColor3s_ARG_NAMES red, green, blue
#define glColor3s_ARG_EXPAND GLshort red, GLshort green, GLshort blue
#define glColor3s_PACKED PACKED_glColor3s
#define glColor3s_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glColor3s_NOT_VOID_WRAP(...) {}
#define pack_glColor3s(_red, _green, _blue) ({ \
    glColor3s_PACKED *packed_data = malloc(sizeof(glColor3s_PACKED)); \
    packed_data->index = glColor3s_INDEX; \
    packed_data->args.red = (GLshort)_red; \
    packed_data->args.green = (GLshort)_green; \
    packed_data->args.blue = (GLshort)_blue; \
    (packed_call_t *)packed_data; \
})
#define call_glColor3s(packed, ret_v) do { \
    PACKED_glColor3s *unpacked = (PACKED_glColor3s *)packed; \
    ARGS_glColor3s *args = (ARGS_glColor3s *)&unpacked->args; \
    glColor3s(args->red, args->green, args->blue);; \
} while(0)
void glColor3s(glColor3s_ARG_EXPAND);
typedef void (*glColor3s_PTR)(glColor3s_ARG_EXPAND);
#define glColor3sv_INDEX 258
#define glColor3sv_RETURN void
#define glColor3sv_ARG_NAMES v
#define glColor3sv_ARG_EXPAND const GLshort * v
#define glColor3sv_PACKED PACKED_glColor3sv
#define glColor3sv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glColor3sv_NOT_VOID_WRAP(...) {}
#define pack_glColor3sv(_v) ({ \
    glColor3sv_PACKED *packed_data = malloc(sizeof(glColor3sv_PACKED)); \
    packed_data->index = glColor3sv_INDEX; \
    packed_data->args.v = (GLshort *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glColor3sv(packed, ret_v) do { \
    PACKED_glColor3sv *unpacked = (PACKED_glColor3sv *)packed; \
    ARGS_glColor3sv *args = (ARGS_glColor3sv *)&unpacked->args; \
    glColor3sv(args->v);; \
} while(0)
void glColor3sv(glColor3sv_ARG_EXPAND);
typedef void (*glColor3sv_PTR)(glColor3sv_ARG_EXPAND);
#define glColor3ub_INDEX 259
#define glColor3ub_RETURN void
#define glColor3ub_ARG_NAMES red, green, blue
#define glColor3ub_ARG_EXPAND GLubyte red, GLubyte green, GLubyte blue
#define glColor3ub_PACKED PACKED_glColor3ub
#define glColor3ub_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glColor3ub_NOT_VOID_WRAP(...) {}
#define pack_glColor3ub(_red, _green, _blue) ({ \
    glColor3ub_PACKED *packed_data = malloc(sizeof(glColor3ub_PACKED)); \
    packed_data->index = glColor3ub_INDEX; \
    packed_data->args.red = (GLubyte)_red; \
    packed_data->args.green = (GLubyte)_green; \
    packed_data->args.blue = (GLubyte)_blue; \
    (packed_call_t *)packed_data; \
})
#define call_glColor3ub(packed, ret_v) do { \
    PACKED_glColor3ub *unpacked = (PACKED_glColor3ub *)packed; \
    ARGS_glColor3ub *args = (ARGS_glColor3ub *)&unpacked->args; \
    glColor3ub(args->red, args->green, args->blue);; \
} while(0)
void glColor3ub(glColor3ub_ARG_EXPAND);
typedef void (*glColor3ub_PTR)(glColor3ub_ARG_EXPAND);
#define glColor3ubv_INDEX 260
#define glColor3ubv_RETURN void
#define glColor3ubv_ARG_NAMES v
#define glColor3ubv_ARG_EXPAND const GLubyte * v
#define glColor3ubv_PACKED PACKED_glColor3ubv
#define glColor3ubv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glColor3ubv_NOT_VOID_WRAP(...) {}
#define pack_glColor3ubv(_v) ({ \
    glColor3ubv_PACKED *packed_data = malloc(sizeof(glColor3ubv_PACKED)); \
    packed_data->index = glColor3ubv_INDEX; \
    packed_data->args.v = (GLubyte *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glColor3ubv(packed, ret_v) do { \
    PACKED_glColor3ubv *unpacked = (PACKED_glColor3ubv *)packed; \
    ARGS_glColor3ubv *args = (ARGS_glColor3ubv *)&unpacked->args; \
    glColor3ubv(args->v);; \
} while(0)
void glColor3ubv(glColor3ubv_ARG_EXPAND);
typedef void (*glColor3ubv_PTR)(glColor3ubv_ARG_EXPAND);
#define glColor3ui_INDEX 261
#define glColor3ui_RETURN void
#define glColor3ui_ARG_NAMES red, green, blue
#define glColor3ui_ARG_EXPAND GLuint red, GLuint green, GLuint blue
#define glColor3ui_PACKED PACKED_glColor3ui
#define glColor3ui_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glColor3ui_NOT_VOID_WRAP(...) {}
#define pack_glColor3ui(_red, _green, _blue) ({ \
    glColor3ui_PACKED *packed_data = malloc(sizeof(glColor3ui_PACKED)); \
    packed_data->index = glColor3ui_INDEX; \
    packed_data->args.red = (GLuint)_red; \
    packed_data->args.green = (GLuint)_green; \
    packed_data->args.blue = (GLuint)_blue; \
    (packed_call_t *)packed_data; \
})
#define call_glColor3ui(packed, ret_v) do { \
    PACKED_glColor3ui *unpacked = (PACKED_glColor3ui *)packed; \
    ARGS_glColor3ui *args = (ARGS_glColor3ui *)&unpacked->args; \
    glColor3ui(args->red, args->green, args->blue);; \
} while(0)
void glColor3ui(glColor3ui_ARG_EXPAND);
typedef void (*glColor3ui_PTR)(glColor3ui_ARG_EXPAND);
#define glColor3uiv_INDEX 262
#define glColor3uiv_RETURN void
#define glColor3uiv_ARG_NAMES v
#define glColor3uiv_ARG_EXPAND const GLuint * v
#define glColor3uiv_PACKED PACKED_glColor3uiv
#define glColor3uiv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glColor3uiv_NOT_VOID_WRAP(...) {}
#define pack_glColor3uiv(_v) ({ \
    glColor3uiv_PACKED *packed_data = malloc(sizeof(glColor3uiv_PACKED)); \
    packed_data->index = glColor3uiv_INDEX; \
    packed_data->args.v = (GLuint *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glColor3uiv(packed, ret_v) do { \
    PACKED_glColor3uiv *unpacked = (PACKED_glColor3uiv *)packed; \
    ARGS_glColor3uiv *args = (ARGS_glColor3uiv *)&unpacked->args; \
    glColor3uiv(args->v);; \
} while(0)
void glColor3uiv(glColor3uiv_ARG_EXPAND);
typedef void (*glColor3uiv_PTR)(glColor3uiv_ARG_EXPAND);
#define glColor3us_INDEX 263
#define glColor3us_RETURN void
#define glColor3us_ARG_NAMES red, green, blue
#define glColor3us_ARG_EXPAND GLushort red, GLushort green, GLushort blue
#define glColor3us_PACKED PACKED_glColor3us
#define glColor3us_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glColor3us_NOT_VOID_WRAP(...) {}
#define pack_glColor3us(_red, _green, _blue) ({ \
    glColor3us_PACKED *packed_data = malloc(sizeof(glColor3us_PACKED)); \
    packed_data->index = glColor3us_INDEX; \
    packed_data->args.red = (GLushort)_red; \
    packed_data->args.green = (GLushort)_green; \
    packed_data->args.blue = (GLushort)_blue; \
    (packed_call_t *)packed_data; \
})
#define call_glColor3us(packed, ret_v) do { \
    PACKED_glColor3us *unpacked = (PACKED_glColor3us *)packed; \
    ARGS_glColor3us *args = (ARGS_glColor3us *)&unpacked->args; \
    glColor3us(args->red, args->green, args->blue);; \
} while(0)
void glColor3us(glColor3us_ARG_EXPAND);
typedef void (*glColor3us_PTR)(glColor3us_ARG_EXPAND);
#define glColor3usv_INDEX 264
#define glColor3usv_RETURN void
#define glColor3usv_ARG_NAMES v
#define glColor3usv_ARG_EXPAND const GLushort * v
#define glColor3usv_PACKED PACKED_glColor3usv
#define glColor3usv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glColor3usv_NOT_VOID_WRAP(...) {}
#define pack_glColor3usv(_v) ({ \
    glColor3usv_PACKED *packed_data = malloc(sizeof(glColor3usv_PACKED)); \
    packed_data->index = glColor3usv_INDEX; \
    packed_data->args.v = (GLushort *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glColor3usv(packed, ret_v) do { \
    PACKED_glColor3usv *unpacked = (PACKED_glColor3usv *)packed; \
    ARGS_glColor3usv *args = (ARGS_glColor3usv *)&unpacked->args; \
    glColor3usv(args->v);; \
} while(0)
void glColor3usv(glColor3usv_ARG_EXPAND);
typedef void (*glColor3usv_PTR)(glColor3usv_ARG_EXPAND);
#define glColor3xOES_INDEX 265
#define glColor3xOES_RETURN void
#define glColor3xOES_ARG_NAMES red, green, blue
#define glColor3xOES_ARG_EXPAND GLfixed red, GLfixed green, GLfixed blue
#define glColor3xOES_PACKED PACKED_glColor3xOES
#define glColor3xOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glColor3xOES_NOT_VOID_WRAP(...) {}
#define pack_glColor3xOES(_red, _green, _blue) ({ \
    glColor3xOES_PACKED *packed_data = malloc(sizeof(glColor3xOES_PACKED)); \
    packed_data->index = glColor3xOES_INDEX; \
    packed_data->args.red = (GLfixed)_red; \
    packed_data->args.green = (GLfixed)_green; \
    packed_data->args.blue = (GLfixed)_blue; \
    (packed_call_t *)packed_data; \
})
#define call_glColor3xOES(packed, ret_v) do { \
    PACKED_glColor3xOES *unpacked = (PACKED_glColor3xOES *)packed; \
    ARGS_glColor3xOES *args = (ARGS_glColor3xOES *)&unpacked->args; \
    glColor3xOES(args->red, args->green, args->blue);; \
} while(0)
void glColor3xOES(glColor3xOES_ARG_EXPAND);
typedef void (*glColor3xOES_PTR)(glColor3xOES_ARG_EXPAND);
#define glColor3xvOES_INDEX 266
#define glColor3xvOES_RETURN void
#define glColor3xvOES_ARG_NAMES components
#define glColor3xvOES_ARG_EXPAND const GLfixed * components
#define glColor3xvOES_PACKED PACKED_glColor3xvOES
#define glColor3xvOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glColor3xvOES_NOT_VOID_WRAP(...) {}
#define pack_glColor3xvOES(_components) ({ \
    glColor3xvOES_PACKED *packed_data = malloc(sizeof(glColor3xvOES_PACKED)); \
    packed_data->index = glColor3xvOES_INDEX; \
    packed_data->args.components = (GLfixed *)_components; \
    (packed_call_t *)packed_data; \
})
#define call_glColor3xvOES(packed, ret_v) do { \
    PACKED_glColor3xvOES *unpacked = (PACKED_glColor3xvOES *)packed; \
    ARGS_glColor3xvOES *args = (ARGS_glColor3xvOES *)&unpacked->args; \
    glColor3xvOES(args->components);; \
} while(0)
void glColor3xvOES(glColor3xvOES_ARG_EXPAND);
typedef void (*glColor3xvOES_PTR)(glColor3xvOES_ARG_EXPAND);
#define glColor4b_INDEX 267
#define glColor4b_RETURN void
#define glColor4b_ARG_NAMES red, green, blue, alpha
#define glColor4b_ARG_EXPAND GLbyte red, GLbyte green, GLbyte blue, GLbyte alpha
#define glColor4b_PACKED PACKED_glColor4b
#define glColor4b_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glColor4b_NOT_VOID_WRAP(...) {}
#define pack_glColor4b(_red, _green, _blue, _alpha) ({ \
    glColor4b_PACKED *packed_data = malloc(sizeof(glColor4b_PACKED)); \
    packed_data->index = glColor4b_INDEX; \
    packed_data->args.red = (GLbyte)_red; \
    packed_data->args.green = (GLbyte)_green; \
    packed_data->args.blue = (GLbyte)_blue; \
    packed_data->args.alpha = (GLbyte)_alpha; \
    (packed_call_t *)packed_data; \
})
#define call_glColor4b(packed, ret_v) do { \
    PACKED_glColor4b *unpacked = (PACKED_glColor4b *)packed; \
    ARGS_glColor4b *args = (ARGS_glColor4b *)&unpacked->args; \
    glColor4b(args->red, args->green, args->blue, args->alpha);; \
} while(0)
void glColor4b(glColor4b_ARG_EXPAND);
typedef void (*glColor4b_PTR)(glColor4b_ARG_EXPAND);
#define glColor4bv_INDEX 268
#define glColor4bv_RETURN void
#define glColor4bv_ARG_NAMES v
#define glColor4bv_ARG_EXPAND const GLbyte * v
#define glColor4bv_PACKED PACKED_glColor4bv
#define glColor4bv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glColor4bv_NOT_VOID_WRAP(...) {}
#define pack_glColor4bv(_v) ({ \
    glColor4bv_PACKED *packed_data = malloc(sizeof(glColor4bv_PACKED)); \
    packed_data->index = glColor4bv_INDEX; \
    packed_data->args.v = (GLbyte *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glColor4bv(packed, ret_v) do { \
    PACKED_glColor4bv *unpacked = (PACKED_glColor4bv *)packed; \
    ARGS_glColor4bv *args = (ARGS_glColor4bv *)&unpacked->args; \
    glColor4bv(args->v);; \
} while(0)
void glColor4bv(glColor4bv_ARG_EXPAND);
typedef void (*glColor4bv_PTR)(glColor4bv_ARG_EXPAND);
#define glColor4d_INDEX 269
#define glColor4d_RETURN void
#define glColor4d_ARG_NAMES red, green, blue, alpha
#define glColor4d_ARG_EXPAND GLdouble red, GLdouble green, GLdouble blue, GLdouble alpha
#define glColor4d_PACKED PACKED_glColor4d
#define glColor4d_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glColor4d_NOT_VOID_WRAP(...) {}
#define pack_glColor4d(_red, _green, _blue, _alpha) ({ \
    glColor4d_PACKED *packed_data = malloc(sizeof(glColor4d_PACKED)); \
    packed_data->index = glColor4d_INDEX; \
    packed_data->args.red = (GLdouble)_red; \
    packed_data->args.green = (GLdouble)_green; \
    packed_data->args.blue = (GLdouble)_blue; \
    packed_data->args.alpha = (GLdouble)_alpha; \
    (packed_call_t *)packed_data; \
})
#define call_glColor4d(packed, ret_v) do { \
    PACKED_glColor4d *unpacked = (PACKED_glColor4d *)packed; \
    ARGS_glColor4d *args = (ARGS_glColor4d *)&unpacked->args; \
    glColor4d(args->red, args->green, args->blue, args->alpha);; \
} while(0)
void glColor4d(glColor4d_ARG_EXPAND);
typedef void (*glColor4d_PTR)(glColor4d_ARG_EXPAND);
#define glColor4dv_INDEX 270
#define glColor4dv_RETURN void
#define glColor4dv_ARG_NAMES v
#define glColor4dv_ARG_EXPAND const GLdouble * v
#define glColor4dv_PACKED PACKED_glColor4dv
#define glColor4dv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glColor4dv_NOT_VOID_WRAP(...) {}
#define pack_glColor4dv(_v) ({ \
    glColor4dv_PACKED *packed_data = malloc(sizeof(glColor4dv_PACKED)); \
    packed_data->index = glColor4dv_INDEX; \
    packed_data->args.v = (GLdouble *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glColor4dv(packed, ret_v) do { \
    PACKED_glColor4dv *unpacked = (PACKED_glColor4dv *)packed; \
    ARGS_glColor4dv *args = (ARGS_glColor4dv *)&unpacked->args; \
    glColor4dv(args->v);; \
} while(0)
void glColor4dv(glColor4dv_ARG_EXPAND);
typedef void (*glColor4dv_PTR)(glColor4dv_ARG_EXPAND);
#define glColor4f_INDEX 271
#define glColor4f_RETURN void
#define glColor4f_ARG_NAMES red, green, blue, alpha
#define glColor4f_ARG_EXPAND GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha
#define glColor4f_PACKED PACKED_glColor4f
#define glColor4f_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glColor4f_NOT_VOID_WRAP(...) {}
#define pack_glColor4f(_red, _green, _blue, _alpha) ({ \
    glColor4f_PACKED *packed_data = malloc(sizeof(glColor4f_PACKED)); \
    packed_data->index = glColor4f_INDEX; \
    packed_data->args.red = (GLfloat)_red; \
    packed_data->args.green = (GLfloat)_green; \
    packed_data->args.blue = (GLfloat)_blue; \
    packed_data->args.alpha = (GLfloat)_alpha; \
    (packed_call_t *)packed_data; \
})
#define call_glColor4f(packed, ret_v) do { \
    PACKED_glColor4f *unpacked = (PACKED_glColor4f *)packed; \
    ARGS_glColor4f *args = (ARGS_glColor4f *)&unpacked->args; \
    glColor4f(args->red, args->green, args->blue, args->alpha);; \
} while(0)
void glColor4f(glColor4f_ARG_EXPAND);
typedef void (*glColor4f_PTR)(glColor4f_ARG_EXPAND);
#define glColor4fNormal3fVertex3fSUN_INDEX 272
#define glColor4fNormal3fVertex3fSUN_RETURN void
#define glColor4fNormal3fVertex3fSUN_ARG_NAMES r, g, b, a, nx, ny, nz, x, y, z
#define glColor4fNormal3fVertex3fSUN_ARG_EXPAND GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z
#define glColor4fNormal3fVertex3fSUN_PACKED PACKED_glColor4fNormal3fVertex3fSUN
#define glColor4fNormal3fVertex3fSUN_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glColor4fNormal3fVertex3fSUN_NOT_VOID_WRAP(...) {}
#define pack_glColor4fNormal3fVertex3fSUN(_r, _g, _b, _a, _nx, _ny, _nz, _x, _y, _z) ({ \
    glColor4fNormal3fVertex3fSUN_PACKED *packed_data = malloc(sizeof(glColor4fNormal3fVertex3fSUN_PACKED)); \
    packed_data->index = glColor4fNormal3fVertex3fSUN_INDEX; \
    packed_data->args.r = (GLfloat)_r; \
    packed_data->args.g = (GLfloat)_g; \
    packed_data->args.b = (GLfloat)_b; \
    packed_data->args.a = (GLfloat)_a; \
    packed_data->args.nx = (GLfloat)_nx; \
    packed_data->args.ny = (GLfloat)_ny; \
    packed_data->args.nz = (GLfloat)_nz; \
    packed_data->args.x = (GLfloat)_x; \
    packed_data->args.y = (GLfloat)_y; \
    packed_data->args.z = (GLfloat)_z; \
    (packed_call_t *)packed_data; \
})
#define call_glColor4fNormal3fVertex3fSUN(packed, ret_v) do { \
    PACKED_glColor4fNormal3fVertex3fSUN *unpacked = (PACKED_glColor4fNormal3fVertex3fSUN *)packed; \
    ARGS_glColor4fNormal3fVertex3fSUN *args = (ARGS_glColor4fNormal3fVertex3fSUN *)&unpacked->args; \
    glColor4fNormal3fVertex3fSUN(args->r, args->g, args->b, args->a, args->nx, args->ny, args->nz, args->x, args->y, args->z);; \
} while(0)
void glColor4fNormal3fVertex3fSUN(glColor4fNormal3fVertex3fSUN_ARG_EXPAND);
typedef void (*glColor4fNormal3fVertex3fSUN_PTR)(glColor4fNormal3fVertex3fSUN_ARG_EXPAND);
#define glColor4fNormal3fVertex3fvSUN_INDEX 273
#define glColor4fNormal3fVertex3fvSUN_RETURN void
#define glColor4fNormal3fVertex3fvSUN_ARG_NAMES c, n, v
#define glColor4fNormal3fVertex3fvSUN_ARG_EXPAND const GLfloat * c, const GLfloat * n, const GLfloat * v
#define glColor4fNormal3fVertex3fvSUN_PACKED PACKED_glColor4fNormal3fVertex3fvSUN
#define glColor4fNormal3fVertex3fvSUN_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glColor4fNormal3fVertex3fvSUN_NOT_VOID_WRAP(...) {}
#define pack_glColor4fNormal3fVertex3fvSUN(_c, _n, _v) ({ \
    glColor4fNormal3fVertex3fvSUN_PACKED *packed_data = malloc(sizeof(glColor4fNormal3fVertex3fvSUN_PACKED)); \
    packed_data->index = glColor4fNormal3fVertex3fvSUN_INDEX; \
    packed_data->args.c = (GLfloat *)_c; \
    packed_data->args.n = (GLfloat *)_n; \
    packed_data->args.v = (GLfloat *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glColor4fNormal3fVertex3fvSUN(packed, ret_v) do { \
    PACKED_glColor4fNormal3fVertex3fvSUN *unpacked = (PACKED_glColor4fNormal3fVertex3fvSUN *)packed; \
    ARGS_glColor4fNormal3fVertex3fvSUN *args = (ARGS_glColor4fNormal3fVertex3fvSUN *)&unpacked->args; \
    glColor4fNormal3fVertex3fvSUN(args->c, args->n, args->v);; \
} while(0)
void glColor4fNormal3fVertex3fvSUN(glColor4fNormal3fVertex3fvSUN_ARG_EXPAND);
typedef void (*glColor4fNormal3fVertex3fvSUN_PTR)(glColor4fNormal3fVertex3fvSUN_ARG_EXPAND);
#define glColor4fv_INDEX 274
#define glColor4fv_RETURN void
#define glColor4fv_ARG_NAMES v
#define glColor4fv_ARG_EXPAND const GLfloat * v
#define glColor4fv_PACKED PACKED_glColor4fv
#define glColor4fv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glColor4fv_NOT_VOID_WRAP(...) {}
#define pack_glColor4fv(_v) ({ \
    glColor4fv_PACKED *packed_data = malloc(sizeof(glColor4fv_PACKED)); \
    packed_data->index = glColor4fv_INDEX; \
    packed_data->args.v = (GLfloat *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glColor4fv(packed, ret_v) do { \
    PACKED_glColor4fv *unpacked = (PACKED_glColor4fv *)packed; \
    ARGS_glColor4fv *args = (ARGS_glColor4fv *)&unpacked->args; \
    glColor4fv(args->v);; \
} while(0)
void glColor4fv(glColor4fv_ARG_EXPAND);
typedef void (*glColor4fv_PTR)(glColor4fv_ARG_EXPAND);
#define glColor4hNV_INDEX 275
#define glColor4hNV_RETURN void
#define glColor4hNV_ARG_NAMES red, green, blue, alpha
#define glColor4hNV_ARG_EXPAND GLhalfNV red, GLhalfNV green, GLhalfNV blue, GLhalfNV alpha
#define glColor4hNV_PACKED PACKED_glColor4hNV
#define glColor4hNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glColor4hNV_NOT_VOID_WRAP(...) {}
#define pack_glColor4hNV(_red, _green, _blue, _alpha) ({ \
    glColor4hNV_PACKED *packed_data = malloc(sizeof(glColor4hNV_PACKED)); \
    packed_data->index = glColor4hNV_INDEX; \
    packed_data->args.red = (GLhalfNV)_red; \
    packed_data->args.green = (GLhalfNV)_green; \
    packed_data->args.blue = (GLhalfNV)_blue; \
    packed_data->args.alpha = (GLhalfNV)_alpha; \
    (packed_call_t *)packed_data; \
})
#define call_glColor4hNV(packed, ret_v) do { \
    PACKED_glColor4hNV *unpacked = (PACKED_glColor4hNV *)packed; \
    ARGS_glColor4hNV *args = (ARGS_glColor4hNV *)&unpacked->args; \
    glColor4hNV(args->red, args->green, args->blue, args->alpha);; \
} while(0)
void glColor4hNV(glColor4hNV_ARG_EXPAND);
typedef void (*glColor4hNV_PTR)(glColor4hNV_ARG_EXPAND);
#define glColor4hvNV_INDEX 276
#define glColor4hvNV_RETURN void
#define glColor4hvNV_ARG_NAMES v
#define glColor4hvNV_ARG_EXPAND const GLhalfNV * v
#define glColor4hvNV_PACKED PACKED_glColor4hvNV
#define glColor4hvNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glColor4hvNV_NOT_VOID_WRAP(...) {}
#define pack_glColor4hvNV(_v) ({ \
    glColor4hvNV_PACKED *packed_data = malloc(sizeof(glColor4hvNV_PACKED)); \
    packed_data->index = glColor4hvNV_INDEX; \
    packed_data->args.v = (GLhalfNV *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glColor4hvNV(packed, ret_v) do { \
    PACKED_glColor4hvNV *unpacked = (PACKED_glColor4hvNV *)packed; \
    ARGS_glColor4hvNV *args = (ARGS_glColor4hvNV *)&unpacked->args; \
    glColor4hvNV(args->v);; \
} while(0)
void glColor4hvNV(glColor4hvNV_ARG_EXPAND);
typedef void (*glColor4hvNV_PTR)(glColor4hvNV_ARG_EXPAND);
#define glColor4i_INDEX 277
#define glColor4i_RETURN void
#define glColor4i_ARG_NAMES red, green, blue, alpha
#define glColor4i_ARG_EXPAND GLint red, GLint green, GLint blue, GLint alpha
#define glColor4i_PACKED PACKED_glColor4i
#define glColor4i_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glColor4i_NOT_VOID_WRAP(...) {}
#define pack_glColor4i(_red, _green, _blue, _alpha) ({ \
    glColor4i_PACKED *packed_data = malloc(sizeof(glColor4i_PACKED)); \
    packed_data->index = glColor4i_INDEX; \
    packed_data->args.red = (GLint)_red; \
    packed_data->args.green = (GLint)_green; \
    packed_data->args.blue = (GLint)_blue; \
    packed_data->args.alpha = (GLint)_alpha; \
    (packed_call_t *)packed_data; \
})
#define call_glColor4i(packed, ret_v) do { \
    PACKED_glColor4i *unpacked = (PACKED_glColor4i *)packed; \
    ARGS_glColor4i *args = (ARGS_glColor4i *)&unpacked->args; \
    glColor4i(args->red, args->green, args->blue, args->alpha);; \
} while(0)
void glColor4i(glColor4i_ARG_EXPAND);
typedef void (*glColor4i_PTR)(glColor4i_ARG_EXPAND);
#define glColor4iv_INDEX 278
#define glColor4iv_RETURN void
#define glColor4iv_ARG_NAMES v
#define glColor4iv_ARG_EXPAND const GLint * v
#define glColor4iv_PACKED PACKED_glColor4iv
#define glColor4iv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glColor4iv_NOT_VOID_WRAP(...) {}
#define pack_glColor4iv(_v) ({ \
    glColor4iv_PACKED *packed_data = malloc(sizeof(glColor4iv_PACKED)); \
    packed_data->index = glColor4iv_INDEX; \
    packed_data->args.v = (GLint *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glColor4iv(packed, ret_v) do { \
    PACKED_glColor4iv *unpacked = (PACKED_glColor4iv *)packed; \
    ARGS_glColor4iv *args = (ARGS_glColor4iv *)&unpacked->args; \
    glColor4iv(args->v);; \
} while(0)
void glColor4iv(glColor4iv_ARG_EXPAND);
typedef void (*glColor4iv_PTR)(glColor4iv_ARG_EXPAND);
#define glColor4s_INDEX 279
#define glColor4s_RETURN void
#define glColor4s_ARG_NAMES red, green, blue, alpha
#define glColor4s_ARG_EXPAND GLshort red, GLshort green, GLshort blue, GLshort alpha
#define glColor4s_PACKED PACKED_glColor4s
#define glColor4s_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glColor4s_NOT_VOID_WRAP(...) {}
#define pack_glColor4s(_red, _green, _blue, _alpha) ({ \
    glColor4s_PACKED *packed_data = malloc(sizeof(glColor4s_PACKED)); \
    packed_data->index = glColor4s_INDEX; \
    packed_data->args.red = (GLshort)_red; \
    packed_data->args.green = (GLshort)_green; \
    packed_data->args.blue = (GLshort)_blue; \
    packed_data->args.alpha = (GLshort)_alpha; \
    (packed_call_t *)packed_data; \
})
#define call_glColor4s(packed, ret_v) do { \
    PACKED_glColor4s *unpacked = (PACKED_glColor4s *)packed; \
    ARGS_glColor4s *args = (ARGS_glColor4s *)&unpacked->args; \
    glColor4s(args->red, args->green, args->blue, args->alpha);; \
} while(0)
void glColor4s(glColor4s_ARG_EXPAND);
typedef void (*glColor4s_PTR)(glColor4s_ARG_EXPAND);
#define glColor4sv_INDEX 280
#define glColor4sv_RETURN void
#define glColor4sv_ARG_NAMES v
#define glColor4sv_ARG_EXPAND const GLshort * v
#define glColor4sv_PACKED PACKED_glColor4sv
#define glColor4sv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glColor4sv_NOT_VOID_WRAP(...) {}
#define pack_glColor4sv(_v) ({ \
    glColor4sv_PACKED *packed_data = malloc(sizeof(glColor4sv_PACKED)); \
    packed_data->index = glColor4sv_INDEX; \
    packed_data->args.v = (GLshort *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glColor4sv(packed, ret_v) do { \
    PACKED_glColor4sv *unpacked = (PACKED_glColor4sv *)packed; \
    ARGS_glColor4sv *args = (ARGS_glColor4sv *)&unpacked->args; \
    glColor4sv(args->v);; \
} while(0)
void glColor4sv(glColor4sv_ARG_EXPAND);
typedef void (*glColor4sv_PTR)(glColor4sv_ARG_EXPAND);
#define glColor4ub_INDEX 281
#define glColor4ub_RETURN void
#define glColor4ub_ARG_NAMES red, green, blue, alpha
#define glColor4ub_ARG_EXPAND GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha
#define glColor4ub_PACKED PACKED_glColor4ub
#define glColor4ub_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glColor4ub_NOT_VOID_WRAP(...) {}
#define pack_glColor4ub(_red, _green, _blue, _alpha) ({ \
    glColor4ub_PACKED *packed_data = malloc(sizeof(glColor4ub_PACKED)); \
    packed_data->index = glColor4ub_INDEX; \
    packed_data->args.red = (GLubyte)_red; \
    packed_data->args.green = (GLubyte)_green; \
    packed_data->args.blue = (GLubyte)_blue; \
    packed_data->args.alpha = (GLubyte)_alpha; \
    (packed_call_t *)packed_data; \
})
#define call_glColor4ub(packed, ret_v) do { \
    PACKED_glColor4ub *unpacked = (PACKED_glColor4ub *)packed; \
    ARGS_glColor4ub *args = (ARGS_glColor4ub *)&unpacked->args; \
    glColor4ub(args->red, args->green, args->blue, args->alpha);; \
} while(0)
void glColor4ub(glColor4ub_ARG_EXPAND);
typedef void (*glColor4ub_PTR)(glColor4ub_ARG_EXPAND);
#define glColor4ubVertex2fSUN_INDEX 282
#define glColor4ubVertex2fSUN_RETURN void
#define glColor4ubVertex2fSUN_ARG_NAMES r, g, b, a, x, y
#define glColor4ubVertex2fSUN_ARG_EXPAND GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y
#define glColor4ubVertex2fSUN_PACKED PACKED_glColor4ubVertex2fSUN
#define glColor4ubVertex2fSUN_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glColor4ubVertex2fSUN_NOT_VOID_WRAP(...) {}
#define pack_glColor4ubVertex2fSUN(_r, _g, _b, _a, _x, _y) ({ \
    glColor4ubVertex2fSUN_PACKED *packed_data = malloc(sizeof(glColor4ubVertex2fSUN_PACKED)); \
    packed_data->index = glColor4ubVertex2fSUN_INDEX; \
    packed_data->args.r = (GLubyte)_r; \
    packed_data->args.g = (GLubyte)_g; \
    packed_data->args.b = (GLubyte)_b; \
    packed_data->args.a = (GLubyte)_a; \
    packed_data->args.x = (GLfloat)_x; \
    packed_data->args.y = (GLfloat)_y; \
    (packed_call_t *)packed_data; \
})
#define call_glColor4ubVertex2fSUN(packed, ret_v) do { \
    PACKED_glColor4ubVertex2fSUN *unpacked = (PACKED_glColor4ubVertex2fSUN *)packed; \
    ARGS_glColor4ubVertex2fSUN *args = (ARGS_glColor4ubVertex2fSUN *)&unpacked->args; \
    glColor4ubVertex2fSUN(args->r, args->g, args->b, args->a, args->x, args->y);; \
} while(0)
void glColor4ubVertex2fSUN(glColor4ubVertex2fSUN_ARG_EXPAND);
typedef void (*glColor4ubVertex2fSUN_PTR)(glColor4ubVertex2fSUN_ARG_EXPAND);
#define glColor4ubVertex2fvSUN_INDEX 283
#define glColor4ubVertex2fvSUN_RETURN void
#define glColor4ubVertex2fvSUN_ARG_NAMES c, v
#define glColor4ubVertex2fvSUN_ARG_EXPAND const GLubyte * c, const GLfloat * v
#define glColor4ubVertex2fvSUN_PACKED PACKED_glColor4ubVertex2fvSUN
#define glColor4ubVertex2fvSUN_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glColor4ubVertex2fvSUN_NOT_VOID_WRAP(...) {}
#define pack_glColor4ubVertex2fvSUN(_c, _v) ({ \
    glColor4ubVertex2fvSUN_PACKED *packed_data = malloc(sizeof(glColor4ubVertex2fvSUN_PACKED)); \
    packed_data->index = glColor4ubVertex2fvSUN_INDEX; \
    packed_data->args.c = (GLubyte *)_c; \
    packed_data->args.v = (GLfloat *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glColor4ubVertex2fvSUN(packed, ret_v) do { \
    PACKED_glColor4ubVertex2fvSUN *unpacked = (PACKED_glColor4ubVertex2fvSUN *)packed; \
    ARGS_glColor4ubVertex2fvSUN *args = (ARGS_glColor4ubVertex2fvSUN *)&unpacked->args; \
    glColor4ubVertex2fvSUN(args->c, args->v);; \
} while(0)
void glColor4ubVertex2fvSUN(glColor4ubVertex2fvSUN_ARG_EXPAND);
typedef void (*glColor4ubVertex2fvSUN_PTR)(glColor4ubVertex2fvSUN_ARG_EXPAND);
#define glColor4ubVertex3fSUN_INDEX 284
#define glColor4ubVertex3fSUN_RETURN void
#define glColor4ubVertex3fSUN_ARG_NAMES r, g, b, a, x, y, z
#define glColor4ubVertex3fSUN_ARG_EXPAND GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z
#define glColor4ubVertex3fSUN_PACKED PACKED_glColor4ubVertex3fSUN
#define glColor4ubVertex3fSUN_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glColor4ubVertex3fSUN_NOT_VOID_WRAP(...) {}
#define pack_glColor4ubVertex3fSUN(_r, _g, _b, _a, _x, _y, _z) ({ \
    glColor4ubVertex3fSUN_PACKED *packed_data = malloc(sizeof(glColor4ubVertex3fSUN_PACKED)); \
    packed_data->index = glColor4ubVertex3fSUN_INDEX; \
    packed_data->args.r = (GLubyte)_r; \
    packed_data->args.g = (GLubyte)_g; \
    packed_data->args.b = (GLubyte)_b; \
    packed_data->args.a = (GLubyte)_a; \
    packed_data->args.x = (GLfloat)_x; \
    packed_data->args.y = (GLfloat)_y; \
    packed_data->args.z = (GLfloat)_z; \
    (packed_call_t *)packed_data; \
})
#define call_glColor4ubVertex3fSUN(packed, ret_v) do { \
    PACKED_glColor4ubVertex3fSUN *unpacked = (PACKED_glColor4ubVertex3fSUN *)packed; \
    ARGS_glColor4ubVertex3fSUN *args = (ARGS_glColor4ubVertex3fSUN *)&unpacked->args; \
    glColor4ubVertex3fSUN(args->r, args->g, args->b, args->a, args->x, args->y, args->z);; \
} while(0)
void glColor4ubVertex3fSUN(glColor4ubVertex3fSUN_ARG_EXPAND);
typedef void (*glColor4ubVertex3fSUN_PTR)(glColor4ubVertex3fSUN_ARG_EXPAND);
#define glColor4ubVertex3fvSUN_INDEX 285
#define glColor4ubVertex3fvSUN_RETURN void
#define glColor4ubVertex3fvSUN_ARG_NAMES c, v
#define glColor4ubVertex3fvSUN_ARG_EXPAND const GLubyte * c, const GLfloat * v
#define glColor4ubVertex3fvSUN_PACKED PACKED_glColor4ubVertex3fvSUN
#define glColor4ubVertex3fvSUN_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glColor4ubVertex3fvSUN_NOT_VOID_WRAP(...) {}
#define pack_glColor4ubVertex3fvSUN(_c, _v) ({ \
    glColor4ubVertex3fvSUN_PACKED *packed_data = malloc(sizeof(glColor4ubVertex3fvSUN_PACKED)); \
    packed_data->index = glColor4ubVertex3fvSUN_INDEX; \
    packed_data->args.c = (GLubyte *)_c; \
    packed_data->args.v = (GLfloat *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glColor4ubVertex3fvSUN(packed, ret_v) do { \
    PACKED_glColor4ubVertex3fvSUN *unpacked = (PACKED_glColor4ubVertex3fvSUN *)packed; \
    ARGS_glColor4ubVertex3fvSUN *args = (ARGS_glColor4ubVertex3fvSUN *)&unpacked->args; \
    glColor4ubVertex3fvSUN(args->c, args->v);; \
} while(0)
void glColor4ubVertex3fvSUN(glColor4ubVertex3fvSUN_ARG_EXPAND);
typedef void (*glColor4ubVertex3fvSUN_PTR)(glColor4ubVertex3fvSUN_ARG_EXPAND);
#define glColor4ubv_INDEX 286
#define glColor4ubv_RETURN void
#define glColor4ubv_ARG_NAMES v
#define glColor4ubv_ARG_EXPAND const GLubyte * v
#define glColor4ubv_PACKED PACKED_glColor4ubv
#define glColor4ubv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glColor4ubv_NOT_VOID_WRAP(...) {}
#define pack_glColor4ubv(_v) ({ \
    glColor4ubv_PACKED *packed_data = malloc(sizeof(glColor4ubv_PACKED)); \
    packed_data->index = glColor4ubv_INDEX; \
    packed_data->args.v = (GLubyte *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glColor4ubv(packed, ret_v) do { \
    PACKED_glColor4ubv *unpacked = (PACKED_glColor4ubv *)packed; \
    ARGS_glColor4ubv *args = (ARGS_glColor4ubv *)&unpacked->args; \
    glColor4ubv(args->v);; \
} while(0)
void glColor4ubv(glColor4ubv_ARG_EXPAND);
typedef void (*glColor4ubv_PTR)(glColor4ubv_ARG_EXPAND);
#define glColor4ui_INDEX 287
#define glColor4ui_RETURN void
#define glColor4ui_ARG_NAMES red, green, blue, alpha
#define glColor4ui_ARG_EXPAND GLuint red, GLuint green, GLuint blue, GLuint alpha
#define glColor4ui_PACKED PACKED_glColor4ui
#define glColor4ui_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glColor4ui_NOT_VOID_WRAP(...) {}
#define pack_glColor4ui(_red, _green, _blue, _alpha) ({ \
    glColor4ui_PACKED *packed_data = malloc(sizeof(glColor4ui_PACKED)); \
    packed_data->index = glColor4ui_INDEX; \
    packed_data->args.red = (GLuint)_red; \
    packed_data->args.green = (GLuint)_green; \
    packed_data->args.blue = (GLuint)_blue; \
    packed_data->args.alpha = (GLuint)_alpha; \
    (packed_call_t *)packed_data; \
})
#define call_glColor4ui(packed, ret_v) do { \
    PACKED_glColor4ui *unpacked = (PACKED_glColor4ui *)packed; \
    ARGS_glColor4ui *args = (ARGS_glColor4ui *)&unpacked->args; \
    glColor4ui(args->red, args->green, args->blue, args->alpha);; \
} while(0)
void glColor4ui(glColor4ui_ARG_EXPAND);
typedef void (*glColor4ui_PTR)(glColor4ui_ARG_EXPAND);
#define glColor4uiv_INDEX 288
#define glColor4uiv_RETURN void
#define glColor4uiv_ARG_NAMES v
#define glColor4uiv_ARG_EXPAND const GLuint * v
#define glColor4uiv_PACKED PACKED_glColor4uiv
#define glColor4uiv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glColor4uiv_NOT_VOID_WRAP(...) {}
#define pack_glColor4uiv(_v) ({ \
    glColor4uiv_PACKED *packed_data = malloc(sizeof(glColor4uiv_PACKED)); \
    packed_data->index = glColor4uiv_INDEX; \
    packed_data->args.v = (GLuint *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glColor4uiv(packed, ret_v) do { \
    PACKED_glColor4uiv *unpacked = (PACKED_glColor4uiv *)packed; \
    ARGS_glColor4uiv *args = (ARGS_glColor4uiv *)&unpacked->args; \
    glColor4uiv(args->v);; \
} while(0)
void glColor4uiv(glColor4uiv_ARG_EXPAND);
typedef void (*glColor4uiv_PTR)(glColor4uiv_ARG_EXPAND);
#define glColor4us_INDEX 289
#define glColor4us_RETURN void
#define glColor4us_ARG_NAMES red, green, blue, alpha
#define glColor4us_ARG_EXPAND GLushort red, GLushort green, GLushort blue, GLushort alpha
#define glColor4us_PACKED PACKED_glColor4us
#define glColor4us_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glColor4us_NOT_VOID_WRAP(...) {}
#define pack_glColor4us(_red, _green, _blue, _alpha) ({ \
    glColor4us_PACKED *packed_data = malloc(sizeof(glColor4us_PACKED)); \
    packed_data->index = glColor4us_INDEX; \
    packed_data->args.red = (GLushort)_red; \
    packed_data->args.green = (GLushort)_green; \
    packed_data->args.blue = (GLushort)_blue; \
    packed_data->args.alpha = (GLushort)_alpha; \
    (packed_call_t *)packed_data; \
})
#define call_glColor4us(packed, ret_v) do { \
    PACKED_glColor4us *unpacked = (PACKED_glColor4us *)packed; \
    ARGS_glColor4us *args = (ARGS_glColor4us *)&unpacked->args; \
    glColor4us(args->red, args->green, args->blue, args->alpha);; \
} while(0)
void glColor4us(glColor4us_ARG_EXPAND);
typedef void (*glColor4us_PTR)(glColor4us_ARG_EXPAND);
#define glColor4usv_INDEX 290
#define glColor4usv_RETURN void
#define glColor4usv_ARG_NAMES v
#define glColor4usv_ARG_EXPAND const GLushort * v
#define glColor4usv_PACKED PACKED_glColor4usv
#define glColor4usv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glColor4usv_NOT_VOID_WRAP(...) {}
#define pack_glColor4usv(_v) ({ \
    glColor4usv_PACKED *packed_data = malloc(sizeof(glColor4usv_PACKED)); \
    packed_data->index = glColor4usv_INDEX; \
    packed_data->args.v = (GLushort *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glColor4usv(packed, ret_v) do { \
    PACKED_glColor4usv *unpacked = (PACKED_glColor4usv *)packed; \
    ARGS_glColor4usv *args = (ARGS_glColor4usv *)&unpacked->args; \
    glColor4usv(args->v);; \
} while(0)
void glColor4usv(glColor4usv_ARG_EXPAND);
typedef void (*glColor4usv_PTR)(glColor4usv_ARG_EXPAND);
#define glColor4x_INDEX 291
#define glColor4x_RETURN void
#define glColor4x_ARG_NAMES red, green, blue, alpha
#define glColor4x_ARG_EXPAND GLfixed red, GLfixed green, GLfixed blue, GLfixed alpha
#define glColor4x_PACKED PACKED_glColor4x
#define glColor4x_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glColor4x_NOT_VOID_WRAP(...) {}
#define pack_glColor4x(_red, _green, _blue, _alpha) ({ \
    glColor4x_PACKED *packed_data = malloc(sizeof(glColor4x_PACKED)); \
    packed_data->index = glColor4x_INDEX; \
    packed_data->args.red = (GLfixed)_red; \
    packed_data->args.green = (GLfixed)_green; \
    packed_data->args.blue = (GLfixed)_blue; \
    packed_data->args.alpha = (GLfixed)_alpha; \
    (packed_call_t *)packed_data; \
})
#define call_glColor4x(packed, ret_v) do { \
    PACKED_glColor4x *unpacked = (PACKED_glColor4x *)packed; \
    ARGS_glColor4x *args = (ARGS_glColor4x *)&unpacked->args; \
    glColor4x(args->red, args->green, args->blue, args->alpha);; \
} while(0)
void glColor4x(glColor4x_ARG_EXPAND);
typedef void (*glColor4x_PTR)(glColor4x_ARG_EXPAND);
#define glColor4xOES_INDEX 292
#define glColor4xOES_RETURN void
#define glColor4xOES_ARG_NAMES red, green, blue, alpha
#define glColor4xOES_ARG_EXPAND GLfixed red, GLfixed green, GLfixed blue, GLfixed alpha
#define glColor4xOES_PACKED PACKED_glColor4xOES
#define glColor4xOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glColor4xOES_NOT_VOID_WRAP(...) {}
#define pack_glColor4xOES(_red, _green, _blue, _alpha) ({ \
    glColor4xOES_PACKED *packed_data = malloc(sizeof(glColor4xOES_PACKED)); \
    packed_data->index = glColor4xOES_INDEX; \
    packed_data->args.red = (GLfixed)_red; \
    packed_data->args.green = (GLfixed)_green; \
    packed_data->args.blue = (GLfixed)_blue; \
    packed_data->args.alpha = (GLfixed)_alpha; \
    (packed_call_t *)packed_data; \
})
#define call_glColor4xOES(packed, ret_v) do { \
    PACKED_glColor4xOES *unpacked = (PACKED_glColor4xOES *)packed; \
    ARGS_glColor4xOES *args = (ARGS_glColor4xOES *)&unpacked->args; \
    glColor4xOES(args->red, args->green, args->blue, args->alpha);; \
} while(0)
void glColor4xOES(glColor4xOES_ARG_EXPAND);
typedef void (*glColor4xOES_PTR)(glColor4xOES_ARG_EXPAND);
#define glColor4xvOES_INDEX 293
#define glColor4xvOES_RETURN void
#define glColor4xvOES_ARG_NAMES components
#define glColor4xvOES_ARG_EXPAND const GLfixed * components
#define glColor4xvOES_PACKED PACKED_glColor4xvOES
#define glColor4xvOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glColor4xvOES_NOT_VOID_WRAP(...) {}
#define pack_glColor4xvOES(_components) ({ \
    glColor4xvOES_PACKED *packed_data = malloc(sizeof(glColor4xvOES_PACKED)); \
    packed_data->index = glColor4xvOES_INDEX; \
    packed_data->args.components = (GLfixed *)_components; \
    (packed_call_t *)packed_data; \
})
#define call_glColor4xvOES(packed, ret_v) do { \
    PACKED_glColor4xvOES *unpacked = (PACKED_glColor4xvOES *)packed; \
    ARGS_glColor4xvOES *args = (ARGS_glColor4xvOES *)&unpacked->args; \
    glColor4xvOES(args->components);; \
} while(0)
void glColor4xvOES(glColor4xvOES_ARG_EXPAND);
typedef void (*glColor4xvOES_PTR)(glColor4xvOES_ARG_EXPAND);
#define glColorFormatNV_INDEX 294
#define glColorFormatNV_RETURN void
#define glColorFormatNV_ARG_NAMES size, type, stride
#define glColorFormatNV_ARG_EXPAND GLint size, GLenum type, GLsizei stride
#define glColorFormatNV_PACKED PACKED_glColorFormatNV
#define glColorFormatNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glColorFormatNV_NOT_VOID_WRAP(...) {}
#define pack_glColorFormatNV(_size, _type, _stride) ({ \
    glColorFormatNV_PACKED *packed_data = malloc(sizeof(glColorFormatNV_PACKED)); \
    packed_data->index = glColorFormatNV_INDEX; \
    packed_data->args.size = (GLint)_size; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.stride = (GLsizei)_stride; \
    (packed_call_t *)packed_data; \
})
#define call_glColorFormatNV(packed, ret_v) do { \
    PACKED_glColorFormatNV *unpacked = (PACKED_glColorFormatNV *)packed; \
    ARGS_glColorFormatNV *args = (ARGS_glColorFormatNV *)&unpacked->args; \
    glColorFormatNV(args->size, args->type, args->stride);; \
} while(0)
void glColorFormatNV(glColorFormatNV_ARG_EXPAND);
typedef void (*glColorFormatNV_PTR)(glColorFormatNV_ARG_EXPAND);
#define glColorFragmentOp1ATI_INDEX 295
#define glColorFragmentOp1ATI_RETURN void
#define glColorFragmentOp1ATI_ARG_NAMES op, dst, dstMask, dstMod, arg1, arg1Rep, arg1Mod
#define glColorFragmentOp1ATI_ARG_EXPAND GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod
#define glColorFragmentOp1ATI_PACKED PACKED_glColorFragmentOp1ATI
#define glColorFragmentOp1ATI_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glColorFragmentOp1ATI_NOT_VOID_WRAP(...) {}
#define pack_glColorFragmentOp1ATI(_op, _dst, _dstMask, _dstMod, _arg1, _arg1Rep, _arg1Mod) ({ \
    glColorFragmentOp1ATI_PACKED *packed_data = malloc(sizeof(glColorFragmentOp1ATI_PACKED)); \
    packed_data->index = glColorFragmentOp1ATI_INDEX; \
    packed_data->args.op = (GLenum)_op; \
    packed_data->args.dst = (GLuint)_dst; \
    packed_data->args.dstMask = (GLuint)_dstMask; \
    packed_data->args.dstMod = (GLuint)_dstMod; \
    packed_data->args.arg1 = (GLuint)_arg1; \
    packed_data->args.arg1Rep = (GLuint)_arg1Rep; \
    packed_data->args.arg1Mod = (GLuint)_arg1Mod; \
    (packed_call_t *)packed_data; \
})
#define call_glColorFragmentOp1ATI(packed, ret_v) do { \
    PACKED_glColorFragmentOp1ATI *unpacked = (PACKED_glColorFragmentOp1ATI *)packed; \
    ARGS_glColorFragmentOp1ATI *args = (ARGS_glColorFragmentOp1ATI *)&unpacked->args; \
    glColorFragmentOp1ATI(args->op, args->dst, args->dstMask, args->dstMod, args->arg1, args->arg1Rep, args->arg1Mod);; \
} while(0)
void glColorFragmentOp1ATI(glColorFragmentOp1ATI_ARG_EXPAND);
typedef void (*glColorFragmentOp1ATI_PTR)(glColorFragmentOp1ATI_ARG_EXPAND);
#define glColorFragmentOp2ATI_INDEX 296
#define glColorFragmentOp2ATI_RETURN void
#define glColorFragmentOp2ATI_ARG_NAMES op, dst, dstMask, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod
#define glColorFragmentOp2ATI_ARG_EXPAND GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod
#define glColorFragmentOp2ATI_PACKED PACKED_glColorFragmentOp2ATI
#define glColorFragmentOp2ATI_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glColorFragmentOp2ATI_NOT_VOID_WRAP(...) {}
#define pack_glColorFragmentOp2ATI(_op, _dst, _dstMask, _dstMod, _arg1, _arg1Rep, _arg1Mod, _arg2, _arg2Rep, _arg2Mod) ({ \
    glColorFragmentOp2ATI_PACKED *packed_data = malloc(sizeof(glColorFragmentOp2ATI_PACKED)); \
    packed_data->index = glColorFragmentOp2ATI_INDEX; \
    packed_data->args.op = (GLenum)_op; \
    packed_data->args.dst = (GLuint)_dst; \
    packed_data->args.dstMask = (GLuint)_dstMask; \
    packed_data->args.dstMod = (GLuint)_dstMod; \
    packed_data->args.arg1 = (GLuint)_arg1; \
    packed_data->args.arg1Rep = (GLuint)_arg1Rep; \
    packed_data->args.arg1Mod = (GLuint)_arg1Mod; \
    packed_data->args.arg2 = (GLuint)_arg2; \
    packed_data->args.arg2Rep = (GLuint)_arg2Rep; \
    packed_data->args.arg2Mod = (GLuint)_arg2Mod; \
    (packed_call_t *)packed_data; \
})
#define call_glColorFragmentOp2ATI(packed, ret_v) do { \
    PACKED_glColorFragmentOp2ATI *unpacked = (PACKED_glColorFragmentOp2ATI *)packed; \
    ARGS_glColorFragmentOp2ATI *args = (ARGS_glColorFragmentOp2ATI *)&unpacked->args; \
    glColorFragmentOp2ATI(args->op, args->dst, args->dstMask, args->dstMod, args->arg1, args->arg1Rep, args->arg1Mod, args->arg2, args->arg2Rep, args->arg2Mod);; \
} while(0)
void glColorFragmentOp2ATI(glColorFragmentOp2ATI_ARG_EXPAND);
typedef void (*glColorFragmentOp2ATI_PTR)(glColorFragmentOp2ATI_ARG_EXPAND);
#define glColorFragmentOp3ATI_INDEX 297
#define glColorFragmentOp3ATI_RETURN void
#define glColorFragmentOp3ATI_ARG_NAMES op, dst, dstMask, dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod, arg3, arg3Rep, arg3Mod
#define glColorFragmentOp3ATI_ARG_EXPAND GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod, GLuint arg3, GLuint arg3Rep, GLuint arg3Mod
#define glColorFragmentOp3ATI_PACKED PACKED_glColorFragmentOp3ATI
#define glColorFragmentOp3ATI_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glColorFragmentOp3ATI_NOT_VOID_WRAP(...) {}
#define pack_glColorFragmentOp3ATI(_op, _dst, _dstMask, _dstMod, _arg1, _arg1Rep, _arg1Mod, _arg2, _arg2Rep, _arg2Mod, _arg3, _arg3Rep, _arg3Mod) ({ \
    glColorFragmentOp3ATI_PACKED *packed_data = malloc(sizeof(glColorFragmentOp3ATI_PACKED)); \
    packed_data->index = glColorFragmentOp3ATI_INDEX; \
    packed_data->args.op = (GLenum)_op; \
    packed_data->args.dst = (GLuint)_dst; \
    packed_data->args.dstMask = (GLuint)_dstMask; \
    packed_data->args.dstMod = (GLuint)_dstMod; \
    packed_data->args.arg1 = (GLuint)_arg1; \
    packed_data->args.arg1Rep = (GLuint)_arg1Rep; \
    packed_data->args.arg1Mod = (GLuint)_arg1Mod; \
    packed_data->args.arg2 = (GLuint)_arg2; \
    packed_data->args.arg2Rep = (GLuint)_arg2Rep; \
    packed_data->args.arg2Mod = (GLuint)_arg2Mod; \
    packed_data->args.arg3 = (GLuint)_arg3; \
    packed_data->args.arg3Rep = (GLuint)_arg3Rep; \
    packed_data->args.arg3Mod = (GLuint)_arg3Mod; \
    (packed_call_t *)packed_data; \
})
#define call_glColorFragmentOp3ATI(packed, ret_v) do { \
    PACKED_glColorFragmentOp3ATI *unpacked = (PACKED_glColorFragmentOp3ATI *)packed; \
    ARGS_glColorFragmentOp3ATI *args = (ARGS_glColorFragmentOp3ATI *)&unpacked->args; \
    glColorFragmentOp3ATI(args->op, args->dst, args->dstMask, args->dstMod, args->arg1, args->arg1Rep, args->arg1Mod, args->arg2, args->arg2Rep, args->arg2Mod, args->arg3, args->arg3Rep, args->arg3Mod);; \
} while(0)
void glColorFragmentOp3ATI(glColorFragmentOp3ATI_ARG_EXPAND);
typedef void (*glColorFragmentOp3ATI_PTR)(glColorFragmentOp3ATI_ARG_EXPAND);
#define glColorMask_INDEX 298
#define glColorMask_RETURN void
#define glColorMask_ARG_NAMES red, green, blue, alpha
#define glColorMask_ARG_EXPAND GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha
#define glColorMask_PACKED PACKED_glColorMask
#define glColorMask_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glColorMask_NOT_VOID_WRAP(...) {}
#define pack_glColorMask(_red, _green, _blue, _alpha) ({ \
    glColorMask_PACKED *packed_data = malloc(sizeof(glColorMask_PACKED)); \
    packed_data->index = glColorMask_INDEX; \
    packed_data->args.red = (GLboolean)_red; \
    packed_data->args.green = (GLboolean)_green; \
    packed_data->args.blue = (GLboolean)_blue; \
    packed_data->args.alpha = (GLboolean)_alpha; \
    (packed_call_t *)packed_data; \
})
#define call_glColorMask(packed, ret_v) do { \
    PACKED_glColorMask *unpacked = (PACKED_glColorMask *)packed; \
    ARGS_glColorMask *args = (ARGS_glColorMask *)&unpacked->args; \
    glColorMask(args->red, args->green, args->blue, args->alpha);; \
} while(0)
void glColorMask(glColorMask_ARG_EXPAND);
typedef void (*glColorMask_PTR)(glColorMask_ARG_EXPAND);
#define glColorMaskIndexedEXT_INDEX 299
#define glColorMaskIndexedEXT_RETURN void
#define glColorMaskIndexedEXT_ARG_NAMES index, r, g, b, a
#define glColorMaskIndexedEXT_ARG_EXPAND GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a
#define glColorMaskIndexedEXT_PACKED PACKED_glColorMaskIndexedEXT
#define glColorMaskIndexedEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glColorMaskIndexedEXT_NOT_VOID_WRAP(...) {}
#define pack_glColorMaskIndexedEXT(_index, _r, _g, _b, _a) ({ \
    glColorMaskIndexedEXT_PACKED *packed_data = malloc(sizeof(glColorMaskIndexedEXT_PACKED)); \
    packed_data->index = glColorMaskIndexedEXT_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.r = (GLboolean)_r; \
    packed_data->args.g = (GLboolean)_g; \
    packed_data->args.b = (GLboolean)_b; \
    packed_data->args.a = (GLboolean)_a; \
    (packed_call_t *)packed_data; \
})
#define call_glColorMaskIndexedEXT(packed, ret_v) do { \
    PACKED_glColorMaskIndexedEXT *unpacked = (PACKED_glColorMaskIndexedEXT *)packed; \
    ARGS_glColorMaskIndexedEXT *args = (ARGS_glColorMaskIndexedEXT *)&unpacked->args; \
    glColorMaskIndexedEXT(args->index, args->r, args->g, args->b, args->a);; \
} while(0)
void glColorMaskIndexedEXT(glColorMaskIndexedEXT_ARG_EXPAND);
typedef void (*glColorMaskIndexedEXT_PTR)(glColorMaskIndexedEXT_ARG_EXPAND);
#define glColorMaski_INDEX 300
#define glColorMaski_RETURN void
#define glColorMaski_ARG_NAMES index, r, g, b, a
#define glColorMaski_ARG_EXPAND GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a
#define glColorMaski_PACKED PACKED_glColorMaski
#define glColorMaski_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glColorMaski_NOT_VOID_WRAP(...) {}
#define pack_glColorMaski(_index, _r, _g, _b, _a) ({ \
    glColorMaski_PACKED *packed_data = malloc(sizeof(glColorMaski_PACKED)); \
    packed_data->index = glColorMaski_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.r = (GLboolean)_r; \
    packed_data->args.g = (GLboolean)_g; \
    packed_data->args.b = (GLboolean)_b; \
    packed_data->args.a = (GLboolean)_a; \
    (packed_call_t *)packed_data; \
})
#define call_glColorMaski(packed, ret_v) do { \
    PACKED_glColorMaski *unpacked = (PACKED_glColorMaski *)packed; \
    ARGS_glColorMaski *args = (ARGS_glColorMaski *)&unpacked->args; \
    glColorMaski(args->index, args->r, args->g, args->b, args->a);; \
} while(0)
void glColorMaski(glColorMaski_ARG_EXPAND);
typedef void (*glColorMaski_PTR)(glColorMaski_ARG_EXPAND);
#define glColorMaterial_INDEX 301
#define glColorMaterial_RETURN void
#define glColorMaterial_ARG_NAMES face, mode
#define glColorMaterial_ARG_EXPAND GLenum face, GLenum mode
#define glColorMaterial_PACKED PACKED_glColorMaterial
#define glColorMaterial_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glColorMaterial_NOT_VOID_WRAP(...) {}
#define pack_glColorMaterial(_face, _mode) ({ \
    glColorMaterial_PACKED *packed_data = malloc(sizeof(glColorMaterial_PACKED)); \
    packed_data->index = glColorMaterial_INDEX; \
    packed_data->args.face = (GLenum)_face; \
    packed_data->args.mode = (GLenum)_mode; \
    (packed_call_t *)packed_data; \
})
#define call_glColorMaterial(packed, ret_v) do { \
    PACKED_glColorMaterial *unpacked = (PACKED_glColorMaterial *)packed; \
    ARGS_glColorMaterial *args = (ARGS_glColorMaterial *)&unpacked->args; \
    glColorMaterial(args->face, args->mode);; \
} while(0)
void glColorMaterial(glColorMaterial_ARG_EXPAND);
typedef void (*glColorMaterial_PTR)(glColorMaterial_ARG_EXPAND);
#define glColorP3ui_INDEX 302
#define glColorP3ui_RETURN void
#define glColorP3ui_ARG_NAMES type, color
#define glColorP3ui_ARG_EXPAND GLenum type, GLuint color
#define glColorP3ui_PACKED PACKED_glColorP3ui
#define glColorP3ui_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glColorP3ui_NOT_VOID_WRAP(...) {}
#define pack_glColorP3ui(_type, _color) ({ \
    glColorP3ui_PACKED *packed_data = malloc(sizeof(glColorP3ui_PACKED)); \
    packed_data->index = glColorP3ui_INDEX; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.color = (GLuint)_color; \
    (packed_call_t *)packed_data; \
})
#define call_glColorP3ui(packed, ret_v) do { \
    PACKED_glColorP3ui *unpacked = (PACKED_glColorP3ui *)packed; \
    ARGS_glColorP3ui *args = (ARGS_glColorP3ui *)&unpacked->args; \
    glColorP3ui(args->type, args->color);; \
} while(0)
void glColorP3ui(glColorP3ui_ARG_EXPAND);
typedef void (*glColorP3ui_PTR)(glColorP3ui_ARG_EXPAND);
#define glColorP3uiv_INDEX 303
#define glColorP3uiv_RETURN void
#define glColorP3uiv_ARG_NAMES type, color
#define glColorP3uiv_ARG_EXPAND GLenum type, const GLuint * color
#define glColorP3uiv_PACKED PACKED_glColorP3uiv
#define glColorP3uiv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glColorP3uiv_NOT_VOID_WRAP(...) {}
#define pack_glColorP3uiv(_type, _color) ({ \
    glColorP3uiv_PACKED *packed_data = malloc(sizeof(glColorP3uiv_PACKED)); \
    packed_data->index = glColorP3uiv_INDEX; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.color = (GLuint *)_color; \
    (packed_call_t *)packed_data; \
})
#define call_glColorP3uiv(packed, ret_v) do { \
    PACKED_glColorP3uiv *unpacked = (PACKED_glColorP3uiv *)packed; \
    ARGS_glColorP3uiv *args = (ARGS_glColorP3uiv *)&unpacked->args; \
    glColorP3uiv(args->type, args->color);; \
} while(0)
void glColorP3uiv(glColorP3uiv_ARG_EXPAND);
typedef void (*glColorP3uiv_PTR)(glColorP3uiv_ARG_EXPAND);
#define glColorP4ui_INDEX 304
#define glColorP4ui_RETURN void
#define glColorP4ui_ARG_NAMES type, color
#define glColorP4ui_ARG_EXPAND GLenum type, GLuint color
#define glColorP4ui_PACKED PACKED_glColorP4ui
#define glColorP4ui_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glColorP4ui_NOT_VOID_WRAP(...) {}
#define pack_glColorP4ui(_type, _color) ({ \
    glColorP4ui_PACKED *packed_data = malloc(sizeof(glColorP4ui_PACKED)); \
    packed_data->index = glColorP4ui_INDEX; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.color = (GLuint)_color; \
    (packed_call_t *)packed_data; \
})
#define call_glColorP4ui(packed, ret_v) do { \
    PACKED_glColorP4ui *unpacked = (PACKED_glColorP4ui *)packed; \
    ARGS_glColorP4ui *args = (ARGS_glColorP4ui *)&unpacked->args; \
    glColorP4ui(args->type, args->color);; \
} while(0)
void glColorP4ui(glColorP4ui_ARG_EXPAND);
typedef void (*glColorP4ui_PTR)(glColorP4ui_ARG_EXPAND);
#define glColorP4uiv_INDEX 305
#define glColorP4uiv_RETURN void
#define glColorP4uiv_ARG_NAMES type, color
#define glColorP4uiv_ARG_EXPAND GLenum type, const GLuint * color
#define glColorP4uiv_PACKED PACKED_glColorP4uiv
#define glColorP4uiv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glColorP4uiv_NOT_VOID_WRAP(...) {}
#define pack_glColorP4uiv(_type, _color) ({ \
    glColorP4uiv_PACKED *packed_data = malloc(sizeof(glColorP4uiv_PACKED)); \
    packed_data->index = glColorP4uiv_INDEX; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.color = (GLuint *)_color; \
    (packed_call_t *)packed_data; \
})
#define call_glColorP4uiv(packed, ret_v) do { \
    PACKED_glColorP4uiv *unpacked = (PACKED_glColorP4uiv *)packed; \
    ARGS_glColorP4uiv *args = (ARGS_glColorP4uiv *)&unpacked->args; \
    glColorP4uiv(args->type, args->color);; \
} while(0)
void glColorP4uiv(glColorP4uiv_ARG_EXPAND);
typedef void (*glColorP4uiv_PTR)(glColorP4uiv_ARG_EXPAND);
#define glColorPointer_INDEX 306
#define glColorPointer_RETURN void
#define glColorPointer_ARG_NAMES size, type, stride, pointer
#define glColorPointer_ARG_EXPAND GLint size, GLenum type, GLsizei stride, const GLvoid * pointer
#define glColorPointer_PACKED PACKED_glColorPointer
#define glColorPointer_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glColorPointer_NOT_VOID_WRAP(...) {}
#define pack_glColorPointer(_size, _type, _stride, _pointer) ({ \
    glColorPointer_PACKED *packed_data = malloc(sizeof(glColorPointer_PACKED)); \
    packed_data->index = glColorPointer_INDEX; \
    packed_data->args.size = (GLint)_size; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.stride = (GLsizei)_stride; \
    packed_data->args.pointer = (GLvoid *)_pointer; \
    (packed_call_t *)packed_data; \
})
#define call_glColorPointer(packed, ret_v) do { \
    PACKED_glColorPointer *unpacked = (PACKED_glColorPointer *)packed; \
    ARGS_glColorPointer *args = (ARGS_glColorPointer *)&unpacked->args; \
    glColorPointer(args->size, args->type, args->stride, args->pointer);; \
} while(0)
void glColorPointer(glColorPointer_ARG_EXPAND);
typedef void (*glColorPointer_PTR)(glColorPointer_ARG_EXPAND);
#define glColorPointerEXT_INDEX 307
#define glColorPointerEXT_RETURN void
#define glColorPointerEXT_ARG_NAMES size, type, stride, count, pointer
#define glColorPointerEXT_ARG_EXPAND GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid * pointer
#define glColorPointerEXT_PACKED PACKED_glColorPointerEXT
#define glColorPointerEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glColorPointerEXT_NOT_VOID_WRAP(...) {}
#define pack_glColorPointerEXT(_size, _type, _stride, _count, _pointer) ({ \
    glColorPointerEXT_PACKED *packed_data = malloc(sizeof(glColorPointerEXT_PACKED)); \
    packed_data->index = glColorPointerEXT_INDEX; \
    packed_data->args.size = (GLint)_size; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.stride = (GLsizei)_stride; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.pointer = (GLvoid *)_pointer; \
    (packed_call_t *)packed_data; \
})
#define call_glColorPointerEXT(packed, ret_v) do { \
    PACKED_glColorPointerEXT *unpacked = (PACKED_glColorPointerEXT *)packed; \
    ARGS_glColorPointerEXT *args = (ARGS_glColorPointerEXT *)&unpacked->args; \
    glColorPointerEXT(args->size, args->type, args->stride, args->count, args->pointer);; \
} while(0)
void glColorPointerEXT(glColorPointerEXT_ARG_EXPAND);
typedef void (*glColorPointerEXT_PTR)(glColorPointerEXT_ARG_EXPAND);
#define glColorPointerListIBM_INDEX 308
#define glColorPointerListIBM_RETURN void
#define glColorPointerListIBM_ARG_NAMES size, type, stride, pointer, ptrstride
#define glColorPointerListIBM_ARG_EXPAND GLint size, GLenum type, GLint stride, const GLvoid * pointer, GLint ptrstride
#define glColorPointerListIBM_PACKED PACKED_glColorPointerListIBM
#define glColorPointerListIBM_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glColorPointerListIBM_NOT_VOID_WRAP(...) {}
#define pack_glColorPointerListIBM(_size, _type, _stride, _pointer, _ptrstride) ({ \
    glColorPointerListIBM_PACKED *packed_data = malloc(sizeof(glColorPointerListIBM_PACKED)); \
    packed_data->index = glColorPointerListIBM_INDEX; \
    packed_data->args.size = (GLint)_size; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.stride = (GLint)_stride; \
    packed_data->args.pointer = (GLvoid *)_pointer; \
    packed_data->args.ptrstride = (GLint)_ptrstride; \
    (packed_call_t *)packed_data; \
})
#define call_glColorPointerListIBM(packed, ret_v) do { \
    PACKED_glColorPointerListIBM *unpacked = (PACKED_glColorPointerListIBM *)packed; \
    ARGS_glColorPointerListIBM *args = (ARGS_glColorPointerListIBM *)&unpacked->args; \
    glColorPointerListIBM(args->size, args->type, args->stride, args->pointer, args->ptrstride);; \
} while(0)
void glColorPointerListIBM(glColorPointerListIBM_ARG_EXPAND);
typedef void (*glColorPointerListIBM_PTR)(glColorPointerListIBM_ARG_EXPAND);
#define glColorPointervINTEL_INDEX 309
#define glColorPointervINTEL_RETURN void
#define glColorPointervINTEL_ARG_NAMES size, type, pointer
#define glColorPointervINTEL_ARG_EXPAND GLint size, GLenum type, const GLvoid * pointer
#define glColorPointervINTEL_PACKED PACKED_glColorPointervINTEL
#define glColorPointervINTEL_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glColorPointervINTEL_NOT_VOID_WRAP(...) {}
#define pack_glColorPointervINTEL(_size, _type, _pointer) ({ \
    glColorPointervINTEL_PACKED *packed_data = malloc(sizeof(glColorPointervINTEL_PACKED)); \
    packed_data->index = glColorPointervINTEL_INDEX; \
    packed_data->args.size = (GLint)_size; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.pointer = (GLvoid *)_pointer; \
    (packed_call_t *)packed_data; \
})
#define call_glColorPointervINTEL(packed, ret_v) do { \
    PACKED_glColorPointervINTEL *unpacked = (PACKED_glColorPointervINTEL *)packed; \
    ARGS_glColorPointervINTEL *args = (ARGS_glColorPointervINTEL *)&unpacked->args; \
    glColorPointervINTEL(args->size, args->type, args->pointer);; \
} while(0)
void glColorPointervINTEL(glColorPointervINTEL_ARG_EXPAND);
typedef void (*glColorPointervINTEL_PTR)(glColorPointervINTEL_ARG_EXPAND);
#define glColorSubTable_INDEX 310
#define glColorSubTable_RETURN void
#define glColorSubTable_ARG_NAMES target, start, count, format, type, data
#define glColorSubTable_ARG_EXPAND GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const GLvoid * data
#define glColorSubTable_PACKED PACKED_glColorSubTable
#define glColorSubTable_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glColorSubTable_NOT_VOID_WRAP(...) {}
#define pack_glColorSubTable(_target, _start, _count, _format, _type, _data) ({ \
    glColorSubTable_PACKED *packed_data = malloc(sizeof(glColorSubTable_PACKED)); \
    packed_data->index = glColorSubTable_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.start = (GLsizei)_start; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.format = (GLenum)_format; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.data = (GLvoid *)_data; \
    (packed_call_t *)packed_data; \
})
#define call_glColorSubTable(packed, ret_v) do { \
    PACKED_glColorSubTable *unpacked = (PACKED_glColorSubTable *)packed; \
    ARGS_glColorSubTable *args = (ARGS_glColorSubTable *)&unpacked->args; \
    glColorSubTable(args->target, args->start, args->count, args->format, args->type, args->data);; \
} while(0)
void glColorSubTable(glColorSubTable_ARG_EXPAND);
typedef void (*glColorSubTable_PTR)(glColorSubTable_ARG_EXPAND);
#define glColorSubTableEXT_INDEX 311
#define glColorSubTableEXT_RETURN void
#define glColorSubTableEXT_ARG_NAMES target, start, count, format, type, data
#define glColorSubTableEXT_ARG_EXPAND GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const GLvoid * data
#define glColorSubTableEXT_PACKED PACKED_glColorSubTableEXT
#define glColorSubTableEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glColorSubTableEXT_NOT_VOID_WRAP(...) {}
#define pack_glColorSubTableEXT(_target, _start, _count, _format, _type, _data) ({ \
    glColorSubTableEXT_PACKED *packed_data = malloc(sizeof(glColorSubTableEXT_PACKED)); \
    packed_data->index = glColorSubTableEXT_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.start = (GLsizei)_start; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.format = (GLenum)_format; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.data = (GLvoid *)_data; \
    (packed_call_t *)packed_data; \
})
#define call_glColorSubTableEXT(packed, ret_v) do { \
    PACKED_glColorSubTableEXT *unpacked = (PACKED_glColorSubTableEXT *)packed; \
    ARGS_glColorSubTableEXT *args = (ARGS_glColorSubTableEXT *)&unpacked->args; \
    glColorSubTableEXT(args->target, args->start, args->count, args->format, args->type, args->data);; \
} while(0)
void glColorSubTableEXT(glColorSubTableEXT_ARG_EXPAND);
typedef void (*glColorSubTableEXT_PTR)(glColorSubTableEXT_ARG_EXPAND);
#define glColorTable_INDEX 312
#define glColorTable_RETURN void
#define glColorTable_ARG_NAMES target, internalformat, width, format, type, table
#define glColorTable_ARG_EXPAND GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid * table
#define glColorTable_PACKED PACKED_glColorTable
#define glColorTable_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glColorTable_NOT_VOID_WRAP(...) {}
#define pack_glColorTable(_target, _internalformat, _width, _format, _type, _table) ({ \
    glColorTable_PACKED *packed_data = malloc(sizeof(glColorTable_PACKED)); \
    packed_data->index = glColorTable_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.internalformat = (GLenum)_internalformat; \
    packed_data->args.width = (GLsizei)_width; \
    packed_data->args.format = (GLenum)_format; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.table = (GLvoid *)_table; \
    (packed_call_t *)packed_data; \
})
#define call_glColorTable(packed, ret_v) do { \
    PACKED_glColorTable *unpacked = (PACKED_glColorTable *)packed; \
    ARGS_glColorTable *args = (ARGS_glColorTable *)&unpacked->args; \
    glColorTable(args->target, args->internalformat, args->width, args->format, args->type, args->table);; \
} while(0)
void glColorTable(glColorTable_ARG_EXPAND);
typedef void (*glColorTable_PTR)(glColorTable_ARG_EXPAND);
#define glColorTableEXT_INDEX 313
#define glColorTableEXT_RETURN void
#define glColorTableEXT_ARG_NAMES target, internalFormat, width, format, type, table
#define glColorTableEXT_ARG_EXPAND GLenum target, GLenum internalFormat, GLsizei width, GLenum format, GLenum type, const GLvoid * table
#define glColorTableEXT_PACKED PACKED_glColorTableEXT
#define glColorTableEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glColorTableEXT_NOT_VOID_WRAP(...) {}
#define pack_glColorTableEXT(_target, _internalFormat, _width, _format, _type, _table) ({ \
    glColorTableEXT_PACKED *packed_data = malloc(sizeof(glColorTableEXT_PACKED)); \
    packed_data->index = glColorTableEXT_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.internalFormat = (GLenum)_internalFormat; \
    packed_data->args.width = (GLsizei)_width; \
    packed_data->args.format = (GLenum)_format; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.table = (GLvoid *)_table; \
    (packed_call_t *)packed_data; \
})
#define call_glColorTableEXT(packed, ret_v) do { \
    PACKED_glColorTableEXT *unpacked = (PACKED_glColorTableEXT *)packed; \
    ARGS_glColorTableEXT *args = (ARGS_glColorTableEXT *)&unpacked->args; \
    glColorTableEXT(args->target, args->internalFormat, args->width, args->format, args->type, args->table);; \
} while(0)
void glColorTableEXT(glColorTableEXT_ARG_EXPAND);
typedef void (*glColorTableEXT_PTR)(glColorTableEXT_ARG_EXPAND);
#define glColorTableParameterfv_INDEX 314
#define glColorTableParameterfv_RETURN void
#define glColorTableParameterfv_ARG_NAMES target, pname, params
#define glColorTableParameterfv_ARG_EXPAND GLenum target, GLenum pname, const GLfloat * params
#define glColorTableParameterfv_PACKED PACKED_glColorTableParameterfv
#define glColorTableParameterfv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glColorTableParameterfv_NOT_VOID_WRAP(...) {}
#define pack_glColorTableParameterfv(_target, _pname, _params) ({ \
    glColorTableParameterfv_PACKED *packed_data = malloc(sizeof(glColorTableParameterfv_PACKED)); \
    packed_data->index = glColorTableParameterfv_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLfloat *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glColorTableParameterfv(packed, ret_v) do { \
    PACKED_glColorTableParameterfv *unpacked = (PACKED_glColorTableParameterfv *)packed; \
    ARGS_glColorTableParameterfv *args = (ARGS_glColorTableParameterfv *)&unpacked->args; \
    glColorTableParameterfv(args->target, args->pname, args->params);; \
} while(0)
void glColorTableParameterfv(glColorTableParameterfv_ARG_EXPAND);
typedef void (*glColorTableParameterfv_PTR)(glColorTableParameterfv_ARG_EXPAND);
#define glColorTableParameterfvSGI_INDEX 315
#define glColorTableParameterfvSGI_RETURN void
#define glColorTableParameterfvSGI_ARG_NAMES target, pname, params
#define glColorTableParameterfvSGI_ARG_EXPAND GLenum target, GLenum pname, const GLfloat * params
#define glColorTableParameterfvSGI_PACKED PACKED_glColorTableParameterfvSGI
#define glColorTableParameterfvSGI_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glColorTableParameterfvSGI_NOT_VOID_WRAP(...) {}
#define pack_glColorTableParameterfvSGI(_target, _pname, _params) ({ \
    glColorTableParameterfvSGI_PACKED *packed_data = malloc(sizeof(glColorTableParameterfvSGI_PACKED)); \
    packed_data->index = glColorTableParameterfvSGI_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLfloat *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glColorTableParameterfvSGI(packed, ret_v) do { \
    PACKED_glColorTableParameterfvSGI *unpacked = (PACKED_glColorTableParameterfvSGI *)packed; \
    ARGS_glColorTableParameterfvSGI *args = (ARGS_glColorTableParameterfvSGI *)&unpacked->args; \
    glColorTableParameterfvSGI(args->target, args->pname, args->params);; \
} while(0)
void glColorTableParameterfvSGI(glColorTableParameterfvSGI_ARG_EXPAND);
typedef void (*glColorTableParameterfvSGI_PTR)(glColorTableParameterfvSGI_ARG_EXPAND);
#define glColorTableParameteriv_INDEX 316
#define glColorTableParameteriv_RETURN void
#define glColorTableParameteriv_ARG_NAMES target, pname, params
#define glColorTableParameteriv_ARG_EXPAND GLenum target, GLenum pname, const GLint * params
#define glColorTableParameteriv_PACKED PACKED_glColorTableParameteriv
#define glColorTableParameteriv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glColorTableParameteriv_NOT_VOID_WRAP(...) {}
#define pack_glColorTableParameteriv(_target, _pname, _params) ({ \
    glColorTableParameteriv_PACKED *packed_data = malloc(sizeof(glColorTableParameteriv_PACKED)); \
    packed_data->index = glColorTableParameteriv_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glColorTableParameteriv(packed, ret_v) do { \
    PACKED_glColorTableParameteriv *unpacked = (PACKED_glColorTableParameteriv *)packed; \
    ARGS_glColorTableParameteriv *args = (ARGS_glColorTableParameteriv *)&unpacked->args; \
    glColorTableParameteriv(args->target, args->pname, args->params);; \
} while(0)
void glColorTableParameteriv(glColorTableParameteriv_ARG_EXPAND);
typedef void (*glColorTableParameteriv_PTR)(glColorTableParameteriv_ARG_EXPAND);
#define glColorTableParameterivSGI_INDEX 317
#define glColorTableParameterivSGI_RETURN void
#define glColorTableParameterivSGI_ARG_NAMES target, pname, params
#define glColorTableParameterivSGI_ARG_EXPAND GLenum target, GLenum pname, const GLint * params
#define glColorTableParameterivSGI_PACKED PACKED_glColorTableParameterivSGI
#define glColorTableParameterivSGI_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glColorTableParameterivSGI_NOT_VOID_WRAP(...) {}
#define pack_glColorTableParameterivSGI(_target, _pname, _params) ({ \
    glColorTableParameterivSGI_PACKED *packed_data = malloc(sizeof(glColorTableParameterivSGI_PACKED)); \
    packed_data->index = glColorTableParameterivSGI_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glColorTableParameterivSGI(packed, ret_v) do { \
    PACKED_glColorTableParameterivSGI *unpacked = (PACKED_glColorTableParameterivSGI *)packed; \
    ARGS_glColorTableParameterivSGI *args = (ARGS_glColorTableParameterivSGI *)&unpacked->args; \
    glColorTableParameterivSGI(args->target, args->pname, args->params);; \
} while(0)
void glColorTableParameterivSGI(glColorTableParameterivSGI_ARG_EXPAND);
typedef void (*glColorTableParameterivSGI_PTR)(glColorTableParameterivSGI_ARG_EXPAND);
#define glColorTableSGI_INDEX 318
#define glColorTableSGI_RETURN void
#define glColorTableSGI_ARG_NAMES target, internalformat, width, format, type, table
#define glColorTableSGI_ARG_EXPAND GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid * table
#define glColorTableSGI_PACKED PACKED_glColorTableSGI
#define glColorTableSGI_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glColorTableSGI_NOT_VOID_WRAP(...) {}
#define pack_glColorTableSGI(_target, _internalformat, _width, _format, _type, _table) ({ \
    glColorTableSGI_PACKED *packed_data = malloc(sizeof(glColorTableSGI_PACKED)); \
    packed_data->index = glColorTableSGI_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.internalformat = (GLenum)_internalformat; \
    packed_data->args.width = (GLsizei)_width; \
    packed_data->args.format = (GLenum)_format; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.table = (GLvoid *)_table; \
    (packed_call_t *)packed_data; \
})
#define call_glColorTableSGI(packed, ret_v) do { \
    PACKED_glColorTableSGI *unpacked = (PACKED_glColorTableSGI *)packed; \
    ARGS_glColorTableSGI *args = (ARGS_glColorTableSGI *)&unpacked->args; \
    glColorTableSGI(args->target, args->internalformat, args->width, args->format, args->type, args->table);; \
} while(0)
void glColorTableSGI(glColorTableSGI_ARG_EXPAND);
typedef void (*glColorTableSGI_PTR)(glColorTableSGI_ARG_EXPAND);
#define glCombinerInputNV_INDEX 319
#define glCombinerInputNV_RETURN void
#define glCombinerInputNV_ARG_NAMES stage, portion, variable, input, mapping, componentUsage
#define glCombinerInputNV_ARG_EXPAND GLenum stage, GLenum portion, GLenum variable, GLenum input, GLenum mapping, GLenum componentUsage
#define glCombinerInputNV_PACKED PACKED_glCombinerInputNV
#define glCombinerInputNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glCombinerInputNV_NOT_VOID_WRAP(...) {}
#define pack_glCombinerInputNV(_stage, _portion, _variable, _input, _mapping, _componentUsage) ({ \
    glCombinerInputNV_PACKED *packed_data = malloc(sizeof(glCombinerInputNV_PACKED)); \
    packed_data->index = glCombinerInputNV_INDEX; \
    packed_data->args.stage = (GLenum)_stage; \
    packed_data->args.portion = (GLenum)_portion; \
    packed_data->args.variable = (GLenum)_variable; \
    packed_data->args.input = (GLenum)_input; \
    packed_data->args.mapping = (GLenum)_mapping; \
    packed_data->args.componentUsage = (GLenum)_componentUsage; \
    (packed_call_t *)packed_data; \
})
#define call_glCombinerInputNV(packed, ret_v) do { \
    PACKED_glCombinerInputNV *unpacked = (PACKED_glCombinerInputNV *)packed; \
    ARGS_glCombinerInputNV *args = (ARGS_glCombinerInputNV *)&unpacked->args; \
    glCombinerInputNV(args->stage, args->portion, args->variable, args->input, args->mapping, args->componentUsage);; \
} while(0)
void glCombinerInputNV(glCombinerInputNV_ARG_EXPAND);
typedef void (*glCombinerInputNV_PTR)(glCombinerInputNV_ARG_EXPAND);
#define glCombinerOutputNV_INDEX 320
#define glCombinerOutputNV_RETURN void
#define glCombinerOutputNV_ARG_NAMES stage, portion, abOutput, cdOutput, sumOutput, scale, bias, abDotProduct, cdDotProduct, muxSum
#define glCombinerOutputNV_ARG_EXPAND GLenum stage, GLenum portion, GLenum abOutput, GLenum cdOutput, GLenum sumOutput, GLenum scale, GLenum bias, GLboolean abDotProduct, GLboolean cdDotProduct, GLboolean muxSum
#define glCombinerOutputNV_PACKED PACKED_glCombinerOutputNV
#define glCombinerOutputNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glCombinerOutputNV_NOT_VOID_WRAP(...) {}
#define pack_glCombinerOutputNV(_stage, _portion, _abOutput, _cdOutput, _sumOutput, _scale, _bias, _abDotProduct, _cdDotProduct, _muxSum) ({ \
    glCombinerOutputNV_PACKED *packed_data = malloc(sizeof(glCombinerOutputNV_PACKED)); \
    packed_data->index = glCombinerOutputNV_INDEX; \
    packed_data->args.stage = (GLenum)_stage; \
    packed_data->args.portion = (GLenum)_portion; \
    packed_data->args.abOutput = (GLenum)_abOutput; \
    packed_data->args.cdOutput = (GLenum)_cdOutput; \
    packed_data->args.sumOutput = (GLenum)_sumOutput; \
    packed_data->args.scale = (GLenum)_scale; \
    packed_data->args.bias = (GLenum)_bias; \
    packed_data->args.abDotProduct = (GLboolean)_abDotProduct; \
    packed_data->args.cdDotProduct = (GLboolean)_cdDotProduct; \
    packed_data->args.muxSum = (GLboolean)_muxSum; \
    (packed_call_t *)packed_data; \
})
#define call_glCombinerOutputNV(packed, ret_v) do { \
    PACKED_glCombinerOutputNV *unpacked = (PACKED_glCombinerOutputNV *)packed; \
    ARGS_glCombinerOutputNV *args = (ARGS_glCombinerOutputNV *)&unpacked->args; \
    glCombinerOutputNV(args->stage, args->portion, args->abOutput, args->cdOutput, args->sumOutput, args->scale, args->bias, args->abDotProduct, args->cdDotProduct, args->muxSum);; \
} while(0)
void glCombinerOutputNV(glCombinerOutputNV_ARG_EXPAND);
typedef void (*glCombinerOutputNV_PTR)(glCombinerOutputNV_ARG_EXPAND);
#define glCombinerParameterfNV_INDEX 321
#define glCombinerParameterfNV_RETURN void
#define glCombinerParameterfNV_ARG_NAMES pname, param
#define glCombinerParameterfNV_ARG_EXPAND GLenum pname, GLfloat param
#define glCombinerParameterfNV_PACKED PACKED_glCombinerParameterfNV
#define glCombinerParameterfNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glCombinerParameterfNV_NOT_VOID_WRAP(...) {}
#define pack_glCombinerParameterfNV(_pname, _param) ({ \
    glCombinerParameterfNV_PACKED *packed_data = malloc(sizeof(glCombinerParameterfNV_PACKED)); \
    packed_data->index = glCombinerParameterfNV_INDEX; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.param = (GLfloat)_param; \
    (packed_call_t *)packed_data; \
})
#define call_glCombinerParameterfNV(packed, ret_v) do { \
    PACKED_glCombinerParameterfNV *unpacked = (PACKED_glCombinerParameterfNV *)packed; \
    ARGS_glCombinerParameterfNV *args = (ARGS_glCombinerParameterfNV *)&unpacked->args; \
    glCombinerParameterfNV(args->pname, args->param);; \
} while(0)
void glCombinerParameterfNV(glCombinerParameterfNV_ARG_EXPAND);
typedef void (*glCombinerParameterfNV_PTR)(glCombinerParameterfNV_ARG_EXPAND);
#define glCombinerParameterfvNV_INDEX 322
#define glCombinerParameterfvNV_RETURN void
#define glCombinerParameterfvNV_ARG_NAMES pname, params
#define glCombinerParameterfvNV_ARG_EXPAND GLenum pname, const GLfloat * params
#define glCombinerParameterfvNV_PACKED PACKED_glCombinerParameterfvNV
#define glCombinerParameterfvNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glCombinerParameterfvNV_NOT_VOID_WRAP(...) {}
#define pack_glCombinerParameterfvNV(_pname, _params) ({ \
    glCombinerParameterfvNV_PACKED *packed_data = malloc(sizeof(glCombinerParameterfvNV_PACKED)); \
    packed_data->index = glCombinerParameterfvNV_INDEX; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLfloat *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glCombinerParameterfvNV(packed, ret_v) do { \
    PACKED_glCombinerParameterfvNV *unpacked = (PACKED_glCombinerParameterfvNV *)packed; \
    ARGS_glCombinerParameterfvNV *args = (ARGS_glCombinerParameterfvNV *)&unpacked->args; \
    glCombinerParameterfvNV(args->pname, args->params);; \
} while(0)
void glCombinerParameterfvNV(glCombinerParameterfvNV_ARG_EXPAND);
typedef void (*glCombinerParameterfvNV_PTR)(glCombinerParameterfvNV_ARG_EXPAND);
#define glCombinerParameteriNV_INDEX 323
#define glCombinerParameteriNV_RETURN void
#define glCombinerParameteriNV_ARG_NAMES pname, param
#define glCombinerParameteriNV_ARG_EXPAND GLenum pname, GLint param
#define glCombinerParameteriNV_PACKED PACKED_glCombinerParameteriNV
#define glCombinerParameteriNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glCombinerParameteriNV_NOT_VOID_WRAP(...) {}
#define pack_glCombinerParameteriNV(_pname, _param) ({ \
    glCombinerParameteriNV_PACKED *packed_data = malloc(sizeof(glCombinerParameteriNV_PACKED)); \
    packed_data->index = glCombinerParameteriNV_INDEX; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.param = (GLint)_param; \
    (packed_call_t *)packed_data; \
})
#define call_glCombinerParameteriNV(packed, ret_v) do { \
    PACKED_glCombinerParameteriNV *unpacked = (PACKED_glCombinerParameteriNV *)packed; \
    ARGS_glCombinerParameteriNV *args = (ARGS_glCombinerParameteriNV *)&unpacked->args; \
    glCombinerParameteriNV(args->pname, args->param);; \
} while(0)
void glCombinerParameteriNV(glCombinerParameteriNV_ARG_EXPAND);
typedef void (*glCombinerParameteriNV_PTR)(glCombinerParameteriNV_ARG_EXPAND);
#define glCombinerParameterivNV_INDEX 324
#define glCombinerParameterivNV_RETURN void
#define glCombinerParameterivNV_ARG_NAMES pname, params
#define glCombinerParameterivNV_ARG_EXPAND GLenum pname, const GLint * params
#define glCombinerParameterivNV_PACKED PACKED_glCombinerParameterivNV
#define glCombinerParameterivNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glCombinerParameterivNV_NOT_VOID_WRAP(...) {}
#define pack_glCombinerParameterivNV(_pname, _params) ({ \
    glCombinerParameterivNV_PACKED *packed_data = malloc(sizeof(glCombinerParameterivNV_PACKED)); \
    packed_data->index = glCombinerParameterivNV_INDEX; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glCombinerParameterivNV(packed, ret_v) do { \
    PACKED_glCombinerParameterivNV *unpacked = (PACKED_glCombinerParameterivNV *)packed; \
    ARGS_glCombinerParameterivNV *args = (ARGS_glCombinerParameterivNV *)&unpacked->args; \
    glCombinerParameterivNV(args->pname, args->params);; \
} while(0)
void glCombinerParameterivNV(glCombinerParameterivNV_ARG_EXPAND);
typedef void (*glCombinerParameterivNV_PTR)(glCombinerParameterivNV_ARG_EXPAND);
#define glCombinerStageParameterfvNV_INDEX 325
#define glCombinerStageParameterfvNV_RETURN void
#define glCombinerStageParameterfvNV_ARG_NAMES stage, pname, params
#define glCombinerStageParameterfvNV_ARG_EXPAND GLenum stage, GLenum pname, const GLfloat * params
#define glCombinerStageParameterfvNV_PACKED PACKED_glCombinerStageParameterfvNV
#define glCombinerStageParameterfvNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glCombinerStageParameterfvNV_NOT_VOID_WRAP(...) {}
#define pack_glCombinerStageParameterfvNV(_stage, _pname, _params) ({ \
    glCombinerStageParameterfvNV_PACKED *packed_data = malloc(sizeof(glCombinerStageParameterfvNV_PACKED)); \
    packed_data->index = glCombinerStageParameterfvNV_INDEX; \
    packed_data->args.stage = (GLenum)_stage; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLfloat *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glCombinerStageParameterfvNV(packed, ret_v) do { \
    PACKED_glCombinerStageParameterfvNV *unpacked = (PACKED_glCombinerStageParameterfvNV *)packed; \
    ARGS_glCombinerStageParameterfvNV *args = (ARGS_glCombinerStageParameterfvNV *)&unpacked->args; \
    glCombinerStageParameterfvNV(args->stage, args->pname, args->params);; \
} while(0)
void glCombinerStageParameterfvNV(glCombinerStageParameterfvNV_ARG_EXPAND);
typedef void (*glCombinerStageParameterfvNV_PTR)(glCombinerStageParameterfvNV_ARG_EXPAND);
#define glCompileShader_INDEX 326
#define glCompileShader_RETURN void
#define glCompileShader_ARG_NAMES shader
#define glCompileShader_ARG_EXPAND GLuint shader
#define glCompileShader_PACKED PACKED_glCompileShader
#define glCompileShader_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glCompileShader_NOT_VOID_WRAP(...) {}
#define pack_glCompileShader(_shader) ({ \
    glCompileShader_PACKED *packed_data = malloc(sizeof(glCompileShader_PACKED)); \
    packed_data->index = glCompileShader_INDEX; \
    packed_data->args.shader = (GLuint)_shader; \
    (packed_call_t *)packed_data; \
})
#define call_glCompileShader(packed, ret_v) do { \
    PACKED_glCompileShader *unpacked = (PACKED_glCompileShader *)packed; \
    ARGS_glCompileShader *args = (ARGS_glCompileShader *)&unpacked->args; \
    glCompileShader(args->shader);; \
} while(0)
void glCompileShader(glCompileShader_ARG_EXPAND);
typedef void (*glCompileShader_PTR)(glCompileShader_ARG_EXPAND);
#define glCompileShaderARB_INDEX 327
#define glCompileShaderARB_RETURN void
#define glCompileShaderARB_ARG_NAMES shaderObj
#define glCompileShaderARB_ARG_EXPAND GLhandleARB shaderObj
#define glCompileShaderARB_PACKED PACKED_glCompileShaderARB
#define glCompileShaderARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glCompileShaderARB_NOT_VOID_WRAP(...) {}
#define pack_glCompileShaderARB(_shaderObj) ({ \
    glCompileShaderARB_PACKED *packed_data = malloc(sizeof(glCompileShaderARB_PACKED)); \
    packed_data->index = glCompileShaderARB_INDEX; \
    packed_data->args.shaderObj = (GLhandleARB)_shaderObj; \
    (packed_call_t *)packed_data; \
})
#define call_glCompileShaderARB(packed, ret_v) do { \
    PACKED_glCompileShaderARB *unpacked = (PACKED_glCompileShaderARB *)packed; \
    ARGS_glCompileShaderARB *args = (ARGS_glCompileShaderARB *)&unpacked->args; \
    glCompileShaderARB(args->shaderObj);; \
} while(0)
void glCompileShaderARB(glCompileShaderARB_ARG_EXPAND);
typedef void (*glCompileShaderARB_PTR)(glCompileShaderARB_ARG_EXPAND);
#define glCompileShaderIncludeARB_INDEX 328
#define glCompileShaderIncludeARB_RETURN void
#define glCompileShaderIncludeARB_ARG_NAMES shader, count, path, length
#define glCompileShaderIncludeARB_ARG_EXPAND GLuint shader, GLsizei count, const GLchar * path, const GLint * length
#define glCompileShaderIncludeARB_PACKED PACKED_glCompileShaderIncludeARB
#define glCompileShaderIncludeARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glCompileShaderIncludeARB_NOT_VOID_WRAP(...) {}
#define pack_glCompileShaderIncludeARB(_shader, _count, _path, _length) ({ \
    glCompileShaderIncludeARB_PACKED *packed_data = malloc(sizeof(glCompileShaderIncludeARB_PACKED)); \
    packed_data->index = glCompileShaderIncludeARB_INDEX; \
    packed_data->args.shader = (GLuint)_shader; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.path = (GLchar *)_path; \
    packed_data->args.length = (GLint *)_length; \
    (packed_call_t *)packed_data; \
})
#define call_glCompileShaderIncludeARB(packed, ret_v) do { \
    PACKED_glCompileShaderIncludeARB *unpacked = (PACKED_glCompileShaderIncludeARB *)packed; \
    ARGS_glCompileShaderIncludeARB *args = (ARGS_glCompileShaderIncludeARB *)&unpacked->args; \
    glCompileShaderIncludeARB(args->shader, args->count, args->path, args->length);; \
} while(0)
void glCompileShaderIncludeARB(glCompileShaderIncludeARB_ARG_EXPAND);
typedef void (*glCompileShaderIncludeARB_PTR)(glCompileShaderIncludeARB_ARG_EXPAND);
#define glCompressedMultiTexImage1DEXT_INDEX 329
#define glCompressedMultiTexImage1DEXT_RETURN void
#define glCompressedMultiTexImage1DEXT_ARG_NAMES texunit, target, level, internalformat, width, border, imageSize, bits
#define glCompressedMultiTexImage1DEXT_ARG_EXPAND GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid * bits
#define glCompressedMultiTexImage1DEXT_PACKED PACKED_glCompressedMultiTexImage1DEXT
#define glCompressedMultiTexImage1DEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glCompressedMultiTexImage1DEXT_NOT_VOID_WRAP(...) {}
#define pack_glCompressedMultiTexImage1DEXT(_texunit, _target, _level, _internalformat, _width, _border, _imageSize, _bits) ({ \
    glCompressedMultiTexImage1DEXT_PACKED *packed_data = malloc(sizeof(glCompressedMultiTexImage1DEXT_PACKED)); \
    packed_data->index = glCompressedMultiTexImage1DEXT_INDEX; \
    packed_data->args.texunit = (GLenum)_texunit; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.level = (GLint)_level; \
    packed_data->args.internalformat = (GLenum)_internalformat; \
    packed_data->args.width = (GLsizei)_width; \
    packed_data->args.border = (GLint)_border; \
    packed_data->args.imageSize = (GLsizei)_imageSize; \
    packed_data->args.bits = (GLvoid *)_bits; \
    (packed_call_t *)packed_data; \
})
#define call_glCompressedMultiTexImage1DEXT(packed, ret_v) do { \
    PACKED_glCompressedMultiTexImage1DEXT *unpacked = (PACKED_glCompressedMultiTexImage1DEXT *)packed; \
    ARGS_glCompressedMultiTexImage1DEXT *args = (ARGS_glCompressedMultiTexImage1DEXT *)&unpacked->args; \
    glCompressedMultiTexImage1DEXT(args->texunit, args->target, args->level, args->internalformat, args->width, args->border, args->imageSize, args->bits);; \
} while(0)
void glCompressedMultiTexImage1DEXT(glCompressedMultiTexImage1DEXT_ARG_EXPAND);
typedef void (*glCompressedMultiTexImage1DEXT_PTR)(glCompressedMultiTexImage1DEXT_ARG_EXPAND);
#define glCompressedMultiTexImage2DEXT_INDEX 330
#define glCompressedMultiTexImage2DEXT_RETURN void
#define glCompressedMultiTexImage2DEXT_ARG_NAMES texunit, target, level, internalformat, width, height, border, imageSize, bits
#define glCompressedMultiTexImage2DEXT_ARG_EXPAND GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid * bits
#define glCompressedMultiTexImage2DEXT_PACKED PACKED_glCompressedMultiTexImage2DEXT
#define glCompressedMultiTexImage2DEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glCompressedMultiTexImage2DEXT_NOT_VOID_WRAP(...) {}
#define pack_glCompressedMultiTexImage2DEXT(_texunit, _target, _level, _internalformat, _width, _height, _border, _imageSize, _bits) ({ \
    glCompressedMultiTexImage2DEXT_PACKED *packed_data = malloc(sizeof(glCompressedMultiTexImage2DEXT_PACKED)); \
    packed_data->index = glCompressedMultiTexImage2DEXT_INDEX; \
    packed_data->args.texunit = (GLenum)_texunit; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.level = (GLint)_level; \
    packed_data->args.internalformat = (GLenum)_internalformat; \
    packed_data->args.width = (GLsizei)_width; \
    packed_data->args.height = (GLsizei)_height; \
    packed_data->args.border = (GLint)_border; \
    packed_data->args.imageSize = (GLsizei)_imageSize; \
    packed_data->args.bits = (GLvoid *)_bits; \
    (packed_call_t *)packed_data; \
})
#define call_glCompressedMultiTexImage2DEXT(packed, ret_v) do { \
    PACKED_glCompressedMultiTexImage2DEXT *unpacked = (PACKED_glCompressedMultiTexImage2DEXT *)packed; \
    ARGS_glCompressedMultiTexImage2DEXT *args = (ARGS_glCompressedMultiTexImage2DEXT *)&unpacked->args; \
    glCompressedMultiTexImage2DEXT(args->texunit, args->target, args->level, args->internalformat, args->width, args->height, args->border, args->imageSize, args->bits);; \
} while(0)
void glCompressedMultiTexImage2DEXT(glCompressedMultiTexImage2DEXT_ARG_EXPAND);
typedef void (*glCompressedMultiTexImage2DEXT_PTR)(glCompressedMultiTexImage2DEXT_ARG_EXPAND);
#define glCompressedMultiTexImage3DEXT_INDEX 331
#define glCompressedMultiTexImage3DEXT_RETURN void
#define glCompressedMultiTexImage3DEXT_ARG_NAMES texunit, target, level, internalformat, width, height, depth, border, imageSize, bits
#define glCompressedMultiTexImage3DEXT_ARG_EXPAND GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid * bits
#define glCompressedMultiTexImage3DEXT_PACKED PACKED_glCompressedMultiTexImage3DEXT
#define glCompressedMultiTexImage3DEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glCompressedMultiTexImage3DEXT_NOT_VOID_WRAP(...) {}
#define pack_glCompressedMultiTexImage3DEXT(_texunit, _target, _level, _internalformat, _width, _height, _depth, _border, _imageSize, _bits) ({ \
    glCompressedMultiTexImage3DEXT_PACKED *packed_data = malloc(sizeof(glCompressedMultiTexImage3DEXT_PACKED)); \
    packed_data->index = glCompressedMultiTexImage3DEXT_INDEX; \
    packed_data->args.texunit = (GLenum)_texunit; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.level = (GLint)_level; \
    packed_data->args.internalformat = (GLenum)_internalformat; \
    packed_data->args.width = (GLsizei)_width; \
    packed_data->args.height = (GLsizei)_height; \
    packed_data->args.depth = (GLsizei)_depth; \
    packed_data->args.border = (GLint)_border; \
    packed_data->args.imageSize = (GLsizei)_imageSize; \
    packed_data->args.bits = (GLvoid *)_bits; \
    (packed_call_t *)packed_data; \
})
#define call_glCompressedMultiTexImage3DEXT(packed, ret_v) do { \
    PACKED_glCompressedMultiTexImage3DEXT *unpacked = (PACKED_glCompressedMultiTexImage3DEXT *)packed; \
    ARGS_glCompressedMultiTexImage3DEXT *args = (ARGS_glCompressedMultiTexImage3DEXT *)&unpacked->args; \
    glCompressedMultiTexImage3DEXT(args->texunit, args->target, args->level, args->internalformat, args->width, args->height, args->depth, args->border, args->imageSize, args->bits);; \
} while(0)
void glCompressedMultiTexImage3DEXT(glCompressedMultiTexImage3DEXT_ARG_EXPAND);
typedef void (*glCompressedMultiTexImage3DEXT_PTR)(glCompressedMultiTexImage3DEXT_ARG_EXPAND);
#define glCompressedMultiTexSubImage1DEXT_INDEX 332
#define glCompressedMultiTexSubImage1DEXT_RETURN void
#define glCompressedMultiTexSubImage1DEXT_ARG_NAMES texunit, target, level, xoffset, width, format, imageSize, bits
#define glCompressedMultiTexSubImage1DEXT_ARG_EXPAND GLenum texunit, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid * bits
#define glCompressedMultiTexSubImage1DEXT_PACKED PACKED_glCompressedMultiTexSubImage1DEXT
#define glCompressedMultiTexSubImage1DEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glCompressedMultiTexSubImage1DEXT_NOT_VOID_WRAP(...) {}
#define pack_glCompressedMultiTexSubImage1DEXT(_texunit, _target, _level, _xoffset, _width, _format, _imageSize, _bits) ({ \
    glCompressedMultiTexSubImage1DEXT_PACKED *packed_data = malloc(sizeof(glCompressedMultiTexSubImage1DEXT_PACKED)); \
    packed_data->index = glCompressedMultiTexSubImage1DEXT_INDEX; \
    packed_data->args.texunit = (GLenum)_texunit; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.level = (GLint)_level; \
    packed_data->args.xoffset = (GLint)_xoffset; \
    packed_data->args.width = (GLsizei)_width; \
    packed_data->args.format = (GLenum)_format; \
    packed_data->args.imageSize = (GLsizei)_imageSize; \
    packed_data->args.bits = (GLvoid *)_bits; \
    (packed_call_t *)packed_data; \
})
#define call_glCompressedMultiTexSubImage1DEXT(packed, ret_v) do { \
    PACKED_glCompressedMultiTexSubImage1DEXT *unpacked = (PACKED_glCompressedMultiTexSubImage1DEXT *)packed; \
    ARGS_glCompressedMultiTexSubImage1DEXT *args = (ARGS_glCompressedMultiTexSubImage1DEXT *)&unpacked->args; \
    glCompressedMultiTexSubImage1DEXT(args->texunit, args->target, args->level, args->xoffset, args->width, args->format, args->imageSize, args->bits);; \
} while(0)
void glCompressedMultiTexSubImage1DEXT(glCompressedMultiTexSubImage1DEXT_ARG_EXPAND);
typedef void (*glCompressedMultiTexSubImage1DEXT_PTR)(glCompressedMultiTexSubImage1DEXT_ARG_EXPAND);
#define glCompressedMultiTexSubImage2DEXT_INDEX 333
#define glCompressedMultiTexSubImage2DEXT_RETURN void
#define glCompressedMultiTexSubImage2DEXT_ARG_NAMES texunit, target, level, xoffset, yoffset, width, height, format, imageSize, bits
#define glCompressedMultiTexSubImage2DEXT_ARG_EXPAND GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid * bits
#define glCompressedMultiTexSubImage2DEXT_PACKED PACKED_glCompressedMultiTexSubImage2DEXT
#define glCompressedMultiTexSubImage2DEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glCompressedMultiTexSubImage2DEXT_NOT_VOID_WRAP(...) {}
#define pack_glCompressedMultiTexSubImage2DEXT(_texunit, _target, _level, _xoffset, _yoffset, _width, _height, _format, _imageSize, _bits) ({ \
    glCompressedMultiTexSubImage2DEXT_PACKED *packed_data = malloc(sizeof(glCompressedMultiTexSubImage2DEXT_PACKED)); \
    packed_data->index = glCompressedMultiTexSubImage2DEXT_INDEX; \
    packed_data->args.texunit = (GLenum)_texunit; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.level = (GLint)_level; \
    packed_data->args.xoffset = (GLint)_xoffset; \
    packed_data->args.yoffset = (GLint)_yoffset; \
    packed_data->args.width = (GLsizei)_width; \
    packed_data->args.height = (GLsizei)_height; \
    packed_data->args.format = (GLenum)_format; \
    packed_data->args.imageSize = (GLsizei)_imageSize; \
    packed_data->args.bits = (GLvoid *)_bits; \
    (packed_call_t *)packed_data; \
})
#define call_glCompressedMultiTexSubImage2DEXT(packed, ret_v) do { \
    PACKED_glCompressedMultiTexSubImage2DEXT *unpacked = (PACKED_glCompressedMultiTexSubImage2DEXT *)packed; \
    ARGS_glCompressedMultiTexSubImage2DEXT *args = (ARGS_glCompressedMultiTexSubImage2DEXT *)&unpacked->args; \
    glCompressedMultiTexSubImage2DEXT(args->texunit, args->target, args->level, args->xoffset, args->yoffset, args->width, args->height, args->format, args->imageSize, args->bits);; \
} while(0)
void glCompressedMultiTexSubImage2DEXT(glCompressedMultiTexSubImage2DEXT_ARG_EXPAND);
typedef void (*glCompressedMultiTexSubImage2DEXT_PTR)(glCompressedMultiTexSubImage2DEXT_ARG_EXPAND);
#define glCompressedMultiTexSubImage3DEXT_INDEX 334
#define glCompressedMultiTexSubImage3DEXT_RETURN void
#define glCompressedMultiTexSubImage3DEXT_ARG_NAMES texunit, target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, bits
#define glCompressedMultiTexSubImage3DEXT_ARG_EXPAND GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid * bits
#define glCompressedMultiTexSubImage3DEXT_PACKED PACKED_glCompressedMultiTexSubImage3DEXT
#define glCompressedMultiTexSubImage3DEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glCompressedMultiTexSubImage3DEXT_NOT_VOID_WRAP(...) {}
#define pack_glCompressedMultiTexSubImage3DEXT(_texunit, _target, _level, _xoffset, _yoffset, _zoffset, _width, _height, _depth, _format, _imageSize, _bits) ({ \
    glCompressedMultiTexSubImage3DEXT_PACKED *packed_data = malloc(sizeof(glCompressedMultiTexSubImage3DEXT_PACKED)); \
    packed_data->index = glCompressedMultiTexSubImage3DEXT_INDEX; \
    packed_data->args.texunit = (GLenum)_texunit; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.level = (GLint)_level; \
    packed_data->args.xoffset = (GLint)_xoffset; \
    packed_data->args.yoffset = (GLint)_yoffset; \
    packed_data->args.zoffset = (GLint)_zoffset; \
    packed_data->args.width = (GLsizei)_width; \
    packed_data->args.height = (GLsizei)_height; \
    packed_data->args.depth = (GLsizei)_depth; \
    packed_data->args.format = (GLenum)_format; \
    packed_data->args.imageSize = (GLsizei)_imageSize; \
    packed_data->args.bits = (GLvoid *)_bits; \
    (packed_call_t *)packed_data; \
})
#define call_glCompressedMultiTexSubImage3DEXT(packed, ret_v) do { \
    PACKED_glCompressedMultiTexSubImage3DEXT *unpacked = (PACKED_glCompressedMultiTexSubImage3DEXT *)packed; \
    ARGS_glCompressedMultiTexSubImage3DEXT *args = (ARGS_glCompressedMultiTexSubImage3DEXT *)&unpacked->args; \
    glCompressedMultiTexSubImage3DEXT(args->texunit, args->target, args->level, args->xoffset, args->yoffset, args->zoffset, args->width, args->height, args->depth, args->format, args->imageSize, args->bits);; \
} while(0)
void glCompressedMultiTexSubImage3DEXT(glCompressedMultiTexSubImage3DEXT_ARG_EXPAND);
typedef void (*glCompressedMultiTexSubImage3DEXT_PTR)(glCompressedMultiTexSubImage3DEXT_ARG_EXPAND);
#define glCompressedTexImage1D_INDEX 335
#define glCompressedTexImage1D_RETURN void
#define glCompressedTexImage1D_ARG_NAMES target, level, internalformat, width, border, imageSize, data
#define glCompressedTexImage1D_ARG_EXPAND GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid * data
#define glCompressedTexImage1D_PACKED PACKED_glCompressedTexImage1D
#define glCompressedTexImage1D_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glCompressedTexImage1D_NOT_VOID_WRAP(...) {}
#define pack_glCompressedTexImage1D(_target, _level, _internalformat, _width, _border, _imageSize, _data) ({ \
    glCompressedTexImage1D_PACKED *packed_data = malloc(sizeof(glCompressedTexImage1D_PACKED)); \
    packed_data->index = glCompressedTexImage1D_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.level = (GLint)_level; \
    packed_data->args.internalformat = (GLenum)_internalformat; \
    packed_data->args.width = (GLsizei)_width; \
    packed_data->args.border = (GLint)_border; \
    packed_data->args.imageSize = (GLsizei)_imageSize; \
    packed_data->args.data = (GLvoid *)_data; \
    (packed_call_t *)packed_data; \
})
#define call_glCompressedTexImage1D(packed, ret_v) do { \
    PACKED_glCompressedTexImage1D *unpacked = (PACKED_glCompressedTexImage1D *)packed; \
    ARGS_glCompressedTexImage1D *args = (ARGS_glCompressedTexImage1D *)&unpacked->args; \
    glCompressedTexImage1D(args->target, args->level, args->internalformat, args->width, args->border, args->imageSize, args->data);; \
} while(0)
void glCompressedTexImage1D(glCompressedTexImage1D_ARG_EXPAND);
typedef void (*glCompressedTexImage1D_PTR)(glCompressedTexImage1D_ARG_EXPAND);
#define glCompressedTexImage1DARB_INDEX 336
#define glCompressedTexImage1DARB_RETURN void
#define glCompressedTexImage1DARB_ARG_NAMES target, level, internalformat, width, border, imageSize, data
#define glCompressedTexImage1DARB_ARG_EXPAND GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid * data
#define glCompressedTexImage1DARB_PACKED PACKED_glCompressedTexImage1DARB
#define glCompressedTexImage1DARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glCompressedTexImage1DARB_NOT_VOID_WRAP(...) {}
#define pack_glCompressedTexImage1DARB(_target, _level, _internalformat, _width, _border, _imageSize, _data) ({ \
    glCompressedTexImage1DARB_PACKED *packed_data = malloc(sizeof(glCompressedTexImage1DARB_PACKED)); \
    packed_data->index = glCompressedTexImage1DARB_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.level = (GLint)_level; \
    packed_data->args.internalformat = (GLenum)_internalformat; \
    packed_data->args.width = (GLsizei)_width; \
    packed_data->args.border = (GLint)_border; \
    packed_data->args.imageSize = (GLsizei)_imageSize; \
    packed_data->args.data = (GLvoid *)_data; \
    (packed_call_t *)packed_data; \
})
#define call_glCompressedTexImage1DARB(packed, ret_v) do { \
    PACKED_glCompressedTexImage1DARB *unpacked = (PACKED_glCompressedTexImage1DARB *)packed; \
    ARGS_glCompressedTexImage1DARB *args = (ARGS_glCompressedTexImage1DARB *)&unpacked->args; \
    glCompressedTexImage1DARB(args->target, args->level, args->internalformat, args->width, args->border, args->imageSize, args->data);; \
} while(0)
void glCompressedTexImage1DARB(glCompressedTexImage1DARB_ARG_EXPAND);
typedef void (*glCompressedTexImage1DARB_PTR)(glCompressedTexImage1DARB_ARG_EXPAND);
#define glCompressedTexImage2D_INDEX 337
#define glCompressedTexImage2D_RETURN void
#define glCompressedTexImage2D_ARG_NAMES target, level, internalformat, width, height, border, imageSize, data
#define glCompressedTexImage2D_ARG_EXPAND GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid * data
#define glCompressedTexImage2D_PACKED PACKED_glCompressedTexImage2D
#define glCompressedTexImage2D_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glCompressedTexImage2D_NOT_VOID_WRAP(...) {}
#define pack_glCompressedTexImage2D(_target, _level, _internalformat, _width, _height, _border, _imageSize, _data) ({ \
    glCompressedTexImage2D_PACKED *packed_data = malloc(sizeof(glCompressedTexImage2D_PACKED)); \
    packed_data->index = glCompressedTexImage2D_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.level = (GLint)_level; \
    packed_data->args.internalformat = (GLenum)_internalformat; \
    packed_data->args.width = (GLsizei)_width; \
    packed_data->args.height = (GLsizei)_height; \
    packed_data->args.border = (GLint)_border; \
    packed_data->args.imageSize = (GLsizei)_imageSize; \
    packed_data->args.data = (GLvoid *)_data; \
    (packed_call_t *)packed_data; \
})
#define call_glCompressedTexImage2D(packed, ret_v) do { \
    PACKED_glCompressedTexImage2D *unpacked = (PACKED_glCompressedTexImage2D *)packed; \
    ARGS_glCompressedTexImage2D *args = (ARGS_glCompressedTexImage2D *)&unpacked->args; \
    glCompressedTexImage2D(args->target, args->level, args->internalformat, args->width, args->height, args->border, args->imageSize, args->data);; \
} while(0)
void glCompressedTexImage2D(glCompressedTexImage2D_ARG_EXPAND);
typedef void (*glCompressedTexImage2D_PTR)(glCompressedTexImage2D_ARG_EXPAND);
#define glCompressedTexImage2DARB_INDEX 338
#define glCompressedTexImage2DARB_RETURN void
#define glCompressedTexImage2DARB_ARG_NAMES target, level, internalformat, width, height, border, imageSize, data
#define glCompressedTexImage2DARB_ARG_EXPAND GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid * data
#define glCompressedTexImage2DARB_PACKED PACKED_glCompressedTexImage2DARB
#define glCompressedTexImage2DARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glCompressedTexImage2DARB_NOT_VOID_WRAP(...) {}
#define pack_glCompressedTexImage2DARB(_target, _level, _internalformat, _width, _height, _border, _imageSize, _data) ({ \
    glCompressedTexImage2DARB_PACKED *packed_data = malloc(sizeof(glCompressedTexImage2DARB_PACKED)); \
    packed_data->index = glCompressedTexImage2DARB_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.level = (GLint)_level; \
    packed_data->args.internalformat = (GLenum)_internalformat; \
    packed_data->args.width = (GLsizei)_width; \
    packed_data->args.height = (GLsizei)_height; \
    packed_data->args.border = (GLint)_border; \
    packed_data->args.imageSize = (GLsizei)_imageSize; \
    packed_data->args.data = (GLvoid *)_data; \
    (packed_call_t *)packed_data; \
})
#define call_glCompressedTexImage2DARB(packed, ret_v) do { \
    PACKED_glCompressedTexImage2DARB *unpacked = (PACKED_glCompressedTexImage2DARB *)packed; \
    ARGS_glCompressedTexImage2DARB *args = (ARGS_glCompressedTexImage2DARB *)&unpacked->args; \
    glCompressedTexImage2DARB(args->target, args->level, args->internalformat, args->width, args->height, args->border, args->imageSize, args->data);; \
} while(0)
void glCompressedTexImage2DARB(glCompressedTexImage2DARB_ARG_EXPAND);
typedef void (*glCompressedTexImage2DARB_PTR)(glCompressedTexImage2DARB_ARG_EXPAND);
#define glCompressedTexImage3D_INDEX 339
#define glCompressedTexImage3D_RETURN void
#define glCompressedTexImage3D_ARG_NAMES target, level, internalformat, width, height, depth, border, imageSize, data
#define glCompressedTexImage3D_ARG_EXPAND GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid * data
#define glCompressedTexImage3D_PACKED PACKED_glCompressedTexImage3D
#define glCompressedTexImage3D_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glCompressedTexImage3D_NOT_VOID_WRAP(...) {}
#define pack_glCompressedTexImage3D(_target, _level, _internalformat, _width, _height, _depth, _border, _imageSize, _data) ({ \
    glCompressedTexImage3D_PACKED *packed_data = malloc(sizeof(glCompressedTexImage3D_PACKED)); \
    packed_data->index = glCompressedTexImage3D_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.level = (GLint)_level; \
    packed_data->args.internalformat = (GLenum)_internalformat; \
    packed_data->args.width = (GLsizei)_width; \
    packed_data->args.height = (GLsizei)_height; \
    packed_data->args.depth = (GLsizei)_depth; \
    packed_data->args.border = (GLint)_border; \
    packed_data->args.imageSize = (GLsizei)_imageSize; \
    packed_data->args.data = (GLvoid *)_data; \
    (packed_call_t *)packed_data; \
})
#define call_glCompressedTexImage3D(packed, ret_v) do { \
    PACKED_glCompressedTexImage3D *unpacked = (PACKED_glCompressedTexImage3D *)packed; \
    ARGS_glCompressedTexImage3D *args = (ARGS_glCompressedTexImage3D *)&unpacked->args; \
    glCompressedTexImage3D(args->target, args->level, args->internalformat, args->width, args->height, args->depth, args->border, args->imageSize, args->data);; \
} while(0)
void glCompressedTexImage3D(glCompressedTexImage3D_ARG_EXPAND);
typedef void (*glCompressedTexImage3D_PTR)(glCompressedTexImage3D_ARG_EXPAND);
#define glCompressedTexImage3DARB_INDEX 340
#define glCompressedTexImage3DARB_RETURN void
#define glCompressedTexImage3DARB_ARG_NAMES target, level, internalformat, width, height, depth, border, imageSize, data
#define glCompressedTexImage3DARB_ARG_EXPAND GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid * data
#define glCompressedTexImage3DARB_PACKED PACKED_glCompressedTexImage3DARB
#define glCompressedTexImage3DARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glCompressedTexImage3DARB_NOT_VOID_WRAP(...) {}
#define pack_glCompressedTexImage3DARB(_target, _level, _internalformat, _width, _height, _depth, _border, _imageSize, _data) ({ \
    glCompressedTexImage3DARB_PACKED *packed_data = malloc(sizeof(glCompressedTexImage3DARB_PACKED)); \
    packed_data->index = glCompressedTexImage3DARB_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.level = (GLint)_level; \
    packed_data->args.internalformat = (GLenum)_internalformat; \
    packed_data->args.width = (GLsizei)_width; \
    packed_data->args.height = (GLsizei)_height; \
    packed_data->args.depth = (GLsizei)_depth; \
    packed_data->args.border = (GLint)_border; \
    packed_data->args.imageSize = (GLsizei)_imageSize; \
    packed_data->args.data = (GLvoid *)_data; \
    (packed_call_t *)packed_data; \
})
#define call_glCompressedTexImage3DARB(packed, ret_v) do { \
    PACKED_glCompressedTexImage3DARB *unpacked = (PACKED_glCompressedTexImage3DARB *)packed; \
    ARGS_glCompressedTexImage3DARB *args = (ARGS_glCompressedTexImage3DARB *)&unpacked->args; \
    glCompressedTexImage3DARB(args->target, args->level, args->internalformat, args->width, args->height, args->depth, args->border, args->imageSize, args->data);; \
} while(0)
void glCompressedTexImage3DARB(glCompressedTexImage3DARB_ARG_EXPAND);
typedef void (*glCompressedTexImage3DARB_PTR)(glCompressedTexImage3DARB_ARG_EXPAND);
#define glCompressedTexSubImage1D_INDEX 341
#define glCompressedTexSubImage1D_RETURN void
#define glCompressedTexSubImage1D_ARG_NAMES target, level, xoffset, width, format, imageSize, data
#define glCompressedTexSubImage1D_ARG_EXPAND GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid * data
#define glCompressedTexSubImage1D_PACKED PACKED_glCompressedTexSubImage1D
#define glCompressedTexSubImage1D_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glCompressedTexSubImage1D_NOT_VOID_WRAP(...) {}
#define pack_glCompressedTexSubImage1D(_target, _level, _xoffset, _width, _format, _imageSize, _data) ({ \
    glCompressedTexSubImage1D_PACKED *packed_data = malloc(sizeof(glCompressedTexSubImage1D_PACKED)); \
    packed_data->index = glCompressedTexSubImage1D_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.level = (GLint)_level; \
    packed_data->args.xoffset = (GLint)_xoffset; \
    packed_data->args.width = (GLsizei)_width; \
    packed_data->args.format = (GLenum)_format; \
    packed_data->args.imageSize = (GLsizei)_imageSize; \
    packed_data->args.data = (GLvoid *)_data; \
    (packed_call_t *)packed_data; \
})
#define call_glCompressedTexSubImage1D(packed, ret_v) do { \
    PACKED_glCompressedTexSubImage1D *unpacked = (PACKED_glCompressedTexSubImage1D *)packed; \
    ARGS_glCompressedTexSubImage1D *args = (ARGS_glCompressedTexSubImage1D *)&unpacked->args; \
    glCompressedTexSubImage1D(args->target, args->level, args->xoffset, args->width, args->format, args->imageSize, args->data);; \
} while(0)
void glCompressedTexSubImage1D(glCompressedTexSubImage1D_ARG_EXPAND);
typedef void (*glCompressedTexSubImage1D_PTR)(glCompressedTexSubImage1D_ARG_EXPAND);
#define glCompressedTexSubImage1DARB_INDEX 342
#define glCompressedTexSubImage1DARB_RETURN void
#define glCompressedTexSubImage1DARB_ARG_NAMES target, level, xoffset, width, format, imageSize, data
#define glCompressedTexSubImage1DARB_ARG_EXPAND GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid * data
#define glCompressedTexSubImage1DARB_PACKED PACKED_glCompressedTexSubImage1DARB
#define glCompressedTexSubImage1DARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glCompressedTexSubImage1DARB_NOT_VOID_WRAP(...) {}
#define pack_glCompressedTexSubImage1DARB(_target, _level, _xoffset, _width, _format, _imageSize, _data) ({ \
    glCompressedTexSubImage1DARB_PACKED *packed_data = malloc(sizeof(glCompressedTexSubImage1DARB_PACKED)); \
    packed_data->index = glCompressedTexSubImage1DARB_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.level = (GLint)_level; \
    packed_data->args.xoffset = (GLint)_xoffset; \
    packed_data->args.width = (GLsizei)_width; \
    packed_data->args.format = (GLenum)_format; \
    packed_data->args.imageSize = (GLsizei)_imageSize; \
    packed_data->args.data = (GLvoid *)_data; \
    (packed_call_t *)packed_data; \
})
#define call_glCompressedTexSubImage1DARB(packed, ret_v) do { \
    PACKED_glCompressedTexSubImage1DARB *unpacked = (PACKED_glCompressedTexSubImage1DARB *)packed; \
    ARGS_glCompressedTexSubImage1DARB *args = (ARGS_glCompressedTexSubImage1DARB *)&unpacked->args; \
    glCompressedTexSubImage1DARB(args->target, args->level, args->xoffset, args->width, args->format, args->imageSize, args->data);; \
} while(0)
void glCompressedTexSubImage1DARB(glCompressedTexSubImage1DARB_ARG_EXPAND);
typedef void (*glCompressedTexSubImage1DARB_PTR)(glCompressedTexSubImage1DARB_ARG_EXPAND);
#define glCompressedTexSubImage2D_INDEX 343
#define glCompressedTexSubImage2D_RETURN void
#define glCompressedTexSubImage2D_ARG_NAMES target, level, xoffset, yoffset, width, height, format, imageSize, data
#define glCompressedTexSubImage2D_ARG_EXPAND GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid * data
#define glCompressedTexSubImage2D_PACKED PACKED_glCompressedTexSubImage2D
#define glCompressedTexSubImage2D_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glCompressedTexSubImage2D_NOT_VOID_WRAP(...) {}
#define pack_glCompressedTexSubImage2D(_target, _level, _xoffset, _yoffset, _width, _height, _format, _imageSize, _data) ({ \
    glCompressedTexSubImage2D_PACKED *packed_data = malloc(sizeof(glCompressedTexSubImage2D_PACKED)); \
    packed_data->index = glCompressedTexSubImage2D_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.level = (GLint)_level; \
    packed_data->args.xoffset = (GLint)_xoffset; \
    packed_data->args.yoffset = (GLint)_yoffset; \
    packed_data->args.width = (GLsizei)_width; \
    packed_data->args.height = (GLsizei)_height; \
    packed_data->args.format = (GLenum)_format; \
    packed_data->args.imageSize = (GLsizei)_imageSize; \
    packed_data->args.data = (GLvoid *)_data; \
    (packed_call_t *)packed_data; \
})
#define call_glCompressedTexSubImage2D(packed, ret_v) do { \
    PACKED_glCompressedTexSubImage2D *unpacked = (PACKED_glCompressedTexSubImage2D *)packed; \
    ARGS_glCompressedTexSubImage2D *args = (ARGS_glCompressedTexSubImage2D *)&unpacked->args; \
    glCompressedTexSubImage2D(args->target, args->level, args->xoffset, args->yoffset, args->width, args->height, args->format, args->imageSize, args->data);; \
} while(0)
void glCompressedTexSubImage2D(glCompressedTexSubImage2D_ARG_EXPAND);
typedef void (*glCompressedTexSubImage2D_PTR)(glCompressedTexSubImage2D_ARG_EXPAND);
#define glCompressedTexSubImage2DARB_INDEX 344
#define glCompressedTexSubImage2DARB_RETURN void
#define glCompressedTexSubImage2DARB_ARG_NAMES target, level, xoffset, yoffset, width, height, format, imageSize, data
#define glCompressedTexSubImage2DARB_ARG_EXPAND GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid * data
#define glCompressedTexSubImage2DARB_PACKED PACKED_glCompressedTexSubImage2DARB
#define glCompressedTexSubImage2DARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glCompressedTexSubImage2DARB_NOT_VOID_WRAP(...) {}
#define pack_glCompressedTexSubImage2DARB(_target, _level, _xoffset, _yoffset, _width, _height, _format, _imageSize, _data) ({ \
    glCompressedTexSubImage2DARB_PACKED *packed_data = malloc(sizeof(glCompressedTexSubImage2DARB_PACKED)); \
    packed_data->index = glCompressedTexSubImage2DARB_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.level = (GLint)_level; \
    packed_data->args.xoffset = (GLint)_xoffset; \
    packed_data->args.yoffset = (GLint)_yoffset; \
    packed_data->args.width = (GLsizei)_width; \
    packed_data->args.height = (GLsizei)_height; \
    packed_data->args.format = (GLenum)_format; \
    packed_data->args.imageSize = (GLsizei)_imageSize; \
    packed_data->args.data = (GLvoid *)_data; \
    (packed_call_t *)packed_data; \
})
#define call_glCompressedTexSubImage2DARB(packed, ret_v) do { \
    PACKED_glCompressedTexSubImage2DARB *unpacked = (PACKED_glCompressedTexSubImage2DARB *)packed; \
    ARGS_glCompressedTexSubImage2DARB *args = (ARGS_glCompressedTexSubImage2DARB *)&unpacked->args; \
    glCompressedTexSubImage2DARB(args->target, args->level, args->xoffset, args->yoffset, args->width, args->height, args->format, args->imageSize, args->data);; \
} while(0)
void glCompressedTexSubImage2DARB(glCompressedTexSubImage2DARB_ARG_EXPAND);
typedef void (*glCompressedTexSubImage2DARB_PTR)(glCompressedTexSubImage2DARB_ARG_EXPAND);
#define glCompressedTexSubImage3D_INDEX 345
#define glCompressedTexSubImage3D_RETURN void
#define glCompressedTexSubImage3D_ARG_NAMES target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data
#define glCompressedTexSubImage3D_ARG_EXPAND GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid * data
#define glCompressedTexSubImage3D_PACKED PACKED_glCompressedTexSubImage3D
#define glCompressedTexSubImage3D_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glCompressedTexSubImage3D_NOT_VOID_WRAP(...) {}
#define pack_glCompressedTexSubImage3D(_target, _level, _xoffset, _yoffset, _zoffset, _width, _height, _depth, _format, _imageSize, _data) ({ \
    glCompressedTexSubImage3D_PACKED *packed_data = malloc(sizeof(glCompressedTexSubImage3D_PACKED)); \
    packed_data->index = glCompressedTexSubImage3D_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.level = (GLint)_level; \
    packed_data->args.xoffset = (GLint)_xoffset; \
    packed_data->args.yoffset = (GLint)_yoffset; \
    packed_data->args.zoffset = (GLint)_zoffset; \
    packed_data->args.width = (GLsizei)_width; \
    packed_data->args.height = (GLsizei)_height; \
    packed_data->args.depth = (GLsizei)_depth; \
    packed_data->args.format = (GLenum)_format; \
    packed_data->args.imageSize = (GLsizei)_imageSize; \
    packed_data->args.data = (GLvoid *)_data; \
    (packed_call_t *)packed_data; \
})
#define call_glCompressedTexSubImage3D(packed, ret_v) do { \
    PACKED_glCompressedTexSubImage3D *unpacked = (PACKED_glCompressedTexSubImage3D *)packed; \
    ARGS_glCompressedTexSubImage3D *args = (ARGS_glCompressedTexSubImage3D *)&unpacked->args; \
    glCompressedTexSubImage3D(args->target, args->level, args->xoffset, args->yoffset, args->zoffset, args->width, args->height, args->depth, args->format, args->imageSize, args->data);; \
} while(0)
void glCompressedTexSubImage3D(glCompressedTexSubImage3D_ARG_EXPAND);
typedef void (*glCompressedTexSubImage3D_PTR)(glCompressedTexSubImage3D_ARG_EXPAND);
#define glCompressedTexSubImage3DARB_INDEX 346
#define glCompressedTexSubImage3DARB_RETURN void
#define glCompressedTexSubImage3DARB_ARG_NAMES target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data
#define glCompressedTexSubImage3DARB_ARG_EXPAND GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid * data
#define glCompressedTexSubImage3DARB_PACKED PACKED_glCompressedTexSubImage3DARB
#define glCompressedTexSubImage3DARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glCompressedTexSubImage3DARB_NOT_VOID_WRAP(...) {}
#define pack_glCompressedTexSubImage3DARB(_target, _level, _xoffset, _yoffset, _zoffset, _width, _height, _depth, _format, _imageSize, _data) ({ \
    glCompressedTexSubImage3DARB_PACKED *packed_data = malloc(sizeof(glCompressedTexSubImage3DARB_PACKED)); \
    packed_data->index = glCompressedTexSubImage3DARB_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.level = (GLint)_level; \
    packed_data->args.xoffset = (GLint)_xoffset; \
    packed_data->args.yoffset = (GLint)_yoffset; \
    packed_data->args.zoffset = (GLint)_zoffset; \
    packed_data->args.width = (GLsizei)_width; \
    packed_data->args.height = (GLsizei)_height; \
    packed_data->args.depth = (GLsizei)_depth; \
    packed_data->args.format = (GLenum)_format; \
    packed_data->args.imageSize = (GLsizei)_imageSize; \
    packed_data->args.data = (GLvoid *)_data; \
    (packed_call_t *)packed_data; \
})
#define call_glCompressedTexSubImage3DARB(packed, ret_v) do { \
    PACKED_glCompressedTexSubImage3DARB *unpacked = (PACKED_glCompressedTexSubImage3DARB *)packed; \
    ARGS_glCompressedTexSubImage3DARB *args = (ARGS_glCompressedTexSubImage3DARB *)&unpacked->args; \
    glCompressedTexSubImage3DARB(args->target, args->level, args->xoffset, args->yoffset, args->zoffset, args->width, args->height, args->depth, args->format, args->imageSize, args->data);; \
} while(0)
void glCompressedTexSubImage3DARB(glCompressedTexSubImage3DARB_ARG_EXPAND);
typedef void (*glCompressedTexSubImage3DARB_PTR)(glCompressedTexSubImage3DARB_ARG_EXPAND);
#define glCompressedTextureImage1DEXT_INDEX 347
#define glCompressedTextureImage1DEXT_RETURN void
#define glCompressedTextureImage1DEXT_ARG_NAMES texture, target, level, internalformat, width, border, imageSize, bits
#define glCompressedTextureImage1DEXT_ARG_EXPAND GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid * bits
#define glCompressedTextureImage1DEXT_PACKED PACKED_glCompressedTextureImage1DEXT
#define glCompressedTextureImage1DEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glCompressedTextureImage1DEXT_NOT_VOID_WRAP(...) {}
#define pack_glCompressedTextureImage1DEXT(_texture, _target, _level, _internalformat, _width, _border, _imageSize, _bits) ({ \
    glCompressedTextureImage1DEXT_PACKED *packed_data = malloc(sizeof(glCompressedTextureImage1DEXT_PACKED)); \
    packed_data->index = glCompressedTextureImage1DEXT_INDEX; \
    packed_data->args.texture = (GLuint)_texture; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.level = (GLint)_level; \
    packed_data->args.internalformat = (GLenum)_internalformat; \
    packed_data->args.width = (GLsizei)_width; \
    packed_data->args.border = (GLint)_border; \
    packed_data->args.imageSize = (GLsizei)_imageSize; \
    packed_data->args.bits = (GLvoid *)_bits; \
    (packed_call_t *)packed_data; \
})
#define call_glCompressedTextureImage1DEXT(packed, ret_v) do { \
    PACKED_glCompressedTextureImage1DEXT *unpacked = (PACKED_glCompressedTextureImage1DEXT *)packed; \
    ARGS_glCompressedTextureImage1DEXT *args = (ARGS_glCompressedTextureImage1DEXT *)&unpacked->args; \
    glCompressedTextureImage1DEXT(args->texture, args->target, args->level, args->internalformat, args->width, args->border, args->imageSize, args->bits);; \
} while(0)
void glCompressedTextureImage1DEXT(glCompressedTextureImage1DEXT_ARG_EXPAND);
typedef void (*glCompressedTextureImage1DEXT_PTR)(glCompressedTextureImage1DEXT_ARG_EXPAND);
#define glCompressedTextureImage2DEXT_INDEX 348
#define glCompressedTextureImage2DEXT_RETURN void
#define glCompressedTextureImage2DEXT_ARG_NAMES texture, target, level, internalformat, width, height, border, imageSize, bits
#define glCompressedTextureImage2DEXT_ARG_EXPAND GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid * bits
#define glCompressedTextureImage2DEXT_PACKED PACKED_glCompressedTextureImage2DEXT
#define glCompressedTextureImage2DEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glCompressedTextureImage2DEXT_NOT_VOID_WRAP(...) {}
#define pack_glCompressedTextureImage2DEXT(_texture, _target, _level, _internalformat, _width, _height, _border, _imageSize, _bits) ({ \
    glCompressedTextureImage2DEXT_PACKED *packed_data = malloc(sizeof(glCompressedTextureImage2DEXT_PACKED)); \
    packed_data->index = glCompressedTextureImage2DEXT_INDEX; \
    packed_data->args.texture = (GLuint)_texture; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.level = (GLint)_level; \
    packed_data->args.internalformat = (GLenum)_internalformat; \
    packed_data->args.width = (GLsizei)_width; \
    packed_data->args.height = (GLsizei)_height; \
    packed_data->args.border = (GLint)_border; \
    packed_data->args.imageSize = (GLsizei)_imageSize; \
    packed_data->args.bits = (GLvoid *)_bits; \
    (packed_call_t *)packed_data; \
})
#define call_glCompressedTextureImage2DEXT(packed, ret_v) do { \
    PACKED_glCompressedTextureImage2DEXT *unpacked = (PACKED_glCompressedTextureImage2DEXT *)packed; \
    ARGS_glCompressedTextureImage2DEXT *args = (ARGS_glCompressedTextureImage2DEXT *)&unpacked->args; \
    glCompressedTextureImage2DEXT(args->texture, args->target, args->level, args->internalformat, args->width, args->height, args->border, args->imageSize, args->bits);; \
} while(0)
void glCompressedTextureImage2DEXT(glCompressedTextureImage2DEXT_ARG_EXPAND);
typedef void (*glCompressedTextureImage2DEXT_PTR)(glCompressedTextureImage2DEXT_ARG_EXPAND);
#define glCompressedTextureImage3DEXT_INDEX 349
#define glCompressedTextureImage3DEXT_RETURN void
#define glCompressedTextureImage3DEXT_ARG_NAMES texture, target, level, internalformat, width, height, depth, border, imageSize, bits
#define glCompressedTextureImage3DEXT_ARG_EXPAND GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid * bits
#define glCompressedTextureImage3DEXT_PACKED PACKED_glCompressedTextureImage3DEXT
#define glCompressedTextureImage3DEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glCompressedTextureImage3DEXT_NOT_VOID_WRAP(...) {}
#define pack_glCompressedTextureImage3DEXT(_texture, _target, _level, _internalformat, _width, _height, _depth, _border, _imageSize, _bits) ({ \
    glCompressedTextureImage3DEXT_PACKED *packed_data = malloc(sizeof(glCompressedTextureImage3DEXT_PACKED)); \
    packed_data->index = glCompressedTextureImage3DEXT_INDEX; \
    packed_data->args.texture = (GLuint)_texture; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.level = (GLint)_level; \
    packed_data->args.internalformat = (GLenum)_internalformat; \
    packed_data->args.width = (GLsizei)_width; \
    packed_data->args.height = (GLsizei)_height; \
    packed_data->args.depth = (GLsizei)_depth; \
    packed_data->args.border = (GLint)_border; \
    packed_data->args.imageSize = (GLsizei)_imageSize; \
    packed_data->args.bits = (GLvoid *)_bits; \
    (packed_call_t *)packed_data; \
})
#define call_glCompressedTextureImage3DEXT(packed, ret_v) do { \
    PACKED_glCompressedTextureImage3DEXT *unpacked = (PACKED_glCompressedTextureImage3DEXT *)packed; \
    ARGS_glCompressedTextureImage3DEXT *args = (ARGS_glCompressedTextureImage3DEXT *)&unpacked->args; \
    glCompressedTextureImage3DEXT(args->texture, args->target, args->level, args->internalformat, args->width, args->height, args->depth, args->border, args->imageSize, args->bits);; \
} while(0)
void glCompressedTextureImage3DEXT(glCompressedTextureImage3DEXT_ARG_EXPAND);
typedef void (*glCompressedTextureImage3DEXT_PTR)(glCompressedTextureImage3DEXT_ARG_EXPAND);
#define glCompressedTextureSubImage1DEXT_INDEX 350
#define glCompressedTextureSubImage1DEXT_RETURN void
#define glCompressedTextureSubImage1DEXT_ARG_NAMES texture, target, level, xoffset, width, format, imageSize, bits
#define glCompressedTextureSubImage1DEXT_ARG_EXPAND GLuint texture, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid * bits
#define glCompressedTextureSubImage1DEXT_PACKED PACKED_glCompressedTextureSubImage1DEXT
#define glCompressedTextureSubImage1DEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glCompressedTextureSubImage1DEXT_NOT_VOID_WRAP(...) {}
#define pack_glCompressedTextureSubImage1DEXT(_texture, _target, _level, _xoffset, _width, _format, _imageSize, _bits) ({ \
    glCompressedTextureSubImage1DEXT_PACKED *packed_data = malloc(sizeof(glCompressedTextureSubImage1DEXT_PACKED)); \
    packed_data->index = glCompressedTextureSubImage1DEXT_INDEX; \
    packed_data->args.texture = (GLuint)_texture; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.level = (GLint)_level; \
    packed_data->args.xoffset = (GLint)_xoffset; \
    packed_data->args.width = (GLsizei)_width; \
    packed_data->args.format = (GLenum)_format; \
    packed_data->args.imageSize = (GLsizei)_imageSize; \
    packed_data->args.bits = (GLvoid *)_bits; \
    (packed_call_t *)packed_data; \
})
#define call_glCompressedTextureSubImage1DEXT(packed, ret_v) do { \
    PACKED_glCompressedTextureSubImage1DEXT *unpacked = (PACKED_glCompressedTextureSubImage1DEXT *)packed; \
    ARGS_glCompressedTextureSubImage1DEXT *args = (ARGS_glCompressedTextureSubImage1DEXT *)&unpacked->args; \
    glCompressedTextureSubImage1DEXT(args->texture, args->target, args->level, args->xoffset, args->width, args->format, args->imageSize, args->bits);; \
} while(0)
void glCompressedTextureSubImage1DEXT(glCompressedTextureSubImage1DEXT_ARG_EXPAND);
typedef void (*glCompressedTextureSubImage1DEXT_PTR)(glCompressedTextureSubImage1DEXT_ARG_EXPAND);
#define glCompressedTextureSubImage2DEXT_INDEX 351
#define glCompressedTextureSubImage2DEXT_RETURN void
#define glCompressedTextureSubImage2DEXT_ARG_NAMES texture, target, level, xoffset, yoffset, width, height, format, imageSize, bits
#define glCompressedTextureSubImage2DEXT_ARG_EXPAND GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid * bits
#define glCompressedTextureSubImage2DEXT_PACKED PACKED_glCompressedTextureSubImage2DEXT
#define glCompressedTextureSubImage2DEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glCompressedTextureSubImage2DEXT_NOT_VOID_WRAP(...) {}
#define pack_glCompressedTextureSubImage2DEXT(_texture, _target, _level, _xoffset, _yoffset, _width, _height, _format, _imageSize, _bits) ({ \
    glCompressedTextureSubImage2DEXT_PACKED *packed_data = malloc(sizeof(glCompressedTextureSubImage2DEXT_PACKED)); \
    packed_data->index = glCompressedTextureSubImage2DEXT_INDEX; \
    packed_data->args.texture = (GLuint)_texture; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.level = (GLint)_level; \
    packed_data->args.xoffset = (GLint)_xoffset; \
    packed_data->args.yoffset = (GLint)_yoffset; \
    packed_data->args.width = (GLsizei)_width; \
    packed_data->args.height = (GLsizei)_height; \
    packed_data->args.format = (GLenum)_format; \
    packed_data->args.imageSize = (GLsizei)_imageSize; \
    packed_data->args.bits = (GLvoid *)_bits; \
    (packed_call_t *)packed_data; \
})
#define call_glCompressedTextureSubImage2DEXT(packed, ret_v) do { \
    PACKED_glCompressedTextureSubImage2DEXT *unpacked = (PACKED_glCompressedTextureSubImage2DEXT *)packed; \
    ARGS_glCompressedTextureSubImage2DEXT *args = (ARGS_glCompressedTextureSubImage2DEXT *)&unpacked->args; \
    glCompressedTextureSubImage2DEXT(args->texture, args->target, args->level, args->xoffset, args->yoffset, args->width, args->height, args->format, args->imageSize, args->bits);; \
} while(0)
void glCompressedTextureSubImage2DEXT(glCompressedTextureSubImage2DEXT_ARG_EXPAND);
typedef void (*glCompressedTextureSubImage2DEXT_PTR)(glCompressedTextureSubImage2DEXT_ARG_EXPAND);
#define glCompressedTextureSubImage3DEXT_INDEX 352
#define glCompressedTextureSubImage3DEXT_RETURN void
#define glCompressedTextureSubImage3DEXT_ARG_NAMES texture, target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, bits
#define glCompressedTextureSubImage3DEXT_ARG_EXPAND GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid * bits
#define glCompressedTextureSubImage3DEXT_PACKED PACKED_glCompressedTextureSubImage3DEXT
#define glCompressedTextureSubImage3DEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glCompressedTextureSubImage3DEXT_NOT_VOID_WRAP(...) {}
#define pack_glCompressedTextureSubImage3DEXT(_texture, _target, _level, _xoffset, _yoffset, _zoffset, _width, _height, _depth, _format, _imageSize, _bits) ({ \
    glCompressedTextureSubImage3DEXT_PACKED *packed_data = malloc(sizeof(glCompressedTextureSubImage3DEXT_PACKED)); \
    packed_data->index = glCompressedTextureSubImage3DEXT_INDEX; \
    packed_data->args.texture = (GLuint)_texture; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.level = (GLint)_level; \
    packed_data->args.xoffset = (GLint)_xoffset; \
    packed_data->args.yoffset = (GLint)_yoffset; \
    packed_data->args.zoffset = (GLint)_zoffset; \
    packed_data->args.width = (GLsizei)_width; \
    packed_data->args.height = (GLsizei)_height; \
    packed_data->args.depth = (GLsizei)_depth; \
    packed_data->args.format = (GLenum)_format; \
    packed_data->args.imageSize = (GLsizei)_imageSize; \
    packed_data->args.bits = (GLvoid *)_bits; \
    (packed_call_t *)packed_data; \
})
#define call_glCompressedTextureSubImage3DEXT(packed, ret_v) do { \
    PACKED_glCompressedTextureSubImage3DEXT *unpacked = (PACKED_glCompressedTextureSubImage3DEXT *)packed; \
    ARGS_glCompressedTextureSubImage3DEXT *args = (ARGS_glCompressedTextureSubImage3DEXT *)&unpacked->args; \
    glCompressedTextureSubImage3DEXT(args->texture, args->target, args->level, args->xoffset, args->yoffset, args->zoffset, args->width, args->height, args->depth, args->format, args->imageSize, args->bits);; \
} while(0)
void glCompressedTextureSubImage3DEXT(glCompressedTextureSubImage3DEXT_ARG_EXPAND);
typedef void (*glCompressedTextureSubImage3DEXT_PTR)(glCompressedTextureSubImage3DEXT_ARG_EXPAND);
#define glConvolutionFilter1D_INDEX 353
#define glConvolutionFilter1D_RETURN void
#define glConvolutionFilter1D_ARG_NAMES target, internalformat, width, format, type, image
#define glConvolutionFilter1D_ARG_EXPAND GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid * image
#define glConvolutionFilter1D_PACKED PACKED_glConvolutionFilter1D
#define glConvolutionFilter1D_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glConvolutionFilter1D_NOT_VOID_WRAP(...) {}
#define pack_glConvolutionFilter1D(_target, _internalformat, _width, _format, _type, _image) ({ \
    glConvolutionFilter1D_PACKED *packed_data = malloc(sizeof(glConvolutionFilter1D_PACKED)); \
    packed_data->index = glConvolutionFilter1D_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.internalformat = (GLenum)_internalformat; \
    packed_data->args.width = (GLsizei)_width; \
    packed_data->args.format = (GLenum)_format; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.image = (GLvoid *)_image; \
    (packed_call_t *)packed_data; \
})
#define call_glConvolutionFilter1D(packed, ret_v) do { \
    PACKED_glConvolutionFilter1D *unpacked = (PACKED_glConvolutionFilter1D *)packed; \
    ARGS_glConvolutionFilter1D *args = (ARGS_glConvolutionFilter1D *)&unpacked->args; \
    glConvolutionFilter1D(args->target, args->internalformat, args->width, args->format, args->type, args->image);; \
} while(0)
void glConvolutionFilter1D(glConvolutionFilter1D_ARG_EXPAND);
typedef void (*glConvolutionFilter1D_PTR)(glConvolutionFilter1D_ARG_EXPAND);
#define glConvolutionFilter1DEXT_INDEX 354
#define glConvolutionFilter1DEXT_RETURN void
#define glConvolutionFilter1DEXT_ARG_NAMES target, internalformat, width, format, type, image
#define glConvolutionFilter1DEXT_ARG_EXPAND GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid * image
#define glConvolutionFilter1DEXT_PACKED PACKED_glConvolutionFilter1DEXT
#define glConvolutionFilter1DEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glConvolutionFilter1DEXT_NOT_VOID_WRAP(...) {}
#define pack_glConvolutionFilter1DEXT(_target, _internalformat, _width, _format, _type, _image) ({ \
    glConvolutionFilter1DEXT_PACKED *packed_data = malloc(sizeof(glConvolutionFilter1DEXT_PACKED)); \
    packed_data->index = glConvolutionFilter1DEXT_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.internalformat = (GLenum)_internalformat; \
    packed_data->args.width = (GLsizei)_width; \
    packed_data->args.format = (GLenum)_format; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.image = (GLvoid *)_image; \
    (packed_call_t *)packed_data; \
})
#define call_glConvolutionFilter1DEXT(packed, ret_v) do { \
    PACKED_glConvolutionFilter1DEXT *unpacked = (PACKED_glConvolutionFilter1DEXT *)packed; \
    ARGS_glConvolutionFilter1DEXT *args = (ARGS_glConvolutionFilter1DEXT *)&unpacked->args; \
    glConvolutionFilter1DEXT(args->target, args->internalformat, args->width, args->format, args->type, args->image);; \
} while(0)
void glConvolutionFilter1DEXT(glConvolutionFilter1DEXT_ARG_EXPAND);
typedef void (*glConvolutionFilter1DEXT_PTR)(glConvolutionFilter1DEXT_ARG_EXPAND);
#define glConvolutionFilter2D_INDEX 355
#define glConvolutionFilter2D_RETURN void
#define glConvolutionFilter2D_ARG_NAMES target, internalformat, width, height, format, type, image
#define glConvolutionFilter2D_ARG_EXPAND GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid * image
#define glConvolutionFilter2D_PACKED PACKED_glConvolutionFilter2D
#define glConvolutionFilter2D_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glConvolutionFilter2D_NOT_VOID_WRAP(...) {}
#define pack_glConvolutionFilter2D(_target, _internalformat, _width, _height, _format, _type, _image) ({ \
    glConvolutionFilter2D_PACKED *packed_data = malloc(sizeof(glConvolutionFilter2D_PACKED)); \
    packed_data->index = glConvolutionFilter2D_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.internalformat = (GLenum)_internalformat; \
    packed_data->args.width = (GLsizei)_width; \
    packed_data->args.height = (GLsizei)_height; \
    packed_data->args.format = (GLenum)_format; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.image = (GLvoid *)_image; \
    (packed_call_t *)packed_data; \
})
#define call_glConvolutionFilter2D(packed, ret_v) do { \
    PACKED_glConvolutionFilter2D *unpacked = (PACKED_glConvolutionFilter2D *)packed; \
    ARGS_glConvolutionFilter2D *args = (ARGS_glConvolutionFilter2D *)&unpacked->args; \
    glConvolutionFilter2D(args->target, args->internalformat, args->width, args->height, args->format, args->type, args->image);; \
} while(0)
void glConvolutionFilter2D(glConvolutionFilter2D_ARG_EXPAND);
typedef void (*glConvolutionFilter2D_PTR)(glConvolutionFilter2D_ARG_EXPAND);
#define glConvolutionFilter2DEXT_INDEX 356
#define glConvolutionFilter2DEXT_RETURN void
#define glConvolutionFilter2DEXT_ARG_NAMES target, internalformat, width, height, format, type, image
#define glConvolutionFilter2DEXT_ARG_EXPAND GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid * image
#define glConvolutionFilter2DEXT_PACKED PACKED_glConvolutionFilter2DEXT
#define glConvolutionFilter2DEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glConvolutionFilter2DEXT_NOT_VOID_WRAP(...) {}
#define pack_glConvolutionFilter2DEXT(_target, _internalformat, _width, _height, _format, _type, _image) ({ \
    glConvolutionFilter2DEXT_PACKED *packed_data = malloc(sizeof(glConvolutionFilter2DEXT_PACKED)); \
    packed_data->index = glConvolutionFilter2DEXT_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.internalformat = (GLenum)_internalformat; \
    packed_data->args.width = (GLsizei)_width; \
    packed_data->args.height = (GLsizei)_height; \
    packed_data->args.format = (GLenum)_format; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.image = (GLvoid *)_image; \
    (packed_call_t *)packed_data; \
})
#define call_glConvolutionFilter2DEXT(packed, ret_v) do { \
    PACKED_glConvolutionFilter2DEXT *unpacked = (PACKED_glConvolutionFilter2DEXT *)packed; \
    ARGS_glConvolutionFilter2DEXT *args = (ARGS_glConvolutionFilter2DEXT *)&unpacked->args; \
    glConvolutionFilter2DEXT(args->target, args->internalformat, args->width, args->height, args->format, args->type, args->image);; \
} while(0)
void glConvolutionFilter2DEXT(glConvolutionFilter2DEXT_ARG_EXPAND);
typedef void (*glConvolutionFilter2DEXT_PTR)(glConvolutionFilter2DEXT_ARG_EXPAND);
#define glConvolutionParameterf_INDEX 357
#define glConvolutionParameterf_RETURN void
#define glConvolutionParameterf_ARG_NAMES target, pname, params
#define glConvolutionParameterf_ARG_EXPAND GLenum target, GLenum pname, GLfloat params
#define glConvolutionParameterf_PACKED PACKED_glConvolutionParameterf
#define glConvolutionParameterf_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glConvolutionParameterf_NOT_VOID_WRAP(...) {}
#define pack_glConvolutionParameterf(_target, _pname, _params) ({ \
    glConvolutionParameterf_PACKED *packed_data = malloc(sizeof(glConvolutionParameterf_PACKED)); \
    packed_data->index = glConvolutionParameterf_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLfloat)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glConvolutionParameterf(packed, ret_v) do { \
    PACKED_glConvolutionParameterf *unpacked = (PACKED_glConvolutionParameterf *)packed; \
    ARGS_glConvolutionParameterf *args = (ARGS_glConvolutionParameterf *)&unpacked->args; \
    glConvolutionParameterf(args->target, args->pname, args->params);; \
} while(0)
void glConvolutionParameterf(glConvolutionParameterf_ARG_EXPAND);
typedef void (*glConvolutionParameterf_PTR)(glConvolutionParameterf_ARG_EXPAND);
#define glConvolutionParameterfEXT_INDEX 358
#define glConvolutionParameterfEXT_RETURN void
#define glConvolutionParameterfEXT_ARG_NAMES target, pname, params
#define glConvolutionParameterfEXT_ARG_EXPAND GLenum target, GLenum pname, GLfloat params
#define glConvolutionParameterfEXT_PACKED PACKED_glConvolutionParameterfEXT
#define glConvolutionParameterfEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glConvolutionParameterfEXT_NOT_VOID_WRAP(...) {}
#define pack_glConvolutionParameterfEXT(_target, _pname, _params) ({ \
    glConvolutionParameterfEXT_PACKED *packed_data = malloc(sizeof(glConvolutionParameterfEXT_PACKED)); \
    packed_data->index = glConvolutionParameterfEXT_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLfloat)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glConvolutionParameterfEXT(packed, ret_v) do { \
    PACKED_glConvolutionParameterfEXT *unpacked = (PACKED_glConvolutionParameterfEXT *)packed; \
    ARGS_glConvolutionParameterfEXT *args = (ARGS_glConvolutionParameterfEXT *)&unpacked->args; \
    glConvolutionParameterfEXT(args->target, args->pname, args->params);; \
} while(0)
void glConvolutionParameterfEXT(glConvolutionParameterfEXT_ARG_EXPAND);
typedef void (*glConvolutionParameterfEXT_PTR)(glConvolutionParameterfEXT_ARG_EXPAND);
#define glConvolutionParameterfv_INDEX 359
#define glConvolutionParameterfv_RETURN void
#define glConvolutionParameterfv_ARG_NAMES target, pname, params
#define glConvolutionParameterfv_ARG_EXPAND GLenum target, GLenum pname, const GLfloat * params
#define glConvolutionParameterfv_PACKED PACKED_glConvolutionParameterfv
#define glConvolutionParameterfv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glConvolutionParameterfv_NOT_VOID_WRAP(...) {}
#define pack_glConvolutionParameterfv(_target, _pname, _params) ({ \
    glConvolutionParameterfv_PACKED *packed_data = malloc(sizeof(glConvolutionParameterfv_PACKED)); \
    packed_data->index = glConvolutionParameterfv_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLfloat *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glConvolutionParameterfv(packed, ret_v) do { \
    PACKED_glConvolutionParameterfv *unpacked = (PACKED_glConvolutionParameterfv *)packed; \
    ARGS_glConvolutionParameterfv *args = (ARGS_glConvolutionParameterfv *)&unpacked->args; \
    glConvolutionParameterfv(args->target, args->pname, args->params);; \
} while(0)
void glConvolutionParameterfv(glConvolutionParameterfv_ARG_EXPAND);
typedef void (*glConvolutionParameterfv_PTR)(glConvolutionParameterfv_ARG_EXPAND);
#define glConvolutionParameterfvEXT_INDEX 360
#define glConvolutionParameterfvEXT_RETURN void
#define glConvolutionParameterfvEXT_ARG_NAMES target, pname, params
#define glConvolutionParameterfvEXT_ARG_EXPAND GLenum target, GLenum pname, const GLfloat * params
#define glConvolutionParameterfvEXT_PACKED PACKED_glConvolutionParameterfvEXT
#define glConvolutionParameterfvEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glConvolutionParameterfvEXT_NOT_VOID_WRAP(...) {}
#define pack_glConvolutionParameterfvEXT(_target, _pname, _params) ({ \
    glConvolutionParameterfvEXT_PACKED *packed_data = malloc(sizeof(glConvolutionParameterfvEXT_PACKED)); \
    packed_data->index = glConvolutionParameterfvEXT_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLfloat *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glConvolutionParameterfvEXT(packed, ret_v) do { \
    PACKED_glConvolutionParameterfvEXT *unpacked = (PACKED_glConvolutionParameterfvEXT *)packed; \
    ARGS_glConvolutionParameterfvEXT *args = (ARGS_glConvolutionParameterfvEXT *)&unpacked->args; \
    glConvolutionParameterfvEXT(args->target, args->pname, args->params);; \
} while(0)
void glConvolutionParameterfvEXT(glConvolutionParameterfvEXT_ARG_EXPAND);
typedef void (*glConvolutionParameterfvEXT_PTR)(glConvolutionParameterfvEXT_ARG_EXPAND);
#define glConvolutionParameteri_INDEX 361
#define glConvolutionParameteri_RETURN void
#define glConvolutionParameteri_ARG_NAMES target, pname, params
#define glConvolutionParameteri_ARG_EXPAND GLenum target, GLenum pname, GLint params
#define glConvolutionParameteri_PACKED PACKED_glConvolutionParameteri
#define glConvolutionParameteri_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glConvolutionParameteri_NOT_VOID_WRAP(...) {}
#define pack_glConvolutionParameteri(_target, _pname, _params) ({ \
    glConvolutionParameteri_PACKED *packed_data = malloc(sizeof(glConvolutionParameteri_PACKED)); \
    packed_data->index = glConvolutionParameteri_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLint)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glConvolutionParameteri(packed, ret_v) do { \
    PACKED_glConvolutionParameteri *unpacked = (PACKED_glConvolutionParameteri *)packed; \
    ARGS_glConvolutionParameteri *args = (ARGS_glConvolutionParameteri *)&unpacked->args; \
    glConvolutionParameteri(args->target, args->pname, args->params);; \
} while(0)
void glConvolutionParameteri(glConvolutionParameteri_ARG_EXPAND);
typedef void (*glConvolutionParameteri_PTR)(glConvolutionParameteri_ARG_EXPAND);
#define glConvolutionParameteriEXT_INDEX 362
#define glConvolutionParameteriEXT_RETURN void
#define glConvolutionParameteriEXT_ARG_NAMES target, pname, params
#define glConvolutionParameteriEXT_ARG_EXPAND GLenum target, GLenum pname, GLint params
#define glConvolutionParameteriEXT_PACKED PACKED_glConvolutionParameteriEXT
#define glConvolutionParameteriEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glConvolutionParameteriEXT_NOT_VOID_WRAP(...) {}
#define pack_glConvolutionParameteriEXT(_target, _pname, _params) ({ \
    glConvolutionParameteriEXT_PACKED *packed_data = malloc(sizeof(glConvolutionParameteriEXT_PACKED)); \
    packed_data->index = glConvolutionParameteriEXT_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLint)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glConvolutionParameteriEXT(packed, ret_v) do { \
    PACKED_glConvolutionParameteriEXT *unpacked = (PACKED_glConvolutionParameteriEXT *)packed; \
    ARGS_glConvolutionParameteriEXT *args = (ARGS_glConvolutionParameteriEXT *)&unpacked->args; \
    glConvolutionParameteriEXT(args->target, args->pname, args->params);; \
} while(0)
void glConvolutionParameteriEXT(glConvolutionParameteriEXT_ARG_EXPAND);
typedef void (*glConvolutionParameteriEXT_PTR)(glConvolutionParameteriEXT_ARG_EXPAND);
#define glConvolutionParameteriv_INDEX 363
#define glConvolutionParameteriv_RETURN void
#define glConvolutionParameteriv_ARG_NAMES target, pname, params
#define glConvolutionParameteriv_ARG_EXPAND GLenum target, GLenum pname, const GLint * params
#define glConvolutionParameteriv_PACKED PACKED_glConvolutionParameteriv
#define glConvolutionParameteriv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glConvolutionParameteriv_NOT_VOID_WRAP(...) {}
#define pack_glConvolutionParameteriv(_target, _pname, _params) ({ \
    glConvolutionParameteriv_PACKED *packed_data = malloc(sizeof(glConvolutionParameteriv_PACKED)); \
    packed_data->index = glConvolutionParameteriv_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glConvolutionParameteriv(packed, ret_v) do { \
    PACKED_glConvolutionParameteriv *unpacked = (PACKED_glConvolutionParameteriv *)packed; \
    ARGS_glConvolutionParameteriv *args = (ARGS_glConvolutionParameteriv *)&unpacked->args; \
    glConvolutionParameteriv(args->target, args->pname, args->params);; \
} while(0)
void glConvolutionParameteriv(glConvolutionParameteriv_ARG_EXPAND);
typedef void (*glConvolutionParameteriv_PTR)(glConvolutionParameteriv_ARG_EXPAND);
#define glConvolutionParameterivEXT_INDEX 364
#define glConvolutionParameterivEXT_RETURN void
#define glConvolutionParameterivEXT_ARG_NAMES target, pname, params
#define glConvolutionParameterivEXT_ARG_EXPAND GLenum target, GLenum pname, const GLint * params
#define glConvolutionParameterivEXT_PACKED PACKED_glConvolutionParameterivEXT
#define glConvolutionParameterivEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glConvolutionParameterivEXT_NOT_VOID_WRAP(...) {}
#define pack_glConvolutionParameterivEXT(_target, _pname, _params) ({ \
    glConvolutionParameterivEXT_PACKED *packed_data = malloc(sizeof(glConvolutionParameterivEXT_PACKED)); \
    packed_data->index = glConvolutionParameterivEXT_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glConvolutionParameterivEXT(packed, ret_v) do { \
    PACKED_glConvolutionParameterivEXT *unpacked = (PACKED_glConvolutionParameterivEXT *)packed; \
    ARGS_glConvolutionParameterivEXT *args = (ARGS_glConvolutionParameterivEXT *)&unpacked->args; \
    glConvolutionParameterivEXT(args->target, args->pname, args->params);; \
} while(0)
void glConvolutionParameterivEXT(glConvolutionParameterivEXT_ARG_EXPAND);
typedef void (*glConvolutionParameterivEXT_PTR)(glConvolutionParameterivEXT_ARG_EXPAND);
#define glConvolutionParameterxOES_INDEX 365
#define glConvolutionParameterxOES_RETURN void
#define glConvolutionParameterxOES_ARG_NAMES target, pname, param
#define glConvolutionParameterxOES_ARG_EXPAND GLenum target, GLenum pname, GLfixed param
#define glConvolutionParameterxOES_PACKED PACKED_glConvolutionParameterxOES
#define glConvolutionParameterxOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glConvolutionParameterxOES_NOT_VOID_WRAP(...) {}
#define pack_glConvolutionParameterxOES(_target, _pname, _param) ({ \
    glConvolutionParameterxOES_PACKED *packed_data = malloc(sizeof(glConvolutionParameterxOES_PACKED)); \
    packed_data->index = glConvolutionParameterxOES_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.param = (GLfixed)_param; \
    (packed_call_t *)packed_data; \
})
#define call_glConvolutionParameterxOES(packed, ret_v) do { \
    PACKED_glConvolutionParameterxOES *unpacked = (PACKED_glConvolutionParameterxOES *)packed; \
    ARGS_glConvolutionParameterxOES *args = (ARGS_glConvolutionParameterxOES *)&unpacked->args; \
    glConvolutionParameterxOES(args->target, args->pname, args->param);; \
} while(0)
void glConvolutionParameterxOES(glConvolutionParameterxOES_ARG_EXPAND);
typedef void (*glConvolutionParameterxOES_PTR)(glConvolutionParameterxOES_ARG_EXPAND);
#define glConvolutionParameterxvOES_INDEX 366
#define glConvolutionParameterxvOES_RETURN void
#define glConvolutionParameterxvOES_ARG_NAMES target, pname, params
#define glConvolutionParameterxvOES_ARG_EXPAND GLenum target, GLenum pname, const GLfixed * params
#define glConvolutionParameterxvOES_PACKED PACKED_glConvolutionParameterxvOES
#define glConvolutionParameterxvOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glConvolutionParameterxvOES_NOT_VOID_WRAP(...) {}
#define pack_glConvolutionParameterxvOES(_target, _pname, _params) ({ \
    glConvolutionParameterxvOES_PACKED *packed_data = malloc(sizeof(glConvolutionParameterxvOES_PACKED)); \
    packed_data->index = glConvolutionParameterxvOES_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLfixed *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glConvolutionParameterxvOES(packed, ret_v) do { \
    PACKED_glConvolutionParameterxvOES *unpacked = (PACKED_glConvolutionParameterxvOES *)packed; \
    ARGS_glConvolutionParameterxvOES *args = (ARGS_glConvolutionParameterxvOES *)&unpacked->args; \
    glConvolutionParameterxvOES(args->target, args->pname, args->params);; \
} while(0)
void glConvolutionParameterxvOES(glConvolutionParameterxvOES_ARG_EXPAND);
typedef void (*glConvolutionParameterxvOES_PTR)(glConvolutionParameterxvOES_ARG_EXPAND);
#define glCopyBufferSubData_INDEX 367
#define glCopyBufferSubData_RETURN void
#define glCopyBufferSubData_ARG_NAMES readTarget, writeTarget, readOffset, writeOffset, size
#define glCopyBufferSubData_ARG_EXPAND GLenum readTarget, GLenum writeTarget, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size
#define glCopyBufferSubData_PACKED PACKED_glCopyBufferSubData
#define glCopyBufferSubData_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glCopyBufferSubData_NOT_VOID_WRAP(...) {}
#define pack_glCopyBufferSubData(_readTarget, _writeTarget, _readOffset, _writeOffset, _size) ({ \
    glCopyBufferSubData_PACKED *packed_data = malloc(sizeof(glCopyBufferSubData_PACKED)); \
    packed_data->index = glCopyBufferSubData_INDEX; \
    packed_data->args.readTarget = (GLenum)_readTarget; \
    packed_data->args.writeTarget = (GLenum)_writeTarget; \
    packed_data->args.readOffset = (GLintptr)_readOffset; \
    packed_data->args.writeOffset = (GLintptr)_writeOffset; \
    packed_data->args.size = (GLsizeiptr)_size; \
    (packed_call_t *)packed_data; \
})
#define call_glCopyBufferSubData(packed, ret_v) do { \
    PACKED_glCopyBufferSubData *unpacked = (PACKED_glCopyBufferSubData *)packed; \
    ARGS_glCopyBufferSubData *args = (ARGS_glCopyBufferSubData *)&unpacked->args; \
    glCopyBufferSubData(args->readTarget, args->writeTarget, args->readOffset, args->writeOffset, args->size);; \
} while(0)
void glCopyBufferSubData(glCopyBufferSubData_ARG_EXPAND);
typedef void (*glCopyBufferSubData_PTR)(glCopyBufferSubData_ARG_EXPAND);
#define glCopyColorSubTable_INDEX 368
#define glCopyColorSubTable_RETURN void
#define glCopyColorSubTable_ARG_NAMES target, start, x, y, width
#define glCopyColorSubTable_ARG_EXPAND GLenum target, GLsizei start, GLint x, GLint y, GLsizei width
#define glCopyColorSubTable_PACKED PACKED_glCopyColorSubTable
#define glCopyColorSubTable_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glCopyColorSubTable_NOT_VOID_WRAP(...) {}
#define pack_glCopyColorSubTable(_target, _start, _x, _y, _width) ({ \
    glCopyColorSubTable_PACKED *packed_data = malloc(sizeof(glCopyColorSubTable_PACKED)); \
    packed_data->index = glCopyColorSubTable_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.start = (GLsizei)_start; \
    packed_data->args.x = (GLint)_x; \
    packed_data->args.y = (GLint)_y; \
    packed_data->args.width = (GLsizei)_width; \
    (packed_call_t *)packed_data; \
})
#define call_glCopyColorSubTable(packed, ret_v) do { \
    PACKED_glCopyColorSubTable *unpacked = (PACKED_glCopyColorSubTable *)packed; \
    ARGS_glCopyColorSubTable *args = (ARGS_glCopyColorSubTable *)&unpacked->args; \
    glCopyColorSubTable(args->target, args->start, args->x, args->y, args->width);; \
} while(0)
void glCopyColorSubTable(glCopyColorSubTable_ARG_EXPAND);
typedef void (*glCopyColorSubTable_PTR)(glCopyColorSubTable_ARG_EXPAND);
#define glCopyColorSubTableEXT_INDEX 369
#define glCopyColorSubTableEXT_RETURN void
#define glCopyColorSubTableEXT_ARG_NAMES target, start, x, y, width
#define glCopyColorSubTableEXT_ARG_EXPAND GLenum target, GLsizei start, GLint x, GLint y, GLsizei width
#define glCopyColorSubTableEXT_PACKED PACKED_glCopyColorSubTableEXT
#define glCopyColorSubTableEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glCopyColorSubTableEXT_NOT_VOID_WRAP(...) {}
#define pack_glCopyColorSubTableEXT(_target, _start, _x, _y, _width) ({ \
    glCopyColorSubTableEXT_PACKED *packed_data = malloc(sizeof(glCopyColorSubTableEXT_PACKED)); \
    packed_data->index = glCopyColorSubTableEXT_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.start = (GLsizei)_start; \
    packed_data->args.x = (GLint)_x; \
    packed_data->args.y = (GLint)_y; \
    packed_data->args.width = (GLsizei)_width; \
    (packed_call_t *)packed_data; \
})
#define call_glCopyColorSubTableEXT(packed, ret_v) do { \
    PACKED_glCopyColorSubTableEXT *unpacked = (PACKED_glCopyColorSubTableEXT *)packed; \
    ARGS_glCopyColorSubTableEXT *args = (ARGS_glCopyColorSubTableEXT *)&unpacked->args; \
    glCopyColorSubTableEXT(args->target, args->start, args->x, args->y, args->width);; \
} while(0)
void glCopyColorSubTableEXT(glCopyColorSubTableEXT_ARG_EXPAND);
typedef void (*glCopyColorSubTableEXT_PTR)(glCopyColorSubTableEXT_ARG_EXPAND);
#define glCopyColorTable_INDEX 370
#define glCopyColorTable_RETURN void
#define glCopyColorTable_ARG_NAMES target, internalformat, x, y, width
#define glCopyColorTable_ARG_EXPAND GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width
#define glCopyColorTable_PACKED PACKED_glCopyColorTable
#define glCopyColorTable_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glCopyColorTable_NOT_VOID_WRAP(...) {}
#define pack_glCopyColorTable(_target, _internalformat, _x, _y, _width) ({ \
    glCopyColorTable_PACKED *packed_data = malloc(sizeof(glCopyColorTable_PACKED)); \
    packed_data->index = glCopyColorTable_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.internalformat = (GLenum)_internalformat; \
    packed_data->args.x = (GLint)_x; \
    packed_data->args.y = (GLint)_y; \
    packed_data->args.width = (GLsizei)_width; \
    (packed_call_t *)packed_data; \
})
#define call_glCopyColorTable(packed, ret_v) do { \
    PACKED_glCopyColorTable *unpacked = (PACKED_glCopyColorTable *)packed; \
    ARGS_glCopyColorTable *args = (ARGS_glCopyColorTable *)&unpacked->args; \
    glCopyColorTable(args->target, args->internalformat, args->x, args->y, args->width);; \
} while(0)
void glCopyColorTable(glCopyColorTable_ARG_EXPAND);
typedef void (*glCopyColorTable_PTR)(glCopyColorTable_ARG_EXPAND);
#define glCopyColorTableSGI_INDEX 371
#define glCopyColorTableSGI_RETURN void
#define glCopyColorTableSGI_ARG_NAMES target, internalformat, x, y, width
#define glCopyColorTableSGI_ARG_EXPAND GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width
#define glCopyColorTableSGI_PACKED PACKED_glCopyColorTableSGI
#define glCopyColorTableSGI_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glCopyColorTableSGI_NOT_VOID_WRAP(...) {}
#define pack_glCopyColorTableSGI(_target, _internalformat, _x, _y, _width) ({ \
    glCopyColorTableSGI_PACKED *packed_data = malloc(sizeof(glCopyColorTableSGI_PACKED)); \
    packed_data->index = glCopyColorTableSGI_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.internalformat = (GLenum)_internalformat; \
    packed_data->args.x = (GLint)_x; \
    packed_data->args.y = (GLint)_y; \
    packed_data->args.width = (GLsizei)_width; \
    (packed_call_t *)packed_data; \
})
#define call_glCopyColorTableSGI(packed, ret_v) do { \
    PACKED_glCopyColorTableSGI *unpacked = (PACKED_glCopyColorTableSGI *)packed; \
    ARGS_glCopyColorTableSGI *args = (ARGS_glCopyColorTableSGI *)&unpacked->args; \
    glCopyColorTableSGI(args->target, args->internalformat, args->x, args->y, args->width);; \
} while(0)
void glCopyColorTableSGI(glCopyColorTableSGI_ARG_EXPAND);
typedef void (*glCopyColorTableSGI_PTR)(glCopyColorTableSGI_ARG_EXPAND);
#define glCopyConvolutionFilter1D_INDEX 372
#define glCopyConvolutionFilter1D_RETURN void
#define glCopyConvolutionFilter1D_ARG_NAMES target, internalformat, x, y, width
#define glCopyConvolutionFilter1D_ARG_EXPAND GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width
#define glCopyConvolutionFilter1D_PACKED PACKED_glCopyConvolutionFilter1D
#define glCopyConvolutionFilter1D_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glCopyConvolutionFilter1D_NOT_VOID_WRAP(...) {}
#define pack_glCopyConvolutionFilter1D(_target, _internalformat, _x, _y, _width) ({ \
    glCopyConvolutionFilter1D_PACKED *packed_data = malloc(sizeof(glCopyConvolutionFilter1D_PACKED)); \
    packed_data->index = glCopyConvolutionFilter1D_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.internalformat = (GLenum)_internalformat; \
    packed_data->args.x = (GLint)_x; \
    packed_data->args.y = (GLint)_y; \
    packed_data->args.width = (GLsizei)_width; \
    (packed_call_t *)packed_data; \
})
#define call_glCopyConvolutionFilter1D(packed, ret_v) do { \
    PACKED_glCopyConvolutionFilter1D *unpacked = (PACKED_glCopyConvolutionFilter1D *)packed; \
    ARGS_glCopyConvolutionFilter1D *args = (ARGS_glCopyConvolutionFilter1D *)&unpacked->args; \
    glCopyConvolutionFilter1D(args->target, args->internalformat, args->x, args->y, args->width);; \
} while(0)
void glCopyConvolutionFilter1D(glCopyConvolutionFilter1D_ARG_EXPAND);
typedef void (*glCopyConvolutionFilter1D_PTR)(glCopyConvolutionFilter1D_ARG_EXPAND);
#define glCopyConvolutionFilter1DEXT_INDEX 373
#define glCopyConvolutionFilter1DEXT_RETURN void
#define glCopyConvolutionFilter1DEXT_ARG_NAMES target, internalformat, x, y, width
#define glCopyConvolutionFilter1DEXT_ARG_EXPAND GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width
#define glCopyConvolutionFilter1DEXT_PACKED PACKED_glCopyConvolutionFilter1DEXT
#define glCopyConvolutionFilter1DEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glCopyConvolutionFilter1DEXT_NOT_VOID_WRAP(...) {}
#define pack_glCopyConvolutionFilter1DEXT(_target, _internalformat, _x, _y, _width) ({ \
    glCopyConvolutionFilter1DEXT_PACKED *packed_data = malloc(sizeof(glCopyConvolutionFilter1DEXT_PACKED)); \
    packed_data->index = glCopyConvolutionFilter1DEXT_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.internalformat = (GLenum)_internalformat; \
    packed_data->args.x = (GLint)_x; \
    packed_data->args.y = (GLint)_y; \
    packed_data->args.width = (GLsizei)_width; \
    (packed_call_t *)packed_data; \
})
#define call_glCopyConvolutionFilter1DEXT(packed, ret_v) do { \
    PACKED_glCopyConvolutionFilter1DEXT *unpacked = (PACKED_glCopyConvolutionFilter1DEXT *)packed; \
    ARGS_glCopyConvolutionFilter1DEXT *args = (ARGS_glCopyConvolutionFilter1DEXT *)&unpacked->args; \
    glCopyConvolutionFilter1DEXT(args->target, args->internalformat, args->x, args->y, args->width);; \
} while(0)
void glCopyConvolutionFilter1DEXT(glCopyConvolutionFilter1DEXT_ARG_EXPAND);
typedef void (*glCopyConvolutionFilter1DEXT_PTR)(glCopyConvolutionFilter1DEXT_ARG_EXPAND);
#define glCopyConvolutionFilter2D_INDEX 374
#define glCopyConvolutionFilter2D_RETURN void
#define glCopyConvolutionFilter2D_ARG_NAMES target, internalformat, x, y, width, height
#define glCopyConvolutionFilter2D_ARG_EXPAND GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height
#define glCopyConvolutionFilter2D_PACKED PACKED_glCopyConvolutionFilter2D
#define glCopyConvolutionFilter2D_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glCopyConvolutionFilter2D_NOT_VOID_WRAP(...) {}
#define pack_glCopyConvolutionFilter2D(_target, _internalformat, _x, _y, _width, _height) ({ \
    glCopyConvolutionFilter2D_PACKED *packed_data = malloc(sizeof(glCopyConvolutionFilter2D_PACKED)); \
    packed_data->index = glCopyConvolutionFilter2D_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.internalformat = (GLenum)_internalformat; \
    packed_data->args.x = (GLint)_x; \
    packed_data->args.y = (GLint)_y; \
    packed_data->args.width = (GLsizei)_width; \
    packed_data->args.height = (GLsizei)_height; \
    (packed_call_t *)packed_data; \
})
#define call_glCopyConvolutionFilter2D(packed, ret_v) do { \
    PACKED_glCopyConvolutionFilter2D *unpacked = (PACKED_glCopyConvolutionFilter2D *)packed; \
    ARGS_glCopyConvolutionFilter2D *args = (ARGS_glCopyConvolutionFilter2D *)&unpacked->args; \
    glCopyConvolutionFilter2D(args->target, args->internalformat, args->x, args->y, args->width, args->height);; \
} while(0)
void glCopyConvolutionFilter2D(glCopyConvolutionFilter2D_ARG_EXPAND);
typedef void (*glCopyConvolutionFilter2D_PTR)(glCopyConvolutionFilter2D_ARG_EXPAND);
#define glCopyConvolutionFilter2DEXT_INDEX 375
#define glCopyConvolutionFilter2DEXT_RETURN void
#define glCopyConvolutionFilter2DEXT_ARG_NAMES target, internalformat, x, y, width, height
#define glCopyConvolutionFilter2DEXT_ARG_EXPAND GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height
#define glCopyConvolutionFilter2DEXT_PACKED PACKED_glCopyConvolutionFilter2DEXT
#define glCopyConvolutionFilter2DEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glCopyConvolutionFilter2DEXT_NOT_VOID_WRAP(...) {}
#define pack_glCopyConvolutionFilter2DEXT(_target, _internalformat, _x, _y, _width, _height) ({ \
    glCopyConvolutionFilter2DEXT_PACKED *packed_data = malloc(sizeof(glCopyConvolutionFilter2DEXT_PACKED)); \
    packed_data->index = glCopyConvolutionFilter2DEXT_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.internalformat = (GLenum)_internalformat; \
    packed_data->args.x = (GLint)_x; \
    packed_data->args.y = (GLint)_y; \
    packed_data->args.width = (GLsizei)_width; \
    packed_data->args.height = (GLsizei)_height; \
    (packed_call_t *)packed_data; \
})
#define call_glCopyConvolutionFilter2DEXT(packed, ret_v) do { \
    PACKED_glCopyConvolutionFilter2DEXT *unpacked = (PACKED_glCopyConvolutionFilter2DEXT *)packed; \
    ARGS_glCopyConvolutionFilter2DEXT *args = (ARGS_glCopyConvolutionFilter2DEXT *)&unpacked->args; \
    glCopyConvolutionFilter2DEXT(args->target, args->internalformat, args->x, args->y, args->width, args->height);; \
} while(0)
void glCopyConvolutionFilter2DEXT(glCopyConvolutionFilter2DEXT_ARG_EXPAND);
typedef void (*glCopyConvolutionFilter2DEXT_PTR)(glCopyConvolutionFilter2DEXT_ARG_EXPAND);
#define glCopyImageSubData_INDEX 376
#define glCopyImageSubData_RETURN void
#define glCopyImageSubData_ARG_NAMES srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth
#define glCopyImageSubData_ARG_EXPAND GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei srcWidth, GLsizei srcHeight, GLsizei srcDepth
#define glCopyImageSubData_PACKED PACKED_glCopyImageSubData
#define glCopyImageSubData_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glCopyImageSubData_NOT_VOID_WRAP(...) {}
#define pack_glCopyImageSubData(_srcName, _srcTarget, _srcLevel, _srcX, _srcY, _srcZ, _dstName, _dstTarget, _dstLevel, _dstX, _dstY, _dstZ, _srcWidth, _srcHeight, _srcDepth) ({ \
    glCopyImageSubData_PACKED *packed_data = malloc(sizeof(glCopyImageSubData_PACKED)); \
    packed_data->index = glCopyImageSubData_INDEX; \
    packed_data->args.srcName = (GLuint)_srcName; \
    packed_data->args.srcTarget = (GLenum)_srcTarget; \
    packed_data->args.srcLevel = (GLint)_srcLevel; \
    packed_data->args.srcX = (GLint)_srcX; \
    packed_data->args.srcY = (GLint)_srcY; \
    packed_data->args.srcZ = (GLint)_srcZ; \
    packed_data->args.dstName = (GLuint)_dstName; \
    packed_data->args.dstTarget = (GLenum)_dstTarget; \
    packed_data->args.dstLevel = (GLint)_dstLevel; \
    packed_data->args.dstX = (GLint)_dstX; \
    packed_data->args.dstY = (GLint)_dstY; \
    packed_data->args.dstZ = (GLint)_dstZ; \
    packed_data->args.srcWidth = (GLsizei)_srcWidth; \
    packed_data->args.srcHeight = (GLsizei)_srcHeight; \
    packed_data->args.srcDepth = (GLsizei)_srcDepth; \
    (packed_call_t *)packed_data; \
})
#define call_glCopyImageSubData(packed, ret_v) do { \
    PACKED_glCopyImageSubData *unpacked = (PACKED_glCopyImageSubData *)packed; \
    ARGS_glCopyImageSubData *args = (ARGS_glCopyImageSubData *)&unpacked->args; \
    glCopyImageSubData(args->srcName, args->srcTarget, args->srcLevel, args->srcX, args->srcY, args->srcZ, args->dstName, args->dstTarget, args->dstLevel, args->dstX, args->dstY, args->dstZ, args->srcWidth, args->srcHeight, args->srcDepth);; \
} while(0)
void glCopyImageSubData(glCopyImageSubData_ARG_EXPAND);
typedef void (*glCopyImageSubData_PTR)(glCopyImageSubData_ARG_EXPAND);
#define glCopyImageSubDataNV_INDEX 377
#define glCopyImageSubDataNV_RETURN void
#define glCopyImageSubDataNV_ARG_NAMES srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, width, height, depth
#define glCopyImageSubDataNV_ARG_EXPAND GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei width, GLsizei height, GLsizei depth
#define glCopyImageSubDataNV_PACKED PACKED_glCopyImageSubDataNV
#define glCopyImageSubDataNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glCopyImageSubDataNV_NOT_VOID_WRAP(...) {}
#define pack_glCopyImageSubDataNV(_srcName, _srcTarget, _srcLevel, _srcX, _srcY, _srcZ, _dstName, _dstTarget, _dstLevel, _dstX, _dstY, _dstZ, _width, _height, _depth) ({ \
    glCopyImageSubDataNV_PACKED *packed_data = malloc(sizeof(glCopyImageSubDataNV_PACKED)); \
    packed_data->index = glCopyImageSubDataNV_INDEX; \
    packed_data->args.srcName = (GLuint)_srcName; \
    packed_data->args.srcTarget = (GLenum)_srcTarget; \
    packed_data->args.srcLevel = (GLint)_srcLevel; \
    packed_data->args.srcX = (GLint)_srcX; \
    packed_data->args.srcY = (GLint)_srcY; \
    packed_data->args.srcZ = (GLint)_srcZ; \
    packed_data->args.dstName = (GLuint)_dstName; \
    packed_data->args.dstTarget = (GLenum)_dstTarget; \
    packed_data->args.dstLevel = (GLint)_dstLevel; \
    packed_data->args.dstX = (GLint)_dstX; \
    packed_data->args.dstY = (GLint)_dstY; \
    packed_data->args.dstZ = (GLint)_dstZ; \
    packed_data->args.width = (GLsizei)_width; \
    packed_data->args.height = (GLsizei)_height; \
    packed_data->args.depth = (GLsizei)_depth; \
    (packed_call_t *)packed_data; \
})
#define call_glCopyImageSubDataNV(packed, ret_v) do { \
    PACKED_glCopyImageSubDataNV *unpacked = (PACKED_glCopyImageSubDataNV *)packed; \
    ARGS_glCopyImageSubDataNV *args = (ARGS_glCopyImageSubDataNV *)&unpacked->args; \
    glCopyImageSubDataNV(args->srcName, args->srcTarget, args->srcLevel, args->srcX, args->srcY, args->srcZ, args->dstName, args->dstTarget, args->dstLevel, args->dstX, args->dstY, args->dstZ, args->width, args->height, args->depth);; \
} while(0)
void glCopyImageSubDataNV(glCopyImageSubDataNV_ARG_EXPAND);
typedef void (*glCopyImageSubDataNV_PTR)(glCopyImageSubDataNV_ARG_EXPAND);
#define glCopyMultiTexImage1DEXT_INDEX 378
#define glCopyMultiTexImage1DEXT_RETURN void
#define glCopyMultiTexImage1DEXT_ARG_NAMES texunit, target, level, internalformat, x, y, width, border
#define glCopyMultiTexImage1DEXT_ARG_EXPAND GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border
#define glCopyMultiTexImage1DEXT_PACKED PACKED_glCopyMultiTexImage1DEXT
#define glCopyMultiTexImage1DEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glCopyMultiTexImage1DEXT_NOT_VOID_WRAP(...) {}
#define pack_glCopyMultiTexImage1DEXT(_texunit, _target, _level, _internalformat, _x, _y, _width, _border) ({ \
    glCopyMultiTexImage1DEXT_PACKED *packed_data = malloc(sizeof(glCopyMultiTexImage1DEXT_PACKED)); \
    packed_data->index = glCopyMultiTexImage1DEXT_INDEX; \
    packed_data->args.texunit = (GLenum)_texunit; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.level = (GLint)_level; \
    packed_data->args.internalformat = (GLenum)_internalformat; \
    packed_data->args.x = (GLint)_x; \
    packed_data->args.y = (GLint)_y; \
    packed_data->args.width = (GLsizei)_width; \
    packed_data->args.border = (GLint)_border; \
    (packed_call_t *)packed_data; \
})
#define call_glCopyMultiTexImage1DEXT(packed, ret_v) do { \
    PACKED_glCopyMultiTexImage1DEXT *unpacked = (PACKED_glCopyMultiTexImage1DEXT *)packed; \
    ARGS_glCopyMultiTexImage1DEXT *args = (ARGS_glCopyMultiTexImage1DEXT *)&unpacked->args; \
    glCopyMultiTexImage1DEXT(args->texunit, args->target, args->level, args->internalformat, args->x, args->y, args->width, args->border);; \
} while(0)
void glCopyMultiTexImage1DEXT(glCopyMultiTexImage1DEXT_ARG_EXPAND);
typedef void (*glCopyMultiTexImage1DEXT_PTR)(glCopyMultiTexImage1DEXT_ARG_EXPAND);
#define glCopyMultiTexImage2DEXT_INDEX 379
#define glCopyMultiTexImage2DEXT_RETURN void
#define glCopyMultiTexImage2DEXT_ARG_NAMES texunit, target, level, internalformat, x, y, width, height, border
#define glCopyMultiTexImage2DEXT_ARG_EXPAND GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border
#define glCopyMultiTexImage2DEXT_PACKED PACKED_glCopyMultiTexImage2DEXT
#define glCopyMultiTexImage2DEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glCopyMultiTexImage2DEXT_NOT_VOID_WRAP(...) {}
#define pack_glCopyMultiTexImage2DEXT(_texunit, _target, _level, _internalformat, _x, _y, _width, _height, _border) ({ \
    glCopyMultiTexImage2DEXT_PACKED *packed_data = malloc(sizeof(glCopyMultiTexImage2DEXT_PACKED)); \
    packed_data->index = glCopyMultiTexImage2DEXT_INDEX; \
    packed_data->args.texunit = (GLenum)_texunit; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.level = (GLint)_level; \
    packed_data->args.internalformat = (GLenum)_internalformat; \
    packed_data->args.x = (GLint)_x; \
    packed_data->args.y = (GLint)_y; \
    packed_data->args.width = (GLsizei)_width; \
    packed_data->args.height = (GLsizei)_height; \
    packed_data->args.border = (GLint)_border; \
    (packed_call_t *)packed_data; \
})
#define call_glCopyMultiTexImage2DEXT(packed, ret_v) do { \
    PACKED_glCopyMultiTexImage2DEXT *unpacked = (PACKED_glCopyMultiTexImage2DEXT *)packed; \
    ARGS_glCopyMultiTexImage2DEXT *args = (ARGS_glCopyMultiTexImage2DEXT *)&unpacked->args; \
    glCopyMultiTexImage2DEXT(args->texunit, args->target, args->level, args->internalformat, args->x, args->y, args->width, args->height, args->border);; \
} while(0)
void glCopyMultiTexImage2DEXT(glCopyMultiTexImage2DEXT_ARG_EXPAND);
typedef void (*glCopyMultiTexImage2DEXT_PTR)(glCopyMultiTexImage2DEXT_ARG_EXPAND);
#define glCopyMultiTexSubImage1DEXT_INDEX 380
#define glCopyMultiTexSubImage1DEXT_RETURN void
#define glCopyMultiTexSubImage1DEXT_ARG_NAMES texunit, target, level, xoffset, x, y, width
#define glCopyMultiTexSubImage1DEXT_ARG_EXPAND GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width
#define glCopyMultiTexSubImage1DEXT_PACKED PACKED_glCopyMultiTexSubImage1DEXT
#define glCopyMultiTexSubImage1DEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glCopyMultiTexSubImage1DEXT_NOT_VOID_WRAP(...) {}
#define pack_glCopyMultiTexSubImage1DEXT(_texunit, _target, _level, _xoffset, _x, _y, _width) ({ \
    glCopyMultiTexSubImage1DEXT_PACKED *packed_data = malloc(sizeof(glCopyMultiTexSubImage1DEXT_PACKED)); \
    packed_data->index = glCopyMultiTexSubImage1DEXT_INDEX; \
    packed_data->args.texunit = (GLenum)_texunit; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.level = (GLint)_level; \
    packed_data->args.xoffset = (GLint)_xoffset; \
    packed_data->args.x = (GLint)_x; \
    packed_data->args.y = (GLint)_y; \
    packed_data->args.width = (GLsizei)_width; \
    (packed_call_t *)packed_data; \
})
#define call_glCopyMultiTexSubImage1DEXT(packed, ret_v) do { \
    PACKED_glCopyMultiTexSubImage1DEXT *unpacked = (PACKED_glCopyMultiTexSubImage1DEXT *)packed; \
    ARGS_glCopyMultiTexSubImage1DEXT *args = (ARGS_glCopyMultiTexSubImage1DEXT *)&unpacked->args; \
    glCopyMultiTexSubImage1DEXT(args->texunit, args->target, args->level, args->xoffset, args->x, args->y, args->width);; \
} while(0)
void glCopyMultiTexSubImage1DEXT(glCopyMultiTexSubImage1DEXT_ARG_EXPAND);
typedef void (*glCopyMultiTexSubImage1DEXT_PTR)(glCopyMultiTexSubImage1DEXT_ARG_EXPAND);
#define glCopyMultiTexSubImage2DEXT_INDEX 381
#define glCopyMultiTexSubImage2DEXT_RETURN void
#define glCopyMultiTexSubImage2DEXT_ARG_NAMES texunit, target, level, xoffset, yoffset, x, y, width, height
#define glCopyMultiTexSubImage2DEXT_ARG_EXPAND GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height
#define glCopyMultiTexSubImage2DEXT_PACKED PACKED_glCopyMultiTexSubImage2DEXT
#define glCopyMultiTexSubImage2DEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glCopyMultiTexSubImage2DEXT_NOT_VOID_WRAP(...) {}
#define pack_glCopyMultiTexSubImage2DEXT(_texunit, _target, _level, _xoffset, _yoffset, _x, _y, _width, _height) ({ \
    glCopyMultiTexSubImage2DEXT_PACKED *packed_data = malloc(sizeof(glCopyMultiTexSubImage2DEXT_PACKED)); \
    packed_data->index = glCopyMultiTexSubImage2DEXT_INDEX; \
    packed_data->args.texunit = (GLenum)_texunit; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.level = (GLint)_level; \
    packed_data->args.xoffset = (GLint)_xoffset; \
    packed_data->args.yoffset = (GLint)_yoffset; \
    packed_data->args.x = (GLint)_x; \
    packed_data->args.y = (GLint)_y; \
    packed_data->args.width = (GLsizei)_width; \
    packed_data->args.height = (GLsizei)_height; \
    (packed_call_t *)packed_data; \
})
#define call_glCopyMultiTexSubImage2DEXT(packed, ret_v) do { \
    PACKED_glCopyMultiTexSubImage2DEXT *unpacked = (PACKED_glCopyMultiTexSubImage2DEXT *)packed; \
    ARGS_glCopyMultiTexSubImage2DEXT *args = (ARGS_glCopyMultiTexSubImage2DEXT *)&unpacked->args; \
    glCopyMultiTexSubImage2DEXT(args->texunit, args->target, args->level, args->xoffset, args->yoffset, args->x, args->y, args->width, args->height);; \
} while(0)
void glCopyMultiTexSubImage2DEXT(glCopyMultiTexSubImage2DEXT_ARG_EXPAND);
typedef void (*glCopyMultiTexSubImage2DEXT_PTR)(glCopyMultiTexSubImage2DEXT_ARG_EXPAND);
#define glCopyMultiTexSubImage3DEXT_INDEX 382
#define glCopyMultiTexSubImage3DEXT_RETURN void
#define glCopyMultiTexSubImage3DEXT_ARG_NAMES texunit, target, level, xoffset, yoffset, zoffset, x, y, width, height
#define glCopyMultiTexSubImage3DEXT_ARG_EXPAND GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height
#define glCopyMultiTexSubImage3DEXT_PACKED PACKED_glCopyMultiTexSubImage3DEXT
#define glCopyMultiTexSubImage3DEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glCopyMultiTexSubImage3DEXT_NOT_VOID_WRAP(...) {}
#define pack_glCopyMultiTexSubImage3DEXT(_texunit, _target, _level, _xoffset, _yoffset, _zoffset, _x, _y, _width, _height) ({ \
    glCopyMultiTexSubImage3DEXT_PACKED *packed_data = malloc(sizeof(glCopyMultiTexSubImage3DEXT_PACKED)); \
    packed_data->index = glCopyMultiTexSubImage3DEXT_INDEX; \
    packed_data->args.texunit = (GLenum)_texunit; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.level = (GLint)_level; \
    packed_data->args.xoffset = (GLint)_xoffset; \
    packed_data->args.yoffset = (GLint)_yoffset; \
    packed_data->args.zoffset = (GLint)_zoffset; \
    packed_data->args.x = (GLint)_x; \
    packed_data->args.y = (GLint)_y; \
    packed_data->args.width = (GLsizei)_width; \
    packed_data->args.height = (GLsizei)_height; \
    (packed_call_t *)packed_data; \
})
#define call_glCopyMultiTexSubImage3DEXT(packed, ret_v) do { \
    PACKED_glCopyMultiTexSubImage3DEXT *unpacked = (PACKED_glCopyMultiTexSubImage3DEXT *)packed; \
    ARGS_glCopyMultiTexSubImage3DEXT *args = (ARGS_glCopyMultiTexSubImage3DEXT *)&unpacked->args; \
    glCopyMultiTexSubImage3DEXT(args->texunit, args->target, args->level, args->xoffset, args->yoffset, args->zoffset, args->x, args->y, args->width, args->height);; \
} while(0)
void glCopyMultiTexSubImage3DEXT(glCopyMultiTexSubImage3DEXT_ARG_EXPAND);
typedef void (*glCopyMultiTexSubImage3DEXT_PTR)(glCopyMultiTexSubImage3DEXT_ARG_EXPAND);
#define glCopyPathNV_INDEX 383
#define glCopyPathNV_RETURN void
#define glCopyPathNV_ARG_NAMES resultPath, srcPath
#define glCopyPathNV_ARG_EXPAND GLuint resultPath, GLuint srcPath
#define glCopyPathNV_PACKED PACKED_glCopyPathNV
#define glCopyPathNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glCopyPathNV_NOT_VOID_WRAP(...) {}
#define pack_glCopyPathNV(_resultPath, _srcPath) ({ \
    glCopyPathNV_PACKED *packed_data = malloc(sizeof(glCopyPathNV_PACKED)); \
    packed_data->index = glCopyPathNV_INDEX; \
    packed_data->args.resultPath = (GLuint)_resultPath; \
    packed_data->args.srcPath = (GLuint)_srcPath; \
    (packed_call_t *)packed_data; \
})
#define call_glCopyPathNV(packed, ret_v) do { \
    PACKED_glCopyPathNV *unpacked = (PACKED_glCopyPathNV *)packed; \
    ARGS_glCopyPathNV *args = (ARGS_glCopyPathNV *)&unpacked->args; \
    glCopyPathNV(args->resultPath, args->srcPath);; \
} while(0)
void glCopyPathNV(glCopyPathNV_ARG_EXPAND);
typedef void (*glCopyPathNV_PTR)(glCopyPathNV_ARG_EXPAND);
#define glCopyPixels_INDEX 384
#define glCopyPixels_RETURN void
#define glCopyPixels_ARG_NAMES x, y, width, height, type
#define glCopyPixels_ARG_EXPAND GLint x, GLint y, GLsizei width, GLsizei height, GLenum type
#define glCopyPixels_PACKED PACKED_glCopyPixels
#define glCopyPixels_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glCopyPixels_NOT_VOID_WRAP(...) {}
#define pack_glCopyPixels(_x, _y, _width, _height, _type) ({ \
    glCopyPixels_PACKED *packed_data = malloc(sizeof(glCopyPixels_PACKED)); \
    packed_data->index = glCopyPixels_INDEX; \
    packed_data->args.x = (GLint)_x; \
    packed_data->args.y = (GLint)_y; \
    packed_data->args.width = (GLsizei)_width; \
    packed_data->args.height = (GLsizei)_height; \
    packed_data->args.type = (GLenum)_type; \
    (packed_call_t *)packed_data; \
})
#define call_glCopyPixels(packed, ret_v) do { \
    PACKED_glCopyPixels *unpacked = (PACKED_glCopyPixels *)packed; \
    ARGS_glCopyPixels *args = (ARGS_glCopyPixels *)&unpacked->args; \
    glCopyPixels(args->x, args->y, args->width, args->height, args->type);; \
} while(0)
void glCopyPixels(glCopyPixels_ARG_EXPAND);
typedef void (*glCopyPixels_PTR)(glCopyPixels_ARG_EXPAND);
#define glCopyTexImage1D_INDEX 385
#define glCopyTexImage1D_RETURN void
#define glCopyTexImage1D_ARG_NAMES target, level, internalformat, x, y, width, border
#define glCopyTexImage1D_ARG_EXPAND GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border
#define glCopyTexImage1D_PACKED PACKED_glCopyTexImage1D
#define glCopyTexImage1D_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glCopyTexImage1D_NOT_VOID_WRAP(...) {}
#define pack_glCopyTexImage1D(_target, _level, _internalformat, _x, _y, _width, _border) ({ \
    glCopyTexImage1D_PACKED *packed_data = malloc(sizeof(glCopyTexImage1D_PACKED)); \
    packed_data->index = glCopyTexImage1D_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.level = (GLint)_level; \
    packed_data->args.internalformat = (GLenum)_internalformat; \
    packed_data->args.x = (GLint)_x; \
    packed_data->args.y = (GLint)_y; \
    packed_data->args.width = (GLsizei)_width; \
    packed_data->args.border = (GLint)_border; \
    (packed_call_t *)packed_data; \
})
#define call_glCopyTexImage1D(packed, ret_v) do { \
    PACKED_glCopyTexImage1D *unpacked = (PACKED_glCopyTexImage1D *)packed; \
    ARGS_glCopyTexImage1D *args = (ARGS_glCopyTexImage1D *)&unpacked->args; \
    glCopyTexImage1D(args->target, args->level, args->internalformat, args->x, args->y, args->width, args->border);; \
} while(0)
void glCopyTexImage1D(glCopyTexImage1D_ARG_EXPAND);
typedef void (*glCopyTexImage1D_PTR)(glCopyTexImage1D_ARG_EXPAND);
#define glCopyTexImage1DEXT_INDEX 386
#define glCopyTexImage1DEXT_RETURN void
#define glCopyTexImage1DEXT_ARG_NAMES target, level, internalformat, x, y, width, border
#define glCopyTexImage1DEXT_ARG_EXPAND GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border
#define glCopyTexImage1DEXT_PACKED PACKED_glCopyTexImage1DEXT
#define glCopyTexImage1DEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glCopyTexImage1DEXT_NOT_VOID_WRAP(...) {}
#define pack_glCopyTexImage1DEXT(_target, _level, _internalformat, _x, _y, _width, _border) ({ \
    glCopyTexImage1DEXT_PACKED *packed_data = malloc(sizeof(glCopyTexImage1DEXT_PACKED)); \
    packed_data->index = glCopyTexImage1DEXT_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.level = (GLint)_level; \
    packed_data->args.internalformat = (GLenum)_internalformat; \
    packed_data->args.x = (GLint)_x; \
    packed_data->args.y = (GLint)_y; \
    packed_data->args.width = (GLsizei)_width; \
    packed_data->args.border = (GLint)_border; \
    (packed_call_t *)packed_data; \
})
#define call_glCopyTexImage1DEXT(packed, ret_v) do { \
    PACKED_glCopyTexImage1DEXT *unpacked = (PACKED_glCopyTexImage1DEXT *)packed; \
    ARGS_glCopyTexImage1DEXT *args = (ARGS_glCopyTexImage1DEXT *)&unpacked->args; \
    glCopyTexImage1DEXT(args->target, args->level, args->internalformat, args->x, args->y, args->width, args->border);; \
} while(0)
void glCopyTexImage1DEXT(glCopyTexImage1DEXT_ARG_EXPAND);
typedef void (*glCopyTexImage1DEXT_PTR)(glCopyTexImage1DEXT_ARG_EXPAND);
#define glCopyTexImage2D_INDEX 387
#define glCopyTexImage2D_RETURN void
#define glCopyTexImage2D_ARG_NAMES target, level, internalformat, x, y, width, height, border
#define glCopyTexImage2D_ARG_EXPAND GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border
#define glCopyTexImage2D_PACKED PACKED_glCopyTexImage2D
#define glCopyTexImage2D_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glCopyTexImage2D_NOT_VOID_WRAP(...) {}
#define pack_glCopyTexImage2D(_target, _level, _internalformat, _x, _y, _width, _height, _border) ({ \
    glCopyTexImage2D_PACKED *packed_data = malloc(sizeof(glCopyTexImage2D_PACKED)); \
    packed_data->index = glCopyTexImage2D_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.level = (GLint)_level; \
    packed_data->args.internalformat = (GLenum)_internalformat; \
    packed_data->args.x = (GLint)_x; \
    packed_data->args.y = (GLint)_y; \
    packed_data->args.width = (GLsizei)_width; \
    packed_data->args.height = (GLsizei)_height; \
    packed_data->args.border = (GLint)_border; \
    (packed_call_t *)packed_data; \
})
#define call_glCopyTexImage2D(packed, ret_v) do { \
    PACKED_glCopyTexImage2D *unpacked = (PACKED_glCopyTexImage2D *)packed; \
    ARGS_glCopyTexImage2D *args = (ARGS_glCopyTexImage2D *)&unpacked->args; \
    glCopyTexImage2D(args->target, args->level, args->internalformat, args->x, args->y, args->width, args->height, args->border);; \
} while(0)
void glCopyTexImage2D(glCopyTexImage2D_ARG_EXPAND);
typedef void (*glCopyTexImage2D_PTR)(glCopyTexImage2D_ARG_EXPAND);
#define glCopyTexImage2DEXT_INDEX 388
#define glCopyTexImage2DEXT_RETURN void
#define glCopyTexImage2DEXT_ARG_NAMES target, level, internalformat, x, y, width, height, border
#define glCopyTexImage2DEXT_ARG_EXPAND GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border
#define glCopyTexImage2DEXT_PACKED PACKED_glCopyTexImage2DEXT
#define glCopyTexImage2DEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glCopyTexImage2DEXT_NOT_VOID_WRAP(...) {}
#define pack_glCopyTexImage2DEXT(_target, _level, _internalformat, _x, _y, _width, _height, _border) ({ \
    glCopyTexImage2DEXT_PACKED *packed_data = malloc(sizeof(glCopyTexImage2DEXT_PACKED)); \
    packed_data->index = glCopyTexImage2DEXT_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.level = (GLint)_level; \
    packed_data->args.internalformat = (GLenum)_internalformat; \
    packed_data->args.x = (GLint)_x; \
    packed_data->args.y = (GLint)_y; \
    packed_data->args.width = (GLsizei)_width; \
    packed_data->args.height = (GLsizei)_height; \
    packed_data->args.border = (GLint)_border; \
    (packed_call_t *)packed_data; \
})
#define call_glCopyTexImage2DEXT(packed, ret_v) do { \
    PACKED_glCopyTexImage2DEXT *unpacked = (PACKED_glCopyTexImage2DEXT *)packed; \
    ARGS_glCopyTexImage2DEXT *args = (ARGS_glCopyTexImage2DEXT *)&unpacked->args; \
    glCopyTexImage2DEXT(args->target, args->level, args->internalformat, args->x, args->y, args->width, args->height, args->border);; \
} while(0)
void glCopyTexImage2DEXT(glCopyTexImage2DEXT_ARG_EXPAND);
typedef void (*glCopyTexImage2DEXT_PTR)(glCopyTexImage2DEXT_ARG_EXPAND);
#define glCopyTexSubImage1D_INDEX 389
#define glCopyTexSubImage1D_RETURN void
#define glCopyTexSubImage1D_ARG_NAMES target, level, xoffset, x, y, width
#define glCopyTexSubImage1D_ARG_EXPAND GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width
#define glCopyTexSubImage1D_PACKED PACKED_glCopyTexSubImage1D
#define glCopyTexSubImage1D_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glCopyTexSubImage1D_NOT_VOID_WRAP(...) {}
#define pack_glCopyTexSubImage1D(_target, _level, _xoffset, _x, _y, _width) ({ \
    glCopyTexSubImage1D_PACKED *packed_data = malloc(sizeof(glCopyTexSubImage1D_PACKED)); \
    packed_data->index = glCopyTexSubImage1D_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.level = (GLint)_level; \
    packed_data->args.xoffset = (GLint)_xoffset; \
    packed_data->args.x = (GLint)_x; \
    packed_data->args.y = (GLint)_y; \
    packed_data->args.width = (GLsizei)_width; \
    (packed_call_t *)packed_data; \
})
#define call_glCopyTexSubImage1D(packed, ret_v) do { \
    PACKED_glCopyTexSubImage1D *unpacked = (PACKED_glCopyTexSubImage1D *)packed; \
    ARGS_glCopyTexSubImage1D *args = (ARGS_glCopyTexSubImage1D *)&unpacked->args; \
    glCopyTexSubImage1D(args->target, args->level, args->xoffset, args->x, args->y, args->width);; \
} while(0)
void glCopyTexSubImage1D(glCopyTexSubImage1D_ARG_EXPAND);
typedef void (*glCopyTexSubImage1D_PTR)(glCopyTexSubImage1D_ARG_EXPAND);
#define glCopyTexSubImage1DEXT_INDEX 390
#define glCopyTexSubImage1DEXT_RETURN void
#define glCopyTexSubImage1DEXT_ARG_NAMES target, level, xoffset, x, y, width
#define glCopyTexSubImage1DEXT_ARG_EXPAND GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width
#define glCopyTexSubImage1DEXT_PACKED PACKED_glCopyTexSubImage1DEXT
#define glCopyTexSubImage1DEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glCopyTexSubImage1DEXT_NOT_VOID_WRAP(...) {}
#define pack_glCopyTexSubImage1DEXT(_target, _level, _xoffset, _x, _y, _width) ({ \
    glCopyTexSubImage1DEXT_PACKED *packed_data = malloc(sizeof(glCopyTexSubImage1DEXT_PACKED)); \
    packed_data->index = glCopyTexSubImage1DEXT_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.level = (GLint)_level; \
    packed_data->args.xoffset = (GLint)_xoffset; \
    packed_data->args.x = (GLint)_x; \
    packed_data->args.y = (GLint)_y; \
    packed_data->args.width = (GLsizei)_width; \
    (packed_call_t *)packed_data; \
})
#define call_glCopyTexSubImage1DEXT(packed, ret_v) do { \
    PACKED_glCopyTexSubImage1DEXT *unpacked = (PACKED_glCopyTexSubImage1DEXT *)packed; \
    ARGS_glCopyTexSubImage1DEXT *args = (ARGS_glCopyTexSubImage1DEXT *)&unpacked->args; \
    glCopyTexSubImage1DEXT(args->target, args->level, args->xoffset, args->x, args->y, args->width);; \
} while(0)
void glCopyTexSubImage1DEXT(glCopyTexSubImage1DEXT_ARG_EXPAND);
typedef void (*glCopyTexSubImage1DEXT_PTR)(glCopyTexSubImage1DEXT_ARG_EXPAND);
#define glCopyTexSubImage2D_INDEX 391
#define glCopyTexSubImage2D_RETURN void
#define glCopyTexSubImage2D_ARG_NAMES target, level, xoffset, yoffset, x, y, width, height
#define glCopyTexSubImage2D_ARG_EXPAND GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height
#define glCopyTexSubImage2D_PACKED PACKED_glCopyTexSubImage2D
#define glCopyTexSubImage2D_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glCopyTexSubImage2D_NOT_VOID_WRAP(...) {}
#define pack_glCopyTexSubImage2D(_target, _level, _xoffset, _yoffset, _x, _y, _width, _height) ({ \
    glCopyTexSubImage2D_PACKED *packed_data = malloc(sizeof(glCopyTexSubImage2D_PACKED)); \
    packed_data->index = glCopyTexSubImage2D_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.level = (GLint)_level; \
    packed_data->args.xoffset = (GLint)_xoffset; \
    packed_data->args.yoffset = (GLint)_yoffset; \
    packed_data->args.x = (GLint)_x; \
    packed_data->args.y = (GLint)_y; \
    packed_data->args.width = (GLsizei)_width; \
    packed_data->args.height = (GLsizei)_height; \
    (packed_call_t *)packed_data; \
})
#define call_glCopyTexSubImage2D(packed, ret_v) do { \
    PACKED_glCopyTexSubImage2D *unpacked = (PACKED_glCopyTexSubImage2D *)packed; \
    ARGS_glCopyTexSubImage2D *args = (ARGS_glCopyTexSubImage2D *)&unpacked->args; \
    glCopyTexSubImage2D(args->target, args->level, args->xoffset, args->yoffset, args->x, args->y, args->width, args->height);; \
} while(0)
void glCopyTexSubImage2D(glCopyTexSubImage2D_ARG_EXPAND);
typedef void (*glCopyTexSubImage2D_PTR)(glCopyTexSubImage2D_ARG_EXPAND);
#define glCopyTexSubImage2DEXT_INDEX 392
#define glCopyTexSubImage2DEXT_RETURN void
#define glCopyTexSubImage2DEXT_ARG_NAMES target, level, xoffset, yoffset, x, y, width, height
#define glCopyTexSubImage2DEXT_ARG_EXPAND GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height
#define glCopyTexSubImage2DEXT_PACKED PACKED_glCopyTexSubImage2DEXT
#define glCopyTexSubImage2DEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glCopyTexSubImage2DEXT_NOT_VOID_WRAP(...) {}
#define pack_glCopyTexSubImage2DEXT(_target, _level, _xoffset, _yoffset, _x, _y, _width, _height) ({ \
    glCopyTexSubImage2DEXT_PACKED *packed_data = malloc(sizeof(glCopyTexSubImage2DEXT_PACKED)); \
    packed_data->index = glCopyTexSubImage2DEXT_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.level = (GLint)_level; \
    packed_data->args.xoffset = (GLint)_xoffset; \
    packed_data->args.yoffset = (GLint)_yoffset; \
    packed_data->args.x = (GLint)_x; \
    packed_data->args.y = (GLint)_y; \
    packed_data->args.width = (GLsizei)_width; \
    packed_data->args.height = (GLsizei)_height; \
    (packed_call_t *)packed_data; \
})
#define call_glCopyTexSubImage2DEXT(packed, ret_v) do { \
    PACKED_glCopyTexSubImage2DEXT *unpacked = (PACKED_glCopyTexSubImage2DEXT *)packed; \
    ARGS_glCopyTexSubImage2DEXT *args = (ARGS_glCopyTexSubImage2DEXT *)&unpacked->args; \
    glCopyTexSubImage2DEXT(args->target, args->level, args->xoffset, args->yoffset, args->x, args->y, args->width, args->height);; \
} while(0)
void glCopyTexSubImage2DEXT(glCopyTexSubImage2DEXT_ARG_EXPAND);
typedef void (*glCopyTexSubImage2DEXT_PTR)(glCopyTexSubImage2DEXT_ARG_EXPAND);
#define glCopyTexSubImage3D_INDEX 393
#define glCopyTexSubImage3D_RETURN void
#define glCopyTexSubImage3D_ARG_NAMES target, level, xoffset, yoffset, zoffset, x, y, width, height
#define glCopyTexSubImage3D_ARG_EXPAND GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height
#define glCopyTexSubImage3D_PACKED PACKED_glCopyTexSubImage3D
#define glCopyTexSubImage3D_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glCopyTexSubImage3D_NOT_VOID_WRAP(...) {}
#define pack_glCopyTexSubImage3D(_target, _level, _xoffset, _yoffset, _zoffset, _x, _y, _width, _height) ({ \
    glCopyTexSubImage3D_PACKED *packed_data = malloc(sizeof(glCopyTexSubImage3D_PACKED)); \
    packed_data->index = glCopyTexSubImage3D_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.level = (GLint)_level; \
    packed_data->args.xoffset = (GLint)_xoffset; \
    packed_data->args.yoffset = (GLint)_yoffset; \
    packed_data->args.zoffset = (GLint)_zoffset; \
    packed_data->args.x = (GLint)_x; \
    packed_data->args.y = (GLint)_y; \
    packed_data->args.width = (GLsizei)_width; \
    packed_data->args.height = (GLsizei)_height; \
    (packed_call_t *)packed_data; \
})
#define call_glCopyTexSubImage3D(packed, ret_v) do { \
    PACKED_glCopyTexSubImage3D *unpacked = (PACKED_glCopyTexSubImage3D *)packed; \
    ARGS_glCopyTexSubImage3D *args = (ARGS_glCopyTexSubImage3D *)&unpacked->args; \
    glCopyTexSubImage3D(args->target, args->level, args->xoffset, args->yoffset, args->zoffset, args->x, args->y, args->width, args->height);; \
} while(0)
void glCopyTexSubImage3D(glCopyTexSubImage3D_ARG_EXPAND);
typedef void (*glCopyTexSubImage3D_PTR)(glCopyTexSubImage3D_ARG_EXPAND);
#define glCopyTexSubImage3DEXT_INDEX 394
#define glCopyTexSubImage3DEXT_RETURN void
#define glCopyTexSubImage3DEXT_ARG_NAMES target, level, xoffset, yoffset, zoffset, x, y, width, height
#define glCopyTexSubImage3DEXT_ARG_EXPAND GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height
#define glCopyTexSubImage3DEXT_PACKED PACKED_glCopyTexSubImage3DEXT
#define glCopyTexSubImage3DEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glCopyTexSubImage3DEXT_NOT_VOID_WRAP(...) {}
#define pack_glCopyTexSubImage3DEXT(_target, _level, _xoffset, _yoffset, _zoffset, _x, _y, _width, _height) ({ \
    glCopyTexSubImage3DEXT_PACKED *packed_data = malloc(sizeof(glCopyTexSubImage3DEXT_PACKED)); \
    packed_data->index = glCopyTexSubImage3DEXT_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.level = (GLint)_level; \
    packed_data->args.xoffset = (GLint)_xoffset; \
    packed_data->args.yoffset = (GLint)_yoffset; \
    packed_data->args.zoffset = (GLint)_zoffset; \
    packed_data->args.x = (GLint)_x; \
    packed_data->args.y = (GLint)_y; \
    packed_data->args.width = (GLsizei)_width; \
    packed_data->args.height = (GLsizei)_height; \
    (packed_call_t *)packed_data; \
})
#define call_glCopyTexSubImage3DEXT(packed, ret_v) do { \
    PACKED_glCopyTexSubImage3DEXT *unpacked = (PACKED_glCopyTexSubImage3DEXT *)packed; \
    ARGS_glCopyTexSubImage3DEXT *args = (ARGS_glCopyTexSubImage3DEXT *)&unpacked->args; \
    glCopyTexSubImage3DEXT(args->target, args->level, args->xoffset, args->yoffset, args->zoffset, args->x, args->y, args->width, args->height);; \
} while(0)
void glCopyTexSubImage3DEXT(glCopyTexSubImage3DEXT_ARG_EXPAND);
typedef void (*glCopyTexSubImage3DEXT_PTR)(glCopyTexSubImage3DEXT_ARG_EXPAND);
#define glCopyTextureImage1DEXT_INDEX 395
#define glCopyTextureImage1DEXT_RETURN void
#define glCopyTextureImage1DEXT_ARG_NAMES texture, target, level, internalformat, x, y, width, border
#define glCopyTextureImage1DEXT_ARG_EXPAND GLuint texture, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border
#define glCopyTextureImage1DEXT_PACKED PACKED_glCopyTextureImage1DEXT
#define glCopyTextureImage1DEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glCopyTextureImage1DEXT_NOT_VOID_WRAP(...) {}
#define pack_glCopyTextureImage1DEXT(_texture, _target, _level, _internalformat, _x, _y, _width, _border) ({ \
    glCopyTextureImage1DEXT_PACKED *packed_data = malloc(sizeof(glCopyTextureImage1DEXT_PACKED)); \
    packed_data->index = glCopyTextureImage1DEXT_INDEX; \
    packed_data->args.texture = (GLuint)_texture; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.level = (GLint)_level; \
    packed_data->args.internalformat = (GLenum)_internalformat; \
    packed_data->args.x = (GLint)_x; \
    packed_data->args.y = (GLint)_y; \
    packed_data->args.width = (GLsizei)_width; \
    packed_data->args.border = (GLint)_border; \
    (packed_call_t *)packed_data; \
})
#define call_glCopyTextureImage1DEXT(packed, ret_v) do { \
    PACKED_glCopyTextureImage1DEXT *unpacked = (PACKED_glCopyTextureImage1DEXT *)packed; \
    ARGS_glCopyTextureImage1DEXT *args = (ARGS_glCopyTextureImage1DEXT *)&unpacked->args; \
    glCopyTextureImage1DEXT(args->texture, args->target, args->level, args->internalformat, args->x, args->y, args->width, args->border);; \
} while(0)
void glCopyTextureImage1DEXT(glCopyTextureImage1DEXT_ARG_EXPAND);
typedef void (*glCopyTextureImage1DEXT_PTR)(glCopyTextureImage1DEXT_ARG_EXPAND);
#define glCopyTextureImage2DEXT_INDEX 396
#define glCopyTextureImage2DEXT_RETURN void
#define glCopyTextureImage2DEXT_ARG_NAMES texture, target, level, internalformat, x, y, width, height, border
#define glCopyTextureImage2DEXT_ARG_EXPAND GLuint texture, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border
#define glCopyTextureImage2DEXT_PACKED PACKED_glCopyTextureImage2DEXT
#define glCopyTextureImage2DEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glCopyTextureImage2DEXT_NOT_VOID_WRAP(...) {}
#define pack_glCopyTextureImage2DEXT(_texture, _target, _level, _internalformat, _x, _y, _width, _height, _border) ({ \
    glCopyTextureImage2DEXT_PACKED *packed_data = malloc(sizeof(glCopyTextureImage2DEXT_PACKED)); \
    packed_data->index = glCopyTextureImage2DEXT_INDEX; \
    packed_data->args.texture = (GLuint)_texture; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.level = (GLint)_level; \
    packed_data->args.internalformat = (GLenum)_internalformat; \
    packed_data->args.x = (GLint)_x; \
    packed_data->args.y = (GLint)_y; \
    packed_data->args.width = (GLsizei)_width; \
    packed_data->args.height = (GLsizei)_height; \
    packed_data->args.border = (GLint)_border; \
    (packed_call_t *)packed_data; \
})
#define call_glCopyTextureImage2DEXT(packed, ret_v) do { \
    PACKED_glCopyTextureImage2DEXT *unpacked = (PACKED_glCopyTextureImage2DEXT *)packed; \
    ARGS_glCopyTextureImage2DEXT *args = (ARGS_glCopyTextureImage2DEXT *)&unpacked->args; \
    glCopyTextureImage2DEXT(args->texture, args->target, args->level, args->internalformat, args->x, args->y, args->width, args->height, args->border);; \
} while(0)
void glCopyTextureImage2DEXT(glCopyTextureImage2DEXT_ARG_EXPAND);
typedef void (*glCopyTextureImage2DEXT_PTR)(glCopyTextureImage2DEXT_ARG_EXPAND);
#define glCopyTextureSubImage1DEXT_INDEX 397
#define glCopyTextureSubImage1DEXT_RETURN void
#define glCopyTextureSubImage1DEXT_ARG_NAMES texture, target, level, xoffset, x, y, width
#define glCopyTextureSubImage1DEXT_ARG_EXPAND GLuint texture, GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width
#define glCopyTextureSubImage1DEXT_PACKED PACKED_glCopyTextureSubImage1DEXT
#define glCopyTextureSubImage1DEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glCopyTextureSubImage1DEXT_NOT_VOID_WRAP(...) {}
#define pack_glCopyTextureSubImage1DEXT(_texture, _target, _level, _xoffset, _x, _y, _width) ({ \
    glCopyTextureSubImage1DEXT_PACKED *packed_data = malloc(sizeof(glCopyTextureSubImage1DEXT_PACKED)); \
    packed_data->index = glCopyTextureSubImage1DEXT_INDEX; \
    packed_data->args.texture = (GLuint)_texture; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.level = (GLint)_level; \
    packed_data->args.xoffset = (GLint)_xoffset; \
    packed_data->args.x = (GLint)_x; \
    packed_data->args.y = (GLint)_y; \
    packed_data->args.width = (GLsizei)_width; \
    (packed_call_t *)packed_data; \
})
#define call_glCopyTextureSubImage1DEXT(packed, ret_v) do { \
    PACKED_glCopyTextureSubImage1DEXT *unpacked = (PACKED_glCopyTextureSubImage1DEXT *)packed; \
    ARGS_glCopyTextureSubImage1DEXT *args = (ARGS_glCopyTextureSubImage1DEXT *)&unpacked->args; \
    glCopyTextureSubImage1DEXT(args->texture, args->target, args->level, args->xoffset, args->x, args->y, args->width);; \
} while(0)
void glCopyTextureSubImage1DEXT(glCopyTextureSubImage1DEXT_ARG_EXPAND);
typedef void (*glCopyTextureSubImage1DEXT_PTR)(glCopyTextureSubImage1DEXT_ARG_EXPAND);
#define glCopyTextureSubImage2DEXT_INDEX 398
#define glCopyTextureSubImage2DEXT_RETURN void
#define glCopyTextureSubImage2DEXT_ARG_NAMES texture, target, level, xoffset, yoffset, x, y, width, height
#define glCopyTextureSubImage2DEXT_ARG_EXPAND GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height
#define glCopyTextureSubImage2DEXT_PACKED PACKED_glCopyTextureSubImage2DEXT
#define glCopyTextureSubImage2DEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glCopyTextureSubImage2DEXT_NOT_VOID_WRAP(...) {}
#define pack_glCopyTextureSubImage2DEXT(_texture, _target, _level, _xoffset, _yoffset, _x, _y, _width, _height) ({ \
    glCopyTextureSubImage2DEXT_PACKED *packed_data = malloc(sizeof(glCopyTextureSubImage2DEXT_PACKED)); \
    packed_data->index = glCopyTextureSubImage2DEXT_INDEX; \
    packed_data->args.texture = (GLuint)_texture; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.level = (GLint)_level; \
    packed_data->args.xoffset = (GLint)_xoffset; \
    packed_data->args.yoffset = (GLint)_yoffset; \
    packed_data->args.x = (GLint)_x; \
    packed_data->args.y = (GLint)_y; \
    packed_data->args.width = (GLsizei)_width; \
    packed_data->args.height = (GLsizei)_height; \
    (packed_call_t *)packed_data; \
})
#define call_glCopyTextureSubImage2DEXT(packed, ret_v) do { \
    PACKED_glCopyTextureSubImage2DEXT *unpacked = (PACKED_glCopyTextureSubImage2DEXT *)packed; \
    ARGS_glCopyTextureSubImage2DEXT *args = (ARGS_glCopyTextureSubImage2DEXT *)&unpacked->args; \
    glCopyTextureSubImage2DEXT(args->texture, args->target, args->level, args->xoffset, args->yoffset, args->x, args->y, args->width, args->height);; \
} while(0)
void glCopyTextureSubImage2DEXT(glCopyTextureSubImage2DEXT_ARG_EXPAND);
typedef void (*glCopyTextureSubImage2DEXT_PTR)(glCopyTextureSubImage2DEXT_ARG_EXPAND);
#define glCopyTextureSubImage3DEXT_INDEX 399
#define glCopyTextureSubImage3DEXT_RETURN void
#define glCopyTextureSubImage3DEXT_ARG_NAMES texture, target, level, xoffset, yoffset, zoffset, x, y, width, height
#define glCopyTextureSubImage3DEXT_ARG_EXPAND GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height
#define glCopyTextureSubImage3DEXT_PACKED PACKED_glCopyTextureSubImage3DEXT
#define glCopyTextureSubImage3DEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glCopyTextureSubImage3DEXT_NOT_VOID_WRAP(...) {}
#define pack_glCopyTextureSubImage3DEXT(_texture, _target, _level, _xoffset, _yoffset, _zoffset, _x, _y, _width, _height) ({ \
    glCopyTextureSubImage3DEXT_PACKED *packed_data = malloc(sizeof(glCopyTextureSubImage3DEXT_PACKED)); \
    packed_data->index = glCopyTextureSubImage3DEXT_INDEX; \
    packed_data->args.texture = (GLuint)_texture; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.level = (GLint)_level; \
    packed_data->args.xoffset = (GLint)_xoffset; \
    packed_data->args.yoffset = (GLint)_yoffset; \
    packed_data->args.zoffset = (GLint)_zoffset; \
    packed_data->args.x = (GLint)_x; \
    packed_data->args.y = (GLint)_y; \
    packed_data->args.width = (GLsizei)_width; \
    packed_data->args.height = (GLsizei)_height; \
    (packed_call_t *)packed_data; \
})
#define call_glCopyTextureSubImage3DEXT(packed, ret_v) do { \
    PACKED_glCopyTextureSubImage3DEXT *unpacked = (PACKED_glCopyTextureSubImage3DEXT *)packed; \
    ARGS_glCopyTextureSubImage3DEXT *args = (ARGS_glCopyTextureSubImage3DEXT *)&unpacked->args; \
    glCopyTextureSubImage3DEXT(args->texture, args->target, args->level, args->xoffset, args->yoffset, args->zoffset, args->x, args->y, args->width, args->height);; \
} while(0)
void glCopyTextureSubImage3DEXT(glCopyTextureSubImage3DEXT_ARG_EXPAND);
typedef void (*glCopyTextureSubImage3DEXT_PTR)(glCopyTextureSubImage3DEXT_ARG_EXPAND);
#define glCoverFillPathInstancedNV_INDEX 400
#define glCoverFillPathInstancedNV_RETURN void
#define glCoverFillPathInstancedNV_ARG_NAMES numPaths, pathNameType, paths, pathBase, coverMode, transformType, transformValues
#define glCoverFillPathInstancedNV_ARG_EXPAND GLsizei numPaths, GLenum pathNameType, const GLvoid * paths, GLuint pathBase, GLenum coverMode, GLenum transformType, const GLfloat * transformValues
#define glCoverFillPathInstancedNV_PACKED PACKED_glCoverFillPathInstancedNV
#define glCoverFillPathInstancedNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glCoverFillPathInstancedNV_NOT_VOID_WRAP(...) {}
#define pack_glCoverFillPathInstancedNV(_numPaths, _pathNameType, _paths, _pathBase, _coverMode, _transformType, _transformValues) ({ \
    glCoverFillPathInstancedNV_PACKED *packed_data = malloc(sizeof(glCoverFillPathInstancedNV_PACKED)); \
    packed_data->index = glCoverFillPathInstancedNV_INDEX; \
    packed_data->args.numPaths = (GLsizei)_numPaths; \
    packed_data->args.pathNameType = (GLenum)_pathNameType; \
    packed_data->args.paths = (GLvoid *)_paths; \
    packed_data->args.pathBase = (GLuint)_pathBase; \
    packed_data->args.coverMode = (GLenum)_coverMode; \
    packed_data->args.transformType = (GLenum)_transformType; \
    packed_data->args.transformValues = (GLfloat *)_transformValues; \
    (packed_call_t *)packed_data; \
})
#define call_glCoverFillPathInstancedNV(packed, ret_v) do { \
    PACKED_glCoverFillPathInstancedNV *unpacked = (PACKED_glCoverFillPathInstancedNV *)packed; \
    ARGS_glCoverFillPathInstancedNV *args = (ARGS_glCoverFillPathInstancedNV *)&unpacked->args; \
    glCoverFillPathInstancedNV(args->numPaths, args->pathNameType, args->paths, args->pathBase, args->coverMode, args->transformType, args->transformValues);; \
} while(0)
void glCoverFillPathInstancedNV(glCoverFillPathInstancedNV_ARG_EXPAND);
typedef void (*glCoverFillPathInstancedNV_PTR)(glCoverFillPathInstancedNV_ARG_EXPAND);
#define glCoverFillPathNV_INDEX 401
#define glCoverFillPathNV_RETURN void
#define glCoverFillPathNV_ARG_NAMES path, coverMode
#define glCoverFillPathNV_ARG_EXPAND GLuint path, GLenum coverMode
#define glCoverFillPathNV_PACKED PACKED_glCoverFillPathNV
#define glCoverFillPathNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glCoverFillPathNV_NOT_VOID_WRAP(...) {}
#define pack_glCoverFillPathNV(_path, _coverMode) ({ \
    glCoverFillPathNV_PACKED *packed_data = malloc(sizeof(glCoverFillPathNV_PACKED)); \
    packed_data->index = glCoverFillPathNV_INDEX; \
    packed_data->args.path = (GLuint)_path; \
    packed_data->args.coverMode = (GLenum)_coverMode; \
    (packed_call_t *)packed_data; \
})
#define call_glCoverFillPathNV(packed, ret_v) do { \
    PACKED_glCoverFillPathNV *unpacked = (PACKED_glCoverFillPathNV *)packed; \
    ARGS_glCoverFillPathNV *args = (ARGS_glCoverFillPathNV *)&unpacked->args; \
    glCoverFillPathNV(args->path, args->coverMode);; \
} while(0)
void glCoverFillPathNV(glCoverFillPathNV_ARG_EXPAND);
typedef void (*glCoverFillPathNV_PTR)(glCoverFillPathNV_ARG_EXPAND);
#define glCoverStrokePathInstancedNV_INDEX 402
#define glCoverStrokePathInstancedNV_RETURN void
#define glCoverStrokePathInstancedNV_ARG_NAMES numPaths, pathNameType, paths, pathBase, coverMode, transformType, transformValues
#define glCoverStrokePathInstancedNV_ARG_EXPAND GLsizei numPaths, GLenum pathNameType, const GLvoid * paths, GLuint pathBase, GLenum coverMode, GLenum transformType, const GLfloat * transformValues
#define glCoverStrokePathInstancedNV_PACKED PACKED_glCoverStrokePathInstancedNV
#define glCoverStrokePathInstancedNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glCoverStrokePathInstancedNV_NOT_VOID_WRAP(...) {}
#define pack_glCoverStrokePathInstancedNV(_numPaths, _pathNameType, _paths, _pathBase, _coverMode, _transformType, _transformValues) ({ \
    glCoverStrokePathInstancedNV_PACKED *packed_data = malloc(sizeof(glCoverStrokePathInstancedNV_PACKED)); \
    packed_data->index = glCoverStrokePathInstancedNV_INDEX; \
    packed_data->args.numPaths = (GLsizei)_numPaths; \
    packed_data->args.pathNameType = (GLenum)_pathNameType; \
    packed_data->args.paths = (GLvoid *)_paths; \
    packed_data->args.pathBase = (GLuint)_pathBase; \
    packed_data->args.coverMode = (GLenum)_coverMode; \
    packed_data->args.transformType = (GLenum)_transformType; \
    packed_data->args.transformValues = (GLfloat *)_transformValues; \
    (packed_call_t *)packed_data; \
})
#define call_glCoverStrokePathInstancedNV(packed, ret_v) do { \
    PACKED_glCoverStrokePathInstancedNV *unpacked = (PACKED_glCoverStrokePathInstancedNV *)packed; \
    ARGS_glCoverStrokePathInstancedNV *args = (ARGS_glCoverStrokePathInstancedNV *)&unpacked->args; \
    glCoverStrokePathInstancedNV(args->numPaths, args->pathNameType, args->paths, args->pathBase, args->coverMode, args->transformType, args->transformValues);; \
} while(0)
void glCoverStrokePathInstancedNV(glCoverStrokePathInstancedNV_ARG_EXPAND);
typedef void (*glCoverStrokePathInstancedNV_PTR)(glCoverStrokePathInstancedNV_ARG_EXPAND);
#define glCoverStrokePathNV_INDEX 403
#define glCoverStrokePathNV_RETURN void
#define glCoverStrokePathNV_ARG_NAMES path, coverMode
#define glCoverStrokePathNV_ARG_EXPAND GLuint path, GLenum coverMode
#define glCoverStrokePathNV_PACKED PACKED_glCoverStrokePathNV
#define glCoverStrokePathNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glCoverStrokePathNV_NOT_VOID_WRAP(...) {}
#define pack_glCoverStrokePathNV(_path, _coverMode) ({ \
    glCoverStrokePathNV_PACKED *packed_data = malloc(sizeof(glCoverStrokePathNV_PACKED)); \
    packed_data->index = glCoverStrokePathNV_INDEX; \
    packed_data->args.path = (GLuint)_path; \
    packed_data->args.coverMode = (GLenum)_coverMode; \
    (packed_call_t *)packed_data; \
})
#define call_glCoverStrokePathNV(packed, ret_v) do { \
    PACKED_glCoverStrokePathNV *unpacked = (PACKED_glCoverStrokePathNV *)packed; \
    ARGS_glCoverStrokePathNV *args = (ARGS_glCoverStrokePathNV *)&unpacked->args; \
    glCoverStrokePathNV(args->path, args->coverMode);; \
} while(0)
void glCoverStrokePathNV(glCoverStrokePathNV_ARG_EXPAND);
typedef void (*glCoverStrokePathNV_PTR)(glCoverStrokePathNV_ARG_EXPAND);
#define glCreateProgram_INDEX 404
#define glCreateProgram_RETURN GLuint
#define glCreateProgram_ARG_NAMES 
#define glCreateProgram_ARG_EXPAND 
#define glCreateProgram_PACKED PACKED_glCreateProgram
#define glCreateProgram_VOID_ONLY_WRAP(...) {}
#define glCreateProgram_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glCreateProgram() ({ \
    glCreateProgram_PACKED *packed_data = malloc(sizeof(glCreateProgram_PACKED)); \
    packed_data->index = glCreateProgram_INDEX; \
    (packed_call_t *)packed_data; \
})
#define call_glCreateProgram(packed, ret_v) do { \
    GLuint *ret = (GLuint *)ret_v; \
    if (ret != NULL) { \
        *ret = glCreateProgram();; \
    } else { \
        glCreateProgram();; \
    } \
} while(0)
GLuint glCreateProgram(glCreateProgram_ARG_EXPAND);
typedef GLuint (*glCreateProgram_PTR)(glCreateProgram_ARG_EXPAND);
#define glCreateProgramObjectARB_INDEX 405
#define glCreateProgramObjectARB_RETURN GLhandleARB
#define glCreateProgramObjectARB_ARG_NAMES 
#define glCreateProgramObjectARB_ARG_EXPAND 
#define glCreateProgramObjectARB_PACKED PACKED_glCreateProgramObjectARB
#define glCreateProgramObjectARB_VOID_ONLY_WRAP(...) {}
#define glCreateProgramObjectARB_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glCreateProgramObjectARB() ({ \
    glCreateProgramObjectARB_PACKED *packed_data = malloc(sizeof(glCreateProgramObjectARB_PACKED)); \
    packed_data->index = glCreateProgramObjectARB_INDEX; \
    (packed_call_t *)packed_data; \
})
#define call_glCreateProgramObjectARB(packed, ret_v) do { \
    GLhandleARB *ret = (GLhandleARB *)ret_v; \
    if (ret != NULL) { \
        *ret = glCreateProgramObjectARB();; \
    } else { \
        glCreateProgramObjectARB();; \
    } \
} while(0)
GLhandleARB glCreateProgramObjectARB(glCreateProgramObjectARB_ARG_EXPAND);
typedef GLhandleARB (*glCreateProgramObjectARB_PTR)(glCreateProgramObjectARB_ARG_EXPAND);
#define glCreateShader_INDEX 406
#define glCreateShader_RETURN GLuint
#define glCreateShader_ARG_NAMES type
#define glCreateShader_ARG_EXPAND GLenum type
#define glCreateShader_PACKED PACKED_glCreateShader
#define glCreateShader_VOID_ONLY_WRAP(...) {}
#define glCreateShader_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glCreateShader(_type) ({ \
    glCreateShader_PACKED *packed_data = malloc(sizeof(glCreateShader_PACKED)); \
    packed_data->index = glCreateShader_INDEX; \
    packed_data->args.type = (GLenum)_type; \
    (packed_call_t *)packed_data; \
})
#define call_glCreateShader(packed, ret_v) do { \
    PACKED_glCreateShader *unpacked = (PACKED_glCreateShader *)packed; \
    ARGS_glCreateShader *args = (ARGS_glCreateShader *)&unpacked->args; \
    GLuint *ret = (GLuint *)ret_v; \
    if (ret != NULL) { \
        *ret = glCreateShader(args->type);; \
    } else { \
        glCreateShader(args->type);; \
    } \
} while(0)
GLuint glCreateShader(glCreateShader_ARG_EXPAND);
typedef GLuint (*glCreateShader_PTR)(glCreateShader_ARG_EXPAND);
#define glCreateShaderObjectARB_INDEX 407
#define glCreateShaderObjectARB_RETURN GLhandleARB
#define glCreateShaderObjectARB_ARG_NAMES shaderType
#define glCreateShaderObjectARB_ARG_EXPAND GLenum shaderType
#define glCreateShaderObjectARB_PACKED PACKED_glCreateShaderObjectARB
#define glCreateShaderObjectARB_VOID_ONLY_WRAP(...) {}
#define glCreateShaderObjectARB_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glCreateShaderObjectARB(_shaderType) ({ \
    glCreateShaderObjectARB_PACKED *packed_data = malloc(sizeof(glCreateShaderObjectARB_PACKED)); \
    packed_data->index = glCreateShaderObjectARB_INDEX; \
    packed_data->args.shaderType = (GLenum)_shaderType; \
    (packed_call_t *)packed_data; \
})
#define call_glCreateShaderObjectARB(packed, ret_v) do { \
    PACKED_glCreateShaderObjectARB *unpacked = (PACKED_glCreateShaderObjectARB *)packed; \
    ARGS_glCreateShaderObjectARB *args = (ARGS_glCreateShaderObjectARB *)&unpacked->args; \
    GLhandleARB *ret = (GLhandleARB *)ret_v; \
    if (ret != NULL) { \
        *ret = glCreateShaderObjectARB(args->shaderType);; \
    } else { \
        glCreateShaderObjectARB(args->shaderType);; \
    } \
} while(0)
GLhandleARB glCreateShaderObjectARB(glCreateShaderObjectARB_ARG_EXPAND);
typedef GLhandleARB (*glCreateShaderObjectARB_PTR)(glCreateShaderObjectARB_ARG_EXPAND);
#define glCreateShaderProgramEXT_INDEX 408
#define glCreateShaderProgramEXT_RETURN GLuint
#define glCreateShaderProgramEXT_ARG_NAMES type, string
#define glCreateShaderProgramEXT_ARG_EXPAND GLenum type, const GLchar * string
#define glCreateShaderProgramEXT_PACKED PACKED_glCreateShaderProgramEXT
#define glCreateShaderProgramEXT_VOID_ONLY_WRAP(...) {}
#define glCreateShaderProgramEXT_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glCreateShaderProgramEXT(_type, _string) ({ \
    glCreateShaderProgramEXT_PACKED *packed_data = malloc(sizeof(glCreateShaderProgramEXT_PACKED)); \
    packed_data->index = glCreateShaderProgramEXT_INDEX; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.string = (GLchar *)_string; \
    (packed_call_t *)packed_data; \
})
#define call_glCreateShaderProgramEXT(packed, ret_v) do { \
    PACKED_glCreateShaderProgramEXT *unpacked = (PACKED_glCreateShaderProgramEXT *)packed; \
    ARGS_glCreateShaderProgramEXT *args = (ARGS_glCreateShaderProgramEXT *)&unpacked->args; \
    GLuint *ret = (GLuint *)ret_v; \
    if (ret != NULL) { \
        *ret = glCreateShaderProgramEXT(args->type, args->string);; \
    } else { \
        glCreateShaderProgramEXT(args->type, args->string);; \
    } \
} while(0)
GLuint glCreateShaderProgramEXT(glCreateShaderProgramEXT_ARG_EXPAND);
typedef GLuint (*glCreateShaderProgramEXT_PTR)(glCreateShaderProgramEXT_ARG_EXPAND);
#define glCreateShaderProgramv_INDEX 409
#define glCreateShaderProgramv_RETURN GLuint
#define glCreateShaderProgramv_ARG_NAMES type, count, strings
#define glCreateShaderProgramv_ARG_EXPAND GLenum type, GLsizei count, GLchar*const * strings
#define glCreateShaderProgramv_PACKED PACKED_glCreateShaderProgramv
#define glCreateShaderProgramv_VOID_ONLY_WRAP(...) {}
#define glCreateShaderProgramv_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glCreateShaderProgramv(_type, _count, _strings) ({ \
    glCreateShaderProgramv_PACKED *packed_data = malloc(sizeof(glCreateShaderProgramv_PACKED)); \
    packed_data->index = glCreateShaderProgramv_INDEX; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.strings = (GLchar*const *)_strings; \
    (packed_call_t *)packed_data; \
})
#define call_glCreateShaderProgramv(packed, ret_v) do { \
    PACKED_glCreateShaderProgramv *unpacked = (PACKED_glCreateShaderProgramv *)packed; \
    ARGS_glCreateShaderProgramv *args = (ARGS_glCreateShaderProgramv *)&unpacked->args; \
    GLuint *ret = (GLuint *)ret_v; \
    if (ret != NULL) { \
        *ret = glCreateShaderProgramv(args->type, args->count, args->strings);; \
    } else { \
        glCreateShaderProgramv(args->type, args->count, args->strings);; \
    } \
} while(0)
GLuint glCreateShaderProgramv(glCreateShaderProgramv_ARG_EXPAND);
typedef GLuint (*glCreateShaderProgramv_PTR)(glCreateShaderProgramv_ARG_EXPAND);
#define glCreateSyncFromCLeventARB_INDEX 410
#define glCreateSyncFromCLeventARB_RETURN GLsync
#define glCreateSyncFromCLeventARB_ARG_NAMES context, event, flags
#define glCreateSyncFromCLeventARB_ARG_EXPAND struct _cl_context * context, struct _cl_event * event, GLbitfield flags
#define glCreateSyncFromCLeventARB_PACKED PACKED_glCreateSyncFromCLeventARB
#define glCreateSyncFromCLeventARB_VOID_ONLY_WRAP(...) {}
#define glCreateSyncFromCLeventARB_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glCreateSyncFromCLeventARB(_context, _event, _flags) ({ \
    glCreateSyncFromCLeventARB_PACKED *packed_data = malloc(sizeof(glCreateSyncFromCLeventARB_PACKED)); \
    packed_data->index = glCreateSyncFromCLeventARB_INDEX; \
    packed_data->args.context = (struct _cl_context *)_context; \
    packed_data->args.event = (struct _cl_event *)_event; \
    packed_data->args.flags = (GLbitfield)_flags; \
    (packed_call_t *)packed_data; \
})
#define call_glCreateSyncFromCLeventARB(packed, ret_v) do { \
    PACKED_glCreateSyncFromCLeventARB *unpacked = (PACKED_glCreateSyncFromCLeventARB *)packed; \
    ARGS_glCreateSyncFromCLeventARB *args = (ARGS_glCreateSyncFromCLeventARB *)&unpacked->args; \
    GLsync *ret = (GLsync *)ret_v; \
    if (ret != NULL) { \
        *ret = glCreateSyncFromCLeventARB(args->context, args->event, args->flags);; \
    } else { \
        glCreateSyncFromCLeventARB(args->context, args->event, args->flags);; \
    } \
} while(0)
GLsync glCreateSyncFromCLeventARB(glCreateSyncFromCLeventARB_ARG_EXPAND);
typedef GLsync (*glCreateSyncFromCLeventARB_PTR)(glCreateSyncFromCLeventARB_ARG_EXPAND);
#define glCullFace_INDEX 411
#define glCullFace_RETURN void
#define glCullFace_ARG_NAMES mode
#define glCullFace_ARG_EXPAND GLenum mode
#define glCullFace_PACKED PACKED_glCullFace
#define glCullFace_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glCullFace_NOT_VOID_WRAP(...) {}
#define pack_glCullFace(_mode) ({ \
    glCullFace_PACKED *packed_data = malloc(sizeof(glCullFace_PACKED)); \
    packed_data->index = glCullFace_INDEX; \
    packed_data->args.mode = (GLenum)_mode; \
    (packed_call_t *)packed_data; \
})
#define call_glCullFace(packed, ret_v) do { \
    PACKED_glCullFace *unpacked = (PACKED_glCullFace *)packed; \
    ARGS_glCullFace *args = (ARGS_glCullFace *)&unpacked->args; \
    glCullFace(args->mode);; \
} while(0)
void glCullFace(glCullFace_ARG_EXPAND);
typedef void (*glCullFace_PTR)(glCullFace_ARG_EXPAND);
#define glCullParameterdvEXT_INDEX 412
#define glCullParameterdvEXT_RETURN void
#define glCullParameterdvEXT_ARG_NAMES pname, params
#define glCullParameterdvEXT_ARG_EXPAND GLenum pname, GLdouble * params
#define glCullParameterdvEXT_PACKED PACKED_glCullParameterdvEXT
#define glCullParameterdvEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glCullParameterdvEXT_NOT_VOID_WRAP(...) {}
#define pack_glCullParameterdvEXT(_pname, _params) ({ \
    glCullParameterdvEXT_PACKED *packed_data = malloc(sizeof(glCullParameterdvEXT_PACKED)); \
    packed_data->index = glCullParameterdvEXT_INDEX; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLdouble *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glCullParameterdvEXT(packed, ret_v) do { \
    PACKED_glCullParameterdvEXT *unpacked = (PACKED_glCullParameterdvEXT *)packed; \
    ARGS_glCullParameterdvEXT *args = (ARGS_glCullParameterdvEXT *)&unpacked->args; \
    glCullParameterdvEXT(args->pname, args->params);; \
} while(0)
void glCullParameterdvEXT(glCullParameterdvEXT_ARG_EXPAND);
typedef void (*glCullParameterdvEXT_PTR)(glCullParameterdvEXT_ARG_EXPAND);
#define glCullParameterfvEXT_INDEX 413
#define glCullParameterfvEXT_RETURN void
#define glCullParameterfvEXT_ARG_NAMES pname, params
#define glCullParameterfvEXT_ARG_EXPAND GLenum pname, GLfloat * params
#define glCullParameterfvEXT_PACKED PACKED_glCullParameterfvEXT
#define glCullParameterfvEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glCullParameterfvEXT_NOT_VOID_WRAP(...) {}
#define pack_glCullParameterfvEXT(_pname, _params) ({ \
    glCullParameterfvEXT_PACKED *packed_data = malloc(sizeof(glCullParameterfvEXT_PACKED)); \
    packed_data->index = glCullParameterfvEXT_INDEX; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLfloat *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glCullParameterfvEXT(packed, ret_v) do { \
    PACKED_glCullParameterfvEXT *unpacked = (PACKED_glCullParameterfvEXT *)packed; \
    ARGS_glCullParameterfvEXT *args = (ARGS_glCullParameterfvEXT *)&unpacked->args; \
    glCullParameterfvEXT(args->pname, args->params);; \
} while(0)
void glCullParameterfvEXT(glCullParameterfvEXT_ARG_EXPAND);
typedef void (*glCullParameterfvEXT_PTR)(glCullParameterfvEXT_ARG_EXPAND);
#define glCurrentPaletteMatrixARB_INDEX 414
#define glCurrentPaletteMatrixARB_RETURN void
#define glCurrentPaletteMatrixARB_ARG_NAMES index
#define glCurrentPaletteMatrixARB_ARG_EXPAND GLint index
#define glCurrentPaletteMatrixARB_PACKED PACKED_glCurrentPaletteMatrixARB
#define glCurrentPaletteMatrixARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glCurrentPaletteMatrixARB_NOT_VOID_WRAP(...) {}
#define pack_glCurrentPaletteMatrixARB(_index) ({ \
    glCurrentPaletteMatrixARB_PACKED *packed_data = malloc(sizeof(glCurrentPaletteMatrixARB_PACKED)); \
    packed_data->index = glCurrentPaletteMatrixARB_INDEX; \
    packed_data->args.index = (GLint)_index; \
    (packed_call_t *)packed_data; \
})
#define call_glCurrentPaletteMatrixARB(packed, ret_v) do { \
    PACKED_glCurrentPaletteMatrixARB *unpacked = (PACKED_glCurrentPaletteMatrixARB *)packed; \
    ARGS_glCurrentPaletteMatrixARB *args = (ARGS_glCurrentPaletteMatrixARB *)&unpacked->args; \
    glCurrentPaletteMatrixARB(args->index);; \
} while(0)
void glCurrentPaletteMatrixARB(glCurrentPaletteMatrixARB_ARG_EXPAND);
typedef void (*glCurrentPaletteMatrixARB_PTR)(glCurrentPaletteMatrixARB_ARG_EXPAND);
#define glDebugMessageCallback_INDEX 415
#define glDebugMessageCallback_RETURN void
#define glDebugMessageCallback_ARG_NAMES callback, userParam
#define glDebugMessageCallback_ARG_EXPAND GLDEBUGPROC callback, const void * userParam
#define glDebugMessageCallback_PACKED PACKED_glDebugMessageCallback
#define glDebugMessageCallback_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glDebugMessageCallback_NOT_VOID_WRAP(...) {}
#define pack_glDebugMessageCallback(_callback, _userParam) ({ \
    glDebugMessageCallback_PACKED *packed_data = malloc(sizeof(glDebugMessageCallback_PACKED)); \
    packed_data->index = glDebugMessageCallback_INDEX; \
    packed_data->args.callback = (GLDEBUGPROC)_callback; \
    packed_data->args.userParam = (void *)_userParam; \
    (packed_call_t *)packed_data; \
})
#define call_glDebugMessageCallback(packed, ret_v) do { \
    PACKED_glDebugMessageCallback *unpacked = (PACKED_glDebugMessageCallback *)packed; \
    ARGS_glDebugMessageCallback *args = (ARGS_glDebugMessageCallback *)&unpacked->args; \
    glDebugMessageCallback(args->callback, args->userParam);; \
} while(0)
void glDebugMessageCallback(glDebugMessageCallback_ARG_EXPAND);
typedef void (*glDebugMessageCallback_PTR)(glDebugMessageCallback_ARG_EXPAND);
#define glDebugMessageCallbackAMD_INDEX 416
#define glDebugMessageCallbackAMD_RETURN void
#define glDebugMessageCallbackAMD_ARG_NAMES callback, userParam
#define glDebugMessageCallbackAMD_ARG_EXPAND GLDEBUGPROCAMD callback, GLvoid * userParam
#define glDebugMessageCallbackAMD_PACKED PACKED_glDebugMessageCallbackAMD
#define glDebugMessageCallbackAMD_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glDebugMessageCallbackAMD_NOT_VOID_WRAP(...) {}
#define pack_glDebugMessageCallbackAMD(_callback, _userParam) ({ \
    glDebugMessageCallbackAMD_PACKED *packed_data = malloc(sizeof(glDebugMessageCallbackAMD_PACKED)); \
    packed_data->index = glDebugMessageCallbackAMD_INDEX; \
    packed_data->args.callback = (GLDEBUGPROCAMD)_callback; \
    packed_data->args.userParam = (GLvoid *)_userParam; \
    (packed_call_t *)packed_data; \
})
#define call_glDebugMessageCallbackAMD(packed, ret_v) do { \
    PACKED_glDebugMessageCallbackAMD *unpacked = (PACKED_glDebugMessageCallbackAMD *)packed; \
    ARGS_glDebugMessageCallbackAMD *args = (ARGS_glDebugMessageCallbackAMD *)&unpacked->args; \
    glDebugMessageCallbackAMD(args->callback, args->userParam);; \
} while(0)
void glDebugMessageCallbackAMD(glDebugMessageCallbackAMD_ARG_EXPAND);
typedef void (*glDebugMessageCallbackAMD_PTR)(glDebugMessageCallbackAMD_ARG_EXPAND);
#define glDebugMessageCallbackARB_INDEX 417
#define glDebugMessageCallbackARB_RETURN void
#define glDebugMessageCallbackARB_ARG_NAMES callback, userParam
#define glDebugMessageCallbackARB_ARG_EXPAND GLDEBUGPROCARB callback, const GLvoid * userParam
#define glDebugMessageCallbackARB_PACKED PACKED_glDebugMessageCallbackARB
#define glDebugMessageCallbackARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glDebugMessageCallbackARB_NOT_VOID_WRAP(...) {}
#define pack_glDebugMessageCallbackARB(_callback, _userParam) ({ \
    glDebugMessageCallbackARB_PACKED *packed_data = malloc(sizeof(glDebugMessageCallbackARB_PACKED)); \
    packed_data->index = glDebugMessageCallbackARB_INDEX; \
    packed_data->args.callback = (GLDEBUGPROCARB)_callback; \
    packed_data->args.userParam = (GLvoid *)_userParam; \
    (packed_call_t *)packed_data; \
})
#define call_glDebugMessageCallbackARB(packed, ret_v) do { \
    PACKED_glDebugMessageCallbackARB *unpacked = (PACKED_glDebugMessageCallbackARB *)packed; \
    ARGS_glDebugMessageCallbackARB *args = (ARGS_glDebugMessageCallbackARB *)&unpacked->args; \
    glDebugMessageCallbackARB(args->callback, args->userParam);; \
} while(0)
void glDebugMessageCallbackARB(glDebugMessageCallbackARB_ARG_EXPAND);
typedef void (*glDebugMessageCallbackARB_PTR)(glDebugMessageCallbackARB_ARG_EXPAND);
#define glDebugMessageControl_INDEX 418
#define glDebugMessageControl_RETURN void
#define glDebugMessageControl_ARG_NAMES source, type, severity, count, ids, enabled
#define glDebugMessageControl_ARG_EXPAND GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint * ids, GLboolean enabled
#define glDebugMessageControl_PACKED PACKED_glDebugMessageControl
#define glDebugMessageControl_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glDebugMessageControl_NOT_VOID_WRAP(...) {}
#define pack_glDebugMessageControl(_source, _type, _severity, _count, _ids, _enabled) ({ \
    glDebugMessageControl_PACKED *packed_data = malloc(sizeof(glDebugMessageControl_PACKED)); \
    packed_data->index = glDebugMessageControl_INDEX; \
    packed_data->args.source = (GLenum)_source; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.severity = (GLenum)_severity; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.ids = (GLuint *)_ids; \
    packed_data->args.enabled = (GLboolean)_enabled; \
    (packed_call_t *)packed_data; \
})
#define call_glDebugMessageControl(packed, ret_v) do { \
    PACKED_glDebugMessageControl *unpacked = (PACKED_glDebugMessageControl *)packed; \
    ARGS_glDebugMessageControl *args = (ARGS_glDebugMessageControl *)&unpacked->args; \
    glDebugMessageControl(args->source, args->type, args->severity, args->count, args->ids, args->enabled);; \
} while(0)
void glDebugMessageControl(glDebugMessageControl_ARG_EXPAND);
typedef void (*glDebugMessageControl_PTR)(glDebugMessageControl_ARG_EXPAND);
#define glDebugMessageControlARB_INDEX 419
#define glDebugMessageControlARB_RETURN void
#define glDebugMessageControlARB_ARG_NAMES source, type, severity, count, ids, enabled
#define glDebugMessageControlARB_ARG_EXPAND GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint * ids, GLboolean enabled
#define glDebugMessageControlARB_PACKED PACKED_glDebugMessageControlARB
#define glDebugMessageControlARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glDebugMessageControlARB_NOT_VOID_WRAP(...) {}
#define pack_glDebugMessageControlARB(_source, _type, _severity, _count, _ids, _enabled) ({ \
    glDebugMessageControlARB_PACKED *packed_data = malloc(sizeof(glDebugMessageControlARB_PACKED)); \
    packed_data->index = glDebugMessageControlARB_INDEX; \
    packed_data->args.source = (GLenum)_source; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.severity = (GLenum)_severity; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.ids = (GLuint *)_ids; \
    packed_data->args.enabled = (GLboolean)_enabled; \
    (packed_call_t *)packed_data; \
})
#define call_glDebugMessageControlARB(packed, ret_v) do { \
    PACKED_glDebugMessageControlARB *unpacked = (PACKED_glDebugMessageControlARB *)packed; \
    ARGS_glDebugMessageControlARB *args = (ARGS_glDebugMessageControlARB *)&unpacked->args; \
    glDebugMessageControlARB(args->source, args->type, args->severity, args->count, args->ids, args->enabled);; \
} while(0)
void glDebugMessageControlARB(glDebugMessageControlARB_ARG_EXPAND);
typedef void (*glDebugMessageControlARB_PTR)(glDebugMessageControlARB_ARG_EXPAND);
#define glDebugMessageEnableAMD_INDEX 420
#define glDebugMessageEnableAMD_RETURN void
#define glDebugMessageEnableAMD_ARG_NAMES category, severity, count, ids, enabled
#define glDebugMessageEnableAMD_ARG_EXPAND GLenum category, GLenum severity, GLsizei count, const GLuint * ids, GLboolean enabled
#define glDebugMessageEnableAMD_PACKED PACKED_glDebugMessageEnableAMD
#define glDebugMessageEnableAMD_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glDebugMessageEnableAMD_NOT_VOID_WRAP(...) {}
#define pack_glDebugMessageEnableAMD(_category, _severity, _count, _ids, _enabled) ({ \
    glDebugMessageEnableAMD_PACKED *packed_data = malloc(sizeof(glDebugMessageEnableAMD_PACKED)); \
    packed_data->index = glDebugMessageEnableAMD_INDEX; \
    packed_data->args.category = (GLenum)_category; \
    packed_data->args.severity = (GLenum)_severity; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.ids = (GLuint *)_ids; \
    packed_data->args.enabled = (GLboolean)_enabled; \
    (packed_call_t *)packed_data; \
})
#define call_glDebugMessageEnableAMD(packed, ret_v) do { \
    PACKED_glDebugMessageEnableAMD *unpacked = (PACKED_glDebugMessageEnableAMD *)packed; \
    ARGS_glDebugMessageEnableAMD *args = (ARGS_glDebugMessageEnableAMD *)&unpacked->args; \
    glDebugMessageEnableAMD(args->category, args->severity, args->count, args->ids, args->enabled);; \
} while(0)
void glDebugMessageEnableAMD(glDebugMessageEnableAMD_ARG_EXPAND);
typedef void (*glDebugMessageEnableAMD_PTR)(glDebugMessageEnableAMD_ARG_EXPAND);
#define glDebugMessageInsert_INDEX 421
#define glDebugMessageInsert_RETURN void
#define glDebugMessageInsert_ARG_NAMES source, type, id, severity, length, buf
#define glDebugMessageInsert_ARG_EXPAND GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar * buf
#define glDebugMessageInsert_PACKED PACKED_glDebugMessageInsert
#define glDebugMessageInsert_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glDebugMessageInsert_NOT_VOID_WRAP(...) {}
#define pack_glDebugMessageInsert(_source, _type, _id, _severity, _length, _buf) ({ \
    glDebugMessageInsert_PACKED *packed_data = malloc(sizeof(glDebugMessageInsert_PACKED)); \
    packed_data->index = glDebugMessageInsert_INDEX; \
    packed_data->args.source = (GLenum)_source; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.id = (GLuint)_id; \
    packed_data->args.severity = (GLenum)_severity; \
    packed_data->args.length = (GLsizei)_length; \
    packed_data->args.buf = (GLchar *)_buf; \
    (packed_call_t *)packed_data; \
})
#define call_glDebugMessageInsert(packed, ret_v) do { \
    PACKED_glDebugMessageInsert *unpacked = (PACKED_glDebugMessageInsert *)packed; \
    ARGS_glDebugMessageInsert *args = (ARGS_glDebugMessageInsert *)&unpacked->args; \
    glDebugMessageInsert(args->source, args->type, args->id, args->severity, args->length, args->buf);; \
} while(0)
void glDebugMessageInsert(glDebugMessageInsert_ARG_EXPAND);
typedef void (*glDebugMessageInsert_PTR)(glDebugMessageInsert_ARG_EXPAND);
#define glDebugMessageInsertAMD_INDEX 422
#define glDebugMessageInsertAMD_RETURN void
#define glDebugMessageInsertAMD_ARG_NAMES category, severity, id, length, buf
#define glDebugMessageInsertAMD_ARG_EXPAND GLenum category, GLenum severity, GLuint id, GLsizei length, const GLchar * buf
#define glDebugMessageInsertAMD_PACKED PACKED_glDebugMessageInsertAMD
#define glDebugMessageInsertAMD_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glDebugMessageInsertAMD_NOT_VOID_WRAP(...) {}
#define pack_glDebugMessageInsertAMD(_category, _severity, _id, _length, _buf) ({ \
    glDebugMessageInsertAMD_PACKED *packed_data = malloc(sizeof(glDebugMessageInsertAMD_PACKED)); \
    packed_data->index = glDebugMessageInsertAMD_INDEX; \
    packed_data->args.category = (GLenum)_category; \
    packed_data->args.severity = (GLenum)_severity; \
    packed_data->args.id = (GLuint)_id; \
    packed_data->args.length = (GLsizei)_length; \
    packed_data->args.buf = (GLchar *)_buf; \
    (packed_call_t *)packed_data; \
})
#define call_glDebugMessageInsertAMD(packed, ret_v) do { \
    PACKED_glDebugMessageInsertAMD *unpacked = (PACKED_glDebugMessageInsertAMD *)packed; \
    ARGS_glDebugMessageInsertAMD *args = (ARGS_glDebugMessageInsertAMD *)&unpacked->args; \
    glDebugMessageInsertAMD(args->category, args->severity, args->id, args->length, args->buf);; \
} while(0)
void glDebugMessageInsertAMD(glDebugMessageInsertAMD_ARG_EXPAND);
typedef void (*glDebugMessageInsertAMD_PTR)(glDebugMessageInsertAMD_ARG_EXPAND);
#define glDebugMessageInsertARB_INDEX 423
#define glDebugMessageInsertARB_RETURN void
#define glDebugMessageInsertARB_ARG_NAMES source, type, id, severity, length, buf
#define glDebugMessageInsertARB_ARG_EXPAND GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar * buf
#define glDebugMessageInsertARB_PACKED PACKED_glDebugMessageInsertARB
#define glDebugMessageInsertARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glDebugMessageInsertARB_NOT_VOID_WRAP(...) {}
#define pack_glDebugMessageInsertARB(_source, _type, _id, _severity, _length, _buf) ({ \
    glDebugMessageInsertARB_PACKED *packed_data = malloc(sizeof(glDebugMessageInsertARB_PACKED)); \
    packed_data->index = glDebugMessageInsertARB_INDEX; \
    packed_data->args.source = (GLenum)_source; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.id = (GLuint)_id; \
    packed_data->args.severity = (GLenum)_severity; \
    packed_data->args.length = (GLsizei)_length; \
    packed_data->args.buf = (GLchar *)_buf; \
    (packed_call_t *)packed_data; \
})
#define call_glDebugMessageInsertARB(packed, ret_v) do { \
    PACKED_glDebugMessageInsertARB *unpacked = (PACKED_glDebugMessageInsertARB *)packed; \
    ARGS_glDebugMessageInsertARB *args = (ARGS_glDebugMessageInsertARB *)&unpacked->args; \
    glDebugMessageInsertARB(args->source, args->type, args->id, args->severity, args->length, args->buf);; \
} while(0)
void glDebugMessageInsertARB(glDebugMessageInsertARB_ARG_EXPAND);
typedef void (*glDebugMessageInsertARB_PTR)(glDebugMessageInsertARB_ARG_EXPAND);
#define glDeformSGIX_INDEX 424
#define glDeformSGIX_RETURN void
#define glDeformSGIX_ARG_NAMES mask
#define glDeformSGIX_ARG_EXPAND GLbitfield mask
#define glDeformSGIX_PACKED PACKED_glDeformSGIX
#define glDeformSGIX_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glDeformSGIX_NOT_VOID_WRAP(...) {}
#define pack_glDeformSGIX(_mask) ({ \
    glDeformSGIX_PACKED *packed_data = malloc(sizeof(glDeformSGIX_PACKED)); \
    packed_data->index = glDeformSGIX_INDEX; \
    packed_data->args.mask = (GLbitfield)_mask; \
    (packed_call_t *)packed_data; \
})
#define call_glDeformSGIX(packed, ret_v) do { \
    PACKED_glDeformSGIX *unpacked = (PACKED_glDeformSGIX *)packed; \
    ARGS_glDeformSGIX *args = (ARGS_glDeformSGIX *)&unpacked->args; \
    glDeformSGIX(args->mask);; \
} while(0)
void glDeformSGIX(glDeformSGIX_ARG_EXPAND);
typedef void (*glDeformSGIX_PTR)(glDeformSGIX_ARG_EXPAND);
#define glDeformationMap3dSGIX_INDEX 425
#define glDeformationMap3dSGIX_RETURN void
#define glDeformationMap3dSGIX_ARG_NAMES target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, w1, w2, wstride, worder, points
#define glDeformationMap3dSGIX_ARG_EXPAND GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, GLdouble w1, GLdouble w2, GLint wstride, GLint worder, const GLdouble * points
#define glDeformationMap3dSGIX_PACKED PACKED_glDeformationMap3dSGIX
#define glDeformationMap3dSGIX_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glDeformationMap3dSGIX_NOT_VOID_WRAP(...) {}
#define pack_glDeformationMap3dSGIX(_target, _u1, _u2, _ustride, _uorder, _v1, _v2, _vstride, _vorder, _w1, _w2, _wstride, _worder, _points) ({ \
    glDeformationMap3dSGIX_PACKED *packed_data = malloc(sizeof(glDeformationMap3dSGIX_PACKED)); \
    packed_data->index = glDeformationMap3dSGIX_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.u1 = (GLdouble)_u1; \
    packed_data->args.u2 = (GLdouble)_u2; \
    packed_data->args.ustride = (GLint)_ustride; \
    packed_data->args.uorder = (GLint)_uorder; \
    packed_data->args.v1 = (GLdouble)_v1; \
    packed_data->args.v2 = (GLdouble)_v2; \
    packed_data->args.vstride = (GLint)_vstride; \
    packed_data->args.vorder = (GLint)_vorder; \
    packed_data->args.w1 = (GLdouble)_w1; \
    packed_data->args.w2 = (GLdouble)_w2; \
    packed_data->args.wstride = (GLint)_wstride; \
    packed_data->args.worder = (GLint)_worder; \
    packed_data->args.points = (GLdouble *)_points; \
    (packed_call_t *)packed_data; \
})
#define call_glDeformationMap3dSGIX(packed, ret_v) do { \
    PACKED_glDeformationMap3dSGIX *unpacked = (PACKED_glDeformationMap3dSGIX *)packed; \
    ARGS_glDeformationMap3dSGIX *args = (ARGS_glDeformationMap3dSGIX *)&unpacked->args; \
    glDeformationMap3dSGIX(args->target, args->u1, args->u2, args->ustride, args->uorder, args->v1, args->v2, args->vstride, args->vorder, args->w1, args->w2, args->wstride, args->worder, args->points);; \
} while(0)
void glDeformationMap3dSGIX(glDeformationMap3dSGIX_ARG_EXPAND);
typedef void (*glDeformationMap3dSGIX_PTR)(glDeformationMap3dSGIX_ARG_EXPAND);
#define glDeformationMap3fSGIX_INDEX 426
#define glDeformationMap3fSGIX_RETURN void
#define glDeformationMap3fSGIX_ARG_NAMES target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, w1, w2, wstride, worder, points
#define glDeformationMap3fSGIX_ARG_EXPAND GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, GLfloat w1, GLfloat w2, GLint wstride, GLint worder, const GLfloat * points
#define glDeformationMap3fSGIX_PACKED PACKED_glDeformationMap3fSGIX
#define glDeformationMap3fSGIX_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glDeformationMap3fSGIX_NOT_VOID_WRAP(...) {}
#define pack_glDeformationMap3fSGIX(_target, _u1, _u2, _ustride, _uorder, _v1, _v2, _vstride, _vorder, _w1, _w2, _wstride, _worder, _points) ({ \
    glDeformationMap3fSGIX_PACKED *packed_data = malloc(sizeof(glDeformationMap3fSGIX_PACKED)); \
    packed_data->index = glDeformationMap3fSGIX_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.u1 = (GLfloat)_u1; \
    packed_data->args.u2 = (GLfloat)_u2; \
    packed_data->args.ustride = (GLint)_ustride; \
    packed_data->args.uorder = (GLint)_uorder; \
    packed_data->args.v1 = (GLfloat)_v1; \
    packed_data->args.v2 = (GLfloat)_v2; \
    packed_data->args.vstride = (GLint)_vstride; \
    packed_data->args.vorder = (GLint)_vorder; \
    packed_data->args.w1 = (GLfloat)_w1; \
    packed_data->args.w2 = (GLfloat)_w2; \
    packed_data->args.wstride = (GLint)_wstride; \
    packed_data->args.worder = (GLint)_worder; \
    packed_data->args.points = (GLfloat *)_points; \
    (packed_call_t *)packed_data; \
})
#define call_glDeformationMap3fSGIX(packed, ret_v) do { \
    PACKED_glDeformationMap3fSGIX *unpacked = (PACKED_glDeformationMap3fSGIX *)packed; \
    ARGS_glDeformationMap3fSGIX *args = (ARGS_glDeformationMap3fSGIX *)&unpacked->args; \
    glDeformationMap3fSGIX(args->target, args->u1, args->u2, args->ustride, args->uorder, args->v1, args->v2, args->vstride, args->vorder, args->w1, args->w2, args->wstride, args->worder, args->points);; \
} while(0)
void glDeformationMap3fSGIX(glDeformationMap3fSGIX_ARG_EXPAND);
typedef void (*glDeformationMap3fSGIX_PTR)(glDeformationMap3fSGIX_ARG_EXPAND);
#define glDeleteAsyncMarkersSGIX_INDEX 427
#define glDeleteAsyncMarkersSGIX_RETURN void
#define glDeleteAsyncMarkersSGIX_ARG_NAMES marker, range
#define glDeleteAsyncMarkersSGIX_ARG_EXPAND GLuint marker, GLsizei range
#define glDeleteAsyncMarkersSGIX_PACKED PACKED_glDeleteAsyncMarkersSGIX
#define glDeleteAsyncMarkersSGIX_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glDeleteAsyncMarkersSGIX_NOT_VOID_WRAP(...) {}
#define pack_glDeleteAsyncMarkersSGIX(_marker, _range) ({ \
    glDeleteAsyncMarkersSGIX_PACKED *packed_data = malloc(sizeof(glDeleteAsyncMarkersSGIX_PACKED)); \
    packed_data->index = glDeleteAsyncMarkersSGIX_INDEX; \
    packed_data->args.marker = (GLuint)_marker; \
    packed_data->args.range = (GLsizei)_range; \
    (packed_call_t *)packed_data; \
})
#define call_glDeleteAsyncMarkersSGIX(packed, ret_v) do { \
    PACKED_glDeleteAsyncMarkersSGIX *unpacked = (PACKED_glDeleteAsyncMarkersSGIX *)packed; \
    ARGS_glDeleteAsyncMarkersSGIX *args = (ARGS_glDeleteAsyncMarkersSGIX *)&unpacked->args; \
    glDeleteAsyncMarkersSGIX(args->marker, args->range);; \
} while(0)
void glDeleteAsyncMarkersSGIX(glDeleteAsyncMarkersSGIX_ARG_EXPAND);
typedef void (*glDeleteAsyncMarkersSGIX_PTR)(glDeleteAsyncMarkersSGIX_ARG_EXPAND);
#define glDeleteBuffers_INDEX 428
#define glDeleteBuffers_RETURN void
#define glDeleteBuffers_ARG_NAMES n, buffers
#define glDeleteBuffers_ARG_EXPAND GLsizei n, const GLuint * buffers
#define glDeleteBuffers_PACKED PACKED_glDeleteBuffers
#define glDeleteBuffers_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glDeleteBuffers_NOT_VOID_WRAP(...) {}
#define pack_glDeleteBuffers(_n, _buffers) ({ \
    glDeleteBuffers_PACKED *packed_data = malloc(sizeof(glDeleteBuffers_PACKED)); \
    packed_data->index = glDeleteBuffers_INDEX; \
    packed_data->args.n = (GLsizei)_n; \
    packed_data->args.buffers = (GLuint *)_buffers; \
    (packed_call_t *)packed_data; \
})
#define call_glDeleteBuffers(packed, ret_v) do { \
    PACKED_glDeleteBuffers *unpacked = (PACKED_glDeleteBuffers *)packed; \
    ARGS_glDeleteBuffers *args = (ARGS_glDeleteBuffers *)&unpacked->args; \
    glDeleteBuffers(args->n, args->buffers);; \
} while(0)
void glDeleteBuffers(glDeleteBuffers_ARG_EXPAND);
typedef void (*glDeleteBuffers_PTR)(glDeleteBuffers_ARG_EXPAND);
#define glDeleteBuffersARB_INDEX 429
#define glDeleteBuffersARB_RETURN void
#define glDeleteBuffersARB_ARG_NAMES n, buffers
#define glDeleteBuffersARB_ARG_EXPAND GLsizei n, const GLuint * buffers
#define glDeleteBuffersARB_PACKED PACKED_glDeleteBuffersARB
#define glDeleteBuffersARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glDeleteBuffersARB_NOT_VOID_WRAP(...) {}
#define pack_glDeleteBuffersARB(_n, _buffers) ({ \
    glDeleteBuffersARB_PACKED *packed_data = malloc(sizeof(glDeleteBuffersARB_PACKED)); \
    packed_data->index = glDeleteBuffersARB_INDEX; \
    packed_data->args.n = (GLsizei)_n; \
    packed_data->args.buffers = (GLuint *)_buffers; \
    (packed_call_t *)packed_data; \
})
#define call_glDeleteBuffersARB(packed, ret_v) do { \
    PACKED_glDeleteBuffersARB *unpacked = (PACKED_glDeleteBuffersARB *)packed; \
    ARGS_glDeleteBuffersARB *args = (ARGS_glDeleteBuffersARB *)&unpacked->args; \
    glDeleteBuffersARB(args->n, args->buffers);; \
} while(0)
void glDeleteBuffersARB(glDeleteBuffersARB_ARG_EXPAND);
typedef void (*glDeleteBuffersARB_PTR)(glDeleteBuffersARB_ARG_EXPAND);
#define glDeleteFencesAPPLE_INDEX 430
#define glDeleteFencesAPPLE_RETURN void
#define glDeleteFencesAPPLE_ARG_NAMES n, fences
#define glDeleteFencesAPPLE_ARG_EXPAND GLsizei n, const GLuint * fences
#define glDeleteFencesAPPLE_PACKED PACKED_glDeleteFencesAPPLE
#define glDeleteFencesAPPLE_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glDeleteFencesAPPLE_NOT_VOID_WRAP(...) {}
#define pack_glDeleteFencesAPPLE(_n, _fences) ({ \
    glDeleteFencesAPPLE_PACKED *packed_data = malloc(sizeof(glDeleteFencesAPPLE_PACKED)); \
    packed_data->index = glDeleteFencesAPPLE_INDEX; \
    packed_data->args.n = (GLsizei)_n; \
    packed_data->args.fences = (GLuint *)_fences; \
    (packed_call_t *)packed_data; \
})
#define call_glDeleteFencesAPPLE(packed, ret_v) do { \
    PACKED_glDeleteFencesAPPLE *unpacked = (PACKED_glDeleteFencesAPPLE *)packed; \
    ARGS_glDeleteFencesAPPLE *args = (ARGS_glDeleteFencesAPPLE *)&unpacked->args; \
    glDeleteFencesAPPLE(args->n, args->fences);; \
} while(0)
void glDeleteFencesAPPLE(glDeleteFencesAPPLE_ARG_EXPAND);
typedef void (*glDeleteFencesAPPLE_PTR)(glDeleteFencesAPPLE_ARG_EXPAND);
#define glDeleteFencesNV_INDEX 431
#define glDeleteFencesNV_RETURN void
#define glDeleteFencesNV_ARG_NAMES n, fences
#define glDeleteFencesNV_ARG_EXPAND GLsizei n, const GLuint * fences
#define glDeleteFencesNV_PACKED PACKED_glDeleteFencesNV
#define glDeleteFencesNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glDeleteFencesNV_NOT_VOID_WRAP(...) {}
#define pack_glDeleteFencesNV(_n, _fences) ({ \
    glDeleteFencesNV_PACKED *packed_data = malloc(sizeof(glDeleteFencesNV_PACKED)); \
    packed_data->index = glDeleteFencesNV_INDEX; \
    packed_data->args.n = (GLsizei)_n; \
    packed_data->args.fences = (GLuint *)_fences; \
    (packed_call_t *)packed_data; \
})
#define call_glDeleteFencesNV(packed, ret_v) do { \
    PACKED_glDeleteFencesNV *unpacked = (PACKED_glDeleteFencesNV *)packed; \
    ARGS_glDeleteFencesNV *args = (ARGS_glDeleteFencesNV *)&unpacked->args; \
    glDeleteFencesNV(args->n, args->fences);; \
} while(0)
void glDeleteFencesNV(glDeleteFencesNV_ARG_EXPAND);
typedef void (*glDeleteFencesNV_PTR)(glDeleteFencesNV_ARG_EXPAND);
#define glDeleteFragmentShaderATI_INDEX 432
#define glDeleteFragmentShaderATI_RETURN void
#define glDeleteFragmentShaderATI_ARG_NAMES id
#define glDeleteFragmentShaderATI_ARG_EXPAND GLuint id
#define glDeleteFragmentShaderATI_PACKED PACKED_glDeleteFragmentShaderATI
#define glDeleteFragmentShaderATI_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glDeleteFragmentShaderATI_NOT_VOID_WRAP(...) {}
#define pack_glDeleteFragmentShaderATI(_id) ({ \
    glDeleteFragmentShaderATI_PACKED *packed_data = malloc(sizeof(glDeleteFragmentShaderATI_PACKED)); \
    packed_data->index = glDeleteFragmentShaderATI_INDEX; \
    packed_data->args.id = (GLuint)_id; \
    (packed_call_t *)packed_data; \
})
#define call_glDeleteFragmentShaderATI(packed, ret_v) do { \
    PACKED_glDeleteFragmentShaderATI *unpacked = (PACKED_glDeleteFragmentShaderATI *)packed; \
    ARGS_glDeleteFragmentShaderATI *args = (ARGS_glDeleteFragmentShaderATI *)&unpacked->args; \
    glDeleteFragmentShaderATI(args->id);; \
} while(0)
void glDeleteFragmentShaderATI(glDeleteFragmentShaderATI_ARG_EXPAND);
typedef void (*glDeleteFragmentShaderATI_PTR)(glDeleteFragmentShaderATI_ARG_EXPAND);
#define glDeleteFramebuffers_INDEX 433
#define glDeleteFramebuffers_RETURN void
#define glDeleteFramebuffers_ARG_NAMES n, framebuffers
#define glDeleteFramebuffers_ARG_EXPAND GLsizei n, const GLuint * framebuffers
#define glDeleteFramebuffers_PACKED PACKED_glDeleteFramebuffers
#define glDeleteFramebuffers_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glDeleteFramebuffers_NOT_VOID_WRAP(...) {}
#define pack_glDeleteFramebuffers(_n, _framebuffers) ({ \
    glDeleteFramebuffers_PACKED *packed_data = malloc(sizeof(glDeleteFramebuffers_PACKED)); \
    packed_data->index = glDeleteFramebuffers_INDEX; \
    packed_data->args.n = (GLsizei)_n; \
    packed_data->args.framebuffers = (GLuint *)_framebuffers; \
    (packed_call_t *)packed_data; \
})
#define call_glDeleteFramebuffers(packed, ret_v) do { \
    PACKED_glDeleteFramebuffers *unpacked = (PACKED_glDeleteFramebuffers *)packed; \
    ARGS_glDeleteFramebuffers *args = (ARGS_glDeleteFramebuffers *)&unpacked->args; \
    glDeleteFramebuffers(args->n, args->framebuffers);; \
} while(0)
void glDeleteFramebuffers(glDeleteFramebuffers_ARG_EXPAND);
typedef void (*glDeleteFramebuffers_PTR)(glDeleteFramebuffers_ARG_EXPAND);
#define glDeleteFramebuffersEXT_INDEX 434
#define glDeleteFramebuffersEXT_RETURN void
#define glDeleteFramebuffersEXT_ARG_NAMES n, framebuffers
#define glDeleteFramebuffersEXT_ARG_EXPAND GLsizei n, const GLuint * framebuffers
#define glDeleteFramebuffersEXT_PACKED PACKED_glDeleteFramebuffersEXT
#define glDeleteFramebuffersEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glDeleteFramebuffersEXT_NOT_VOID_WRAP(...) {}
#define pack_glDeleteFramebuffersEXT(_n, _framebuffers) ({ \
    glDeleteFramebuffersEXT_PACKED *packed_data = malloc(sizeof(glDeleteFramebuffersEXT_PACKED)); \
    packed_data->index = glDeleteFramebuffersEXT_INDEX; \
    packed_data->args.n = (GLsizei)_n; \
    packed_data->args.framebuffers = (GLuint *)_framebuffers; \
    (packed_call_t *)packed_data; \
})
#define call_glDeleteFramebuffersEXT(packed, ret_v) do { \
    PACKED_glDeleteFramebuffersEXT *unpacked = (PACKED_glDeleteFramebuffersEXT *)packed; \
    ARGS_glDeleteFramebuffersEXT *args = (ARGS_glDeleteFramebuffersEXT *)&unpacked->args; \
    glDeleteFramebuffersEXT(args->n, args->framebuffers);; \
} while(0)
void glDeleteFramebuffersEXT(glDeleteFramebuffersEXT_ARG_EXPAND);
typedef void (*glDeleteFramebuffersEXT_PTR)(glDeleteFramebuffersEXT_ARG_EXPAND);
#define glDeleteLists_INDEX 435
#define glDeleteLists_RETURN void
#define glDeleteLists_ARG_NAMES list, range
#define glDeleteLists_ARG_EXPAND GLuint list, GLsizei range
#define glDeleteLists_PACKED PACKED_glDeleteLists
#define glDeleteLists_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glDeleteLists_NOT_VOID_WRAP(...) {}
#define pack_glDeleteLists(_list, _range) ({ \
    glDeleteLists_PACKED *packed_data = malloc(sizeof(glDeleteLists_PACKED)); \
    packed_data->index = glDeleteLists_INDEX; \
    packed_data->args.list = (GLuint)_list; \
    packed_data->args.range = (GLsizei)_range; \
    (packed_call_t *)packed_data; \
})
#define call_glDeleteLists(packed, ret_v) do { \
    PACKED_glDeleteLists *unpacked = (PACKED_glDeleteLists *)packed; \
    ARGS_glDeleteLists *args = (ARGS_glDeleteLists *)&unpacked->args; \
    glDeleteLists(args->list, args->range);; \
} while(0)
void glDeleteLists(glDeleteLists_ARG_EXPAND);
typedef void (*glDeleteLists_PTR)(glDeleteLists_ARG_EXPAND);
#define glDeleteNamedStringARB_INDEX 436
#define glDeleteNamedStringARB_RETURN void
#define glDeleteNamedStringARB_ARG_NAMES namelen, name
#define glDeleteNamedStringARB_ARG_EXPAND GLint namelen, const GLchar * name
#define glDeleteNamedStringARB_PACKED PACKED_glDeleteNamedStringARB
#define glDeleteNamedStringARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glDeleteNamedStringARB_NOT_VOID_WRAP(...) {}
#define pack_glDeleteNamedStringARB(_namelen, _name) ({ \
    glDeleteNamedStringARB_PACKED *packed_data = malloc(sizeof(glDeleteNamedStringARB_PACKED)); \
    packed_data->index = glDeleteNamedStringARB_INDEX; \
    packed_data->args.namelen = (GLint)_namelen; \
    packed_data->args.name = (GLchar *)_name; \
    (packed_call_t *)packed_data; \
})
#define call_glDeleteNamedStringARB(packed, ret_v) do { \
    PACKED_glDeleteNamedStringARB *unpacked = (PACKED_glDeleteNamedStringARB *)packed; \
    ARGS_glDeleteNamedStringARB *args = (ARGS_glDeleteNamedStringARB *)&unpacked->args; \
    glDeleteNamedStringARB(args->namelen, args->name);; \
} while(0)
void glDeleteNamedStringARB(glDeleteNamedStringARB_ARG_EXPAND);
typedef void (*glDeleteNamedStringARB_PTR)(glDeleteNamedStringARB_ARG_EXPAND);
#define glDeleteNamesAMD_INDEX 437
#define glDeleteNamesAMD_RETURN void
#define glDeleteNamesAMD_ARG_NAMES identifier, num, names
#define glDeleteNamesAMD_ARG_EXPAND GLenum identifier, GLuint num, const GLuint * names
#define glDeleteNamesAMD_PACKED PACKED_glDeleteNamesAMD
#define glDeleteNamesAMD_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glDeleteNamesAMD_NOT_VOID_WRAP(...) {}
#define pack_glDeleteNamesAMD(_identifier, _num, _names) ({ \
    glDeleteNamesAMD_PACKED *packed_data = malloc(sizeof(glDeleteNamesAMD_PACKED)); \
    packed_data->index = glDeleteNamesAMD_INDEX; \
    packed_data->args.identifier = (GLenum)_identifier; \
    packed_data->args.num = (GLuint)_num; \
    packed_data->args.names = (GLuint *)_names; \
    (packed_call_t *)packed_data; \
})
#define call_glDeleteNamesAMD(packed, ret_v) do { \
    PACKED_glDeleteNamesAMD *unpacked = (PACKED_glDeleteNamesAMD *)packed; \
    ARGS_glDeleteNamesAMD *args = (ARGS_glDeleteNamesAMD *)&unpacked->args; \
    glDeleteNamesAMD(args->identifier, args->num, args->names);; \
} while(0)
void glDeleteNamesAMD(glDeleteNamesAMD_ARG_EXPAND);
typedef void (*glDeleteNamesAMD_PTR)(glDeleteNamesAMD_ARG_EXPAND);
#define glDeleteObjectARB_INDEX 438
#define glDeleteObjectARB_RETURN void
#define glDeleteObjectARB_ARG_NAMES obj
#define glDeleteObjectARB_ARG_EXPAND GLhandleARB obj
#define glDeleteObjectARB_PACKED PACKED_glDeleteObjectARB
#define glDeleteObjectARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glDeleteObjectARB_NOT_VOID_WRAP(...) {}
#define pack_glDeleteObjectARB(_obj) ({ \
    glDeleteObjectARB_PACKED *packed_data = malloc(sizeof(glDeleteObjectARB_PACKED)); \
    packed_data->index = glDeleteObjectARB_INDEX; \
    packed_data->args.obj = (GLhandleARB)_obj; \
    (packed_call_t *)packed_data; \
})
#define call_glDeleteObjectARB(packed, ret_v) do { \
    PACKED_glDeleteObjectARB *unpacked = (PACKED_glDeleteObjectARB *)packed; \
    ARGS_glDeleteObjectARB *args = (ARGS_glDeleteObjectARB *)&unpacked->args; \
    glDeleteObjectARB(args->obj);; \
} while(0)
void glDeleteObjectARB(glDeleteObjectARB_ARG_EXPAND);
typedef void (*glDeleteObjectARB_PTR)(glDeleteObjectARB_ARG_EXPAND);
#define glDeleteOcclusionQueriesNV_INDEX 439
#define glDeleteOcclusionQueriesNV_RETURN void
#define glDeleteOcclusionQueriesNV_ARG_NAMES n, ids
#define glDeleteOcclusionQueriesNV_ARG_EXPAND GLsizei n, const GLuint * ids
#define glDeleteOcclusionQueriesNV_PACKED PACKED_glDeleteOcclusionQueriesNV
#define glDeleteOcclusionQueriesNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glDeleteOcclusionQueriesNV_NOT_VOID_WRAP(...) {}
#define pack_glDeleteOcclusionQueriesNV(_n, _ids) ({ \
    glDeleteOcclusionQueriesNV_PACKED *packed_data = malloc(sizeof(glDeleteOcclusionQueriesNV_PACKED)); \
    packed_data->index = glDeleteOcclusionQueriesNV_INDEX; \
    packed_data->args.n = (GLsizei)_n; \
    packed_data->args.ids = (GLuint *)_ids; \
    (packed_call_t *)packed_data; \
})
#define call_glDeleteOcclusionQueriesNV(packed, ret_v) do { \
    PACKED_glDeleteOcclusionQueriesNV *unpacked = (PACKED_glDeleteOcclusionQueriesNV *)packed; \
    ARGS_glDeleteOcclusionQueriesNV *args = (ARGS_glDeleteOcclusionQueriesNV *)&unpacked->args; \
    glDeleteOcclusionQueriesNV(args->n, args->ids);; \
} while(0)
void glDeleteOcclusionQueriesNV(glDeleteOcclusionQueriesNV_ARG_EXPAND);
typedef void (*glDeleteOcclusionQueriesNV_PTR)(glDeleteOcclusionQueriesNV_ARG_EXPAND);
#define glDeletePathsNV_INDEX 440
#define glDeletePathsNV_RETURN void
#define glDeletePathsNV_ARG_NAMES path, range
#define glDeletePathsNV_ARG_EXPAND GLuint path, GLsizei range
#define glDeletePathsNV_PACKED PACKED_glDeletePathsNV
#define glDeletePathsNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glDeletePathsNV_NOT_VOID_WRAP(...) {}
#define pack_glDeletePathsNV(_path, _range) ({ \
    glDeletePathsNV_PACKED *packed_data = malloc(sizeof(glDeletePathsNV_PACKED)); \
    packed_data->index = glDeletePathsNV_INDEX; \
    packed_data->args.path = (GLuint)_path; \
    packed_data->args.range = (GLsizei)_range; \
    (packed_call_t *)packed_data; \
})
#define call_glDeletePathsNV(packed, ret_v) do { \
    PACKED_glDeletePathsNV *unpacked = (PACKED_glDeletePathsNV *)packed; \
    ARGS_glDeletePathsNV *args = (ARGS_glDeletePathsNV *)&unpacked->args; \
    glDeletePathsNV(args->path, args->range);; \
} while(0)
void glDeletePathsNV(glDeletePathsNV_ARG_EXPAND);
typedef void (*glDeletePathsNV_PTR)(glDeletePathsNV_ARG_EXPAND);
#define glDeletePerfMonitorsAMD_INDEX 441
#define glDeletePerfMonitorsAMD_RETURN void
#define glDeletePerfMonitorsAMD_ARG_NAMES n, monitors
#define glDeletePerfMonitorsAMD_ARG_EXPAND GLsizei n, GLuint * monitors
#define glDeletePerfMonitorsAMD_PACKED PACKED_glDeletePerfMonitorsAMD
#define glDeletePerfMonitorsAMD_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glDeletePerfMonitorsAMD_NOT_VOID_WRAP(...) {}
#define pack_glDeletePerfMonitorsAMD(_n, _monitors) ({ \
    glDeletePerfMonitorsAMD_PACKED *packed_data = malloc(sizeof(glDeletePerfMonitorsAMD_PACKED)); \
    packed_data->index = glDeletePerfMonitorsAMD_INDEX; \
    packed_data->args.n = (GLsizei)_n; \
    packed_data->args.monitors = (GLuint *)_monitors; \
    (packed_call_t *)packed_data; \
})
#define call_glDeletePerfMonitorsAMD(packed, ret_v) do { \
    PACKED_glDeletePerfMonitorsAMD *unpacked = (PACKED_glDeletePerfMonitorsAMD *)packed; \
    ARGS_glDeletePerfMonitorsAMD *args = (ARGS_glDeletePerfMonitorsAMD *)&unpacked->args; \
    glDeletePerfMonitorsAMD(args->n, args->monitors);; \
} while(0)
void glDeletePerfMonitorsAMD(glDeletePerfMonitorsAMD_ARG_EXPAND);
typedef void (*glDeletePerfMonitorsAMD_PTR)(glDeletePerfMonitorsAMD_ARG_EXPAND);
#define glDeleteProgram_INDEX 442
#define glDeleteProgram_RETURN void
#define glDeleteProgram_ARG_NAMES program
#define glDeleteProgram_ARG_EXPAND GLuint program
#define glDeleteProgram_PACKED PACKED_glDeleteProgram
#define glDeleteProgram_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glDeleteProgram_NOT_VOID_WRAP(...) {}
#define pack_glDeleteProgram(_program) ({ \
    glDeleteProgram_PACKED *packed_data = malloc(sizeof(glDeleteProgram_PACKED)); \
    packed_data->index = glDeleteProgram_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    (packed_call_t *)packed_data; \
})
#define call_glDeleteProgram(packed, ret_v) do { \
    PACKED_glDeleteProgram *unpacked = (PACKED_glDeleteProgram *)packed; \
    ARGS_glDeleteProgram *args = (ARGS_glDeleteProgram *)&unpacked->args; \
    glDeleteProgram(args->program);; \
} while(0)
void glDeleteProgram(glDeleteProgram_ARG_EXPAND);
typedef void (*glDeleteProgram_PTR)(glDeleteProgram_ARG_EXPAND);
#define glDeleteProgramPipelines_INDEX 443
#define glDeleteProgramPipelines_RETURN void
#define glDeleteProgramPipelines_ARG_NAMES n, pipelines
#define glDeleteProgramPipelines_ARG_EXPAND GLsizei n, const GLuint * pipelines
#define glDeleteProgramPipelines_PACKED PACKED_glDeleteProgramPipelines
#define glDeleteProgramPipelines_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glDeleteProgramPipelines_NOT_VOID_WRAP(...) {}
#define pack_glDeleteProgramPipelines(_n, _pipelines) ({ \
    glDeleteProgramPipelines_PACKED *packed_data = malloc(sizeof(glDeleteProgramPipelines_PACKED)); \
    packed_data->index = glDeleteProgramPipelines_INDEX; \
    packed_data->args.n = (GLsizei)_n; \
    packed_data->args.pipelines = (GLuint *)_pipelines; \
    (packed_call_t *)packed_data; \
})
#define call_glDeleteProgramPipelines(packed, ret_v) do { \
    PACKED_glDeleteProgramPipelines *unpacked = (PACKED_glDeleteProgramPipelines *)packed; \
    ARGS_glDeleteProgramPipelines *args = (ARGS_glDeleteProgramPipelines *)&unpacked->args; \
    glDeleteProgramPipelines(args->n, args->pipelines);; \
} while(0)
void glDeleteProgramPipelines(glDeleteProgramPipelines_ARG_EXPAND);
typedef void (*glDeleteProgramPipelines_PTR)(glDeleteProgramPipelines_ARG_EXPAND);
#define glDeleteProgramsARB_INDEX 444
#define glDeleteProgramsARB_RETURN void
#define glDeleteProgramsARB_ARG_NAMES n, programs
#define glDeleteProgramsARB_ARG_EXPAND GLsizei n, const GLuint * programs
#define glDeleteProgramsARB_PACKED PACKED_glDeleteProgramsARB
#define glDeleteProgramsARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glDeleteProgramsARB_NOT_VOID_WRAP(...) {}
#define pack_glDeleteProgramsARB(_n, _programs) ({ \
    glDeleteProgramsARB_PACKED *packed_data = malloc(sizeof(glDeleteProgramsARB_PACKED)); \
    packed_data->index = glDeleteProgramsARB_INDEX; \
    packed_data->args.n = (GLsizei)_n; \
    packed_data->args.programs = (GLuint *)_programs; \
    (packed_call_t *)packed_data; \
})
#define call_glDeleteProgramsARB(packed, ret_v) do { \
    PACKED_glDeleteProgramsARB *unpacked = (PACKED_glDeleteProgramsARB *)packed; \
    ARGS_glDeleteProgramsARB *args = (ARGS_glDeleteProgramsARB *)&unpacked->args; \
    glDeleteProgramsARB(args->n, args->programs);; \
} while(0)
void glDeleteProgramsARB(glDeleteProgramsARB_ARG_EXPAND);
typedef void (*glDeleteProgramsARB_PTR)(glDeleteProgramsARB_ARG_EXPAND);
#define glDeleteProgramsNV_INDEX 445
#define glDeleteProgramsNV_RETURN void
#define glDeleteProgramsNV_ARG_NAMES n, programs
#define glDeleteProgramsNV_ARG_EXPAND GLsizei n, const GLuint * programs
#define glDeleteProgramsNV_PACKED PACKED_glDeleteProgramsNV
#define glDeleteProgramsNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glDeleteProgramsNV_NOT_VOID_WRAP(...) {}
#define pack_glDeleteProgramsNV(_n, _programs) ({ \
    glDeleteProgramsNV_PACKED *packed_data = malloc(sizeof(glDeleteProgramsNV_PACKED)); \
    packed_data->index = glDeleteProgramsNV_INDEX; \
    packed_data->args.n = (GLsizei)_n; \
    packed_data->args.programs = (GLuint *)_programs; \
    (packed_call_t *)packed_data; \
})
#define call_glDeleteProgramsNV(packed, ret_v) do { \
    PACKED_glDeleteProgramsNV *unpacked = (PACKED_glDeleteProgramsNV *)packed; \
    ARGS_glDeleteProgramsNV *args = (ARGS_glDeleteProgramsNV *)&unpacked->args; \
    glDeleteProgramsNV(args->n, args->programs);; \
} while(0)
void glDeleteProgramsNV(glDeleteProgramsNV_ARG_EXPAND);
typedef void (*glDeleteProgramsNV_PTR)(glDeleteProgramsNV_ARG_EXPAND);
#define glDeleteQueries_INDEX 446
#define glDeleteQueries_RETURN void
#define glDeleteQueries_ARG_NAMES n, ids
#define glDeleteQueries_ARG_EXPAND GLsizei n, const GLuint * ids
#define glDeleteQueries_PACKED PACKED_glDeleteQueries
#define glDeleteQueries_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glDeleteQueries_NOT_VOID_WRAP(...) {}
#define pack_glDeleteQueries(_n, _ids) ({ \
    glDeleteQueries_PACKED *packed_data = malloc(sizeof(glDeleteQueries_PACKED)); \
    packed_data->index = glDeleteQueries_INDEX; \
    packed_data->args.n = (GLsizei)_n; \
    packed_data->args.ids = (GLuint *)_ids; \
    (packed_call_t *)packed_data; \
})
#define call_glDeleteQueries(packed, ret_v) do { \
    PACKED_glDeleteQueries *unpacked = (PACKED_glDeleteQueries *)packed; \
    ARGS_glDeleteQueries *args = (ARGS_glDeleteQueries *)&unpacked->args; \
    glDeleteQueries(args->n, args->ids);; \
} while(0)
void glDeleteQueries(glDeleteQueries_ARG_EXPAND);
typedef void (*glDeleteQueries_PTR)(glDeleteQueries_ARG_EXPAND);
#define glDeleteQueriesARB_INDEX 447
#define glDeleteQueriesARB_RETURN void
#define glDeleteQueriesARB_ARG_NAMES n, ids
#define glDeleteQueriesARB_ARG_EXPAND GLsizei n, const GLuint * ids
#define glDeleteQueriesARB_PACKED PACKED_glDeleteQueriesARB
#define glDeleteQueriesARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glDeleteQueriesARB_NOT_VOID_WRAP(...) {}
#define pack_glDeleteQueriesARB(_n, _ids) ({ \
    glDeleteQueriesARB_PACKED *packed_data = malloc(sizeof(glDeleteQueriesARB_PACKED)); \
    packed_data->index = glDeleteQueriesARB_INDEX; \
    packed_data->args.n = (GLsizei)_n; \
    packed_data->args.ids = (GLuint *)_ids; \
    (packed_call_t *)packed_data; \
})
#define call_glDeleteQueriesARB(packed, ret_v) do { \
    PACKED_glDeleteQueriesARB *unpacked = (PACKED_glDeleteQueriesARB *)packed; \
    ARGS_glDeleteQueriesARB *args = (ARGS_glDeleteQueriesARB *)&unpacked->args; \
    glDeleteQueriesARB(args->n, args->ids);; \
} while(0)
void glDeleteQueriesARB(glDeleteQueriesARB_ARG_EXPAND);
typedef void (*glDeleteQueriesARB_PTR)(glDeleteQueriesARB_ARG_EXPAND);
#define glDeleteRenderbuffers_INDEX 448
#define glDeleteRenderbuffers_RETURN void
#define glDeleteRenderbuffers_ARG_NAMES n, renderbuffers
#define glDeleteRenderbuffers_ARG_EXPAND GLsizei n, const GLuint * renderbuffers
#define glDeleteRenderbuffers_PACKED PACKED_glDeleteRenderbuffers
#define glDeleteRenderbuffers_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glDeleteRenderbuffers_NOT_VOID_WRAP(...) {}
#define pack_glDeleteRenderbuffers(_n, _renderbuffers) ({ \
    glDeleteRenderbuffers_PACKED *packed_data = malloc(sizeof(glDeleteRenderbuffers_PACKED)); \
    packed_data->index = glDeleteRenderbuffers_INDEX; \
    packed_data->args.n = (GLsizei)_n; \
    packed_data->args.renderbuffers = (GLuint *)_renderbuffers; \
    (packed_call_t *)packed_data; \
})
#define call_glDeleteRenderbuffers(packed, ret_v) do { \
    PACKED_glDeleteRenderbuffers *unpacked = (PACKED_glDeleteRenderbuffers *)packed; \
    ARGS_glDeleteRenderbuffers *args = (ARGS_glDeleteRenderbuffers *)&unpacked->args; \
    glDeleteRenderbuffers(args->n, args->renderbuffers);; \
} while(0)
void glDeleteRenderbuffers(glDeleteRenderbuffers_ARG_EXPAND);
typedef void (*glDeleteRenderbuffers_PTR)(glDeleteRenderbuffers_ARG_EXPAND);
#define glDeleteRenderbuffersEXT_INDEX 449
#define glDeleteRenderbuffersEXT_RETURN void
#define glDeleteRenderbuffersEXT_ARG_NAMES n, renderbuffers
#define glDeleteRenderbuffersEXT_ARG_EXPAND GLsizei n, const GLuint * renderbuffers
#define glDeleteRenderbuffersEXT_PACKED PACKED_glDeleteRenderbuffersEXT
#define glDeleteRenderbuffersEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glDeleteRenderbuffersEXT_NOT_VOID_WRAP(...) {}
#define pack_glDeleteRenderbuffersEXT(_n, _renderbuffers) ({ \
    glDeleteRenderbuffersEXT_PACKED *packed_data = malloc(sizeof(glDeleteRenderbuffersEXT_PACKED)); \
    packed_data->index = glDeleteRenderbuffersEXT_INDEX; \
    packed_data->args.n = (GLsizei)_n; \
    packed_data->args.renderbuffers = (GLuint *)_renderbuffers; \
    (packed_call_t *)packed_data; \
})
#define call_glDeleteRenderbuffersEXT(packed, ret_v) do { \
    PACKED_glDeleteRenderbuffersEXT *unpacked = (PACKED_glDeleteRenderbuffersEXT *)packed; \
    ARGS_glDeleteRenderbuffersEXT *args = (ARGS_glDeleteRenderbuffersEXT *)&unpacked->args; \
    glDeleteRenderbuffersEXT(args->n, args->renderbuffers);; \
} while(0)
void glDeleteRenderbuffersEXT(glDeleteRenderbuffersEXT_ARG_EXPAND);
typedef void (*glDeleteRenderbuffersEXT_PTR)(glDeleteRenderbuffersEXT_ARG_EXPAND);
#define glDeleteSamplers_INDEX 450
#define glDeleteSamplers_RETURN void
#define glDeleteSamplers_ARG_NAMES count, samplers
#define glDeleteSamplers_ARG_EXPAND GLsizei count, const GLuint * samplers
#define glDeleteSamplers_PACKED PACKED_glDeleteSamplers
#define glDeleteSamplers_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glDeleteSamplers_NOT_VOID_WRAP(...) {}
#define pack_glDeleteSamplers(_count, _samplers) ({ \
    glDeleteSamplers_PACKED *packed_data = malloc(sizeof(glDeleteSamplers_PACKED)); \
    packed_data->index = glDeleteSamplers_INDEX; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.samplers = (GLuint *)_samplers; \
    (packed_call_t *)packed_data; \
})
#define call_glDeleteSamplers(packed, ret_v) do { \
    PACKED_glDeleteSamplers *unpacked = (PACKED_glDeleteSamplers *)packed; \
    ARGS_glDeleteSamplers *args = (ARGS_glDeleteSamplers *)&unpacked->args; \
    glDeleteSamplers(args->count, args->samplers);; \
} while(0)
void glDeleteSamplers(glDeleteSamplers_ARG_EXPAND);
typedef void (*glDeleteSamplers_PTR)(glDeleteSamplers_ARG_EXPAND);
#define glDeleteShader_INDEX 451
#define glDeleteShader_RETURN void
#define glDeleteShader_ARG_NAMES shader
#define glDeleteShader_ARG_EXPAND GLuint shader
#define glDeleteShader_PACKED PACKED_glDeleteShader
#define glDeleteShader_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glDeleteShader_NOT_VOID_WRAP(...) {}
#define pack_glDeleteShader(_shader) ({ \
    glDeleteShader_PACKED *packed_data = malloc(sizeof(glDeleteShader_PACKED)); \
    packed_data->index = glDeleteShader_INDEX; \
    packed_data->args.shader = (GLuint)_shader; \
    (packed_call_t *)packed_data; \
})
#define call_glDeleteShader(packed, ret_v) do { \
    PACKED_glDeleteShader *unpacked = (PACKED_glDeleteShader *)packed; \
    ARGS_glDeleteShader *args = (ARGS_glDeleteShader *)&unpacked->args; \
    glDeleteShader(args->shader);; \
} while(0)
void glDeleteShader(glDeleteShader_ARG_EXPAND);
typedef void (*glDeleteShader_PTR)(glDeleteShader_ARG_EXPAND);
#define glDeleteSync_INDEX 452
#define glDeleteSync_RETURN void
#define glDeleteSync_ARG_NAMES sync
#define glDeleteSync_ARG_EXPAND GLsync sync
#define glDeleteSync_PACKED PACKED_glDeleteSync
#define glDeleteSync_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glDeleteSync_NOT_VOID_WRAP(...) {}
#define pack_glDeleteSync(_sync) ({ \
    glDeleteSync_PACKED *packed_data = malloc(sizeof(glDeleteSync_PACKED)); \
    packed_data->index = glDeleteSync_INDEX; \
    packed_data->args.sync = (GLsync)_sync; \
    (packed_call_t *)packed_data; \
})
#define call_glDeleteSync(packed, ret_v) do { \
    PACKED_glDeleteSync *unpacked = (PACKED_glDeleteSync *)packed; \
    ARGS_glDeleteSync *args = (ARGS_glDeleteSync *)&unpacked->args; \
    glDeleteSync(args->sync);; \
} while(0)
void glDeleteSync(glDeleteSync_ARG_EXPAND);
typedef void (*glDeleteSync_PTR)(glDeleteSync_ARG_EXPAND);
#define glDeleteTextures_INDEX 453
#define glDeleteTextures_RETURN void
#define glDeleteTextures_ARG_NAMES n, textures
#define glDeleteTextures_ARG_EXPAND GLsizei n, const GLuint * textures
#define glDeleteTextures_PACKED PACKED_glDeleteTextures
#define glDeleteTextures_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glDeleteTextures_NOT_VOID_WRAP(...) {}
#define pack_glDeleteTextures(_n, _textures) ({ \
    glDeleteTextures_PACKED *packed_data = malloc(sizeof(glDeleteTextures_PACKED)); \
    packed_data->index = glDeleteTextures_INDEX; \
    packed_data->args.n = (GLsizei)_n; \
    packed_data->args.textures = (GLuint *)_textures; \
    (packed_call_t *)packed_data; \
})
#define call_glDeleteTextures(packed, ret_v) do { \
    PACKED_glDeleteTextures *unpacked = (PACKED_glDeleteTextures *)packed; \
    ARGS_glDeleteTextures *args = (ARGS_glDeleteTextures *)&unpacked->args; \
    glDeleteTextures(args->n, args->textures);; \
} while(0)
void glDeleteTextures(glDeleteTextures_ARG_EXPAND);
typedef void (*glDeleteTextures_PTR)(glDeleteTextures_ARG_EXPAND);
#define glDeleteTexturesEXT_INDEX 454
#define glDeleteTexturesEXT_RETURN void
#define glDeleteTexturesEXT_ARG_NAMES n, textures
#define glDeleteTexturesEXT_ARG_EXPAND GLsizei n, const GLuint * textures
#define glDeleteTexturesEXT_PACKED PACKED_glDeleteTexturesEXT
#define glDeleteTexturesEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glDeleteTexturesEXT_NOT_VOID_WRAP(...) {}
#define pack_glDeleteTexturesEXT(_n, _textures) ({ \
    glDeleteTexturesEXT_PACKED *packed_data = malloc(sizeof(glDeleteTexturesEXT_PACKED)); \
    packed_data->index = glDeleteTexturesEXT_INDEX; \
    packed_data->args.n = (GLsizei)_n; \
    packed_data->args.textures = (GLuint *)_textures; \
    (packed_call_t *)packed_data; \
})
#define call_glDeleteTexturesEXT(packed, ret_v) do { \
    PACKED_glDeleteTexturesEXT *unpacked = (PACKED_glDeleteTexturesEXT *)packed; \
    ARGS_glDeleteTexturesEXT *args = (ARGS_glDeleteTexturesEXT *)&unpacked->args; \
    glDeleteTexturesEXT(args->n, args->textures);; \
} while(0)
void glDeleteTexturesEXT(glDeleteTexturesEXT_ARG_EXPAND);
typedef void (*glDeleteTexturesEXT_PTR)(glDeleteTexturesEXT_ARG_EXPAND);
#define glDeleteTransformFeedbacks_INDEX 455
#define glDeleteTransformFeedbacks_RETURN void
#define glDeleteTransformFeedbacks_ARG_NAMES n, ids
#define glDeleteTransformFeedbacks_ARG_EXPAND GLsizei n, const GLuint * ids
#define glDeleteTransformFeedbacks_PACKED PACKED_glDeleteTransformFeedbacks
#define glDeleteTransformFeedbacks_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glDeleteTransformFeedbacks_NOT_VOID_WRAP(...) {}
#define pack_glDeleteTransformFeedbacks(_n, _ids) ({ \
    glDeleteTransformFeedbacks_PACKED *packed_data = malloc(sizeof(glDeleteTransformFeedbacks_PACKED)); \
    packed_data->index = glDeleteTransformFeedbacks_INDEX; \
    packed_data->args.n = (GLsizei)_n; \
    packed_data->args.ids = (GLuint *)_ids; \
    (packed_call_t *)packed_data; \
})
#define call_glDeleteTransformFeedbacks(packed, ret_v) do { \
    PACKED_glDeleteTransformFeedbacks *unpacked = (PACKED_glDeleteTransformFeedbacks *)packed; \
    ARGS_glDeleteTransformFeedbacks *args = (ARGS_glDeleteTransformFeedbacks *)&unpacked->args; \
    glDeleteTransformFeedbacks(args->n, args->ids);; \
} while(0)
void glDeleteTransformFeedbacks(glDeleteTransformFeedbacks_ARG_EXPAND);
typedef void (*glDeleteTransformFeedbacks_PTR)(glDeleteTransformFeedbacks_ARG_EXPAND);
#define glDeleteTransformFeedbacksNV_INDEX 456
#define glDeleteTransformFeedbacksNV_RETURN void
#define glDeleteTransformFeedbacksNV_ARG_NAMES n, ids
#define glDeleteTransformFeedbacksNV_ARG_EXPAND GLsizei n, const GLuint * ids
#define glDeleteTransformFeedbacksNV_PACKED PACKED_glDeleteTransformFeedbacksNV
#define glDeleteTransformFeedbacksNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glDeleteTransformFeedbacksNV_NOT_VOID_WRAP(...) {}
#define pack_glDeleteTransformFeedbacksNV(_n, _ids) ({ \
    glDeleteTransformFeedbacksNV_PACKED *packed_data = malloc(sizeof(glDeleteTransformFeedbacksNV_PACKED)); \
    packed_data->index = glDeleteTransformFeedbacksNV_INDEX; \
    packed_data->args.n = (GLsizei)_n; \
    packed_data->args.ids = (GLuint *)_ids; \
    (packed_call_t *)packed_data; \
})
#define call_glDeleteTransformFeedbacksNV(packed, ret_v) do { \
    PACKED_glDeleteTransformFeedbacksNV *unpacked = (PACKED_glDeleteTransformFeedbacksNV *)packed; \
    ARGS_glDeleteTransformFeedbacksNV *args = (ARGS_glDeleteTransformFeedbacksNV *)&unpacked->args; \
    glDeleteTransformFeedbacksNV(args->n, args->ids);; \
} while(0)
void glDeleteTransformFeedbacksNV(glDeleteTransformFeedbacksNV_ARG_EXPAND);
typedef void (*glDeleteTransformFeedbacksNV_PTR)(glDeleteTransformFeedbacksNV_ARG_EXPAND);
#define glDeleteVertexArrays_INDEX 457
#define glDeleteVertexArrays_RETURN void
#define glDeleteVertexArrays_ARG_NAMES n, arrays
#define glDeleteVertexArrays_ARG_EXPAND GLsizei n, const GLuint * arrays
#define glDeleteVertexArrays_PACKED PACKED_glDeleteVertexArrays
#define glDeleteVertexArrays_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glDeleteVertexArrays_NOT_VOID_WRAP(...) {}
#define pack_glDeleteVertexArrays(_n, _arrays) ({ \
    glDeleteVertexArrays_PACKED *packed_data = malloc(sizeof(glDeleteVertexArrays_PACKED)); \
    packed_data->index = glDeleteVertexArrays_INDEX; \
    packed_data->args.n = (GLsizei)_n; \
    packed_data->args.arrays = (GLuint *)_arrays; \
    (packed_call_t *)packed_data; \
})
#define call_glDeleteVertexArrays(packed, ret_v) do { \
    PACKED_glDeleteVertexArrays *unpacked = (PACKED_glDeleteVertexArrays *)packed; \
    ARGS_glDeleteVertexArrays *args = (ARGS_glDeleteVertexArrays *)&unpacked->args; \
    glDeleteVertexArrays(args->n, args->arrays);; \
} while(0)
void glDeleteVertexArrays(glDeleteVertexArrays_ARG_EXPAND);
typedef void (*glDeleteVertexArrays_PTR)(glDeleteVertexArrays_ARG_EXPAND);
#define glDeleteVertexArraysAPPLE_INDEX 458
#define glDeleteVertexArraysAPPLE_RETURN void
#define glDeleteVertexArraysAPPLE_ARG_NAMES n, arrays
#define glDeleteVertexArraysAPPLE_ARG_EXPAND GLsizei n, const GLuint * arrays
#define glDeleteVertexArraysAPPLE_PACKED PACKED_glDeleteVertexArraysAPPLE
#define glDeleteVertexArraysAPPLE_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glDeleteVertexArraysAPPLE_NOT_VOID_WRAP(...) {}
#define pack_glDeleteVertexArraysAPPLE(_n, _arrays) ({ \
    glDeleteVertexArraysAPPLE_PACKED *packed_data = malloc(sizeof(glDeleteVertexArraysAPPLE_PACKED)); \
    packed_data->index = glDeleteVertexArraysAPPLE_INDEX; \
    packed_data->args.n = (GLsizei)_n; \
    packed_data->args.arrays = (GLuint *)_arrays; \
    (packed_call_t *)packed_data; \
})
#define call_glDeleteVertexArraysAPPLE(packed, ret_v) do { \
    PACKED_glDeleteVertexArraysAPPLE *unpacked = (PACKED_glDeleteVertexArraysAPPLE *)packed; \
    ARGS_glDeleteVertexArraysAPPLE *args = (ARGS_glDeleteVertexArraysAPPLE *)&unpacked->args; \
    glDeleteVertexArraysAPPLE(args->n, args->arrays);; \
} while(0)
void glDeleteVertexArraysAPPLE(glDeleteVertexArraysAPPLE_ARG_EXPAND);
typedef void (*glDeleteVertexArraysAPPLE_PTR)(glDeleteVertexArraysAPPLE_ARG_EXPAND);
#define glDeleteVertexShaderEXT_INDEX 459
#define glDeleteVertexShaderEXT_RETURN void
#define glDeleteVertexShaderEXT_ARG_NAMES id
#define glDeleteVertexShaderEXT_ARG_EXPAND GLuint id
#define glDeleteVertexShaderEXT_PACKED PACKED_glDeleteVertexShaderEXT
#define glDeleteVertexShaderEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glDeleteVertexShaderEXT_NOT_VOID_WRAP(...) {}
#define pack_glDeleteVertexShaderEXT(_id) ({ \
    glDeleteVertexShaderEXT_PACKED *packed_data = malloc(sizeof(glDeleteVertexShaderEXT_PACKED)); \
    packed_data->index = glDeleteVertexShaderEXT_INDEX; \
    packed_data->args.id = (GLuint)_id; \
    (packed_call_t *)packed_data; \
})
#define call_glDeleteVertexShaderEXT(packed, ret_v) do { \
    PACKED_glDeleteVertexShaderEXT *unpacked = (PACKED_glDeleteVertexShaderEXT *)packed; \
    ARGS_glDeleteVertexShaderEXT *args = (ARGS_glDeleteVertexShaderEXT *)&unpacked->args; \
    glDeleteVertexShaderEXT(args->id);; \
} while(0)
void glDeleteVertexShaderEXT(glDeleteVertexShaderEXT_ARG_EXPAND);
typedef void (*glDeleteVertexShaderEXT_PTR)(glDeleteVertexShaderEXT_ARG_EXPAND);
#define glDepthBoundsEXT_INDEX 460
#define glDepthBoundsEXT_RETURN void
#define glDepthBoundsEXT_ARG_NAMES zmin, zmax
#define glDepthBoundsEXT_ARG_EXPAND GLclampd zmin, GLclampd zmax
#define glDepthBoundsEXT_PACKED PACKED_glDepthBoundsEXT
#define glDepthBoundsEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glDepthBoundsEXT_NOT_VOID_WRAP(...) {}
#define pack_glDepthBoundsEXT(_zmin, _zmax) ({ \
    glDepthBoundsEXT_PACKED *packed_data = malloc(sizeof(glDepthBoundsEXT_PACKED)); \
    packed_data->index = glDepthBoundsEXT_INDEX; \
    packed_data->args.zmin = (GLclampd)_zmin; \
    packed_data->args.zmax = (GLclampd)_zmax; \
    (packed_call_t *)packed_data; \
})
#define call_glDepthBoundsEXT(packed, ret_v) do { \
    PACKED_glDepthBoundsEXT *unpacked = (PACKED_glDepthBoundsEXT *)packed; \
    ARGS_glDepthBoundsEXT *args = (ARGS_glDepthBoundsEXT *)&unpacked->args; \
    glDepthBoundsEXT(args->zmin, args->zmax);; \
} while(0)
void glDepthBoundsEXT(glDepthBoundsEXT_ARG_EXPAND);
typedef void (*glDepthBoundsEXT_PTR)(glDepthBoundsEXT_ARG_EXPAND);
#define glDepthBoundsdNV_INDEX 461
#define glDepthBoundsdNV_RETURN void
#define glDepthBoundsdNV_ARG_NAMES zmin, zmax
#define glDepthBoundsdNV_ARG_EXPAND GLdouble zmin, GLdouble zmax
#define glDepthBoundsdNV_PACKED PACKED_glDepthBoundsdNV
#define glDepthBoundsdNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glDepthBoundsdNV_NOT_VOID_WRAP(...) {}
#define pack_glDepthBoundsdNV(_zmin, _zmax) ({ \
    glDepthBoundsdNV_PACKED *packed_data = malloc(sizeof(glDepthBoundsdNV_PACKED)); \
    packed_data->index = glDepthBoundsdNV_INDEX; \
    packed_data->args.zmin = (GLdouble)_zmin; \
    packed_data->args.zmax = (GLdouble)_zmax; \
    (packed_call_t *)packed_data; \
})
#define call_glDepthBoundsdNV(packed, ret_v) do { \
    PACKED_glDepthBoundsdNV *unpacked = (PACKED_glDepthBoundsdNV *)packed; \
    ARGS_glDepthBoundsdNV *args = (ARGS_glDepthBoundsdNV *)&unpacked->args; \
    glDepthBoundsdNV(args->zmin, args->zmax);; \
} while(0)
void glDepthBoundsdNV(glDepthBoundsdNV_ARG_EXPAND);
typedef void (*glDepthBoundsdNV_PTR)(glDepthBoundsdNV_ARG_EXPAND);
#define glDepthFunc_INDEX 462
#define glDepthFunc_RETURN void
#define glDepthFunc_ARG_NAMES func
#define glDepthFunc_ARG_EXPAND GLenum func
#define glDepthFunc_PACKED PACKED_glDepthFunc
#define glDepthFunc_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glDepthFunc_NOT_VOID_WRAP(...) {}
#define pack_glDepthFunc(_func) ({ \
    glDepthFunc_PACKED *packed_data = malloc(sizeof(glDepthFunc_PACKED)); \
    packed_data->index = glDepthFunc_INDEX; \
    packed_data->args.func = (GLenum)_func; \
    (packed_call_t *)packed_data; \
})
#define call_glDepthFunc(packed, ret_v) do { \
    PACKED_glDepthFunc *unpacked = (PACKED_glDepthFunc *)packed; \
    ARGS_glDepthFunc *args = (ARGS_glDepthFunc *)&unpacked->args; \
    glDepthFunc(args->func);; \
} while(0)
void glDepthFunc(glDepthFunc_ARG_EXPAND);
typedef void (*glDepthFunc_PTR)(glDepthFunc_ARG_EXPAND);
#define glDepthMask_INDEX 463
#define glDepthMask_RETURN void
#define glDepthMask_ARG_NAMES flag
#define glDepthMask_ARG_EXPAND GLboolean flag
#define glDepthMask_PACKED PACKED_glDepthMask
#define glDepthMask_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glDepthMask_NOT_VOID_WRAP(...) {}
#define pack_glDepthMask(_flag) ({ \
    glDepthMask_PACKED *packed_data = malloc(sizeof(glDepthMask_PACKED)); \
    packed_data->index = glDepthMask_INDEX; \
    packed_data->args.flag = (GLboolean)_flag; \
    (packed_call_t *)packed_data; \
})
#define call_glDepthMask(packed, ret_v) do { \
    PACKED_glDepthMask *unpacked = (PACKED_glDepthMask *)packed; \
    ARGS_glDepthMask *args = (ARGS_glDepthMask *)&unpacked->args; \
    glDepthMask(args->flag);; \
} while(0)
void glDepthMask(glDepthMask_ARG_EXPAND);
typedef void (*glDepthMask_PTR)(glDepthMask_ARG_EXPAND);
#define glDepthRange_INDEX 464
#define glDepthRange_RETURN void
#define glDepthRange_ARG_NAMES near, far
#define glDepthRange_ARG_EXPAND GLdouble near, GLdouble far
#define glDepthRange_PACKED PACKED_glDepthRange
#define glDepthRange_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glDepthRange_NOT_VOID_WRAP(...) {}
#define pack_glDepthRange(_near, _far) ({ \
    glDepthRange_PACKED *packed_data = malloc(sizeof(glDepthRange_PACKED)); \
    packed_data->index = glDepthRange_INDEX; \
    packed_data->args.near = (GLdouble)_near; \
    packed_data->args.far = (GLdouble)_far; \
    (packed_call_t *)packed_data; \
})
#define call_glDepthRange(packed, ret_v) do { \
    PACKED_glDepthRange *unpacked = (PACKED_glDepthRange *)packed; \
    ARGS_glDepthRange *args = (ARGS_glDepthRange *)&unpacked->args; \
    glDepthRange(args->near, args->far);; \
} while(0)
void glDepthRange(glDepthRange_ARG_EXPAND);
typedef void (*glDepthRange_PTR)(glDepthRange_ARG_EXPAND);
#define glDepthRangeArrayv_INDEX 465
#define glDepthRangeArrayv_RETURN void
#define glDepthRangeArrayv_ARG_NAMES first, count, v
#define glDepthRangeArrayv_ARG_EXPAND GLuint first, GLsizei count, const GLdouble * v
#define glDepthRangeArrayv_PACKED PACKED_glDepthRangeArrayv
#define glDepthRangeArrayv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glDepthRangeArrayv_NOT_VOID_WRAP(...) {}
#define pack_glDepthRangeArrayv(_first, _count, _v) ({ \
    glDepthRangeArrayv_PACKED *packed_data = malloc(sizeof(glDepthRangeArrayv_PACKED)); \
    packed_data->index = glDepthRangeArrayv_INDEX; \
    packed_data->args.first = (GLuint)_first; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.v = (GLdouble *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glDepthRangeArrayv(packed, ret_v) do { \
    PACKED_glDepthRangeArrayv *unpacked = (PACKED_glDepthRangeArrayv *)packed; \
    ARGS_glDepthRangeArrayv *args = (ARGS_glDepthRangeArrayv *)&unpacked->args; \
    glDepthRangeArrayv(args->first, args->count, args->v);; \
} while(0)
void glDepthRangeArrayv(glDepthRangeArrayv_ARG_EXPAND);
typedef void (*glDepthRangeArrayv_PTR)(glDepthRangeArrayv_ARG_EXPAND);
#define glDepthRangeIndexed_INDEX 466
#define glDepthRangeIndexed_RETURN void
#define glDepthRangeIndexed_ARG_NAMES index, n, f
#define glDepthRangeIndexed_ARG_EXPAND GLuint index, GLdouble n, GLdouble f
#define glDepthRangeIndexed_PACKED PACKED_glDepthRangeIndexed
#define glDepthRangeIndexed_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glDepthRangeIndexed_NOT_VOID_WRAP(...) {}
#define pack_glDepthRangeIndexed(_index, _n, _f) ({ \
    glDepthRangeIndexed_PACKED *packed_data = malloc(sizeof(glDepthRangeIndexed_PACKED)); \
    packed_data->index = glDepthRangeIndexed_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.n = (GLdouble)_n; \
    packed_data->args.f = (GLdouble)_f; \
    (packed_call_t *)packed_data; \
})
#define call_glDepthRangeIndexed(packed, ret_v) do { \
    PACKED_glDepthRangeIndexed *unpacked = (PACKED_glDepthRangeIndexed *)packed; \
    ARGS_glDepthRangeIndexed *args = (ARGS_glDepthRangeIndexed *)&unpacked->args; \
    glDepthRangeIndexed(args->index, args->n, args->f);; \
} while(0)
void glDepthRangeIndexed(glDepthRangeIndexed_ARG_EXPAND);
typedef void (*glDepthRangeIndexed_PTR)(glDepthRangeIndexed_ARG_EXPAND);
#define glDepthRangedNV_INDEX 467
#define glDepthRangedNV_RETURN void
#define glDepthRangedNV_ARG_NAMES zNear, zFar
#define glDepthRangedNV_ARG_EXPAND GLdouble zNear, GLdouble zFar
#define glDepthRangedNV_PACKED PACKED_glDepthRangedNV
#define glDepthRangedNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glDepthRangedNV_NOT_VOID_WRAP(...) {}
#define pack_glDepthRangedNV(_zNear, _zFar) ({ \
    glDepthRangedNV_PACKED *packed_data = malloc(sizeof(glDepthRangedNV_PACKED)); \
    packed_data->index = glDepthRangedNV_INDEX; \
    packed_data->args.zNear = (GLdouble)_zNear; \
    packed_data->args.zFar = (GLdouble)_zFar; \
    (packed_call_t *)packed_data; \
})
#define call_glDepthRangedNV(packed, ret_v) do { \
    PACKED_glDepthRangedNV *unpacked = (PACKED_glDepthRangedNV *)packed; \
    ARGS_glDepthRangedNV *args = (ARGS_glDepthRangedNV *)&unpacked->args; \
    glDepthRangedNV(args->zNear, args->zFar);; \
} while(0)
void glDepthRangedNV(glDepthRangedNV_ARG_EXPAND);
typedef void (*glDepthRangedNV_PTR)(glDepthRangedNV_ARG_EXPAND);
#define glDepthRangef_INDEX 468
#define glDepthRangef_RETURN void
#define glDepthRangef_ARG_NAMES near, far
#define glDepthRangef_ARG_EXPAND GLclampf near, GLclampf far
#define glDepthRangef_PACKED PACKED_glDepthRangef
#define glDepthRangef_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glDepthRangef_NOT_VOID_WRAP(...) {}
#define pack_glDepthRangef(_near, _far) ({ \
    glDepthRangef_PACKED *packed_data = malloc(sizeof(glDepthRangef_PACKED)); \
    packed_data->index = glDepthRangef_INDEX; \
    packed_data->args.near = (GLclampf)_near; \
    packed_data->args.far = (GLclampf)_far; \
    (packed_call_t *)packed_data; \
})
#define call_glDepthRangef(packed, ret_v) do { \
    PACKED_glDepthRangef *unpacked = (PACKED_glDepthRangef *)packed; \
    ARGS_glDepthRangef *args = (ARGS_glDepthRangef *)&unpacked->args; \
    glDepthRangef(args->near, args->far);; \
} while(0)
void glDepthRangef(glDepthRangef_ARG_EXPAND);
typedef void (*glDepthRangef_PTR)(glDepthRangef_ARG_EXPAND);
#define glDepthRangefOES_INDEX 469
#define glDepthRangefOES_RETURN void
#define glDepthRangefOES_ARG_NAMES n, f
#define glDepthRangefOES_ARG_EXPAND GLclampf n, GLclampf f
#define glDepthRangefOES_PACKED PACKED_glDepthRangefOES
#define glDepthRangefOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glDepthRangefOES_NOT_VOID_WRAP(...) {}
#define pack_glDepthRangefOES(_n, _f) ({ \
    glDepthRangefOES_PACKED *packed_data = malloc(sizeof(glDepthRangefOES_PACKED)); \
    packed_data->index = glDepthRangefOES_INDEX; \
    packed_data->args.n = (GLclampf)_n; \
    packed_data->args.f = (GLclampf)_f; \
    (packed_call_t *)packed_data; \
})
#define call_glDepthRangefOES(packed, ret_v) do { \
    PACKED_glDepthRangefOES *unpacked = (PACKED_glDepthRangefOES *)packed; \
    ARGS_glDepthRangefOES *args = (ARGS_glDepthRangefOES *)&unpacked->args; \
    glDepthRangefOES(args->n, args->f);; \
} while(0)
void glDepthRangefOES(glDepthRangefOES_ARG_EXPAND);
typedef void (*glDepthRangefOES_PTR)(glDepthRangefOES_ARG_EXPAND);
#define glDepthRangex_INDEX 470
#define glDepthRangex_RETURN void
#define glDepthRangex_ARG_NAMES near, far
#define glDepthRangex_ARG_EXPAND GLclampx near, GLclampx far
#define glDepthRangex_PACKED PACKED_glDepthRangex
#define glDepthRangex_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glDepthRangex_NOT_VOID_WRAP(...) {}
#define pack_glDepthRangex(_near, _far) ({ \
    glDepthRangex_PACKED *packed_data = malloc(sizeof(glDepthRangex_PACKED)); \
    packed_data->index = glDepthRangex_INDEX; \
    packed_data->args.near = (GLclampx)_near; \
    packed_data->args.far = (GLclampx)_far; \
    (packed_call_t *)packed_data; \
})
#define call_glDepthRangex(packed, ret_v) do { \
    PACKED_glDepthRangex *unpacked = (PACKED_glDepthRangex *)packed; \
    ARGS_glDepthRangex *args = (ARGS_glDepthRangex *)&unpacked->args; \
    glDepthRangex(args->near, args->far);; \
} while(0)
void glDepthRangex(glDepthRangex_ARG_EXPAND);
typedef void (*glDepthRangex_PTR)(glDepthRangex_ARG_EXPAND);
#define glDepthRangexOES_INDEX 471
#define glDepthRangexOES_RETURN void
#define glDepthRangexOES_ARG_NAMES n, f
#define glDepthRangexOES_ARG_EXPAND GLfixed n, GLfixed f
#define glDepthRangexOES_PACKED PACKED_glDepthRangexOES
#define glDepthRangexOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glDepthRangexOES_NOT_VOID_WRAP(...) {}
#define pack_glDepthRangexOES(_n, _f) ({ \
    glDepthRangexOES_PACKED *packed_data = malloc(sizeof(glDepthRangexOES_PACKED)); \
    packed_data->index = glDepthRangexOES_INDEX; \
    packed_data->args.n = (GLfixed)_n; \
    packed_data->args.f = (GLfixed)_f; \
    (packed_call_t *)packed_data; \
})
#define call_glDepthRangexOES(packed, ret_v) do { \
    PACKED_glDepthRangexOES *unpacked = (PACKED_glDepthRangexOES *)packed; \
    ARGS_glDepthRangexOES *args = (ARGS_glDepthRangexOES *)&unpacked->args; \
    glDepthRangexOES(args->n, args->f);; \
} while(0)
void glDepthRangexOES(glDepthRangexOES_ARG_EXPAND);
typedef void (*glDepthRangexOES_PTR)(glDepthRangexOES_ARG_EXPAND);
#define glDetachObjectARB_INDEX 472
#define glDetachObjectARB_RETURN void
#define glDetachObjectARB_ARG_NAMES containerObj, attachedObj
#define glDetachObjectARB_ARG_EXPAND GLhandleARB containerObj, GLhandleARB attachedObj
#define glDetachObjectARB_PACKED PACKED_glDetachObjectARB
#define glDetachObjectARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glDetachObjectARB_NOT_VOID_WRAP(...) {}
#define pack_glDetachObjectARB(_containerObj, _attachedObj) ({ \
    glDetachObjectARB_PACKED *packed_data = malloc(sizeof(glDetachObjectARB_PACKED)); \
    packed_data->index = glDetachObjectARB_INDEX; \
    packed_data->args.containerObj = (GLhandleARB)_containerObj; \
    packed_data->args.attachedObj = (GLhandleARB)_attachedObj; \
    (packed_call_t *)packed_data; \
})
#define call_glDetachObjectARB(packed, ret_v) do { \
    PACKED_glDetachObjectARB *unpacked = (PACKED_glDetachObjectARB *)packed; \
    ARGS_glDetachObjectARB *args = (ARGS_glDetachObjectARB *)&unpacked->args; \
    glDetachObjectARB(args->containerObj, args->attachedObj);; \
} while(0)
void glDetachObjectARB(glDetachObjectARB_ARG_EXPAND);
typedef void (*glDetachObjectARB_PTR)(glDetachObjectARB_ARG_EXPAND);
#define glDetachShader_INDEX 473
#define glDetachShader_RETURN void
#define glDetachShader_ARG_NAMES program, shader
#define glDetachShader_ARG_EXPAND GLuint program, GLuint shader
#define glDetachShader_PACKED PACKED_glDetachShader
#define glDetachShader_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glDetachShader_NOT_VOID_WRAP(...) {}
#define pack_glDetachShader(_program, _shader) ({ \
    glDetachShader_PACKED *packed_data = malloc(sizeof(glDetachShader_PACKED)); \
    packed_data->index = glDetachShader_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.shader = (GLuint)_shader; \
    (packed_call_t *)packed_data; \
})
#define call_glDetachShader(packed, ret_v) do { \
    PACKED_glDetachShader *unpacked = (PACKED_glDetachShader *)packed; \
    ARGS_glDetachShader *args = (ARGS_glDetachShader *)&unpacked->args; \
    glDetachShader(args->program, args->shader);; \
} while(0)
void glDetachShader(glDetachShader_ARG_EXPAND);
typedef void (*glDetachShader_PTR)(glDetachShader_ARG_EXPAND);
#define glDetailTexFuncSGIS_INDEX 474
#define glDetailTexFuncSGIS_RETURN void
#define glDetailTexFuncSGIS_ARG_NAMES target, n, points
#define glDetailTexFuncSGIS_ARG_EXPAND GLenum target, GLsizei n, const GLfloat * points
#define glDetailTexFuncSGIS_PACKED PACKED_glDetailTexFuncSGIS
#define glDetailTexFuncSGIS_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glDetailTexFuncSGIS_NOT_VOID_WRAP(...) {}
#define pack_glDetailTexFuncSGIS(_target, _n, _points) ({ \
    glDetailTexFuncSGIS_PACKED *packed_data = malloc(sizeof(glDetailTexFuncSGIS_PACKED)); \
    packed_data->index = glDetailTexFuncSGIS_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.n = (GLsizei)_n; \
    packed_data->args.points = (GLfloat *)_points; \
    (packed_call_t *)packed_data; \
})
#define call_glDetailTexFuncSGIS(packed, ret_v) do { \
    PACKED_glDetailTexFuncSGIS *unpacked = (PACKED_glDetailTexFuncSGIS *)packed; \
    ARGS_glDetailTexFuncSGIS *args = (ARGS_glDetailTexFuncSGIS *)&unpacked->args; \
    glDetailTexFuncSGIS(args->target, args->n, args->points);; \
} while(0)
void glDetailTexFuncSGIS(glDetailTexFuncSGIS_ARG_EXPAND);
typedef void (*glDetailTexFuncSGIS_PTR)(glDetailTexFuncSGIS_ARG_EXPAND);
#define glDisable_INDEX 475
#define glDisable_RETURN void
#define glDisable_ARG_NAMES cap
#define glDisable_ARG_EXPAND GLenum cap
#define glDisable_PACKED PACKED_glDisable
#define glDisable_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glDisable_NOT_VOID_WRAP(...) {}
#define pack_glDisable(_cap) ({ \
    glDisable_PACKED *packed_data = malloc(sizeof(glDisable_PACKED)); \
    packed_data->index = glDisable_INDEX; \
    packed_data->args.cap = (GLenum)_cap; \
    (packed_call_t *)packed_data; \
})
#define call_glDisable(packed, ret_v) do { \
    PACKED_glDisable *unpacked = (PACKED_glDisable *)packed; \
    ARGS_glDisable *args = (ARGS_glDisable *)&unpacked->args; \
    glDisable(args->cap);; \
} while(0)
void glDisable(glDisable_ARG_EXPAND);
typedef void (*glDisable_PTR)(glDisable_ARG_EXPAND);
#define glDisableClientState_INDEX 476
#define glDisableClientState_RETURN void
#define glDisableClientState_ARG_NAMES array
#define glDisableClientState_ARG_EXPAND GLenum array
#define glDisableClientState_PACKED PACKED_glDisableClientState
#define glDisableClientState_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glDisableClientState_NOT_VOID_WRAP(...) {}
#define pack_glDisableClientState(_array) ({ \
    glDisableClientState_PACKED *packed_data = malloc(sizeof(glDisableClientState_PACKED)); \
    packed_data->index = glDisableClientState_INDEX; \
    packed_data->args.array = (GLenum)_array; \
    (packed_call_t *)packed_data; \
})
#define call_glDisableClientState(packed, ret_v) do { \
    PACKED_glDisableClientState *unpacked = (PACKED_glDisableClientState *)packed; \
    ARGS_glDisableClientState *args = (ARGS_glDisableClientState *)&unpacked->args; \
    glDisableClientState(args->array);; \
} while(0)
void glDisableClientState(glDisableClientState_ARG_EXPAND);
typedef void (*glDisableClientState_PTR)(glDisableClientState_ARG_EXPAND);
#define glDisableClientStateIndexedEXT_INDEX 477
#define glDisableClientStateIndexedEXT_RETURN void
#define glDisableClientStateIndexedEXT_ARG_NAMES array, index
#define glDisableClientStateIndexedEXT_ARG_EXPAND GLenum array, GLuint index
#define glDisableClientStateIndexedEXT_PACKED PACKED_glDisableClientStateIndexedEXT
#define glDisableClientStateIndexedEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glDisableClientStateIndexedEXT_NOT_VOID_WRAP(...) {}
#define pack_glDisableClientStateIndexedEXT(_array, _index) ({ \
    glDisableClientStateIndexedEXT_PACKED *packed_data = malloc(sizeof(glDisableClientStateIndexedEXT_PACKED)); \
    packed_data->index = glDisableClientStateIndexedEXT_INDEX; \
    packed_data->args.array = (GLenum)_array; \
    packed_data->args.index = (GLuint)_index; \
    (packed_call_t *)packed_data; \
})
#define call_glDisableClientStateIndexedEXT(packed, ret_v) do { \
    PACKED_glDisableClientStateIndexedEXT *unpacked = (PACKED_glDisableClientStateIndexedEXT *)packed; \
    ARGS_glDisableClientStateIndexedEXT *args = (ARGS_glDisableClientStateIndexedEXT *)&unpacked->args; \
    glDisableClientStateIndexedEXT(args->array, args->index);; \
} while(0)
void glDisableClientStateIndexedEXT(glDisableClientStateIndexedEXT_ARG_EXPAND);
typedef void (*glDisableClientStateIndexedEXT_PTR)(glDisableClientStateIndexedEXT_ARG_EXPAND);
#define glDisableClientStateiEXT_INDEX 478
#define glDisableClientStateiEXT_RETURN void
#define glDisableClientStateiEXT_ARG_NAMES array, index
#define glDisableClientStateiEXT_ARG_EXPAND GLenum array, GLuint index
#define glDisableClientStateiEXT_PACKED PACKED_glDisableClientStateiEXT
#define glDisableClientStateiEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glDisableClientStateiEXT_NOT_VOID_WRAP(...) {}
#define pack_glDisableClientStateiEXT(_array, _index) ({ \
    glDisableClientStateiEXT_PACKED *packed_data = malloc(sizeof(glDisableClientStateiEXT_PACKED)); \
    packed_data->index = glDisableClientStateiEXT_INDEX; \
    packed_data->args.array = (GLenum)_array; \
    packed_data->args.index = (GLuint)_index; \
    (packed_call_t *)packed_data; \
})
#define call_glDisableClientStateiEXT(packed, ret_v) do { \
    PACKED_glDisableClientStateiEXT *unpacked = (PACKED_glDisableClientStateiEXT *)packed; \
    ARGS_glDisableClientStateiEXT *args = (ARGS_glDisableClientStateiEXT *)&unpacked->args; \
    glDisableClientStateiEXT(args->array, args->index);; \
} while(0)
void glDisableClientStateiEXT(glDisableClientStateiEXT_ARG_EXPAND);
typedef void (*glDisableClientStateiEXT_PTR)(glDisableClientStateiEXT_ARG_EXPAND);
#define glDisableIndexedEXT_INDEX 479
#define glDisableIndexedEXT_RETURN void
#define glDisableIndexedEXT_ARG_NAMES target, index
#define glDisableIndexedEXT_ARG_EXPAND GLenum target, GLuint index
#define glDisableIndexedEXT_PACKED PACKED_glDisableIndexedEXT
#define glDisableIndexedEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glDisableIndexedEXT_NOT_VOID_WRAP(...) {}
#define pack_glDisableIndexedEXT(_target, _index) ({ \
    glDisableIndexedEXT_PACKED *packed_data = malloc(sizeof(glDisableIndexedEXT_PACKED)); \
    packed_data->index = glDisableIndexedEXT_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.index = (GLuint)_index; \
    (packed_call_t *)packed_data; \
})
#define call_glDisableIndexedEXT(packed, ret_v) do { \
    PACKED_glDisableIndexedEXT *unpacked = (PACKED_glDisableIndexedEXT *)packed; \
    ARGS_glDisableIndexedEXT *args = (ARGS_glDisableIndexedEXT *)&unpacked->args; \
    glDisableIndexedEXT(args->target, args->index);; \
} while(0)
void glDisableIndexedEXT(glDisableIndexedEXT_ARG_EXPAND);
typedef void (*glDisableIndexedEXT_PTR)(glDisableIndexedEXT_ARG_EXPAND);
#define glDisableVariantClientStateEXT_INDEX 480
#define glDisableVariantClientStateEXT_RETURN void
#define glDisableVariantClientStateEXT_ARG_NAMES id
#define glDisableVariantClientStateEXT_ARG_EXPAND GLuint id
#define glDisableVariantClientStateEXT_PACKED PACKED_glDisableVariantClientStateEXT
#define glDisableVariantClientStateEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glDisableVariantClientStateEXT_NOT_VOID_WRAP(...) {}
#define pack_glDisableVariantClientStateEXT(_id) ({ \
    glDisableVariantClientStateEXT_PACKED *packed_data = malloc(sizeof(glDisableVariantClientStateEXT_PACKED)); \
    packed_data->index = glDisableVariantClientStateEXT_INDEX; \
    packed_data->args.id = (GLuint)_id; \
    (packed_call_t *)packed_data; \
})
#define call_glDisableVariantClientStateEXT(packed, ret_v) do { \
    PACKED_glDisableVariantClientStateEXT *unpacked = (PACKED_glDisableVariantClientStateEXT *)packed; \
    ARGS_glDisableVariantClientStateEXT *args = (ARGS_glDisableVariantClientStateEXT *)&unpacked->args; \
    glDisableVariantClientStateEXT(args->id);; \
} while(0)
void glDisableVariantClientStateEXT(glDisableVariantClientStateEXT_ARG_EXPAND);
typedef void (*glDisableVariantClientStateEXT_PTR)(glDisableVariantClientStateEXT_ARG_EXPAND);
#define glDisableVertexArrayAttribEXT_INDEX 481
#define glDisableVertexArrayAttribEXT_RETURN void
#define glDisableVertexArrayAttribEXT_ARG_NAMES vaobj, index
#define glDisableVertexArrayAttribEXT_ARG_EXPAND GLuint vaobj, GLuint index
#define glDisableVertexArrayAttribEXT_PACKED PACKED_glDisableVertexArrayAttribEXT
#define glDisableVertexArrayAttribEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glDisableVertexArrayAttribEXT_NOT_VOID_WRAP(...) {}
#define pack_glDisableVertexArrayAttribEXT(_vaobj, _index) ({ \
    glDisableVertexArrayAttribEXT_PACKED *packed_data = malloc(sizeof(glDisableVertexArrayAttribEXT_PACKED)); \
    packed_data->index = glDisableVertexArrayAttribEXT_INDEX; \
    packed_data->args.vaobj = (GLuint)_vaobj; \
    packed_data->args.index = (GLuint)_index; \
    (packed_call_t *)packed_data; \
})
#define call_glDisableVertexArrayAttribEXT(packed, ret_v) do { \
    PACKED_glDisableVertexArrayAttribEXT *unpacked = (PACKED_glDisableVertexArrayAttribEXT *)packed; \
    ARGS_glDisableVertexArrayAttribEXT *args = (ARGS_glDisableVertexArrayAttribEXT *)&unpacked->args; \
    glDisableVertexArrayAttribEXT(args->vaobj, args->index);; \
} while(0)
void glDisableVertexArrayAttribEXT(glDisableVertexArrayAttribEXT_ARG_EXPAND);
typedef void (*glDisableVertexArrayAttribEXT_PTR)(glDisableVertexArrayAttribEXT_ARG_EXPAND);
#define glDisableVertexArrayEXT_INDEX 482
#define glDisableVertexArrayEXT_RETURN void
#define glDisableVertexArrayEXT_ARG_NAMES vaobj, array
#define glDisableVertexArrayEXT_ARG_EXPAND GLuint vaobj, GLenum array
#define glDisableVertexArrayEXT_PACKED PACKED_glDisableVertexArrayEXT
#define glDisableVertexArrayEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glDisableVertexArrayEXT_NOT_VOID_WRAP(...) {}
#define pack_glDisableVertexArrayEXT(_vaobj, _array) ({ \
    glDisableVertexArrayEXT_PACKED *packed_data = malloc(sizeof(glDisableVertexArrayEXT_PACKED)); \
    packed_data->index = glDisableVertexArrayEXT_INDEX; \
    packed_data->args.vaobj = (GLuint)_vaobj; \
    packed_data->args.array = (GLenum)_array; \
    (packed_call_t *)packed_data; \
})
#define call_glDisableVertexArrayEXT(packed, ret_v) do { \
    PACKED_glDisableVertexArrayEXT *unpacked = (PACKED_glDisableVertexArrayEXT *)packed; \
    ARGS_glDisableVertexArrayEXT *args = (ARGS_glDisableVertexArrayEXT *)&unpacked->args; \
    glDisableVertexArrayEXT(args->vaobj, args->array);; \
} while(0)
void glDisableVertexArrayEXT(glDisableVertexArrayEXT_ARG_EXPAND);
typedef void (*glDisableVertexArrayEXT_PTR)(glDisableVertexArrayEXT_ARG_EXPAND);
#define glDisableVertexAttribAPPLE_INDEX 483
#define glDisableVertexAttribAPPLE_RETURN void
#define glDisableVertexAttribAPPLE_ARG_NAMES index, pname
#define glDisableVertexAttribAPPLE_ARG_EXPAND GLuint index, GLenum pname
#define glDisableVertexAttribAPPLE_PACKED PACKED_glDisableVertexAttribAPPLE
#define glDisableVertexAttribAPPLE_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glDisableVertexAttribAPPLE_NOT_VOID_WRAP(...) {}
#define pack_glDisableVertexAttribAPPLE(_index, _pname) ({ \
    glDisableVertexAttribAPPLE_PACKED *packed_data = malloc(sizeof(glDisableVertexAttribAPPLE_PACKED)); \
    packed_data->index = glDisableVertexAttribAPPLE_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.pname = (GLenum)_pname; \
    (packed_call_t *)packed_data; \
})
#define call_glDisableVertexAttribAPPLE(packed, ret_v) do { \
    PACKED_glDisableVertexAttribAPPLE *unpacked = (PACKED_glDisableVertexAttribAPPLE *)packed; \
    ARGS_glDisableVertexAttribAPPLE *args = (ARGS_glDisableVertexAttribAPPLE *)&unpacked->args; \
    glDisableVertexAttribAPPLE(args->index, args->pname);; \
} while(0)
void glDisableVertexAttribAPPLE(glDisableVertexAttribAPPLE_ARG_EXPAND);
typedef void (*glDisableVertexAttribAPPLE_PTR)(glDisableVertexAttribAPPLE_ARG_EXPAND);
#define glDisableVertexAttribArray_INDEX 484
#define glDisableVertexAttribArray_RETURN void
#define glDisableVertexAttribArray_ARG_NAMES index
#define glDisableVertexAttribArray_ARG_EXPAND GLuint index
#define glDisableVertexAttribArray_PACKED PACKED_glDisableVertexAttribArray
#define glDisableVertexAttribArray_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glDisableVertexAttribArray_NOT_VOID_WRAP(...) {}
#define pack_glDisableVertexAttribArray(_index) ({ \
    glDisableVertexAttribArray_PACKED *packed_data = malloc(sizeof(glDisableVertexAttribArray_PACKED)); \
    packed_data->index = glDisableVertexAttribArray_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    (packed_call_t *)packed_data; \
})
#define call_glDisableVertexAttribArray(packed, ret_v) do { \
    PACKED_glDisableVertexAttribArray *unpacked = (PACKED_glDisableVertexAttribArray *)packed; \
    ARGS_glDisableVertexAttribArray *args = (ARGS_glDisableVertexAttribArray *)&unpacked->args; \
    glDisableVertexAttribArray(args->index);; \
} while(0)
void glDisableVertexAttribArray(glDisableVertexAttribArray_ARG_EXPAND);
typedef void (*glDisableVertexAttribArray_PTR)(glDisableVertexAttribArray_ARG_EXPAND);
#define glDisableVertexAttribArrayARB_INDEX 485
#define glDisableVertexAttribArrayARB_RETURN void
#define glDisableVertexAttribArrayARB_ARG_NAMES index
#define glDisableVertexAttribArrayARB_ARG_EXPAND GLuint index
#define glDisableVertexAttribArrayARB_PACKED PACKED_glDisableVertexAttribArrayARB
#define glDisableVertexAttribArrayARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glDisableVertexAttribArrayARB_NOT_VOID_WRAP(...) {}
#define pack_glDisableVertexAttribArrayARB(_index) ({ \
    glDisableVertexAttribArrayARB_PACKED *packed_data = malloc(sizeof(glDisableVertexAttribArrayARB_PACKED)); \
    packed_data->index = glDisableVertexAttribArrayARB_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    (packed_call_t *)packed_data; \
})
#define call_glDisableVertexAttribArrayARB(packed, ret_v) do { \
    PACKED_glDisableVertexAttribArrayARB *unpacked = (PACKED_glDisableVertexAttribArrayARB *)packed; \
    ARGS_glDisableVertexAttribArrayARB *args = (ARGS_glDisableVertexAttribArrayARB *)&unpacked->args; \
    glDisableVertexAttribArrayARB(args->index);; \
} while(0)
void glDisableVertexAttribArrayARB(glDisableVertexAttribArrayARB_ARG_EXPAND);
typedef void (*glDisableVertexAttribArrayARB_PTR)(glDisableVertexAttribArrayARB_ARG_EXPAND);
#define glDisablei_INDEX 486
#define glDisablei_RETURN void
#define glDisablei_ARG_NAMES target, index
#define glDisablei_ARG_EXPAND GLenum target, GLuint index
#define glDisablei_PACKED PACKED_glDisablei
#define glDisablei_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glDisablei_NOT_VOID_WRAP(...) {}
#define pack_glDisablei(_target, _index) ({ \
    glDisablei_PACKED *packed_data = malloc(sizeof(glDisablei_PACKED)); \
    packed_data->index = glDisablei_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.index = (GLuint)_index; \
    (packed_call_t *)packed_data; \
})
#define call_glDisablei(packed, ret_v) do { \
    PACKED_glDisablei *unpacked = (PACKED_glDisablei *)packed; \
    ARGS_glDisablei *args = (ARGS_glDisablei *)&unpacked->args; \
    glDisablei(args->target, args->index);; \
} while(0)
void glDisablei(glDisablei_ARG_EXPAND);
typedef void (*glDisablei_PTR)(glDisablei_ARG_EXPAND);
#define glDispatchCompute_INDEX 487
#define glDispatchCompute_RETURN void
#define glDispatchCompute_ARG_NAMES num_groups_x, num_groups_y, num_groups_z
#define glDispatchCompute_ARG_EXPAND GLuint num_groups_x, GLuint num_groups_y, GLuint num_groups_z
#define glDispatchCompute_PACKED PACKED_glDispatchCompute
#define glDispatchCompute_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glDispatchCompute_NOT_VOID_WRAP(...) {}
#define pack_glDispatchCompute(_num_groups_x, _num_groups_y, _num_groups_z) ({ \
    glDispatchCompute_PACKED *packed_data = malloc(sizeof(glDispatchCompute_PACKED)); \
    packed_data->index = glDispatchCompute_INDEX; \
    packed_data->args.num_groups_x = (GLuint)_num_groups_x; \
    packed_data->args.num_groups_y = (GLuint)_num_groups_y; \
    packed_data->args.num_groups_z = (GLuint)_num_groups_z; \
    (packed_call_t *)packed_data; \
})
#define call_glDispatchCompute(packed, ret_v) do { \
    PACKED_glDispatchCompute *unpacked = (PACKED_glDispatchCompute *)packed; \
    ARGS_glDispatchCompute *args = (ARGS_glDispatchCompute *)&unpacked->args; \
    glDispatchCompute(args->num_groups_x, args->num_groups_y, args->num_groups_z);; \
} while(0)
void glDispatchCompute(glDispatchCompute_ARG_EXPAND);
typedef void (*glDispatchCompute_PTR)(glDispatchCompute_ARG_EXPAND);
#define glDispatchComputeIndirect_INDEX 488
#define glDispatchComputeIndirect_RETURN void
#define glDispatchComputeIndirect_ARG_NAMES indirect
#define glDispatchComputeIndirect_ARG_EXPAND GLintptr indirect
#define glDispatchComputeIndirect_PACKED PACKED_glDispatchComputeIndirect
#define glDispatchComputeIndirect_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glDispatchComputeIndirect_NOT_VOID_WRAP(...) {}
#define pack_glDispatchComputeIndirect(_indirect) ({ \
    glDispatchComputeIndirect_PACKED *packed_data = malloc(sizeof(glDispatchComputeIndirect_PACKED)); \
    packed_data->index = glDispatchComputeIndirect_INDEX; \
    packed_data->args.indirect = (GLintptr)_indirect; \
    (packed_call_t *)packed_data; \
})
#define call_glDispatchComputeIndirect(packed, ret_v) do { \
    PACKED_glDispatchComputeIndirect *unpacked = (PACKED_glDispatchComputeIndirect *)packed; \
    ARGS_glDispatchComputeIndirect *args = (ARGS_glDispatchComputeIndirect *)&unpacked->args; \
    glDispatchComputeIndirect(args->indirect);; \
} while(0)
void glDispatchComputeIndirect(glDispatchComputeIndirect_ARG_EXPAND);
typedef void (*glDispatchComputeIndirect_PTR)(glDispatchComputeIndirect_ARG_EXPAND);
#define glDrawArrays_INDEX 489
#define glDrawArrays_RETURN void
#define glDrawArrays_ARG_NAMES mode, first, count
#define glDrawArrays_ARG_EXPAND GLenum mode, GLint first, GLsizei count
#define glDrawArrays_PACKED PACKED_glDrawArrays
#define glDrawArrays_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glDrawArrays_NOT_VOID_WRAP(...) {}
#define pack_glDrawArrays(_mode, _first, _count) ({ \
    glDrawArrays_PACKED *packed_data = malloc(sizeof(glDrawArrays_PACKED)); \
    packed_data->index = glDrawArrays_INDEX; \
    packed_data->args.mode = (GLenum)_mode; \
    packed_data->args.first = (GLint)_first; \
    packed_data->args.count = (GLsizei)_count; \
    (packed_call_t *)packed_data; \
})
#define call_glDrawArrays(packed, ret_v) do { \
    PACKED_glDrawArrays *unpacked = (PACKED_glDrawArrays *)packed; \
    ARGS_glDrawArrays *args = (ARGS_glDrawArrays *)&unpacked->args; \
    glDrawArrays(args->mode, args->first, args->count);; \
} while(0)
void glDrawArrays(glDrawArrays_ARG_EXPAND);
typedef void (*glDrawArrays_PTR)(glDrawArrays_ARG_EXPAND);
#define glDrawArraysEXT_INDEX 490
#define glDrawArraysEXT_RETURN void
#define glDrawArraysEXT_ARG_NAMES mode, first, count
#define glDrawArraysEXT_ARG_EXPAND GLenum mode, GLint first, GLsizei count
#define glDrawArraysEXT_PACKED PACKED_glDrawArraysEXT
#define glDrawArraysEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glDrawArraysEXT_NOT_VOID_WRAP(...) {}
#define pack_glDrawArraysEXT(_mode, _first, _count) ({ \
    glDrawArraysEXT_PACKED *packed_data = malloc(sizeof(glDrawArraysEXT_PACKED)); \
    packed_data->index = glDrawArraysEXT_INDEX; \
    packed_data->args.mode = (GLenum)_mode; \
    packed_data->args.first = (GLint)_first; \
    packed_data->args.count = (GLsizei)_count; \
    (packed_call_t *)packed_data; \
})
#define call_glDrawArraysEXT(packed, ret_v) do { \
    PACKED_glDrawArraysEXT *unpacked = (PACKED_glDrawArraysEXT *)packed; \
    ARGS_glDrawArraysEXT *args = (ARGS_glDrawArraysEXT *)&unpacked->args; \
    glDrawArraysEXT(args->mode, args->first, args->count);; \
} while(0)
void glDrawArraysEXT(glDrawArraysEXT_ARG_EXPAND);
typedef void (*glDrawArraysEXT_PTR)(glDrawArraysEXT_ARG_EXPAND);
#define glDrawArraysIndirect_INDEX 491
#define glDrawArraysIndirect_RETURN void
#define glDrawArraysIndirect_ARG_NAMES mode, indirect
#define glDrawArraysIndirect_ARG_EXPAND GLenum mode, const GLvoid * indirect
#define glDrawArraysIndirect_PACKED PACKED_glDrawArraysIndirect
#define glDrawArraysIndirect_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glDrawArraysIndirect_NOT_VOID_WRAP(...) {}
#define pack_glDrawArraysIndirect(_mode, _indirect) ({ \
    glDrawArraysIndirect_PACKED *packed_data = malloc(sizeof(glDrawArraysIndirect_PACKED)); \
    packed_data->index = glDrawArraysIndirect_INDEX; \
    packed_data->args.mode = (GLenum)_mode; \
    packed_data->args.indirect = (GLvoid *)_indirect; \
    (packed_call_t *)packed_data; \
})
#define call_glDrawArraysIndirect(packed, ret_v) do { \
    PACKED_glDrawArraysIndirect *unpacked = (PACKED_glDrawArraysIndirect *)packed; \
    ARGS_glDrawArraysIndirect *args = (ARGS_glDrawArraysIndirect *)&unpacked->args; \
    glDrawArraysIndirect(args->mode, args->indirect);; \
} while(0)
void glDrawArraysIndirect(glDrawArraysIndirect_ARG_EXPAND);
typedef void (*glDrawArraysIndirect_PTR)(glDrawArraysIndirect_ARG_EXPAND);
#define glDrawArraysInstanced_INDEX 492
#define glDrawArraysInstanced_RETURN void
#define glDrawArraysInstanced_ARG_NAMES mode, first, count, instancecount
#define glDrawArraysInstanced_ARG_EXPAND GLenum mode, GLint first, GLsizei count, GLsizei instancecount
#define glDrawArraysInstanced_PACKED PACKED_glDrawArraysInstanced
#define glDrawArraysInstanced_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glDrawArraysInstanced_NOT_VOID_WRAP(...) {}
#define pack_glDrawArraysInstanced(_mode, _first, _count, _instancecount) ({ \
    glDrawArraysInstanced_PACKED *packed_data = malloc(sizeof(glDrawArraysInstanced_PACKED)); \
    packed_data->index = glDrawArraysInstanced_INDEX; \
    packed_data->args.mode = (GLenum)_mode; \
    packed_data->args.first = (GLint)_first; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.instancecount = (GLsizei)_instancecount; \
    (packed_call_t *)packed_data; \
})
#define call_glDrawArraysInstanced(packed, ret_v) do { \
    PACKED_glDrawArraysInstanced *unpacked = (PACKED_glDrawArraysInstanced *)packed; \
    ARGS_glDrawArraysInstanced *args = (ARGS_glDrawArraysInstanced *)&unpacked->args; \
    glDrawArraysInstanced(args->mode, args->first, args->count, args->instancecount);; \
} while(0)
void glDrawArraysInstanced(glDrawArraysInstanced_ARG_EXPAND);
typedef void (*glDrawArraysInstanced_PTR)(glDrawArraysInstanced_ARG_EXPAND);
#define glDrawArraysInstancedARB_INDEX 493
#define glDrawArraysInstancedARB_RETURN void
#define glDrawArraysInstancedARB_ARG_NAMES mode, first, count, primcount
#define glDrawArraysInstancedARB_ARG_EXPAND GLenum mode, GLint first, GLsizei count, GLsizei primcount
#define glDrawArraysInstancedARB_PACKED PACKED_glDrawArraysInstancedARB
#define glDrawArraysInstancedARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glDrawArraysInstancedARB_NOT_VOID_WRAP(...) {}
#define pack_glDrawArraysInstancedARB(_mode, _first, _count, _primcount) ({ \
    glDrawArraysInstancedARB_PACKED *packed_data = malloc(sizeof(glDrawArraysInstancedARB_PACKED)); \
    packed_data->index = glDrawArraysInstancedARB_INDEX; \
    packed_data->args.mode = (GLenum)_mode; \
    packed_data->args.first = (GLint)_first; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.primcount = (GLsizei)_primcount; \
    (packed_call_t *)packed_data; \
})
#define call_glDrawArraysInstancedARB(packed, ret_v) do { \
    PACKED_glDrawArraysInstancedARB *unpacked = (PACKED_glDrawArraysInstancedARB *)packed; \
    ARGS_glDrawArraysInstancedARB *args = (ARGS_glDrawArraysInstancedARB *)&unpacked->args; \
    glDrawArraysInstancedARB(args->mode, args->first, args->count, args->primcount);; \
} while(0)
void glDrawArraysInstancedARB(glDrawArraysInstancedARB_ARG_EXPAND);
typedef void (*glDrawArraysInstancedARB_PTR)(glDrawArraysInstancedARB_ARG_EXPAND);
#define glDrawArraysInstancedBaseInstance_INDEX 494
#define glDrawArraysInstancedBaseInstance_RETURN void
#define glDrawArraysInstancedBaseInstance_ARG_NAMES mode, first, count, instancecount, baseinstance
#define glDrawArraysInstancedBaseInstance_ARG_EXPAND GLenum mode, GLint first, GLsizei count, GLsizei instancecount, GLuint baseinstance
#define glDrawArraysInstancedBaseInstance_PACKED PACKED_glDrawArraysInstancedBaseInstance
#define glDrawArraysInstancedBaseInstance_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glDrawArraysInstancedBaseInstance_NOT_VOID_WRAP(...) {}
#define pack_glDrawArraysInstancedBaseInstance(_mode, _first, _count, _instancecount, _baseinstance) ({ \
    glDrawArraysInstancedBaseInstance_PACKED *packed_data = malloc(sizeof(glDrawArraysInstancedBaseInstance_PACKED)); \
    packed_data->index = glDrawArraysInstancedBaseInstance_INDEX; \
    packed_data->args.mode = (GLenum)_mode; \
    packed_data->args.first = (GLint)_first; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.instancecount = (GLsizei)_instancecount; \
    packed_data->args.baseinstance = (GLuint)_baseinstance; \
    (packed_call_t *)packed_data; \
})
#define call_glDrawArraysInstancedBaseInstance(packed, ret_v) do { \
    PACKED_glDrawArraysInstancedBaseInstance *unpacked = (PACKED_glDrawArraysInstancedBaseInstance *)packed; \
    ARGS_glDrawArraysInstancedBaseInstance *args = (ARGS_glDrawArraysInstancedBaseInstance *)&unpacked->args; \
    glDrawArraysInstancedBaseInstance(args->mode, args->first, args->count, args->instancecount, args->baseinstance);; \
} while(0)
void glDrawArraysInstancedBaseInstance(glDrawArraysInstancedBaseInstance_ARG_EXPAND);
typedef void (*glDrawArraysInstancedBaseInstance_PTR)(glDrawArraysInstancedBaseInstance_ARG_EXPAND);
#define glDrawArraysInstancedEXT_INDEX 495
#define glDrawArraysInstancedEXT_RETURN void
#define glDrawArraysInstancedEXT_ARG_NAMES mode, start, count, primcount
#define glDrawArraysInstancedEXT_ARG_EXPAND GLenum mode, GLint start, GLsizei count, GLsizei primcount
#define glDrawArraysInstancedEXT_PACKED PACKED_glDrawArraysInstancedEXT
#define glDrawArraysInstancedEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glDrawArraysInstancedEXT_NOT_VOID_WRAP(...) {}
#define pack_glDrawArraysInstancedEXT(_mode, _start, _count, _primcount) ({ \
    glDrawArraysInstancedEXT_PACKED *packed_data = malloc(sizeof(glDrawArraysInstancedEXT_PACKED)); \
    packed_data->index = glDrawArraysInstancedEXT_INDEX; \
    packed_data->args.mode = (GLenum)_mode; \
    packed_data->args.start = (GLint)_start; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.primcount = (GLsizei)_primcount; \
    (packed_call_t *)packed_data; \
})
#define call_glDrawArraysInstancedEXT(packed, ret_v) do { \
    PACKED_glDrawArraysInstancedEXT *unpacked = (PACKED_glDrawArraysInstancedEXT *)packed; \
    ARGS_glDrawArraysInstancedEXT *args = (ARGS_glDrawArraysInstancedEXT *)&unpacked->args; \
    glDrawArraysInstancedEXT(args->mode, args->start, args->count, args->primcount);; \
} while(0)
void glDrawArraysInstancedEXT(glDrawArraysInstancedEXT_ARG_EXPAND);
typedef void (*glDrawArraysInstancedEXT_PTR)(glDrawArraysInstancedEXT_ARG_EXPAND);
#define glDrawBuffer_INDEX 496
#define glDrawBuffer_RETURN void
#define glDrawBuffer_ARG_NAMES mode
#define glDrawBuffer_ARG_EXPAND GLenum mode
#define glDrawBuffer_PACKED PACKED_glDrawBuffer
#define glDrawBuffer_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glDrawBuffer_NOT_VOID_WRAP(...) {}
#define pack_glDrawBuffer(_mode) ({ \
    glDrawBuffer_PACKED *packed_data = malloc(sizeof(glDrawBuffer_PACKED)); \
    packed_data->index = glDrawBuffer_INDEX; \
    packed_data->args.mode = (GLenum)_mode; \
    (packed_call_t *)packed_data; \
})
#define call_glDrawBuffer(packed, ret_v) do { \
    PACKED_glDrawBuffer *unpacked = (PACKED_glDrawBuffer *)packed; \
    ARGS_glDrawBuffer *args = (ARGS_glDrawBuffer *)&unpacked->args; \
    glDrawBuffer(args->mode);; \
} while(0)
void glDrawBuffer(glDrawBuffer_ARG_EXPAND);
typedef void (*glDrawBuffer_PTR)(glDrawBuffer_ARG_EXPAND);
#define glDrawBuffers_INDEX 497
#define glDrawBuffers_RETURN void
#define glDrawBuffers_ARG_NAMES n, bufs
#define glDrawBuffers_ARG_EXPAND GLsizei n, const GLenum * bufs
#define glDrawBuffers_PACKED PACKED_glDrawBuffers
#define glDrawBuffers_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glDrawBuffers_NOT_VOID_WRAP(...) {}
#define pack_glDrawBuffers(_n, _bufs) ({ \
    glDrawBuffers_PACKED *packed_data = malloc(sizeof(glDrawBuffers_PACKED)); \
    packed_data->index = glDrawBuffers_INDEX; \
    packed_data->args.n = (GLsizei)_n; \
    packed_data->args.bufs = (GLenum *)_bufs; \
    (packed_call_t *)packed_data; \
})
#define call_glDrawBuffers(packed, ret_v) do { \
    PACKED_glDrawBuffers *unpacked = (PACKED_glDrawBuffers *)packed; \
    ARGS_glDrawBuffers *args = (ARGS_glDrawBuffers *)&unpacked->args; \
    glDrawBuffers(args->n, args->bufs);; \
} while(0)
void glDrawBuffers(glDrawBuffers_ARG_EXPAND);
typedef void (*glDrawBuffers_PTR)(glDrawBuffers_ARG_EXPAND);
#define glDrawBuffersARB_INDEX 498
#define glDrawBuffersARB_RETURN void
#define glDrawBuffersARB_ARG_NAMES n, bufs
#define glDrawBuffersARB_ARG_EXPAND GLsizei n, const GLenum * bufs
#define glDrawBuffersARB_PACKED PACKED_glDrawBuffersARB
#define glDrawBuffersARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glDrawBuffersARB_NOT_VOID_WRAP(...) {}
#define pack_glDrawBuffersARB(_n, _bufs) ({ \
    glDrawBuffersARB_PACKED *packed_data = malloc(sizeof(glDrawBuffersARB_PACKED)); \
    packed_data->index = glDrawBuffersARB_INDEX; \
    packed_data->args.n = (GLsizei)_n; \
    packed_data->args.bufs = (GLenum *)_bufs; \
    (packed_call_t *)packed_data; \
})
#define call_glDrawBuffersARB(packed, ret_v) do { \
    PACKED_glDrawBuffersARB *unpacked = (PACKED_glDrawBuffersARB *)packed; \
    ARGS_glDrawBuffersARB *args = (ARGS_glDrawBuffersARB *)&unpacked->args; \
    glDrawBuffersARB(args->n, args->bufs);; \
} while(0)
void glDrawBuffersARB(glDrawBuffersARB_ARG_EXPAND);
typedef void (*glDrawBuffersARB_PTR)(glDrawBuffersARB_ARG_EXPAND);
#define glDrawBuffersATI_INDEX 499
#define glDrawBuffersATI_RETURN void
#define glDrawBuffersATI_ARG_NAMES n, bufs
#define glDrawBuffersATI_ARG_EXPAND GLsizei n, const GLenum * bufs
#define glDrawBuffersATI_PACKED PACKED_glDrawBuffersATI
#define glDrawBuffersATI_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glDrawBuffersATI_NOT_VOID_WRAP(...) {}
#define pack_glDrawBuffersATI(_n, _bufs) ({ \
    glDrawBuffersATI_PACKED *packed_data = malloc(sizeof(glDrawBuffersATI_PACKED)); \
    packed_data->index = glDrawBuffersATI_INDEX; \
    packed_data->args.n = (GLsizei)_n; \
    packed_data->args.bufs = (GLenum *)_bufs; \
    (packed_call_t *)packed_data; \
})
#define call_glDrawBuffersATI(packed, ret_v) do { \
    PACKED_glDrawBuffersATI *unpacked = (PACKED_glDrawBuffersATI *)packed; \
    ARGS_glDrawBuffersATI *args = (ARGS_glDrawBuffersATI *)&unpacked->args; \
    glDrawBuffersATI(args->n, args->bufs);; \
} while(0)
void glDrawBuffersATI(glDrawBuffersATI_ARG_EXPAND);
typedef void (*glDrawBuffersATI_PTR)(glDrawBuffersATI_ARG_EXPAND);
#define glDrawElementArrayAPPLE_INDEX 500
#define glDrawElementArrayAPPLE_RETURN void
#define glDrawElementArrayAPPLE_ARG_NAMES mode, first, count
#define glDrawElementArrayAPPLE_ARG_EXPAND GLenum mode, GLint first, GLsizei count
#define glDrawElementArrayAPPLE_PACKED PACKED_glDrawElementArrayAPPLE
#define glDrawElementArrayAPPLE_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glDrawElementArrayAPPLE_NOT_VOID_WRAP(...) {}
#define pack_glDrawElementArrayAPPLE(_mode, _first, _count) ({ \
    glDrawElementArrayAPPLE_PACKED *packed_data = malloc(sizeof(glDrawElementArrayAPPLE_PACKED)); \
    packed_data->index = glDrawElementArrayAPPLE_INDEX; \
    packed_data->args.mode = (GLenum)_mode; \
    packed_data->args.first = (GLint)_first; \
    packed_data->args.count = (GLsizei)_count; \
    (packed_call_t *)packed_data; \
})
#define call_glDrawElementArrayAPPLE(packed, ret_v) do { \
    PACKED_glDrawElementArrayAPPLE *unpacked = (PACKED_glDrawElementArrayAPPLE *)packed; \
    ARGS_glDrawElementArrayAPPLE *args = (ARGS_glDrawElementArrayAPPLE *)&unpacked->args; \
    glDrawElementArrayAPPLE(args->mode, args->first, args->count);; \
} while(0)
void glDrawElementArrayAPPLE(glDrawElementArrayAPPLE_ARG_EXPAND);
typedef void (*glDrawElementArrayAPPLE_PTR)(glDrawElementArrayAPPLE_ARG_EXPAND);
#define glDrawElementArrayATI_INDEX 501
#define glDrawElementArrayATI_RETURN void
#define glDrawElementArrayATI_ARG_NAMES mode, count
#define glDrawElementArrayATI_ARG_EXPAND GLenum mode, GLsizei count
#define glDrawElementArrayATI_PACKED PACKED_glDrawElementArrayATI
#define glDrawElementArrayATI_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glDrawElementArrayATI_NOT_VOID_WRAP(...) {}
#define pack_glDrawElementArrayATI(_mode, _count) ({ \
    glDrawElementArrayATI_PACKED *packed_data = malloc(sizeof(glDrawElementArrayATI_PACKED)); \
    packed_data->index = glDrawElementArrayATI_INDEX; \
    packed_data->args.mode = (GLenum)_mode; \
    packed_data->args.count = (GLsizei)_count; \
    (packed_call_t *)packed_data; \
})
#define call_glDrawElementArrayATI(packed, ret_v) do { \
    PACKED_glDrawElementArrayATI *unpacked = (PACKED_glDrawElementArrayATI *)packed; \
    ARGS_glDrawElementArrayATI *args = (ARGS_glDrawElementArrayATI *)&unpacked->args; \
    glDrawElementArrayATI(args->mode, args->count);; \
} while(0)
void glDrawElementArrayATI(glDrawElementArrayATI_ARG_EXPAND);
typedef void (*glDrawElementArrayATI_PTR)(glDrawElementArrayATI_ARG_EXPAND);
#define glDrawElements_INDEX 502
#define glDrawElements_RETURN void
#define glDrawElements_ARG_NAMES mode, count, type, indices
#define glDrawElements_ARG_EXPAND GLenum mode, GLsizei count, GLenum type, const GLvoid * indices
#define glDrawElements_PACKED PACKED_glDrawElements
#define glDrawElements_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glDrawElements_NOT_VOID_WRAP(...) {}
#define pack_glDrawElements(_mode, _count, _type, _indices) ({ \
    glDrawElements_PACKED *packed_data = malloc(sizeof(glDrawElements_PACKED)); \
    packed_data->index = glDrawElements_INDEX; \
    packed_data->args.mode = (GLenum)_mode; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.indices = (GLvoid *)_indices; \
    (packed_call_t *)packed_data; \
})
#define call_glDrawElements(packed, ret_v) do { \
    PACKED_glDrawElements *unpacked = (PACKED_glDrawElements *)packed; \
    ARGS_glDrawElements *args = (ARGS_glDrawElements *)&unpacked->args; \
    glDrawElements(args->mode, args->count, args->type, args->indices);; \
} while(0)
void glDrawElements(glDrawElements_ARG_EXPAND);
typedef void (*glDrawElements_PTR)(glDrawElements_ARG_EXPAND);
#define glDrawElementsBaseVertex_INDEX 503
#define glDrawElementsBaseVertex_RETURN void
#define glDrawElementsBaseVertex_ARG_NAMES mode, count, type, indices, basevertex
#define glDrawElementsBaseVertex_ARG_EXPAND GLenum mode, GLsizei count, GLenum type, const GLvoid * indices, GLint basevertex
#define glDrawElementsBaseVertex_PACKED PACKED_glDrawElementsBaseVertex
#define glDrawElementsBaseVertex_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glDrawElementsBaseVertex_NOT_VOID_WRAP(...) {}
#define pack_glDrawElementsBaseVertex(_mode, _count, _type, _indices, _basevertex) ({ \
    glDrawElementsBaseVertex_PACKED *packed_data = malloc(sizeof(glDrawElementsBaseVertex_PACKED)); \
    packed_data->index = glDrawElementsBaseVertex_INDEX; \
    packed_data->args.mode = (GLenum)_mode; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.indices = (GLvoid *)_indices; \
    packed_data->args.basevertex = (GLint)_basevertex; \
    (packed_call_t *)packed_data; \
})
#define call_glDrawElementsBaseVertex(packed, ret_v) do { \
    PACKED_glDrawElementsBaseVertex *unpacked = (PACKED_glDrawElementsBaseVertex *)packed; \
    ARGS_glDrawElementsBaseVertex *args = (ARGS_glDrawElementsBaseVertex *)&unpacked->args; \
    glDrawElementsBaseVertex(args->mode, args->count, args->type, args->indices, args->basevertex);; \
} while(0)
void glDrawElementsBaseVertex(glDrawElementsBaseVertex_ARG_EXPAND);
typedef void (*glDrawElementsBaseVertex_PTR)(glDrawElementsBaseVertex_ARG_EXPAND);
#define glDrawElementsIndirect_INDEX 504
#define glDrawElementsIndirect_RETURN void
#define glDrawElementsIndirect_ARG_NAMES mode, type, indirect
#define glDrawElementsIndirect_ARG_EXPAND GLenum mode, GLenum type, const GLvoid * indirect
#define glDrawElementsIndirect_PACKED PACKED_glDrawElementsIndirect
#define glDrawElementsIndirect_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glDrawElementsIndirect_NOT_VOID_WRAP(...) {}
#define pack_glDrawElementsIndirect(_mode, _type, _indirect) ({ \
    glDrawElementsIndirect_PACKED *packed_data = malloc(sizeof(glDrawElementsIndirect_PACKED)); \
    packed_data->index = glDrawElementsIndirect_INDEX; \
    packed_data->args.mode = (GLenum)_mode; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.indirect = (GLvoid *)_indirect; \
    (packed_call_t *)packed_data; \
})
#define call_glDrawElementsIndirect(packed, ret_v) do { \
    PACKED_glDrawElementsIndirect *unpacked = (PACKED_glDrawElementsIndirect *)packed; \
    ARGS_glDrawElementsIndirect *args = (ARGS_glDrawElementsIndirect *)&unpacked->args; \
    glDrawElementsIndirect(args->mode, args->type, args->indirect);; \
} while(0)
void glDrawElementsIndirect(glDrawElementsIndirect_ARG_EXPAND);
typedef void (*glDrawElementsIndirect_PTR)(glDrawElementsIndirect_ARG_EXPAND);
#define glDrawElementsInstanced_INDEX 505
#define glDrawElementsInstanced_RETURN void
#define glDrawElementsInstanced_ARG_NAMES mode, count, type, indices, instancecount
#define glDrawElementsInstanced_ARG_EXPAND GLenum mode, GLsizei count, GLenum type, const GLvoid * indices, GLsizei instancecount
#define glDrawElementsInstanced_PACKED PACKED_glDrawElementsInstanced
#define glDrawElementsInstanced_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glDrawElementsInstanced_NOT_VOID_WRAP(...) {}
#define pack_glDrawElementsInstanced(_mode, _count, _type, _indices, _instancecount) ({ \
    glDrawElementsInstanced_PACKED *packed_data = malloc(sizeof(glDrawElementsInstanced_PACKED)); \
    packed_data->index = glDrawElementsInstanced_INDEX; \
    packed_data->args.mode = (GLenum)_mode; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.indices = (GLvoid *)_indices; \
    packed_data->args.instancecount = (GLsizei)_instancecount; \
    (packed_call_t *)packed_data; \
})
#define call_glDrawElementsInstanced(packed, ret_v) do { \
    PACKED_glDrawElementsInstanced *unpacked = (PACKED_glDrawElementsInstanced *)packed; \
    ARGS_glDrawElementsInstanced *args = (ARGS_glDrawElementsInstanced *)&unpacked->args; \
    glDrawElementsInstanced(args->mode, args->count, args->type, args->indices, args->instancecount);; \
} while(0)
void glDrawElementsInstanced(glDrawElementsInstanced_ARG_EXPAND);
typedef void (*glDrawElementsInstanced_PTR)(glDrawElementsInstanced_ARG_EXPAND);
#define glDrawElementsInstancedARB_INDEX 506
#define glDrawElementsInstancedARB_RETURN void
#define glDrawElementsInstancedARB_ARG_NAMES mode, count, type, indices, primcount
#define glDrawElementsInstancedARB_ARG_EXPAND GLenum mode, GLsizei count, GLenum type, const GLvoid * indices, GLsizei primcount
#define glDrawElementsInstancedARB_PACKED PACKED_glDrawElementsInstancedARB
#define glDrawElementsInstancedARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glDrawElementsInstancedARB_NOT_VOID_WRAP(...) {}
#define pack_glDrawElementsInstancedARB(_mode, _count, _type, _indices, _primcount) ({ \
    glDrawElementsInstancedARB_PACKED *packed_data = malloc(sizeof(glDrawElementsInstancedARB_PACKED)); \
    packed_data->index = glDrawElementsInstancedARB_INDEX; \
    packed_data->args.mode = (GLenum)_mode; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.indices = (GLvoid *)_indices; \
    packed_data->args.primcount = (GLsizei)_primcount; \
    (packed_call_t *)packed_data; \
})
#define call_glDrawElementsInstancedARB(packed, ret_v) do { \
    PACKED_glDrawElementsInstancedARB *unpacked = (PACKED_glDrawElementsInstancedARB *)packed; \
    ARGS_glDrawElementsInstancedARB *args = (ARGS_glDrawElementsInstancedARB *)&unpacked->args; \
    glDrawElementsInstancedARB(args->mode, args->count, args->type, args->indices, args->primcount);; \
} while(0)
void glDrawElementsInstancedARB(glDrawElementsInstancedARB_ARG_EXPAND);
typedef void (*glDrawElementsInstancedARB_PTR)(glDrawElementsInstancedARB_ARG_EXPAND);
#define glDrawElementsInstancedBaseInstance_INDEX 507
#define glDrawElementsInstancedBaseInstance_RETURN void
#define glDrawElementsInstancedBaseInstance_ARG_NAMES mode, count, type, indices, instancecount, baseinstance
#define glDrawElementsInstancedBaseInstance_ARG_EXPAND GLenum mode, GLsizei count, GLenum type, const void * indices, GLsizei instancecount, GLuint baseinstance
#define glDrawElementsInstancedBaseInstance_PACKED PACKED_glDrawElementsInstancedBaseInstance
#define glDrawElementsInstancedBaseInstance_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glDrawElementsInstancedBaseInstance_NOT_VOID_WRAP(...) {}
#define pack_glDrawElementsInstancedBaseInstance(_mode, _count, _type, _indices, _instancecount, _baseinstance) ({ \
    glDrawElementsInstancedBaseInstance_PACKED *packed_data = malloc(sizeof(glDrawElementsInstancedBaseInstance_PACKED)); \
    packed_data->index = glDrawElementsInstancedBaseInstance_INDEX; \
    packed_data->args.mode = (GLenum)_mode; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.indices = (void *)_indices; \
    packed_data->args.instancecount = (GLsizei)_instancecount; \
    packed_data->args.baseinstance = (GLuint)_baseinstance; \
    (packed_call_t *)packed_data; \
})
#define call_glDrawElementsInstancedBaseInstance(packed, ret_v) do { \
    PACKED_glDrawElementsInstancedBaseInstance *unpacked = (PACKED_glDrawElementsInstancedBaseInstance *)packed; \
    ARGS_glDrawElementsInstancedBaseInstance *args = (ARGS_glDrawElementsInstancedBaseInstance *)&unpacked->args; \
    glDrawElementsInstancedBaseInstance(args->mode, args->count, args->type, args->indices, args->instancecount, args->baseinstance);; \
} while(0)
void glDrawElementsInstancedBaseInstance(glDrawElementsInstancedBaseInstance_ARG_EXPAND);
typedef void (*glDrawElementsInstancedBaseInstance_PTR)(glDrawElementsInstancedBaseInstance_ARG_EXPAND);
#define glDrawElementsInstancedBaseVertex_INDEX 508
#define glDrawElementsInstancedBaseVertex_RETURN void
#define glDrawElementsInstancedBaseVertex_ARG_NAMES mode, count, type, indices, instancecount, basevertex
#define glDrawElementsInstancedBaseVertex_ARG_EXPAND GLenum mode, GLsizei count, GLenum type, const GLvoid * indices, GLsizei instancecount, GLint basevertex
#define glDrawElementsInstancedBaseVertex_PACKED PACKED_glDrawElementsInstancedBaseVertex
#define glDrawElementsInstancedBaseVertex_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glDrawElementsInstancedBaseVertex_NOT_VOID_WRAP(...) {}
#define pack_glDrawElementsInstancedBaseVertex(_mode, _count, _type, _indices, _instancecount, _basevertex) ({ \
    glDrawElementsInstancedBaseVertex_PACKED *packed_data = malloc(sizeof(glDrawElementsInstancedBaseVertex_PACKED)); \
    packed_data->index = glDrawElementsInstancedBaseVertex_INDEX; \
    packed_data->args.mode = (GLenum)_mode; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.indices = (GLvoid *)_indices; \
    packed_data->args.instancecount = (GLsizei)_instancecount; \
    packed_data->args.basevertex = (GLint)_basevertex; \
    (packed_call_t *)packed_data; \
})
#define call_glDrawElementsInstancedBaseVertex(packed, ret_v) do { \
    PACKED_glDrawElementsInstancedBaseVertex *unpacked = (PACKED_glDrawElementsInstancedBaseVertex *)packed; \
    ARGS_glDrawElementsInstancedBaseVertex *args = (ARGS_glDrawElementsInstancedBaseVertex *)&unpacked->args; \
    glDrawElementsInstancedBaseVertex(args->mode, args->count, args->type, args->indices, args->instancecount, args->basevertex);; \
} while(0)
void glDrawElementsInstancedBaseVertex(glDrawElementsInstancedBaseVertex_ARG_EXPAND);
typedef void (*glDrawElementsInstancedBaseVertex_PTR)(glDrawElementsInstancedBaseVertex_ARG_EXPAND);
#define glDrawElementsInstancedBaseVertexBaseInstance_INDEX 509
#define glDrawElementsInstancedBaseVertexBaseInstance_RETURN void
#define glDrawElementsInstancedBaseVertexBaseInstance_ARG_NAMES mode, count, type, indices, instancecount, basevertex, baseinstance
#define glDrawElementsInstancedBaseVertexBaseInstance_ARG_EXPAND GLenum mode, GLsizei count, GLenum type, const void * indices, GLsizei instancecount, GLint basevertex, GLuint baseinstance
#define glDrawElementsInstancedBaseVertexBaseInstance_PACKED PACKED_glDrawElementsInstancedBaseVertexBaseInstance
#define glDrawElementsInstancedBaseVertexBaseInstance_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glDrawElementsInstancedBaseVertexBaseInstance_NOT_VOID_WRAP(...) {}
#define pack_glDrawElementsInstancedBaseVertexBaseInstance(_mode, _count, _type, _indices, _instancecount, _basevertex, _baseinstance) ({ \
    glDrawElementsInstancedBaseVertexBaseInstance_PACKED *packed_data = malloc(sizeof(glDrawElementsInstancedBaseVertexBaseInstance_PACKED)); \
    packed_data->index = glDrawElementsInstancedBaseVertexBaseInstance_INDEX; \
    packed_data->args.mode = (GLenum)_mode; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.indices = (void *)_indices; \
    packed_data->args.instancecount = (GLsizei)_instancecount; \
    packed_data->args.basevertex = (GLint)_basevertex; \
    packed_data->args.baseinstance = (GLuint)_baseinstance; \
    (packed_call_t *)packed_data; \
})
#define call_glDrawElementsInstancedBaseVertexBaseInstance(packed, ret_v) do { \
    PACKED_glDrawElementsInstancedBaseVertexBaseInstance *unpacked = (PACKED_glDrawElementsInstancedBaseVertexBaseInstance *)packed; \
    ARGS_glDrawElementsInstancedBaseVertexBaseInstance *args = (ARGS_glDrawElementsInstancedBaseVertexBaseInstance *)&unpacked->args; \
    glDrawElementsInstancedBaseVertexBaseInstance(args->mode, args->count, args->type, args->indices, args->instancecount, args->basevertex, args->baseinstance);; \
} while(0)
void glDrawElementsInstancedBaseVertexBaseInstance(glDrawElementsInstancedBaseVertexBaseInstance_ARG_EXPAND);
typedef void (*glDrawElementsInstancedBaseVertexBaseInstance_PTR)(glDrawElementsInstancedBaseVertexBaseInstance_ARG_EXPAND);
#define glDrawElementsInstancedEXT_INDEX 510
#define glDrawElementsInstancedEXT_RETURN void
#define glDrawElementsInstancedEXT_ARG_NAMES mode, count, type, indices, primcount
#define glDrawElementsInstancedEXT_ARG_EXPAND GLenum mode, GLsizei count, GLenum type, const GLvoid * indices, GLsizei primcount
#define glDrawElementsInstancedEXT_PACKED PACKED_glDrawElementsInstancedEXT
#define glDrawElementsInstancedEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glDrawElementsInstancedEXT_NOT_VOID_WRAP(...) {}
#define pack_glDrawElementsInstancedEXT(_mode, _count, _type, _indices, _primcount) ({ \
    glDrawElementsInstancedEXT_PACKED *packed_data = malloc(sizeof(glDrawElementsInstancedEXT_PACKED)); \
    packed_data->index = glDrawElementsInstancedEXT_INDEX; \
    packed_data->args.mode = (GLenum)_mode; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.indices = (GLvoid *)_indices; \
    packed_data->args.primcount = (GLsizei)_primcount; \
    (packed_call_t *)packed_data; \
})
#define call_glDrawElementsInstancedEXT(packed, ret_v) do { \
    PACKED_glDrawElementsInstancedEXT *unpacked = (PACKED_glDrawElementsInstancedEXT *)packed; \
    ARGS_glDrawElementsInstancedEXT *args = (ARGS_glDrawElementsInstancedEXT *)&unpacked->args; \
    glDrawElementsInstancedEXT(args->mode, args->count, args->type, args->indices, args->primcount);; \
} while(0)
void glDrawElementsInstancedEXT(glDrawElementsInstancedEXT_ARG_EXPAND);
typedef void (*glDrawElementsInstancedEXT_PTR)(glDrawElementsInstancedEXT_ARG_EXPAND);
#define glDrawMeshArraysSUN_INDEX 511
#define glDrawMeshArraysSUN_RETURN void
#define glDrawMeshArraysSUN_ARG_NAMES mode, first, count, width
#define glDrawMeshArraysSUN_ARG_EXPAND GLenum mode, GLint first, GLsizei count, GLsizei width
#define glDrawMeshArraysSUN_PACKED PACKED_glDrawMeshArraysSUN
#define glDrawMeshArraysSUN_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glDrawMeshArraysSUN_NOT_VOID_WRAP(...) {}
#define pack_glDrawMeshArraysSUN(_mode, _first, _count, _width) ({ \
    glDrawMeshArraysSUN_PACKED *packed_data = malloc(sizeof(glDrawMeshArraysSUN_PACKED)); \
    packed_data->index = glDrawMeshArraysSUN_INDEX; \
    packed_data->args.mode = (GLenum)_mode; \
    packed_data->args.first = (GLint)_first; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.width = (GLsizei)_width; \
    (packed_call_t *)packed_data; \
})
#define call_glDrawMeshArraysSUN(packed, ret_v) do { \
    PACKED_glDrawMeshArraysSUN *unpacked = (PACKED_glDrawMeshArraysSUN *)packed; \
    ARGS_glDrawMeshArraysSUN *args = (ARGS_glDrawMeshArraysSUN *)&unpacked->args; \
    glDrawMeshArraysSUN(args->mode, args->first, args->count, args->width);; \
} while(0)
void glDrawMeshArraysSUN(glDrawMeshArraysSUN_ARG_EXPAND);
typedef void (*glDrawMeshArraysSUN_PTR)(glDrawMeshArraysSUN_ARG_EXPAND);
#define glDrawPixels_INDEX 512
#define glDrawPixels_RETURN void
#define glDrawPixels_ARG_NAMES width, height, format, type, pixels
#define glDrawPixels_ARG_EXPAND GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid * pixels
#define glDrawPixels_PACKED PACKED_glDrawPixels
#define glDrawPixels_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glDrawPixels_NOT_VOID_WRAP(...) {}
#define pack_glDrawPixels(_width, _height, _format, _type, _pixels) ({ \
    glDrawPixels_PACKED *packed_data = malloc(sizeof(glDrawPixels_PACKED)); \
    packed_data->index = glDrawPixels_INDEX; \
    packed_data->args.width = (GLsizei)_width; \
    packed_data->args.height = (GLsizei)_height; \
    packed_data->args.format = (GLenum)_format; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.pixels = (GLvoid *)_pixels; \
    (packed_call_t *)packed_data; \
})
#define call_glDrawPixels(packed, ret_v) do { \
    PACKED_glDrawPixels *unpacked = (PACKED_glDrawPixels *)packed; \
    ARGS_glDrawPixels *args = (ARGS_glDrawPixels *)&unpacked->args; \
    glDrawPixels(args->width, args->height, args->format, args->type, args->pixels);; \
} while(0)
void glDrawPixels(glDrawPixels_ARG_EXPAND);
typedef void (*glDrawPixels_PTR)(glDrawPixels_ARG_EXPAND);
#define glDrawRangeElementArrayAPPLE_INDEX 513
#define glDrawRangeElementArrayAPPLE_RETURN void
#define glDrawRangeElementArrayAPPLE_ARG_NAMES mode, start, end, first, count
#define glDrawRangeElementArrayAPPLE_ARG_EXPAND GLenum mode, GLuint start, GLuint end, GLint first, GLsizei count
#define glDrawRangeElementArrayAPPLE_PACKED PACKED_glDrawRangeElementArrayAPPLE
#define glDrawRangeElementArrayAPPLE_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glDrawRangeElementArrayAPPLE_NOT_VOID_WRAP(...) {}
#define pack_glDrawRangeElementArrayAPPLE(_mode, _start, _end, _first, _count) ({ \
    glDrawRangeElementArrayAPPLE_PACKED *packed_data = malloc(sizeof(glDrawRangeElementArrayAPPLE_PACKED)); \
    packed_data->index = glDrawRangeElementArrayAPPLE_INDEX; \
    packed_data->args.mode = (GLenum)_mode; \
    packed_data->args.start = (GLuint)_start; \
    packed_data->args.end = (GLuint)_end; \
    packed_data->args.first = (GLint)_first; \
    packed_data->args.count = (GLsizei)_count; \
    (packed_call_t *)packed_data; \
})
#define call_glDrawRangeElementArrayAPPLE(packed, ret_v) do { \
    PACKED_glDrawRangeElementArrayAPPLE *unpacked = (PACKED_glDrawRangeElementArrayAPPLE *)packed; \
    ARGS_glDrawRangeElementArrayAPPLE *args = (ARGS_glDrawRangeElementArrayAPPLE *)&unpacked->args; \
    glDrawRangeElementArrayAPPLE(args->mode, args->start, args->end, args->first, args->count);; \
} while(0)
void glDrawRangeElementArrayAPPLE(glDrawRangeElementArrayAPPLE_ARG_EXPAND);
typedef void (*glDrawRangeElementArrayAPPLE_PTR)(glDrawRangeElementArrayAPPLE_ARG_EXPAND);
#define glDrawRangeElementArrayATI_INDEX 514
#define glDrawRangeElementArrayATI_RETURN void
#define glDrawRangeElementArrayATI_ARG_NAMES mode, start, end, count
#define glDrawRangeElementArrayATI_ARG_EXPAND GLenum mode, GLuint start, GLuint end, GLsizei count
#define glDrawRangeElementArrayATI_PACKED PACKED_glDrawRangeElementArrayATI
#define glDrawRangeElementArrayATI_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glDrawRangeElementArrayATI_NOT_VOID_WRAP(...) {}
#define pack_glDrawRangeElementArrayATI(_mode, _start, _end, _count) ({ \
    glDrawRangeElementArrayATI_PACKED *packed_data = malloc(sizeof(glDrawRangeElementArrayATI_PACKED)); \
    packed_data->index = glDrawRangeElementArrayATI_INDEX; \
    packed_data->args.mode = (GLenum)_mode; \
    packed_data->args.start = (GLuint)_start; \
    packed_data->args.end = (GLuint)_end; \
    packed_data->args.count = (GLsizei)_count; \
    (packed_call_t *)packed_data; \
})
#define call_glDrawRangeElementArrayATI(packed, ret_v) do { \
    PACKED_glDrawRangeElementArrayATI *unpacked = (PACKED_glDrawRangeElementArrayATI *)packed; \
    ARGS_glDrawRangeElementArrayATI *args = (ARGS_glDrawRangeElementArrayATI *)&unpacked->args; \
    glDrawRangeElementArrayATI(args->mode, args->start, args->end, args->count);; \
} while(0)
void glDrawRangeElementArrayATI(glDrawRangeElementArrayATI_ARG_EXPAND);
typedef void (*glDrawRangeElementArrayATI_PTR)(glDrawRangeElementArrayATI_ARG_EXPAND);
#define glDrawRangeElements_INDEX 515
#define glDrawRangeElements_RETURN void
#define glDrawRangeElements_ARG_NAMES mode, start, end, count, type, indices
#define glDrawRangeElements_ARG_EXPAND GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid * indices
#define glDrawRangeElements_PACKED PACKED_glDrawRangeElements
#define glDrawRangeElements_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glDrawRangeElements_NOT_VOID_WRAP(...) {}
#define pack_glDrawRangeElements(_mode, _start, _end, _count, _type, _indices) ({ \
    glDrawRangeElements_PACKED *packed_data = malloc(sizeof(glDrawRangeElements_PACKED)); \
    packed_data->index = glDrawRangeElements_INDEX; \
    packed_data->args.mode = (GLenum)_mode; \
    packed_data->args.start = (GLuint)_start; \
    packed_data->args.end = (GLuint)_end; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.indices = (GLvoid *)_indices; \
    (packed_call_t *)packed_data; \
})
#define call_glDrawRangeElements(packed, ret_v) do { \
    PACKED_glDrawRangeElements *unpacked = (PACKED_glDrawRangeElements *)packed; \
    ARGS_glDrawRangeElements *args = (ARGS_glDrawRangeElements *)&unpacked->args; \
    glDrawRangeElements(args->mode, args->start, args->end, args->count, args->type, args->indices);; \
} while(0)
void glDrawRangeElements(glDrawRangeElements_ARG_EXPAND);
typedef void (*glDrawRangeElements_PTR)(glDrawRangeElements_ARG_EXPAND);
#define glDrawRangeElementsBaseVertex_INDEX 516
#define glDrawRangeElementsBaseVertex_RETURN void
#define glDrawRangeElementsBaseVertex_ARG_NAMES mode, start, end, count, type, indices, basevertex
#define glDrawRangeElementsBaseVertex_ARG_EXPAND GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid * indices, GLint basevertex
#define glDrawRangeElementsBaseVertex_PACKED PACKED_glDrawRangeElementsBaseVertex
#define glDrawRangeElementsBaseVertex_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glDrawRangeElementsBaseVertex_NOT_VOID_WRAP(...) {}
#define pack_glDrawRangeElementsBaseVertex(_mode, _start, _end, _count, _type, _indices, _basevertex) ({ \
    glDrawRangeElementsBaseVertex_PACKED *packed_data = malloc(sizeof(glDrawRangeElementsBaseVertex_PACKED)); \
    packed_data->index = glDrawRangeElementsBaseVertex_INDEX; \
    packed_data->args.mode = (GLenum)_mode; \
    packed_data->args.start = (GLuint)_start; \
    packed_data->args.end = (GLuint)_end; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.indices = (GLvoid *)_indices; \
    packed_data->args.basevertex = (GLint)_basevertex; \
    (packed_call_t *)packed_data; \
})
#define call_glDrawRangeElementsBaseVertex(packed, ret_v) do { \
    PACKED_glDrawRangeElementsBaseVertex *unpacked = (PACKED_glDrawRangeElementsBaseVertex *)packed; \
    ARGS_glDrawRangeElementsBaseVertex *args = (ARGS_glDrawRangeElementsBaseVertex *)&unpacked->args; \
    glDrawRangeElementsBaseVertex(args->mode, args->start, args->end, args->count, args->type, args->indices, args->basevertex);; \
} while(0)
void glDrawRangeElementsBaseVertex(glDrawRangeElementsBaseVertex_ARG_EXPAND);
typedef void (*glDrawRangeElementsBaseVertex_PTR)(glDrawRangeElementsBaseVertex_ARG_EXPAND);
#define glDrawRangeElementsEXT_INDEX 517
#define glDrawRangeElementsEXT_RETURN void
#define glDrawRangeElementsEXT_ARG_NAMES mode, start, end, count, type, indices
#define glDrawRangeElementsEXT_ARG_EXPAND GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid * indices
#define glDrawRangeElementsEXT_PACKED PACKED_glDrawRangeElementsEXT
#define glDrawRangeElementsEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glDrawRangeElementsEXT_NOT_VOID_WRAP(...) {}
#define pack_glDrawRangeElementsEXT(_mode, _start, _end, _count, _type, _indices) ({ \
    glDrawRangeElementsEXT_PACKED *packed_data = malloc(sizeof(glDrawRangeElementsEXT_PACKED)); \
    packed_data->index = glDrawRangeElementsEXT_INDEX; \
    packed_data->args.mode = (GLenum)_mode; \
    packed_data->args.start = (GLuint)_start; \
    packed_data->args.end = (GLuint)_end; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.indices = (GLvoid *)_indices; \
    (packed_call_t *)packed_data; \
})
#define call_glDrawRangeElementsEXT(packed, ret_v) do { \
    PACKED_glDrawRangeElementsEXT *unpacked = (PACKED_glDrawRangeElementsEXT *)packed; \
    ARGS_glDrawRangeElementsEXT *args = (ARGS_glDrawRangeElementsEXT *)&unpacked->args; \
    glDrawRangeElementsEXT(args->mode, args->start, args->end, args->count, args->type, args->indices);; \
} while(0)
void glDrawRangeElementsEXT(glDrawRangeElementsEXT_ARG_EXPAND);
typedef void (*glDrawRangeElementsEXT_PTR)(glDrawRangeElementsEXT_ARG_EXPAND);
#define glDrawTextureNV_INDEX 518
#define glDrawTextureNV_RETURN void
#define glDrawTextureNV_ARG_NAMES texture, sampler, x0, y0, x1, y1, z, s0, t0, s1, t1
#define glDrawTextureNV_ARG_EXPAND GLuint texture, GLuint sampler, GLfloat x0, GLfloat y0, GLfloat x1, GLfloat y1, GLfloat z, GLfloat s0, GLfloat t0, GLfloat s1, GLfloat t1
#define glDrawTextureNV_PACKED PACKED_glDrawTextureNV
#define glDrawTextureNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glDrawTextureNV_NOT_VOID_WRAP(...) {}
#define pack_glDrawTextureNV(_texture, _sampler, _x0, _y0, _x1, _y1, _z, _s0, _t0, _s1, _t1) ({ \
    glDrawTextureNV_PACKED *packed_data = malloc(sizeof(glDrawTextureNV_PACKED)); \
    packed_data->index = glDrawTextureNV_INDEX; \
    packed_data->args.texture = (GLuint)_texture; \
    packed_data->args.sampler = (GLuint)_sampler; \
    packed_data->args.x0 = (GLfloat)_x0; \
    packed_data->args.y0 = (GLfloat)_y0; \
    packed_data->args.x1 = (GLfloat)_x1; \
    packed_data->args.y1 = (GLfloat)_y1; \
    packed_data->args.z = (GLfloat)_z; \
    packed_data->args.s0 = (GLfloat)_s0; \
    packed_data->args.t0 = (GLfloat)_t0; \
    packed_data->args.s1 = (GLfloat)_s1; \
    packed_data->args.t1 = (GLfloat)_t1; \
    (packed_call_t *)packed_data; \
})
#define call_glDrawTextureNV(packed, ret_v) do { \
    PACKED_glDrawTextureNV *unpacked = (PACKED_glDrawTextureNV *)packed; \
    ARGS_glDrawTextureNV *args = (ARGS_glDrawTextureNV *)&unpacked->args; \
    glDrawTextureNV(args->texture, args->sampler, args->x0, args->y0, args->x1, args->y1, args->z, args->s0, args->t0, args->s1, args->t1);; \
} while(0)
void glDrawTextureNV(glDrawTextureNV_ARG_EXPAND);
typedef void (*glDrawTextureNV_PTR)(glDrawTextureNV_ARG_EXPAND);
#define glDrawTransformFeedback_INDEX 519
#define glDrawTransformFeedback_RETURN void
#define glDrawTransformFeedback_ARG_NAMES mode, id
#define glDrawTransformFeedback_ARG_EXPAND GLenum mode, GLuint id
#define glDrawTransformFeedback_PACKED PACKED_glDrawTransformFeedback
#define glDrawTransformFeedback_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glDrawTransformFeedback_NOT_VOID_WRAP(...) {}
#define pack_glDrawTransformFeedback(_mode, _id) ({ \
    glDrawTransformFeedback_PACKED *packed_data = malloc(sizeof(glDrawTransformFeedback_PACKED)); \
    packed_data->index = glDrawTransformFeedback_INDEX; \
    packed_data->args.mode = (GLenum)_mode; \
    packed_data->args.id = (GLuint)_id; \
    (packed_call_t *)packed_data; \
})
#define call_glDrawTransformFeedback(packed, ret_v) do { \
    PACKED_glDrawTransformFeedback *unpacked = (PACKED_glDrawTransformFeedback *)packed; \
    ARGS_glDrawTransformFeedback *args = (ARGS_glDrawTransformFeedback *)&unpacked->args; \
    glDrawTransformFeedback(args->mode, args->id);; \
} while(0)
void glDrawTransformFeedback(glDrawTransformFeedback_ARG_EXPAND);
typedef void (*glDrawTransformFeedback_PTR)(glDrawTransformFeedback_ARG_EXPAND);
#define glDrawTransformFeedbackInstanced_INDEX 520
#define glDrawTransformFeedbackInstanced_RETURN void
#define glDrawTransformFeedbackInstanced_ARG_NAMES mode, id, instancecount
#define glDrawTransformFeedbackInstanced_ARG_EXPAND GLenum mode, GLuint id, GLsizei instancecount
#define glDrawTransformFeedbackInstanced_PACKED PACKED_glDrawTransformFeedbackInstanced
#define glDrawTransformFeedbackInstanced_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glDrawTransformFeedbackInstanced_NOT_VOID_WRAP(...) {}
#define pack_glDrawTransformFeedbackInstanced(_mode, _id, _instancecount) ({ \
    glDrawTransformFeedbackInstanced_PACKED *packed_data = malloc(sizeof(glDrawTransformFeedbackInstanced_PACKED)); \
    packed_data->index = glDrawTransformFeedbackInstanced_INDEX; \
    packed_data->args.mode = (GLenum)_mode; \
    packed_data->args.id = (GLuint)_id; \
    packed_data->args.instancecount = (GLsizei)_instancecount; \
    (packed_call_t *)packed_data; \
})
#define call_glDrawTransformFeedbackInstanced(packed, ret_v) do { \
    PACKED_glDrawTransformFeedbackInstanced *unpacked = (PACKED_glDrawTransformFeedbackInstanced *)packed; \
    ARGS_glDrawTransformFeedbackInstanced *args = (ARGS_glDrawTransformFeedbackInstanced *)&unpacked->args; \
    glDrawTransformFeedbackInstanced(args->mode, args->id, args->instancecount);; \
} while(0)
void glDrawTransformFeedbackInstanced(glDrawTransformFeedbackInstanced_ARG_EXPAND);
typedef void (*glDrawTransformFeedbackInstanced_PTR)(glDrawTransformFeedbackInstanced_ARG_EXPAND);
#define glDrawTransformFeedbackNV_INDEX 521
#define glDrawTransformFeedbackNV_RETURN void
#define glDrawTransformFeedbackNV_ARG_NAMES mode, id
#define glDrawTransformFeedbackNV_ARG_EXPAND GLenum mode, GLuint id
#define glDrawTransformFeedbackNV_PACKED PACKED_glDrawTransformFeedbackNV
#define glDrawTransformFeedbackNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glDrawTransformFeedbackNV_NOT_VOID_WRAP(...) {}
#define pack_glDrawTransformFeedbackNV(_mode, _id) ({ \
    glDrawTransformFeedbackNV_PACKED *packed_data = malloc(sizeof(glDrawTransformFeedbackNV_PACKED)); \
    packed_data->index = glDrawTransformFeedbackNV_INDEX; \
    packed_data->args.mode = (GLenum)_mode; \
    packed_data->args.id = (GLuint)_id; \
    (packed_call_t *)packed_data; \
})
#define call_glDrawTransformFeedbackNV(packed, ret_v) do { \
    PACKED_glDrawTransformFeedbackNV *unpacked = (PACKED_glDrawTransformFeedbackNV *)packed; \
    ARGS_glDrawTransformFeedbackNV *args = (ARGS_glDrawTransformFeedbackNV *)&unpacked->args; \
    glDrawTransformFeedbackNV(args->mode, args->id);; \
} while(0)
void glDrawTransformFeedbackNV(glDrawTransformFeedbackNV_ARG_EXPAND);
typedef void (*glDrawTransformFeedbackNV_PTR)(glDrawTransformFeedbackNV_ARG_EXPAND);
#define glDrawTransformFeedbackStream_INDEX 522
#define glDrawTransformFeedbackStream_RETURN void
#define glDrawTransformFeedbackStream_ARG_NAMES mode, id, stream
#define glDrawTransformFeedbackStream_ARG_EXPAND GLenum mode, GLuint id, GLuint stream
#define glDrawTransformFeedbackStream_PACKED PACKED_glDrawTransformFeedbackStream
#define glDrawTransformFeedbackStream_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glDrawTransformFeedbackStream_NOT_VOID_WRAP(...) {}
#define pack_glDrawTransformFeedbackStream(_mode, _id, _stream) ({ \
    glDrawTransformFeedbackStream_PACKED *packed_data = malloc(sizeof(glDrawTransformFeedbackStream_PACKED)); \
    packed_data->index = glDrawTransformFeedbackStream_INDEX; \
    packed_data->args.mode = (GLenum)_mode; \
    packed_data->args.id = (GLuint)_id; \
    packed_data->args.stream = (GLuint)_stream; \
    (packed_call_t *)packed_data; \
})
#define call_glDrawTransformFeedbackStream(packed, ret_v) do { \
    PACKED_glDrawTransformFeedbackStream *unpacked = (PACKED_glDrawTransformFeedbackStream *)packed; \
    ARGS_glDrawTransformFeedbackStream *args = (ARGS_glDrawTransformFeedbackStream *)&unpacked->args; \
    glDrawTransformFeedbackStream(args->mode, args->id, args->stream);; \
} while(0)
void glDrawTransformFeedbackStream(glDrawTransformFeedbackStream_ARG_EXPAND);
typedef void (*glDrawTransformFeedbackStream_PTR)(glDrawTransformFeedbackStream_ARG_EXPAND);
#define glDrawTransformFeedbackStreamInstanced_INDEX 523
#define glDrawTransformFeedbackStreamInstanced_RETURN void
#define glDrawTransformFeedbackStreamInstanced_ARG_NAMES mode, id, stream, instancecount
#define glDrawTransformFeedbackStreamInstanced_ARG_EXPAND GLenum mode, GLuint id, GLuint stream, GLsizei instancecount
#define glDrawTransformFeedbackStreamInstanced_PACKED PACKED_glDrawTransformFeedbackStreamInstanced
#define glDrawTransformFeedbackStreamInstanced_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glDrawTransformFeedbackStreamInstanced_NOT_VOID_WRAP(...) {}
#define pack_glDrawTransformFeedbackStreamInstanced(_mode, _id, _stream, _instancecount) ({ \
    glDrawTransformFeedbackStreamInstanced_PACKED *packed_data = malloc(sizeof(glDrawTransformFeedbackStreamInstanced_PACKED)); \
    packed_data->index = glDrawTransformFeedbackStreamInstanced_INDEX; \
    packed_data->args.mode = (GLenum)_mode; \
    packed_data->args.id = (GLuint)_id; \
    packed_data->args.stream = (GLuint)_stream; \
    packed_data->args.instancecount = (GLsizei)_instancecount; \
    (packed_call_t *)packed_data; \
})
#define call_glDrawTransformFeedbackStreamInstanced(packed, ret_v) do { \
    PACKED_glDrawTransformFeedbackStreamInstanced *unpacked = (PACKED_glDrawTransformFeedbackStreamInstanced *)packed; \
    ARGS_glDrawTransformFeedbackStreamInstanced *args = (ARGS_glDrawTransformFeedbackStreamInstanced *)&unpacked->args; \
    glDrawTransformFeedbackStreamInstanced(args->mode, args->id, args->stream, args->instancecount);; \
} while(0)
void glDrawTransformFeedbackStreamInstanced(glDrawTransformFeedbackStreamInstanced_ARG_EXPAND);
typedef void (*glDrawTransformFeedbackStreamInstanced_PTR)(glDrawTransformFeedbackStreamInstanced_ARG_EXPAND);
#define glEdgeFlag_INDEX 524
#define glEdgeFlag_RETURN void
#define glEdgeFlag_ARG_NAMES flag
#define glEdgeFlag_ARG_EXPAND GLboolean flag
#define glEdgeFlag_PACKED PACKED_glEdgeFlag
#define glEdgeFlag_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glEdgeFlag_NOT_VOID_WRAP(...) {}
#define pack_glEdgeFlag(_flag) ({ \
    glEdgeFlag_PACKED *packed_data = malloc(sizeof(glEdgeFlag_PACKED)); \
    packed_data->index = glEdgeFlag_INDEX; \
    packed_data->args.flag = (GLboolean)_flag; \
    (packed_call_t *)packed_data; \
})
#define call_glEdgeFlag(packed, ret_v) do { \
    PACKED_glEdgeFlag *unpacked = (PACKED_glEdgeFlag *)packed; \
    ARGS_glEdgeFlag *args = (ARGS_glEdgeFlag *)&unpacked->args; \
    glEdgeFlag(args->flag);; \
} while(0)
void glEdgeFlag(glEdgeFlag_ARG_EXPAND);
typedef void (*glEdgeFlag_PTR)(glEdgeFlag_ARG_EXPAND);
#define glEdgeFlagFormatNV_INDEX 525
#define glEdgeFlagFormatNV_RETURN void
#define glEdgeFlagFormatNV_ARG_NAMES stride
#define glEdgeFlagFormatNV_ARG_EXPAND GLsizei stride
#define glEdgeFlagFormatNV_PACKED PACKED_glEdgeFlagFormatNV
#define glEdgeFlagFormatNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glEdgeFlagFormatNV_NOT_VOID_WRAP(...) {}
#define pack_glEdgeFlagFormatNV(_stride) ({ \
    glEdgeFlagFormatNV_PACKED *packed_data = malloc(sizeof(glEdgeFlagFormatNV_PACKED)); \
    packed_data->index = glEdgeFlagFormatNV_INDEX; \
    packed_data->args.stride = (GLsizei)_stride; \
    (packed_call_t *)packed_data; \
})
#define call_glEdgeFlagFormatNV(packed, ret_v) do { \
    PACKED_glEdgeFlagFormatNV *unpacked = (PACKED_glEdgeFlagFormatNV *)packed; \
    ARGS_glEdgeFlagFormatNV *args = (ARGS_glEdgeFlagFormatNV *)&unpacked->args; \
    glEdgeFlagFormatNV(args->stride);; \
} while(0)
void glEdgeFlagFormatNV(glEdgeFlagFormatNV_ARG_EXPAND);
typedef void (*glEdgeFlagFormatNV_PTR)(glEdgeFlagFormatNV_ARG_EXPAND);
#define glEdgeFlagPointer_INDEX 526
#define glEdgeFlagPointer_RETURN void
#define glEdgeFlagPointer_ARG_NAMES stride, pointer
#define glEdgeFlagPointer_ARG_EXPAND GLsizei stride, const GLvoid * pointer
#define glEdgeFlagPointer_PACKED PACKED_glEdgeFlagPointer
#define glEdgeFlagPointer_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glEdgeFlagPointer_NOT_VOID_WRAP(...) {}
#define pack_glEdgeFlagPointer(_stride, _pointer) ({ \
    glEdgeFlagPointer_PACKED *packed_data = malloc(sizeof(glEdgeFlagPointer_PACKED)); \
    packed_data->index = glEdgeFlagPointer_INDEX; \
    packed_data->args.stride = (GLsizei)_stride; \
    packed_data->args.pointer = (GLvoid *)_pointer; \
    (packed_call_t *)packed_data; \
})
#define call_glEdgeFlagPointer(packed, ret_v) do { \
    PACKED_glEdgeFlagPointer *unpacked = (PACKED_glEdgeFlagPointer *)packed; \
    ARGS_glEdgeFlagPointer *args = (ARGS_glEdgeFlagPointer *)&unpacked->args; \
    glEdgeFlagPointer(args->stride, args->pointer);; \
} while(0)
void glEdgeFlagPointer(glEdgeFlagPointer_ARG_EXPAND);
typedef void (*glEdgeFlagPointer_PTR)(glEdgeFlagPointer_ARG_EXPAND);
#define glEdgeFlagPointerEXT_INDEX 527
#define glEdgeFlagPointerEXT_RETURN void
#define glEdgeFlagPointerEXT_ARG_NAMES stride, count, pointer
#define glEdgeFlagPointerEXT_ARG_EXPAND GLsizei stride, GLsizei count, const GLboolean * pointer
#define glEdgeFlagPointerEXT_PACKED PACKED_glEdgeFlagPointerEXT
#define glEdgeFlagPointerEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glEdgeFlagPointerEXT_NOT_VOID_WRAP(...) {}
#define pack_glEdgeFlagPointerEXT(_stride, _count, _pointer) ({ \
    glEdgeFlagPointerEXT_PACKED *packed_data = malloc(sizeof(glEdgeFlagPointerEXT_PACKED)); \
    packed_data->index = glEdgeFlagPointerEXT_INDEX; \
    packed_data->args.stride = (GLsizei)_stride; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.pointer = (GLboolean *)_pointer; \
    (packed_call_t *)packed_data; \
})
#define call_glEdgeFlagPointerEXT(packed, ret_v) do { \
    PACKED_glEdgeFlagPointerEXT *unpacked = (PACKED_glEdgeFlagPointerEXT *)packed; \
    ARGS_glEdgeFlagPointerEXT *args = (ARGS_glEdgeFlagPointerEXT *)&unpacked->args; \
    glEdgeFlagPointerEXT(args->stride, args->count, args->pointer);; \
} while(0)
void glEdgeFlagPointerEXT(glEdgeFlagPointerEXT_ARG_EXPAND);
typedef void (*glEdgeFlagPointerEXT_PTR)(glEdgeFlagPointerEXT_ARG_EXPAND);
#define glEdgeFlagPointerListIBM_INDEX 528
#define glEdgeFlagPointerListIBM_RETURN void
#define glEdgeFlagPointerListIBM_ARG_NAMES stride, pointer, ptrstride
#define glEdgeFlagPointerListIBM_ARG_EXPAND GLint stride, const GLboolean * pointer, GLint ptrstride
#define glEdgeFlagPointerListIBM_PACKED PACKED_glEdgeFlagPointerListIBM
#define glEdgeFlagPointerListIBM_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glEdgeFlagPointerListIBM_NOT_VOID_WRAP(...) {}
#define pack_glEdgeFlagPointerListIBM(_stride, _pointer, _ptrstride) ({ \
    glEdgeFlagPointerListIBM_PACKED *packed_data = malloc(sizeof(glEdgeFlagPointerListIBM_PACKED)); \
    packed_data->index = glEdgeFlagPointerListIBM_INDEX; \
    packed_data->args.stride = (GLint)_stride; \
    packed_data->args.pointer = (GLboolean *)_pointer; \
    packed_data->args.ptrstride = (GLint)_ptrstride; \
    (packed_call_t *)packed_data; \
})
#define call_glEdgeFlagPointerListIBM(packed, ret_v) do { \
    PACKED_glEdgeFlagPointerListIBM *unpacked = (PACKED_glEdgeFlagPointerListIBM *)packed; \
    ARGS_glEdgeFlagPointerListIBM *args = (ARGS_glEdgeFlagPointerListIBM *)&unpacked->args; \
    glEdgeFlagPointerListIBM(args->stride, args->pointer, args->ptrstride);; \
} while(0)
void glEdgeFlagPointerListIBM(glEdgeFlagPointerListIBM_ARG_EXPAND);
typedef void (*glEdgeFlagPointerListIBM_PTR)(glEdgeFlagPointerListIBM_ARG_EXPAND);
#define glEdgeFlagv_INDEX 529
#define glEdgeFlagv_RETURN void
#define glEdgeFlagv_ARG_NAMES flag
#define glEdgeFlagv_ARG_EXPAND const GLboolean * flag
#define glEdgeFlagv_PACKED PACKED_glEdgeFlagv
#define glEdgeFlagv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glEdgeFlagv_NOT_VOID_WRAP(...) {}
#define pack_glEdgeFlagv(_flag) ({ \
    glEdgeFlagv_PACKED *packed_data = malloc(sizeof(glEdgeFlagv_PACKED)); \
    packed_data->index = glEdgeFlagv_INDEX; \
    packed_data->args.flag = (GLboolean *)_flag; \
    (packed_call_t *)packed_data; \
})
#define call_glEdgeFlagv(packed, ret_v) do { \
    PACKED_glEdgeFlagv *unpacked = (PACKED_glEdgeFlagv *)packed; \
    ARGS_glEdgeFlagv *args = (ARGS_glEdgeFlagv *)&unpacked->args; \
    glEdgeFlagv(args->flag);; \
} while(0)
void glEdgeFlagv(glEdgeFlagv_ARG_EXPAND);
typedef void (*glEdgeFlagv_PTR)(glEdgeFlagv_ARG_EXPAND);
#define glElementPointerAPPLE_INDEX 530
#define glElementPointerAPPLE_RETURN void
#define glElementPointerAPPLE_ARG_NAMES type, pointer
#define glElementPointerAPPLE_ARG_EXPAND GLenum type, const GLvoid * pointer
#define glElementPointerAPPLE_PACKED PACKED_glElementPointerAPPLE
#define glElementPointerAPPLE_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glElementPointerAPPLE_NOT_VOID_WRAP(...) {}
#define pack_glElementPointerAPPLE(_type, _pointer) ({ \
    glElementPointerAPPLE_PACKED *packed_data = malloc(sizeof(glElementPointerAPPLE_PACKED)); \
    packed_data->index = glElementPointerAPPLE_INDEX; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.pointer = (GLvoid *)_pointer; \
    (packed_call_t *)packed_data; \
})
#define call_glElementPointerAPPLE(packed, ret_v) do { \
    PACKED_glElementPointerAPPLE *unpacked = (PACKED_glElementPointerAPPLE *)packed; \
    ARGS_glElementPointerAPPLE *args = (ARGS_glElementPointerAPPLE *)&unpacked->args; \
    glElementPointerAPPLE(args->type, args->pointer);; \
} while(0)
void glElementPointerAPPLE(glElementPointerAPPLE_ARG_EXPAND);
typedef void (*glElementPointerAPPLE_PTR)(glElementPointerAPPLE_ARG_EXPAND);
#define glElementPointerATI_INDEX 531
#define glElementPointerATI_RETURN void
#define glElementPointerATI_ARG_NAMES type, pointer
#define glElementPointerATI_ARG_EXPAND GLenum type, const GLvoid * pointer
#define glElementPointerATI_PACKED PACKED_glElementPointerATI
#define glElementPointerATI_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glElementPointerATI_NOT_VOID_WRAP(...) {}
#define pack_glElementPointerATI(_type, _pointer) ({ \
    glElementPointerATI_PACKED *packed_data = malloc(sizeof(glElementPointerATI_PACKED)); \
    packed_data->index = glElementPointerATI_INDEX; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.pointer = (GLvoid *)_pointer; \
    (packed_call_t *)packed_data; \
})
#define call_glElementPointerATI(packed, ret_v) do { \
    PACKED_glElementPointerATI *unpacked = (PACKED_glElementPointerATI *)packed; \
    ARGS_glElementPointerATI *args = (ARGS_glElementPointerATI *)&unpacked->args; \
    glElementPointerATI(args->type, args->pointer);; \
} while(0)
void glElementPointerATI(glElementPointerATI_ARG_EXPAND);
typedef void (*glElementPointerATI_PTR)(glElementPointerATI_ARG_EXPAND);
#define glEnable_INDEX 532
#define glEnable_RETURN void
#define glEnable_ARG_NAMES cap
#define glEnable_ARG_EXPAND GLenum cap
#define glEnable_PACKED PACKED_glEnable
#define glEnable_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glEnable_NOT_VOID_WRAP(...) {}
#define pack_glEnable(_cap) ({ \
    glEnable_PACKED *packed_data = malloc(sizeof(glEnable_PACKED)); \
    packed_data->index = glEnable_INDEX; \
    packed_data->args.cap = (GLenum)_cap; \
    (packed_call_t *)packed_data; \
})
#define call_glEnable(packed, ret_v) do { \
    PACKED_glEnable *unpacked = (PACKED_glEnable *)packed; \
    ARGS_glEnable *args = (ARGS_glEnable *)&unpacked->args; \
    glEnable(args->cap);; \
} while(0)
void glEnable(glEnable_ARG_EXPAND);
typedef void (*glEnable_PTR)(glEnable_ARG_EXPAND);
#define glEnableClientState_INDEX 533
#define glEnableClientState_RETURN void
#define glEnableClientState_ARG_NAMES array
#define glEnableClientState_ARG_EXPAND GLenum array
#define glEnableClientState_PACKED PACKED_glEnableClientState
#define glEnableClientState_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glEnableClientState_NOT_VOID_WRAP(...) {}
#define pack_glEnableClientState(_array) ({ \
    glEnableClientState_PACKED *packed_data = malloc(sizeof(glEnableClientState_PACKED)); \
    packed_data->index = glEnableClientState_INDEX; \
    packed_data->args.array = (GLenum)_array; \
    (packed_call_t *)packed_data; \
})
#define call_glEnableClientState(packed, ret_v) do { \
    PACKED_glEnableClientState *unpacked = (PACKED_glEnableClientState *)packed; \
    ARGS_glEnableClientState *args = (ARGS_glEnableClientState *)&unpacked->args; \
    glEnableClientState(args->array);; \
} while(0)
void glEnableClientState(glEnableClientState_ARG_EXPAND);
typedef void (*glEnableClientState_PTR)(glEnableClientState_ARG_EXPAND);
#define glEnableClientStateIndexedEXT_INDEX 534
#define glEnableClientStateIndexedEXT_RETURN void
#define glEnableClientStateIndexedEXT_ARG_NAMES array, index
#define glEnableClientStateIndexedEXT_ARG_EXPAND GLenum array, GLuint index
#define glEnableClientStateIndexedEXT_PACKED PACKED_glEnableClientStateIndexedEXT
#define glEnableClientStateIndexedEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glEnableClientStateIndexedEXT_NOT_VOID_WRAP(...) {}
#define pack_glEnableClientStateIndexedEXT(_array, _index) ({ \
    glEnableClientStateIndexedEXT_PACKED *packed_data = malloc(sizeof(glEnableClientStateIndexedEXT_PACKED)); \
    packed_data->index = glEnableClientStateIndexedEXT_INDEX; \
    packed_data->args.array = (GLenum)_array; \
    packed_data->args.index = (GLuint)_index; \
    (packed_call_t *)packed_data; \
})
#define call_glEnableClientStateIndexedEXT(packed, ret_v) do { \
    PACKED_glEnableClientStateIndexedEXT *unpacked = (PACKED_glEnableClientStateIndexedEXT *)packed; \
    ARGS_glEnableClientStateIndexedEXT *args = (ARGS_glEnableClientStateIndexedEXT *)&unpacked->args; \
    glEnableClientStateIndexedEXT(args->array, args->index);; \
} while(0)
void glEnableClientStateIndexedEXT(glEnableClientStateIndexedEXT_ARG_EXPAND);
typedef void (*glEnableClientStateIndexedEXT_PTR)(glEnableClientStateIndexedEXT_ARG_EXPAND);
#define glEnableClientStateiEXT_INDEX 535
#define glEnableClientStateiEXT_RETURN void
#define glEnableClientStateiEXT_ARG_NAMES array, index
#define glEnableClientStateiEXT_ARG_EXPAND GLenum array, GLuint index
#define glEnableClientStateiEXT_PACKED PACKED_glEnableClientStateiEXT
#define glEnableClientStateiEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glEnableClientStateiEXT_NOT_VOID_WRAP(...) {}
#define pack_glEnableClientStateiEXT(_array, _index) ({ \
    glEnableClientStateiEXT_PACKED *packed_data = malloc(sizeof(glEnableClientStateiEXT_PACKED)); \
    packed_data->index = glEnableClientStateiEXT_INDEX; \
    packed_data->args.array = (GLenum)_array; \
    packed_data->args.index = (GLuint)_index; \
    (packed_call_t *)packed_data; \
})
#define call_glEnableClientStateiEXT(packed, ret_v) do { \
    PACKED_glEnableClientStateiEXT *unpacked = (PACKED_glEnableClientStateiEXT *)packed; \
    ARGS_glEnableClientStateiEXT *args = (ARGS_glEnableClientStateiEXT *)&unpacked->args; \
    glEnableClientStateiEXT(args->array, args->index);; \
} while(0)
void glEnableClientStateiEXT(glEnableClientStateiEXT_ARG_EXPAND);
typedef void (*glEnableClientStateiEXT_PTR)(glEnableClientStateiEXT_ARG_EXPAND);
#define glEnableIndexedEXT_INDEX 536
#define glEnableIndexedEXT_RETURN void
#define glEnableIndexedEXT_ARG_NAMES target, index
#define glEnableIndexedEXT_ARG_EXPAND GLenum target, GLuint index
#define glEnableIndexedEXT_PACKED PACKED_glEnableIndexedEXT
#define glEnableIndexedEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glEnableIndexedEXT_NOT_VOID_WRAP(...) {}
#define pack_glEnableIndexedEXT(_target, _index) ({ \
    glEnableIndexedEXT_PACKED *packed_data = malloc(sizeof(glEnableIndexedEXT_PACKED)); \
    packed_data->index = glEnableIndexedEXT_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.index = (GLuint)_index; \
    (packed_call_t *)packed_data; \
})
#define call_glEnableIndexedEXT(packed, ret_v) do { \
    PACKED_glEnableIndexedEXT *unpacked = (PACKED_glEnableIndexedEXT *)packed; \
    ARGS_glEnableIndexedEXT *args = (ARGS_glEnableIndexedEXT *)&unpacked->args; \
    glEnableIndexedEXT(args->target, args->index);; \
} while(0)
void glEnableIndexedEXT(glEnableIndexedEXT_ARG_EXPAND);
typedef void (*glEnableIndexedEXT_PTR)(glEnableIndexedEXT_ARG_EXPAND);
#define glEnableVariantClientStateEXT_INDEX 537
#define glEnableVariantClientStateEXT_RETURN void
#define glEnableVariantClientStateEXT_ARG_NAMES id
#define glEnableVariantClientStateEXT_ARG_EXPAND GLuint id
#define glEnableVariantClientStateEXT_PACKED PACKED_glEnableVariantClientStateEXT
#define glEnableVariantClientStateEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glEnableVariantClientStateEXT_NOT_VOID_WRAP(...) {}
#define pack_glEnableVariantClientStateEXT(_id) ({ \
    glEnableVariantClientStateEXT_PACKED *packed_data = malloc(sizeof(glEnableVariantClientStateEXT_PACKED)); \
    packed_data->index = glEnableVariantClientStateEXT_INDEX; \
    packed_data->args.id = (GLuint)_id; \
    (packed_call_t *)packed_data; \
})
#define call_glEnableVariantClientStateEXT(packed, ret_v) do { \
    PACKED_glEnableVariantClientStateEXT *unpacked = (PACKED_glEnableVariantClientStateEXT *)packed; \
    ARGS_glEnableVariantClientStateEXT *args = (ARGS_glEnableVariantClientStateEXT *)&unpacked->args; \
    glEnableVariantClientStateEXT(args->id);; \
} while(0)
void glEnableVariantClientStateEXT(glEnableVariantClientStateEXT_ARG_EXPAND);
typedef void (*glEnableVariantClientStateEXT_PTR)(glEnableVariantClientStateEXT_ARG_EXPAND);
#define glEnableVertexArrayAttribEXT_INDEX 538
#define glEnableVertexArrayAttribEXT_RETURN void
#define glEnableVertexArrayAttribEXT_ARG_NAMES vaobj, index
#define glEnableVertexArrayAttribEXT_ARG_EXPAND GLuint vaobj, GLuint index
#define glEnableVertexArrayAttribEXT_PACKED PACKED_glEnableVertexArrayAttribEXT
#define glEnableVertexArrayAttribEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glEnableVertexArrayAttribEXT_NOT_VOID_WRAP(...) {}
#define pack_glEnableVertexArrayAttribEXT(_vaobj, _index) ({ \
    glEnableVertexArrayAttribEXT_PACKED *packed_data = malloc(sizeof(glEnableVertexArrayAttribEXT_PACKED)); \
    packed_data->index = glEnableVertexArrayAttribEXT_INDEX; \
    packed_data->args.vaobj = (GLuint)_vaobj; \
    packed_data->args.index = (GLuint)_index; \
    (packed_call_t *)packed_data; \
})
#define call_glEnableVertexArrayAttribEXT(packed, ret_v) do { \
    PACKED_glEnableVertexArrayAttribEXT *unpacked = (PACKED_glEnableVertexArrayAttribEXT *)packed; \
    ARGS_glEnableVertexArrayAttribEXT *args = (ARGS_glEnableVertexArrayAttribEXT *)&unpacked->args; \
    glEnableVertexArrayAttribEXT(args->vaobj, args->index);; \
} while(0)
void glEnableVertexArrayAttribEXT(glEnableVertexArrayAttribEXT_ARG_EXPAND);
typedef void (*glEnableVertexArrayAttribEXT_PTR)(glEnableVertexArrayAttribEXT_ARG_EXPAND);
#define glEnableVertexArrayEXT_INDEX 539
#define glEnableVertexArrayEXT_RETURN void
#define glEnableVertexArrayEXT_ARG_NAMES vaobj, array
#define glEnableVertexArrayEXT_ARG_EXPAND GLuint vaobj, GLenum array
#define glEnableVertexArrayEXT_PACKED PACKED_glEnableVertexArrayEXT
#define glEnableVertexArrayEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glEnableVertexArrayEXT_NOT_VOID_WRAP(...) {}
#define pack_glEnableVertexArrayEXT(_vaobj, _array) ({ \
    glEnableVertexArrayEXT_PACKED *packed_data = malloc(sizeof(glEnableVertexArrayEXT_PACKED)); \
    packed_data->index = glEnableVertexArrayEXT_INDEX; \
    packed_data->args.vaobj = (GLuint)_vaobj; \
    packed_data->args.array = (GLenum)_array; \
    (packed_call_t *)packed_data; \
})
#define call_glEnableVertexArrayEXT(packed, ret_v) do { \
    PACKED_glEnableVertexArrayEXT *unpacked = (PACKED_glEnableVertexArrayEXT *)packed; \
    ARGS_glEnableVertexArrayEXT *args = (ARGS_glEnableVertexArrayEXT *)&unpacked->args; \
    glEnableVertexArrayEXT(args->vaobj, args->array);; \
} while(0)
void glEnableVertexArrayEXT(glEnableVertexArrayEXT_ARG_EXPAND);
typedef void (*glEnableVertexArrayEXT_PTR)(glEnableVertexArrayEXT_ARG_EXPAND);
#define glEnableVertexAttribAPPLE_INDEX 540
#define glEnableVertexAttribAPPLE_RETURN void
#define glEnableVertexAttribAPPLE_ARG_NAMES index, pname
#define glEnableVertexAttribAPPLE_ARG_EXPAND GLuint index, GLenum pname
#define glEnableVertexAttribAPPLE_PACKED PACKED_glEnableVertexAttribAPPLE
#define glEnableVertexAttribAPPLE_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glEnableVertexAttribAPPLE_NOT_VOID_WRAP(...) {}
#define pack_glEnableVertexAttribAPPLE(_index, _pname) ({ \
    glEnableVertexAttribAPPLE_PACKED *packed_data = malloc(sizeof(glEnableVertexAttribAPPLE_PACKED)); \
    packed_data->index = glEnableVertexAttribAPPLE_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.pname = (GLenum)_pname; \
    (packed_call_t *)packed_data; \
})
#define call_glEnableVertexAttribAPPLE(packed, ret_v) do { \
    PACKED_glEnableVertexAttribAPPLE *unpacked = (PACKED_glEnableVertexAttribAPPLE *)packed; \
    ARGS_glEnableVertexAttribAPPLE *args = (ARGS_glEnableVertexAttribAPPLE *)&unpacked->args; \
    glEnableVertexAttribAPPLE(args->index, args->pname);; \
} while(0)
void glEnableVertexAttribAPPLE(glEnableVertexAttribAPPLE_ARG_EXPAND);
typedef void (*glEnableVertexAttribAPPLE_PTR)(glEnableVertexAttribAPPLE_ARG_EXPAND);
#define glEnableVertexAttribArray_INDEX 541
#define glEnableVertexAttribArray_RETURN void
#define glEnableVertexAttribArray_ARG_NAMES index
#define glEnableVertexAttribArray_ARG_EXPAND GLuint index
#define glEnableVertexAttribArray_PACKED PACKED_glEnableVertexAttribArray
#define glEnableVertexAttribArray_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glEnableVertexAttribArray_NOT_VOID_WRAP(...) {}
#define pack_glEnableVertexAttribArray(_index) ({ \
    glEnableVertexAttribArray_PACKED *packed_data = malloc(sizeof(glEnableVertexAttribArray_PACKED)); \
    packed_data->index = glEnableVertexAttribArray_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    (packed_call_t *)packed_data; \
})
#define call_glEnableVertexAttribArray(packed, ret_v) do { \
    PACKED_glEnableVertexAttribArray *unpacked = (PACKED_glEnableVertexAttribArray *)packed; \
    ARGS_glEnableVertexAttribArray *args = (ARGS_glEnableVertexAttribArray *)&unpacked->args; \
    glEnableVertexAttribArray(args->index);; \
} while(0)
void glEnableVertexAttribArray(glEnableVertexAttribArray_ARG_EXPAND);
typedef void (*glEnableVertexAttribArray_PTR)(glEnableVertexAttribArray_ARG_EXPAND);
#define glEnableVertexAttribArrayARB_INDEX 542
#define glEnableVertexAttribArrayARB_RETURN void
#define glEnableVertexAttribArrayARB_ARG_NAMES index
#define glEnableVertexAttribArrayARB_ARG_EXPAND GLuint index
#define glEnableVertexAttribArrayARB_PACKED PACKED_glEnableVertexAttribArrayARB
#define glEnableVertexAttribArrayARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glEnableVertexAttribArrayARB_NOT_VOID_WRAP(...) {}
#define pack_glEnableVertexAttribArrayARB(_index) ({ \
    glEnableVertexAttribArrayARB_PACKED *packed_data = malloc(sizeof(glEnableVertexAttribArrayARB_PACKED)); \
    packed_data->index = glEnableVertexAttribArrayARB_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    (packed_call_t *)packed_data; \
})
#define call_glEnableVertexAttribArrayARB(packed, ret_v) do { \
    PACKED_glEnableVertexAttribArrayARB *unpacked = (PACKED_glEnableVertexAttribArrayARB *)packed; \
    ARGS_glEnableVertexAttribArrayARB *args = (ARGS_glEnableVertexAttribArrayARB *)&unpacked->args; \
    glEnableVertexAttribArrayARB(args->index);; \
} while(0)
void glEnableVertexAttribArrayARB(glEnableVertexAttribArrayARB_ARG_EXPAND);
typedef void (*glEnableVertexAttribArrayARB_PTR)(glEnableVertexAttribArrayARB_ARG_EXPAND);
#define glEnablei_INDEX 543
#define glEnablei_RETURN void
#define glEnablei_ARG_NAMES target, index
#define glEnablei_ARG_EXPAND GLenum target, GLuint index
#define glEnablei_PACKED PACKED_glEnablei
#define glEnablei_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glEnablei_NOT_VOID_WRAP(...) {}
#define pack_glEnablei(_target, _index) ({ \
    glEnablei_PACKED *packed_data = malloc(sizeof(glEnablei_PACKED)); \
    packed_data->index = glEnablei_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.index = (GLuint)_index; \
    (packed_call_t *)packed_data; \
})
#define call_glEnablei(packed, ret_v) do { \
    PACKED_glEnablei *unpacked = (PACKED_glEnablei *)packed; \
    ARGS_glEnablei *args = (ARGS_glEnablei *)&unpacked->args; \
    glEnablei(args->target, args->index);; \
} while(0)
void glEnablei(glEnablei_ARG_EXPAND);
typedef void (*glEnablei_PTR)(glEnablei_ARG_EXPAND);
#define glEnd_INDEX 544
#define glEnd_RETURN void
#define glEnd_ARG_NAMES 
#define glEnd_ARG_EXPAND 
#define glEnd_PACKED PACKED_glEnd
#define glEnd_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glEnd_NOT_VOID_WRAP(...) {}
#define pack_glEnd() ({ \
    glEnd_PACKED *packed_data = malloc(sizeof(glEnd_PACKED)); \
    packed_data->index = glEnd_INDEX; \
    (packed_call_t *)packed_data; \
})
#define call_glEnd(packed, ret_v) do { \
    glEnd();; \
} while(0)
void glEnd(glEnd_ARG_EXPAND);
typedef void (*glEnd_PTR)(glEnd_ARG_EXPAND);
#define glEndConditionalRender_INDEX 545
#define glEndConditionalRender_RETURN void
#define glEndConditionalRender_ARG_NAMES 
#define glEndConditionalRender_ARG_EXPAND 
#define glEndConditionalRender_PACKED PACKED_glEndConditionalRender
#define glEndConditionalRender_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glEndConditionalRender_NOT_VOID_WRAP(...) {}
#define pack_glEndConditionalRender() ({ \
    glEndConditionalRender_PACKED *packed_data = malloc(sizeof(glEndConditionalRender_PACKED)); \
    packed_data->index = glEndConditionalRender_INDEX; \
    (packed_call_t *)packed_data; \
})
#define call_glEndConditionalRender(packed, ret_v) do { \
    glEndConditionalRender();; \
} while(0)
void glEndConditionalRender(glEndConditionalRender_ARG_EXPAND);
typedef void (*glEndConditionalRender_PTR)(glEndConditionalRender_ARG_EXPAND);
#define glEndConditionalRenderNV_INDEX 546
#define glEndConditionalRenderNV_RETURN void
#define glEndConditionalRenderNV_ARG_NAMES 
#define glEndConditionalRenderNV_ARG_EXPAND 
#define glEndConditionalRenderNV_PACKED PACKED_glEndConditionalRenderNV
#define glEndConditionalRenderNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glEndConditionalRenderNV_NOT_VOID_WRAP(...) {}
#define pack_glEndConditionalRenderNV() ({ \
    glEndConditionalRenderNV_PACKED *packed_data = malloc(sizeof(glEndConditionalRenderNV_PACKED)); \
    packed_data->index = glEndConditionalRenderNV_INDEX; \
    (packed_call_t *)packed_data; \
})
#define call_glEndConditionalRenderNV(packed, ret_v) do { \
    glEndConditionalRenderNV();; \
} while(0)
void glEndConditionalRenderNV(glEndConditionalRenderNV_ARG_EXPAND);
typedef void (*glEndConditionalRenderNV_PTR)(glEndConditionalRenderNV_ARG_EXPAND);
#define glEndConditionalRenderNVX_INDEX 547
#define glEndConditionalRenderNVX_RETURN void
#define glEndConditionalRenderNVX_ARG_NAMES 
#define glEndConditionalRenderNVX_ARG_EXPAND 
#define glEndConditionalRenderNVX_PACKED PACKED_glEndConditionalRenderNVX
#define glEndConditionalRenderNVX_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glEndConditionalRenderNVX_NOT_VOID_WRAP(...) {}
#define pack_glEndConditionalRenderNVX() ({ \
    glEndConditionalRenderNVX_PACKED *packed_data = malloc(sizeof(glEndConditionalRenderNVX_PACKED)); \
    packed_data->index = glEndConditionalRenderNVX_INDEX; \
    (packed_call_t *)packed_data; \
})
#define call_glEndConditionalRenderNVX(packed, ret_v) do { \
    glEndConditionalRenderNVX();; \
} while(0)
void glEndConditionalRenderNVX(glEndConditionalRenderNVX_ARG_EXPAND);
typedef void (*glEndConditionalRenderNVX_PTR)(glEndConditionalRenderNVX_ARG_EXPAND);
#define glEndFragmentShaderATI_INDEX 548
#define glEndFragmentShaderATI_RETURN void
#define glEndFragmentShaderATI_ARG_NAMES 
#define glEndFragmentShaderATI_ARG_EXPAND 
#define glEndFragmentShaderATI_PACKED PACKED_glEndFragmentShaderATI
#define glEndFragmentShaderATI_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glEndFragmentShaderATI_NOT_VOID_WRAP(...) {}
#define pack_glEndFragmentShaderATI() ({ \
    glEndFragmentShaderATI_PACKED *packed_data = malloc(sizeof(glEndFragmentShaderATI_PACKED)); \
    packed_data->index = glEndFragmentShaderATI_INDEX; \
    (packed_call_t *)packed_data; \
})
#define call_glEndFragmentShaderATI(packed, ret_v) do { \
    glEndFragmentShaderATI();; \
} while(0)
void glEndFragmentShaderATI(glEndFragmentShaderATI_ARG_EXPAND);
typedef void (*glEndFragmentShaderATI_PTR)(glEndFragmentShaderATI_ARG_EXPAND);
#define glEndList_INDEX 549
#define glEndList_RETURN void
#define glEndList_ARG_NAMES 
#define glEndList_ARG_EXPAND 
#define glEndList_PACKED PACKED_glEndList
#define glEndList_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glEndList_NOT_VOID_WRAP(...) {}
#define pack_glEndList() ({ \
    glEndList_PACKED *packed_data = malloc(sizeof(glEndList_PACKED)); \
    packed_data->index = glEndList_INDEX; \
    (packed_call_t *)packed_data; \
})
#define call_glEndList(packed, ret_v) do { \
    glEndList();; \
} while(0)
void glEndList(glEndList_ARG_EXPAND);
typedef void (*glEndList_PTR)(glEndList_ARG_EXPAND);
#define glEndOcclusionQueryNV_INDEX 550
#define glEndOcclusionQueryNV_RETURN void
#define glEndOcclusionQueryNV_ARG_NAMES 
#define glEndOcclusionQueryNV_ARG_EXPAND 
#define glEndOcclusionQueryNV_PACKED PACKED_glEndOcclusionQueryNV
#define glEndOcclusionQueryNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glEndOcclusionQueryNV_NOT_VOID_WRAP(...) {}
#define pack_glEndOcclusionQueryNV() ({ \
    glEndOcclusionQueryNV_PACKED *packed_data = malloc(sizeof(glEndOcclusionQueryNV_PACKED)); \
    packed_data->index = glEndOcclusionQueryNV_INDEX; \
    (packed_call_t *)packed_data; \
})
#define call_glEndOcclusionQueryNV(packed, ret_v) do { \
    glEndOcclusionQueryNV();; \
} while(0)
void glEndOcclusionQueryNV(glEndOcclusionQueryNV_ARG_EXPAND);
typedef void (*glEndOcclusionQueryNV_PTR)(glEndOcclusionQueryNV_ARG_EXPAND);
#define glEndPerfMonitorAMD_INDEX 551
#define glEndPerfMonitorAMD_RETURN void
#define glEndPerfMonitorAMD_ARG_NAMES monitor
#define glEndPerfMonitorAMD_ARG_EXPAND GLuint monitor
#define glEndPerfMonitorAMD_PACKED PACKED_glEndPerfMonitorAMD
#define glEndPerfMonitorAMD_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glEndPerfMonitorAMD_NOT_VOID_WRAP(...) {}
#define pack_glEndPerfMonitorAMD(_monitor) ({ \
    glEndPerfMonitorAMD_PACKED *packed_data = malloc(sizeof(glEndPerfMonitorAMD_PACKED)); \
    packed_data->index = glEndPerfMonitorAMD_INDEX; \
    packed_data->args.monitor = (GLuint)_monitor; \
    (packed_call_t *)packed_data; \
})
#define call_glEndPerfMonitorAMD(packed, ret_v) do { \
    PACKED_glEndPerfMonitorAMD *unpacked = (PACKED_glEndPerfMonitorAMD *)packed; \
    ARGS_glEndPerfMonitorAMD *args = (ARGS_glEndPerfMonitorAMD *)&unpacked->args; \
    glEndPerfMonitorAMD(args->monitor);; \
} while(0)
void glEndPerfMonitorAMD(glEndPerfMonitorAMD_ARG_EXPAND);
typedef void (*glEndPerfMonitorAMD_PTR)(glEndPerfMonitorAMD_ARG_EXPAND);
#define glEndQuery_INDEX 552
#define glEndQuery_RETURN void
#define glEndQuery_ARG_NAMES target
#define glEndQuery_ARG_EXPAND GLenum target
#define glEndQuery_PACKED PACKED_glEndQuery
#define glEndQuery_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glEndQuery_NOT_VOID_WRAP(...) {}
#define pack_glEndQuery(_target) ({ \
    glEndQuery_PACKED *packed_data = malloc(sizeof(glEndQuery_PACKED)); \
    packed_data->index = glEndQuery_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    (packed_call_t *)packed_data; \
})
#define call_glEndQuery(packed, ret_v) do { \
    PACKED_glEndQuery *unpacked = (PACKED_glEndQuery *)packed; \
    ARGS_glEndQuery *args = (ARGS_glEndQuery *)&unpacked->args; \
    glEndQuery(args->target);; \
} while(0)
void glEndQuery(glEndQuery_ARG_EXPAND);
typedef void (*glEndQuery_PTR)(glEndQuery_ARG_EXPAND);
#define glEndQueryARB_INDEX 553
#define glEndQueryARB_RETURN void
#define glEndQueryARB_ARG_NAMES target
#define glEndQueryARB_ARG_EXPAND GLenum target
#define glEndQueryARB_PACKED PACKED_glEndQueryARB
#define glEndQueryARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glEndQueryARB_NOT_VOID_WRAP(...) {}
#define pack_glEndQueryARB(_target) ({ \
    glEndQueryARB_PACKED *packed_data = malloc(sizeof(glEndQueryARB_PACKED)); \
    packed_data->index = glEndQueryARB_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    (packed_call_t *)packed_data; \
})
#define call_glEndQueryARB(packed, ret_v) do { \
    PACKED_glEndQueryARB *unpacked = (PACKED_glEndQueryARB *)packed; \
    ARGS_glEndQueryARB *args = (ARGS_glEndQueryARB *)&unpacked->args; \
    glEndQueryARB(args->target);; \
} while(0)
void glEndQueryARB(glEndQueryARB_ARG_EXPAND);
typedef void (*glEndQueryARB_PTR)(glEndQueryARB_ARG_EXPAND);
#define glEndQueryIndexed_INDEX 554
#define glEndQueryIndexed_RETURN void
#define glEndQueryIndexed_ARG_NAMES target, index
#define glEndQueryIndexed_ARG_EXPAND GLenum target, GLuint index
#define glEndQueryIndexed_PACKED PACKED_glEndQueryIndexed
#define glEndQueryIndexed_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glEndQueryIndexed_NOT_VOID_WRAP(...) {}
#define pack_glEndQueryIndexed(_target, _index) ({ \
    glEndQueryIndexed_PACKED *packed_data = malloc(sizeof(glEndQueryIndexed_PACKED)); \
    packed_data->index = glEndQueryIndexed_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.index = (GLuint)_index; \
    (packed_call_t *)packed_data; \
})
#define call_glEndQueryIndexed(packed, ret_v) do { \
    PACKED_glEndQueryIndexed *unpacked = (PACKED_glEndQueryIndexed *)packed; \
    ARGS_glEndQueryIndexed *args = (ARGS_glEndQueryIndexed *)&unpacked->args; \
    glEndQueryIndexed(args->target, args->index);; \
} while(0)
void glEndQueryIndexed(glEndQueryIndexed_ARG_EXPAND);
typedef void (*glEndQueryIndexed_PTR)(glEndQueryIndexed_ARG_EXPAND);
#define glEndTransformFeedback_INDEX 555
#define glEndTransformFeedback_RETURN void
#define glEndTransformFeedback_ARG_NAMES 
#define glEndTransformFeedback_ARG_EXPAND 
#define glEndTransformFeedback_PACKED PACKED_glEndTransformFeedback
#define glEndTransformFeedback_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glEndTransformFeedback_NOT_VOID_WRAP(...) {}
#define pack_glEndTransformFeedback() ({ \
    glEndTransformFeedback_PACKED *packed_data = malloc(sizeof(glEndTransformFeedback_PACKED)); \
    packed_data->index = glEndTransformFeedback_INDEX; \
    (packed_call_t *)packed_data; \
})
#define call_glEndTransformFeedback(packed, ret_v) do { \
    glEndTransformFeedback();; \
} while(0)
void glEndTransformFeedback(glEndTransformFeedback_ARG_EXPAND);
typedef void (*glEndTransformFeedback_PTR)(glEndTransformFeedback_ARG_EXPAND);
#define glEndTransformFeedbackEXT_INDEX 556
#define glEndTransformFeedbackEXT_RETURN void
#define glEndTransformFeedbackEXT_ARG_NAMES 
#define glEndTransformFeedbackEXT_ARG_EXPAND 
#define glEndTransformFeedbackEXT_PACKED PACKED_glEndTransformFeedbackEXT
#define glEndTransformFeedbackEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glEndTransformFeedbackEXT_NOT_VOID_WRAP(...) {}
#define pack_glEndTransformFeedbackEXT() ({ \
    glEndTransformFeedbackEXT_PACKED *packed_data = malloc(sizeof(glEndTransformFeedbackEXT_PACKED)); \
    packed_data->index = glEndTransformFeedbackEXT_INDEX; \
    (packed_call_t *)packed_data; \
})
#define call_glEndTransformFeedbackEXT(packed, ret_v) do { \
    glEndTransformFeedbackEXT();; \
} while(0)
void glEndTransformFeedbackEXT(glEndTransformFeedbackEXT_ARG_EXPAND);
typedef void (*glEndTransformFeedbackEXT_PTR)(glEndTransformFeedbackEXT_ARG_EXPAND);
#define glEndTransformFeedbackNV_INDEX 557
#define glEndTransformFeedbackNV_RETURN void
#define glEndTransformFeedbackNV_ARG_NAMES 
#define glEndTransformFeedbackNV_ARG_EXPAND 
#define glEndTransformFeedbackNV_PACKED PACKED_glEndTransformFeedbackNV
#define glEndTransformFeedbackNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glEndTransformFeedbackNV_NOT_VOID_WRAP(...) {}
#define pack_glEndTransformFeedbackNV() ({ \
    glEndTransformFeedbackNV_PACKED *packed_data = malloc(sizeof(glEndTransformFeedbackNV_PACKED)); \
    packed_data->index = glEndTransformFeedbackNV_INDEX; \
    (packed_call_t *)packed_data; \
})
#define call_glEndTransformFeedbackNV(packed, ret_v) do { \
    glEndTransformFeedbackNV();; \
} while(0)
void glEndTransformFeedbackNV(glEndTransformFeedbackNV_ARG_EXPAND);
typedef void (*glEndTransformFeedbackNV_PTR)(glEndTransformFeedbackNV_ARG_EXPAND);
#define glEndVertexShaderEXT_INDEX 558
#define glEndVertexShaderEXT_RETURN void
#define glEndVertexShaderEXT_ARG_NAMES 
#define glEndVertexShaderEXT_ARG_EXPAND 
#define glEndVertexShaderEXT_PACKED PACKED_glEndVertexShaderEXT
#define glEndVertexShaderEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glEndVertexShaderEXT_NOT_VOID_WRAP(...) {}
#define pack_glEndVertexShaderEXT() ({ \
    glEndVertexShaderEXT_PACKED *packed_data = malloc(sizeof(glEndVertexShaderEXT_PACKED)); \
    packed_data->index = glEndVertexShaderEXT_INDEX; \
    (packed_call_t *)packed_data; \
})
#define call_glEndVertexShaderEXT(packed, ret_v) do { \
    glEndVertexShaderEXT();; \
} while(0)
void glEndVertexShaderEXT(glEndVertexShaderEXT_ARG_EXPAND);
typedef void (*glEndVertexShaderEXT_PTR)(glEndVertexShaderEXT_ARG_EXPAND);
#define glEndVideoCaptureNV_INDEX 559
#define glEndVideoCaptureNV_RETURN void
#define glEndVideoCaptureNV_ARG_NAMES video_capture_slot
#define glEndVideoCaptureNV_ARG_EXPAND GLuint video_capture_slot
#define glEndVideoCaptureNV_PACKED PACKED_glEndVideoCaptureNV
#define glEndVideoCaptureNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glEndVideoCaptureNV_NOT_VOID_WRAP(...) {}
#define pack_glEndVideoCaptureNV(_video_capture_slot) ({ \
    glEndVideoCaptureNV_PACKED *packed_data = malloc(sizeof(glEndVideoCaptureNV_PACKED)); \
    packed_data->index = glEndVideoCaptureNV_INDEX; \
    packed_data->args.video_capture_slot = (GLuint)_video_capture_slot; \
    (packed_call_t *)packed_data; \
})
#define call_glEndVideoCaptureNV(packed, ret_v) do { \
    PACKED_glEndVideoCaptureNV *unpacked = (PACKED_glEndVideoCaptureNV *)packed; \
    ARGS_glEndVideoCaptureNV *args = (ARGS_glEndVideoCaptureNV *)&unpacked->args; \
    glEndVideoCaptureNV(args->video_capture_slot);; \
} while(0)
void glEndVideoCaptureNV(glEndVideoCaptureNV_ARG_EXPAND);
typedef void (*glEndVideoCaptureNV_PTR)(glEndVideoCaptureNV_ARG_EXPAND);
#define glEvalCoord1d_INDEX 560
#define glEvalCoord1d_RETURN void
#define glEvalCoord1d_ARG_NAMES u
#define glEvalCoord1d_ARG_EXPAND GLdouble u
#define glEvalCoord1d_PACKED PACKED_glEvalCoord1d
#define glEvalCoord1d_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glEvalCoord1d_NOT_VOID_WRAP(...) {}
#define pack_glEvalCoord1d(_u) ({ \
    glEvalCoord1d_PACKED *packed_data = malloc(sizeof(glEvalCoord1d_PACKED)); \
    packed_data->index = glEvalCoord1d_INDEX; \
    packed_data->args.u = (GLdouble)_u; \
    (packed_call_t *)packed_data; \
})
#define call_glEvalCoord1d(packed, ret_v) do { \
    PACKED_glEvalCoord1d *unpacked = (PACKED_glEvalCoord1d *)packed; \
    ARGS_glEvalCoord1d *args = (ARGS_glEvalCoord1d *)&unpacked->args; \
    glEvalCoord1d(args->u);; \
} while(0)
void glEvalCoord1d(glEvalCoord1d_ARG_EXPAND);
typedef void (*glEvalCoord1d_PTR)(glEvalCoord1d_ARG_EXPAND);
#define glEvalCoord1dv_INDEX 561
#define glEvalCoord1dv_RETURN void
#define glEvalCoord1dv_ARG_NAMES u
#define glEvalCoord1dv_ARG_EXPAND const GLdouble * u
#define glEvalCoord1dv_PACKED PACKED_glEvalCoord1dv
#define glEvalCoord1dv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glEvalCoord1dv_NOT_VOID_WRAP(...) {}
#define pack_glEvalCoord1dv(_u) ({ \
    glEvalCoord1dv_PACKED *packed_data = malloc(sizeof(glEvalCoord1dv_PACKED)); \
    packed_data->index = glEvalCoord1dv_INDEX; \
    packed_data->args.u = (GLdouble *)_u; \
    (packed_call_t *)packed_data; \
})
#define call_glEvalCoord1dv(packed, ret_v) do { \
    PACKED_glEvalCoord1dv *unpacked = (PACKED_glEvalCoord1dv *)packed; \
    ARGS_glEvalCoord1dv *args = (ARGS_glEvalCoord1dv *)&unpacked->args; \
    glEvalCoord1dv(args->u);; \
} while(0)
void glEvalCoord1dv(glEvalCoord1dv_ARG_EXPAND);
typedef void (*glEvalCoord1dv_PTR)(glEvalCoord1dv_ARG_EXPAND);
#define glEvalCoord1f_INDEX 562
#define glEvalCoord1f_RETURN void
#define glEvalCoord1f_ARG_NAMES u
#define glEvalCoord1f_ARG_EXPAND GLfloat u
#define glEvalCoord1f_PACKED PACKED_glEvalCoord1f
#define glEvalCoord1f_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glEvalCoord1f_NOT_VOID_WRAP(...) {}
#define pack_glEvalCoord1f(_u) ({ \
    glEvalCoord1f_PACKED *packed_data = malloc(sizeof(glEvalCoord1f_PACKED)); \
    packed_data->index = glEvalCoord1f_INDEX; \
    packed_data->args.u = (GLfloat)_u; \
    (packed_call_t *)packed_data; \
})
#define call_glEvalCoord1f(packed, ret_v) do { \
    PACKED_glEvalCoord1f *unpacked = (PACKED_glEvalCoord1f *)packed; \
    ARGS_glEvalCoord1f *args = (ARGS_glEvalCoord1f *)&unpacked->args; \
    glEvalCoord1f(args->u);; \
} while(0)
void glEvalCoord1f(glEvalCoord1f_ARG_EXPAND);
typedef void (*glEvalCoord1f_PTR)(glEvalCoord1f_ARG_EXPAND);
#define glEvalCoord1fv_INDEX 563
#define glEvalCoord1fv_RETURN void
#define glEvalCoord1fv_ARG_NAMES u
#define glEvalCoord1fv_ARG_EXPAND const GLfloat * u
#define glEvalCoord1fv_PACKED PACKED_glEvalCoord1fv
#define glEvalCoord1fv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glEvalCoord1fv_NOT_VOID_WRAP(...) {}
#define pack_glEvalCoord1fv(_u) ({ \
    glEvalCoord1fv_PACKED *packed_data = malloc(sizeof(glEvalCoord1fv_PACKED)); \
    packed_data->index = glEvalCoord1fv_INDEX; \
    packed_data->args.u = (GLfloat *)_u; \
    (packed_call_t *)packed_data; \
})
#define call_glEvalCoord1fv(packed, ret_v) do { \
    PACKED_glEvalCoord1fv *unpacked = (PACKED_glEvalCoord1fv *)packed; \
    ARGS_glEvalCoord1fv *args = (ARGS_glEvalCoord1fv *)&unpacked->args; \
    glEvalCoord1fv(args->u);; \
} while(0)
void glEvalCoord1fv(glEvalCoord1fv_ARG_EXPAND);
typedef void (*glEvalCoord1fv_PTR)(glEvalCoord1fv_ARG_EXPAND);
#define glEvalCoord1xOES_INDEX 564
#define glEvalCoord1xOES_RETURN void
#define glEvalCoord1xOES_ARG_NAMES u
#define glEvalCoord1xOES_ARG_EXPAND GLfixed u
#define glEvalCoord1xOES_PACKED PACKED_glEvalCoord1xOES
#define glEvalCoord1xOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glEvalCoord1xOES_NOT_VOID_WRAP(...) {}
#define pack_glEvalCoord1xOES(_u) ({ \
    glEvalCoord1xOES_PACKED *packed_data = malloc(sizeof(glEvalCoord1xOES_PACKED)); \
    packed_data->index = glEvalCoord1xOES_INDEX; \
    packed_data->args.u = (GLfixed)_u; \
    (packed_call_t *)packed_data; \
})
#define call_glEvalCoord1xOES(packed, ret_v) do { \
    PACKED_glEvalCoord1xOES *unpacked = (PACKED_glEvalCoord1xOES *)packed; \
    ARGS_glEvalCoord1xOES *args = (ARGS_glEvalCoord1xOES *)&unpacked->args; \
    glEvalCoord1xOES(args->u);; \
} while(0)
void glEvalCoord1xOES(glEvalCoord1xOES_ARG_EXPAND);
typedef void (*glEvalCoord1xOES_PTR)(glEvalCoord1xOES_ARG_EXPAND);
#define glEvalCoord1xvOES_INDEX 565
#define glEvalCoord1xvOES_RETURN void
#define glEvalCoord1xvOES_ARG_NAMES coords
#define glEvalCoord1xvOES_ARG_EXPAND const GLfixed * coords
#define glEvalCoord1xvOES_PACKED PACKED_glEvalCoord1xvOES
#define glEvalCoord1xvOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glEvalCoord1xvOES_NOT_VOID_WRAP(...) {}
#define pack_glEvalCoord1xvOES(_coords) ({ \
    glEvalCoord1xvOES_PACKED *packed_data = malloc(sizeof(glEvalCoord1xvOES_PACKED)); \
    packed_data->index = glEvalCoord1xvOES_INDEX; \
    packed_data->args.coords = (GLfixed *)_coords; \
    (packed_call_t *)packed_data; \
})
#define call_glEvalCoord1xvOES(packed, ret_v) do { \
    PACKED_glEvalCoord1xvOES *unpacked = (PACKED_glEvalCoord1xvOES *)packed; \
    ARGS_glEvalCoord1xvOES *args = (ARGS_glEvalCoord1xvOES *)&unpacked->args; \
    glEvalCoord1xvOES(args->coords);; \
} while(0)
void glEvalCoord1xvOES(glEvalCoord1xvOES_ARG_EXPAND);
typedef void (*glEvalCoord1xvOES_PTR)(glEvalCoord1xvOES_ARG_EXPAND);
#define glEvalCoord2d_INDEX 566
#define glEvalCoord2d_RETURN void
#define glEvalCoord2d_ARG_NAMES u, v
#define glEvalCoord2d_ARG_EXPAND GLdouble u, GLdouble v
#define glEvalCoord2d_PACKED PACKED_glEvalCoord2d
#define glEvalCoord2d_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glEvalCoord2d_NOT_VOID_WRAP(...) {}
#define pack_glEvalCoord2d(_u, _v) ({ \
    glEvalCoord2d_PACKED *packed_data = malloc(sizeof(glEvalCoord2d_PACKED)); \
    packed_data->index = glEvalCoord2d_INDEX; \
    packed_data->args.u = (GLdouble)_u; \
    packed_data->args.v = (GLdouble)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glEvalCoord2d(packed, ret_v) do { \
    PACKED_glEvalCoord2d *unpacked = (PACKED_glEvalCoord2d *)packed; \
    ARGS_glEvalCoord2d *args = (ARGS_glEvalCoord2d *)&unpacked->args; \
    glEvalCoord2d(args->u, args->v);; \
} while(0)
void glEvalCoord2d(glEvalCoord2d_ARG_EXPAND);
typedef void (*glEvalCoord2d_PTR)(glEvalCoord2d_ARG_EXPAND);
#define glEvalCoord2dv_INDEX 567
#define glEvalCoord2dv_RETURN void
#define glEvalCoord2dv_ARG_NAMES u
#define glEvalCoord2dv_ARG_EXPAND const GLdouble * u
#define glEvalCoord2dv_PACKED PACKED_glEvalCoord2dv
#define glEvalCoord2dv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glEvalCoord2dv_NOT_VOID_WRAP(...) {}
#define pack_glEvalCoord2dv(_u) ({ \
    glEvalCoord2dv_PACKED *packed_data = malloc(sizeof(glEvalCoord2dv_PACKED)); \
    packed_data->index = glEvalCoord2dv_INDEX; \
    packed_data->args.u = (GLdouble *)_u; \
    (packed_call_t *)packed_data; \
})
#define call_glEvalCoord2dv(packed, ret_v) do { \
    PACKED_glEvalCoord2dv *unpacked = (PACKED_glEvalCoord2dv *)packed; \
    ARGS_glEvalCoord2dv *args = (ARGS_glEvalCoord2dv *)&unpacked->args; \
    glEvalCoord2dv(args->u);; \
} while(0)
void glEvalCoord2dv(glEvalCoord2dv_ARG_EXPAND);
typedef void (*glEvalCoord2dv_PTR)(glEvalCoord2dv_ARG_EXPAND);
#define glEvalCoord2f_INDEX 568
#define glEvalCoord2f_RETURN void
#define glEvalCoord2f_ARG_NAMES u, v
#define glEvalCoord2f_ARG_EXPAND GLfloat u, GLfloat v
#define glEvalCoord2f_PACKED PACKED_glEvalCoord2f
#define glEvalCoord2f_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glEvalCoord2f_NOT_VOID_WRAP(...) {}
#define pack_glEvalCoord2f(_u, _v) ({ \
    glEvalCoord2f_PACKED *packed_data = malloc(sizeof(glEvalCoord2f_PACKED)); \
    packed_data->index = glEvalCoord2f_INDEX; \
    packed_data->args.u = (GLfloat)_u; \
    packed_data->args.v = (GLfloat)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glEvalCoord2f(packed, ret_v) do { \
    PACKED_glEvalCoord2f *unpacked = (PACKED_glEvalCoord2f *)packed; \
    ARGS_glEvalCoord2f *args = (ARGS_glEvalCoord2f *)&unpacked->args; \
    glEvalCoord2f(args->u, args->v);; \
} while(0)
void glEvalCoord2f(glEvalCoord2f_ARG_EXPAND);
typedef void (*glEvalCoord2f_PTR)(glEvalCoord2f_ARG_EXPAND);
#define glEvalCoord2fv_INDEX 569
#define glEvalCoord2fv_RETURN void
#define glEvalCoord2fv_ARG_NAMES u
#define glEvalCoord2fv_ARG_EXPAND const GLfloat * u
#define glEvalCoord2fv_PACKED PACKED_glEvalCoord2fv
#define glEvalCoord2fv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glEvalCoord2fv_NOT_VOID_WRAP(...) {}
#define pack_glEvalCoord2fv(_u) ({ \
    glEvalCoord2fv_PACKED *packed_data = malloc(sizeof(glEvalCoord2fv_PACKED)); \
    packed_data->index = glEvalCoord2fv_INDEX; \
    packed_data->args.u = (GLfloat *)_u; \
    (packed_call_t *)packed_data; \
})
#define call_glEvalCoord2fv(packed, ret_v) do { \
    PACKED_glEvalCoord2fv *unpacked = (PACKED_glEvalCoord2fv *)packed; \
    ARGS_glEvalCoord2fv *args = (ARGS_glEvalCoord2fv *)&unpacked->args; \
    glEvalCoord2fv(args->u);; \
} while(0)
void glEvalCoord2fv(glEvalCoord2fv_ARG_EXPAND);
typedef void (*glEvalCoord2fv_PTR)(glEvalCoord2fv_ARG_EXPAND);
#define glEvalCoord2xOES_INDEX 570
#define glEvalCoord2xOES_RETURN void
#define glEvalCoord2xOES_ARG_NAMES u, v
#define glEvalCoord2xOES_ARG_EXPAND GLfixed u, GLfixed v
#define glEvalCoord2xOES_PACKED PACKED_glEvalCoord2xOES
#define glEvalCoord2xOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glEvalCoord2xOES_NOT_VOID_WRAP(...) {}
#define pack_glEvalCoord2xOES(_u, _v) ({ \
    glEvalCoord2xOES_PACKED *packed_data = malloc(sizeof(glEvalCoord2xOES_PACKED)); \
    packed_data->index = glEvalCoord2xOES_INDEX; \
    packed_data->args.u = (GLfixed)_u; \
    packed_data->args.v = (GLfixed)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glEvalCoord2xOES(packed, ret_v) do { \
    PACKED_glEvalCoord2xOES *unpacked = (PACKED_glEvalCoord2xOES *)packed; \
    ARGS_glEvalCoord2xOES *args = (ARGS_glEvalCoord2xOES *)&unpacked->args; \
    glEvalCoord2xOES(args->u, args->v);; \
} while(0)
void glEvalCoord2xOES(glEvalCoord2xOES_ARG_EXPAND);
typedef void (*glEvalCoord2xOES_PTR)(glEvalCoord2xOES_ARG_EXPAND);
#define glEvalCoord2xvOES_INDEX 571
#define glEvalCoord2xvOES_RETURN void
#define glEvalCoord2xvOES_ARG_NAMES coords
#define glEvalCoord2xvOES_ARG_EXPAND const GLfixed * coords
#define glEvalCoord2xvOES_PACKED PACKED_glEvalCoord2xvOES
#define glEvalCoord2xvOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glEvalCoord2xvOES_NOT_VOID_WRAP(...) {}
#define pack_glEvalCoord2xvOES(_coords) ({ \
    glEvalCoord2xvOES_PACKED *packed_data = malloc(sizeof(glEvalCoord2xvOES_PACKED)); \
    packed_data->index = glEvalCoord2xvOES_INDEX; \
    packed_data->args.coords = (GLfixed *)_coords; \
    (packed_call_t *)packed_data; \
})
#define call_glEvalCoord2xvOES(packed, ret_v) do { \
    PACKED_glEvalCoord2xvOES *unpacked = (PACKED_glEvalCoord2xvOES *)packed; \
    ARGS_glEvalCoord2xvOES *args = (ARGS_glEvalCoord2xvOES *)&unpacked->args; \
    glEvalCoord2xvOES(args->coords);; \
} while(0)
void glEvalCoord2xvOES(glEvalCoord2xvOES_ARG_EXPAND);
typedef void (*glEvalCoord2xvOES_PTR)(glEvalCoord2xvOES_ARG_EXPAND);
#define glEvalMapsNV_INDEX 572
#define glEvalMapsNV_RETURN void
#define glEvalMapsNV_ARG_NAMES target, mode
#define glEvalMapsNV_ARG_EXPAND GLenum target, GLenum mode
#define glEvalMapsNV_PACKED PACKED_glEvalMapsNV
#define glEvalMapsNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glEvalMapsNV_NOT_VOID_WRAP(...) {}
#define pack_glEvalMapsNV(_target, _mode) ({ \
    glEvalMapsNV_PACKED *packed_data = malloc(sizeof(glEvalMapsNV_PACKED)); \
    packed_data->index = glEvalMapsNV_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.mode = (GLenum)_mode; \
    (packed_call_t *)packed_data; \
})
#define call_glEvalMapsNV(packed, ret_v) do { \
    PACKED_glEvalMapsNV *unpacked = (PACKED_glEvalMapsNV *)packed; \
    ARGS_glEvalMapsNV *args = (ARGS_glEvalMapsNV *)&unpacked->args; \
    glEvalMapsNV(args->target, args->mode);; \
} while(0)
void glEvalMapsNV(glEvalMapsNV_ARG_EXPAND);
typedef void (*glEvalMapsNV_PTR)(glEvalMapsNV_ARG_EXPAND);
#define glEvalMesh1_INDEX 573
#define glEvalMesh1_RETURN void
#define glEvalMesh1_ARG_NAMES mode, i1, i2
#define glEvalMesh1_ARG_EXPAND GLenum mode, GLint i1, GLint i2
#define glEvalMesh1_PACKED PACKED_glEvalMesh1
#define glEvalMesh1_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glEvalMesh1_NOT_VOID_WRAP(...) {}
#define pack_glEvalMesh1(_mode, _i1, _i2) ({ \
    glEvalMesh1_PACKED *packed_data = malloc(sizeof(glEvalMesh1_PACKED)); \
    packed_data->index = glEvalMesh1_INDEX; \
    packed_data->args.mode = (GLenum)_mode; \
    packed_data->args.i1 = (GLint)_i1; \
    packed_data->args.i2 = (GLint)_i2; \
    (packed_call_t *)packed_data; \
})
#define call_glEvalMesh1(packed, ret_v) do { \
    PACKED_glEvalMesh1 *unpacked = (PACKED_glEvalMesh1 *)packed; \
    ARGS_glEvalMesh1 *args = (ARGS_glEvalMesh1 *)&unpacked->args; \
    glEvalMesh1(args->mode, args->i1, args->i2);; \
} while(0)
void glEvalMesh1(glEvalMesh1_ARG_EXPAND);
typedef void (*glEvalMesh1_PTR)(glEvalMesh1_ARG_EXPAND);
#define glEvalMesh2_INDEX 574
#define glEvalMesh2_RETURN void
#define glEvalMesh2_ARG_NAMES mode, i1, i2, j1, j2
#define glEvalMesh2_ARG_EXPAND GLenum mode, GLint i1, GLint i2, GLint j1, GLint j2
#define glEvalMesh2_PACKED PACKED_glEvalMesh2
#define glEvalMesh2_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glEvalMesh2_NOT_VOID_WRAP(...) {}
#define pack_glEvalMesh2(_mode, _i1, _i2, _j1, _j2) ({ \
    glEvalMesh2_PACKED *packed_data = malloc(sizeof(glEvalMesh2_PACKED)); \
    packed_data->index = glEvalMesh2_INDEX; \
    packed_data->args.mode = (GLenum)_mode; \
    packed_data->args.i1 = (GLint)_i1; \
    packed_data->args.i2 = (GLint)_i2; \
    packed_data->args.j1 = (GLint)_j1; \
    packed_data->args.j2 = (GLint)_j2; \
    (packed_call_t *)packed_data; \
})
#define call_glEvalMesh2(packed, ret_v) do { \
    PACKED_glEvalMesh2 *unpacked = (PACKED_glEvalMesh2 *)packed; \
    ARGS_glEvalMesh2 *args = (ARGS_glEvalMesh2 *)&unpacked->args; \
    glEvalMesh2(args->mode, args->i1, args->i2, args->j1, args->j2);; \
} while(0)
void glEvalMesh2(glEvalMesh2_ARG_EXPAND);
typedef void (*glEvalMesh2_PTR)(glEvalMesh2_ARG_EXPAND);
#define glEvalPoint1_INDEX 575
#define glEvalPoint1_RETURN void
#define glEvalPoint1_ARG_NAMES i
#define glEvalPoint1_ARG_EXPAND GLint i
#define glEvalPoint1_PACKED PACKED_glEvalPoint1
#define glEvalPoint1_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glEvalPoint1_NOT_VOID_WRAP(...) {}
#define pack_glEvalPoint1(_i) ({ \
    glEvalPoint1_PACKED *packed_data = malloc(sizeof(glEvalPoint1_PACKED)); \
    packed_data->index = glEvalPoint1_INDEX; \
    packed_data->args.i = (GLint)_i; \
    (packed_call_t *)packed_data; \
})
#define call_glEvalPoint1(packed, ret_v) do { \
    PACKED_glEvalPoint1 *unpacked = (PACKED_glEvalPoint1 *)packed; \
    ARGS_glEvalPoint1 *args = (ARGS_glEvalPoint1 *)&unpacked->args; \
    glEvalPoint1(args->i);; \
} while(0)
void glEvalPoint1(glEvalPoint1_ARG_EXPAND);
typedef void (*glEvalPoint1_PTR)(glEvalPoint1_ARG_EXPAND);
#define glEvalPoint2_INDEX 576
#define glEvalPoint2_RETURN void
#define glEvalPoint2_ARG_NAMES i, j
#define glEvalPoint2_ARG_EXPAND GLint i, GLint j
#define glEvalPoint2_PACKED PACKED_glEvalPoint2
#define glEvalPoint2_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glEvalPoint2_NOT_VOID_WRAP(...) {}
#define pack_glEvalPoint2(_i, _j) ({ \
    glEvalPoint2_PACKED *packed_data = malloc(sizeof(glEvalPoint2_PACKED)); \
    packed_data->index = glEvalPoint2_INDEX; \
    packed_data->args.i = (GLint)_i; \
    packed_data->args.j = (GLint)_j; \
    (packed_call_t *)packed_data; \
})
#define call_glEvalPoint2(packed, ret_v) do { \
    PACKED_glEvalPoint2 *unpacked = (PACKED_glEvalPoint2 *)packed; \
    ARGS_glEvalPoint2 *args = (ARGS_glEvalPoint2 *)&unpacked->args; \
    glEvalPoint2(args->i, args->j);; \
} while(0)
void glEvalPoint2(glEvalPoint2_ARG_EXPAND);
typedef void (*glEvalPoint2_PTR)(glEvalPoint2_ARG_EXPAND);
#define glExecuteProgramNV_INDEX 577
#define glExecuteProgramNV_RETURN void
#define glExecuteProgramNV_ARG_NAMES target, id, params
#define glExecuteProgramNV_ARG_EXPAND GLenum target, GLuint id, const GLfloat * params
#define glExecuteProgramNV_PACKED PACKED_glExecuteProgramNV
#define glExecuteProgramNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glExecuteProgramNV_NOT_VOID_WRAP(...) {}
#define pack_glExecuteProgramNV(_target, _id, _params) ({ \
    glExecuteProgramNV_PACKED *packed_data = malloc(sizeof(glExecuteProgramNV_PACKED)); \
    packed_data->index = glExecuteProgramNV_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.id = (GLuint)_id; \
    packed_data->args.params = (GLfloat *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glExecuteProgramNV(packed, ret_v) do { \
    PACKED_glExecuteProgramNV *unpacked = (PACKED_glExecuteProgramNV *)packed; \
    ARGS_glExecuteProgramNV *args = (ARGS_glExecuteProgramNV *)&unpacked->args; \
    glExecuteProgramNV(args->target, args->id, args->params);; \
} while(0)
void glExecuteProgramNV(glExecuteProgramNV_ARG_EXPAND);
typedef void (*glExecuteProgramNV_PTR)(glExecuteProgramNV_ARG_EXPAND);
#define glExtractComponentEXT_INDEX 578
#define glExtractComponentEXT_RETURN void
#define glExtractComponentEXT_ARG_NAMES res, src, num
#define glExtractComponentEXT_ARG_EXPAND GLuint res, GLuint src, GLuint num
#define glExtractComponentEXT_PACKED PACKED_glExtractComponentEXT
#define glExtractComponentEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glExtractComponentEXT_NOT_VOID_WRAP(...) {}
#define pack_glExtractComponentEXT(_res, _src, _num) ({ \
    glExtractComponentEXT_PACKED *packed_data = malloc(sizeof(glExtractComponentEXT_PACKED)); \
    packed_data->index = glExtractComponentEXT_INDEX; \
    packed_data->args.res = (GLuint)_res; \
    packed_data->args.src = (GLuint)_src; \
    packed_data->args.num = (GLuint)_num; \
    (packed_call_t *)packed_data; \
})
#define call_glExtractComponentEXT(packed, ret_v) do { \
    PACKED_glExtractComponentEXT *unpacked = (PACKED_glExtractComponentEXT *)packed; \
    ARGS_glExtractComponentEXT *args = (ARGS_glExtractComponentEXT *)&unpacked->args; \
    glExtractComponentEXT(args->res, args->src, args->num);; \
} while(0)
void glExtractComponentEXT(glExtractComponentEXT_ARG_EXPAND);
typedef void (*glExtractComponentEXT_PTR)(glExtractComponentEXT_ARG_EXPAND);
#define glFeedbackBuffer_INDEX 579
#define glFeedbackBuffer_RETURN void
#define glFeedbackBuffer_ARG_NAMES size, type, buffer
#define glFeedbackBuffer_ARG_EXPAND GLsizei size, GLenum type, GLfloat * buffer
#define glFeedbackBuffer_PACKED PACKED_glFeedbackBuffer
#define glFeedbackBuffer_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glFeedbackBuffer_NOT_VOID_WRAP(...) {}
#define pack_glFeedbackBuffer(_size, _type, _buffer) ({ \
    glFeedbackBuffer_PACKED *packed_data = malloc(sizeof(glFeedbackBuffer_PACKED)); \
    packed_data->index = glFeedbackBuffer_INDEX; \
    packed_data->args.size = (GLsizei)_size; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.buffer = (GLfloat *)_buffer; \
    (packed_call_t *)packed_data; \
})
#define call_glFeedbackBuffer(packed, ret_v) do { \
    PACKED_glFeedbackBuffer *unpacked = (PACKED_glFeedbackBuffer *)packed; \
    ARGS_glFeedbackBuffer *args = (ARGS_glFeedbackBuffer *)&unpacked->args; \
    glFeedbackBuffer(args->size, args->type, args->buffer);; \
} while(0)
void glFeedbackBuffer(glFeedbackBuffer_ARG_EXPAND);
typedef void (*glFeedbackBuffer_PTR)(glFeedbackBuffer_ARG_EXPAND);
#define glFeedbackBufferxOES_INDEX 580
#define glFeedbackBufferxOES_RETURN void
#define glFeedbackBufferxOES_ARG_NAMES n, type, buffer
#define glFeedbackBufferxOES_ARG_EXPAND GLsizei n, GLenum type, const GLfixed * buffer
#define glFeedbackBufferxOES_PACKED PACKED_glFeedbackBufferxOES
#define glFeedbackBufferxOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glFeedbackBufferxOES_NOT_VOID_WRAP(...) {}
#define pack_glFeedbackBufferxOES(_n, _type, _buffer) ({ \
    glFeedbackBufferxOES_PACKED *packed_data = malloc(sizeof(glFeedbackBufferxOES_PACKED)); \
    packed_data->index = glFeedbackBufferxOES_INDEX; \
    packed_data->args.n = (GLsizei)_n; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.buffer = (GLfixed *)_buffer; \
    (packed_call_t *)packed_data; \
})
#define call_glFeedbackBufferxOES(packed, ret_v) do { \
    PACKED_glFeedbackBufferxOES *unpacked = (PACKED_glFeedbackBufferxOES *)packed; \
    ARGS_glFeedbackBufferxOES *args = (ARGS_glFeedbackBufferxOES *)&unpacked->args; \
    glFeedbackBufferxOES(args->n, args->type, args->buffer);; \
} while(0)
void glFeedbackBufferxOES(glFeedbackBufferxOES_ARG_EXPAND);
typedef void (*glFeedbackBufferxOES_PTR)(glFeedbackBufferxOES_ARG_EXPAND);
#define glFenceSync_INDEX 581
#define glFenceSync_RETURN GLsync
#define glFenceSync_ARG_NAMES condition, flags
#define glFenceSync_ARG_EXPAND GLenum condition, GLbitfield flags
#define glFenceSync_PACKED PACKED_glFenceSync
#define glFenceSync_VOID_ONLY_WRAP(...) {}
#define glFenceSync_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glFenceSync(_condition, _flags) ({ \
    glFenceSync_PACKED *packed_data = malloc(sizeof(glFenceSync_PACKED)); \
    packed_data->index = glFenceSync_INDEX; \
    packed_data->args.condition = (GLenum)_condition; \
    packed_data->args.flags = (GLbitfield)_flags; \
    (packed_call_t *)packed_data; \
})
#define call_glFenceSync(packed, ret_v) do { \
    PACKED_glFenceSync *unpacked = (PACKED_glFenceSync *)packed; \
    ARGS_glFenceSync *args = (ARGS_glFenceSync *)&unpacked->args; \
    GLsync *ret = (GLsync *)ret_v; \
    if (ret != NULL) { \
        *ret = glFenceSync(args->condition, args->flags);; \
    } else { \
        glFenceSync(args->condition, args->flags);; \
    } \
} while(0)
GLsync glFenceSync(glFenceSync_ARG_EXPAND);
typedef GLsync (*glFenceSync_PTR)(glFenceSync_ARG_EXPAND);
#define glFinalCombinerInputNV_INDEX 582
#define glFinalCombinerInputNV_RETURN void
#define glFinalCombinerInputNV_ARG_NAMES variable, input, mapping, componentUsage
#define glFinalCombinerInputNV_ARG_EXPAND GLenum variable, GLenum input, GLenum mapping, GLenum componentUsage
#define glFinalCombinerInputNV_PACKED PACKED_glFinalCombinerInputNV
#define glFinalCombinerInputNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glFinalCombinerInputNV_NOT_VOID_WRAP(...) {}
#define pack_glFinalCombinerInputNV(_variable, _input, _mapping, _componentUsage) ({ \
    glFinalCombinerInputNV_PACKED *packed_data = malloc(sizeof(glFinalCombinerInputNV_PACKED)); \
    packed_data->index = glFinalCombinerInputNV_INDEX; \
    packed_data->args.variable = (GLenum)_variable; \
    packed_data->args.input = (GLenum)_input; \
    packed_data->args.mapping = (GLenum)_mapping; \
    packed_data->args.componentUsage = (GLenum)_componentUsage; \
    (packed_call_t *)packed_data; \
})
#define call_glFinalCombinerInputNV(packed, ret_v) do { \
    PACKED_glFinalCombinerInputNV *unpacked = (PACKED_glFinalCombinerInputNV *)packed; \
    ARGS_glFinalCombinerInputNV *args = (ARGS_glFinalCombinerInputNV *)&unpacked->args; \
    glFinalCombinerInputNV(args->variable, args->input, args->mapping, args->componentUsage);; \
} while(0)
void glFinalCombinerInputNV(glFinalCombinerInputNV_ARG_EXPAND);
typedef void (*glFinalCombinerInputNV_PTR)(glFinalCombinerInputNV_ARG_EXPAND);
#define glFinish_INDEX 583
#define glFinish_RETURN void
#define glFinish_ARG_NAMES 
#define glFinish_ARG_EXPAND 
#define glFinish_PACKED PACKED_glFinish
#define glFinish_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glFinish_NOT_VOID_WRAP(...) {}
#define pack_glFinish() ({ \
    glFinish_PACKED *packed_data = malloc(sizeof(glFinish_PACKED)); \
    packed_data->index = glFinish_INDEX; \
    (packed_call_t *)packed_data; \
})
#define call_glFinish(packed, ret_v) do { \
    glFinish();; \
} while(0)
void glFinish(glFinish_ARG_EXPAND);
typedef void (*glFinish_PTR)(glFinish_ARG_EXPAND);
#define glFinishAsyncSGIX_INDEX 584
#define glFinishAsyncSGIX_RETURN GLint
#define glFinishAsyncSGIX_ARG_NAMES markerp
#define glFinishAsyncSGIX_ARG_EXPAND GLuint * markerp
#define glFinishAsyncSGIX_PACKED PACKED_glFinishAsyncSGIX
#define glFinishAsyncSGIX_VOID_ONLY_WRAP(...) {}
#define glFinishAsyncSGIX_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glFinishAsyncSGIX(_markerp) ({ \
    glFinishAsyncSGIX_PACKED *packed_data = malloc(sizeof(glFinishAsyncSGIX_PACKED)); \
    packed_data->index = glFinishAsyncSGIX_INDEX; \
    packed_data->args.markerp = (GLuint *)_markerp; \
    (packed_call_t *)packed_data; \
})
#define call_glFinishAsyncSGIX(packed, ret_v) do { \
    PACKED_glFinishAsyncSGIX *unpacked = (PACKED_glFinishAsyncSGIX *)packed; \
    ARGS_glFinishAsyncSGIX *args = (ARGS_glFinishAsyncSGIX *)&unpacked->args; \
    GLint *ret = (GLint *)ret_v; \
    if (ret != NULL) { \
        *ret = glFinishAsyncSGIX(args->markerp);; \
    } else { \
        glFinishAsyncSGIX(args->markerp);; \
    } \
} while(0)
GLint glFinishAsyncSGIX(glFinishAsyncSGIX_ARG_EXPAND);
typedef GLint (*glFinishAsyncSGIX_PTR)(glFinishAsyncSGIX_ARG_EXPAND);
#define glFinishFenceAPPLE_INDEX 585
#define glFinishFenceAPPLE_RETURN void
#define glFinishFenceAPPLE_ARG_NAMES fence
#define glFinishFenceAPPLE_ARG_EXPAND GLuint fence
#define glFinishFenceAPPLE_PACKED PACKED_glFinishFenceAPPLE
#define glFinishFenceAPPLE_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glFinishFenceAPPLE_NOT_VOID_WRAP(...) {}
#define pack_glFinishFenceAPPLE(_fence) ({ \
    glFinishFenceAPPLE_PACKED *packed_data = malloc(sizeof(glFinishFenceAPPLE_PACKED)); \
    packed_data->index = glFinishFenceAPPLE_INDEX; \
    packed_data->args.fence = (GLuint)_fence; \
    (packed_call_t *)packed_data; \
})
#define call_glFinishFenceAPPLE(packed, ret_v) do { \
    PACKED_glFinishFenceAPPLE *unpacked = (PACKED_glFinishFenceAPPLE *)packed; \
    ARGS_glFinishFenceAPPLE *args = (ARGS_glFinishFenceAPPLE *)&unpacked->args; \
    glFinishFenceAPPLE(args->fence);; \
} while(0)
void glFinishFenceAPPLE(glFinishFenceAPPLE_ARG_EXPAND);
typedef void (*glFinishFenceAPPLE_PTR)(glFinishFenceAPPLE_ARG_EXPAND);
#define glFinishFenceNV_INDEX 586
#define glFinishFenceNV_RETURN void
#define glFinishFenceNV_ARG_NAMES fence
#define glFinishFenceNV_ARG_EXPAND GLuint fence
#define glFinishFenceNV_PACKED PACKED_glFinishFenceNV
#define glFinishFenceNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glFinishFenceNV_NOT_VOID_WRAP(...) {}
#define pack_glFinishFenceNV(_fence) ({ \
    glFinishFenceNV_PACKED *packed_data = malloc(sizeof(glFinishFenceNV_PACKED)); \
    packed_data->index = glFinishFenceNV_INDEX; \
    packed_data->args.fence = (GLuint)_fence; \
    (packed_call_t *)packed_data; \
})
#define call_glFinishFenceNV(packed, ret_v) do { \
    PACKED_glFinishFenceNV *unpacked = (PACKED_glFinishFenceNV *)packed; \
    ARGS_glFinishFenceNV *args = (ARGS_glFinishFenceNV *)&unpacked->args; \
    glFinishFenceNV(args->fence);; \
} while(0)
void glFinishFenceNV(glFinishFenceNV_ARG_EXPAND);
typedef void (*glFinishFenceNV_PTR)(glFinishFenceNV_ARG_EXPAND);
#define glFinishObjectAPPLE_INDEX 587
#define glFinishObjectAPPLE_RETURN void
#define glFinishObjectAPPLE_ARG_NAMES object, name
#define glFinishObjectAPPLE_ARG_EXPAND GLenum object, GLint name
#define glFinishObjectAPPLE_PACKED PACKED_glFinishObjectAPPLE
#define glFinishObjectAPPLE_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glFinishObjectAPPLE_NOT_VOID_WRAP(...) {}
#define pack_glFinishObjectAPPLE(_object, _name) ({ \
    glFinishObjectAPPLE_PACKED *packed_data = malloc(sizeof(glFinishObjectAPPLE_PACKED)); \
    packed_data->index = glFinishObjectAPPLE_INDEX; \
    packed_data->args.object = (GLenum)_object; \
    packed_data->args.name = (GLint)_name; \
    (packed_call_t *)packed_data; \
})
#define call_glFinishObjectAPPLE(packed, ret_v) do { \
    PACKED_glFinishObjectAPPLE *unpacked = (PACKED_glFinishObjectAPPLE *)packed; \
    ARGS_glFinishObjectAPPLE *args = (ARGS_glFinishObjectAPPLE *)&unpacked->args; \
    glFinishObjectAPPLE(args->object, args->name);; \
} while(0)
void glFinishObjectAPPLE(glFinishObjectAPPLE_ARG_EXPAND);
typedef void (*glFinishObjectAPPLE_PTR)(glFinishObjectAPPLE_ARG_EXPAND);
#define glFinishTextureSUNX_INDEX 588
#define glFinishTextureSUNX_RETURN void
#define glFinishTextureSUNX_ARG_NAMES 
#define glFinishTextureSUNX_ARG_EXPAND 
#define glFinishTextureSUNX_PACKED PACKED_glFinishTextureSUNX
#define glFinishTextureSUNX_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glFinishTextureSUNX_NOT_VOID_WRAP(...) {}
#define pack_glFinishTextureSUNX() ({ \
    glFinishTextureSUNX_PACKED *packed_data = malloc(sizeof(glFinishTextureSUNX_PACKED)); \
    packed_data->index = glFinishTextureSUNX_INDEX; \
    (packed_call_t *)packed_data; \
})
#define call_glFinishTextureSUNX(packed, ret_v) do { \
    glFinishTextureSUNX();; \
} while(0)
void glFinishTextureSUNX(glFinishTextureSUNX_ARG_EXPAND);
typedef void (*glFinishTextureSUNX_PTR)(glFinishTextureSUNX_ARG_EXPAND);
#define glFlush_INDEX 589
#define glFlush_RETURN void
#define glFlush_ARG_NAMES 
#define glFlush_ARG_EXPAND 
#define glFlush_PACKED PACKED_glFlush
#define glFlush_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glFlush_NOT_VOID_WRAP(...) {}
#define pack_glFlush() ({ \
    glFlush_PACKED *packed_data = malloc(sizeof(glFlush_PACKED)); \
    packed_data->index = glFlush_INDEX; \
    (packed_call_t *)packed_data; \
})
#define call_glFlush(packed, ret_v) do { \
    glFlush();; \
} while(0)
void glFlush(glFlush_ARG_EXPAND);
typedef void (*glFlush_PTR)(glFlush_ARG_EXPAND);
#define glFlushMappedBufferRange_INDEX 590
#define glFlushMappedBufferRange_RETURN void
#define glFlushMappedBufferRange_ARG_NAMES target, offset, length
#define glFlushMappedBufferRange_ARG_EXPAND GLenum target, GLintptr offset, GLsizeiptr length
#define glFlushMappedBufferRange_PACKED PACKED_glFlushMappedBufferRange
#define glFlushMappedBufferRange_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glFlushMappedBufferRange_NOT_VOID_WRAP(...) {}
#define pack_glFlushMappedBufferRange(_target, _offset, _length) ({ \
    glFlushMappedBufferRange_PACKED *packed_data = malloc(sizeof(glFlushMappedBufferRange_PACKED)); \
    packed_data->index = glFlushMappedBufferRange_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.offset = (GLintptr)_offset; \
    packed_data->args.length = (GLsizeiptr)_length; \
    (packed_call_t *)packed_data; \
})
#define call_glFlushMappedBufferRange(packed, ret_v) do { \
    PACKED_glFlushMappedBufferRange *unpacked = (PACKED_glFlushMappedBufferRange *)packed; \
    ARGS_glFlushMappedBufferRange *args = (ARGS_glFlushMappedBufferRange *)&unpacked->args; \
    glFlushMappedBufferRange(args->target, args->offset, args->length);; \
} while(0)
void glFlushMappedBufferRange(glFlushMappedBufferRange_ARG_EXPAND);
typedef void (*glFlushMappedBufferRange_PTR)(glFlushMappedBufferRange_ARG_EXPAND);
#define glFlushMappedBufferRangeAPPLE_INDEX 591
#define glFlushMappedBufferRangeAPPLE_RETURN void
#define glFlushMappedBufferRangeAPPLE_ARG_NAMES target, offset, size
#define glFlushMappedBufferRangeAPPLE_ARG_EXPAND GLenum target, GLintptr offset, GLsizeiptr size
#define glFlushMappedBufferRangeAPPLE_PACKED PACKED_glFlushMappedBufferRangeAPPLE
#define glFlushMappedBufferRangeAPPLE_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glFlushMappedBufferRangeAPPLE_NOT_VOID_WRAP(...) {}
#define pack_glFlushMappedBufferRangeAPPLE(_target, _offset, _size) ({ \
    glFlushMappedBufferRangeAPPLE_PACKED *packed_data = malloc(sizeof(glFlushMappedBufferRangeAPPLE_PACKED)); \
    packed_data->index = glFlushMappedBufferRangeAPPLE_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.offset = (GLintptr)_offset; \
    packed_data->args.size = (GLsizeiptr)_size; \
    (packed_call_t *)packed_data; \
})
#define call_glFlushMappedBufferRangeAPPLE(packed, ret_v) do { \
    PACKED_glFlushMappedBufferRangeAPPLE *unpacked = (PACKED_glFlushMappedBufferRangeAPPLE *)packed; \
    ARGS_glFlushMappedBufferRangeAPPLE *args = (ARGS_glFlushMappedBufferRangeAPPLE *)&unpacked->args; \
    glFlushMappedBufferRangeAPPLE(args->target, args->offset, args->size);; \
} while(0)
void glFlushMappedBufferRangeAPPLE(glFlushMappedBufferRangeAPPLE_ARG_EXPAND);
typedef void (*glFlushMappedBufferRangeAPPLE_PTR)(glFlushMappedBufferRangeAPPLE_ARG_EXPAND);
#define glFlushMappedNamedBufferRangeEXT_INDEX 592
#define glFlushMappedNamedBufferRangeEXT_RETURN void
#define glFlushMappedNamedBufferRangeEXT_ARG_NAMES buffer, offset, length
#define glFlushMappedNamedBufferRangeEXT_ARG_EXPAND GLuint buffer, GLintptr offset, GLsizeiptr length
#define glFlushMappedNamedBufferRangeEXT_PACKED PACKED_glFlushMappedNamedBufferRangeEXT
#define glFlushMappedNamedBufferRangeEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glFlushMappedNamedBufferRangeEXT_NOT_VOID_WRAP(...) {}
#define pack_glFlushMappedNamedBufferRangeEXT(_buffer, _offset, _length) ({ \
    glFlushMappedNamedBufferRangeEXT_PACKED *packed_data = malloc(sizeof(glFlushMappedNamedBufferRangeEXT_PACKED)); \
    packed_data->index = glFlushMappedNamedBufferRangeEXT_INDEX; \
    packed_data->args.buffer = (GLuint)_buffer; \
    packed_data->args.offset = (GLintptr)_offset; \
    packed_data->args.length = (GLsizeiptr)_length; \
    (packed_call_t *)packed_data; \
})
#define call_glFlushMappedNamedBufferRangeEXT(packed, ret_v) do { \
    PACKED_glFlushMappedNamedBufferRangeEXT *unpacked = (PACKED_glFlushMappedNamedBufferRangeEXT *)packed; \
    ARGS_glFlushMappedNamedBufferRangeEXT *args = (ARGS_glFlushMappedNamedBufferRangeEXT *)&unpacked->args; \
    glFlushMappedNamedBufferRangeEXT(args->buffer, args->offset, args->length);; \
} while(0)
void glFlushMappedNamedBufferRangeEXT(glFlushMappedNamedBufferRangeEXT_ARG_EXPAND);
typedef void (*glFlushMappedNamedBufferRangeEXT_PTR)(glFlushMappedNamedBufferRangeEXT_ARG_EXPAND);
#define glFlushPixelDataRangeNV_INDEX 593
#define glFlushPixelDataRangeNV_RETURN void
#define glFlushPixelDataRangeNV_ARG_NAMES target
#define glFlushPixelDataRangeNV_ARG_EXPAND GLenum target
#define glFlushPixelDataRangeNV_PACKED PACKED_glFlushPixelDataRangeNV
#define glFlushPixelDataRangeNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glFlushPixelDataRangeNV_NOT_VOID_WRAP(...) {}
#define pack_glFlushPixelDataRangeNV(_target) ({ \
    glFlushPixelDataRangeNV_PACKED *packed_data = malloc(sizeof(glFlushPixelDataRangeNV_PACKED)); \
    packed_data->index = glFlushPixelDataRangeNV_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    (packed_call_t *)packed_data; \
})
#define call_glFlushPixelDataRangeNV(packed, ret_v) do { \
    PACKED_glFlushPixelDataRangeNV *unpacked = (PACKED_glFlushPixelDataRangeNV *)packed; \
    ARGS_glFlushPixelDataRangeNV *args = (ARGS_glFlushPixelDataRangeNV *)&unpacked->args; \
    glFlushPixelDataRangeNV(args->target);; \
} while(0)
void glFlushPixelDataRangeNV(glFlushPixelDataRangeNV_ARG_EXPAND);
typedef void (*glFlushPixelDataRangeNV_PTR)(glFlushPixelDataRangeNV_ARG_EXPAND);
#define glFlushRasterSGIX_INDEX 594
#define glFlushRasterSGIX_RETURN void
#define glFlushRasterSGIX_ARG_NAMES 
#define glFlushRasterSGIX_ARG_EXPAND 
#define glFlushRasterSGIX_PACKED PACKED_glFlushRasterSGIX
#define glFlushRasterSGIX_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glFlushRasterSGIX_NOT_VOID_WRAP(...) {}
#define pack_glFlushRasterSGIX() ({ \
    glFlushRasterSGIX_PACKED *packed_data = malloc(sizeof(glFlushRasterSGIX_PACKED)); \
    packed_data->index = glFlushRasterSGIX_INDEX; \
    (packed_call_t *)packed_data; \
})
#define call_glFlushRasterSGIX(packed, ret_v) do { \
    glFlushRasterSGIX();; \
} while(0)
void glFlushRasterSGIX(glFlushRasterSGIX_ARG_EXPAND);
typedef void (*glFlushRasterSGIX_PTR)(glFlushRasterSGIX_ARG_EXPAND);
#define glFlushStaticDataIBM_INDEX 595
#define glFlushStaticDataIBM_RETURN void
#define glFlushStaticDataIBM_ARG_NAMES target
#define glFlushStaticDataIBM_ARG_EXPAND GLenum target
#define glFlushStaticDataIBM_PACKED PACKED_glFlushStaticDataIBM
#define glFlushStaticDataIBM_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glFlushStaticDataIBM_NOT_VOID_WRAP(...) {}
#define pack_glFlushStaticDataIBM(_target) ({ \
    glFlushStaticDataIBM_PACKED *packed_data = malloc(sizeof(glFlushStaticDataIBM_PACKED)); \
    packed_data->index = glFlushStaticDataIBM_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    (packed_call_t *)packed_data; \
})
#define call_glFlushStaticDataIBM(packed, ret_v) do { \
    PACKED_glFlushStaticDataIBM *unpacked = (PACKED_glFlushStaticDataIBM *)packed; \
    ARGS_glFlushStaticDataIBM *args = (ARGS_glFlushStaticDataIBM *)&unpacked->args; \
    glFlushStaticDataIBM(args->target);; \
} while(0)
void glFlushStaticDataIBM(glFlushStaticDataIBM_ARG_EXPAND);
typedef void (*glFlushStaticDataIBM_PTR)(glFlushStaticDataIBM_ARG_EXPAND);
#define glFlushVertexArrayRangeAPPLE_INDEX 596
#define glFlushVertexArrayRangeAPPLE_RETURN void
#define glFlushVertexArrayRangeAPPLE_ARG_NAMES length, pointer
#define glFlushVertexArrayRangeAPPLE_ARG_EXPAND GLsizei length, GLvoid * pointer
#define glFlushVertexArrayRangeAPPLE_PACKED PACKED_glFlushVertexArrayRangeAPPLE
#define glFlushVertexArrayRangeAPPLE_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glFlushVertexArrayRangeAPPLE_NOT_VOID_WRAP(...) {}
#define pack_glFlushVertexArrayRangeAPPLE(_length, _pointer) ({ \
    glFlushVertexArrayRangeAPPLE_PACKED *packed_data = malloc(sizeof(glFlushVertexArrayRangeAPPLE_PACKED)); \
    packed_data->index = glFlushVertexArrayRangeAPPLE_INDEX; \
    packed_data->args.length = (GLsizei)_length; \
    packed_data->args.pointer = (GLvoid *)_pointer; \
    (packed_call_t *)packed_data; \
})
#define call_glFlushVertexArrayRangeAPPLE(packed, ret_v) do { \
    PACKED_glFlushVertexArrayRangeAPPLE *unpacked = (PACKED_glFlushVertexArrayRangeAPPLE *)packed; \
    ARGS_glFlushVertexArrayRangeAPPLE *args = (ARGS_glFlushVertexArrayRangeAPPLE *)&unpacked->args; \
    glFlushVertexArrayRangeAPPLE(args->length, args->pointer);; \
} while(0)
void glFlushVertexArrayRangeAPPLE(glFlushVertexArrayRangeAPPLE_ARG_EXPAND);
typedef void (*glFlushVertexArrayRangeAPPLE_PTR)(glFlushVertexArrayRangeAPPLE_ARG_EXPAND);
#define glFlushVertexArrayRangeNV_INDEX 597
#define glFlushVertexArrayRangeNV_RETURN void
#define glFlushVertexArrayRangeNV_ARG_NAMES 
#define glFlushVertexArrayRangeNV_ARG_EXPAND 
#define glFlushVertexArrayRangeNV_PACKED PACKED_glFlushVertexArrayRangeNV
#define glFlushVertexArrayRangeNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glFlushVertexArrayRangeNV_NOT_VOID_WRAP(...) {}
#define pack_glFlushVertexArrayRangeNV() ({ \
    glFlushVertexArrayRangeNV_PACKED *packed_data = malloc(sizeof(glFlushVertexArrayRangeNV_PACKED)); \
    packed_data->index = glFlushVertexArrayRangeNV_INDEX; \
    (packed_call_t *)packed_data; \
})
#define call_glFlushVertexArrayRangeNV(packed, ret_v) do { \
    glFlushVertexArrayRangeNV();; \
} while(0)
void glFlushVertexArrayRangeNV(glFlushVertexArrayRangeNV_ARG_EXPAND);
typedef void (*glFlushVertexArrayRangeNV_PTR)(glFlushVertexArrayRangeNV_ARG_EXPAND);
#define glFogCoordFormatNV_INDEX 598
#define glFogCoordFormatNV_RETURN void
#define glFogCoordFormatNV_ARG_NAMES type, stride
#define glFogCoordFormatNV_ARG_EXPAND GLenum type, GLsizei stride
#define glFogCoordFormatNV_PACKED PACKED_glFogCoordFormatNV
#define glFogCoordFormatNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glFogCoordFormatNV_NOT_VOID_WRAP(...) {}
#define pack_glFogCoordFormatNV(_type, _stride) ({ \
    glFogCoordFormatNV_PACKED *packed_data = malloc(sizeof(glFogCoordFormatNV_PACKED)); \
    packed_data->index = glFogCoordFormatNV_INDEX; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.stride = (GLsizei)_stride; \
    (packed_call_t *)packed_data; \
})
#define call_glFogCoordFormatNV(packed, ret_v) do { \
    PACKED_glFogCoordFormatNV *unpacked = (PACKED_glFogCoordFormatNV *)packed; \
    ARGS_glFogCoordFormatNV *args = (ARGS_glFogCoordFormatNV *)&unpacked->args; \
    glFogCoordFormatNV(args->type, args->stride);; \
} while(0)
void glFogCoordFormatNV(glFogCoordFormatNV_ARG_EXPAND);
typedef void (*glFogCoordFormatNV_PTR)(glFogCoordFormatNV_ARG_EXPAND);
#define glFogCoordPointer_INDEX 599
#define glFogCoordPointer_RETURN void
#define glFogCoordPointer_ARG_NAMES type, stride, pointer
#define glFogCoordPointer_ARG_EXPAND GLenum type, GLsizei stride, const GLvoid * pointer
#define glFogCoordPointer_PACKED PACKED_glFogCoordPointer
#define glFogCoordPointer_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glFogCoordPointer_NOT_VOID_WRAP(...) {}
#define pack_glFogCoordPointer(_type, _stride, _pointer) ({ \
    glFogCoordPointer_PACKED *packed_data = malloc(sizeof(glFogCoordPointer_PACKED)); \
    packed_data->index = glFogCoordPointer_INDEX; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.stride = (GLsizei)_stride; \
    packed_data->args.pointer = (GLvoid *)_pointer; \
    (packed_call_t *)packed_data; \
})
#define call_glFogCoordPointer(packed, ret_v) do { \
    PACKED_glFogCoordPointer *unpacked = (PACKED_glFogCoordPointer *)packed; \
    ARGS_glFogCoordPointer *args = (ARGS_glFogCoordPointer *)&unpacked->args; \
    glFogCoordPointer(args->type, args->stride, args->pointer);; \
} while(0)
void glFogCoordPointer(glFogCoordPointer_ARG_EXPAND);
typedef void (*glFogCoordPointer_PTR)(glFogCoordPointer_ARG_EXPAND);
#define glFogCoordPointerEXT_INDEX 600
#define glFogCoordPointerEXT_RETURN void
#define glFogCoordPointerEXT_ARG_NAMES type, stride, pointer
#define glFogCoordPointerEXT_ARG_EXPAND GLenum type, GLsizei stride, const GLvoid * pointer
#define glFogCoordPointerEXT_PACKED PACKED_glFogCoordPointerEXT
#define glFogCoordPointerEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glFogCoordPointerEXT_NOT_VOID_WRAP(...) {}
#define pack_glFogCoordPointerEXT(_type, _stride, _pointer) ({ \
    glFogCoordPointerEXT_PACKED *packed_data = malloc(sizeof(glFogCoordPointerEXT_PACKED)); \
    packed_data->index = glFogCoordPointerEXT_INDEX; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.stride = (GLsizei)_stride; \
    packed_data->args.pointer = (GLvoid *)_pointer; \
    (packed_call_t *)packed_data; \
})
#define call_glFogCoordPointerEXT(packed, ret_v) do { \
    PACKED_glFogCoordPointerEXT *unpacked = (PACKED_glFogCoordPointerEXT *)packed; \
    ARGS_glFogCoordPointerEXT *args = (ARGS_glFogCoordPointerEXT *)&unpacked->args; \
    glFogCoordPointerEXT(args->type, args->stride, args->pointer);; \
} while(0)
void glFogCoordPointerEXT(glFogCoordPointerEXT_ARG_EXPAND);
typedef void (*glFogCoordPointerEXT_PTR)(glFogCoordPointerEXT_ARG_EXPAND);
#define glFogCoordPointerListIBM_INDEX 601
#define glFogCoordPointerListIBM_RETURN void
#define glFogCoordPointerListIBM_ARG_NAMES type, stride, pointer, ptrstride
#define glFogCoordPointerListIBM_ARG_EXPAND GLenum type, GLint stride, const GLvoid * pointer, GLint ptrstride
#define glFogCoordPointerListIBM_PACKED PACKED_glFogCoordPointerListIBM
#define glFogCoordPointerListIBM_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glFogCoordPointerListIBM_NOT_VOID_WRAP(...) {}
#define pack_glFogCoordPointerListIBM(_type, _stride, _pointer, _ptrstride) ({ \
    glFogCoordPointerListIBM_PACKED *packed_data = malloc(sizeof(glFogCoordPointerListIBM_PACKED)); \
    packed_data->index = glFogCoordPointerListIBM_INDEX; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.stride = (GLint)_stride; \
    packed_data->args.pointer = (GLvoid *)_pointer; \
    packed_data->args.ptrstride = (GLint)_ptrstride; \
    (packed_call_t *)packed_data; \
})
#define call_glFogCoordPointerListIBM(packed, ret_v) do { \
    PACKED_glFogCoordPointerListIBM *unpacked = (PACKED_glFogCoordPointerListIBM *)packed; \
    ARGS_glFogCoordPointerListIBM *args = (ARGS_glFogCoordPointerListIBM *)&unpacked->args; \
    glFogCoordPointerListIBM(args->type, args->stride, args->pointer, args->ptrstride);; \
} while(0)
void glFogCoordPointerListIBM(glFogCoordPointerListIBM_ARG_EXPAND);
typedef void (*glFogCoordPointerListIBM_PTR)(glFogCoordPointerListIBM_ARG_EXPAND);
#define glFogCoordd_INDEX 602
#define glFogCoordd_RETURN void
#define glFogCoordd_ARG_NAMES coord
#define glFogCoordd_ARG_EXPAND GLdouble coord
#define glFogCoordd_PACKED PACKED_glFogCoordd
#define glFogCoordd_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glFogCoordd_NOT_VOID_WRAP(...) {}
#define pack_glFogCoordd(_coord) ({ \
    glFogCoordd_PACKED *packed_data = malloc(sizeof(glFogCoordd_PACKED)); \
    packed_data->index = glFogCoordd_INDEX; \
    packed_data->args.coord = (GLdouble)_coord; \
    (packed_call_t *)packed_data; \
})
#define call_glFogCoordd(packed, ret_v) do { \
    PACKED_glFogCoordd *unpacked = (PACKED_glFogCoordd *)packed; \
    ARGS_glFogCoordd *args = (ARGS_glFogCoordd *)&unpacked->args; \
    glFogCoordd(args->coord);; \
} while(0)
void glFogCoordd(glFogCoordd_ARG_EXPAND);
typedef void (*glFogCoordd_PTR)(glFogCoordd_ARG_EXPAND);
#define glFogCoorddEXT_INDEX 603
#define glFogCoorddEXT_RETURN void
#define glFogCoorddEXT_ARG_NAMES coord
#define glFogCoorddEXT_ARG_EXPAND GLdouble coord
#define glFogCoorddEXT_PACKED PACKED_glFogCoorddEXT
#define glFogCoorddEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glFogCoorddEXT_NOT_VOID_WRAP(...) {}
#define pack_glFogCoorddEXT(_coord) ({ \
    glFogCoorddEXT_PACKED *packed_data = malloc(sizeof(glFogCoorddEXT_PACKED)); \
    packed_data->index = glFogCoorddEXT_INDEX; \
    packed_data->args.coord = (GLdouble)_coord; \
    (packed_call_t *)packed_data; \
})
#define call_glFogCoorddEXT(packed, ret_v) do { \
    PACKED_glFogCoorddEXT *unpacked = (PACKED_glFogCoorddEXT *)packed; \
    ARGS_glFogCoorddEXT *args = (ARGS_glFogCoorddEXT *)&unpacked->args; \
    glFogCoorddEXT(args->coord);; \
} while(0)
void glFogCoorddEXT(glFogCoorddEXT_ARG_EXPAND);
typedef void (*glFogCoorddEXT_PTR)(glFogCoorddEXT_ARG_EXPAND);
#define glFogCoorddv_INDEX 604
#define glFogCoorddv_RETURN void
#define glFogCoorddv_ARG_NAMES coord
#define glFogCoorddv_ARG_EXPAND const GLdouble * coord
#define glFogCoorddv_PACKED PACKED_glFogCoorddv
#define glFogCoorddv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glFogCoorddv_NOT_VOID_WRAP(...) {}
#define pack_glFogCoorddv(_coord) ({ \
    glFogCoorddv_PACKED *packed_data = malloc(sizeof(glFogCoorddv_PACKED)); \
    packed_data->index = glFogCoorddv_INDEX; \
    packed_data->args.coord = (GLdouble *)_coord; \
    (packed_call_t *)packed_data; \
})
#define call_glFogCoorddv(packed, ret_v) do { \
    PACKED_glFogCoorddv *unpacked = (PACKED_glFogCoorddv *)packed; \
    ARGS_glFogCoorddv *args = (ARGS_glFogCoorddv *)&unpacked->args; \
    glFogCoorddv(args->coord);; \
} while(0)
void glFogCoorddv(glFogCoorddv_ARG_EXPAND);
typedef void (*glFogCoorddv_PTR)(glFogCoorddv_ARG_EXPAND);
#define glFogCoorddvEXT_INDEX 605
#define glFogCoorddvEXT_RETURN void
#define glFogCoorddvEXT_ARG_NAMES coord
#define glFogCoorddvEXT_ARG_EXPAND const GLdouble * coord
#define glFogCoorddvEXT_PACKED PACKED_glFogCoorddvEXT
#define glFogCoorddvEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glFogCoorddvEXT_NOT_VOID_WRAP(...) {}
#define pack_glFogCoorddvEXT(_coord) ({ \
    glFogCoorddvEXT_PACKED *packed_data = malloc(sizeof(glFogCoorddvEXT_PACKED)); \
    packed_data->index = glFogCoorddvEXT_INDEX; \
    packed_data->args.coord = (GLdouble *)_coord; \
    (packed_call_t *)packed_data; \
})
#define call_glFogCoorddvEXT(packed, ret_v) do { \
    PACKED_glFogCoorddvEXT *unpacked = (PACKED_glFogCoorddvEXT *)packed; \
    ARGS_glFogCoorddvEXT *args = (ARGS_glFogCoorddvEXT *)&unpacked->args; \
    glFogCoorddvEXT(args->coord);; \
} while(0)
void glFogCoorddvEXT(glFogCoorddvEXT_ARG_EXPAND);
typedef void (*glFogCoorddvEXT_PTR)(glFogCoorddvEXT_ARG_EXPAND);
#define glFogCoordf_INDEX 606
#define glFogCoordf_RETURN void
#define glFogCoordf_ARG_NAMES coord
#define glFogCoordf_ARG_EXPAND GLfloat coord
#define glFogCoordf_PACKED PACKED_glFogCoordf
#define glFogCoordf_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glFogCoordf_NOT_VOID_WRAP(...) {}
#define pack_glFogCoordf(_coord) ({ \
    glFogCoordf_PACKED *packed_data = malloc(sizeof(glFogCoordf_PACKED)); \
    packed_data->index = glFogCoordf_INDEX; \
    packed_data->args.coord = (GLfloat)_coord; \
    (packed_call_t *)packed_data; \
})
#define call_glFogCoordf(packed, ret_v) do { \
    PACKED_glFogCoordf *unpacked = (PACKED_glFogCoordf *)packed; \
    ARGS_glFogCoordf *args = (ARGS_glFogCoordf *)&unpacked->args; \
    glFogCoordf(args->coord);; \
} while(0)
void glFogCoordf(glFogCoordf_ARG_EXPAND);
typedef void (*glFogCoordf_PTR)(glFogCoordf_ARG_EXPAND);
#define glFogCoordfEXT_INDEX 607
#define glFogCoordfEXT_RETURN void
#define glFogCoordfEXT_ARG_NAMES coord
#define glFogCoordfEXT_ARG_EXPAND GLfloat coord
#define glFogCoordfEXT_PACKED PACKED_glFogCoordfEXT
#define glFogCoordfEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glFogCoordfEXT_NOT_VOID_WRAP(...) {}
#define pack_glFogCoordfEXT(_coord) ({ \
    glFogCoordfEXT_PACKED *packed_data = malloc(sizeof(glFogCoordfEXT_PACKED)); \
    packed_data->index = glFogCoordfEXT_INDEX; \
    packed_data->args.coord = (GLfloat)_coord; \
    (packed_call_t *)packed_data; \
})
#define call_glFogCoordfEXT(packed, ret_v) do { \
    PACKED_glFogCoordfEXT *unpacked = (PACKED_glFogCoordfEXT *)packed; \
    ARGS_glFogCoordfEXT *args = (ARGS_glFogCoordfEXT *)&unpacked->args; \
    glFogCoordfEXT(args->coord);; \
} while(0)
void glFogCoordfEXT(glFogCoordfEXT_ARG_EXPAND);
typedef void (*glFogCoordfEXT_PTR)(glFogCoordfEXT_ARG_EXPAND);
#define glFogCoordfv_INDEX 608
#define glFogCoordfv_RETURN void
#define glFogCoordfv_ARG_NAMES coord
#define glFogCoordfv_ARG_EXPAND const GLfloat * coord
#define glFogCoordfv_PACKED PACKED_glFogCoordfv
#define glFogCoordfv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glFogCoordfv_NOT_VOID_WRAP(...) {}
#define pack_glFogCoordfv(_coord) ({ \
    glFogCoordfv_PACKED *packed_data = malloc(sizeof(glFogCoordfv_PACKED)); \
    packed_data->index = glFogCoordfv_INDEX; \
    packed_data->args.coord = (GLfloat *)_coord; \
    (packed_call_t *)packed_data; \
})
#define call_glFogCoordfv(packed, ret_v) do { \
    PACKED_glFogCoordfv *unpacked = (PACKED_glFogCoordfv *)packed; \
    ARGS_glFogCoordfv *args = (ARGS_glFogCoordfv *)&unpacked->args; \
    glFogCoordfv(args->coord);; \
} while(0)
void glFogCoordfv(glFogCoordfv_ARG_EXPAND);
typedef void (*glFogCoordfv_PTR)(glFogCoordfv_ARG_EXPAND);
#define glFogCoordfvEXT_INDEX 609
#define glFogCoordfvEXT_RETURN void
#define glFogCoordfvEXT_ARG_NAMES coord
#define glFogCoordfvEXT_ARG_EXPAND const GLfloat * coord
#define glFogCoordfvEXT_PACKED PACKED_glFogCoordfvEXT
#define glFogCoordfvEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glFogCoordfvEXT_NOT_VOID_WRAP(...) {}
#define pack_glFogCoordfvEXT(_coord) ({ \
    glFogCoordfvEXT_PACKED *packed_data = malloc(sizeof(glFogCoordfvEXT_PACKED)); \
    packed_data->index = glFogCoordfvEXT_INDEX; \
    packed_data->args.coord = (GLfloat *)_coord; \
    (packed_call_t *)packed_data; \
})
#define call_glFogCoordfvEXT(packed, ret_v) do { \
    PACKED_glFogCoordfvEXT *unpacked = (PACKED_glFogCoordfvEXT *)packed; \
    ARGS_glFogCoordfvEXT *args = (ARGS_glFogCoordfvEXT *)&unpacked->args; \
    glFogCoordfvEXT(args->coord);; \
} while(0)
void glFogCoordfvEXT(glFogCoordfvEXT_ARG_EXPAND);
typedef void (*glFogCoordfvEXT_PTR)(glFogCoordfvEXT_ARG_EXPAND);
#define glFogCoordhNV_INDEX 610
#define glFogCoordhNV_RETURN void
#define glFogCoordhNV_ARG_NAMES fog
#define glFogCoordhNV_ARG_EXPAND GLhalfNV fog
#define glFogCoordhNV_PACKED PACKED_glFogCoordhNV
#define glFogCoordhNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glFogCoordhNV_NOT_VOID_WRAP(...) {}
#define pack_glFogCoordhNV(_fog) ({ \
    glFogCoordhNV_PACKED *packed_data = malloc(sizeof(glFogCoordhNV_PACKED)); \
    packed_data->index = glFogCoordhNV_INDEX; \
    packed_data->args.fog = (GLhalfNV)_fog; \
    (packed_call_t *)packed_data; \
})
#define call_glFogCoordhNV(packed, ret_v) do { \
    PACKED_glFogCoordhNV *unpacked = (PACKED_glFogCoordhNV *)packed; \
    ARGS_glFogCoordhNV *args = (ARGS_glFogCoordhNV *)&unpacked->args; \
    glFogCoordhNV(args->fog);; \
} while(0)
void glFogCoordhNV(glFogCoordhNV_ARG_EXPAND);
typedef void (*glFogCoordhNV_PTR)(glFogCoordhNV_ARG_EXPAND);
#define glFogCoordhvNV_INDEX 611
#define glFogCoordhvNV_RETURN void
#define glFogCoordhvNV_ARG_NAMES fog
#define glFogCoordhvNV_ARG_EXPAND const GLhalfNV * fog
#define glFogCoordhvNV_PACKED PACKED_glFogCoordhvNV
#define glFogCoordhvNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glFogCoordhvNV_NOT_VOID_WRAP(...) {}
#define pack_glFogCoordhvNV(_fog) ({ \
    glFogCoordhvNV_PACKED *packed_data = malloc(sizeof(glFogCoordhvNV_PACKED)); \
    packed_data->index = glFogCoordhvNV_INDEX; \
    packed_data->args.fog = (GLhalfNV *)_fog; \
    (packed_call_t *)packed_data; \
})
#define call_glFogCoordhvNV(packed, ret_v) do { \
    PACKED_glFogCoordhvNV *unpacked = (PACKED_glFogCoordhvNV *)packed; \
    ARGS_glFogCoordhvNV *args = (ARGS_glFogCoordhvNV *)&unpacked->args; \
    glFogCoordhvNV(args->fog);; \
} while(0)
void glFogCoordhvNV(glFogCoordhvNV_ARG_EXPAND);
typedef void (*glFogCoordhvNV_PTR)(glFogCoordhvNV_ARG_EXPAND);
#define glFogFuncSGIS_INDEX 612
#define glFogFuncSGIS_RETURN void
#define glFogFuncSGIS_ARG_NAMES n, points
#define glFogFuncSGIS_ARG_EXPAND GLsizei n, const GLfloat * points
#define glFogFuncSGIS_PACKED PACKED_glFogFuncSGIS
#define glFogFuncSGIS_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glFogFuncSGIS_NOT_VOID_WRAP(...) {}
#define pack_glFogFuncSGIS(_n, _points) ({ \
    glFogFuncSGIS_PACKED *packed_data = malloc(sizeof(glFogFuncSGIS_PACKED)); \
    packed_data->index = glFogFuncSGIS_INDEX; \
    packed_data->args.n = (GLsizei)_n; \
    packed_data->args.points = (GLfloat *)_points; \
    (packed_call_t *)packed_data; \
})
#define call_glFogFuncSGIS(packed, ret_v) do { \
    PACKED_glFogFuncSGIS *unpacked = (PACKED_glFogFuncSGIS *)packed; \
    ARGS_glFogFuncSGIS *args = (ARGS_glFogFuncSGIS *)&unpacked->args; \
    glFogFuncSGIS(args->n, args->points);; \
} while(0)
void glFogFuncSGIS(glFogFuncSGIS_ARG_EXPAND);
typedef void (*glFogFuncSGIS_PTR)(glFogFuncSGIS_ARG_EXPAND);
#define glFogf_INDEX 613
#define glFogf_RETURN void
#define glFogf_ARG_NAMES pname, param
#define glFogf_ARG_EXPAND GLenum pname, GLfloat param
#define glFogf_PACKED PACKED_glFogf
#define glFogf_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glFogf_NOT_VOID_WRAP(...) {}
#define pack_glFogf(_pname, _param) ({ \
    glFogf_PACKED *packed_data = malloc(sizeof(glFogf_PACKED)); \
    packed_data->index = glFogf_INDEX; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.param = (GLfloat)_param; \
    (packed_call_t *)packed_data; \
})
#define call_glFogf(packed, ret_v) do { \
    PACKED_glFogf *unpacked = (PACKED_glFogf *)packed; \
    ARGS_glFogf *args = (ARGS_glFogf *)&unpacked->args; \
    glFogf(args->pname, args->param);; \
} while(0)
void glFogf(glFogf_ARG_EXPAND);
typedef void (*glFogf_PTR)(glFogf_ARG_EXPAND);
#define glFogfv_INDEX 614
#define glFogfv_RETURN void
#define glFogfv_ARG_NAMES pname, params
#define glFogfv_ARG_EXPAND GLenum pname, const GLfloat * params
#define glFogfv_PACKED PACKED_glFogfv
#define glFogfv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glFogfv_NOT_VOID_WRAP(...) {}
#define pack_glFogfv(_pname, _params) ({ \
    glFogfv_PACKED *packed_data = malloc(sizeof(glFogfv_PACKED)); \
    packed_data->index = glFogfv_INDEX; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLfloat *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glFogfv(packed, ret_v) do { \
    PACKED_glFogfv *unpacked = (PACKED_glFogfv *)packed; \
    ARGS_glFogfv *args = (ARGS_glFogfv *)&unpacked->args; \
    glFogfv(args->pname, args->params);; \
} while(0)
void glFogfv(glFogfv_ARG_EXPAND);
typedef void (*glFogfv_PTR)(glFogfv_ARG_EXPAND);
#define glFogi_INDEX 615
#define glFogi_RETURN void
#define glFogi_ARG_NAMES pname, param
#define glFogi_ARG_EXPAND GLenum pname, GLint param
#define glFogi_PACKED PACKED_glFogi
#define glFogi_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glFogi_NOT_VOID_WRAP(...) {}
#define pack_glFogi(_pname, _param) ({ \
    glFogi_PACKED *packed_data = malloc(sizeof(glFogi_PACKED)); \
    packed_data->index = glFogi_INDEX; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.param = (GLint)_param; \
    (packed_call_t *)packed_data; \
})
#define call_glFogi(packed, ret_v) do { \
    PACKED_glFogi *unpacked = (PACKED_glFogi *)packed; \
    ARGS_glFogi *args = (ARGS_glFogi *)&unpacked->args; \
    glFogi(args->pname, args->param);; \
} while(0)
void glFogi(glFogi_ARG_EXPAND);
typedef void (*glFogi_PTR)(glFogi_ARG_EXPAND);
#define glFogiv_INDEX 616
#define glFogiv_RETURN void
#define glFogiv_ARG_NAMES pname, params
#define glFogiv_ARG_EXPAND GLenum pname, const GLint * params
#define glFogiv_PACKED PACKED_glFogiv
#define glFogiv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glFogiv_NOT_VOID_WRAP(...) {}
#define pack_glFogiv(_pname, _params) ({ \
    glFogiv_PACKED *packed_data = malloc(sizeof(glFogiv_PACKED)); \
    packed_data->index = glFogiv_INDEX; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glFogiv(packed, ret_v) do { \
    PACKED_glFogiv *unpacked = (PACKED_glFogiv *)packed; \
    ARGS_glFogiv *args = (ARGS_glFogiv *)&unpacked->args; \
    glFogiv(args->pname, args->params);; \
} while(0)
void glFogiv(glFogiv_ARG_EXPAND);
typedef void (*glFogiv_PTR)(glFogiv_ARG_EXPAND);
#define glFogx_INDEX 617
#define glFogx_RETURN void
#define glFogx_ARG_NAMES pname, param
#define glFogx_ARG_EXPAND GLenum pname, GLfixed param
#define glFogx_PACKED PACKED_glFogx
#define glFogx_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glFogx_NOT_VOID_WRAP(...) {}
#define pack_glFogx(_pname, _param) ({ \
    glFogx_PACKED *packed_data = malloc(sizeof(glFogx_PACKED)); \
    packed_data->index = glFogx_INDEX; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.param = (GLfixed)_param; \
    (packed_call_t *)packed_data; \
})
#define call_glFogx(packed, ret_v) do { \
    PACKED_glFogx *unpacked = (PACKED_glFogx *)packed; \
    ARGS_glFogx *args = (ARGS_glFogx *)&unpacked->args; \
    glFogx(args->pname, args->param);; \
} while(0)
void glFogx(glFogx_ARG_EXPAND);
typedef void (*glFogx_PTR)(glFogx_ARG_EXPAND);
#define glFogxOES_INDEX 618
#define glFogxOES_RETURN void
#define glFogxOES_ARG_NAMES pname, param
#define glFogxOES_ARG_EXPAND GLenum pname, GLfixed param
#define glFogxOES_PACKED PACKED_glFogxOES
#define glFogxOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glFogxOES_NOT_VOID_WRAP(...) {}
#define pack_glFogxOES(_pname, _param) ({ \
    glFogxOES_PACKED *packed_data = malloc(sizeof(glFogxOES_PACKED)); \
    packed_data->index = glFogxOES_INDEX; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.param = (GLfixed)_param; \
    (packed_call_t *)packed_data; \
})
#define call_glFogxOES(packed, ret_v) do { \
    PACKED_glFogxOES *unpacked = (PACKED_glFogxOES *)packed; \
    ARGS_glFogxOES *args = (ARGS_glFogxOES *)&unpacked->args; \
    glFogxOES(args->pname, args->param);; \
} while(0)
void glFogxOES(glFogxOES_ARG_EXPAND);
typedef void (*glFogxOES_PTR)(glFogxOES_ARG_EXPAND);
#define glFogxv_INDEX 619
#define glFogxv_RETURN void
#define glFogxv_ARG_NAMES pname, params
#define glFogxv_ARG_EXPAND GLenum pname, const GLfixed * params
#define glFogxv_PACKED PACKED_glFogxv
#define glFogxv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glFogxv_NOT_VOID_WRAP(...) {}
#define pack_glFogxv(_pname, _params) ({ \
    glFogxv_PACKED *packed_data = malloc(sizeof(glFogxv_PACKED)); \
    packed_data->index = glFogxv_INDEX; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLfixed *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glFogxv(packed, ret_v) do { \
    PACKED_glFogxv *unpacked = (PACKED_glFogxv *)packed; \
    ARGS_glFogxv *args = (ARGS_glFogxv *)&unpacked->args; \
    glFogxv(args->pname, args->params);; \
} while(0)
void glFogxv(glFogxv_ARG_EXPAND);
typedef void (*glFogxv_PTR)(glFogxv_ARG_EXPAND);
#define glFogxvOES_INDEX 620
#define glFogxvOES_RETURN void
#define glFogxvOES_ARG_NAMES pname, param
#define glFogxvOES_ARG_EXPAND GLenum pname, const GLfixed * param
#define glFogxvOES_PACKED PACKED_glFogxvOES
#define glFogxvOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glFogxvOES_NOT_VOID_WRAP(...) {}
#define pack_glFogxvOES(_pname, _param) ({ \
    glFogxvOES_PACKED *packed_data = malloc(sizeof(glFogxvOES_PACKED)); \
    packed_data->index = glFogxvOES_INDEX; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.param = (GLfixed *)_param; \
    (packed_call_t *)packed_data; \
})
#define call_glFogxvOES(packed, ret_v) do { \
    PACKED_glFogxvOES *unpacked = (PACKED_glFogxvOES *)packed; \
    ARGS_glFogxvOES *args = (ARGS_glFogxvOES *)&unpacked->args; \
    glFogxvOES(args->pname, args->param);; \
} while(0)
void glFogxvOES(glFogxvOES_ARG_EXPAND);
typedef void (*glFogxvOES_PTR)(glFogxvOES_ARG_EXPAND);
#define glFragmentColorMaterialSGIX_INDEX 621
#define glFragmentColorMaterialSGIX_RETURN void
#define glFragmentColorMaterialSGIX_ARG_NAMES face, mode
#define glFragmentColorMaterialSGIX_ARG_EXPAND GLenum face, GLenum mode
#define glFragmentColorMaterialSGIX_PACKED PACKED_glFragmentColorMaterialSGIX
#define glFragmentColorMaterialSGIX_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glFragmentColorMaterialSGIX_NOT_VOID_WRAP(...) {}
#define pack_glFragmentColorMaterialSGIX(_face, _mode) ({ \
    glFragmentColorMaterialSGIX_PACKED *packed_data = malloc(sizeof(glFragmentColorMaterialSGIX_PACKED)); \
    packed_data->index = glFragmentColorMaterialSGIX_INDEX; \
    packed_data->args.face = (GLenum)_face; \
    packed_data->args.mode = (GLenum)_mode; \
    (packed_call_t *)packed_data; \
})
#define call_glFragmentColorMaterialSGIX(packed, ret_v) do { \
    PACKED_glFragmentColorMaterialSGIX *unpacked = (PACKED_glFragmentColorMaterialSGIX *)packed; \
    ARGS_glFragmentColorMaterialSGIX *args = (ARGS_glFragmentColorMaterialSGIX *)&unpacked->args; \
    glFragmentColorMaterialSGIX(args->face, args->mode);; \
} while(0)
void glFragmentColorMaterialSGIX(glFragmentColorMaterialSGIX_ARG_EXPAND);
typedef void (*glFragmentColorMaterialSGIX_PTR)(glFragmentColorMaterialSGIX_ARG_EXPAND);
#define glFragmentLightModelfSGIX_INDEX 622
#define glFragmentLightModelfSGIX_RETURN void
#define glFragmentLightModelfSGIX_ARG_NAMES pname, param
#define glFragmentLightModelfSGIX_ARG_EXPAND GLenum pname, GLfloat param
#define glFragmentLightModelfSGIX_PACKED PACKED_glFragmentLightModelfSGIX
#define glFragmentLightModelfSGIX_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glFragmentLightModelfSGIX_NOT_VOID_WRAP(...) {}
#define pack_glFragmentLightModelfSGIX(_pname, _param) ({ \
    glFragmentLightModelfSGIX_PACKED *packed_data = malloc(sizeof(glFragmentLightModelfSGIX_PACKED)); \
    packed_data->index = glFragmentLightModelfSGIX_INDEX; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.param = (GLfloat)_param; \
    (packed_call_t *)packed_data; \
})
#define call_glFragmentLightModelfSGIX(packed, ret_v) do { \
    PACKED_glFragmentLightModelfSGIX *unpacked = (PACKED_glFragmentLightModelfSGIX *)packed; \
    ARGS_glFragmentLightModelfSGIX *args = (ARGS_glFragmentLightModelfSGIX *)&unpacked->args; \
    glFragmentLightModelfSGIX(args->pname, args->param);; \
} while(0)
void glFragmentLightModelfSGIX(glFragmentLightModelfSGIX_ARG_EXPAND);
typedef void (*glFragmentLightModelfSGIX_PTR)(glFragmentLightModelfSGIX_ARG_EXPAND);
#define glFragmentLightModelfvSGIX_INDEX 623
#define glFragmentLightModelfvSGIX_RETURN void
#define glFragmentLightModelfvSGIX_ARG_NAMES pname, params
#define glFragmentLightModelfvSGIX_ARG_EXPAND GLenum pname, const GLfloat * params
#define glFragmentLightModelfvSGIX_PACKED PACKED_glFragmentLightModelfvSGIX
#define glFragmentLightModelfvSGIX_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glFragmentLightModelfvSGIX_NOT_VOID_WRAP(...) {}
#define pack_glFragmentLightModelfvSGIX(_pname, _params) ({ \
    glFragmentLightModelfvSGIX_PACKED *packed_data = malloc(sizeof(glFragmentLightModelfvSGIX_PACKED)); \
    packed_data->index = glFragmentLightModelfvSGIX_INDEX; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLfloat *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glFragmentLightModelfvSGIX(packed, ret_v) do { \
    PACKED_glFragmentLightModelfvSGIX *unpacked = (PACKED_glFragmentLightModelfvSGIX *)packed; \
    ARGS_glFragmentLightModelfvSGIX *args = (ARGS_glFragmentLightModelfvSGIX *)&unpacked->args; \
    glFragmentLightModelfvSGIX(args->pname, args->params);; \
} while(0)
void glFragmentLightModelfvSGIX(glFragmentLightModelfvSGIX_ARG_EXPAND);
typedef void (*glFragmentLightModelfvSGIX_PTR)(glFragmentLightModelfvSGIX_ARG_EXPAND);
#define glFragmentLightModeliSGIX_INDEX 624
#define glFragmentLightModeliSGIX_RETURN void
#define glFragmentLightModeliSGIX_ARG_NAMES pname, param
#define glFragmentLightModeliSGIX_ARG_EXPAND GLenum pname, GLint param
#define glFragmentLightModeliSGIX_PACKED PACKED_glFragmentLightModeliSGIX
#define glFragmentLightModeliSGIX_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glFragmentLightModeliSGIX_NOT_VOID_WRAP(...) {}
#define pack_glFragmentLightModeliSGIX(_pname, _param) ({ \
    glFragmentLightModeliSGIX_PACKED *packed_data = malloc(sizeof(glFragmentLightModeliSGIX_PACKED)); \
    packed_data->index = glFragmentLightModeliSGIX_INDEX; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.param = (GLint)_param; \
    (packed_call_t *)packed_data; \
})
#define call_glFragmentLightModeliSGIX(packed, ret_v) do { \
    PACKED_glFragmentLightModeliSGIX *unpacked = (PACKED_glFragmentLightModeliSGIX *)packed; \
    ARGS_glFragmentLightModeliSGIX *args = (ARGS_glFragmentLightModeliSGIX *)&unpacked->args; \
    glFragmentLightModeliSGIX(args->pname, args->param);; \
} while(0)
void glFragmentLightModeliSGIX(glFragmentLightModeliSGIX_ARG_EXPAND);
typedef void (*glFragmentLightModeliSGIX_PTR)(glFragmentLightModeliSGIX_ARG_EXPAND);
#define glFragmentLightModelivSGIX_INDEX 625
#define glFragmentLightModelivSGIX_RETURN void
#define glFragmentLightModelivSGIX_ARG_NAMES pname, params
#define glFragmentLightModelivSGIX_ARG_EXPAND GLenum pname, const GLint * params
#define glFragmentLightModelivSGIX_PACKED PACKED_glFragmentLightModelivSGIX
#define glFragmentLightModelivSGIX_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glFragmentLightModelivSGIX_NOT_VOID_WRAP(...) {}
#define pack_glFragmentLightModelivSGIX(_pname, _params) ({ \
    glFragmentLightModelivSGIX_PACKED *packed_data = malloc(sizeof(glFragmentLightModelivSGIX_PACKED)); \
    packed_data->index = glFragmentLightModelivSGIX_INDEX; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glFragmentLightModelivSGIX(packed, ret_v) do { \
    PACKED_glFragmentLightModelivSGIX *unpacked = (PACKED_glFragmentLightModelivSGIX *)packed; \
    ARGS_glFragmentLightModelivSGIX *args = (ARGS_glFragmentLightModelivSGIX *)&unpacked->args; \
    glFragmentLightModelivSGIX(args->pname, args->params);; \
} while(0)
void glFragmentLightModelivSGIX(glFragmentLightModelivSGIX_ARG_EXPAND);
typedef void (*glFragmentLightModelivSGIX_PTR)(glFragmentLightModelivSGIX_ARG_EXPAND);
#define glFragmentLightfSGIX_INDEX 626
#define glFragmentLightfSGIX_RETURN void
#define glFragmentLightfSGIX_ARG_NAMES light, pname, param
#define glFragmentLightfSGIX_ARG_EXPAND GLenum light, GLenum pname, GLfloat param
#define glFragmentLightfSGIX_PACKED PACKED_glFragmentLightfSGIX
#define glFragmentLightfSGIX_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glFragmentLightfSGIX_NOT_VOID_WRAP(...) {}
#define pack_glFragmentLightfSGIX(_light, _pname, _param) ({ \
    glFragmentLightfSGIX_PACKED *packed_data = malloc(sizeof(glFragmentLightfSGIX_PACKED)); \
    packed_data->index = glFragmentLightfSGIX_INDEX; \
    packed_data->args.light = (GLenum)_light; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.param = (GLfloat)_param; \
    (packed_call_t *)packed_data; \
})
#define call_glFragmentLightfSGIX(packed, ret_v) do { \
    PACKED_glFragmentLightfSGIX *unpacked = (PACKED_glFragmentLightfSGIX *)packed; \
    ARGS_glFragmentLightfSGIX *args = (ARGS_glFragmentLightfSGIX *)&unpacked->args; \
    glFragmentLightfSGIX(args->light, args->pname, args->param);; \
} while(0)
void glFragmentLightfSGIX(glFragmentLightfSGIX_ARG_EXPAND);
typedef void (*glFragmentLightfSGIX_PTR)(glFragmentLightfSGIX_ARG_EXPAND);
#define glFragmentLightfvSGIX_INDEX 627
#define glFragmentLightfvSGIX_RETURN void
#define glFragmentLightfvSGIX_ARG_NAMES light, pname, params
#define glFragmentLightfvSGIX_ARG_EXPAND GLenum light, GLenum pname, const GLfloat * params
#define glFragmentLightfvSGIX_PACKED PACKED_glFragmentLightfvSGIX
#define glFragmentLightfvSGIX_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glFragmentLightfvSGIX_NOT_VOID_WRAP(...) {}
#define pack_glFragmentLightfvSGIX(_light, _pname, _params) ({ \
    glFragmentLightfvSGIX_PACKED *packed_data = malloc(sizeof(glFragmentLightfvSGIX_PACKED)); \
    packed_data->index = glFragmentLightfvSGIX_INDEX; \
    packed_data->args.light = (GLenum)_light; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLfloat *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glFragmentLightfvSGIX(packed, ret_v) do { \
    PACKED_glFragmentLightfvSGIX *unpacked = (PACKED_glFragmentLightfvSGIX *)packed; \
    ARGS_glFragmentLightfvSGIX *args = (ARGS_glFragmentLightfvSGIX *)&unpacked->args; \
    glFragmentLightfvSGIX(args->light, args->pname, args->params);; \
} while(0)
void glFragmentLightfvSGIX(glFragmentLightfvSGIX_ARG_EXPAND);
typedef void (*glFragmentLightfvSGIX_PTR)(glFragmentLightfvSGIX_ARG_EXPAND);
#define glFragmentLightiSGIX_INDEX 628
#define glFragmentLightiSGIX_RETURN void
#define glFragmentLightiSGIX_ARG_NAMES light, pname, param
#define glFragmentLightiSGIX_ARG_EXPAND GLenum light, GLenum pname, GLint param
#define glFragmentLightiSGIX_PACKED PACKED_glFragmentLightiSGIX
#define glFragmentLightiSGIX_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glFragmentLightiSGIX_NOT_VOID_WRAP(...) {}
#define pack_glFragmentLightiSGIX(_light, _pname, _param) ({ \
    glFragmentLightiSGIX_PACKED *packed_data = malloc(sizeof(glFragmentLightiSGIX_PACKED)); \
    packed_data->index = glFragmentLightiSGIX_INDEX; \
    packed_data->args.light = (GLenum)_light; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.param = (GLint)_param; \
    (packed_call_t *)packed_data; \
})
#define call_glFragmentLightiSGIX(packed, ret_v) do { \
    PACKED_glFragmentLightiSGIX *unpacked = (PACKED_glFragmentLightiSGIX *)packed; \
    ARGS_glFragmentLightiSGIX *args = (ARGS_glFragmentLightiSGIX *)&unpacked->args; \
    glFragmentLightiSGIX(args->light, args->pname, args->param);; \
} while(0)
void glFragmentLightiSGIX(glFragmentLightiSGIX_ARG_EXPAND);
typedef void (*glFragmentLightiSGIX_PTR)(glFragmentLightiSGIX_ARG_EXPAND);
#define glFragmentLightivSGIX_INDEX 629
#define glFragmentLightivSGIX_RETURN void
#define glFragmentLightivSGIX_ARG_NAMES light, pname, params
#define glFragmentLightivSGIX_ARG_EXPAND GLenum light, GLenum pname, const GLint * params
#define glFragmentLightivSGIX_PACKED PACKED_glFragmentLightivSGIX
#define glFragmentLightivSGIX_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glFragmentLightivSGIX_NOT_VOID_WRAP(...) {}
#define pack_glFragmentLightivSGIX(_light, _pname, _params) ({ \
    glFragmentLightivSGIX_PACKED *packed_data = malloc(sizeof(glFragmentLightivSGIX_PACKED)); \
    packed_data->index = glFragmentLightivSGIX_INDEX; \
    packed_data->args.light = (GLenum)_light; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glFragmentLightivSGIX(packed, ret_v) do { \
    PACKED_glFragmentLightivSGIX *unpacked = (PACKED_glFragmentLightivSGIX *)packed; \
    ARGS_glFragmentLightivSGIX *args = (ARGS_glFragmentLightivSGIX *)&unpacked->args; \
    glFragmentLightivSGIX(args->light, args->pname, args->params);; \
} while(0)
void glFragmentLightivSGIX(glFragmentLightivSGIX_ARG_EXPAND);
typedef void (*glFragmentLightivSGIX_PTR)(glFragmentLightivSGIX_ARG_EXPAND);
#define glFragmentMaterialfSGIX_INDEX 630
#define glFragmentMaterialfSGIX_RETURN void
#define glFragmentMaterialfSGIX_ARG_NAMES face, pname, param
#define glFragmentMaterialfSGIX_ARG_EXPAND GLenum face, GLenum pname, GLfloat param
#define glFragmentMaterialfSGIX_PACKED PACKED_glFragmentMaterialfSGIX
#define glFragmentMaterialfSGIX_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glFragmentMaterialfSGIX_NOT_VOID_WRAP(...) {}
#define pack_glFragmentMaterialfSGIX(_face, _pname, _param) ({ \
    glFragmentMaterialfSGIX_PACKED *packed_data = malloc(sizeof(glFragmentMaterialfSGIX_PACKED)); \
    packed_data->index = glFragmentMaterialfSGIX_INDEX; \
    packed_data->args.face = (GLenum)_face; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.param = (GLfloat)_param; \
    (packed_call_t *)packed_data; \
})
#define call_glFragmentMaterialfSGIX(packed, ret_v) do { \
    PACKED_glFragmentMaterialfSGIX *unpacked = (PACKED_glFragmentMaterialfSGIX *)packed; \
    ARGS_glFragmentMaterialfSGIX *args = (ARGS_glFragmentMaterialfSGIX *)&unpacked->args; \
    glFragmentMaterialfSGIX(args->face, args->pname, args->param);; \
} while(0)
void glFragmentMaterialfSGIX(glFragmentMaterialfSGIX_ARG_EXPAND);
typedef void (*glFragmentMaterialfSGIX_PTR)(glFragmentMaterialfSGIX_ARG_EXPAND);
#define glFragmentMaterialfvSGIX_INDEX 631
#define glFragmentMaterialfvSGIX_RETURN void
#define glFragmentMaterialfvSGIX_ARG_NAMES face, pname, params
#define glFragmentMaterialfvSGIX_ARG_EXPAND GLenum face, GLenum pname, const GLfloat * params
#define glFragmentMaterialfvSGIX_PACKED PACKED_glFragmentMaterialfvSGIX
#define glFragmentMaterialfvSGIX_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glFragmentMaterialfvSGIX_NOT_VOID_WRAP(...) {}
#define pack_glFragmentMaterialfvSGIX(_face, _pname, _params) ({ \
    glFragmentMaterialfvSGIX_PACKED *packed_data = malloc(sizeof(glFragmentMaterialfvSGIX_PACKED)); \
    packed_data->index = glFragmentMaterialfvSGIX_INDEX; \
    packed_data->args.face = (GLenum)_face; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLfloat *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glFragmentMaterialfvSGIX(packed, ret_v) do { \
    PACKED_glFragmentMaterialfvSGIX *unpacked = (PACKED_glFragmentMaterialfvSGIX *)packed; \
    ARGS_glFragmentMaterialfvSGIX *args = (ARGS_glFragmentMaterialfvSGIX *)&unpacked->args; \
    glFragmentMaterialfvSGIX(args->face, args->pname, args->params);; \
} while(0)
void glFragmentMaterialfvSGIX(glFragmentMaterialfvSGIX_ARG_EXPAND);
typedef void (*glFragmentMaterialfvSGIX_PTR)(glFragmentMaterialfvSGIX_ARG_EXPAND);
#define glFragmentMaterialiSGIX_INDEX 632
#define glFragmentMaterialiSGIX_RETURN void
#define glFragmentMaterialiSGIX_ARG_NAMES face, pname, param
#define glFragmentMaterialiSGIX_ARG_EXPAND GLenum face, GLenum pname, GLint param
#define glFragmentMaterialiSGIX_PACKED PACKED_glFragmentMaterialiSGIX
#define glFragmentMaterialiSGIX_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glFragmentMaterialiSGIX_NOT_VOID_WRAP(...) {}
#define pack_glFragmentMaterialiSGIX(_face, _pname, _param) ({ \
    glFragmentMaterialiSGIX_PACKED *packed_data = malloc(sizeof(glFragmentMaterialiSGIX_PACKED)); \
    packed_data->index = glFragmentMaterialiSGIX_INDEX; \
    packed_data->args.face = (GLenum)_face; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.param = (GLint)_param; \
    (packed_call_t *)packed_data; \
})
#define call_glFragmentMaterialiSGIX(packed, ret_v) do { \
    PACKED_glFragmentMaterialiSGIX *unpacked = (PACKED_glFragmentMaterialiSGIX *)packed; \
    ARGS_glFragmentMaterialiSGIX *args = (ARGS_glFragmentMaterialiSGIX *)&unpacked->args; \
    glFragmentMaterialiSGIX(args->face, args->pname, args->param);; \
} while(0)
void glFragmentMaterialiSGIX(glFragmentMaterialiSGIX_ARG_EXPAND);
typedef void (*glFragmentMaterialiSGIX_PTR)(glFragmentMaterialiSGIX_ARG_EXPAND);
#define glFragmentMaterialivSGIX_INDEX 633
#define glFragmentMaterialivSGIX_RETURN void
#define glFragmentMaterialivSGIX_ARG_NAMES face, pname, params
#define glFragmentMaterialivSGIX_ARG_EXPAND GLenum face, GLenum pname, const GLint * params
#define glFragmentMaterialivSGIX_PACKED PACKED_glFragmentMaterialivSGIX
#define glFragmentMaterialivSGIX_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glFragmentMaterialivSGIX_NOT_VOID_WRAP(...) {}
#define pack_glFragmentMaterialivSGIX(_face, _pname, _params) ({ \
    glFragmentMaterialivSGIX_PACKED *packed_data = malloc(sizeof(glFragmentMaterialivSGIX_PACKED)); \
    packed_data->index = glFragmentMaterialivSGIX_INDEX; \
    packed_data->args.face = (GLenum)_face; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glFragmentMaterialivSGIX(packed, ret_v) do { \
    PACKED_glFragmentMaterialivSGIX *unpacked = (PACKED_glFragmentMaterialivSGIX *)packed; \
    ARGS_glFragmentMaterialivSGIX *args = (ARGS_glFragmentMaterialivSGIX *)&unpacked->args; \
    glFragmentMaterialivSGIX(args->face, args->pname, args->params);; \
} while(0)
void glFragmentMaterialivSGIX(glFragmentMaterialivSGIX_ARG_EXPAND);
typedef void (*glFragmentMaterialivSGIX_PTR)(glFragmentMaterialivSGIX_ARG_EXPAND);
#define glFrameTerminatorGREMEDY_INDEX 634
#define glFrameTerminatorGREMEDY_RETURN void
#define glFrameTerminatorGREMEDY_ARG_NAMES 
#define glFrameTerminatorGREMEDY_ARG_EXPAND 
#define glFrameTerminatorGREMEDY_PACKED PACKED_glFrameTerminatorGREMEDY
#define glFrameTerminatorGREMEDY_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glFrameTerminatorGREMEDY_NOT_VOID_WRAP(...) {}
#define pack_glFrameTerminatorGREMEDY() ({ \
    glFrameTerminatorGREMEDY_PACKED *packed_data = malloc(sizeof(glFrameTerminatorGREMEDY_PACKED)); \
    packed_data->index = glFrameTerminatorGREMEDY_INDEX; \
    (packed_call_t *)packed_data; \
})
#define call_glFrameTerminatorGREMEDY(packed, ret_v) do { \
    glFrameTerminatorGREMEDY();; \
} while(0)
void glFrameTerminatorGREMEDY(glFrameTerminatorGREMEDY_ARG_EXPAND);
typedef void (*glFrameTerminatorGREMEDY_PTR)(glFrameTerminatorGREMEDY_ARG_EXPAND);
#define glFrameZoomSGIX_INDEX 635
#define glFrameZoomSGIX_RETURN void
#define glFrameZoomSGIX_ARG_NAMES factor
#define glFrameZoomSGIX_ARG_EXPAND GLint factor
#define glFrameZoomSGIX_PACKED PACKED_glFrameZoomSGIX
#define glFrameZoomSGIX_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glFrameZoomSGIX_NOT_VOID_WRAP(...) {}
#define pack_glFrameZoomSGIX(_factor) ({ \
    glFrameZoomSGIX_PACKED *packed_data = malloc(sizeof(glFrameZoomSGIX_PACKED)); \
    packed_data->index = glFrameZoomSGIX_INDEX; \
    packed_data->args.factor = (GLint)_factor; \
    (packed_call_t *)packed_data; \
})
#define call_glFrameZoomSGIX(packed, ret_v) do { \
    PACKED_glFrameZoomSGIX *unpacked = (PACKED_glFrameZoomSGIX *)packed; \
    ARGS_glFrameZoomSGIX *args = (ARGS_glFrameZoomSGIX *)&unpacked->args; \
    glFrameZoomSGIX(args->factor);; \
} while(0)
void glFrameZoomSGIX(glFrameZoomSGIX_ARG_EXPAND);
typedef void (*glFrameZoomSGIX_PTR)(glFrameZoomSGIX_ARG_EXPAND);
#define glFramebufferDrawBufferEXT_INDEX 636
#define glFramebufferDrawBufferEXT_RETURN void
#define glFramebufferDrawBufferEXT_ARG_NAMES framebuffer, mode
#define glFramebufferDrawBufferEXT_ARG_EXPAND GLuint framebuffer, GLenum mode
#define glFramebufferDrawBufferEXT_PACKED PACKED_glFramebufferDrawBufferEXT
#define glFramebufferDrawBufferEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glFramebufferDrawBufferEXT_NOT_VOID_WRAP(...) {}
#define pack_glFramebufferDrawBufferEXT(_framebuffer, _mode) ({ \
    glFramebufferDrawBufferEXT_PACKED *packed_data = malloc(sizeof(glFramebufferDrawBufferEXT_PACKED)); \
    packed_data->index = glFramebufferDrawBufferEXT_INDEX; \
    packed_data->args.framebuffer = (GLuint)_framebuffer; \
    packed_data->args.mode = (GLenum)_mode; \
    (packed_call_t *)packed_data; \
})
#define call_glFramebufferDrawBufferEXT(packed, ret_v) do { \
    PACKED_glFramebufferDrawBufferEXT *unpacked = (PACKED_glFramebufferDrawBufferEXT *)packed; \
    ARGS_glFramebufferDrawBufferEXT *args = (ARGS_glFramebufferDrawBufferEXT *)&unpacked->args; \
    glFramebufferDrawBufferEXT(args->framebuffer, args->mode);; \
} while(0)
void glFramebufferDrawBufferEXT(glFramebufferDrawBufferEXT_ARG_EXPAND);
typedef void (*glFramebufferDrawBufferEXT_PTR)(glFramebufferDrawBufferEXT_ARG_EXPAND);
#define glFramebufferDrawBuffersEXT_INDEX 637
#define glFramebufferDrawBuffersEXT_RETURN void
#define glFramebufferDrawBuffersEXT_ARG_NAMES framebuffer, n, bufs
#define glFramebufferDrawBuffersEXT_ARG_EXPAND GLuint framebuffer, GLsizei n, const GLenum * bufs
#define glFramebufferDrawBuffersEXT_PACKED PACKED_glFramebufferDrawBuffersEXT
#define glFramebufferDrawBuffersEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glFramebufferDrawBuffersEXT_NOT_VOID_WRAP(...) {}
#define pack_glFramebufferDrawBuffersEXT(_framebuffer, _n, _bufs) ({ \
    glFramebufferDrawBuffersEXT_PACKED *packed_data = malloc(sizeof(glFramebufferDrawBuffersEXT_PACKED)); \
    packed_data->index = glFramebufferDrawBuffersEXT_INDEX; \
    packed_data->args.framebuffer = (GLuint)_framebuffer; \
    packed_data->args.n = (GLsizei)_n; \
    packed_data->args.bufs = (GLenum *)_bufs; \
    (packed_call_t *)packed_data; \
})
#define call_glFramebufferDrawBuffersEXT(packed, ret_v) do { \
    PACKED_glFramebufferDrawBuffersEXT *unpacked = (PACKED_glFramebufferDrawBuffersEXT *)packed; \
    ARGS_glFramebufferDrawBuffersEXT *args = (ARGS_glFramebufferDrawBuffersEXT *)&unpacked->args; \
    glFramebufferDrawBuffersEXT(args->framebuffer, args->n, args->bufs);; \
} while(0)
void glFramebufferDrawBuffersEXT(glFramebufferDrawBuffersEXT_ARG_EXPAND);
typedef void (*glFramebufferDrawBuffersEXT_PTR)(glFramebufferDrawBuffersEXT_ARG_EXPAND);
#define glFramebufferParameteri_INDEX 638
#define glFramebufferParameteri_RETURN void
#define glFramebufferParameteri_ARG_NAMES target, pname, param
#define glFramebufferParameteri_ARG_EXPAND GLenum target, GLenum pname, GLint param
#define glFramebufferParameteri_PACKED PACKED_glFramebufferParameteri
#define glFramebufferParameteri_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glFramebufferParameteri_NOT_VOID_WRAP(...) {}
#define pack_glFramebufferParameteri(_target, _pname, _param) ({ \
    glFramebufferParameteri_PACKED *packed_data = malloc(sizeof(glFramebufferParameteri_PACKED)); \
    packed_data->index = glFramebufferParameteri_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.param = (GLint)_param; \
    (packed_call_t *)packed_data; \
})
#define call_glFramebufferParameteri(packed, ret_v) do { \
    PACKED_glFramebufferParameteri *unpacked = (PACKED_glFramebufferParameteri *)packed; \
    ARGS_glFramebufferParameteri *args = (ARGS_glFramebufferParameteri *)&unpacked->args; \
    glFramebufferParameteri(args->target, args->pname, args->param);; \
} while(0)
void glFramebufferParameteri(glFramebufferParameteri_ARG_EXPAND);
typedef void (*glFramebufferParameteri_PTR)(glFramebufferParameteri_ARG_EXPAND);
#define glFramebufferReadBufferEXT_INDEX 639
#define glFramebufferReadBufferEXT_RETURN void
#define glFramebufferReadBufferEXT_ARG_NAMES framebuffer, mode
#define glFramebufferReadBufferEXT_ARG_EXPAND GLuint framebuffer, GLenum mode
#define glFramebufferReadBufferEXT_PACKED PACKED_glFramebufferReadBufferEXT
#define glFramebufferReadBufferEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glFramebufferReadBufferEXT_NOT_VOID_WRAP(...) {}
#define pack_glFramebufferReadBufferEXT(_framebuffer, _mode) ({ \
    glFramebufferReadBufferEXT_PACKED *packed_data = malloc(sizeof(glFramebufferReadBufferEXT_PACKED)); \
    packed_data->index = glFramebufferReadBufferEXT_INDEX; \
    packed_data->args.framebuffer = (GLuint)_framebuffer; \
    packed_data->args.mode = (GLenum)_mode; \
    (packed_call_t *)packed_data; \
})
#define call_glFramebufferReadBufferEXT(packed, ret_v) do { \
    PACKED_glFramebufferReadBufferEXT *unpacked = (PACKED_glFramebufferReadBufferEXT *)packed; \
    ARGS_glFramebufferReadBufferEXT *args = (ARGS_glFramebufferReadBufferEXT *)&unpacked->args; \
    glFramebufferReadBufferEXT(args->framebuffer, args->mode);; \
} while(0)
void glFramebufferReadBufferEXT(glFramebufferReadBufferEXT_ARG_EXPAND);
typedef void (*glFramebufferReadBufferEXT_PTR)(glFramebufferReadBufferEXT_ARG_EXPAND);
#define glFramebufferRenderbuffer_INDEX 640
#define glFramebufferRenderbuffer_RETURN void
#define glFramebufferRenderbuffer_ARG_NAMES target, attachment, renderbuffertarget, renderbuffer
#define glFramebufferRenderbuffer_ARG_EXPAND GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer
#define glFramebufferRenderbuffer_PACKED PACKED_glFramebufferRenderbuffer
#define glFramebufferRenderbuffer_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glFramebufferRenderbuffer_NOT_VOID_WRAP(...) {}
#define pack_glFramebufferRenderbuffer(_target, _attachment, _renderbuffertarget, _renderbuffer) ({ \
    glFramebufferRenderbuffer_PACKED *packed_data = malloc(sizeof(glFramebufferRenderbuffer_PACKED)); \
    packed_data->index = glFramebufferRenderbuffer_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.attachment = (GLenum)_attachment; \
    packed_data->args.renderbuffertarget = (GLenum)_renderbuffertarget; \
    packed_data->args.renderbuffer = (GLuint)_renderbuffer; \
    (packed_call_t *)packed_data; \
})
#define call_glFramebufferRenderbuffer(packed, ret_v) do { \
    PACKED_glFramebufferRenderbuffer *unpacked = (PACKED_glFramebufferRenderbuffer *)packed; \
    ARGS_glFramebufferRenderbuffer *args = (ARGS_glFramebufferRenderbuffer *)&unpacked->args; \
    glFramebufferRenderbuffer(args->target, args->attachment, args->renderbuffertarget, args->renderbuffer);; \
} while(0)
void glFramebufferRenderbuffer(glFramebufferRenderbuffer_ARG_EXPAND);
typedef void (*glFramebufferRenderbuffer_PTR)(glFramebufferRenderbuffer_ARG_EXPAND);
#define glFramebufferRenderbufferEXT_INDEX 641
#define glFramebufferRenderbufferEXT_RETURN void
#define glFramebufferRenderbufferEXT_ARG_NAMES target, attachment, renderbuffertarget, renderbuffer
#define glFramebufferRenderbufferEXT_ARG_EXPAND GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer
#define glFramebufferRenderbufferEXT_PACKED PACKED_glFramebufferRenderbufferEXT
#define glFramebufferRenderbufferEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glFramebufferRenderbufferEXT_NOT_VOID_WRAP(...) {}
#define pack_glFramebufferRenderbufferEXT(_target, _attachment, _renderbuffertarget, _renderbuffer) ({ \
    glFramebufferRenderbufferEXT_PACKED *packed_data = malloc(sizeof(glFramebufferRenderbufferEXT_PACKED)); \
    packed_data->index = glFramebufferRenderbufferEXT_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.attachment = (GLenum)_attachment; \
    packed_data->args.renderbuffertarget = (GLenum)_renderbuffertarget; \
    packed_data->args.renderbuffer = (GLuint)_renderbuffer; \
    (packed_call_t *)packed_data; \
})
#define call_glFramebufferRenderbufferEXT(packed, ret_v) do { \
    PACKED_glFramebufferRenderbufferEXT *unpacked = (PACKED_glFramebufferRenderbufferEXT *)packed; \
    ARGS_glFramebufferRenderbufferEXT *args = (ARGS_glFramebufferRenderbufferEXT *)&unpacked->args; \
    glFramebufferRenderbufferEXT(args->target, args->attachment, args->renderbuffertarget, args->renderbuffer);; \
} while(0)
void glFramebufferRenderbufferEXT(glFramebufferRenderbufferEXT_ARG_EXPAND);
typedef void (*glFramebufferRenderbufferEXT_PTR)(glFramebufferRenderbufferEXT_ARG_EXPAND);
#define glFramebufferTexture_INDEX 642
#define glFramebufferTexture_RETURN void
#define glFramebufferTexture_ARG_NAMES target, attachment, texture, level
#define glFramebufferTexture_ARG_EXPAND GLenum target, GLenum attachment, GLuint texture, GLint level
#define glFramebufferTexture_PACKED PACKED_glFramebufferTexture
#define glFramebufferTexture_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glFramebufferTexture_NOT_VOID_WRAP(...) {}
#define pack_glFramebufferTexture(_target, _attachment, _texture, _level) ({ \
    glFramebufferTexture_PACKED *packed_data = malloc(sizeof(glFramebufferTexture_PACKED)); \
    packed_data->index = glFramebufferTexture_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.attachment = (GLenum)_attachment; \
    packed_data->args.texture = (GLuint)_texture; \
    packed_data->args.level = (GLint)_level; \
    (packed_call_t *)packed_data; \
})
#define call_glFramebufferTexture(packed, ret_v) do { \
    PACKED_glFramebufferTexture *unpacked = (PACKED_glFramebufferTexture *)packed; \
    ARGS_glFramebufferTexture *args = (ARGS_glFramebufferTexture *)&unpacked->args; \
    glFramebufferTexture(args->target, args->attachment, args->texture, args->level);; \
} while(0)
void glFramebufferTexture(glFramebufferTexture_ARG_EXPAND);
typedef void (*glFramebufferTexture_PTR)(glFramebufferTexture_ARG_EXPAND);
#define glFramebufferTexture1D_INDEX 643
#define glFramebufferTexture1D_RETURN void
#define glFramebufferTexture1D_ARG_NAMES target, attachment, textarget, texture, level
#define glFramebufferTexture1D_ARG_EXPAND GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level
#define glFramebufferTexture1D_PACKED PACKED_glFramebufferTexture1D
#define glFramebufferTexture1D_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glFramebufferTexture1D_NOT_VOID_WRAP(...) {}
#define pack_glFramebufferTexture1D(_target, _attachment, _textarget, _texture, _level) ({ \
    glFramebufferTexture1D_PACKED *packed_data = malloc(sizeof(glFramebufferTexture1D_PACKED)); \
    packed_data->index = glFramebufferTexture1D_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.attachment = (GLenum)_attachment; \
    packed_data->args.textarget = (GLenum)_textarget; \
    packed_data->args.texture = (GLuint)_texture; \
    packed_data->args.level = (GLint)_level; \
    (packed_call_t *)packed_data; \
})
#define call_glFramebufferTexture1D(packed, ret_v) do { \
    PACKED_glFramebufferTexture1D *unpacked = (PACKED_glFramebufferTexture1D *)packed; \
    ARGS_glFramebufferTexture1D *args = (ARGS_glFramebufferTexture1D *)&unpacked->args; \
    glFramebufferTexture1D(args->target, args->attachment, args->textarget, args->texture, args->level);; \
} while(0)
void glFramebufferTexture1D(glFramebufferTexture1D_ARG_EXPAND);
typedef void (*glFramebufferTexture1D_PTR)(glFramebufferTexture1D_ARG_EXPAND);
#define glFramebufferTexture1DEXT_INDEX 644
#define glFramebufferTexture1DEXT_RETURN void
#define glFramebufferTexture1DEXT_ARG_NAMES target, attachment, textarget, texture, level
#define glFramebufferTexture1DEXT_ARG_EXPAND GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level
#define glFramebufferTexture1DEXT_PACKED PACKED_glFramebufferTexture1DEXT
#define glFramebufferTexture1DEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glFramebufferTexture1DEXT_NOT_VOID_WRAP(...) {}
#define pack_glFramebufferTexture1DEXT(_target, _attachment, _textarget, _texture, _level) ({ \
    glFramebufferTexture1DEXT_PACKED *packed_data = malloc(sizeof(glFramebufferTexture1DEXT_PACKED)); \
    packed_data->index = glFramebufferTexture1DEXT_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.attachment = (GLenum)_attachment; \
    packed_data->args.textarget = (GLenum)_textarget; \
    packed_data->args.texture = (GLuint)_texture; \
    packed_data->args.level = (GLint)_level; \
    (packed_call_t *)packed_data; \
})
#define call_glFramebufferTexture1DEXT(packed, ret_v) do { \
    PACKED_glFramebufferTexture1DEXT *unpacked = (PACKED_glFramebufferTexture1DEXT *)packed; \
    ARGS_glFramebufferTexture1DEXT *args = (ARGS_glFramebufferTexture1DEXT *)&unpacked->args; \
    glFramebufferTexture1DEXT(args->target, args->attachment, args->textarget, args->texture, args->level);; \
} while(0)
void glFramebufferTexture1DEXT(glFramebufferTexture1DEXT_ARG_EXPAND);
typedef void (*glFramebufferTexture1DEXT_PTR)(glFramebufferTexture1DEXT_ARG_EXPAND);
#define glFramebufferTexture2D_INDEX 645
#define glFramebufferTexture2D_RETURN void
#define glFramebufferTexture2D_ARG_NAMES target, attachment, textarget, texture, level
#define glFramebufferTexture2D_ARG_EXPAND GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level
#define glFramebufferTexture2D_PACKED PACKED_glFramebufferTexture2D
#define glFramebufferTexture2D_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glFramebufferTexture2D_NOT_VOID_WRAP(...) {}
#define pack_glFramebufferTexture2D(_target, _attachment, _textarget, _texture, _level) ({ \
    glFramebufferTexture2D_PACKED *packed_data = malloc(sizeof(glFramebufferTexture2D_PACKED)); \
    packed_data->index = glFramebufferTexture2D_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.attachment = (GLenum)_attachment; \
    packed_data->args.textarget = (GLenum)_textarget; \
    packed_data->args.texture = (GLuint)_texture; \
    packed_data->args.level = (GLint)_level; \
    (packed_call_t *)packed_data; \
})
#define call_glFramebufferTexture2D(packed, ret_v) do { \
    PACKED_glFramebufferTexture2D *unpacked = (PACKED_glFramebufferTexture2D *)packed; \
    ARGS_glFramebufferTexture2D *args = (ARGS_glFramebufferTexture2D *)&unpacked->args; \
    glFramebufferTexture2D(args->target, args->attachment, args->textarget, args->texture, args->level);; \
} while(0)
void glFramebufferTexture2D(glFramebufferTexture2D_ARG_EXPAND);
typedef void (*glFramebufferTexture2D_PTR)(glFramebufferTexture2D_ARG_EXPAND);
#define glFramebufferTexture2DEXT_INDEX 646
#define glFramebufferTexture2DEXT_RETURN void
#define glFramebufferTexture2DEXT_ARG_NAMES target, attachment, textarget, texture, level
#define glFramebufferTexture2DEXT_ARG_EXPAND GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level
#define glFramebufferTexture2DEXT_PACKED PACKED_glFramebufferTexture2DEXT
#define glFramebufferTexture2DEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glFramebufferTexture2DEXT_NOT_VOID_WRAP(...) {}
#define pack_glFramebufferTexture2DEXT(_target, _attachment, _textarget, _texture, _level) ({ \
    glFramebufferTexture2DEXT_PACKED *packed_data = malloc(sizeof(glFramebufferTexture2DEXT_PACKED)); \
    packed_data->index = glFramebufferTexture2DEXT_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.attachment = (GLenum)_attachment; \
    packed_data->args.textarget = (GLenum)_textarget; \
    packed_data->args.texture = (GLuint)_texture; \
    packed_data->args.level = (GLint)_level; \
    (packed_call_t *)packed_data; \
})
#define call_glFramebufferTexture2DEXT(packed, ret_v) do { \
    PACKED_glFramebufferTexture2DEXT *unpacked = (PACKED_glFramebufferTexture2DEXT *)packed; \
    ARGS_glFramebufferTexture2DEXT *args = (ARGS_glFramebufferTexture2DEXT *)&unpacked->args; \
    glFramebufferTexture2DEXT(args->target, args->attachment, args->textarget, args->texture, args->level);; \
} while(0)
void glFramebufferTexture2DEXT(glFramebufferTexture2DEXT_ARG_EXPAND);
typedef void (*glFramebufferTexture2DEXT_PTR)(glFramebufferTexture2DEXT_ARG_EXPAND);
#define glFramebufferTexture3D_INDEX 647
#define glFramebufferTexture3D_RETURN void
#define glFramebufferTexture3D_ARG_NAMES target, attachment, textarget, texture, level, zoffset
#define glFramebufferTexture3D_ARG_EXPAND GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset
#define glFramebufferTexture3D_PACKED PACKED_glFramebufferTexture3D
#define glFramebufferTexture3D_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glFramebufferTexture3D_NOT_VOID_WRAP(...) {}
#define pack_glFramebufferTexture3D(_target, _attachment, _textarget, _texture, _level, _zoffset) ({ \
    glFramebufferTexture3D_PACKED *packed_data = malloc(sizeof(glFramebufferTexture3D_PACKED)); \
    packed_data->index = glFramebufferTexture3D_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.attachment = (GLenum)_attachment; \
    packed_data->args.textarget = (GLenum)_textarget; \
    packed_data->args.texture = (GLuint)_texture; \
    packed_data->args.level = (GLint)_level; \
    packed_data->args.zoffset = (GLint)_zoffset; \
    (packed_call_t *)packed_data; \
})
#define call_glFramebufferTexture3D(packed, ret_v) do { \
    PACKED_glFramebufferTexture3D *unpacked = (PACKED_glFramebufferTexture3D *)packed; \
    ARGS_glFramebufferTexture3D *args = (ARGS_glFramebufferTexture3D *)&unpacked->args; \
    glFramebufferTexture3D(args->target, args->attachment, args->textarget, args->texture, args->level, args->zoffset);; \
} while(0)
void glFramebufferTexture3D(glFramebufferTexture3D_ARG_EXPAND);
typedef void (*glFramebufferTexture3D_PTR)(glFramebufferTexture3D_ARG_EXPAND);
#define glFramebufferTexture3DEXT_INDEX 648
#define glFramebufferTexture3DEXT_RETURN void
#define glFramebufferTexture3DEXT_ARG_NAMES target, attachment, textarget, texture, level, zoffset
#define glFramebufferTexture3DEXT_ARG_EXPAND GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset
#define glFramebufferTexture3DEXT_PACKED PACKED_glFramebufferTexture3DEXT
#define glFramebufferTexture3DEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glFramebufferTexture3DEXT_NOT_VOID_WRAP(...) {}
#define pack_glFramebufferTexture3DEXT(_target, _attachment, _textarget, _texture, _level, _zoffset) ({ \
    glFramebufferTexture3DEXT_PACKED *packed_data = malloc(sizeof(glFramebufferTexture3DEXT_PACKED)); \
    packed_data->index = glFramebufferTexture3DEXT_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.attachment = (GLenum)_attachment; \
    packed_data->args.textarget = (GLenum)_textarget; \
    packed_data->args.texture = (GLuint)_texture; \
    packed_data->args.level = (GLint)_level; \
    packed_data->args.zoffset = (GLint)_zoffset; \
    (packed_call_t *)packed_data; \
})
#define call_glFramebufferTexture3DEXT(packed, ret_v) do { \
    PACKED_glFramebufferTexture3DEXT *unpacked = (PACKED_glFramebufferTexture3DEXT *)packed; \
    ARGS_glFramebufferTexture3DEXT *args = (ARGS_glFramebufferTexture3DEXT *)&unpacked->args; \
    glFramebufferTexture3DEXT(args->target, args->attachment, args->textarget, args->texture, args->level, args->zoffset);; \
} while(0)
void glFramebufferTexture3DEXT(glFramebufferTexture3DEXT_ARG_EXPAND);
typedef void (*glFramebufferTexture3DEXT_PTR)(glFramebufferTexture3DEXT_ARG_EXPAND);
#define glFramebufferTextureARB_INDEX 649
#define glFramebufferTextureARB_RETURN void
#define glFramebufferTextureARB_ARG_NAMES target, attachment, texture, level
#define glFramebufferTextureARB_ARG_EXPAND GLenum target, GLenum attachment, GLuint texture, GLint level
#define glFramebufferTextureARB_PACKED PACKED_glFramebufferTextureARB
#define glFramebufferTextureARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glFramebufferTextureARB_NOT_VOID_WRAP(...) {}
#define pack_glFramebufferTextureARB(_target, _attachment, _texture, _level) ({ \
    glFramebufferTextureARB_PACKED *packed_data = malloc(sizeof(glFramebufferTextureARB_PACKED)); \
    packed_data->index = glFramebufferTextureARB_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.attachment = (GLenum)_attachment; \
    packed_data->args.texture = (GLuint)_texture; \
    packed_data->args.level = (GLint)_level; \
    (packed_call_t *)packed_data; \
})
#define call_glFramebufferTextureARB(packed, ret_v) do { \
    PACKED_glFramebufferTextureARB *unpacked = (PACKED_glFramebufferTextureARB *)packed; \
    ARGS_glFramebufferTextureARB *args = (ARGS_glFramebufferTextureARB *)&unpacked->args; \
    glFramebufferTextureARB(args->target, args->attachment, args->texture, args->level);; \
} while(0)
void glFramebufferTextureARB(glFramebufferTextureARB_ARG_EXPAND);
typedef void (*glFramebufferTextureARB_PTR)(glFramebufferTextureARB_ARG_EXPAND);
#define glFramebufferTextureEXT_INDEX 650
#define glFramebufferTextureEXT_RETURN void
#define glFramebufferTextureEXT_ARG_NAMES target, attachment, texture, level
#define glFramebufferTextureEXT_ARG_EXPAND GLenum target, GLenum attachment, GLuint texture, GLint level
#define glFramebufferTextureEXT_PACKED PACKED_glFramebufferTextureEXT
#define glFramebufferTextureEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glFramebufferTextureEXT_NOT_VOID_WRAP(...) {}
#define pack_glFramebufferTextureEXT(_target, _attachment, _texture, _level) ({ \
    glFramebufferTextureEXT_PACKED *packed_data = malloc(sizeof(glFramebufferTextureEXT_PACKED)); \
    packed_data->index = glFramebufferTextureEXT_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.attachment = (GLenum)_attachment; \
    packed_data->args.texture = (GLuint)_texture; \
    packed_data->args.level = (GLint)_level; \
    (packed_call_t *)packed_data; \
})
#define call_glFramebufferTextureEXT(packed, ret_v) do { \
    PACKED_glFramebufferTextureEXT *unpacked = (PACKED_glFramebufferTextureEXT *)packed; \
    ARGS_glFramebufferTextureEXT *args = (ARGS_glFramebufferTextureEXT *)&unpacked->args; \
    glFramebufferTextureEXT(args->target, args->attachment, args->texture, args->level);; \
} while(0)
void glFramebufferTextureEXT(glFramebufferTextureEXT_ARG_EXPAND);
typedef void (*glFramebufferTextureEXT_PTR)(glFramebufferTextureEXT_ARG_EXPAND);
#define glFramebufferTextureFaceARB_INDEX 651
#define glFramebufferTextureFaceARB_RETURN void
#define glFramebufferTextureFaceARB_ARG_NAMES target, attachment, texture, level, face
#define glFramebufferTextureFaceARB_ARG_EXPAND GLenum target, GLenum attachment, GLuint texture, GLint level, GLenum face
#define glFramebufferTextureFaceARB_PACKED PACKED_glFramebufferTextureFaceARB
#define glFramebufferTextureFaceARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glFramebufferTextureFaceARB_NOT_VOID_WRAP(...) {}
#define pack_glFramebufferTextureFaceARB(_target, _attachment, _texture, _level, _face) ({ \
    glFramebufferTextureFaceARB_PACKED *packed_data = malloc(sizeof(glFramebufferTextureFaceARB_PACKED)); \
    packed_data->index = glFramebufferTextureFaceARB_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.attachment = (GLenum)_attachment; \
    packed_data->args.texture = (GLuint)_texture; \
    packed_data->args.level = (GLint)_level; \
    packed_data->args.face = (GLenum)_face; \
    (packed_call_t *)packed_data; \
})
#define call_glFramebufferTextureFaceARB(packed, ret_v) do { \
    PACKED_glFramebufferTextureFaceARB *unpacked = (PACKED_glFramebufferTextureFaceARB *)packed; \
    ARGS_glFramebufferTextureFaceARB *args = (ARGS_glFramebufferTextureFaceARB *)&unpacked->args; \
    glFramebufferTextureFaceARB(args->target, args->attachment, args->texture, args->level, args->face);; \
} while(0)
void glFramebufferTextureFaceARB(glFramebufferTextureFaceARB_ARG_EXPAND);
typedef void (*glFramebufferTextureFaceARB_PTR)(glFramebufferTextureFaceARB_ARG_EXPAND);
#define glFramebufferTextureFaceEXT_INDEX 652
#define glFramebufferTextureFaceEXT_RETURN void
#define glFramebufferTextureFaceEXT_ARG_NAMES target, attachment, texture, level, face
#define glFramebufferTextureFaceEXT_ARG_EXPAND GLenum target, GLenum attachment, GLuint texture, GLint level, GLenum face
#define glFramebufferTextureFaceEXT_PACKED PACKED_glFramebufferTextureFaceEXT
#define glFramebufferTextureFaceEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glFramebufferTextureFaceEXT_NOT_VOID_WRAP(...) {}
#define pack_glFramebufferTextureFaceEXT(_target, _attachment, _texture, _level, _face) ({ \
    glFramebufferTextureFaceEXT_PACKED *packed_data = malloc(sizeof(glFramebufferTextureFaceEXT_PACKED)); \
    packed_data->index = glFramebufferTextureFaceEXT_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.attachment = (GLenum)_attachment; \
    packed_data->args.texture = (GLuint)_texture; \
    packed_data->args.level = (GLint)_level; \
    packed_data->args.face = (GLenum)_face; \
    (packed_call_t *)packed_data; \
})
#define call_glFramebufferTextureFaceEXT(packed, ret_v) do { \
    PACKED_glFramebufferTextureFaceEXT *unpacked = (PACKED_glFramebufferTextureFaceEXT *)packed; \
    ARGS_glFramebufferTextureFaceEXT *args = (ARGS_glFramebufferTextureFaceEXT *)&unpacked->args; \
    glFramebufferTextureFaceEXT(args->target, args->attachment, args->texture, args->level, args->face);; \
} while(0)
void glFramebufferTextureFaceEXT(glFramebufferTextureFaceEXT_ARG_EXPAND);
typedef void (*glFramebufferTextureFaceEXT_PTR)(glFramebufferTextureFaceEXT_ARG_EXPAND);
#define glFramebufferTextureLayer_INDEX 653
#define glFramebufferTextureLayer_RETURN void
#define glFramebufferTextureLayer_ARG_NAMES target, attachment, texture, level, layer
#define glFramebufferTextureLayer_ARG_EXPAND GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer
#define glFramebufferTextureLayer_PACKED PACKED_glFramebufferTextureLayer
#define glFramebufferTextureLayer_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glFramebufferTextureLayer_NOT_VOID_WRAP(...) {}
#define pack_glFramebufferTextureLayer(_target, _attachment, _texture, _level, _layer) ({ \
    glFramebufferTextureLayer_PACKED *packed_data = malloc(sizeof(glFramebufferTextureLayer_PACKED)); \
    packed_data->index = glFramebufferTextureLayer_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.attachment = (GLenum)_attachment; \
    packed_data->args.texture = (GLuint)_texture; \
    packed_data->args.level = (GLint)_level; \
    packed_data->args.layer = (GLint)_layer; \
    (packed_call_t *)packed_data; \
})
#define call_glFramebufferTextureLayer(packed, ret_v) do { \
    PACKED_glFramebufferTextureLayer *unpacked = (PACKED_glFramebufferTextureLayer *)packed; \
    ARGS_glFramebufferTextureLayer *args = (ARGS_glFramebufferTextureLayer *)&unpacked->args; \
    glFramebufferTextureLayer(args->target, args->attachment, args->texture, args->level, args->layer);; \
} while(0)
void glFramebufferTextureLayer(glFramebufferTextureLayer_ARG_EXPAND);
typedef void (*glFramebufferTextureLayer_PTR)(glFramebufferTextureLayer_ARG_EXPAND);
#define glFramebufferTextureLayerARB_INDEX 654
#define glFramebufferTextureLayerARB_RETURN void
#define glFramebufferTextureLayerARB_ARG_NAMES target, attachment, texture, level, layer
#define glFramebufferTextureLayerARB_ARG_EXPAND GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer
#define glFramebufferTextureLayerARB_PACKED PACKED_glFramebufferTextureLayerARB
#define glFramebufferTextureLayerARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glFramebufferTextureLayerARB_NOT_VOID_WRAP(...) {}
#define pack_glFramebufferTextureLayerARB(_target, _attachment, _texture, _level, _layer) ({ \
    glFramebufferTextureLayerARB_PACKED *packed_data = malloc(sizeof(glFramebufferTextureLayerARB_PACKED)); \
    packed_data->index = glFramebufferTextureLayerARB_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.attachment = (GLenum)_attachment; \
    packed_data->args.texture = (GLuint)_texture; \
    packed_data->args.level = (GLint)_level; \
    packed_data->args.layer = (GLint)_layer; \
    (packed_call_t *)packed_data; \
})
#define call_glFramebufferTextureLayerARB(packed, ret_v) do { \
    PACKED_glFramebufferTextureLayerARB *unpacked = (PACKED_glFramebufferTextureLayerARB *)packed; \
    ARGS_glFramebufferTextureLayerARB *args = (ARGS_glFramebufferTextureLayerARB *)&unpacked->args; \
    glFramebufferTextureLayerARB(args->target, args->attachment, args->texture, args->level, args->layer);; \
} while(0)
void glFramebufferTextureLayerARB(glFramebufferTextureLayerARB_ARG_EXPAND);
typedef void (*glFramebufferTextureLayerARB_PTR)(glFramebufferTextureLayerARB_ARG_EXPAND);
#define glFramebufferTextureLayerEXT_INDEX 655
#define glFramebufferTextureLayerEXT_RETURN void
#define glFramebufferTextureLayerEXT_ARG_NAMES target, attachment, texture, level, layer
#define glFramebufferTextureLayerEXT_ARG_EXPAND GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer
#define glFramebufferTextureLayerEXT_PACKED PACKED_glFramebufferTextureLayerEXT
#define glFramebufferTextureLayerEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glFramebufferTextureLayerEXT_NOT_VOID_WRAP(...) {}
#define pack_glFramebufferTextureLayerEXT(_target, _attachment, _texture, _level, _layer) ({ \
    glFramebufferTextureLayerEXT_PACKED *packed_data = malloc(sizeof(glFramebufferTextureLayerEXT_PACKED)); \
    packed_data->index = glFramebufferTextureLayerEXT_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.attachment = (GLenum)_attachment; \
    packed_data->args.texture = (GLuint)_texture; \
    packed_data->args.level = (GLint)_level; \
    packed_data->args.layer = (GLint)_layer; \
    (packed_call_t *)packed_data; \
})
#define call_glFramebufferTextureLayerEXT(packed, ret_v) do { \
    PACKED_glFramebufferTextureLayerEXT *unpacked = (PACKED_glFramebufferTextureLayerEXT *)packed; \
    ARGS_glFramebufferTextureLayerEXT *args = (ARGS_glFramebufferTextureLayerEXT *)&unpacked->args; \
    glFramebufferTextureLayerEXT(args->target, args->attachment, args->texture, args->level, args->layer);; \
} while(0)
void glFramebufferTextureLayerEXT(glFramebufferTextureLayerEXT_ARG_EXPAND);
typedef void (*glFramebufferTextureLayerEXT_PTR)(glFramebufferTextureLayerEXT_ARG_EXPAND);
#define glFreeObjectBufferATI_INDEX 656
#define glFreeObjectBufferATI_RETURN void
#define glFreeObjectBufferATI_ARG_NAMES buffer
#define glFreeObjectBufferATI_ARG_EXPAND GLuint buffer
#define glFreeObjectBufferATI_PACKED PACKED_glFreeObjectBufferATI
#define glFreeObjectBufferATI_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glFreeObjectBufferATI_NOT_VOID_WRAP(...) {}
#define pack_glFreeObjectBufferATI(_buffer) ({ \
    glFreeObjectBufferATI_PACKED *packed_data = malloc(sizeof(glFreeObjectBufferATI_PACKED)); \
    packed_data->index = glFreeObjectBufferATI_INDEX; \
    packed_data->args.buffer = (GLuint)_buffer; \
    (packed_call_t *)packed_data; \
})
#define call_glFreeObjectBufferATI(packed, ret_v) do { \
    PACKED_glFreeObjectBufferATI *unpacked = (PACKED_glFreeObjectBufferATI *)packed; \
    ARGS_glFreeObjectBufferATI *args = (ARGS_glFreeObjectBufferATI *)&unpacked->args; \
    glFreeObjectBufferATI(args->buffer);; \
} while(0)
void glFreeObjectBufferATI(glFreeObjectBufferATI_ARG_EXPAND);
typedef void (*glFreeObjectBufferATI_PTR)(glFreeObjectBufferATI_ARG_EXPAND);
#define glFrontFace_INDEX 657
#define glFrontFace_RETURN void
#define glFrontFace_ARG_NAMES mode
#define glFrontFace_ARG_EXPAND GLenum mode
#define glFrontFace_PACKED PACKED_glFrontFace
#define glFrontFace_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glFrontFace_NOT_VOID_WRAP(...) {}
#define pack_glFrontFace(_mode) ({ \
    glFrontFace_PACKED *packed_data = malloc(sizeof(glFrontFace_PACKED)); \
    packed_data->index = glFrontFace_INDEX; \
    packed_data->args.mode = (GLenum)_mode; \
    (packed_call_t *)packed_data; \
})
#define call_glFrontFace(packed, ret_v) do { \
    PACKED_glFrontFace *unpacked = (PACKED_glFrontFace *)packed; \
    ARGS_glFrontFace *args = (ARGS_glFrontFace *)&unpacked->args; \
    glFrontFace(args->mode);; \
} while(0)
void glFrontFace(glFrontFace_ARG_EXPAND);
typedef void (*glFrontFace_PTR)(glFrontFace_ARG_EXPAND);
#define glFrustum_INDEX 658
#define glFrustum_RETURN void
#define glFrustum_ARG_NAMES left, right, bottom, top, zNear, zFar
#define glFrustum_ARG_EXPAND GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar
#define glFrustum_PACKED PACKED_glFrustum
#define glFrustum_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glFrustum_NOT_VOID_WRAP(...) {}
#define pack_glFrustum(_left, _right, _bottom, _top, _zNear, _zFar) ({ \
    glFrustum_PACKED *packed_data = malloc(sizeof(glFrustum_PACKED)); \
    packed_data->index = glFrustum_INDEX; \
    packed_data->args.left = (GLdouble)_left; \
    packed_data->args.right = (GLdouble)_right; \
    packed_data->args.bottom = (GLdouble)_bottom; \
    packed_data->args.top = (GLdouble)_top; \
    packed_data->args.zNear = (GLdouble)_zNear; \
    packed_data->args.zFar = (GLdouble)_zFar; \
    (packed_call_t *)packed_data; \
})
#define call_glFrustum(packed, ret_v) do { \
    PACKED_glFrustum *unpacked = (PACKED_glFrustum *)packed; \
    ARGS_glFrustum *args = (ARGS_glFrustum *)&unpacked->args; \
    glFrustum(args->left, args->right, args->bottom, args->top, args->zNear, args->zFar);; \
} while(0)
void glFrustum(glFrustum_ARG_EXPAND);
typedef void (*glFrustum_PTR)(glFrustum_ARG_EXPAND);
#define glFrustumf_INDEX 659
#define glFrustumf_RETURN void
#define glFrustumf_ARG_NAMES left, right, bottom, top, near, far
#define glFrustumf_ARG_EXPAND GLfloat left, GLfloat right, GLfloat bottom, GLfloat top, GLfloat near, GLfloat far
#define glFrustumf_PACKED PACKED_glFrustumf
#define glFrustumf_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glFrustumf_NOT_VOID_WRAP(...) {}
#define pack_glFrustumf(_left, _right, _bottom, _top, _near, _far) ({ \
    glFrustumf_PACKED *packed_data = malloc(sizeof(glFrustumf_PACKED)); \
    packed_data->index = glFrustumf_INDEX; \
    packed_data->args.left = (GLfloat)_left; \
    packed_data->args.right = (GLfloat)_right; \
    packed_data->args.bottom = (GLfloat)_bottom; \
    packed_data->args.top = (GLfloat)_top; \
    packed_data->args.near = (GLfloat)_near; \
    packed_data->args.far = (GLfloat)_far; \
    (packed_call_t *)packed_data; \
})
#define call_glFrustumf(packed, ret_v) do { \
    PACKED_glFrustumf *unpacked = (PACKED_glFrustumf *)packed; \
    ARGS_glFrustumf *args = (ARGS_glFrustumf *)&unpacked->args; \
    glFrustumf(args->left, args->right, args->bottom, args->top, args->near, args->far);; \
} while(0)
void glFrustumf(glFrustumf_ARG_EXPAND);
typedef void (*glFrustumf_PTR)(glFrustumf_ARG_EXPAND);
#define glFrustumfOES_INDEX 660
#define glFrustumfOES_RETURN void
#define glFrustumfOES_ARG_NAMES l, r, b, t, n, f
#define glFrustumfOES_ARG_EXPAND GLfloat l, GLfloat r, GLfloat b, GLfloat t, GLfloat n, GLfloat f
#define glFrustumfOES_PACKED PACKED_glFrustumfOES
#define glFrustumfOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glFrustumfOES_NOT_VOID_WRAP(...) {}
#define pack_glFrustumfOES(_l, _r, _b, _t, _n, _f) ({ \
    glFrustumfOES_PACKED *packed_data = malloc(sizeof(glFrustumfOES_PACKED)); \
    packed_data->index = glFrustumfOES_INDEX; \
    packed_data->args.l = (GLfloat)_l; \
    packed_data->args.r = (GLfloat)_r; \
    packed_data->args.b = (GLfloat)_b; \
    packed_data->args.t = (GLfloat)_t; \
    packed_data->args.n = (GLfloat)_n; \
    packed_data->args.f = (GLfloat)_f; \
    (packed_call_t *)packed_data; \
})
#define call_glFrustumfOES(packed, ret_v) do { \
    PACKED_glFrustumfOES *unpacked = (PACKED_glFrustumfOES *)packed; \
    ARGS_glFrustumfOES *args = (ARGS_glFrustumfOES *)&unpacked->args; \
    glFrustumfOES(args->l, args->r, args->b, args->t, args->n, args->f);; \
} while(0)
void glFrustumfOES(glFrustumfOES_ARG_EXPAND);
typedef void (*glFrustumfOES_PTR)(glFrustumfOES_ARG_EXPAND);
#define glFrustumx_INDEX 661
#define glFrustumx_RETURN void
#define glFrustumx_ARG_NAMES left, right, bottom, top, near, far
#define glFrustumx_ARG_EXPAND GLfixed left, GLfixed right, GLfixed bottom, GLfixed top, GLfixed near, GLfixed far
#define glFrustumx_PACKED PACKED_glFrustumx
#define glFrustumx_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glFrustumx_NOT_VOID_WRAP(...) {}
#define pack_glFrustumx(_left, _right, _bottom, _top, _near, _far) ({ \
    glFrustumx_PACKED *packed_data = malloc(sizeof(glFrustumx_PACKED)); \
    packed_data->index = glFrustumx_INDEX; \
    packed_data->args.left = (GLfixed)_left; \
    packed_data->args.right = (GLfixed)_right; \
    packed_data->args.bottom = (GLfixed)_bottom; \
    packed_data->args.top = (GLfixed)_top; \
    packed_data->args.near = (GLfixed)_near; \
    packed_data->args.far = (GLfixed)_far; \
    (packed_call_t *)packed_data; \
})
#define call_glFrustumx(packed, ret_v) do { \
    PACKED_glFrustumx *unpacked = (PACKED_glFrustumx *)packed; \
    ARGS_glFrustumx *args = (ARGS_glFrustumx *)&unpacked->args; \
    glFrustumx(args->left, args->right, args->bottom, args->top, args->near, args->far);; \
} while(0)
void glFrustumx(glFrustumx_ARG_EXPAND);
typedef void (*glFrustumx_PTR)(glFrustumx_ARG_EXPAND);
#define glFrustumxOES_INDEX 662
#define glFrustumxOES_RETURN void
#define glFrustumxOES_ARG_NAMES l, r, b, t, n, f
#define glFrustumxOES_ARG_EXPAND GLfixed l, GLfixed r, GLfixed b, GLfixed t, GLfixed n, GLfixed f
#define glFrustumxOES_PACKED PACKED_glFrustumxOES
#define glFrustumxOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glFrustumxOES_NOT_VOID_WRAP(...) {}
#define pack_glFrustumxOES(_l, _r, _b, _t, _n, _f) ({ \
    glFrustumxOES_PACKED *packed_data = malloc(sizeof(glFrustumxOES_PACKED)); \
    packed_data->index = glFrustumxOES_INDEX; \
    packed_data->args.l = (GLfixed)_l; \
    packed_data->args.r = (GLfixed)_r; \
    packed_data->args.b = (GLfixed)_b; \
    packed_data->args.t = (GLfixed)_t; \
    packed_data->args.n = (GLfixed)_n; \
    packed_data->args.f = (GLfixed)_f; \
    (packed_call_t *)packed_data; \
})
#define call_glFrustumxOES(packed, ret_v) do { \
    PACKED_glFrustumxOES *unpacked = (PACKED_glFrustumxOES *)packed; \
    ARGS_glFrustumxOES *args = (ARGS_glFrustumxOES *)&unpacked->args; \
    glFrustumxOES(args->l, args->r, args->b, args->t, args->n, args->f);; \
} while(0)
void glFrustumxOES(glFrustumxOES_ARG_EXPAND);
typedef void (*glFrustumxOES_PTR)(glFrustumxOES_ARG_EXPAND);
#define glGenAsyncMarkersSGIX_INDEX 663
#define glGenAsyncMarkersSGIX_RETURN GLuint
#define glGenAsyncMarkersSGIX_ARG_NAMES range
#define glGenAsyncMarkersSGIX_ARG_EXPAND GLsizei range
#define glGenAsyncMarkersSGIX_PACKED PACKED_glGenAsyncMarkersSGIX
#define glGenAsyncMarkersSGIX_VOID_ONLY_WRAP(...) {}
#define glGenAsyncMarkersSGIX_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glGenAsyncMarkersSGIX(_range) ({ \
    glGenAsyncMarkersSGIX_PACKED *packed_data = malloc(sizeof(glGenAsyncMarkersSGIX_PACKED)); \
    packed_data->index = glGenAsyncMarkersSGIX_INDEX; \
    packed_data->args.range = (GLsizei)_range; \
    (packed_call_t *)packed_data; \
})
#define call_glGenAsyncMarkersSGIX(packed, ret_v) do { \
    PACKED_glGenAsyncMarkersSGIX *unpacked = (PACKED_glGenAsyncMarkersSGIX *)packed; \
    ARGS_glGenAsyncMarkersSGIX *args = (ARGS_glGenAsyncMarkersSGIX *)&unpacked->args; \
    GLuint *ret = (GLuint *)ret_v; \
    if (ret != NULL) { \
        *ret = glGenAsyncMarkersSGIX(args->range);; \
    } else { \
        glGenAsyncMarkersSGIX(args->range);; \
    } \
} while(0)
GLuint glGenAsyncMarkersSGIX(glGenAsyncMarkersSGIX_ARG_EXPAND);
typedef GLuint (*glGenAsyncMarkersSGIX_PTR)(glGenAsyncMarkersSGIX_ARG_EXPAND);
#define glGenBuffers_INDEX 664
#define glGenBuffers_RETURN void
#define glGenBuffers_ARG_NAMES n, buffers
#define glGenBuffers_ARG_EXPAND GLsizei n, GLuint * buffers
#define glGenBuffers_PACKED PACKED_glGenBuffers
#define glGenBuffers_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGenBuffers_NOT_VOID_WRAP(...) {}
#define pack_glGenBuffers(_n, _buffers) ({ \
    glGenBuffers_PACKED *packed_data = malloc(sizeof(glGenBuffers_PACKED)); \
    packed_data->index = glGenBuffers_INDEX; \
    packed_data->args.n = (GLsizei)_n; \
    packed_data->args.buffers = (GLuint *)_buffers; \
    (packed_call_t *)packed_data; \
})
#define call_glGenBuffers(packed, ret_v) do { \
    PACKED_glGenBuffers *unpacked = (PACKED_glGenBuffers *)packed; \
    ARGS_glGenBuffers *args = (ARGS_glGenBuffers *)&unpacked->args; \
    glGenBuffers(args->n, args->buffers);; \
} while(0)
void glGenBuffers(glGenBuffers_ARG_EXPAND);
typedef void (*glGenBuffers_PTR)(glGenBuffers_ARG_EXPAND);
#define glGenBuffersARB_INDEX 665
#define glGenBuffersARB_RETURN void
#define glGenBuffersARB_ARG_NAMES n, buffers
#define glGenBuffersARB_ARG_EXPAND GLsizei n, GLuint * buffers
#define glGenBuffersARB_PACKED PACKED_glGenBuffersARB
#define glGenBuffersARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGenBuffersARB_NOT_VOID_WRAP(...) {}
#define pack_glGenBuffersARB(_n, _buffers) ({ \
    glGenBuffersARB_PACKED *packed_data = malloc(sizeof(glGenBuffersARB_PACKED)); \
    packed_data->index = glGenBuffersARB_INDEX; \
    packed_data->args.n = (GLsizei)_n; \
    packed_data->args.buffers = (GLuint *)_buffers; \
    (packed_call_t *)packed_data; \
})
#define call_glGenBuffersARB(packed, ret_v) do { \
    PACKED_glGenBuffersARB *unpacked = (PACKED_glGenBuffersARB *)packed; \
    ARGS_glGenBuffersARB *args = (ARGS_glGenBuffersARB *)&unpacked->args; \
    glGenBuffersARB(args->n, args->buffers);; \
} while(0)
void glGenBuffersARB(glGenBuffersARB_ARG_EXPAND);
typedef void (*glGenBuffersARB_PTR)(glGenBuffersARB_ARG_EXPAND);
#define glGenFencesAPPLE_INDEX 666
#define glGenFencesAPPLE_RETURN void
#define glGenFencesAPPLE_ARG_NAMES n, fences
#define glGenFencesAPPLE_ARG_EXPAND GLsizei n, GLuint * fences
#define glGenFencesAPPLE_PACKED PACKED_glGenFencesAPPLE
#define glGenFencesAPPLE_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGenFencesAPPLE_NOT_VOID_WRAP(...) {}
#define pack_glGenFencesAPPLE(_n, _fences) ({ \
    glGenFencesAPPLE_PACKED *packed_data = malloc(sizeof(glGenFencesAPPLE_PACKED)); \
    packed_data->index = glGenFencesAPPLE_INDEX; \
    packed_data->args.n = (GLsizei)_n; \
    packed_data->args.fences = (GLuint *)_fences; \
    (packed_call_t *)packed_data; \
})
#define call_glGenFencesAPPLE(packed, ret_v) do { \
    PACKED_glGenFencesAPPLE *unpacked = (PACKED_glGenFencesAPPLE *)packed; \
    ARGS_glGenFencesAPPLE *args = (ARGS_glGenFencesAPPLE *)&unpacked->args; \
    glGenFencesAPPLE(args->n, args->fences);; \
} while(0)
void glGenFencesAPPLE(glGenFencesAPPLE_ARG_EXPAND);
typedef void (*glGenFencesAPPLE_PTR)(glGenFencesAPPLE_ARG_EXPAND);
#define glGenFencesNV_INDEX 667
#define glGenFencesNV_RETURN void
#define glGenFencesNV_ARG_NAMES n, fences
#define glGenFencesNV_ARG_EXPAND GLsizei n, GLuint * fences
#define glGenFencesNV_PACKED PACKED_glGenFencesNV
#define glGenFencesNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGenFencesNV_NOT_VOID_WRAP(...) {}
#define pack_glGenFencesNV(_n, _fences) ({ \
    glGenFencesNV_PACKED *packed_data = malloc(sizeof(glGenFencesNV_PACKED)); \
    packed_data->index = glGenFencesNV_INDEX; \
    packed_data->args.n = (GLsizei)_n; \
    packed_data->args.fences = (GLuint *)_fences; \
    (packed_call_t *)packed_data; \
})
#define call_glGenFencesNV(packed, ret_v) do { \
    PACKED_glGenFencesNV *unpacked = (PACKED_glGenFencesNV *)packed; \
    ARGS_glGenFencesNV *args = (ARGS_glGenFencesNV *)&unpacked->args; \
    glGenFencesNV(args->n, args->fences);; \
} while(0)
void glGenFencesNV(glGenFencesNV_ARG_EXPAND);
typedef void (*glGenFencesNV_PTR)(glGenFencesNV_ARG_EXPAND);
#define glGenFragmentShadersATI_INDEX 668
#define glGenFragmentShadersATI_RETURN GLuint
#define glGenFragmentShadersATI_ARG_NAMES range
#define glGenFragmentShadersATI_ARG_EXPAND GLuint range
#define glGenFragmentShadersATI_PACKED PACKED_glGenFragmentShadersATI
#define glGenFragmentShadersATI_VOID_ONLY_WRAP(...) {}
#define glGenFragmentShadersATI_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glGenFragmentShadersATI(_range) ({ \
    glGenFragmentShadersATI_PACKED *packed_data = malloc(sizeof(glGenFragmentShadersATI_PACKED)); \
    packed_data->index = glGenFragmentShadersATI_INDEX; \
    packed_data->args.range = (GLuint)_range; \
    (packed_call_t *)packed_data; \
})
#define call_glGenFragmentShadersATI(packed, ret_v) do { \
    PACKED_glGenFragmentShadersATI *unpacked = (PACKED_glGenFragmentShadersATI *)packed; \
    ARGS_glGenFragmentShadersATI *args = (ARGS_glGenFragmentShadersATI *)&unpacked->args; \
    GLuint *ret = (GLuint *)ret_v; \
    if (ret != NULL) { \
        *ret = glGenFragmentShadersATI(args->range);; \
    } else { \
        glGenFragmentShadersATI(args->range);; \
    } \
} while(0)
GLuint glGenFragmentShadersATI(glGenFragmentShadersATI_ARG_EXPAND);
typedef GLuint (*glGenFragmentShadersATI_PTR)(glGenFragmentShadersATI_ARG_EXPAND);
#define glGenFramebuffers_INDEX 669
#define glGenFramebuffers_RETURN void
#define glGenFramebuffers_ARG_NAMES n, framebuffers
#define glGenFramebuffers_ARG_EXPAND GLsizei n, GLuint * framebuffers
#define glGenFramebuffers_PACKED PACKED_glGenFramebuffers
#define glGenFramebuffers_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGenFramebuffers_NOT_VOID_WRAP(...) {}
#define pack_glGenFramebuffers(_n, _framebuffers) ({ \
    glGenFramebuffers_PACKED *packed_data = malloc(sizeof(glGenFramebuffers_PACKED)); \
    packed_data->index = glGenFramebuffers_INDEX; \
    packed_data->args.n = (GLsizei)_n; \
    packed_data->args.framebuffers = (GLuint *)_framebuffers; \
    (packed_call_t *)packed_data; \
})
#define call_glGenFramebuffers(packed, ret_v) do { \
    PACKED_glGenFramebuffers *unpacked = (PACKED_glGenFramebuffers *)packed; \
    ARGS_glGenFramebuffers *args = (ARGS_glGenFramebuffers *)&unpacked->args; \
    glGenFramebuffers(args->n, args->framebuffers);; \
} while(0)
void glGenFramebuffers(glGenFramebuffers_ARG_EXPAND);
typedef void (*glGenFramebuffers_PTR)(glGenFramebuffers_ARG_EXPAND);
#define glGenFramebuffersEXT_INDEX 670
#define glGenFramebuffersEXT_RETURN void
#define glGenFramebuffersEXT_ARG_NAMES n, framebuffers
#define glGenFramebuffersEXT_ARG_EXPAND GLsizei n, GLuint * framebuffers
#define glGenFramebuffersEXT_PACKED PACKED_glGenFramebuffersEXT
#define glGenFramebuffersEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGenFramebuffersEXT_NOT_VOID_WRAP(...) {}
#define pack_glGenFramebuffersEXT(_n, _framebuffers) ({ \
    glGenFramebuffersEXT_PACKED *packed_data = malloc(sizeof(glGenFramebuffersEXT_PACKED)); \
    packed_data->index = glGenFramebuffersEXT_INDEX; \
    packed_data->args.n = (GLsizei)_n; \
    packed_data->args.framebuffers = (GLuint *)_framebuffers; \
    (packed_call_t *)packed_data; \
})
#define call_glGenFramebuffersEXT(packed, ret_v) do { \
    PACKED_glGenFramebuffersEXT *unpacked = (PACKED_glGenFramebuffersEXT *)packed; \
    ARGS_glGenFramebuffersEXT *args = (ARGS_glGenFramebuffersEXT *)&unpacked->args; \
    glGenFramebuffersEXT(args->n, args->framebuffers);; \
} while(0)
void glGenFramebuffersEXT(glGenFramebuffersEXT_ARG_EXPAND);
typedef void (*glGenFramebuffersEXT_PTR)(glGenFramebuffersEXT_ARG_EXPAND);
#define glGenLists_INDEX 671
#define glGenLists_RETURN GLuint
#define glGenLists_ARG_NAMES range
#define glGenLists_ARG_EXPAND GLsizei range
#define glGenLists_PACKED PACKED_glGenLists
#define glGenLists_VOID_ONLY_WRAP(...) {}
#define glGenLists_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glGenLists(_range) ({ \
    glGenLists_PACKED *packed_data = malloc(sizeof(glGenLists_PACKED)); \
    packed_data->index = glGenLists_INDEX; \
    packed_data->args.range = (GLsizei)_range; \
    (packed_call_t *)packed_data; \
})
#define call_glGenLists(packed, ret_v) do { \
    PACKED_glGenLists *unpacked = (PACKED_glGenLists *)packed; \
    ARGS_glGenLists *args = (ARGS_glGenLists *)&unpacked->args; \
    GLuint *ret = (GLuint *)ret_v; \
    if (ret != NULL) { \
        *ret = glGenLists(args->range);; \
    } else { \
        glGenLists(args->range);; \
    } \
} while(0)
GLuint glGenLists(glGenLists_ARG_EXPAND);
typedef GLuint (*glGenLists_PTR)(glGenLists_ARG_EXPAND);
#define glGenNamesAMD_INDEX 672
#define glGenNamesAMD_RETURN void
#define glGenNamesAMD_ARG_NAMES identifier, num, names
#define glGenNamesAMD_ARG_EXPAND GLenum identifier, GLuint num, GLuint * names
#define glGenNamesAMD_PACKED PACKED_glGenNamesAMD
#define glGenNamesAMD_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGenNamesAMD_NOT_VOID_WRAP(...) {}
#define pack_glGenNamesAMD(_identifier, _num, _names) ({ \
    glGenNamesAMD_PACKED *packed_data = malloc(sizeof(glGenNamesAMD_PACKED)); \
    packed_data->index = glGenNamesAMD_INDEX; \
    packed_data->args.identifier = (GLenum)_identifier; \
    packed_data->args.num = (GLuint)_num; \
    packed_data->args.names = (GLuint *)_names; \
    (packed_call_t *)packed_data; \
})
#define call_glGenNamesAMD(packed, ret_v) do { \
    PACKED_glGenNamesAMD *unpacked = (PACKED_glGenNamesAMD *)packed; \
    ARGS_glGenNamesAMD *args = (ARGS_glGenNamesAMD *)&unpacked->args; \
    glGenNamesAMD(args->identifier, args->num, args->names);; \
} while(0)
void glGenNamesAMD(glGenNamesAMD_ARG_EXPAND);
typedef void (*glGenNamesAMD_PTR)(glGenNamesAMD_ARG_EXPAND);
#define glGenOcclusionQueriesNV_INDEX 673
#define glGenOcclusionQueriesNV_RETURN void
#define glGenOcclusionQueriesNV_ARG_NAMES n, ids
#define glGenOcclusionQueriesNV_ARG_EXPAND GLsizei n, GLuint * ids
#define glGenOcclusionQueriesNV_PACKED PACKED_glGenOcclusionQueriesNV
#define glGenOcclusionQueriesNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGenOcclusionQueriesNV_NOT_VOID_WRAP(...) {}
#define pack_glGenOcclusionQueriesNV(_n, _ids) ({ \
    glGenOcclusionQueriesNV_PACKED *packed_data = malloc(sizeof(glGenOcclusionQueriesNV_PACKED)); \
    packed_data->index = glGenOcclusionQueriesNV_INDEX; \
    packed_data->args.n = (GLsizei)_n; \
    packed_data->args.ids = (GLuint *)_ids; \
    (packed_call_t *)packed_data; \
})
#define call_glGenOcclusionQueriesNV(packed, ret_v) do { \
    PACKED_glGenOcclusionQueriesNV *unpacked = (PACKED_glGenOcclusionQueriesNV *)packed; \
    ARGS_glGenOcclusionQueriesNV *args = (ARGS_glGenOcclusionQueriesNV *)&unpacked->args; \
    glGenOcclusionQueriesNV(args->n, args->ids);; \
} while(0)
void glGenOcclusionQueriesNV(glGenOcclusionQueriesNV_ARG_EXPAND);
typedef void (*glGenOcclusionQueriesNV_PTR)(glGenOcclusionQueriesNV_ARG_EXPAND);
#define glGenPathsNV_INDEX 674
#define glGenPathsNV_RETURN GLuint
#define glGenPathsNV_ARG_NAMES range
#define glGenPathsNV_ARG_EXPAND GLsizei range
#define glGenPathsNV_PACKED PACKED_glGenPathsNV
#define glGenPathsNV_VOID_ONLY_WRAP(...) {}
#define glGenPathsNV_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glGenPathsNV(_range) ({ \
    glGenPathsNV_PACKED *packed_data = malloc(sizeof(glGenPathsNV_PACKED)); \
    packed_data->index = glGenPathsNV_INDEX; \
    packed_data->args.range = (GLsizei)_range; \
    (packed_call_t *)packed_data; \
})
#define call_glGenPathsNV(packed, ret_v) do { \
    PACKED_glGenPathsNV *unpacked = (PACKED_glGenPathsNV *)packed; \
    ARGS_glGenPathsNV *args = (ARGS_glGenPathsNV *)&unpacked->args; \
    GLuint *ret = (GLuint *)ret_v; \
    if (ret != NULL) { \
        *ret = glGenPathsNV(args->range);; \
    } else { \
        glGenPathsNV(args->range);; \
    } \
} while(0)
GLuint glGenPathsNV(glGenPathsNV_ARG_EXPAND);
typedef GLuint (*glGenPathsNV_PTR)(glGenPathsNV_ARG_EXPAND);
#define glGenPerfMonitorsAMD_INDEX 675
#define glGenPerfMonitorsAMD_RETURN void
#define glGenPerfMonitorsAMD_ARG_NAMES n, monitors
#define glGenPerfMonitorsAMD_ARG_EXPAND GLsizei n, GLuint * monitors
#define glGenPerfMonitorsAMD_PACKED PACKED_glGenPerfMonitorsAMD
#define glGenPerfMonitorsAMD_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGenPerfMonitorsAMD_NOT_VOID_WRAP(...) {}
#define pack_glGenPerfMonitorsAMD(_n, _monitors) ({ \
    glGenPerfMonitorsAMD_PACKED *packed_data = malloc(sizeof(glGenPerfMonitorsAMD_PACKED)); \
    packed_data->index = glGenPerfMonitorsAMD_INDEX; \
    packed_data->args.n = (GLsizei)_n; \
    packed_data->args.monitors = (GLuint *)_monitors; \
    (packed_call_t *)packed_data; \
})
#define call_glGenPerfMonitorsAMD(packed, ret_v) do { \
    PACKED_glGenPerfMonitorsAMD *unpacked = (PACKED_glGenPerfMonitorsAMD *)packed; \
    ARGS_glGenPerfMonitorsAMD *args = (ARGS_glGenPerfMonitorsAMD *)&unpacked->args; \
    glGenPerfMonitorsAMD(args->n, args->monitors);; \
} while(0)
void glGenPerfMonitorsAMD(glGenPerfMonitorsAMD_ARG_EXPAND);
typedef void (*glGenPerfMonitorsAMD_PTR)(glGenPerfMonitorsAMD_ARG_EXPAND);
#define glGenProgramPipelines_INDEX 676
#define glGenProgramPipelines_RETURN void
#define glGenProgramPipelines_ARG_NAMES n, pipelines
#define glGenProgramPipelines_ARG_EXPAND GLsizei n, GLuint * pipelines
#define glGenProgramPipelines_PACKED PACKED_glGenProgramPipelines
#define glGenProgramPipelines_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGenProgramPipelines_NOT_VOID_WRAP(...) {}
#define pack_glGenProgramPipelines(_n, _pipelines) ({ \
    glGenProgramPipelines_PACKED *packed_data = malloc(sizeof(glGenProgramPipelines_PACKED)); \
    packed_data->index = glGenProgramPipelines_INDEX; \
    packed_data->args.n = (GLsizei)_n; \
    packed_data->args.pipelines = (GLuint *)_pipelines; \
    (packed_call_t *)packed_data; \
})
#define call_glGenProgramPipelines(packed, ret_v) do { \
    PACKED_glGenProgramPipelines *unpacked = (PACKED_glGenProgramPipelines *)packed; \
    ARGS_glGenProgramPipelines *args = (ARGS_glGenProgramPipelines *)&unpacked->args; \
    glGenProgramPipelines(args->n, args->pipelines);; \
} while(0)
void glGenProgramPipelines(glGenProgramPipelines_ARG_EXPAND);
typedef void (*glGenProgramPipelines_PTR)(glGenProgramPipelines_ARG_EXPAND);
#define glGenProgramsARB_INDEX 677
#define glGenProgramsARB_RETURN void
#define glGenProgramsARB_ARG_NAMES n, programs
#define glGenProgramsARB_ARG_EXPAND GLsizei n, GLuint * programs
#define glGenProgramsARB_PACKED PACKED_glGenProgramsARB
#define glGenProgramsARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGenProgramsARB_NOT_VOID_WRAP(...) {}
#define pack_glGenProgramsARB(_n, _programs) ({ \
    glGenProgramsARB_PACKED *packed_data = malloc(sizeof(glGenProgramsARB_PACKED)); \
    packed_data->index = glGenProgramsARB_INDEX; \
    packed_data->args.n = (GLsizei)_n; \
    packed_data->args.programs = (GLuint *)_programs; \
    (packed_call_t *)packed_data; \
})
#define call_glGenProgramsARB(packed, ret_v) do { \
    PACKED_glGenProgramsARB *unpacked = (PACKED_glGenProgramsARB *)packed; \
    ARGS_glGenProgramsARB *args = (ARGS_glGenProgramsARB *)&unpacked->args; \
    glGenProgramsARB(args->n, args->programs);; \
} while(0)
void glGenProgramsARB(glGenProgramsARB_ARG_EXPAND);
typedef void (*glGenProgramsARB_PTR)(glGenProgramsARB_ARG_EXPAND);
#define glGenProgramsNV_INDEX 678
#define glGenProgramsNV_RETURN void
#define glGenProgramsNV_ARG_NAMES n, programs
#define glGenProgramsNV_ARG_EXPAND GLsizei n, GLuint * programs
#define glGenProgramsNV_PACKED PACKED_glGenProgramsNV
#define glGenProgramsNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGenProgramsNV_NOT_VOID_WRAP(...) {}
#define pack_glGenProgramsNV(_n, _programs) ({ \
    glGenProgramsNV_PACKED *packed_data = malloc(sizeof(glGenProgramsNV_PACKED)); \
    packed_data->index = glGenProgramsNV_INDEX; \
    packed_data->args.n = (GLsizei)_n; \
    packed_data->args.programs = (GLuint *)_programs; \
    (packed_call_t *)packed_data; \
})
#define call_glGenProgramsNV(packed, ret_v) do { \
    PACKED_glGenProgramsNV *unpacked = (PACKED_glGenProgramsNV *)packed; \
    ARGS_glGenProgramsNV *args = (ARGS_glGenProgramsNV *)&unpacked->args; \
    glGenProgramsNV(args->n, args->programs);; \
} while(0)
void glGenProgramsNV(glGenProgramsNV_ARG_EXPAND);
typedef void (*glGenProgramsNV_PTR)(glGenProgramsNV_ARG_EXPAND);
#define glGenQueries_INDEX 679
#define glGenQueries_RETURN void
#define glGenQueries_ARG_NAMES n, ids
#define glGenQueries_ARG_EXPAND GLsizei n, GLuint * ids
#define glGenQueries_PACKED PACKED_glGenQueries
#define glGenQueries_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGenQueries_NOT_VOID_WRAP(...) {}
#define pack_glGenQueries(_n, _ids) ({ \
    glGenQueries_PACKED *packed_data = malloc(sizeof(glGenQueries_PACKED)); \
    packed_data->index = glGenQueries_INDEX; \
    packed_data->args.n = (GLsizei)_n; \
    packed_data->args.ids = (GLuint *)_ids; \
    (packed_call_t *)packed_data; \
})
#define call_glGenQueries(packed, ret_v) do { \
    PACKED_glGenQueries *unpacked = (PACKED_glGenQueries *)packed; \
    ARGS_glGenQueries *args = (ARGS_glGenQueries *)&unpacked->args; \
    glGenQueries(args->n, args->ids);; \
} while(0)
void glGenQueries(glGenQueries_ARG_EXPAND);
typedef void (*glGenQueries_PTR)(glGenQueries_ARG_EXPAND);
#define glGenQueriesARB_INDEX 680
#define glGenQueriesARB_RETURN void
#define glGenQueriesARB_ARG_NAMES n, ids
#define glGenQueriesARB_ARG_EXPAND GLsizei n, GLuint * ids
#define glGenQueriesARB_PACKED PACKED_glGenQueriesARB
#define glGenQueriesARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGenQueriesARB_NOT_VOID_WRAP(...) {}
#define pack_glGenQueriesARB(_n, _ids) ({ \
    glGenQueriesARB_PACKED *packed_data = malloc(sizeof(glGenQueriesARB_PACKED)); \
    packed_data->index = glGenQueriesARB_INDEX; \
    packed_data->args.n = (GLsizei)_n; \
    packed_data->args.ids = (GLuint *)_ids; \
    (packed_call_t *)packed_data; \
})
#define call_glGenQueriesARB(packed, ret_v) do { \
    PACKED_glGenQueriesARB *unpacked = (PACKED_glGenQueriesARB *)packed; \
    ARGS_glGenQueriesARB *args = (ARGS_glGenQueriesARB *)&unpacked->args; \
    glGenQueriesARB(args->n, args->ids);; \
} while(0)
void glGenQueriesARB(glGenQueriesARB_ARG_EXPAND);
typedef void (*glGenQueriesARB_PTR)(glGenQueriesARB_ARG_EXPAND);
#define glGenRenderbuffers_INDEX 681
#define glGenRenderbuffers_RETURN void
#define glGenRenderbuffers_ARG_NAMES n, renderbuffers
#define glGenRenderbuffers_ARG_EXPAND GLsizei n, GLuint * renderbuffers
#define glGenRenderbuffers_PACKED PACKED_glGenRenderbuffers
#define glGenRenderbuffers_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGenRenderbuffers_NOT_VOID_WRAP(...) {}
#define pack_glGenRenderbuffers(_n, _renderbuffers) ({ \
    glGenRenderbuffers_PACKED *packed_data = malloc(sizeof(glGenRenderbuffers_PACKED)); \
    packed_data->index = glGenRenderbuffers_INDEX; \
    packed_data->args.n = (GLsizei)_n; \
    packed_data->args.renderbuffers = (GLuint *)_renderbuffers; \
    (packed_call_t *)packed_data; \
})
#define call_glGenRenderbuffers(packed, ret_v) do { \
    PACKED_glGenRenderbuffers *unpacked = (PACKED_glGenRenderbuffers *)packed; \
    ARGS_glGenRenderbuffers *args = (ARGS_glGenRenderbuffers *)&unpacked->args; \
    glGenRenderbuffers(args->n, args->renderbuffers);; \
} while(0)
void glGenRenderbuffers(glGenRenderbuffers_ARG_EXPAND);
typedef void (*glGenRenderbuffers_PTR)(glGenRenderbuffers_ARG_EXPAND);
#define glGenRenderbuffersEXT_INDEX 682
#define glGenRenderbuffersEXT_RETURN void
#define glGenRenderbuffersEXT_ARG_NAMES n, renderbuffers
#define glGenRenderbuffersEXT_ARG_EXPAND GLsizei n, GLuint * renderbuffers
#define glGenRenderbuffersEXT_PACKED PACKED_glGenRenderbuffersEXT
#define glGenRenderbuffersEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGenRenderbuffersEXT_NOT_VOID_WRAP(...) {}
#define pack_glGenRenderbuffersEXT(_n, _renderbuffers) ({ \
    glGenRenderbuffersEXT_PACKED *packed_data = malloc(sizeof(glGenRenderbuffersEXT_PACKED)); \
    packed_data->index = glGenRenderbuffersEXT_INDEX; \
    packed_data->args.n = (GLsizei)_n; \
    packed_data->args.renderbuffers = (GLuint *)_renderbuffers; \
    (packed_call_t *)packed_data; \
})
#define call_glGenRenderbuffersEXT(packed, ret_v) do { \
    PACKED_glGenRenderbuffersEXT *unpacked = (PACKED_glGenRenderbuffersEXT *)packed; \
    ARGS_glGenRenderbuffersEXT *args = (ARGS_glGenRenderbuffersEXT *)&unpacked->args; \
    glGenRenderbuffersEXT(args->n, args->renderbuffers);; \
} while(0)
void glGenRenderbuffersEXT(glGenRenderbuffersEXT_ARG_EXPAND);
typedef void (*glGenRenderbuffersEXT_PTR)(glGenRenderbuffersEXT_ARG_EXPAND);
#define glGenSamplers_INDEX 683
#define glGenSamplers_RETURN void
#define glGenSamplers_ARG_NAMES count, samplers
#define glGenSamplers_ARG_EXPAND GLsizei count, GLuint * samplers
#define glGenSamplers_PACKED PACKED_glGenSamplers
#define glGenSamplers_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGenSamplers_NOT_VOID_WRAP(...) {}
#define pack_glGenSamplers(_count, _samplers) ({ \
    glGenSamplers_PACKED *packed_data = malloc(sizeof(glGenSamplers_PACKED)); \
    packed_data->index = glGenSamplers_INDEX; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.samplers = (GLuint *)_samplers; \
    (packed_call_t *)packed_data; \
})
#define call_glGenSamplers(packed, ret_v) do { \
    PACKED_glGenSamplers *unpacked = (PACKED_glGenSamplers *)packed; \
    ARGS_glGenSamplers *args = (ARGS_glGenSamplers *)&unpacked->args; \
    glGenSamplers(args->count, args->samplers);; \
} while(0)
void glGenSamplers(glGenSamplers_ARG_EXPAND);
typedef void (*glGenSamplers_PTR)(glGenSamplers_ARG_EXPAND);
#define glGenSymbolsEXT_INDEX 684
#define glGenSymbolsEXT_RETURN GLuint
#define glGenSymbolsEXT_ARG_NAMES datatype, storagetype, range, components
#define glGenSymbolsEXT_ARG_EXPAND GLenum datatype, GLenum storagetype, GLenum range, GLuint components
#define glGenSymbolsEXT_PACKED PACKED_glGenSymbolsEXT
#define glGenSymbolsEXT_VOID_ONLY_WRAP(...) {}
#define glGenSymbolsEXT_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glGenSymbolsEXT(_datatype, _storagetype, _range, _components) ({ \
    glGenSymbolsEXT_PACKED *packed_data = malloc(sizeof(glGenSymbolsEXT_PACKED)); \
    packed_data->index = glGenSymbolsEXT_INDEX; \
    packed_data->args.datatype = (GLenum)_datatype; \
    packed_data->args.storagetype = (GLenum)_storagetype; \
    packed_data->args.range = (GLenum)_range; \
    packed_data->args.components = (GLuint)_components; \
    (packed_call_t *)packed_data; \
})
#define call_glGenSymbolsEXT(packed, ret_v) do { \
    PACKED_glGenSymbolsEXT *unpacked = (PACKED_glGenSymbolsEXT *)packed; \
    ARGS_glGenSymbolsEXT *args = (ARGS_glGenSymbolsEXT *)&unpacked->args; \
    GLuint *ret = (GLuint *)ret_v; \
    if (ret != NULL) { \
        *ret = glGenSymbolsEXT(args->datatype, args->storagetype, args->range, args->components);; \
    } else { \
        glGenSymbolsEXT(args->datatype, args->storagetype, args->range, args->components);; \
    } \
} while(0)
GLuint glGenSymbolsEXT(glGenSymbolsEXT_ARG_EXPAND);
typedef GLuint (*glGenSymbolsEXT_PTR)(glGenSymbolsEXT_ARG_EXPAND);
#define glGenTextures_INDEX 685
#define glGenTextures_RETURN void
#define glGenTextures_ARG_NAMES n, textures
#define glGenTextures_ARG_EXPAND GLsizei n, GLuint * textures
#define glGenTextures_PACKED PACKED_glGenTextures
#define glGenTextures_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGenTextures_NOT_VOID_WRAP(...) {}
#define pack_glGenTextures(_n, _textures) ({ \
    glGenTextures_PACKED *packed_data = malloc(sizeof(glGenTextures_PACKED)); \
    packed_data->index = glGenTextures_INDEX; \
    packed_data->args.n = (GLsizei)_n; \
    packed_data->args.textures = (GLuint *)_textures; \
    (packed_call_t *)packed_data; \
})
#define call_glGenTextures(packed, ret_v) do { \
    PACKED_glGenTextures *unpacked = (PACKED_glGenTextures *)packed; \
    ARGS_glGenTextures *args = (ARGS_glGenTextures *)&unpacked->args; \
    glGenTextures(args->n, args->textures);; \
} while(0)
void glGenTextures(glGenTextures_ARG_EXPAND);
typedef void (*glGenTextures_PTR)(glGenTextures_ARG_EXPAND);
#define glGenTexturesEXT_INDEX 686
#define glGenTexturesEXT_RETURN void
#define glGenTexturesEXT_ARG_NAMES n, textures
#define glGenTexturesEXT_ARG_EXPAND GLsizei n, GLuint * textures
#define glGenTexturesEXT_PACKED PACKED_glGenTexturesEXT
#define glGenTexturesEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGenTexturesEXT_NOT_VOID_WRAP(...) {}
#define pack_glGenTexturesEXT(_n, _textures) ({ \
    glGenTexturesEXT_PACKED *packed_data = malloc(sizeof(glGenTexturesEXT_PACKED)); \
    packed_data->index = glGenTexturesEXT_INDEX; \
    packed_data->args.n = (GLsizei)_n; \
    packed_data->args.textures = (GLuint *)_textures; \
    (packed_call_t *)packed_data; \
})
#define call_glGenTexturesEXT(packed, ret_v) do { \
    PACKED_glGenTexturesEXT *unpacked = (PACKED_glGenTexturesEXT *)packed; \
    ARGS_glGenTexturesEXT *args = (ARGS_glGenTexturesEXT *)&unpacked->args; \
    glGenTexturesEXT(args->n, args->textures);; \
} while(0)
void glGenTexturesEXT(glGenTexturesEXT_ARG_EXPAND);
typedef void (*glGenTexturesEXT_PTR)(glGenTexturesEXT_ARG_EXPAND);
#define glGenTransformFeedbacks_INDEX 687
#define glGenTransformFeedbacks_RETURN void
#define glGenTransformFeedbacks_ARG_NAMES n, ids
#define glGenTransformFeedbacks_ARG_EXPAND GLsizei n, GLuint * ids
#define glGenTransformFeedbacks_PACKED PACKED_glGenTransformFeedbacks
#define glGenTransformFeedbacks_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGenTransformFeedbacks_NOT_VOID_WRAP(...) {}
#define pack_glGenTransformFeedbacks(_n, _ids) ({ \
    glGenTransformFeedbacks_PACKED *packed_data = malloc(sizeof(glGenTransformFeedbacks_PACKED)); \
    packed_data->index = glGenTransformFeedbacks_INDEX; \
    packed_data->args.n = (GLsizei)_n; \
    packed_data->args.ids = (GLuint *)_ids; \
    (packed_call_t *)packed_data; \
})
#define call_glGenTransformFeedbacks(packed, ret_v) do { \
    PACKED_glGenTransformFeedbacks *unpacked = (PACKED_glGenTransformFeedbacks *)packed; \
    ARGS_glGenTransformFeedbacks *args = (ARGS_glGenTransformFeedbacks *)&unpacked->args; \
    glGenTransformFeedbacks(args->n, args->ids);; \
} while(0)
void glGenTransformFeedbacks(glGenTransformFeedbacks_ARG_EXPAND);
typedef void (*glGenTransformFeedbacks_PTR)(glGenTransformFeedbacks_ARG_EXPAND);
#define glGenTransformFeedbacksNV_INDEX 688
#define glGenTransformFeedbacksNV_RETURN void
#define glGenTransformFeedbacksNV_ARG_NAMES n, ids
#define glGenTransformFeedbacksNV_ARG_EXPAND GLsizei n, GLuint * ids
#define glGenTransformFeedbacksNV_PACKED PACKED_glGenTransformFeedbacksNV
#define glGenTransformFeedbacksNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGenTransformFeedbacksNV_NOT_VOID_WRAP(...) {}
#define pack_glGenTransformFeedbacksNV(_n, _ids) ({ \
    glGenTransformFeedbacksNV_PACKED *packed_data = malloc(sizeof(glGenTransformFeedbacksNV_PACKED)); \
    packed_data->index = glGenTransformFeedbacksNV_INDEX; \
    packed_data->args.n = (GLsizei)_n; \
    packed_data->args.ids = (GLuint *)_ids; \
    (packed_call_t *)packed_data; \
})
#define call_glGenTransformFeedbacksNV(packed, ret_v) do { \
    PACKED_glGenTransformFeedbacksNV *unpacked = (PACKED_glGenTransformFeedbacksNV *)packed; \
    ARGS_glGenTransformFeedbacksNV *args = (ARGS_glGenTransformFeedbacksNV *)&unpacked->args; \
    glGenTransformFeedbacksNV(args->n, args->ids);; \
} while(0)
void glGenTransformFeedbacksNV(glGenTransformFeedbacksNV_ARG_EXPAND);
typedef void (*glGenTransformFeedbacksNV_PTR)(glGenTransformFeedbacksNV_ARG_EXPAND);
#define glGenVertexArrays_INDEX 689
#define glGenVertexArrays_RETURN void
#define glGenVertexArrays_ARG_NAMES n, arrays
#define glGenVertexArrays_ARG_EXPAND GLsizei n, GLuint * arrays
#define glGenVertexArrays_PACKED PACKED_glGenVertexArrays
#define glGenVertexArrays_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGenVertexArrays_NOT_VOID_WRAP(...) {}
#define pack_glGenVertexArrays(_n, _arrays) ({ \
    glGenVertexArrays_PACKED *packed_data = malloc(sizeof(glGenVertexArrays_PACKED)); \
    packed_data->index = glGenVertexArrays_INDEX; \
    packed_data->args.n = (GLsizei)_n; \
    packed_data->args.arrays = (GLuint *)_arrays; \
    (packed_call_t *)packed_data; \
})
#define call_glGenVertexArrays(packed, ret_v) do { \
    PACKED_glGenVertexArrays *unpacked = (PACKED_glGenVertexArrays *)packed; \
    ARGS_glGenVertexArrays *args = (ARGS_glGenVertexArrays *)&unpacked->args; \
    glGenVertexArrays(args->n, args->arrays);; \
} while(0)
void glGenVertexArrays(glGenVertexArrays_ARG_EXPAND);
typedef void (*glGenVertexArrays_PTR)(glGenVertexArrays_ARG_EXPAND);
#define glGenVertexArraysAPPLE_INDEX 690
#define glGenVertexArraysAPPLE_RETURN void
#define glGenVertexArraysAPPLE_ARG_NAMES n, arrays
#define glGenVertexArraysAPPLE_ARG_EXPAND GLsizei n, GLuint * arrays
#define glGenVertexArraysAPPLE_PACKED PACKED_glGenVertexArraysAPPLE
#define glGenVertexArraysAPPLE_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGenVertexArraysAPPLE_NOT_VOID_WRAP(...) {}
#define pack_glGenVertexArraysAPPLE(_n, _arrays) ({ \
    glGenVertexArraysAPPLE_PACKED *packed_data = malloc(sizeof(glGenVertexArraysAPPLE_PACKED)); \
    packed_data->index = glGenVertexArraysAPPLE_INDEX; \
    packed_data->args.n = (GLsizei)_n; \
    packed_data->args.arrays = (GLuint *)_arrays; \
    (packed_call_t *)packed_data; \
})
#define call_glGenVertexArraysAPPLE(packed, ret_v) do { \
    PACKED_glGenVertexArraysAPPLE *unpacked = (PACKED_glGenVertexArraysAPPLE *)packed; \
    ARGS_glGenVertexArraysAPPLE *args = (ARGS_glGenVertexArraysAPPLE *)&unpacked->args; \
    glGenVertexArraysAPPLE(args->n, args->arrays);; \
} while(0)
void glGenVertexArraysAPPLE(glGenVertexArraysAPPLE_ARG_EXPAND);
typedef void (*glGenVertexArraysAPPLE_PTR)(glGenVertexArraysAPPLE_ARG_EXPAND);
#define glGenVertexShadersEXT_INDEX 691
#define glGenVertexShadersEXT_RETURN GLuint
#define glGenVertexShadersEXT_ARG_NAMES range
#define glGenVertexShadersEXT_ARG_EXPAND GLuint range
#define glGenVertexShadersEXT_PACKED PACKED_glGenVertexShadersEXT
#define glGenVertexShadersEXT_VOID_ONLY_WRAP(...) {}
#define glGenVertexShadersEXT_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glGenVertexShadersEXT(_range) ({ \
    glGenVertexShadersEXT_PACKED *packed_data = malloc(sizeof(glGenVertexShadersEXT_PACKED)); \
    packed_data->index = glGenVertexShadersEXT_INDEX; \
    packed_data->args.range = (GLuint)_range; \
    (packed_call_t *)packed_data; \
})
#define call_glGenVertexShadersEXT(packed, ret_v) do { \
    PACKED_glGenVertexShadersEXT *unpacked = (PACKED_glGenVertexShadersEXT *)packed; \
    ARGS_glGenVertexShadersEXT *args = (ARGS_glGenVertexShadersEXT *)&unpacked->args; \
    GLuint *ret = (GLuint *)ret_v; \
    if (ret != NULL) { \
        *ret = glGenVertexShadersEXT(args->range);; \
    } else { \
        glGenVertexShadersEXT(args->range);; \
    } \
} while(0)
GLuint glGenVertexShadersEXT(glGenVertexShadersEXT_ARG_EXPAND);
typedef GLuint (*glGenVertexShadersEXT_PTR)(glGenVertexShadersEXT_ARG_EXPAND);
#define glGenerateMipmap_INDEX 692
#define glGenerateMipmap_RETURN void
#define glGenerateMipmap_ARG_NAMES target
#define glGenerateMipmap_ARG_EXPAND GLenum target
#define glGenerateMipmap_PACKED PACKED_glGenerateMipmap
#define glGenerateMipmap_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGenerateMipmap_NOT_VOID_WRAP(...) {}
#define pack_glGenerateMipmap(_target) ({ \
    glGenerateMipmap_PACKED *packed_data = malloc(sizeof(glGenerateMipmap_PACKED)); \
    packed_data->index = glGenerateMipmap_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    (packed_call_t *)packed_data; \
})
#define call_glGenerateMipmap(packed, ret_v) do { \
    PACKED_glGenerateMipmap *unpacked = (PACKED_glGenerateMipmap *)packed; \
    ARGS_glGenerateMipmap *args = (ARGS_glGenerateMipmap *)&unpacked->args; \
    glGenerateMipmap(args->target);; \
} while(0)
void glGenerateMipmap(glGenerateMipmap_ARG_EXPAND);
typedef void (*glGenerateMipmap_PTR)(glGenerateMipmap_ARG_EXPAND);
#define glGenerateMipmapEXT_INDEX 693
#define glGenerateMipmapEXT_RETURN void
#define glGenerateMipmapEXT_ARG_NAMES target
#define glGenerateMipmapEXT_ARG_EXPAND GLenum target
#define glGenerateMipmapEXT_PACKED PACKED_glGenerateMipmapEXT
#define glGenerateMipmapEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGenerateMipmapEXT_NOT_VOID_WRAP(...) {}
#define pack_glGenerateMipmapEXT(_target) ({ \
    glGenerateMipmapEXT_PACKED *packed_data = malloc(sizeof(glGenerateMipmapEXT_PACKED)); \
    packed_data->index = glGenerateMipmapEXT_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    (packed_call_t *)packed_data; \
})
#define call_glGenerateMipmapEXT(packed, ret_v) do { \
    PACKED_glGenerateMipmapEXT *unpacked = (PACKED_glGenerateMipmapEXT *)packed; \
    ARGS_glGenerateMipmapEXT *args = (ARGS_glGenerateMipmapEXT *)&unpacked->args; \
    glGenerateMipmapEXT(args->target);; \
} while(0)
void glGenerateMipmapEXT(glGenerateMipmapEXT_ARG_EXPAND);
typedef void (*glGenerateMipmapEXT_PTR)(glGenerateMipmapEXT_ARG_EXPAND);
#define glGenerateMultiTexMipmapEXT_INDEX 694
#define glGenerateMultiTexMipmapEXT_RETURN void
#define glGenerateMultiTexMipmapEXT_ARG_NAMES texunit, target
#define glGenerateMultiTexMipmapEXT_ARG_EXPAND GLenum texunit, GLenum target
#define glGenerateMultiTexMipmapEXT_PACKED PACKED_glGenerateMultiTexMipmapEXT
#define glGenerateMultiTexMipmapEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGenerateMultiTexMipmapEXT_NOT_VOID_WRAP(...) {}
#define pack_glGenerateMultiTexMipmapEXT(_texunit, _target) ({ \
    glGenerateMultiTexMipmapEXT_PACKED *packed_data = malloc(sizeof(glGenerateMultiTexMipmapEXT_PACKED)); \
    packed_data->index = glGenerateMultiTexMipmapEXT_INDEX; \
    packed_data->args.texunit = (GLenum)_texunit; \
    packed_data->args.target = (GLenum)_target; \
    (packed_call_t *)packed_data; \
})
#define call_glGenerateMultiTexMipmapEXT(packed, ret_v) do { \
    PACKED_glGenerateMultiTexMipmapEXT *unpacked = (PACKED_glGenerateMultiTexMipmapEXT *)packed; \
    ARGS_glGenerateMultiTexMipmapEXT *args = (ARGS_glGenerateMultiTexMipmapEXT *)&unpacked->args; \
    glGenerateMultiTexMipmapEXT(args->texunit, args->target);; \
} while(0)
void glGenerateMultiTexMipmapEXT(glGenerateMultiTexMipmapEXT_ARG_EXPAND);
typedef void (*glGenerateMultiTexMipmapEXT_PTR)(glGenerateMultiTexMipmapEXT_ARG_EXPAND);
#define glGenerateTextureMipmapEXT_INDEX 695
#define glGenerateTextureMipmapEXT_RETURN void
#define glGenerateTextureMipmapEXT_ARG_NAMES texture, target
#define glGenerateTextureMipmapEXT_ARG_EXPAND GLuint texture, GLenum target
#define glGenerateTextureMipmapEXT_PACKED PACKED_glGenerateTextureMipmapEXT
#define glGenerateTextureMipmapEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGenerateTextureMipmapEXT_NOT_VOID_WRAP(...) {}
#define pack_glGenerateTextureMipmapEXT(_texture, _target) ({ \
    glGenerateTextureMipmapEXT_PACKED *packed_data = malloc(sizeof(glGenerateTextureMipmapEXT_PACKED)); \
    packed_data->index = glGenerateTextureMipmapEXT_INDEX; \
    packed_data->args.texture = (GLuint)_texture; \
    packed_data->args.target = (GLenum)_target; \
    (packed_call_t *)packed_data; \
})
#define call_glGenerateTextureMipmapEXT(packed, ret_v) do { \
    PACKED_glGenerateTextureMipmapEXT *unpacked = (PACKED_glGenerateTextureMipmapEXT *)packed; \
    ARGS_glGenerateTextureMipmapEXT *args = (ARGS_glGenerateTextureMipmapEXT *)&unpacked->args; \
    glGenerateTextureMipmapEXT(args->texture, args->target);; \
} while(0)
void glGenerateTextureMipmapEXT(glGenerateTextureMipmapEXT_ARG_EXPAND);
typedef void (*glGenerateTextureMipmapEXT_PTR)(glGenerateTextureMipmapEXT_ARG_EXPAND);
#define glGetActiveAtomicCounterBufferiv_INDEX 696
#define glGetActiveAtomicCounterBufferiv_RETURN void
#define glGetActiveAtomicCounterBufferiv_ARG_NAMES program, bufferIndex, pname, params
#define glGetActiveAtomicCounterBufferiv_ARG_EXPAND GLuint program, GLuint bufferIndex, GLenum pname, GLint * params
#define glGetActiveAtomicCounterBufferiv_PACKED PACKED_glGetActiveAtomicCounterBufferiv
#define glGetActiveAtomicCounterBufferiv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetActiveAtomicCounterBufferiv_NOT_VOID_WRAP(...) {}
#define pack_glGetActiveAtomicCounterBufferiv(_program, _bufferIndex, _pname, _params) ({ \
    glGetActiveAtomicCounterBufferiv_PACKED *packed_data = malloc(sizeof(glGetActiveAtomicCounterBufferiv_PACKED)); \
    packed_data->index = glGetActiveAtomicCounterBufferiv_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.bufferIndex = (GLuint)_bufferIndex; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetActiveAtomicCounterBufferiv(packed, ret_v) do { \
    PACKED_glGetActiveAtomicCounterBufferiv *unpacked = (PACKED_glGetActiveAtomicCounterBufferiv *)packed; \
    ARGS_glGetActiveAtomicCounterBufferiv *args = (ARGS_glGetActiveAtomicCounterBufferiv *)&unpacked->args; \
    glGetActiveAtomicCounterBufferiv(args->program, args->bufferIndex, args->pname, args->params);; \
} while(0)
void glGetActiveAtomicCounterBufferiv(glGetActiveAtomicCounterBufferiv_ARG_EXPAND);
typedef void (*glGetActiveAtomicCounterBufferiv_PTR)(glGetActiveAtomicCounterBufferiv_ARG_EXPAND);
#define glGetActiveAttrib_INDEX 697
#define glGetActiveAttrib_RETURN void
#define glGetActiveAttrib_ARG_NAMES program, index, bufSize, length, size, type, name
#define glGetActiveAttrib_ARG_EXPAND GLuint program, GLuint index, GLsizei bufSize, GLsizei * length, GLint * size, GLenum * type, GLchar * name
#define glGetActiveAttrib_PACKED PACKED_glGetActiveAttrib
#define glGetActiveAttrib_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetActiveAttrib_NOT_VOID_WRAP(...) {}
#define pack_glGetActiveAttrib(_program, _index, _bufSize, _length, _size, _type, _name) ({ \
    glGetActiveAttrib_PACKED *packed_data = malloc(sizeof(glGetActiveAttrib_PACKED)); \
    packed_data->index = glGetActiveAttrib_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.bufSize = (GLsizei)_bufSize; \
    packed_data->args.length = (GLsizei *)_length; \
    packed_data->args.size = (GLint *)_size; \
    packed_data->args.type = (GLenum *)_type; \
    packed_data->args.name = (GLchar *)_name; \
    (packed_call_t *)packed_data; \
})
#define call_glGetActiveAttrib(packed, ret_v) do { \
    PACKED_glGetActiveAttrib *unpacked = (PACKED_glGetActiveAttrib *)packed; \
    ARGS_glGetActiveAttrib *args = (ARGS_glGetActiveAttrib *)&unpacked->args; \
    glGetActiveAttrib(args->program, args->index, args->bufSize, args->length, args->size, args->type, args->name);; \
} while(0)
void glGetActiveAttrib(glGetActiveAttrib_ARG_EXPAND);
typedef void (*glGetActiveAttrib_PTR)(glGetActiveAttrib_ARG_EXPAND);
#define glGetActiveAttribARB_INDEX 698
#define glGetActiveAttribARB_RETURN void
#define glGetActiveAttribARB_ARG_NAMES programObj, index, maxLength, length, size, type, name
#define glGetActiveAttribARB_ARG_EXPAND GLhandleARB programObj, GLuint index, GLsizei maxLength, GLsizei * length, GLint * size, GLenum * type, GLcharARB * name
#define glGetActiveAttribARB_PACKED PACKED_glGetActiveAttribARB
#define glGetActiveAttribARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetActiveAttribARB_NOT_VOID_WRAP(...) {}
#define pack_glGetActiveAttribARB(_programObj, _index, _maxLength, _length, _size, _type, _name) ({ \
    glGetActiveAttribARB_PACKED *packed_data = malloc(sizeof(glGetActiveAttribARB_PACKED)); \
    packed_data->index = glGetActiveAttribARB_INDEX; \
    packed_data->args.programObj = (GLhandleARB)_programObj; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.maxLength = (GLsizei)_maxLength; \
    packed_data->args.length = (GLsizei *)_length; \
    packed_data->args.size = (GLint *)_size; \
    packed_data->args.type = (GLenum *)_type; \
    packed_data->args.name = (GLcharARB *)_name; \
    (packed_call_t *)packed_data; \
})
#define call_glGetActiveAttribARB(packed, ret_v) do { \
    PACKED_glGetActiveAttribARB *unpacked = (PACKED_glGetActiveAttribARB *)packed; \
    ARGS_glGetActiveAttribARB *args = (ARGS_glGetActiveAttribARB *)&unpacked->args; \
    glGetActiveAttribARB(args->programObj, args->index, args->maxLength, args->length, args->size, args->type, args->name);; \
} while(0)
void glGetActiveAttribARB(glGetActiveAttribARB_ARG_EXPAND);
typedef void (*glGetActiveAttribARB_PTR)(glGetActiveAttribARB_ARG_EXPAND);
#define glGetActiveSubroutineName_INDEX 699
#define glGetActiveSubroutineName_RETURN void
#define glGetActiveSubroutineName_ARG_NAMES program, shadertype, index, bufsize, length, name
#define glGetActiveSubroutineName_ARG_EXPAND GLuint program, GLenum shadertype, GLuint index, GLsizei bufsize, GLsizei * length, GLchar * name
#define glGetActiveSubroutineName_PACKED PACKED_glGetActiveSubroutineName
#define glGetActiveSubroutineName_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetActiveSubroutineName_NOT_VOID_WRAP(...) {}
#define pack_glGetActiveSubroutineName(_program, _shadertype, _index, _bufsize, _length, _name) ({ \
    glGetActiveSubroutineName_PACKED *packed_data = malloc(sizeof(glGetActiveSubroutineName_PACKED)); \
    packed_data->index = glGetActiveSubroutineName_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.shadertype = (GLenum)_shadertype; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.bufsize = (GLsizei)_bufsize; \
    packed_data->args.length = (GLsizei *)_length; \
    packed_data->args.name = (GLchar *)_name; \
    (packed_call_t *)packed_data; \
})
#define call_glGetActiveSubroutineName(packed, ret_v) do { \
    PACKED_glGetActiveSubroutineName *unpacked = (PACKED_glGetActiveSubroutineName *)packed; \
    ARGS_glGetActiveSubroutineName *args = (ARGS_glGetActiveSubroutineName *)&unpacked->args; \
    glGetActiveSubroutineName(args->program, args->shadertype, args->index, args->bufsize, args->length, args->name);; \
} while(0)
void glGetActiveSubroutineName(glGetActiveSubroutineName_ARG_EXPAND);
typedef void (*glGetActiveSubroutineName_PTR)(glGetActiveSubroutineName_ARG_EXPAND);
#define glGetActiveSubroutineUniformName_INDEX 700
#define glGetActiveSubroutineUniformName_RETURN void
#define glGetActiveSubroutineUniformName_ARG_NAMES program, shadertype, index, bufsize, length, name
#define glGetActiveSubroutineUniformName_ARG_EXPAND GLuint program, GLenum shadertype, GLuint index, GLsizei bufsize, GLsizei * length, GLchar * name
#define glGetActiveSubroutineUniformName_PACKED PACKED_glGetActiveSubroutineUniformName
#define glGetActiveSubroutineUniformName_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetActiveSubroutineUniformName_NOT_VOID_WRAP(...) {}
#define pack_glGetActiveSubroutineUniformName(_program, _shadertype, _index, _bufsize, _length, _name) ({ \
    glGetActiveSubroutineUniformName_PACKED *packed_data = malloc(sizeof(glGetActiveSubroutineUniformName_PACKED)); \
    packed_data->index = glGetActiveSubroutineUniformName_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.shadertype = (GLenum)_shadertype; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.bufsize = (GLsizei)_bufsize; \
    packed_data->args.length = (GLsizei *)_length; \
    packed_data->args.name = (GLchar *)_name; \
    (packed_call_t *)packed_data; \
})
#define call_glGetActiveSubroutineUniformName(packed, ret_v) do { \
    PACKED_glGetActiveSubroutineUniformName *unpacked = (PACKED_glGetActiveSubroutineUniformName *)packed; \
    ARGS_glGetActiveSubroutineUniformName *args = (ARGS_glGetActiveSubroutineUniformName *)&unpacked->args; \
    glGetActiveSubroutineUniformName(args->program, args->shadertype, args->index, args->bufsize, args->length, args->name);; \
} while(0)
void glGetActiveSubroutineUniformName(glGetActiveSubroutineUniformName_ARG_EXPAND);
typedef void (*glGetActiveSubroutineUniformName_PTR)(glGetActiveSubroutineUniformName_ARG_EXPAND);
#define glGetActiveSubroutineUniformiv_INDEX 701
#define glGetActiveSubroutineUniformiv_RETURN void
#define glGetActiveSubroutineUniformiv_ARG_NAMES program, shadertype, index, pname, values
#define glGetActiveSubroutineUniformiv_ARG_EXPAND GLuint program, GLenum shadertype, GLuint index, GLenum pname, GLint * values
#define glGetActiveSubroutineUniformiv_PACKED PACKED_glGetActiveSubroutineUniformiv
#define glGetActiveSubroutineUniformiv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetActiveSubroutineUniformiv_NOT_VOID_WRAP(...) {}
#define pack_glGetActiveSubroutineUniformiv(_program, _shadertype, _index, _pname, _values) ({ \
    glGetActiveSubroutineUniformiv_PACKED *packed_data = malloc(sizeof(glGetActiveSubroutineUniformiv_PACKED)); \
    packed_data->index = glGetActiveSubroutineUniformiv_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.shadertype = (GLenum)_shadertype; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.values = (GLint *)_values; \
    (packed_call_t *)packed_data; \
})
#define call_glGetActiveSubroutineUniformiv(packed, ret_v) do { \
    PACKED_glGetActiveSubroutineUniformiv *unpacked = (PACKED_glGetActiveSubroutineUniformiv *)packed; \
    ARGS_glGetActiveSubroutineUniformiv *args = (ARGS_glGetActiveSubroutineUniformiv *)&unpacked->args; \
    glGetActiveSubroutineUniformiv(args->program, args->shadertype, args->index, args->pname, args->values);; \
} while(0)
void glGetActiveSubroutineUniformiv(glGetActiveSubroutineUniformiv_ARG_EXPAND);
typedef void (*glGetActiveSubroutineUniformiv_PTR)(glGetActiveSubroutineUniformiv_ARG_EXPAND);
#define glGetActiveUniform_INDEX 702
#define glGetActiveUniform_RETURN void
#define glGetActiveUniform_ARG_NAMES program, index, bufSize, length, size, type, name
#define glGetActiveUniform_ARG_EXPAND GLuint program, GLuint index, GLsizei bufSize, GLsizei * length, GLint * size, GLenum * type, GLchar * name
#define glGetActiveUniform_PACKED PACKED_glGetActiveUniform
#define glGetActiveUniform_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetActiveUniform_NOT_VOID_WRAP(...) {}
#define pack_glGetActiveUniform(_program, _index, _bufSize, _length, _size, _type, _name) ({ \
    glGetActiveUniform_PACKED *packed_data = malloc(sizeof(glGetActiveUniform_PACKED)); \
    packed_data->index = glGetActiveUniform_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.bufSize = (GLsizei)_bufSize; \
    packed_data->args.length = (GLsizei *)_length; \
    packed_data->args.size = (GLint *)_size; \
    packed_data->args.type = (GLenum *)_type; \
    packed_data->args.name = (GLchar *)_name; \
    (packed_call_t *)packed_data; \
})
#define call_glGetActiveUniform(packed, ret_v) do { \
    PACKED_glGetActiveUniform *unpacked = (PACKED_glGetActiveUniform *)packed; \
    ARGS_glGetActiveUniform *args = (ARGS_glGetActiveUniform *)&unpacked->args; \
    glGetActiveUniform(args->program, args->index, args->bufSize, args->length, args->size, args->type, args->name);; \
} while(0)
void glGetActiveUniform(glGetActiveUniform_ARG_EXPAND);
typedef void (*glGetActiveUniform_PTR)(glGetActiveUniform_ARG_EXPAND);
#define glGetActiveUniformARB_INDEX 703
#define glGetActiveUniformARB_RETURN void
#define glGetActiveUniformARB_ARG_NAMES programObj, index, maxLength, length, size, type, name
#define glGetActiveUniformARB_ARG_EXPAND GLhandleARB programObj, GLuint index, GLsizei maxLength, GLsizei * length, GLint * size, GLenum * type, GLcharARB * name
#define glGetActiveUniformARB_PACKED PACKED_glGetActiveUniformARB
#define glGetActiveUniformARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetActiveUniformARB_NOT_VOID_WRAP(...) {}
#define pack_glGetActiveUniformARB(_programObj, _index, _maxLength, _length, _size, _type, _name) ({ \
    glGetActiveUniformARB_PACKED *packed_data = malloc(sizeof(glGetActiveUniformARB_PACKED)); \
    packed_data->index = glGetActiveUniformARB_INDEX; \
    packed_data->args.programObj = (GLhandleARB)_programObj; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.maxLength = (GLsizei)_maxLength; \
    packed_data->args.length = (GLsizei *)_length; \
    packed_data->args.size = (GLint *)_size; \
    packed_data->args.type = (GLenum *)_type; \
    packed_data->args.name = (GLcharARB *)_name; \
    (packed_call_t *)packed_data; \
})
#define call_glGetActiveUniformARB(packed, ret_v) do { \
    PACKED_glGetActiveUniformARB *unpacked = (PACKED_glGetActiveUniformARB *)packed; \
    ARGS_glGetActiveUniformARB *args = (ARGS_glGetActiveUniformARB *)&unpacked->args; \
    glGetActiveUniformARB(args->programObj, args->index, args->maxLength, args->length, args->size, args->type, args->name);; \
} while(0)
void glGetActiveUniformARB(glGetActiveUniformARB_ARG_EXPAND);
typedef void (*glGetActiveUniformARB_PTR)(glGetActiveUniformARB_ARG_EXPAND);
#define glGetActiveUniformBlockName_INDEX 704
#define glGetActiveUniformBlockName_RETURN void
#define glGetActiveUniformBlockName_ARG_NAMES program, uniformBlockIndex, bufSize, length, uniformBlockName
#define glGetActiveUniformBlockName_ARG_EXPAND GLuint program, GLuint uniformBlockIndex, GLsizei bufSize, GLsizei * length, GLchar * uniformBlockName
#define glGetActiveUniformBlockName_PACKED PACKED_glGetActiveUniformBlockName
#define glGetActiveUniformBlockName_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetActiveUniformBlockName_NOT_VOID_WRAP(...) {}
#define pack_glGetActiveUniformBlockName(_program, _uniformBlockIndex, _bufSize, _length, _uniformBlockName) ({ \
    glGetActiveUniformBlockName_PACKED *packed_data = malloc(sizeof(glGetActiveUniformBlockName_PACKED)); \
    packed_data->index = glGetActiveUniformBlockName_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.uniformBlockIndex = (GLuint)_uniformBlockIndex; \
    packed_data->args.bufSize = (GLsizei)_bufSize; \
    packed_data->args.length = (GLsizei *)_length; \
    packed_data->args.uniformBlockName = (GLchar *)_uniformBlockName; \
    (packed_call_t *)packed_data; \
})
#define call_glGetActiveUniformBlockName(packed, ret_v) do { \
    PACKED_glGetActiveUniformBlockName *unpacked = (PACKED_glGetActiveUniformBlockName *)packed; \
    ARGS_glGetActiveUniformBlockName *args = (ARGS_glGetActiveUniformBlockName *)&unpacked->args; \
    glGetActiveUniformBlockName(args->program, args->uniformBlockIndex, args->bufSize, args->length, args->uniformBlockName);; \
} while(0)
void glGetActiveUniformBlockName(glGetActiveUniformBlockName_ARG_EXPAND);
typedef void (*glGetActiveUniformBlockName_PTR)(glGetActiveUniformBlockName_ARG_EXPAND);
#define glGetActiveUniformBlockiv_INDEX 705
#define glGetActiveUniformBlockiv_RETURN void
#define glGetActiveUniformBlockiv_ARG_NAMES program, uniformBlockIndex, pname, params
#define glGetActiveUniformBlockiv_ARG_EXPAND GLuint program, GLuint uniformBlockIndex, GLenum pname, GLint * params
#define glGetActiveUniformBlockiv_PACKED PACKED_glGetActiveUniformBlockiv
#define glGetActiveUniformBlockiv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetActiveUniformBlockiv_NOT_VOID_WRAP(...) {}
#define pack_glGetActiveUniformBlockiv(_program, _uniformBlockIndex, _pname, _params) ({ \
    glGetActiveUniformBlockiv_PACKED *packed_data = malloc(sizeof(glGetActiveUniformBlockiv_PACKED)); \
    packed_data->index = glGetActiveUniformBlockiv_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.uniformBlockIndex = (GLuint)_uniformBlockIndex; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetActiveUniformBlockiv(packed, ret_v) do { \
    PACKED_glGetActiveUniformBlockiv *unpacked = (PACKED_glGetActiveUniformBlockiv *)packed; \
    ARGS_glGetActiveUniformBlockiv *args = (ARGS_glGetActiveUniformBlockiv *)&unpacked->args; \
    glGetActiveUniformBlockiv(args->program, args->uniformBlockIndex, args->pname, args->params);; \
} while(0)
void glGetActiveUniformBlockiv(glGetActiveUniformBlockiv_ARG_EXPAND);
typedef void (*glGetActiveUniformBlockiv_PTR)(glGetActiveUniformBlockiv_ARG_EXPAND);
#define glGetActiveUniformName_INDEX 706
#define glGetActiveUniformName_RETURN void
#define glGetActiveUniformName_ARG_NAMES program, uniformIndex, bufSize, length, uniformName
#define glGetActiveUniformName_ARG_EXPAND GLuint program, GLuint uniformIndex, GLsizei bufSize, GLsizei * length, GLchar * uniformName
#define glGetActiveUniformName_PACKED PACKED_glGetActiveUniformName
#define glGetActiveUniformName_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetActiveUniformName_NOT_VOID_WRAP(...) {}
#define pack_glGetActiveUniformName(_program, _uniformIndex, _bufSize, _length, _uniformName) ({ \
    glGetActiveUniformName_PACKED *packed_data = malloc(sizeof(glGetActiveUniformName_PACKED)); \
    packed_data->index = glGetActiveUniformName_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.uniformIndex = (GLuint)_uniformIndex; \
    packed_data->args.bufSize = (GLsizei)_bufSize; \
    packed_data->args.length = (GLsizei *)_length; \
    packed_data->args.uniformName = (GLchar *)_uniformName; \
    (packed_call_t *)packed_data; \
})
#define call_glGetActiveUniformName(packed, ret_v) do { \
    PACKED_glGetActiveUniformName *unpacked = (PACKED_glGetActiveUniformName *)packed; \
    ARGS_glGetActiveUniformName *args = (ARGS_glGetActiveUniformName *)&unpacked->args; \
    glGetActiveUniformName(args->program, args->uniformIndex, args->bufSize, args->length, args->uniformName);; \
} while(0)
void glGetActiveUniformName(glGetActiveUniformName_ARG_EXPAND);
typedef void (*glGetActiveUniformName_PTR)(glGetActiveUniformName_ARG_EXPAND);
#define glGetActiveUniformsiv_INDEX 707
#define glGetActiveUniformsiv_RETURN void
#define glGetActiveUniformsiv_ARG_NAMES program, uniformCount, uniformIndices, pname, params
#define glGetActiveUniformsiv_ARG_EXPAND GLuint program, GLsizei uniformCount, const GLuint * uniformIndices, GLenum pname, GLint * params
#define glGetActiveUniformsiv_PACKED PACKED_glGetActiveUniformsiv
#define glGetActiveUniformsiv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetActiveUniformsiv_NOT_VOID_WRAP(...) {}
#define pack_glGetActiveUniformsiv(_program, _uniformCount, _uniformIndices, _pname, _params) ({ \
    glGetActiveUniformsiv_PACKED *packed_data = malloc(sizeof(glGetActiveUniformsiv_PACKED)); \
    packed_data->index = glGetActiveUniformsiv_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.uniformCount = (GLsizei)_uniformCount; \
    packed_data->args.uniformIndices = (GLuint *)_uniformIndices; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetActiveUniformsiv(packed, ret_v) do { \
    PACKED_glGetActiveUniformsiv *unpacked = (PACKED_glGetActiveUniformsiv *)packed; \
    ARGS_glGetActiveUniformsiv *args = (ARGS_glGetActiveUniformsiv *)&unpacked->args; \
    glGetActiveUniformsiv(args->program, args->uniformCount, args->uniformIndices, args->pname, args->params);; \
} while(0)
void glGetActiveUniformsiv(glGetActiveUniformsiv_ARG_EXPAND);
typedef void (*glGetActiveUniformsiv_PTR)(glGetActiveUniformsiv_ARG_EXPAND);
#define glGetActiveVaryingNV_INDEX 708
#define glGetActiveVaryingNV_RETURN void
#define glGetActiveVaryingNV_ARG_NAMES program, index, bufSize, length, size, type, name
#define glGetActiveVaryingNV_ARG_EXPAND GLuint program, GLuint index, GLsizei bufSize, GLsizei * length, GLsizei * size, GLenum * type, GLchar * name
#define glGetActiveVaryingNV_PACKED PACKED_glGetActiveVaryingNV
#define glGetActiveVaryingNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetActiveVaryingNV_NOT_VOID_WRAP(...) {}
#define pack_glGetActiveVaryingNV(_program, _index, _bufSize, _length, _size, _type, _name) ({ \
    glGetActiveVaryingNV_PACKED *packed_data = malloc(sizeof(glGetActiveVaryingNV_PACKED)); \
    packed_data->index = glGetActiveVaryingNV_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.bufSize = (GLsizei)_bufSize; \
    packed_data->args.length = (GLsizei *)_length; \
    packed_data->args.size = (GLsizei *)_size; \
    packed_data->args.type = (GLenum *)_type; \
    packed_data->args.name = (GLchar *)_name; \
    (packed_call_t *)packed_data; \
})
#define call_glGetActiveVaryingNV(packed, ret_v) do { \
    PACKED_glGetActiveVaryingNV *unpacked = (PACKED_glGetActiveVaryingNV *)packed; \
    ARGS_glGetActiveVaryingNV *args = (ARGS_glGetActiveVaryingNV *)&unpacked->args; \
    glGetActiveVaryingNV(args->program, args->index, args->bufSize, args->length, args->size, args->type, args->name);; \
} while(0)
void glGetActiveVaryingNV(glGetActiveVaryingNV_ARG_EXPAND);
typedef void (*glGetActiveVaryingNV_PTR)(glGetActiveVaryingNV_ARG_EXPAND);
#define glGetArrayObjectfvATI_INDEX 709
#define glGetArrayObjectfvATI_RETURN void
#define glGetArrayObjectfvATI_ARG_NAMES array, pname, params
#define glGetArrayObjectfvATI_ARG_EXPAND GLenum array, GLenum pname, GLfloat * params
#define glGetArrayObjectfvATI_PACKED PACKED_glGetArrayObjectfvATI
#define glGetArrayObjectfvATI_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetArrayObjectfvATI_NOT_VOID_WRAP(...) {}
#define pack_glGetArrayObjectfvATI(_array, _pname, _params) ({ \
    glGetArrayObjectfvATI_PACKED *packed_data = malloc(sizeof(glGetArrayObjectfvATI_PACKED)); \
    packed_data->index = glGetArrayObjectfvATI_INDEX; \
    packed_data->args.array = (GLenum)_array; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLfloat *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetArrayObjectfvATI(packed, ret_v) do { \
    PACKED_glGetArrayObjectfvATI *unpacked = (PACKED_glGetArrayObjectfvATI *)packed; \
    ARGS_glGetArrayObjectfvATI *args = (ARGS_glGetArrayObjectfvATI *)&unpacked->args; \
    glGetArrayObjectfvATI(args->array, args->pname, args->params);; \
} while(0)
void glGetArrayObjectfvATI(glGetArrayObjectfvATI_ARG_EXPAND);
typedef void (*glGetArrayObjectfvATI_PTR)(glGetArrayObjectfvATI_ARG_EXPAND);
#define glGetArrayObjectivATI_INDEX 710
#define glGetArrayObjectivATI_RETURN void
#define glGetArrayObjectivATI_ARG_NAMES array, pname, params
#define glGetArrayObjectivATI_ARG_EXPAND GLenum array, GLenum pname, GLint * params
#define glGetArrayObjectivATI_PACKED PACKED_glGetArrayObjectivATI
#define glGetArrayObjectivATI_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetArrayObjectivATI_NOT_VOID_WRAP(...) {}
#define pack_glGetArrayObjectivATI(_array, _pname, _params) ({ \
    glGetArrayObjectivATI_PACKED *packed_data = malloc(sizeof(glGetArrayObjectivATI_PACKED)); \
    packed_data->index = glGetArrayObjectivATI_INDEX; \
    packed_data->args.array = (GLenum)_array; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetArrayObjectivATI(packed, ret_v) do { \
    PACKED_glGetArrayObjectivATI *unpacked = (PACKED_glGetArrayObjectivATI *)packed; \
    ARGS_glGetArrayObjectivATI *args = (ARGS_glGetArrayObjectivATI *)&unpacked->args; \
    glGetArrayObjectivATI(args->array, args->pname, args->params);; \
} while(0)
void glGetArrayObjectivATI(glGetArrayObjectivATI_ARG_EXPAND);
typedef void (*glGetArrayObjectivATI_PTR)(glGetArrayObjectivATI_ARG_EXPAND);
#define glGetAttachedObjectsARB_INDEX 711
#define glGetAttachedObjectsARB_RETURN void
#define glGetAttachedObjectsARB_ARG_NAMES containerObj, maxCount, count, obj
#define glGetAttachedObjectsARB_ARG_EXPAND GLhandleARB containerObj, GLsizei maxCount, GLsizei * count, GLhandleARB * obj
#define glGetAttachedObjectsARB_PACKED PACKED_glGetAttachedObjectsARB
#define glGetAttachedObjectsARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetAttachedObjectsARB_NOT_VOID_WRAP(...) {}
#define pack_glGetAttachedObjectsARB(_containerObj, _maxCount, _count, _obj) ({ \
    glGetAttachedObjectsARB_PACKED *packed_data = malloc(sizeof(glGetAttachedObjectsARB_PACKED)); \
    packed_data->index = glGetAttachedObjectsARB_INDEX; \
    packed_data->args.containerObj = (GLhandleARB)_containerObj; \
    packed_data->args.maxCount = (GLsizei)_maxCount; \
    packed_data->args.count = (GLsizei *)_count; \
    packed_data->args.obj = (GLhandleARB *)_obj; \
    (packed_call_t *)packed_data; \
})
#define call_glGetAttachedObjectsARB(packed, ret_v) do { \
    PACKED_glGetAttachedObjectsARB *unpacked = (PACKED_glGetAttachedObjectsARB *)packed; \
    ARGS_glGetAttachedObjectsARB *args = (ARGS_glGetAttachedObjectsARB *)&unpacked->args; \
    glGetAttachedObjectsARB(args->containerObj, args->maxCount, args->count, args->obj);; \
} while(0)
void glGetAttachedObjectsARB(glGetAttachedObjectsARB_ARG_EXPAND);
typedef void (*glGetAttachedObjectsARB_PTR)(glGetAttachedObjectsARB_ARG_EXPAND);
#define glGetAttachedShaders_INDEX 712
#define glGetAttachedShaders_RETURN void
#define glGetAttachedShaders_ARG_NAMES program, maxCount, count, obj
#define glGetAttachedShaders_ARG_EXPAND GLuint program, GLsizei maxCount, GLsizei * count, GLuint * obj
#define glGetAttachedShaders_PACKED PACKED_glGetAttachedShaders
#define glGetAttachedShaders_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetAttachedShaders_NOT_VOID_WRAP(...) {}
#define pack_glGetAttachedShaders(_program, _maxCount, _count, _obj) ({ \
    glGetAttachedShaders_PACKED *packed_data = malloc(sizeof(glGetAttachedShaders_PACKED)); \
    packed_data->index = glGetAttachedShaders_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.maxCount = (GLsizei)_maxCount; \
    packed_data->args.count = (GLsizei *)_count; \
    packed_data->args.obj = (GLuint *)_obj; \
    (packed_call_t *)packed_data; \
})
#define call_glGetAttachedShaders(packed, ret_v) do { \
    PACKED_glGetAttachedShaders *unpacked = (PACKED_glGetAttachedShaders *)packed; \
    ARGS_glGetAttachedShaders *args = (ARGS_glGetAttachedShaders *)&unpacked->args; \
    glGetAttachedShaders(args->program, args->maxCount, args->count, args->obj);; \
} while(0)
void glGetAttachedShaders(glGetAttachedShaders_ARG_EXPAND);
typedef void (*glGetAttachedShaders_PTR)(glGetAttachedShaders_ARG_EXPAND);
#define glGetAttribLocation_INDEX 713
#define glGetAttribLocation_RETURN GLint
#define glGetAttribLocation_ARG_NAMES program, name
#define glGetAttribLocation_ARG_EXPAND GLuint program, const GLchar * name
#define glGetAttribLocation_PACKED PACKED_glGetAttribLocation
#define glGetAttribLocation_VOID_ONLY_WRAP(...) {}
#define glGetAttribLocation_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glGetAttribLocation(_program, _name) ({ \
    glGetAttribLocation_PACKED *packed_data = malloc(sizeof(glGetAttribLocation_PACKED)); \
    packed_data->index = glGetAttribLocation_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.name = (GLchar *)_name; \
    (packed_call_t *)packed_data; \
})
#define call_glGetAttribLocation(packed, ret_v) do { \
    PACKED_glGetAttribLocation *unpacked = (PACKED_glGetAttribLocation *)packed; \
    ARGS_glGetAttribLocation *args = (ARGS_glGetAttribLocation *)&unpacked->args; \
    GLint *ret = (GLint *)ret_v; \
    if (ret != NULL) { \
        *ret = glGetAttribLocation(args->program, args->name);; \
    } else { \
        glGetAttribLocation(args->program, args->name);; \
    } \
} while(0)
GLint glGetAttribLocation(glGetAttribLocation_ARG_EXPAND);
typedef GLint (*glGetAttribLocation_PTR)(glGetAttribLocation_ARG_EXPAND);
#define glGetAttribLocationARB_INDEX 714
#define glGetAttribLocationARB_RETURN GLint
#define glGetAttribLocationARB_ARG_NAMES programObj, name
#define glGetAttribLocationARB_ARG_EXPAND GLhandleARB programObj, const GLcharARB * name
#define glGetAttribLocationARB_PACKED PACKED_glGetAttribLocationARB
#define glGetAttribLocationARB_VOID_ONLY_WRAP(...) {}
#define glGetAttribLocationARB_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glGetAttribLocationARB(_programObj, _name) ({ \
    glGetAttribLocationARB_PACKED *packed_data = malloc(sizeof(glGetAttribLocationARB_PACKED)); \
    packed_data->index = glGetAttribLocationARB_INDEX; \
    packed_data->args.programObj = (GLhandleARB)_programObj; \
    packed_data->args.name = (GLcharARB *)_name; \
    (packed_call_t *)packed_data; \
})
#define call_glGetAttribLocationARB(packed, ret_v) do { \
    PACKED_glGetAttribLocationARB *unpacked = (PACKED_glGetAttribLocationARB *)packed; \
    ARGS_glGetAttribLocationARB *args = (ARGS_glGetAttribLocationARB *)&unpacked->args; \
    GLint *ret = (GLint *)ret_v; \
    if (ret != NULL) { \
        *ret = glGetAttribLocationARB(args->programObj, args->name);; \
    } else { \
        glGetAttribLocationARB(args->programObj, args->name);; \
    } \
} while(0)
GLint glGetAttribLocationARB(glGetAttribLocationARB_ARG_EXPAND);
typedef GLint (*glGetAttribLocationARB_PTR)(glGetAttribLocationARB_ARG_EXPAND);
#define glGetBooleanIndexedvEXT_INDEX 715
#define glGetBooleanIndexedvEXT_RETURN void
#define glGetBooleanIndexedvEXT_ARG_NAMES target, index, data
#define glGetBooleanIndexedvEXT_ARG_EXPAND GLenum target, GLuint index, GLboolean * data
#define glGetBooleanIndexedvEXT_PACKED PACKED_glGetBooleanIndexedvEXT
#define glGetBooleanIndexedvEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetBooleanIndexedvEXT_NOT_VOID_WRAP(...) {}
#define pack_glGetBooleanIndexedvEXT(_target, _index, _data) ({ \
    glGetBooleanIndexedvEXT_PACKED *packed_data = malloc(sizeof(glGetBooleanIndexedvEXT_PACKED)); \
    packed_data->index = glGetBooleanIndexedvEXT_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.data = (GLboolean *)_data; \
    (packed_call_t *)packed_data; \
})
#define call_glGetBooleanIndexedvEXT(packed, ret_v) do { \
    PACKED_glGetBooleanIndexedvEXT *unpacked = (PACKED_glGetBooleanIndexedvEXT *)packed; \
    ARGS_glGetBooleanIndexedvEXT *args = (ARGS_glGetBooleanIndexedvEXT *)&unpacked->args; \
    glGetBooleanIndexedvEXT(args->target, args->index, args->data);; \
} while(0)
void glGetBooleanIndexedvEXT(glGetBooleanIndexedvEXT_ARG_EXPAND);
typedef void (*glGetBooleanIndexedvEXT_PTR)(glGetBooleanIndexedvEXT_ARG_EXPAND);
#define glGetBooleani_v_INDEX 716
#define glGetBooleani_v_RETURN void
#define glGetBooleani_v_ARG_NAMES target, index, data
#define glGetBooleani_v_ARG_EXPAND GLenum target, GLuint index, GLboolean * data
#define glGetBooleani_v_PACKED PACKED_glGetBooleani_v
#define glGetBooleani_v_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetBooleani_v_NOT_VOID_WRAP(...) {}
#define pack_glGetBooleani_v(_target, _index, _data) ({ \
    glGetBooleani_v_PACKED *packed_data = malloc(sizeof(glGetBooleani_v_PACKED)); \
    packed_data->index = glGetBooleani_v_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.data = (GLboolean *)_data; \
    (packed_call_t *)packed_data; \
})
#define call_glGetBooleani_v(packed, ret_v) do { \
    PACKED_glGetBooleani_v *unpacked = (PACKED_glGetBooleani_v *)packed; \
    ARGS_glGetBooleani_v *args = (ARGS_glGetBooleani_v *)&unpacked->args; \
    glGetBooleani_v(args->target, args->index, args->data);; \
} while(0)
void glGetBooleani_v(glGetBooleani_v_ARG_EXPAND);
typedef void (*glGetBooleani_v_PTR)(glGetBooleani_v_ARG_EXPAND);
#define glGetBooleanv_INDEX 717
#define glGetBooleanv_RETURN void
#define glGetBooleanv_ARG_NAMES pname, params
#define glGetBooleanv_ARG_EXPAND GLenum pname, GLboolean * params
#define glGetBooleanv_PACKED PACKED_glGetBooleanv
#define glGetBooleanv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetBooleanv_NOT_VOID_WRAP(...) {}
#define pack_glGetBooleanv(_pname, _params) ({ \
    glGetBooleanv_PACKED *packed_data = malloc(sizeof(glGetBooleanv_PACKED)); \
    packed_data->index = glGetBooleanv_INDEX; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLboolean *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetBooleanv(packed, ret_v) do { \
    PACKED_glGetBooleanv *unpacked = (PACKED_glGetBooleanv *)packed; \
    ARGS_glGetBooleanv *args = (ARGS_glGetBooleanv *)&unpacked->args; \
    glGetBooleanv(args->pname, args->params);; \
} while(0)
void glGetBooleanv(glGetBooleanv_ARG_EXPAND);
typedef void (*glGetBooleanv_PTR)(glGetBooleanv_ARG_EXPAND);
#define glGetBufferParameteri64v_INDEX 718
#define glGetBufferParameteri64v_RETURN void
#define glGetBufferParameteri64v_ARG_NAMES target, pname, params
#define glGetBufferParameteri64v_ARG_EXPAND GLenum target, GLenum pname, GLint64 * params
#define glGetBufferParameteri64v_PACKED PACKED_glGetBufferParameteri64v
#define glGetBufferParameteri64v_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetBufferParameteri64v_NOT_VOID_WRAP(...) {}
#define pack_glGetBufferParameteri64v(_target, _pname, _params) ({ \
    glGetBufferParameteri64v_PACKED *packed_data = malloc(sizeof(glGetBufferParameteri64v_PACKED)); \
    packed_data->index = glGetBufferParameteri64v_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLint64 *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetBufferParameteri64v(packed, ret_v) do { \
    PACKED_glGetBufferParameteri64v *unpacked = (PACKED_glGetBufferParameteri64v *)packed; \
    ARGS_glGetBufferParameteri64v *args = (ARGS_glGetBufferParameteri64v *)&unpacked->args; \
    glGetBufferParameteri64v(args->target, args->pname, args->params);; \
} while(0)
void glGetBufferParameteri64v(glGetBufferParameteri64v_ARG_EXPAND);
typedef void (*glGetBufferParameteri64v_PTR)(glGetBufferParameteri64v_ARG_EXPAND);
#define glGetBufferParameteriv_INDEX 719
#define glGetBufferParameteriv_RETURN void
#define glGetBufferParameteriv_ARG_NAMES target, pname, params
#define glGetBufferParameteriv_ARG_EXPAND GLenum target, GLenum pname, GLint * params
#define glGetBufferParameteriv_PACKED PACKED_glGetBufferParameteriv
#define glGetBufferParameteriv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetBufferParameteriv_NOT_VOID_WRAP(...) {}
#define pack_glGetBufferParameteriv(_target, _pname, _params) ({ \
    glGetBufferParameteriv_PACKED *packed_data = malloc(sizeof(glGetBufferParameteriv_PACKED)); \
    packed_data->index = glGetBufferParameteriv_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetBufferParameteriv(packed, ret_v) do { \
    PACKED_glGetBufferParameteriv *unpacked = (PACKED_glGetBufferParameteriv *)packed; \
    ARGS_glGetBufferParameteriv *args = (ARGS_glGetBufferParameteriv *)&unpacked->args; \
    glGetBufferParameteriv(args->target, args->pname, args->params);; \
} while(0)
void glGetBufferParameteriv(glGetBufferParameteriv_ARG_EXPAND);
typedef void (*glGetBufferParameteriv_PTR)(glGetBufferParameteriv_ARG_EXPAND);
#define glGetBufferParameterivARB_INDEX 720
#define glGetBufferParameterivARB_RETURN void
#define glGetBufferParameterivARB_ARG_NAMES target, pname, params
#define glGetBufferParameterivARB_ARG_EXPAND GLenum target, GLenum pname, GLint * params
#define glGetBufferParameterivARB_PACKED PACKED_glGetBufferParameterivARB
#define glGetBufferParameterivARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetBufferParameterivARB_NOT_VOID_WRAP(...) {}
#define pack_glGetBufferParameterivARB(_target, _pname, _params) ({ \
    glGetBufferParameterivARB_PACKED *packed_data = malloc(sizeof(glGetBufferParameterivARB_PACKED)); \
    packed_data->index = glGetBufferParameterivARB_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetBufferParameterivARB(packed, ret_v) do { \
    PACKED_glGetBufferParameterivARB *unpacked = (PACKED_glGetBufferParameterivARB *)packed; \
    ARGS_glGetBufferParameterivARB *args = (ARGS_glGetBufferParameterivARB *)&unpacked->args; \
    glGetBufferParameterivARB(args->target, args->pname, args->params);; \
} while(0)
void glGetBufferParameterivARB(glGetBufferParameterivARB_ARG_EXPAND);
typedef void (*glGetBufferParameterivARB_PTR)(glGetBufferParameterivARB_ARG_EXPAND);
#define glGetBufferParameterui64vNV_INDEX 721
#define glGetBufferParameterui64vNV_RETURN void
#define glGetBufferParameterui64vNV_ARG_NAMES target, pname, params
#define glGetBufferParameterui64vNV_ARG_EXPAND GLenum target, GLenum pname, GLuint64EXT * params
#define glGetBufferParameterui64vNV_PACKED PACKED_glGetBufferParameterui64vNV
#define glGetBufferParameterui64vNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetBufferParameterui64vNV_NOT_VOID_WRAP(...) {}
#define pack_glGetBufferParameterui64vNV(_target, _pname, _params) ({ \
    glGetBufferParameterui64vNV_PACKED *packed_data = malloc(sizeof(glGetBufferParameterui64vNV_PACKED)); \
    packed_data->index = glGetBufferParameterui64vNV_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLuint64EXT *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetBufferParameterui64vNV(packed, ret_v) do { \
    PACKED_glGetBufferParameterui64vNV *unpacked = (PACKED_glGetBufferParameterui64vNV *)packed; \
    ARGS_glGetBufferParameterui64vNV *args = (ARGS_glGetBufferParameterui64vNV *)&unpacked->args; \
    glGetBufferParameterui64vNV(args->target, args->pname, args->params);; \
} while(0)
void glGetBufferParameterui64vNV(glGetBufferParameterui64vNV_ARG_EXPAND);
typedef void (*glGetBufferParameterui64vNV_PTR)(glGetBufferParameterui64vNV_ARG_EXPAND);
#define glGetBufferPointerv_INDEX 722
#define glGetBufferPointerv_RETURN void
#define glGetBufferPointerv_ARG_NAMES target, pname, params
#define glGetBufferPointerv_ARG_EXPAND GLenum target, GLenum pname, GLvoid * params
#define glGetBufferPointerv_PACKED PACKED_glGetBufferPointerv
#define glGetBufferPointerv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetBufferPointerv_NOT_VOID_WRAP(...) {}
#define pack_glGetBufferPointerv(_target, _pname, _params) ({ \
    glGetBufferPointerv_PACKED *packed_data = malloc(sizeof(glGetBufferPointerv_PACKED)); \
    packed_data->index = glGetBufferPointerv_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLvoid *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetBufferPointerv(packed, ret_v) do { \
    PACKED_glGetBufferPointerv *unpacked = (PACKED_glGetBufferPointerv *)packed; \
    ARGS_glGetBufferPointerv *args = (ARGS_glGetBufferPointerv *)&unpacked->args; \
    glGetBufferPointerv(args->target, args->pname, args->params);; \
} while(0)
void glGetBufferPointerv(glGetBufferPointerv_ARG_EXPAND);
typedef void (*glGetBufferPointerv_PTR)(glGetBufferPointerv_ARG_EXPAND);
#define glGetBufferPointervARB_INDEX 723
#define glGetBufferPointervARB_RETURN void
#define glGetBufferPointervARB_ARG_NAMES target, pname, params
#define glGetBufferPointervARB_ARG_EXPAND GLenum target, GLenum pname, GLvoid * params
#define glGetBufferPointervARB_PACKED PACKED_glGetBufferPointervARB
#define glGetBufferPointervARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetBufferPointervARB_NOT_VOID_WRAP(...) {}
#define pack_glGetBufferPointervARB(_target, _pname, _params) ({ \
    glGetBufferPointervARB_PACKED *packed_data = malloc(sizeof(glGetBufferPointervARB_PACKED)); \
    packed_data->index = glGetBufferPointervARB_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLvoid *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetBufferPointervARB(packed, ret_v) do { \
    PACKED_glGetBufferPointervARB *unpacked = (PACKED_glGetBufferPointervARB *)packed; \
    ARGS_glGetBufferPointervARB *args = (ARGS_glGetBufferPointervARB *)&unpacked->args; \
    glGetBufferPointervARB(args->target, args->pname, args->params);; \
} while(0)
void glGetBufferPointervARB(glGetBufferPointervARB_ARG_EXPAND);
typedef void (*glGetBufferPointervARB_PTR)(glGetBufferPointervARB_ARG_EXPAND);
#define glGetBufferSubData_INDEX 724
#define glGetBufferSubData_RETURN void
#define glGetBufferSubData_ARG_NAMES target, offset, size, data
#define glGetBufferSubData_ARG_EXPAND GLenum target, GLintptr offset, GLsizeiptr size, GLvoid * data
#define glGetBufferSubData_PACKED PACKED_glGetBufferSubData
#define glGetBufferSubData_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetBufferSubData_NOT_VOID_WRAP(...) {}
#define pack_glGetBufferSubData(_target, _offset, _size, _data) ({ \
    glGetBufferSubData_PACKED *packed_data = malloc(sizeof(glGetBufferSubData_PACKED)); \
    packed_data->index = glGetBufferSubData_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.offset = (GLintptr)_offset; \
    packed_data->args.size = (GLsizeiptr)_size; \
    packed_data->args.data = (GLvoid *)_data; \
    (packed_call_t *)packed_data; \
})
#define call_glGetBufferSubData(packed, ret_v) do { \
    PACKED_glGetBufferSubData *unpacked = (PACKED_glGetBufferSubData *)packed; \
    ARGS_glGetBufferSubData *args = (ARGS_glGetBufferSubData *)&unpacked->args; \
    glGetBufferSubData(args->target, args->offset, args->size, args->data);; \
} while(0)
void glGetBufferSubData(glGetBufferSubData_ARG_EXPAND);
typedef void (*glGetBufferSubData_PTR)(glGetBufferSubData_ARG_EXPAND);
#define glGetBufferSubDataARB_INDEX 725
#define glGetBufferSubDataARB_RETURN void
#define glGetBufferSubDataARB_ARG_NAMES target, offset, size, data
#define glGetBufferSubDataARB_ARG_EXPAND GLenum target, GLintptrARB offset, GLsizeiptrARB size, GLvoid * data
#define glGetBufferSubDataARB_PACKED PACKED_glGetBufferSubDataARB
#define glGetBufferSubDataARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetBufferSubDataARB_NOT_VOID_WRAP(...) {}
#define pack_glGetBufferSubDataARB(_target, _offset, _size, _data) ({ \
    glGetBufferSubDataARB_PACKED *packed_data = malloc(sizeof(glGetBufferSubDataARB_PACKED)); \
    packed_data->index = glGetBufferSubDataARB_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.offset = (GLintptrARB)_offset; \
    packed_data->args.size = (GLsizeiptrARB)_size; \
    packed_data->args.data = (GLvoid *)_data; \
    (packed_call_t *)packed_data; \
})
#define call_glGetBufferSubDataARB(packed, ret_v) do { \
    PACKED_glGetBufferSubDataARB *unpacked = (PACKED_glGetBufferSubDataARB *)packed; \
    ARGS_glGetBufferSubDataARB *args = (ARGS_glGetBufferSubDataARB *)&unpacked->args; \
    glGetBufferSubDataARB(args->target, args->offset, args->size, args->data);; \
} while(0)
void glGetBufferSubDataARB(glGetBufferSubDataARB_ARG_EXPAND);
typedef void (*glGetBufferSubDataARB_PTR)(glGetBufferSubDataARB_ARG_EXPAND);
#define glGetClipPlane_INDEX 726
#define glGetClipPlane_RETURN void
#define glGetClipPlane_ARG_NAMES plane, equation
#define glGetClipPlane_ARG_EXPAND GLenum plane, GLdouble * equation
#define glGetClipPlane_PACKED PACKED_glGetClipPlane
#define glGetClipPlane_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetClipPlane_NOT_VOID_WRAP(...) {}
#define pack_glGetClipPlane(_plane, _equation) ({ \
    glGetClipPlane_PACKED *packed_data = malloc(sizeof(glGetClipPlane_PACKED)); \
    packed_data->index = glGetClipPlane_INDEX; \
    packed_data->args.plane = (GLenum)_plane; \
    packed_data->args.equation = (GLdouble *)_equation; \
    (packed_call_t *)packed_data; \
})
#define call_glGetClipPlane(packed, ret_v) do { \
    PACKED_glGetClipPlane *unpacked = (PACKED_glGetClipPlane *)packed; \
    ARGS_glGetClipPlane *args = (ARGS_glGetClipPlane *)&unpacked->args; \
    glGetClipPlane(args->plane, args->equation);; \
} while(0)
void glGetClipPlane(glGetClipPlane_ARG_EXPAND);
typedef void (*glGetClipPlane_PTR)(glGetClipPlane_ARG_EXPAND);
#define glGetClipPlanef_INDEX 727
#define glGetClipPlanef_RETURN void
#define glGetClipPlanef_ARG_NAMES plane, equation
#define glGetClipPlanef_ARG_EXPAND GLenum plane, GLfloat * equation
#define glGetClipPlanef_PACKED PACKED_glGetClipPlanef
#define glGetClipPlanef_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetClipPlanef_NOT_VOID_WRAP(...) {}
#define pack_glGetClipPlanef(_plane, _equation) ({ \
    glGetClipPlanef_PACKED *packed_data = malloc(sizeof(glGetClipPlanef_PACKED)); \
    packed_data->index = glGetClipPlanef_INDEX; \
    packed_data->args.plane = (GLenum)_plane; \
    packed_data->args.equation = (GLfloat *)_equation; \
    (packed_call_t *)packed_data; \
})
#define call_glGetClipPlanef(packed, ret_v) do { \
    PACKED_glGetClipPlanef *unpacked = (PACKED_glGetClipPlanef *)packed; \
    ARGS_glGetClipPlanef *args = (ARGS_glGetClipPlanef *)&unpacked->args; \
    glGetClipPlanef(args->plane, args->equation);; \
} while(0)
void glGetClipPlanef(glGetClipPlanef_ARG_EXPAND);
typedef void (*glGetClipPlanef_PTR)(glGetClipPlanef_ARG_EXPAND);
#define glGetClipPlanefOES_INDEX 728
#define glGetClipPlanefOES_RETURN void
#define glGetClipPlanefOES_ARG_NAMES plane, equation
#define glGetClipPlanefOES_ARG_EXPAND GLenum plane, GLfloat * equation
#define glGetClipPlanefOES_PACKED PACKED_glGetClipPlanefOES
#define glGetClipPlanefOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetClipPlanefOES_NOT_VOID_WRAP(...) {}
#define pack_glGetClipPlanefOES(_plane, _equation) ({ \
    glGetClipPlanefOES_PACKED *packed_data = malloc(sizeof(glGetClipPlanefOES_PACKED)); \
    packed_data->index = glGetClipPlanefOES_INDEX; \
    packed_data->args.plane = (GLenum)_plane; \
    packed_data->args.equation = (GLfloat *)_equation; \
    (packed_call_t *)packed_data; \
})
#define call_glGetClipPlanefOES(packed, ret_v) do { \
    PACKED_glGetClipPlanefOES *unpacked = (PACKED_glGetClipPlanefOES *)packed; \
    ARGS_glGetClipPlanefOES *args = (ARGS_glGetClipPlanefOES *)&unpacked->args; \
    glGetClipPlanefOES(args->plane, args->equation);; \
} while(0)
void glGetClipPlanefOES(glGetClipPlanefOES_ARG_EXPAND);
typedef void (*glGetClipPlanefOES_PTR)(glGetClipPlanefOES_ARG_EXPAND);
#define glGetClipPlanex_INDEX 729
#define glGetClipPlanex_RETURN void
#define glGetClipPlanex_ARG_NAMES plane, equation
#define glGetClipPlanex_ARG_EXPAND GLenum plane, GLfixed * equation
#define glGetClipPlanex_PACKED PACKED_glGetClipPlanex
#define glGetClipPlanex_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetClipPlanex_NOT_VOID_WRAP(...) {}
#define pack_glGetClipPlanex(_plane, _equation) ({ \
    glGetClipPlanex_PACKED *packed_data = malloc(sizeof(glGetClipPlanex_PACKED)); \
    packed_data->index = glGetClipPlanex_INDEX; \
    packed_data->args.plane = (GLenum)_plane; \
    packed_data->args.equation = (GLfixed *)_equation; \
    (packed_call_t *)packed_data; \
})
#define call_glGetClipPlanex(packed, ret_v) do { \
    PACKED_glGetClipPlanex *unpacked = (PACKED_glGetClipPlanex *)packed; \
    ARGS_glGetClipPlanex *args = (ARGS_glGetClipPlanex *)&unpacked->args; \
    glGetClipPlanex(args->plane, args->equation);; \
} while(0)
void glGetClipPlanex(glGetClipPlanex_ARG_EXPAND);
typedef void (*glGetClipPlanex_PTR)(glGetClipPlanex_ARG_EXPAND);
#define glGetClipPlanexOES_INDEX 730
#define glGetClipPlanexOES_RETURN void
#define glGetClipPlanexOES_ARG_NAMES plane, equation
#define glGetClipPlanexOES_ARG_EXPAND GLenum plane, GLfixed * equation
#define glGetClipPlanexOES_PACKED PACKED_glGetClipPlanexOES
#define glGetClipPlanexOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetClipPlanexOES_NOT_VOID_WRAP(...) {}
#define pack_glGetClipPlanexOES(_plane, _equation) ({ \
    glGetClipPlanexOES_PACKED *packed_data = malloc(sizeof(glGetClipPlanexOES_PACKED)); \
    packed_data->index = glGetClipPlanexOES_INDEX; \
    packed_data->args.plane = (GLenum)_plane; \
    packed_data->args.equation = (GLfixed *)_equation; \
    (packed_call_t *)packed_data; \
})
#define call_glGetClipPlanexOES(packed, ret_v) do { \
    PACKED_glGetClipPlanexOES *unpacked = (PACKED_glGetClipPlanexOES *)packed; \
    ARGS_glGetClipPlanexOES *args = (ARGS_glGetClipPlanexOES *)&unpacked->args; \
    glGetClipPlanexOES(args->plane, args->equation);; \
} while(0)
void glGetClipPlanexOES(glGetClipPlanexOES_ARG_EXPAND);
typedef void (*glGetClipPlanexOES_PTR)(glGetClipPlanexOES_ARG_EXPAND);
#define glGetColorTable_INDEX 731
#define glGetColorTable_RETURN void
#define glGetColorTable_ARG_NAMES target, format, type, table
#define glGetColorTable_ARG_EXPAND GLenum target, GLenum format, GLenum type, GLvoid * table
#define glGetColorTable_PACKED PACKED_glGetColorTable
#define glGetColorTable_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetColorTable_NOT_VOID_WRAP(...) {}
#define pack_glGetColorTable(_target, _format, _type, _table) ({ \
    glGetColorTable_PACKED *packed_data = malloc(sizeof(glGetColorTable_PACKED)); \
    packed_data->index = glGetColorTable_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.format = (GLenum)_format; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.table = (GLvoid *)_table; \
    (packed_call_t *)packed_data; \
})
#define call_glGetColorTable(packed, ret_v) do { \
    PACKED_glGetColorTable *unpacked = (PACKED_glGetColorTable *)packed; \
    ARGS_glGetColorTable *args = (ARGS_glGetColorTable *)&unpacked->args; \
    glGetColorTable(args->target, args->format, args->type, args->table);; \
} while(0)
void glGetColorTable(glGetColorTable_ARG_EXPAND);
typedef void (*glGetColorTable_PTR)(glGetColorTable_ARG_EXPAND);
#define glGetColorTableEXT_INDEX 732
#define glGetColorTableEXT_RETURN void
#define glGetColorTableEXT_ARG_NAMES target, format, type, data
#define glGetColorTableEXT_ARG_EXPAND GLenum target, GLenum format, GLenum type, GLvoid * data
#define glGetColorTableEXT_PACKED PACKED_glGetColorTableEXT
#define glGetColorTableEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetColorTableEXT_NOT_VOID_WRAP(...) {}
#define pack_glGetColorTableEXT(_target, _format, _type, _data) ({ \
    glGetColorTableEXT_PACKED *packed_data = malloc(sizeof(glGetColorTableEXT_PACKED)); \
    packed_data->index = glGetColorTableEXT_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.format = (GLenum)_format; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.data = (GLvoid *)_data; \
    (packed_call_t *)packed_data; \
})
#define call_glGetColorTableEXT(packed, ret_v) do { \
    PACKED_glGetColorTableEXT *unpacked = (PACKED_glGetColorTableEXT *)packed; \
    ARGS_glGetColorTableEXT *args = (ARGS_glGetColorTableEXT *)&unpacked->args; \
    glGetColorTableEXT(args->target, args->format, args->type, args->data);; \
} while(0)
void glGetColorTableEXT(glGetColorTableEXT_ARG_EXPAND);
typedef void (*glGetColorTableEXT_PTR)(glGetColorTableEXT_ARG_EXPAND);
#define glGetColorTableParameterfv_INDEX 733
#define glGetColorTableParameterfv_RETURN void
#define glGetColorTableParameterfv_ARG_NAMES target, pname, params
#define glGetColorTableParameterfv_ARG_EXPAND GLenum target, GLenum pname, GLfloat * params
#define glGetColorTableParameterfv_PACKED PACKED_glGetColorTableParameterfv
#define glGetColorTableParameterfv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetColorTableParameterfv_NOT_VOID_WRAP(...) {}
#define pack_glGetColorTableParameterfv(_target, _pname, _params) ({ \
    glGetColorTableParameterfv_PACKED *packed_data = malloc(sizeof(glGetColorTableParameterfv_PACKED)); \
    packed_data->index = glGetColorTableParameterfv_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLfloat *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetColorTableParameterfv(packed, ret_v) do { \
    PACKED_glGetColorTableParameterfv *unpacked = (PACKED_glGetColorTableParameterfv *)packed; \
    ARGS_glGetColorTableParameterfv *args = (ARGS_glGetColorTableParameterfv *)&unpacked->args; \
    glGetColorTableParameterfv(args->target, args->pname, args->params);; \
} while(0)
void glGetColorTableParameterfv(glGetColorTableParameterfv_ARG_EXPAND);
typedef void (*glGetColorTableParameterfv_PTR)(glGetColorTableParameterfv_ARG_EXPAND);
#define glGetColorTableParameterfvEXT_INDEX 734
#define glGetColorTableParameterfvEXT_RETURN void
#define glGetColorTableParameterfvEXT_ARG_NAMES target, pname, params
#define glGetColorTableParameterfvEXT_ARG_EXPAND GLenum target, GLenum pname, GLfloat * params
#define glGetColorTableParameterfvEXT_PACKED PACKED_glGetColorTableParameterfvEXT
#define glGetColorTableParameterfvEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetColorTableParameterfvEXT_NOT_VOID_WRAP(...) {}
#define pack_glGetColorTableParameterfvEXT(_target, _pname, _params) ({ \
    glGetColorTableParameterfvEXT_PACKED *packed_data = malloc(sizeof(glGetColorTableParameterfvEXT_PACKED)); \
    packed_data->index = glGetColorTableParameterfvEXT_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLfloat *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetColorTableParameterfvEXT(packed, ret_v) do { \
    PACKED_glGetColorTableParameterfvEXT *unpacked = (PACKED_glGetColorTableParameterfvEXT *)packed; \
    ARGS_glGetColorTableParameterfvEXT *args = (ARGS_glGetColorTableParameterfvEXT *)&unpacked->args; \
    glGetColorTableParameterfvEXT(args->target, args->pname, args->params);; \
} while(0)
void glGetColorTableParameterfvEXT(glGetColorTableParameterfvEXT_ARG_EXPAND);
typedef void (*glGetColorTableParameterfvEXT_PTR)(glGetColorTableParameterfvEXT_ARG_EXPAND);
#define glGetColorTableParameterfvSGI_INDEX 735
#define glGetColorTableParameterfvSGI_RETURN void
#define glGetColorTableParameterfvSGI_ARG_NAMES target, pname, params
#define glGetColorTableParameterfvSGI_ARG_EXPAND GLenum target, GLenum pname, GLfloat * params
#define glGetColorTableParameterfvSGI_PACKED PACKED_glGetColorTableParameterfvSGI
#define glGetColorTableParameterfvSGI_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetColorTableParameterfvSGI_NOT_VOID_WRAP(...) {}
#define pack_glGetColorTableParameterfvSGI(_target, _pname, _params) ({ \
    glGetColorTableParameterfvSGI_PACKED *packed_data = malloc(sizeof(glGetColorTableParameterfvSGI_PACKED)); \
    packed_data->index = glGetColorTableParameterfvSGI_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLfloat *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetColorTableParameterfvSGI(packed, ret_v) do { \
    PACKED_glGetColorTableParameterfvSGI *unpacked = (PACKED_glGetColorTableParameterfvSGI *)packed; \
    ARGS_glGetColorTableParameterfvSGI *args = (ARGS_glGetColorTableParameterfvSGI *)&unpacked->args; \
    glGetColorTableParameterfvSGI(args->target, args->pname, args->params);; \
} while(0)
void glGetColorTableParameterfvSGI(glGetColorTableParameterfvSGI_ARG_EXPAND);
typedef void (*glGetColorTableParameterfvSGI_PTR)(glGetColorTableParameterfvSGI_ARG_EXPAND);
#define glGetColorTableParameteriv_INDEX 736
#define glGetColorTableParameteriv_RETURN void
#define glGetColorTableParameteriv_ARG_NAMES target, pname, params
#define glGetColorTableParameteriv_ARG_EXPAND GLenum target, GLenum pname, GLint * params
#define glGetColorTableParameteriv_PACKED PACKED_glGetColorTableParameteriv
#define glGetColorTableParameteriv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetColorTableParameteriv_NOT_VOID_WRAP(...) {}
#define pack_glGetColorTableParameteriv(_target, _pname, _params) ({ \
    glGetColorTableParameteriv_PACKED *packed_data = malloc(sizeof(glGetColorTableParameteriv_PACKED)); \
    packed_data->index = glGetColorTableParameteriv_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetColorTableParameteriv(packed, ret_v) do { \
    PACKED_glGetColorTableParameteriv *unpacked = (PACKED_glGetColorTableParameteriv *)packed; \
    ARGS_glGetColorTableParameteriv *args = (ARGS_glGetColorTableParameteriv *)&unpacked->args; \
    glGetColorTableParameteriv(args->target, args->pname, args->params);; \
} while(0)
void glGetColorTableParameteriv(glGetColorTableParameteriv_ARG_EXPAND);
typedef void (*glGetColorTableParameteriv_PTR)(glGetColorTableParameteriv_ARG_EXPAND);
#define glGetColorTableParameterivEXT_INDEX 737
#define glGetColorTableParameterivEXT_RETURN void
#define glGetColorTableParameterivEXT_ARG_NAMES target, pname, params
#define glGetColorTableParameterivEXT_ARG_EXPAND GLenum target, GLenum pname, GLint * params
#define glGetColorTableParameterivEXT_PACKED PACKED_glGetColorTableParameterivEXT
#define glGetColorTableParameterivEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetColorTableParameterivEXT_NOT_VOID_WRAP(...) {}
#define pack_glGetColorTableParameterivEXT(_target, _pname, _params) ({ \
    glGetColorTableParameterivEXT_PACKED *packed_data = malloc(sizeof(glGetColorTableParameterivEXT_PACKED)); \
    packed_data->index = glGetColorTableParameterivEXT_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetColorTableParameterivEXT(packed, ret_v) do { \
    PACKED_glGetColorTableParameterivEXT *unpacked = (PACKED_glGetColorTableParameterivEXT *)packed; \
    ARGS_glGetColorTableParameterivEXT *args = (ARGS_glGetColorTableParameterivEXT *)&unpacked->args; \
    glGetColorTableParameterivEXT(args->target, args->pname, args->params);; \
} while(0)
void glGetColorTableParameterivEXT(glGetColorTableParameterivEXT_ARG_EXPAND);
typedef void (*glGetColorTableParameterivEXT_PTR)(glGetColorTableParameterivEXT_ARG_EXPAND);
#define glGetColorTableParameterivSGI_INDEX 738
#define glGetColorTableParameterivSGI_RETURN void
#define glGetColorTableParameterivSGI_ARG_NAMES target, pname, params
#define glGetColorTableParameterivSGI_ARG_EXPAND GLenum target, GLenum pname, GLint * params
#define glGetColorTableParameterivSGI_PACKED PACKED_glGetColorTableParameterivSGI
#define glGetColorTableParameterivSGI_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetColorTableParameterivSGI_NOT_VOID_WRAP(...) {}
#define pack_glGetColorTableParameterivSGI(_target, _pname, _params) ({ \
    glGetColorTableParameterivSGI_PACKED *packed_data = malloc(sizeof(glGetColorTableParameterivSGI_PACKED)); \
    packed_data->index = glGetColorTableParameterivSGI_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetColorTableParameterivSGI(packed, ret_v) do { \
    PACKED_glGetColorTableParameterivSGI *unpacked = (PACKED_glGetColorTableParameterivSGI *)packed; \
    ARGS_glGetColorTableParameterivSGI *args = (ARGS_glGetColorTableParameterivSGI *)&unpacked->args; \
    glGetColorTableParameterivSGI(args->target, args->pname, args->params);; \
} while(0)
void glGetColorTableParameterivSGI(glGetColorTableParameterivSGI_ARG_EXPAND);
typedef void (*glGetColorTableParameterivSGI_PTR)(glGetColorTableParameterivSGI_ARG_EXPAND);
#define glGetColorTableSGI_INDEX 739
#define glGetColorTableSGI_RETURN void
#define glGetColorTableSGI_ARG_NAMES target, format, type, table
#define glGetColorTableSGI_ARG_EXPAND GLenum target, GLenum format, GLenum type, GLvoid * table
#define glGetColorTableSGI_PACKED PACKED_glGetColorTableSGI
#define glGetColorTableSGI_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetColorTableSGI_NOT_VOID_WRAP(...) {}
#define pack_glGetColorTableSGI(_target, _format, _type, _table) ({ \
    glGetColorTableSGI_PACKED *packed_data = malloc(sizeof(glGetColorTableSGI_PACKED)); \
    packed_data->index = glGetColorTableSGI_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.format = (GLenum)_format; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.table = (GLvoid *)_table; \
    (packed_call_t *)packed_data; \
})
#define call_glGetColorTableSGI(packed, ret_v) do { \
    PACKED_glGetColorTableSGI *unpacked = (PACKED_glGetColorTableSGI *)packed; \
    ARGS_glGetColorTableSGI *args = (ARGS_glGetColorTableSGI *)&unpacked->args; \
    glGetColorTableSGI(args->target, args->format, args->type, args->table);; \
} while(0)
void glGetColorTableSGI(glGetColorTableSGI_ARG_EXPAND);
typedef void (*glGetColorTableSGI_PTR)(glGetColorTableSGI_ARG_EXPAND);
#define glGetCombinerInputParameterfvNV_INDEX 740
#define glGetCombinerInputParameterfvNV_RETURN void
#define glGetCombinerInputParameterfvNV_ARG_NAMES stage, portion, variable, pname, params
#define glGetCombinerInputParameterfvNV_ARG_EXPAND GLenum stage, GLenum portion, GLenum variable, GLenum pname, GLfloat * params
#define glGetCombinerInputParameterfvNV_PACKED PACKED_glGetCombinerInputParameterfvNV
#define glGetCombinerInputParameterfvNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetCombinerInputParameterfvNV_NOT_VOID_WRAP(...) {}
#define pack_glGetCombinerInputParameterfvNV(_stage, _portion, _variable, _pname, _params) ({ \
    glGetCombinerInputParameterfvNV_PACKED *packed_data = malloc(sizeof(glGetCombinerInputParameterfvNV_PACKED)); \
    packed_data->index = glGetCombinerInputParameterfvNV_INDEX; \
    packed_data->args.stage = (GLenum)_stage; \
    packed_data->args.portion = (GLenum)_portion; \
    packed_data->args.variable = (GLenum)_variable; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLfloat *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetCombinerInputParameterfvNV(packed, ret_v) do { \
    PACKED_glGetCombinerInputParameterfvNV *unpacked = (PACKED_glGetCombinerInputParameterfvNV *)packed; \
    ARGS_glGetCombinerInputParameterfvNV *args = (ARGS_glGetCombinerInputParameterfvNV *)&unpacked->args; \
    glGetCombinerInputParameterfvNV(args->stage, args->portion, args->variable, args->pname, args->params);; \
} while(0)
void glGetCombinerInputParameterfvNV(glGetCombinerInputParameterfvNV_ARG_EXPAND);
typedef void (*glGetCombinerInputParameterfvNV_PTR)(glGetCombinerInputParameterfvNV_ARG_EXPAND);
#define glGetCombinerInputParameterivNV_INDEX 741
#define glGetCombinerInputParameterivNV_RETURN void
#define glGetCombinerInputParameterivNV_ARG_NAMES stage, portion, variable, pname, params
#define glGetCombinerInputParameterivNV_ARG_EXPAND GLenum stage, GLenum portion, GLenum variable, GLenum pname, GLint * params
#define glGetCombinerInputParameterivNV_PACKED PACKED_glGetCombinerInputParameterivNV
#define glGetCombinerInputParameterivNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetCombinerInputParameterivNV_NOT_VOID_WRAP(...) {}
#define pack_glGetCombinerInputParameterivNV(_stage, _portion, _variable, _pname, _params) ({ \
    glGetCombinerInputParameterivNV_PACKED *packed_data = malloc(sizeof(glGetCombinerInputParameterivNV_PACKED)); \
    packed_data->index = glGetCombinerInputParameterivNV_INDEX; \
    packed_data->args.stage = (GLenum)_stage; \
    packed_data->args.portion = (GLenum)_portion; \
    packed_data->args.variable = (GLenum)_variable; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetCombinerInputParameterivNV(packed, ret_v) do { \
    PACKED_glGetCombinerInputParameterivNV *unpacked = (PACKED_glGetCombinerInputParameterivNV *)packed; \
    ARGS_glGetCombinerInputParameterivNV *args = (ARGS_glGetCombinerInputParameterivNV *)&unpacked->args; \
    glGetCombinerInputParameterivNV(args->stage, args->portion, args->variable, args->pname, args->params);; \
} while(0)
void glGetCombinerInputParameterivNV(glGetCombinerInputParameterivNV_ARG_EXPAND);
typedef void (*glGetCombinerInputParameterivNV_PTR)(glGetCombinerInputParameterivNV_ARG_EXPAND);
#define glGetCombinerOutputParameterfvNV_INDEX 742
#define glGetCombinerOutputParameterfvNV_RETURN void
#define glGetCombinerOutputParameterfvNV_ARG_NAMES stage, portion, pname, params
#define glGetCombinerOutputParameterfvNV_ARG_EXPAND GLenum stage, GLenum portion, GLenum pname, GLfloat * params
#define glGetCombinerOutputParameterfvNV_PACKED PACKED_glGetCombinerOutputParameterfvNV
#define glGetCombinerOutputParameterfvNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetCombinerOutputParameterfvNV_NOT_VOID_WRAP(...) {}
#define pack_glGetCombinerOutputParameterfvNV(_stage, _portion, _pname, _params) ({ \
    glGetCombinerOutputParameterfvNV_PACKED *packed_data = malloc(sizeof(glGetCombinerOutputParameterfvNV_PACKED)); \
    packed_data->index = glGetCombinerOutputParameterfvNV_INDEX; \
    packed_data->args.stage = (GLenum)_stage; \
    packed_data->args.portion = (GLenum)_portion; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLfloat *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetCombinerOutputParameterfvNV(packed, ret_v) do { \
    PACKED_glGetCombinerOutputParameterfvNV *unpacked = (PACKED_glGetCombinerOutputParameterfvNV *)packed; \
    ARGS_glGetCombinerOutputParameterfvNV *args = (ARGS_glGetCombinerOutputParameterfvNV *)&unpacked->args; \
    glGetCombinerOutputParameterfvNV(args->stage, args->portion, args->pname, args->params);; \
} while(0)
void glGetCombinerOutputParameterfvNV(glGetCombinerOutputParameterfvNV_ARG_EXPAND);
typedef void (*glGetCombinerOutputParameterfvNV_PTR)(glGetCombinerOutputParameterfvNV_ARG_EXPAND);
#define glGetCombinerOutputParameterivNV_INDEX 743
#define glGetCombinerOutputParameterivNV_RETURN void
#define glGetCombinerOutputParameterivNV_ARG_NAMES stage, portion, pname, params
#define glGetCombinerOutputParameterivNV_ARG_EXPAND GLenum stage, GLenum portion, GLenum pname, GLint * params
#define glGetCombinerOutputParameterivNV_PACKED PACKED_glGetCombinerOutputParameterivNV
#define glGetCombinerOutputParameterivNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetCombinerOutputParameterivNV_NOT_VOID_WRAP(...) {}
#define pack_glGetCombinerOutputParameterivNV(_stage, _portion, _pname, _params) ({ \
    glGetCombinerOutputParameterivNV_PACKED *packed_data = malloc(sizeof(glGetCombinerOutputParameterivNV_PACKED)); \
    packed_data->index = glGetCombinerOutputParameterivNV_INDEX; \
    packed_data->args.stage = (GLenum)_stage; \
    packed_data->args.portion = (GLenum)_portion; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetCombinerOutputParameterivNV(packed, ret_v) do { \
    PACKED_glGetCombinerOutputParameterivNV *unpacked = (PACKED_glGetCombinerOutputParameterivNV *)packed; \
    ARGS_glGetCombinerOutputParameterivNV *args = (ARGS_glGetCombinerOutputParameterivNV *)&unpacked->args; \
    glGetCombinerOutputParameterivNV(args->stage, args->portion, args->pname, args->params);; \
} while(0)
void glGetCombinerOutputParameterivNV(glGetCombinerOutputParameterivNV_ARG_EXPAND);
typedef void (*glGetCombinerOutputParameterivNV_PTR)(glGetCombinerOutputParameterivNV_ARG_EXPAND);
#define glGetCombinerStageParameterfvNV_INDEX 744
#define glGetCombinerStageParameterfvNV_RETURN void
#define glGetCombinerStageParameterfvNV_ARG_NAMES stage, pname, params
#define glGetCombinerStageParameterfvNV_ARG_EXPAND GLenum stage, GLenum pname, GLfloat * params
#define glGetCombinerStageParameterfvNV_PACKED PACKED_glGetCombinerStageParameterfvNV
#define glGetCombinerStageParameterfvNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetCombinerStageParameterfvNV_NOT_VOID_WRAP(...) {}
#define pack_glGetCombinerStageParameterfvNV(_stage, _pname, _params) ({ \
    glGetCombinerStageParameterfvNV_PACKED *packed_data = malloc(sizeof(glGetCombinerStageParameterfvNV_PACKED)); \
    packed_data->index = glGetCombinerStageParameterfvNV_INDEX; \
    packed_data->args.stage = (GLenum)_stage; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLfloat *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetCombinerStageParameterfvNV(packed, ret_v) do { \
    PACKED_glGetCombinerStageParameterfvNV *unpacked = (PACKED_glGetCombinerStageParameterfvNV *)packed; \
    ARGS_glGetCombinerStageParameterfvNV *args = (ARGS_glGetCombinerStageParameterfvNV *)&unpacked->args; \
    glGetCombinerStageParameterfvNV(args->stage, args->pname, args->params);; \
} while(0)
void glGetCombinerStageParameterfvNV(glGetCombinerStageParameterfvNV_ARG_EXPAND);
typedef void (*glGetCombinerStageParameterfvNV_PTR)(glGetCombinerStageParameterfvNV_ARG_EXPAND);
#define glGetCompressedMultiTexImageEXT_INDEX 745
#define glGetCompressedMultiTexImageEXT_RETURN void
#define glGetCompressedMultiTexImageEXT_ARG_NAMES texunit, target, lod, img
#define glGetCompressedMultiTexImageEXT_ARG_EXPAND GLenum texunit, GLenum target, GLint lod, GLvoid * img
#define glGetCompressedMultiTexImageEXT_PACKED PACKED_glGetCompressedMultiTexImageEXT
#define glGetCompressedMultiTexImageEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetCompressedMultiTexImageEXT_NOT_VOID_WRAP(...) {}
#define pack_glGetCompressedMultiTexImageEXT(_texunit, _target, _lod, _img) ({ \
    glGetCompressedMultiTexImageEXT_PACKED *packed_data = malloc(sizeof(glGetCompressedMultiTexImageEXT_PACKED)); \
    packed_data->index = glGetCompressedMultiTexImageEXT_INDEX; \
    packed_data->args.texunit = (GLenum)_texunit; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.lod = (GLint)_lod; \
    packed_data->args.img = (GLvoid *)_img; \
    (packed_call_t *)packed_data; \
})
#define call_glGetCompressedMultiTexImageEXT(packed, ret_v) do { \
    PACKED_glGetCompressedMultiTexImageEXT *unpacked = (PACKED_glGetCompressedMultiTexImageEXT *)packed; \
    ARGS_glGetCompressedMultiTexImageEXT *args = (ARGS_glGetCompressedMultiTexImageEXT *)&unpacked->args; \
    glGetCompressedMultiTexImageEXT(args->texunit, args->target, args->lod, args->img);; \
} while(0)
void glGetCompressedMultiTexImageEXT(glGetCompressedMultiTexImageEXT_ARG_EXPAND);
typedef void (*glGetCompressedMultiTexImageEXT_PTR)(glGetCompressedMultiTexImageEXT_ARG_EXPAND);
#define glGetCompressedTexImage_INDEX 746
#define glGetCompressedTexImage_RETURN void
#define glGetCompressedTexImage_ARG_NAMES target, level, img
#define glGetCompressedTexImage_ARG_EXPAND GLenum target, GLint level, GLvoid * img
#define glGetCompressedTexImage_PACKED PACKED_glGetCompressedTexImage
#define glGetCompressedTexImage_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetCompressedTexImage_NOT_VOID_WRAP(...) {}
#define pack_glGetCompressedTexImage(_target, _level, _img) ({ \
    glGetCompressedTexImage_PACKED *packed_data = malloc(sizeof(glGetCompressedTexImage_PACKED)); \
    packed_data->index = glGetCompressedTexImage_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.level = (GLint)_level; \
    packed_data->args.img = (GLvoid *)_img; \
    (packed_call_t *)packed_data; \
})
#define call_glGetCompressedTexImage(packed, ret_v) do { \
    PACKED_glGetCompressedTexImage *unpacked = (PACKED_glGetCompressedTexImage *)packed; \
    ARGS_glGetCompressedTexImage *args = (ARGS_glGetCompressedTexImage *)&unpacked->args; \
    glGetCompressedTexImage(args->target, args->level, args->img);; \
} while(0)
void glGetCompressedTexImage(glGetCompressedTexImage_ARG_EXPAND);
typedef void (*glGetCompressedTexImage_PTR)(glGetCompressedTexImage_ARG_EXPAND);
#define glGetCompressedTexImageARB_INDEX 747
#define glGetCompressedTexImageARB_RETURN void
#define glGetCompressedTexImageARB_ARG_NAMES target, level, img
#define glGetCompressedTexImageARB_ARG_EXPAND GLenum target, GLint level, GLvoid * img
#define glGetCompressedTexImageARB_PACKED PACKED_glGetCompressedTexImageARB
#define glGetCompressedTexImageARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetCompressedTexImageARB_NOT_VOID_WRAP(...) {}
#define pack_glGetCompressedTexImageARB(_target, _level, _img) ({ \
    glGetCompressedTexImageARB_PACKED *packed_data = malloc(sizeof(glGetCompressedTexImageARB_PACKED)); \
    packed_data->index = glGetCompressedTexImageARB_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.level = (GLint)_level; \
    packed_data->args.img = (GLvoid *)_img; \
    (packed_call_t *)packed_data; \
})
#define call_glGetCompressedTexImageARB(packed, ret_v) do { \
    PACKED_glGetCompressedTexImageARB *unpacked = (PACKED_glGetCompressedTexImageARB *)packed; \
    ARGS_glGetCompressedTexImageARB *args = (ARGS_glGetCompressedTexImageARB *)&unpacked->args; \
    glGetCompressedTexImageARB(args->target, args->level, args->img);; \
} while(0)
void glGetCompressedTexImageARB(glGetCompressedTexImageARB_ARG_EXPAND);
typedef void (*glGetCompressedTexImageARB_PTR)(glGetCompressedTexImageARB_ARG_EXPAND);
#define glGetCompressedTextureImageEXT_INDEX 748
#define glGetCompressedTextureImageEXT_RETURN void
#define glGetCompressedTextureImageEXT_ARG_NAMES texture, target, lod, img
#define glGetCompressedTextureImageEXT_ARG_EXPAND GLuint texture, GLenum target, GLint lod, GLvoid * img
#define glGetCompressedTextureImageEXT_PACKED PACKED_glGetCompressedTextureImageEXT
#define glGetCompressedTextureImageEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetCompressedTextureImageEXT_NOT_VOID_WRAP(...) {}
#define pack_glGetCompressedTextureImageEXT(_texture, _target, _lod, _img) ({ \
    glGetCompressedTextureImageEXT_PACKED *packed_data = malloc(sizeof(glGetCompressedTextureImageEXT_PACKED)); \
    packed_data->index = glGetCompressedTextureImageEXT_INDEX; \
    packed_data->args.texture = (GLuint)_texture; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.lod = (GLint)_lod; \
    packed_data->args.img = (GLvoid *)_img; \
    (packed_call_t *)packed_data; \
})
#define call_glGetCompressedTextureImageEXT(packed, ret_v) do { \
    PACKED_glGetCompressedTextureImageEXT *unpacked = (PACKED_glGetCompressedTextureImageEXT *)packed; \
    ARGS_glGetCompressedTextureImageEXT *args = (ARGS_glGetCompressedTextureImageEXT *)&unpacked->args; \
    glGetCompressedTextureImageEXT(args->texture, args->target, args->lod, args->img);; \
} while(0)
void glGetCompressedTextureImageEXT(glGetCompressedTextureImageEXT_ARG_EXPAND);
typedef void (*glGetCompressedTextureImageEXT_PTR)(glGetCompressedTextureImageEXT_ARG_EXPAND);
#define glGetConvolutionFilter_INDEX 749
#define glGetConvolutionFilter_RETURN void
#define glGetConvolutionFilter_ARG_NAMES target, format, type, image
#define glGetConvolutionFilter_ARG_EXPAND GLenum target, GLenum format, GLenum type, GLvoid * image
#define glGetConvolutionFilter_PACKED PACKED_glGetConvolutionFilter
#define glGetConvolutionFilter_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetConvolutionFilter_NOT_VOID_WRAP(...) {}
#define pack_glGetConvolutionFilter(_target, _format, _type, _image) ({ \
    glGetConvolutionFilter_PACKED *packed_data = malloc(sizeof(glGetConvolutionFilter_PACKED)); \
    packed_data->index = glGetConvolutionFilter_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.format = (GLenum)_format; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.image = (GLvoid *)_image; \
    (packed_call_t *)packed_data; \
})
#define call_glGetConvolutionFilter(packed, ret_v) do { \
    PACKED_glGetConvolutionFilter *unpacked = (PACKED_glGetConvolutionFilter *)packed; \
    ARGS_glGetConvolutionFilter *args = (ARGS_glGetConvolutionFilter *)&unpacked->args; \
    glGetConvolutionFilter(args->target, args->format, args->type, args->image);; \
} while(0)
void glGetConvolutionFilter(glGetConvolutionFilter_ARG_EXPAND);
typedef void (*glGetConvolutionFilter_PTR)(glGetConvolutionFilter_ARG_EXPAND);
#define glGetConvolutionFilterEXT_INDEX 750
#define glGetConvolutionFilterEXT_RETURN void
#define glGetConvolutionFilterEXT_ARG_NAMES target, format, type, image
#define glGetConvolutionFilterEXT_ARG_EXPAND GLenum target, GLenum format, GLenum type, GLvoid * image
#define glGetConvolutionFilterEXT_PACKED PACKED_glGetConvolutionFilterEXT
#define glGetConvolutionFilterEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetConvolutionFilterEXT_NOT_VOID_WRAP(...) {}
#define pack_glGetConvolutionFilterEXT(_target, _format, _type, _image) ({ \
    glGetConvolutionFilterEXT_PACKED *packed_data = malloc(sizeof(glGetConvolutionFilterEXT_PACKED)); \
    packed_data->index = glGetConvolutionFilterEXT_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.format = (GLenum)_format; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.image = (GLvoid *)_image; \
    (packed_call_t *)packed_data; \
})
#define call_glGetConvolutionFilterEXT(packed, ret_v) do { \
    PACKED_glGetConvolutionFilterEXT *unpacked = (PACKED_glGetConvolutionFilterEXT *)packed; \
    ARGS_glGetConvolutionFilterEXT *args = (ARGS_glGetConvolutionFilterEXT *)&unpacked->args; \
    glGetConvolutionFilterEXT(args->target, args->format, args->type, args->image);; \
} while(0)
void glGetConvolutionFilterEXT(glGetConvolutionFilterEXT_ARG_EXPAND);
typedef void (*glGetConvolutionFilterEXT_PTR)(glGetConvolutionFilterEXT_ARG_EXPAND);
#define glGetConvolutionParameterfv_INDEX 751
#define glGetConvolutionParameterfv_RETURN void
#define glGetConvolutionParameterfv_ARG_NAMES target, pname, params
#define glGetConvolutionParameterfv_ARG_EXPAND GLenum target, GLenum pname, GLfloat * params
#define glGetConvolutionParameterfv_PACKED PACKED_glGetConvolutionParameterfv
#define glGetConvolutionParameterfv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetConvolutionParameterfv_NOT_VOID_WRAP(...) {}
#define pack_glGetConvolutionParameterfv(_target, _pname, _params) ({ \
    glGetConvolutionParameterfv_PACKED *packed_data = malloc(sizeof(glGetConvolutionParameterfv_PACKED)); \
    packed_data->index = glGetConvolutionParameterfv_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLfloat *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetConvolutionParameterfv(packed, ret_v) do { \
    PACKED_glGetConvolutionParameterfv *unpacked = (PACKED_glGetConvolutionParameterfv *)packed; \
    ARGS_glGetConvolutionParameterfv *args = (ARGS_glGetConvolutionParameterfv *)&unpacked->args; \
    glGetConvolutionParameterfv(args->target, args->pname, args->params);; \
} while(0)
void glGetConvolutionParameterfv(glGetConvolutionParameterfv_ARG_EXPAND);
typedef void (*glGetConvolutionParameterfv_PTR)(glGetConvolutionParameterfv_ARG_EXPAND);
#define glGetConvolutionParameterfvEXT_INDEX 752
#define glGetConvolutionParameterfvEXT_RETURN void
#define glGetConvolutionParameterfvEXT_ARG_NAMES target, pname, params
#define glGetConvolutionParameterfvEXT_ARG_EXPAND GLenum target, GLenum pname, GLfloat * params
#define glGetConvolutionParameterfvEXT_PACKED PACKED_glGetConvolutionParameterfvEXT
#define glGetConvolutionParameterfvEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetConvolutionParameterfvEXT_NOT_VOID_WRAP(...) {}
#define pack_glGetConvolutionParameterfvEXT(_target, _pname, _params) ({ \
    glGetConvolutionParameterfvEXT_PACKED *packed_data = malloc(sizeof(glGetConvolutionParameterfvEXT_PACKED)); \
    packed_data->index = glGetConvolutionParameterfvEXT_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLfloat *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetConvolutionParameterfvEXT(packed, ret_v) do { \
    PACKED_glGetConvolutionParameterfvEXT *unpacked = (PACKED_glGetConvolutionParameterfvEXT *)packed; \
    ARGS_glGetConvolutionParameterfvEXT *args = (ARGS_glGetConvolutionParameterfvEXT *)&unpacked->args; \
    glGetConvolutionParameterfvEXT(args->target, args->pname, args->params);; \
} while(0)
void glGetConvolutionParameterfvEXT(glGetConvolutionParameterfvEXT_ARG_EXPAND);
typedef void (*glGetConvolutionParameterfvEXT_PTR)(glGetConvolutionParameterfvEXT_ARG_EXPAND);
#define glGetConvolutionParameteriv_INDEX 753
#define glGetConvolutionParameteriv_RETURN void
#define glGetConvolutionParameteriv_ARG_NAMES target, pname, params
#define glGetConvolutionParameteriv_ARG_EXPAND GLenum target, GLenum pname, GLint * params
#define glGetConvolutionParameteriv_PACKED PACKED_glGetConvolutionParameteriv
#define glGetConvolutionParameteriv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetConvolutionParameteriv_NOT_VOID_WRAP(...) {}
#define pack_glGetConvolutionParameteriv(_target, _pname, _params) ({ \
    glGetConvolutionParameteriv_PACKED *packed_data = malloc(sizeof(glGetConvolutionParameteriv_PACKED)); \
    packed_data->index = glGetConvolutionParameteriv_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetConvolutionParameteriv(packed, ret_v) do { \
    PACKED_glGetConvolutionParameteriv *unpacked = (PACKED_glGetConvolutionParameteriv *)packed; \
    ARGS_glGetConvolutionParameteriv *args = (ARGS_glGetConvolutionParameteriv *)&unpacked->args; \
    glGetConvolutionParameteriv(args->target, args->pname, args->params);; \
} while(0)
void glGetConvolutionParameteriv(glGetConvolutionParameteriv_ARG_EXPAND);
typedef void (*glGetConvolutionParameteriv_PTR)(glGetConvolutionParameteriv_ARG_EXPAND);
#define glGetConvolutionParameterivEXT_INDEX 754
#define glGetConvolutionParameterivEXT_RETURN void
#define glGetConvolutionParameterivEXT_ARG_NAMES target, pname, params
#define glGetConvolutionParameterivEXT_ARG_EXPAND GLenum target, GLenum pname, GLint * params
#define glGetConvolutionParameterivEXT_PACKED PACKED_glGetConvolutionParameterivEXT
#define glGetConvolutionParameterivEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetConvolutionParameterivEXT_NOT_VOID_WRAP(...) {}
#define pack_glGetConvolutionParameterivEXT(_target, _pname, _params) ({ \
    glGetConvolutionParameterivEXT_PACKED *packed_data = malloc(sizeof(glGetConvolutionParameterivEXT_PACKED)); \
    packed_data->index = glGetConvolutionParameterivEXT_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetConvolutionParameterivEXT(packed, ret_v) do { \
    PACKED_glGetConvolutionParameterivEXT *unpacked = (PACKED_glGetConvolutionParameterivEXT *)packed; \
    ARGS_glGetConvolutionParameterivEXT *args = (ARGS_glGetConvolutionParameterivEXT *)&unpacked->args; \
    glGetConvolutionParameterivEXT(args->target, args->pname, args->params);; \
} while(0)
void glGetConvolutionParameterivEXT(glGetConvolutionParameterivEXT_ARG_EXPAND);
typedef void (*glGetConvolutionParameterivEXT_PTR)(glGetConvolutionParameterivEXT_ARG_EXPAND);
#define glGetConvolutionParameterxvOES_INDEX 755
#define glGetConvolutionParameterxvOES_RETURN void
#define glGetConvolutionParameterxvOES_ARG_NAMES target, pname, params
#define glGetConvolutionParameterxvOES_ARG_EXPAND GLenum target, GLenum pname, GLfixed * params
#define glGetConvolutionParameterxvOES_PACKED PACKED_glGetConvolutionParameterxvOES
#define glGetConvolutionParameterxvOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetConvolutionParameterxvOES_NOT_VOID_WRAP(...) {}
#define pack_glGetConvolutionParameterxvOES(_target, _pname, _params) ({ \
    glGetConvolutionParameterxvOES_PACKED *packed_data = malloc(sizeof(glGetConvolutionParameterxvOES_PACKED)); \
    packed_data->index = glGetConvolutionParameterxvOES_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLfixed *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetConvolutionParameterxvOES(packed, ret_v) do { \
    PACKED_glGetConvolutionParameterxvOES *unpacked = (PACKED_glGetConvolutionParameterxvOES *)packed; \
    ARGS_glGetConvolutionParameterxvOES *args = (ARGS_glGetConvolutionParameterxvOES *)&unpacked->args; \
    glGetConvolutionParameterxvOES(args->target, args->pname, args->params);; \
} while(0)
void glGetConvolutionParameterxvOES(glGetConvolutionParameterxvOES_ARG_EXPAND);
typedef void (*glGetConvolutionParameterxvOES_PTR)(glGetConvolutionParameterxvOES_ARG_EXPAND);
#define glGetDebugMessageLog_INDEX 756
#define glGetDebugMessageLog_RETURN GLuint
#define glGetDebugMessageLog_ARG_NAMES count, bufsize, sources, types, ids, severities, lengths, messageLog
#define glGetDebugMessageLog_ARG_EXPAND GLuint count, GLsizei bufsize, GLenum * sources, GLenum * types, GLuint * ids, GLenum * severities, GLsizei * lengths, GLchar * messageLog
#define glGetDebugMessageLog_PACKED PACKED_glGetDebugMessageLog
#define glGetDebugMessageLog_VOID_ONLY_WRAP(...) {}
#define glGetDebugMessageLog_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glGetDebugMessageLog(_count, _bufsize, _sources, _types, _ids, _severities, _lengths, _messageLog) ({ \
    glGetDebugMessageLog_PACKED *packed_data = malloc(sizeof(glGetDebugMessageLog_PACKED)); \
    packed_data->index = glGetDebugMessageLog_INDEX; \
    packed_data->args.count = (GLuint)_count; \
    packed_data->args.bufsize = (GLsizei)_bufsize; \
    packed_data->args.sources = (GLenum *)_sources; \
    packed_data->args.types = (GLenum *)_types; \
    packed_data->args.ids = (GLuint *)_ids; \
    packed_data->args.severities = (GLenum *)_severities; \
    packed_data->args.lengths = (GLsizei *)_lengths; \
    packed_data->args.messageLog = (GLchar *)_messageLog; \
    (packed_call_t *)packed_data; \
})
#define call_glGetDebugMessageLog(packed, ret_v) do { \
    PACKED_glGetDebugMessageLog *unpacked = (PACKED_glGetDebugMessageLog *)packed; \
    ARGS_glGetDebugMessageLog *args = (ARGS_glGetDebugMessageLog *)&unpacked->args; \
    GLuint *ret = (GLuint *)ret_v; \
    if (ret != NULL) { \
        *ret = glGetDebugMessageLog(args->count, args->bufsize, args->sources, args->types, args->ids, args->severities, args->lengths, args->messageLog);; \
    } else { \
        glGetDebugMessageLog(args->count, args->bufsize, args->sources, args->types, args->ids, args->severities, args->lengths, args->messageLog);; \
    } \
} while(0)
GLuint glGetDebugMessageLog(glGetDebugMessageLog_ARG_EXPAND);
typedef GLuint (*glGetDebugMessageLog_PTR)(glGetDebugMessageLog_ARG_EXPAND);
#define glGetDebugMessageLogAMD_INDEX 757
#define glGetDebugMessageLogAMD_RETURN GLuint
#define glGetDebugMessageLogAMD_ARG_NAMES count, bufsize, categories, severities, ids, lengths, message
#define glGetDebugMessageLogAMD_ARG_EXPAND GLuint count, GLsizei bufsize, GLenum * categories, GLuint * severities, GLuint * ids, GLsizei * lengths, GLchar * message
#define glGetDebugMessageLogAMD_PACKED PACKED_glGetDebugMessageLogAMD
#define glGetDebugMessageLogAMD_VOID_ONLY_WRAP(...) {}
#define glGetDebugMessageLogAMD_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glGetDebugMessageLogAMD(_count, _bufsize, _categories, _severities, _ids, _lengths, _message) ({ \
    glGetDebugMessageLogAMD_PACKED *packed_data = malloc(sizeof(glGetDebugMessageLogAMD_PACKED)); \
    packed_data->index = glGetDebugMessageLogAMD_INDEX; \
    packed_data->args.count = (GLuint)_count; \
    packed_data->args.bufsize = (GLsizei)_bufsize; \
    packed_data->args.categories = (GLenum *)_categories; \
    packed_data->args.severities = (GLuint *)_severities; \
    packed_data->args.ids = (GLuint *)_ids; \
    packed_data->args.lengths = (GLsizei *)_lengths; \
    packed_data->args.message = (GLchar *)_message; \
    (packed_call_t *)packed_data; \
})
#define call_glGetDebugMessageLogAMD(packed, ret_v) do { \
    PACKED_glGetDebugMessageLogAMD *unpacked = (PACKED_glGetDebugMessageLogAMD *)packed; \
    ARGS_glGetDebugMessageLogAMD *args = (ARGS_glGetDebugMessageLogAMD *)&unpacked->args; \
    GLuint *ret = (GLuint *)ret_v; \
    if (ret != NULL) { \
        *ret = glGetDebugMessageLogAMD(args->count, args->bufsize, args->categories, args->severities, args->ids, args->lengths, args->message);; \
    } else { \
        glGetDebugMessageLogAMD(args->count, args->bufsize, args->categories, args->severities, args->ids, args->lengths, args->message);; \
    } \
} while(0)
GLuint glGetDebugMessageLogAMD(glGetDebugMessageLogAMD_ARG_EXPAND);
typedef GLuint (*glGetDebugMessageLogAMD_PTR)(glGetDebugMessageLogAMD_ARG_EXPAND);
#define glGetDebugMessageLogARB_INDEX 758
#define glGetDebugMessageLogARB_RETURN GLuint
#define glGetDebugMessageLogARB_ARG_NAMES count, bufsize, sources, types, ids, severities, lengths, messageLog
#define glGetDebugMessageLogARB_ARG_EXPAND GLuint count, GLsizei bufsize, GLenum * sources, GLenum * types, GLuint * ids, GLenum * severities, GLsizei * lengths, GLchar * messageLog
#define glGetDebugMessageLogARB_PACKED PACKED_glGetDebugMessageLogARB
#define glGetDebugMessageLogARB_VOID_ONLY_WRAP(...) {}
#define glGetDebugMessageLogARB_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glGetDebugMessageLogARB(_count, _bufsize, _sources, _types, _ids, _severities, _lengths, _messageLog) ({ \
    glGetDebugMessageLogARB_PACKED *packed_data = malloc(sizeof(glGetDebugMessageLogARB_PACKED)); \
    packed_data->index = glGetDebugMessageLogARB_INDEX; \
    packed_data->args.count = (GLuint)_count; \
    packed_data->args.bufsize = (GLsizei)_bufsize; \
    packed_data->args.sources = (GLenum *)_sources; \
    packed_data->args.types = (GLenum *)_types; \
    packed_data->args.ids = (GLuint *)_ids; \
    packed_data->args.severities = (GLenum *)_severities; \
    packed_data->args.lengths = (GLsizei *)_lengths; \
    packed_data->args.messageLog = (GLchar *)_messageLog; \
    (packed_call_t *)packed_data; \
})
#define call_glGetDebugMessageLogARB(packed, ret_v) do { \
    PACKED_glGetDebugMessageLogARB *unpacked = (PACKED_glGetDebugMessageLogARB *)packed; \
    ARGS_glGetDebugMessageLogARB *args = (ARGS_glGetDebugMessageLogARB *)&unpacked->args; \
    GLuint *ret = (GLuint *)ret_v; \
    if (ret != NULL) { \
        *ret = glGetDebugMessageLogARB(args->count, args->bufsize, args->sources, args->types, args->ids, args->severities, args->lengths, args->messageLog);; \
    } else { \
        glGetDebugMessageLogARB(args->count, args->bufsize, args->sources, args->types, args->ids, args->severities, args->lengths, args->messageLog);; \
    } \
} while(0)
GLuint glGetDebugMessageLogARB(glGetDebugMessageLogARB_ARG_EXPAND);
typedef GLuint (*glGetDebugMessageLogARB_PTR)(glGetDebugMessageLogARB_ARG_EXPAND);
#define glGetDetailTexFuncSGIS_INDEX 759
#define glGetDetailTexFuncSGIS_RETURN void
#define glGetDetailTexFuncSGIS_ARG_NAMES target, points
#define glGetDetailTexFuncSGIS_ARG_EXPAND GLenum target, GLfloat * points
#define glGetDetailTexFuncSGIS_PACKED PACKED_glGetDetailTexFuncSGIS
#define glGetDetailTexFuncSGIS_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetDetailTexFuncSGIS_NOT_VOID_WRAP(...) {}
#define pack_glGetDetailTexFuncSGIS(_target, _points) ({ \
    glGetDetailTexFuncSGIS_PACKED *packed_data = malloc(sizeof(glGetDetailTexFuncSGIS_PACKED)); \
    packed_data->index = glGetDetailTexFuncSGIS_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.points = (GLfloat *)_points; \
    (packed_call_t *)packed_data; \
})
#define call_glGetDetailTexFuncSGIS(packed, ret_v) do { \
    PACKED_glGetDetailTexFuncSGIS *unpacked = (PACKED_glGetDetailTexFuncSGIS *)packed; \
    ARGS_glGetDetailTexFuncSGIS *args = (ARGS_glGetDetailTexFuncSGIS *)&unpacked->args; \
    glGetDetailTexFuncSGIS(args->target, args->points);; \
} while(0)
void glGetDetailTexFuncSGIS(glGetDetailTexFuncSGIS_ARG_EXPAND);
typedef void (*glGetDetailTexFuncSGIS_PTR)(glGetDetailTexFuncSGIS_ARG_EXPAND);
#define glGetDoubleIndexedvEXT_INDEX 760
#define glGetDoubleIndexedvEXT_RETURN void
#define glGetDoubleIndexedvEXT_ARG_NAMES target, index, data
#define glGetDoubleIndexedvEXT_ARG_EXPAND GLenum target, GLuint index, GLdouble * data
#define glGetDoubleIndexedvEXT_PACKED PACKED_glGetDoubleIndexedvEXT
#define glGetDoubleIndexedvEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetDoubleIndexedvEXT_NOT_VOID_WRAP(...) {}
#define pack_glGetDoubleIndexedvEXT(_target, _index, _data) ({ \
    glGetDoubleIndexedvEXT_PACKED *packed_data = malloc(sizeof(glGetDoubleIndexedvEXT_PACKED)); \
    packed_data->index = glGetDoubleIndexedvEXT_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.data = (GLdouble *)_data; \
    (packed_call_t *)packed_data; \
})
#define call_glGetDoubleIndexedvEXT(packed, ret_v) do { \
    PACKED_glGetDoubleIndexedvEXT *unpacked = (PACKED_glGetDoubleIndexedvEXT *)packed; \
    ARGS_glGetDoubleIndexedvEXT *args = (ARGS_glGetDoubleIndexedvEXT *)&unpacked->args; \
    glGetDoubleIndexedvEXT(args->target, args->index, args->data);; \
} while(0)
void glGetDoubleIndexedvEXT(glGetDoubleIndexedvEXT_ARG_EXPAND);
typedef void (*glGetDoubleIndexedvEXT_PTR)(glGetDoubleIndexedvEXT_ARG_EXPAND);
#define glGetDoublei_v_INDEX 761
#define glGetDoublei_v_RETURN void
#define glGetDoublei_v_ARG_NAMES target, index, data
#define glGetDoublei_v_ARG_EXPAND GLenum target, GLuint index, GLdouble * data
#define glGetDoublei_v_PACKED PACKED_glGetDoublei_v
#define glGetDoublei_v_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetDoublei_v_NOT_VOID_WRAP(...) {}
#define pack_glGetDoublei_v(_target, _index, _data) ({ \
    glGetDoublei_v_PACKED *packed_data = malloc(sizeof(glGetDoublei_v_PACKED)); \
    packed_data->index = glGetDoublei_v_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.data = (GLdouble *)_data; \
    (packed_call_t *)packed_data; \
})
#define call_glGetDoublei_v(packed, ret_v) do { \
    PACKED_glGetDoublei_v *unpacked = (PACKED_glGetDoublei_v *)packed; \
    ARGS_glGetDoublei_v *args = (ARGS_glGetDoublei_v *)&unpacked->args; \
    glGetDoublei_v(args->target, args->index, args->data);; \
} while(0)
void glGetDoublei_v(glGetDoublei_v_ARG_EXPAND);
typedef void (*glGetDoublei_v_PTR)(glGetDoublei_v_ARG_EXPAND);
#define glGetDoublei_vEXT_INDEX 762
#define glGetDoublei_vEXT_RETURN void
#define glGetDoublei_vEXT_ARG_NAMES target, index, data
#define glGetDoublei_vEXT_ARG_EXPAND GLenum target, GLuint index, GLdouble * data
#define glGetDoublei_vEXT_PACKED PACKED_glGetDoublei_vEXT
#define glGetDoublei_vEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetDoublei_vEXT_NOT_VOID_WRAP(...) {}
#define pack_glGetDoublei_vEXT(_target, _index, _data) ({ \
    glGetDoublei_vEXT_PACKED *packed_data = malloc(sizeof(glGetDoublei_vEXT_PACKED)); \
    packed_data->index = glGetDoublei_vEXT_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.data = (GLdouble *)_data; \
    (packed_call_t *)packed_data; \
})
#define call_glGetDoublei_vEXT(packed, ret_v) do { \
    PACKED_glGetDoublei_vEXT *unpacked = (PACKED_glGetDoublei_vEXT *)packed; \
    ARGS_glGetDoublei_vEXT *args = (ARGS_glGetDoublei_vEXT *)&unpacked->args; \
    glGetDoublei_vEXT(args->target, args->index, args->data);; \
} while(0)
void glGetDoublei_vEXT(glGetDoublei_vEXT_ARG_EXPAND);
typedef void (*glGetDoublei_vEXT_PTR)(glGetDoublei_vEXT_ARG_EXPAND);
#define glGetDoublev_INDEX 763
#define glGetDoublev_RETURN void
#define glGetDoublev_ARG_NAMES pname, params
#define glGetDoublev_ARG_EXPAND GLenum pname, GLdouble * params
#define glGetDoublev_PACKED PACKED_glGetDoublev
#define glGetDoublev_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetDoublev_NOT_VOID_WRAP(...) {}
#define pack_glGetDoublev(_pname, _params) ({ \
    glGetDoublev_PACKED *packed_data = malloc(sizeof(glGetDoublev_PACKED)); \
    packed_data->index = glGetDoublev_INDEX; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLdouble *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetDoublev(packed, ret_v) do { \
    PACKED_glGetDoublev *unpacked = (PACKED_glGetDoublev *)packed; \
    ARGS_glGetDoublev *args = (ARGS_glGetDoublev *)&unpacked->args; \
    glGetDoublev(args->pname, args->params);; \
} while(0)
void glGetDoublev(glGetDoublev_ARG_EXPAND);
typedef void (*glGetDoublev_PTR)(glGetDoublev_ARG_EXPAND);
#define glGetError_INDEX 764
#define glGetError_RETURN GLenum
#define glGetError_ARG_NAMES 
#define glGetError_ARG_EXPAND 
#define glGetError_PACKED PACKED_glGetError
#define glGetError_VOID_ONLY_WRAP(...) {}
#define glGetError_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glGetError() ({ \
    glGetError_PACKED *packed_data = malloc(sizeof(glGetError_PACKED)); \
    packed_data->index = glGetError_INDEX; \
    (packed_call_t *)packed_data; \
})
#define call_glGetError(packed, ret_v) do { \
    GLenum *ret = (GLenum *)ret_v; \
    if (ret != NULL) { \
        *ret = glGetError();; \
    } else { \
        glGetError();; \
    } \
} while(0)
GLenum glGetError(glGetError_ARG_EXPAND);
typedef GLenum (*glGetError_PTR)(glGetError_ARG_EXPAND);
#define glGetFenceivNV_INDEX 765
#define glGetFenceivNV_RETURN void
#define glGetFenceivNV_ARG_NAMES fence, pname, params
#define glGetFenceivNV_ARG_EXPAND GLuint fence, GLenum pname, GLint * params
#define glGetFenceivNV_PACKED PACKED_glGetFenceivNV
#define glGetFenceivNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetFenceivNV_NOT_VOID_WRAP(...) {}
#define pack_glGetFenceivNV(_fence, _pname, _params) ({ \
    glGetFenceivNV_PACKED *packed_data = malloc(sizeof(glGetFenceivNV_PACKED)); \
    packed_data->index = glGetFenceivNV_INDEX; \
    packed_data->args.fence = (GLuint)_fence; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetFenceivNV(packed, ret_v) do { \
    PACKED_glGetFenceivNV *unpacked = (PACKED_glGetFenceivNV *)packed; \
    ARGS_glGetFenceivNV *args = (ARGS_glGetFenceivNV *)&unpacked->args; \
    glGetFenceivNV(args->fence, args->pname, args->params);; \
} while(0)
void glGetFenceivNV(glGetFenceivNV_ARG_EXPAND);
typedef void (*glGetFenceivNV_PTR)(glGetFenceivNV_ARG_EXPAND);
#define glGetFinalCombinerInputParameterfvNV_INDEX 766
#define glGetFinalCombinerInputParameterfvNV_RETURN void
#define glGetFinalCombinerInputParameterfvNV_ARG_NAMES variable, pname, params
#define glGetFinalCombinerInputParameterfvNV_ARG_EXPAND GLenum variable, GLenum pname, GLfloat * params
#define glGetFinalCombinerInputParameterfvNV_PACKED PACKED_glGetFinalCombinerInputParameterfvNV
#define glGetFinalCombinerInputParameterfvNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetFinalCombinerInputParameterfvNV_NOT_VOID_WRAP(...) {}
#define pack_glGetFinalCombinerInputParameterfvNV(_variable, _pname, _params) ({ \
    glGetFinalCombinerInputParameterfvNV_PACKED *packed_data = malloc(sizeof(glGetFinalCombinerInputParameterfvNV_PACKED)); \
    packed_data->index = glGetFinalCombinerInputParameterfvNV_INDEX; \
    packed_data->args.variable = (GLenum)_variable; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLfloat *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetFinalCombinerInputParameterfvNV(packed, ret_v) do { \
    PACKED_glGetFinalCombinerInputParameterfvNV *unpacked = (PACKED_glGetFinalCombinerInputParameterfvNV *)packed; \
    ARGS_glGetFinalCombinerInputParameterfvNV *args = (ARGS_glGetFinalCombinerInputParameterfvNV *)&unpacked->args; \
    glGetFinalCombinerInputParameterfvNV(args->variable, args->pname, args->params);; \
} while(0)
void glGetFinalCombinerInputParameterfvNV(glGetFinalCombinerInputParameterfvNV_ARG_EXPAND);
typedef void (*glGetFinalCombinerInputParameterfvNV_PTR)(glGetFinalCombinerInputParameterfvNV_ARG_EXPAND);
#define glGetFinalCombinerInputParameterivNV_INDEX 767
#define glGetFinalCombinerInputParameterivNV_RETURN void
#define glGetFinalCombinerInputParameterivNV_ARG_NAMES variable, pname, params
#define glGetFinalCombinerInputParameterivNV_ARG_EXPAND GLenum variable, GLenum pname, GLint * params
#define glGetFinalCombinerInputParameterivNV_PACKED PACKED_glGetFinalCombinerInputParameterivNV
#define glGetFinalCombinerInputParameterivNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetFinalCombinerInputParameterivNV_NOT_VOID_WRAP(...) {}
#define pack_glGetFinalCombinerInputParameterivNV(_variable, _pname, _params) ({ \
    glGetFinalCombinerInputParameterivNV_PACKED *packed_data = malloc(sizeof(glGetFinalCombinerInputParameterivNV_PACKED)); \
    packed_data->index = glGetFinalCombinerInputParameterivNV_INDEX; \
    packed_data->args.variable = (GLenum)_variable; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetFinalCombinerInputParameterivNV(packed, ret_v) do { \
    PACKED_glGetFinalCombinerInputParameterivNV *unpacked = (PACKED_glGetFinalCombinerInputParameterivNV *)packed; \
    ARGS_glGetFinalCombinerInputParameterivNV *args = (ARGS_glGetFinalCombinerInputParameterivNV *)&unpacked->args; \
    glGetFinalCombinerInputParameterivNV(args->variable, args->pname, args->params);; \
} while(0)
void glGetFinalCombinerInputParameterivNV(glGetFinalCombinerInputParameterivNV_ARG_EXPAND);
typedef void (*glGetFinalCombinerInputParameterivNV_PTR)(glGetFinalCombinerInputParameterivNV_ARG_EXPAND);
#define glGetFixedv_INDEX 768
#define glGetFixedv_RETURN void
#define glGetFixedv_ARG_NAMES pname, params
#define glGetFixedv_ARG_EXPAND GLenum pname, GLfixed * params
#define glGetFixedv_PACKED PACKED_glGetFixedv
#define glGetFixedv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetFixedv_NOT_VOID_WRAP(...) {}
#define pack_glGetFixedv(_pname, _params) ({ \
    glGetFixedv_PACKED *packed_data = malloc(sizeof(glGetFixedv_PACKED)); \
    packed_data->index = glGetFixedv_INDEX; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLfixed *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetFixedv(packed, ret_v) do { \
    PACKED_glGetFixedv *unpacked = (PACKED_glGetFixedv *)packed; \
    ARGS_glGetFixedv *args = (ARGS_glGetFixedv *)&unpacked->args; \
    glGetFixedv(args->pname, args->params);; \
} while(0)
void glGetFixedv(glGetFixedv_ARG_EXPAND);
typedef void (*glGetFixedv_PTR)(glGetFixedv_ARG_EXPAND);
#define glGetFixedvOES_INDEX 769
#define glGetFixedvOES_RETURN void
#define glGetFixedvOES_ARG_NAMES pname, params
#define glGetFixedvOES_ARG_EXPAND GLenum pname, GLfixed * params
#define glGetFixedvOES_PACKED PACKED_glGetFixedvOES
#define glGetFixedvOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetFixedvOES_NOT_VOID_WRAP(...) {}
#define pack_glGetFixedvOES(_pname, _params) ({ \
    glGetFixedvOES_PACKED *packed_data = malloc(sizeof(glGetFixedvOES_PACKED)); \
    packed_data->index = glGetFixedvOES_INDEX; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLfixed *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetFixedvOES(packed, ret_v) do { \
    PACKED_glGetFixedvOES *unpacked = (PACKED_glGetFixedvOES *)packed; \
    ARGS_glGetFixedvOES *args = (ARGS_glGetFixedvOES *)&unpacked->args; \
    glGetFixedvOES(args->pname, args->params);; \
} while(0)
void glGetFixedvOES(glGetFixedvOES_ARG_EXPAND);
typedef void (*glGetFixedvOES_PTR)(glGetFixedvOES_ARG_EXPAND);
#define glGetFloatIndexedvEXT_INDEX 770
#define glGetFloatIndexedvEXT_RETURN void
#define glGetFloatIndexedvEXT_ARG_NAMES target, index, data
#define glGetFloatIndexedvEXT_ARG_EXPAND GLenum target, GLuint index, GLfloat * data
#define glGetFloatIndexedvEXT_PACKED PACKED_glGetFloatIndexedvEXT
#define glGetFloatIndexedvEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetFloatIndexedvEXT_NOT_VOID_WRAP(...) {}
#define pack_glGetFloatIndexedvEXT(_target, _index, _data) ({ \
    glGetFloatIndexedvEXT_PACKED *packed_data = malloc(sizeof(glGetFloatIndexedvEXT_PACKED)); \
    packed_data->index = glGetFloatIndexedvEXT_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.data = (GLfloat *)_data; \
    (packed_call_t *)packed_data; \
})
#define call_glGetFloatIndexedvEXT(packed, ret_v) do { \
    PACKED_glGetFloatIndexedvEXT *unpacked = (PACKED_glGetFloatIndexedvEXT *)packed; \
    ARGS_glGetFloatIndexedvEXT *args = (ARGS_glGetFloatIndexedvEXT *)&unpacked->args; \
    glGetFloatIndexedvEXT(args->target, args->index, args->data);; \
} while(0)
void glGetFloatIndexedvEXT(glGetFloatIndexedvEXT_ARG_EXPAND);
typedef void (*glGetFloatIndexedvEXT_PTR)(glGetFloatIndexedvEXT_ARG_EXPAND);
#define glGetFloati_v_INDEX 771
#define glGetFloati_v_RETURN void
#define glGetFloati_v_ARG_NAMES target, index, data
#define glGetFloati_v_ARG_EXPAND GLenum target, GLuint index, GLfloat * data
#define glGetFloati_v_PACKED PACKED_glGetFloati_v
#define glGetFloati_v_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetFloati_v_NOT_VOID_WRAP(...) {}
#define pack_glGetFloati_v(_target, _index, _data) ({ \
    glGetFloati_v_PACKED *packed_data = malloc(sizeof(glGetFloati_v_PACKED)); \
    packed_data->index = glGetFloati_v_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.data = (GLfloat *)_data; \
    (packed_call_t *)packed_data; \
})
#define call_glGetFloati_v(packed, ret_v) do { \
    PACKED_glGetFloati_v *unpacked = (PACKED_glGetFloati_v *)packed; \
    ARGS_glGetFloati_v *args = (ARGS_glGetFloati_v *)&unpacked->args; \
    glGetFloati_v(args->target, args->index, args->data);; \
} while(0)
void glGetFloati_v(glGetFloati_v_ARG_EXPAND);
typedef void (*glGetFloati_v_PTR)(glGetFloati_v_ARG_EXPAND);
#define glGetFloati_vEXT_INDEX 772
#define glGetFloati_vEXT_RETURN void
#define glGetFloati_vEXT_ARG_NAMES target, index, data
#define glGetFloati_vEXT_ARG_EXPAND GLenum target, GLuint index, GLfloat * data
#define glGetFloati_vEXT_PACKED PACKED_glGetFloati_vEXT
#define glGetFloati_vEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetFloati_vEXT_NOT_VOID_WRAP(...) {}
#define pack_glGetFloati_vEXT(_target, _index, _data) ({ \
    glGetFloati_vEXT_PACKED *packed_data = malloc(sizeof(glGetFloati_vEXT_PACKED)); \
    packed_data->index = glGetFloati_vEXT_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.data = (GLfloat *)_data; \
    (packed_call_t *)packed_data; \
})
#define call_glGetFloati_vEXT(packed, ret_v) do { \
    PACKED_glGetFloati_vEXT *unpacked = (PACKED_glGetFloati_vEXT *)packed; \
    ARGS_glGetFloati_vEXT *args = (ARGS_glGetFloati_vEXT *)&unpacked->args; \
    glGetFloati_vEXT(args->target, args->index, args->data);; \
} while(0)
void glGetFloati_vEXT(glGetFloati_vEXT_ARG_EXPAND);
typedef void (*glGetFloati_vEXT_PTR)(glGetFloati_vEXT_ARG_EXPAND);
#define glGetFloatv_INDEX 773
#define glGetFloatv_RETURN void
#define glGetFloatv_ARG_NAMES pname, params
#define glGetFloatv_ARG_EXPAND GLenum pname, GLfloat * params
#define glGetFloatv_PACKED PACKED_glGetFloatv
#define glGetFloatv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetFloatv_NOT_VOID_WRAP(...) {}
#define pack_glGetFloatv(_pname, _params) ({ \
    glGetFloatv_PACKED *packed_data = malloc(sizeof(glGetFloatv_PACKED)); \
    packed_data->index = glGetFloatv_INDEX; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLfloat *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetFloatv(packed, ret_v) do { \
    PACKED_glGetFloatv *unpacked = (PACKED_glGetFloatv *)packed; \
    ARGS_glGetFloatv *args = (ARGS_glGetFloatv *)&unpacked->args; \
    glGetFloatv(args->pname, args->params);; \
} while(0)
void glGetFloatv(glGetFloatv_ARG_EXPAND);
typedef void (*glGetFloatv_PTR)(glGetFloatv_ARG_EXPAND);
#define glGetFogFuncSGIS_INDEX 774
#define glGetFogFuncSGIS_RETURN void
#define glGetFogFuncSGIS_ARG_NAMES points
#define glGetFogFuncSGIS_ARG_EXPAND GLfloat * points
#define glGetFogFuncSGIS_PACKED PACKED_glGetFogFuncSGIS
#define glGetFogFuncSGIS_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetFogFuncSGIS_NOT_VOID_WRAP(...) {}
#define pack_glGetFogFuncSGIS(_points) ({ \
    glGetFogFuncSGIS_PACKED *packed_data = malloc(sizeof(glGetFogFuncSGIS_PACKED)); \
    packed_data->index = glGetFogFuncSGIS_INDEX; \
    packed_data->args.points = (GLfloat *)_points; \
    (packed_call_t *)packed_data; \
})
#define call_glGetFogFuncSGIS(packed, ret_v) do { \
    PACKED_glGetFogFuncSGIS *unpacked = (PACKED_glGetFogFuncSGIS *)packed; \
    ARGS_glGetFogFuncSGIS *args = (ARGS_glGetFogFuncSGIS *)&unpacked->args; \
    glGetFogFuncSGIS(args->points);; \
} while(0)
void glGetFogFuncSGIS(glGetFogFuncSGIS_ARG_EXPAND);
typedef void (*glGetFogFuncSGIS_PTR)(glGetFogFuncSGIS_ARG_EXPAND);
#define glGetFragDataIndex_INDEX 775
#define glGetFragDataIndex_RETURN GLint
#define glGetFragDataIndex_ARG_NAMES program, name
#define glGetFragDataIndex_ARG_EXPAND GLuint program, const GLchar * name
#define glGetFragDataIndex_PACKED PACKED_glGetFragDataIndex
#define glGetFragDataIndex_VOID_ONLY_WRAP(...) {}
#define glGetFragDataIndex_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glGetFragDataIndex(_program, _name) ({ \
    glGetFragDataIndex_PACKED *packed_data = malloc(sizeof(glGetFragDataIndex_PACKED)); \
    packed_data->index = glGetFragDataIndex_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.name = (GLchar *)_name; \
    (packed_call_t *)packed_data; \
})
#define call_glGetFragDataIndex(packed, ret_v) do { \
    PACKED_glGetFragDataIndex *unpacked = (PACKED_glGetFragDataIndex *)packed; \
    ARGS_glGetFragDataIndex *args = (ARGS_glGetFragDataIndex *)&unpacked->args; \
    GLint *ret = (GLint *)ret_v; \
    if (ret != NULL) { \
        *ret = glGetFragDataIndex(args->program, args->name);; \
    } else { \
        glGetFragDataIndex(args->program, args->name);; \
    } \
} while(0)
GLint glGetFragDataIndex(glGetFragDataIndex_ARG_EXPAND);
typedef GLint (*glGetFragDataIndex_PTR)(glGetFragDataIndex_ARG_EXPAND);
#define glGetFragDataLocation_INDEX 776
#define glGetFragDataLocation_RETURN GLint
#define glGetFragDataLocation_ARG_NAMES program, name
#define glGetFragDataLocation_ARG_EXPAND GLuint program, const GLchar * name
#define glGetFragDataLocation_PACKED PACKED_glGetFragDataLocation
#define glGetFragDataLocation_VOID_ONLY_WRAP(...) {}
#define glGetFragDataLocation_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glGetFragDataLocation(_program, _name) ({ \
    glGetFragDataLocation_PACKED *packed_data = malloc(sizeof(glGetFragDataLocation_PACKED)); \
    packed_data->index = glGetFragDataLocation_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.name = (GLchar *)_name; \
    (packed_call_t *)packed_data; \
})
#define call_glGetFragDataLocation(packed, ret_v) do { \
    PACKED_glGetFragDataLocation *unpacked = (PACKED_glGetFragDataLocation *)packed; \
    ARGS_glGetFragDataLocation *args = (ARGS_glGetFragDataLocation *)&unpacked->args; \
    GLint *ret = (GLint *)ret_v; \
    if (ret != NULL) { \
        *ret = glGetFragDataLocation(args->program, args->name);; \
    } else { \
        glGetFragDataLocation(args->program, args->name);; \
    } \
} while(0)
GLint glGetFragDataLocation(glGetFragDataLocation_ARG_EXPAND);
typedef GLint (*glGetFragDataLocation_PTR)(glGetFragDataLocation_ARG_EXPAND);
#define glGetFragDataLocationEXT_INDEX 777
#define glGetFragDataLocationEXT_RETURN GLint
#define glGetFragDataLocationEXT_ARG_NAMES program, name
#define glGetFragDataLocationEXT_ARG_EXPAND GLuint program, const GLchar * name
#define glGetFragDataLocationEXT_PACKED PACKED_glGetFragDataLocationEXT
#define glGetFragDataLocationEXT_VOID_ONLY_WRAP(...) {}
#define glGetFragDataLocationEXT_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glGetFragDataLocationEXT(_program, _name) ({ \
    glGetFragDataLocationEXT_PACKED *packed_data = malloc(sizeof(glGetFragDataLocationEXT_PACKED)); \
    packed_data->index = glGetFragDataLocationEXT_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.name = (GLchar *)_name; \
    (packed_call_t *)packed_data; \
})
#define call_glGetFragDataLocationEXT(packed, ret_v) do { \
    PACKED_glGetFragDataLocationEXT *unpacked = (PACKED_glGetFragDataLocationEXT *)packed; \
    ARGS_glGetFragDataLocationEXT *args = (ARGS_glGetFragDataLocationEXT *)&unpacked->args; \
    GLint *ret = (GLint *)ret_v; \
    if (ret != NULL) { \
        *ret = glGetFragDataLocationEXT(args->program, args->name);; \
    } else { \
        glGetFragDataLocationEXT(args->program, args->name);; \
    } \
} while(0)
GLint glGetFragDataLocationEXT(glGetFragDataLocationEXT_ARG_EXPAND);
typedef GLint (*glGetFragDataLocationEXT_PTR)(glGetFragDataLocationEXT_ARG_EXPAND);
#define glGetFragmentLightfvSGIX_INDEX 778
#define glGetFragmentLightfvSGIX_RETURN void
#define glGetFragmentLightfvSGIX_ARG_NAMES light, pname, params
#define glGetFragmentLightfvSGIX_ARG_EXPAND GLenum light, GLenum pname, GLfloat * params
#define glGetFragmentLightfvSGIX_PACKED PACKED_glGetFragmentLightfvSGIX
#define glGetFragmentLightfvSGIX_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetFragmentLightfvSGIX_NOT_VOID_WRAP(...) {}
#define pack_glGetFragmentLightfvSGIX(_light, _pname, _params) ({ \
    glGetFragmentLightfvSGIX_PACKED *packed_data = malloc(sizeof(glGetFragmentLightfvSGIX_PACKED)); \
    packed_data->index = glGetFragmentLightfvSGIX_INDEX; \
    packed_data->args.light = (GLenum)_light; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLfloat *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetFragmentLightfvSGIX(packed, ret_v) do { \
    PACKED_glGetFragmentLightfvSGIX *unpacked = (PACKED_glGetFragmentLightfvSGIX *)packed; \
    ARGS_glGetFragmentLightfvSGIX *args = (ARGS_glGetFragmentLightfvSGIX *)&unpacked->args; \
    glGetFragmentLightfvSGIX(args->light, args->pname, args->params);; \
} while(0)
void glGetFragmentLightfvSGIX(glGetFragmentLightfvSGIX_ARG_EXPAND);
typedef void (*glGetFragmentLightfvSGIX_PTR)(glGetFragmentLightfvSGIX_ARG_EXPAND);
#define glGetFragmentLightivSGIX_INDEX 779
#define glGetFragmentLightivSGIX_RETURN void
#define glGetFragmentLightivSGIX_ARG_NAMES light, pname, params
#define glGetFragmentLightivSGIX_ARG_EXPAND GLenum light, GLenum pname, GLint * params
#define glGetFragmentLightivSGIX_PACKED PACKED_glGetFragmentLightivSGIX
#define glGetFragmentLightivSGIX_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetFragmentLightivSGIX_NOT_VOID_WRAP(...) {}
#define pack_glGetFragmentLightivSGIX(_light, _pname, _params) ({ \
    glGetFragmentLightivSGIX_PACKED *packed_data = malloc(sizeof(glGetFragmentLightivSGIX_PACKED)); \
    packed_data->index = glGetFragmentLightivSGIX_INDEX; \
    packed_data->args.light = (GLenum)_light; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetFragmentLightivSGIX(packed, ret_v) do { \
    PACKED_glGetFragmentLightivSGIX *unpacked = (PACKED_glGetFragmentLightivSGIX *)packed; \
    ARGS_glGetFragmentLightivSGIX *args = (ARGS_glGetFragmentLightivSGIX *)&unpacked->args; \
    glGetFragmentLightivSGIX(args->light, args->pname, args->params);; \
} while(0)
void glGetFragmentLightivSGIX(glGetFragmentLightivSGIX_ARG_EXPAND);
typedef void (*glGetFragmentLightivSGIX_PTR)(glGetFragmentLightivSGIX_ARG_EXPAND);
#define glGetFragmentMaterialfvSGIX_INDEX 780
#define glGetFragmentMaterialfvSGIX_RETURN void
#define glGetFragmentMaterialfvSGIX_ARG_NAMES face, pname, params
#define glGetFragmentMaterialfvSGIX_ARG_EXPAND GLenum face, GLenum pname, GLfloat * params
#define glGetFragmentMaterialfvSGIX_PACKED PACKED_glGetFragmentMaterialfvSGIX
#define glGetFragmentMaterialfvSGIX_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetFragmentMaterialfvSGIX_NOT_VOID_WRAP(...) {}
#define pack_glGetFragmentMaterialfvSGIX(_face, _pname, _params) ({ \
    glGetFragmentMaterialfvSGIX_PACKED *packed_data = malloc(sizeof(glGetFragmentMaterialfvSGIX_PACKED)); \
    packed_data->index = glGetFragmentMaterialfvSGIX_INDEX; \
    packed_data->args.face = (GLenum)_face; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLfloat *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetFragmentMaterialfvSGIX(packed, ret_v) do { \
    PACKED_glGetFragmentMaterialfvSGIX *unpacked = (PACKED_glGetFragmentMaterialfvSGIX *)packed; \
    ARGS_glGetFragmentMaterialfvSGIX *args = (ARGS_glGetFragmentMaterialfvSGIX *)&unpacked->args; \
    glGetFragmentMaterialfvSGIX(args->face, args->pname, args->params);; \
} while(0)
void glGetFragmentMaterialfvSGIX(glGetFragmentMaterialfvSGIX_ARG_EXPAND);
typedef void (*glGetFragmentMaterialfvSGIX_PTR)(glGetFragmentMaterialfvSGIX_ARG_EXPAND);
#define glGetFragmentMaterialivSGIX_INDEX 781
#define glGetFragmentMaterialivSGIX_RETURN void
#define glGetFragmentMaterialivSGIX_ARG_NAMES face, pname, params
#define glGetFragmentMaterialivSGIX_ARG_EXPAND GLenum face, GLenum pname, GLint * params
#define glGetFragmentMaterialivSGIX_PACKED PACKED_glGetFragmentMaterialivSGIX
#define glGetFragmentMaterialivSGIX_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetFragmentMaterialivSGIX_NOT_VOID_WRAP(...) {}
#define pack_glGetFragmentMaterialivSGIX(_face, _pname, _params) ({ \
    glGetFragmentMaterialivSGIX_PACKED *packed_data = malloc(sizeof(glGetFragmentMaterialivSGIX_PACKED)); \
    packed_data->index = glGetFragmentMaterialivSGIX_INDEX; \
    packed_data->args.face = (GLenum)_face; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetFragmentMaterialivSGIX(packed, ret_v) do { \
    PACKED_glGetFragmentMaterialivSGIX *unpacked = (PACKED_glGetFragmentMaterialivSGIX *)packed; \
    ARGS_glGetFragmentMaterialivSGIX *args = (ARGS_glGetFragmentMaterialivSGIX *)&unpacked->args; \
    glGetFragmentMaterialivSGIX(args->face, args->pname, args->params);; \
} while(0)
void glGetFragmentMaterialivSGIX(glGetFragmentMaterialivSGIX_ARG_EXPAND);
typedef void (*glGetFragmentMaterialivSGIX_PTR)(glGetFragmentMaterialivSGIX_ARG_EXPAND);
#define glGetFramebufferAttachmentParameteriv_INDEX 782
#define glGetFramebufferAttachmentParameteriv_RETURN void
#define glGetFramebufferAttachmentParameteriv_ARG_NAMES target, attachment, pname, params
#define glGetFramebufferAttachmentParameteriv_ARG_EXPAND GLenum target, GLenum attachment, GLenum pname, GLint * params
#define glGetFramebufferAttachmentParameteriv_PACKED PACKED_glGetFramebufferAttachmentParameteriv
#define glGetFramebufferAttachmentParameteriv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetFramebufferAttachmentParameteriv_NOT_VOID_WRAP(...) {}
#define pack_glGetFramebufferAttachmentParameteriv(_target, _attachment, _pname, _params) ({ \
    glGetFramebufferAttachmentParameteriv_PACKED *packed_data = malloc(sizeof(glGetFramebufferAttachmentParameteriv_PACKED)); \
    packed_data->index = glGetFramebufferAttachmentParameteriv_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.attachment = (GLenum)_attachment; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetFramebufferAttachmentParameteriv(packed, ret_v) do { \
    PACKED_glGetFramebufferAttachmentParameteriv *unpacked = (PACKED_glGetFramebufferAttachmentParameteriv *)packed; \
    ARGS_glGetFramebufferAttachmentParameteriv *args = (ARGS_glGetFramebufferAttachmentParameteriv *)&unpacked->args; \
    glGetFramebufferAttachmentParameteriv(args->target, args->attachment, args->pname, args->params);; \
} while(0)
void glGetFramebufferAttachmentParameteriv(glGetFramebufferAttachmentParameteriv_ARG_EXPAND);
typedef void (*glGetFramebufferAttachmentParameteriv_PTR)(glGetFramebufferAttachmentParameteriv_ARG_EXPAND);
#define glGetFramebufferAttachmentParameterivEXT_INDEX 783
#define glGetFramebufferAttachmentParameterivEXT_RETURN void
#define glGetFramebufferAttachmentParameterivEXT_ARG_NAMES target, attachment, pname, params
#define glGetFramebufferAttachmentParameterivEXT_ARG_EXPAND GLenum target, GLenum attachment, GLenum pname, GLint * params
#define glGetFramebufferAttachmentParameterivEXT_PACKED PACKED_glGetFramebufferAttachmentParameterivEXT
#define glGetFramebufferAttachmentParameterivEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetFramebufferAttachmentParameterivEXT_NOT_VOID_WRAP(...) {}
#define pack_glGetFramebufferAttachmentParameterivEXT(_target, _attachment, _pname, _params) ({ \
    glGetFramebufferAttachmentParameterivEXT_PACKED *packed_data = malloc(sizeof(glGetFramebufferAttachmentParameterivEXT_PACKED)); \
    packed_data->index = glGetFramebufferAttachmentParameterivEXT_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.attachment = (GLenum)_attachment; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetFramebufferAttachmentParameterivEXT(packed, ret_v) do { \
    PACKED_glGetFramebufferAttachmentParameterivEXT *unpacked = (PACKED_glGetFramebufferAttachmentParameterivEXT *)packed; \
    ARGS_glGetFramebufferAttachmentParameterivEXT *args = (ARGS_glGetFramebufferAttachmentParameterivEXT *)&unpacked->args; \
    glGetFramebufferAttachmentParameterivEXT(args->target, args->attachment, args->pname, args->params);; \
} while(0)
void glGetFramebufferAttachmentParameterivEXT(glGetFramebufferAttachmentParameterivEXT_ARG_EXPAND);
typedef void (*glGetFramebufferAttachmentParameterivEXT_PTR)(glGetFramebufferAttachmentParameterivEXT_ARG_EXPAND);
#define glGetFramebufferParameteriv_INDEX 784
#define glGetFramebufferParameteriv_RETURN void
#define glGetFramebufferParameteriv_ARG_NAMES target, pname, params
#define glGetFramebufferParameteriv_ARG_EXPAND GLenum target, GLenum pname, GLint * params
#define glGetFramebufferParameteriv_PACKED PACKED_glGetFramebufferParameteriv
#define glGetFramebufferParameteriv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetFramebufferParameteriv_NOT_VOID_WRAP(...) {}
#define pack_glGetFramebufferParameteriv(_target, _pname, _params) ({ \
    glGetFramebufferParameteriv_PACKED *packed_data = malloc(sizeof(glGetFramebufferParameteriv_PACKED)); \
    packed_data->index = glGetFramebufferParameteriv_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetFramebufferParameteriv(packed, ret_v) do { \
    PACKED_glGetFramebufferParameteriv *unpacked = (PACKED_glGetFramebufferParameteriv *)packed; \
    ARGS_glGetFramebufferParameteriv *args = (ARGS_glGetFramebufferParameteriv *)&unpacked->args; \
    glGetFramebufferParameteriv(args->target, args->pname, args->params);; \
} while(0)
void glGetFramebufferParameteriv(glGetFramebufferParameteriv_ARG_EXPAND);
typedef void (*glGetFramebufferParameteriv_PTR)(glGetFramebufferParameteriv_ARG_EXPAND);
#define glGetFramebufferParameterivEXT_INDEX 785
#define glGetFramebufferParameterivEXT_RETURN void
#define glGetFramebufferParameterivEXT_ARG_NAMES framebuffer, pname, params
#define glGetFramebufferParameterivEXT_ARG_EXPAND GLuint framebuffer, GLenum pname, GLint * params
#define glGetFramebufferParameterivEXT_PACKED PACKED_glGetFramebufferParameterivEXT
#define glGetFramebufferParameterivEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetFramebufferParameterivEXT_NOT_VOID_WRAP(...) {}
#define pack_glGetFramebufferParameterivEXT(_framebuffer, _pname, _params) ({ \
    glGetFramebufferParameterivEXT_PACKED *packed_data = malloc(sizeof(glGetFramebufferParameterivEXT_PACKED)); \
    packed_data->index = glGetFramebufferParameterivEXT_INDEX; \
    packed_data->args.framebuffer = (GLuint)_framebuffer; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetFramebufferParameterivEXT(packed, ret_v) do { \
    PACKED_glGetFramebufferParameterivEXT *unpacked = (PACKED_glGetFramebufferParameterivEXT *)packed; \
    ARGS_glGetFramebufferParameterivEXT *args = (ARGS_glGetFramebufferParameterivEXT *)&unpacked->args; \
    glGetFramebufferParameterivEXT(args->framebuffer, args->pname, args->params);; \
} while(0)
void glGetFramebufferParameterivEXT(glGetFramebufferParameterivEXT_ARG_EXPAND);
typedef void (*glGetFramebufferParameterivEXT_PTR)(glGetFramebufferParameterivEXT_ARG_EXPAND);
#define glGetGraphicsResetStatusARB_INDEX 786
#define glGetGraphicsResetStatusARB_RETURN GLenum
#define glGetGraphicsResetStatusARB_ARG_NAMES 
#define glGetGraphicsResetStatusARB_ARG_EXPAND 
#define glGetGraphicsResetStatusARB_PACKED PACKED_glGetGraphicsResetStatusARB
#define glGetGraphicsResetStatusARB_VOID_ONLY_WRAP(...) {}
#define glGetGraphicsResetStatusARB_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glGetGraphicsResetStatusARB() ({ \
    glGetGraphicsResetStatusARB_PACKED *packed_data = malloc(sizeof(glGetGraphicsResetStatusARB_PACKED)); \
    packed_data->index = glGetGraphicsResetStatusARB_INDEX; \
    (packed_call_t *)packed_data; \
})
#define call_glGetGraphicsResetStatusARB(packed, ret_v) do { \
    GLenum *ret = (GLenum *)ret_v; \
    if (ret != NULL) { \
        *ret = glGetGraphicsResetStatusARB();; \
    } else { \
        glGetGraphicsResetStatusARB();; \
    } \
} while(0)
GLenum glGetGraphicsResetStatusARB(glGetGraphicsResetStatusARB_ARG_EXPAND);
typedef GLenum (*glGetGraphicsResetStatusARB_PTR)(glGetGraphicsResetStatusARB_ARG_EXPAND);
#define glGetHandleARB_INDEX 787
#define glGetHandleARB_RETURN GLhandleARB
#define glGetHandleARB_ARG_NAMES pname
#define glGetHandleARB_ARG_EXPAND GLenum pname
#define glGetHandleARB_PACKED PACKED_glGetHandleARB
#define glGetHandleARB_VOID_ONLY_WRAP(...) {}
#define glGetHandleARB_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glGetHandleARB(_pname) ({ \
    glGetHandleARB_PACKED *packed_data = malloc(sizeof(glGetHandleARB_PACKED)); \
    packed_data->index = glGetHandleARB_INDEX; \
    packed_data->args.pname = (GLenum)_pname; \
    (packed_call_t *)packed_data; \
})
#define call_glGetHandleARB(packed, ret_v) do { \
    PACKED_glGetHandleARB *unpacked = (PACKED_glGetHandleARB *)packed; \
    ARGS_glGetHandleARB *args = (ARGS_glGetHandleARB *)&unpacked->args; \
    GLhandleARB *ret = (GLhandleARB *)ret_v; \
    if (ret != NULL) { \
        *ret = glGetHandleARB(args->pname);; \
    } else { \
        glGetHandleARB(args->pname);; \
    } \
} while(0)
GLhandleARB glGetHandleARB(glGetHandleARB_ARG_EXPAND);
typedef GLhandleARB (*glGetHandleARB_PTR)(glGetHandleARB_ARG_EXPAND);
#define glGetHistogram_INDEX 788
#define glGetHistogram_RETURN void
#define glGetHistogram_ARG_NAMES target, reset, format, type, values
#define glGetHistogram_ARG_EXPAND GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid * values
#define glGetHistogram_PACKED PACKED_glGetHistogram
#define glGetHistogram_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetHistogram_NOT_VOID_WRAP(...) {}
#define pack_glGetHistogram(_target, _reset, _format, _type, _values) ({ \
    glGetHistogram_PACKED *packed_data = malloc(sizeof(glGetHistogram_PACKED)); \
    packed_data->index = glGetHistogram_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.reset = (GLboolean)_reset; \
    packed_data->args.format = (GLenum)_format; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.values = (GLvoid *)_values; \
    (packed_call_t *)packed_data; \
})
#define call_glGetHistogram(packed, ret_v) do { \
    PACKED_glGetHistogram *unpacked = (PACKED_glGetHistogram *)packed; \
    ARGS_glGetHistogram *args = (ARGS_glGetHistogram *)&unpacked->args; \
    glGetHistogram(args->target, args->reset, args->format, args->type, args->values);; \
} while(0)
void glGetHistogram(glGetHistogram_ARG_EXPAND);
typedef void (*glGetHistogram_PTR)(glGetHistogram_ARG_EXPAND);
#define glGetHistogramEXT_INDEX 789
#define glGetHistogramEXT_RETURN void
#define glGetHistogramEXT_ARG_NAMES target, reset, format, type, values
#define glGetHistogramEXT_ARG_EXPAND GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid * values
#define glGetHistogramEXT_PACKED PACKED_glGetHistogramEXT
#define glGetHistogramEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetHistogramEXT_NOT_VOID_WRAP(...) {}
#define pack_glGetHistogramEXT(_target, _reset, _format, _type, _values) ({ \
    glGetHistogramEXT_PACKED *packed_data = malloc(sizeof(glGetHistogramEXT_PACKED)); \
    packed_data->index = glGetHistogramEXT_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.reset = (GLboolean)_reset; \
    packed_data->args.format = (GLenum)_format; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.values = (GLvoid *)_values; \
    (packed_call_t *)packed_data; \
})
#define call_glGetHistogramEXT(packed, ret_v) do { \
    PACKED_glGetHistogramEXT *unpacked = (PACKED_glGetHistogramEXT *)packed; \
    ARGS_glGetHistogramEXT *args = (ARGS_glGetHistogramEXT *)&unpacked->args; \
    glGetHistogramEXT(args->target, args->reset, args->format, args->type, args->values);; \
} while(0)
void glGetHistogramEXT(glGetHistogramEXT_ARG_EXPAND);
typedef void (*glGetHistogramEXT_PTR)(glGetHistogramEXT_ARG_EXPAND);
#define glGetHistogramParameterfv_INDEX 790
#define glGetHistogramParameterfv_RETURN void
#define glGetHistogramParameterfv_ARG_NAMES target, pname, params
#define glGetHistogramParameterfv_ARG_EXPAND GLenum target, GLenum pname, GLfloat * params
#define glGetHistogramParameterfv_PACKED PACKED_glGetHistogramParameterfv
#define glGetHistogramParameterfv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetHistogramParameterfv_NOT_VOID_WRAP(...) {}
#define pack_glGetHistogramParameterfv(_target, _pname, _params) ({ \
    glGetHistogramParameterfv_PACKED *packed_data = malloc(sizeof(glGetHistogramParameterfv_PACKED)); \
    packed_data->index = glGetHistogramParameterfv_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLfloat *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetHistogramParameterfv(packed, ret_v) do { \
    PACKED_glGetHistogramParameterfv *unpacked = (PACKED_glGetHistogramParameterfv *)packed; \
    ARGS_glGetHistogramParameterfv *args = (ARGS_glGetHistogramParameterfv *)&unpacked->args; \
    glGetHistogramParameterfv(args->target, args->pname, args->params);; \
} while(0)
void glGetHistogramParameterfv(glGetHistogramParameterfv_ARG_EXPAND);
typedef void (*glGetHistogramParameterfv_PTR)(glGetHistogramParameterfv_ARG_EXPAND);
#define glGetHistogramParameterfvEXT_INDEX 791
#define glGetHistogramParameterfvEXT_RETURN void
#define glGetHistogramParameterfvEXT_ARG_NAMES target, pname, params
#define glGetHistogramParameterfvEXT_ARG_EXPAND GLenum target, GLenum pname, GLfloat * params
#define glGetHistogramParameterfvEXT_PACKED PACKED_glGetHistogramParameterfvEXT
#define glGetHistogramParameterfvEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetHistogramParameterfvEXT_NOT_VOID_WRAP(...) {}
#define pack_glGetHistogramParameterfvEXT(_target, _pname, _params) ({ \
    glGetHistogramParameterfvEXT_PACKED *packed_data = malloc(sizeof(glGetHistogramParameterfvEXT_PACKED)); \
    packed_data->index = glGetHistogramParameterfvEXT_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLfloat *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetHistogramParameterfvEXT(packed, ret_v) do { \
    PACKED_glGetHistogramParameterfvEXT *unpacked = (PACKED_glGetHistogramParameterfvEXT *)packed; \
    ARGS_glGetHistogramParameterfvEXT *args = (ARGS_glGetHistogramParameterfvEXT *)&unpacked->args; \
    glGetHistogramParameterfvEXT(args->target, args->pname, args->params);; \
} while(0)
void glGetHistogramParameterfvEXT(glGetHistogramParameterfvEXT_ARG_EXPAND);
typedef void (*glGetHistogramParameterfvEXT_PTR)(glGetHistogramParameterfvEXT_ARG_EXPAND);
#define glGetHistogramParameteriv_INDEX 792
#define glGetHistogramParameteriv_RETURN void
#define glGetHistogramParameteriv_ARG_NAMES target, pname, params
#define glGetHistogramParameteriv_ARG_EXPAND GLenum target, GLenum pname, GLint * params
#define glGetHistogramParameteriv_PACKED PACKED_glGetHistogramParameteriv
#define glGetHistogramParameteriv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetHistogramParameteriv_NOT_VOID_WRAP(...) {}
#define pack_glGetHistogramParameteriv(_target, _pname, _params) ({ \
    glGetHistogramParameteriv_PACKED *packed_data = malloc(sizeof(glGetHistogramParameteriv_PACKED)); \
    packed_data->index = glGetHistogramParameteriv_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetHistogramParameteriv(packed, ret_v) do { \
    PACKED_glGetHistogramParameteriv *unpacked = (PACKED_glGetHistogramParameteriv *)packed; \
    ARGS_glGetHistogramParameteriv *args = (ARGS_glGetHistogramParameteriv *)&unpacked->args; \
    glGetHistogramParameteriv(args->target, args->pname, args->params);; \
} while(0)
void glGetHistogramParameteriv(glGetHistogramParameteriv_ARG_EXPAND);
typedef void (*glGetHistogramParameteriv_PTR)(glGetHistogramParameteriv_ARG_EXPAND);
#define glGetHistogramParameterivEXT_INDEX 793
#define glGetHistogramParameterivEXT_RETURN void
#define glGetHistogramParameterivEXT_ARG_NAMES target, pname, params
#define glGetHistogramParameterivEXT_ARG_EXPAND GLenum target, GLenum pname, GLint * params
#define glGetHistogramParameterivEXT_PACKED PACKED_glGetHistogramParameterivEXT
#define glGetHistogramParameterivEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetHistogramParameterivEXT_NOT_VOID_WRAP(...) {}
#define pack_glGetHistogramParameterivEXT(_target, _pname, _params) ({ \
    glGetHistogramParameterivEXT_PACKED *packed_data = malloc(sizeof(glGetHistogramParameterivEXT_PACKED)); \
    packed_data->index = glGetHistogramParameterivEXT_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetHistogramParameterivEXT(packed, ret_v) do { \
    PACKED_glGetHistogramParameterivEXT *unpacked = (PACKED_glGetHistogramParameterivEXT *)packed; \
    ARGS_glGetHistogramParameterivEXT *args = (ARGS_glGetHistogramParameterivEXT *)&unpacked->args; \
    glGetHistogramParameterivEXT(args->target, args->pname, args->params);; \
} while(0)
void glGetHistogramParameterivEXT(glGetHistogramParameterivEXT_ARG_EXPAND);
typedef void (*glGetHistogramParameterivEXT_PTR)(glGetHistogramParameterivEXT_ARG_EXPAND);
#define glGetHistogramParameterxvOES_INDEX 794
#define glGetHistogramParameterxvOES_RETURN void
#define glGetHistogramParameterxvOES_ARG_NAMES target, pname, params
#define glGetHistogramParameterxvOES_ARG_EXPAND GLenum target, GLenum pname, GLfixed * params
#define glGetHistogramParameterxvOES_PACKED PACKED_glGetHistogramParameterxvOES
#define glGetHistogramParameterxvOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetHistogramParameterxvOES_NOT_VOID_WRAP(...) {}
#define pack_glGetHistogramParameterxvOES(_target, _pname, _params) ({ \
    glGetHistogramParameterxvOES_PACKED *packed_data = malloc(sizeof(glGetHistogramParameterxvOES_PACKED)); \
    packed_data->index = glGetHistogramParameterxvOES_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLfixed *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetHistogramParameterxvOES(packed, ret_v) do { \
    PACKED_glGetHistogramParameterxvOES *unpacked = (PACKED_glGetHistogramParameterxvOES *)packed; \
    ARGS_glGetHistogramParameterxvOES *args = (ARGS_glGetHistogramParameterxvOES *)&unpacked->args; \
    glGetHistogramParameterxvOES(args->target, args->pname, args->params);; \
} while(0)
void glGetHistogramParameterxvOES(glGetHistogramParameterxvOES_ARG_EXPAND);
typedef void (*glGetHistogramParameterxvOES_PTR)(glGetHistogramParameterxvOES_ARG_EXPAND);
#define glGetImageHandleNV_INDEX 795
#define glGetImageHandleNV_RETURN GLuint64
#define glGetImageHandleNV_ARG_NAMES texture, level, layered, layer, format
#define glGetImageHandleNV_ARG_EXPAND GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum format
#define glGetImageHandleNV_PACKED PACKED_glGetImageHandleNV
#define glGetImageHandleNV_VOID_ONLY_WRAP(...) {}
#define glGetImageHandleNV_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glGetImageHandleNV(_texture, _level, _layered, _layer, _format) ({ \
    glGetImageHandleNV_PACKED *packed_data = malloc(sizeof(glGetImageHandleNV_PACKED)); \
    packed_data->index = glGetImageHandleNV_INDEX; \
    packed_data->args.texture = (GLuint)_texture; \
    packed_data->args.level = (GLint)_level; \
    packed_data->args.layered = (GLboolean)_layered; \
    packed_data->args.layer = (GLint)_layer; \
    packed_data->args.format = (GLenum)_format; \
    (packed_call_t *)packed_data; \
})
#define call_glGetImageHandleNV(packed, ret_v) do { \
    PACKED_glGetImageHandleNV *unpacked = (PACKED_glGetImageHandleNV *)packed; \
    ARGS_glGetImageHandleNV *args = (ARGS_glGetImageHandleNV *)&unpacked->args; \
    GLuint64 *ret = (GLuint64 *)ret_v; \
    if (ret != NULL) { \
        *ret = glGetImageHandleNV(args->texture, args->level, args->layered, args->layer, args->format);; \
    } else { \
        glGetImageHandleNV(args->texture, args->level, args->layered, args->layer, args->format);; \
    } \
} while(0)
GLuint64 glGetImageHandleNV(glGetImageHandleNV_ARG_EXPAND);
typedef GLuint64 (*glGetImageHandleNV_PTR)(glGetImageHandleNV_ARG_EXPAND);
#define glGetImageTransformParameterfvHP_INDEX 796
#define glGetImageTransformParameterfvHP_RETURN void
#define glGetImageTransformParameterfvHP_ARG_NAMES target, pname, params
#define glGetImageTransformParameterfvHP_ARG_EXPAND GLenum target, GLenum pname, GLfloat * params
#define glGetImageTransformParameterfvHP_PACKED PACKED_glGetImageTransformParameterfvHP
#define glGetImageTransformParameterfvHP_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetImageTransformParameterfvHP_NOT_VOID_WRAP(...) {}
#define pack_glGetImageTransformParameterfvHP(_target, _pname, _params) ({ \
    glGetImageTransformParameterfvHP_PACKED *packed_data = malloc(sizeof(glGetImageTransformParameterfvHP_PACKED)); \
    packed_data->index = glGetImageTransformParameterfvHP_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLfloat *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetImageTransformParameterfvHP(packed, ret_v) do { \
    PACKED_glGetImageTransformParameterfvHP *unpacked = (PACKED_glGetImageTransformParameterfvHP *)packed; \
    ARGS_glGetImageTransformParameterfvHP *args = (ARGS_glGetImageTransformParameterfvHP *)&unpacked->args; \
    glGetImageTransformParameterfvHP(args->target, args->pname, args->params);; \
} while(0)
void glGetImageTransformParameterfvHP(glGetImageTransformParameterfvHP_ARG_EXPAND);
typedef void (*glGetImageTransformParameterfvHP_PTR)(glGetImageTransformParameterfvHP_ARG_EXPAND);
#define glGetImageTransformParameterivHP_INDEX 797
#define glGetImageTransformParameterivHP_RETURN void
#define glGetImageTransformParameterivHP_ARG_NAMES target, pname, params
#define glGetImageTransformParameterivHP_ARG_EXPAND GLenum target, GLenum pname, GLint * params
#define glGetImageTransformParameterivHP_PACKED PACKED_glGetImageTransformParameterivHP
#define glGetImageTransformParameterivHP_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetImageTransformParameterivHP_NOT_VOID_WRAP(...) {}
#define pack_glGetImageTransformParameterivHP(_target, _pname, _params) ({ \
    glGetImageTransformParameterivHP_PACKED *packed_data = malloc(sizeof(glGetImageTransformParameterivHP_PACKED)); \
    packed_data->index = glGetImageTransformParameterivHP_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetImageTransformParameterivHP(packed, ret_v) do { \
    PACKED_glGetImageTransformParameterivHP *unpacked = (PACKED_glGetImageTransformParameterivHP *)packed; \
    ARGS_glGetImageTransformParameterivHP *args = (ARGS_glGetImageTransformParameterivHP *)&unpacked->args; \
    glGetImageTransformParameterivHP(args->target, args->pname, args->params);; \
} while(0)
void glGetImageTransformParameterivHP(glGetImageTransformParameterivHP_ARG_EXPAND);
typedef void (*glGetImageTransformParameterivHP_PTR)(glGetImageTransformParameterivHP_ARG_EXPAND);
#define glGetInfoLogARB_INDEX 798
#define glGetInfoLogARB_RETURN void
#define glGetInfoLogARB_ARG_NAMES obj, maxLength, length, infoLog
#define glGetInfoLogARB_ARG_EXPAND GLhandleARB obj, GLsizei maxLength, GLsizei * length, GLcharARB * infoLog
#define glGetInfoLogARB_PACKED PACKED_glGetInfoLogARB
#define glGetInfoLogARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetInfoLogARB_NOT_VOID_WRAP(...) {}
#define pack_glGetInfoLogARB(_obj, _maxLength, _length, _infoLog) ({ \
    glGetInfoLogARB_PACKED *packed_data = malloc(sizeof(glGetInfoLogARB_PACKED)); \
    packed_data->index = glGetInfoLogARB_INDEX; \
    packed_data->args.obj = (GLhandleARB)_obj; \
    packed_data->args.maxLength = (GLsizei)_maxLength; \
    packed_data->args.length = (GLsizei *)_length; \
    packed_data->args.infoLog = (GLcharARB *)_infoLog; \
    (packed_call_t *)packed_data; \
})
#define call_glGetInfoLogARB(packed, ret_v) do { \
    PACKED_glGetInfoLogARB *unpacked = (PACKED_glGetInfoLogARB *)packed; \
    ARGS_glGetInfoLogARB *args = (ARGS_glGetInfoLogARB *)&unpacked->args; \
    glGetInfoLogARB(args->obj, args->maxLength, args->length, args->infoLog);; \
} while(0)
void glGetInfoLogARB(glGetInfoLogARB_ARG_EXPAND);
typedef void (*glGetInfoLogARB_PTR)(glGetInfoLogARB_ARG_EXPAND);
#define glGetInstrumentsSGIX_INDEX 799
#define glGetInstrumentsSGIX_RETURN GLint
#define glGetInstrumentsSGIX_ARG_NAMES 
#define glGetInstrumentsSGIX_ARG_EXPAND 
#define glGetInstrumentsSGIX_PACKED PACKED_glGetInstrumentsSGIX
#define glGetInstrumentsSGIX_VOID_ONLY_WRAP(...) {}
#define glGetInstrumentsSGIX_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glGetInstrumentsSGIX() ({ \
    glGetInstrumentsSGIX_PACKED *packed_data = malloc(sizeof(glGetInstrumentsSGIX_PACKED)); \
    packed_data->index = glGetInstrumentsSGIX_INDEX; \
    (packed_call_t *)packed_data; \
})
#define call_glGetInstrumentsSGIX(packed, ret_v) do { \
    GLint *ret = (GLint *)ret_v; \
    if (ret != NULL) { \
        *ret = glGetInstrumentsSGIX();; \
    } else { \
        glGetInstrumentsSGIX();; \
    } \
} while(0)
GLint glGetInstrumentsSGIX(glGetInstrumentsSGIX_ARG_EXPAND);
typedef GLint (*glGetInstrumentsSGIX_PTR)(glGetInstrumentsSGIX_ARG_EXPAND);
#define glGetInteger64i_v_INDEX 800
#define glGetInteger64i_v_RETURN void
#define glGetInteger64i_v_ARG_NAMES target, index, data
#define glGetInteger64i_v_ARG_EXPAND GLenum target, GLuint index, GLint64 * data
#define glGetInteger64i_v_PACKED PACKED_glGetInteger64i_v
#define glGetInteger64i_v_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetInteger64i_v_NOT_VOID_WRAP(...) {}
#define pack_glGetInteger64i_v(_target, _index, _data) ({ \
    glGetInteger64i_v_PACKED *packed_data = malloc(sizeof(glGetInteger64i_v_PACKED)); \
    packed_data->index = glGetInteger64i_v_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.data = (GLint64 *)_data; \
    (packed_call_t *)packed_data; \
})
#define call_glGetInteger64i_v(packed, ret_v) do { \
    PACKED_glGetInteger64i_v *unpacked = (PACKED_glGetInteger64i_v *)packed; \
    ARGS_glGetInteger64i_v *args = (ARGS_glGetInteger64i_v *)&unpacked->args; \
    glGetInteger64i_v(args->target, args->index, args->data);; \
} while(0)
void glGetInteger64i_v(glGetInteger64i_v_ARG_EXPAND);
typedef void (*glGetInteger64i_v_PTR)(glGetInteger64i_v_ARG_EXPAND);
#define glGetInteger64v_INDEX 801
#define glGetInteger64v_RETURN void
#define glGetInteger64v_ARG_NAMES pname, params
#define glGetInteger64v_ARG_EXPAND GLenum pname, GLint64 * params
#define glGetInteger64v_PACKED PACKED_glGetInteger64v
#define glGetInteger64v_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetInteger64v_NOT_VOID_WRAP(...) {}
#define pack_glGetInteger64v(_pname, _params) ({ \
    glGetInteger64v_PACKED *packed_data = malloc(sizeof(glGetInteger64v_PACKED)); \
    packed_data->index = glGetInteger64v_INDEX; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLint64 *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetInteger64v(packed, ret_v) do { \
    PACKED_glGetInteger64v *unpacked = (PACKED_glGetInteger64v *)packed; \
    ARGS_glGetInteger64v *args = (ARGS_glGetInteger64v *)&unpacked->args; \
    glGetInteger64v(args->pname, args->params);; \
} while(0)
void glGetInteger64v(glGetInteger64v_ARG_EXPAND);
typedef void (*glGetInteger64v_PTR)(glGetInteger64v_ARG_EXPAND);
#define glGetIntegerIndexedvEXT_INDEX 802
#define glGetIntegerIndexedvEXT_RETURN void
#define glGetIntegerIndexedvEXT_ARG_NAMES target, index, data
#define glGetIntegerIndexedvEXT_ARG_EXPAND GLenum target, GLuint index, GLint * data
#define glGetIntegerIndexedvEXT_PACKED PACKED_glGetIntegerIndexedvEXT
#define glGetIntegerIndexedvEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetIntegerIndexedvEXT_NOT_VOID_WRAP(...) {}
#define pack_glGetIntegerIndexedvEXT(_target, _index, _data) ({ \
    glGetIntegerIndexedvEXT_PACKED *packed_data = malloc(sizeof(glGetIntegerIndexedvEXT_PACKED)); \
    packed_data->index = glGetIntegerIndexedvEXT_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.data = (GLint *)_data; \
    (packed_call_t *)packed_data; \
})
#define call_glGetIntegerIndexedvEXT(packed, ret_v) do { \
    PACKED_glGetIntegerIndexedvEXT *unpacked = (PACKED_glGetIntegerIndexedvEXT *)packed; \
    ARGS_glGetIntegerIndexedvEXT *args = (ARGS_glGetIntegerIndexedvEXT *)&unpacked->args; \
    glGetIntegerIndexedvEXT(args->target, args->index, args->data);; \
} while(0)
void glGetIntegerIndexedvEXT(glGetIntegerIndexedvEXT_ARG_EXPAND);
typedef void (*glGetIntegerIndexedvEXT_PTR)(glGetIntegerIndexedvEXT_ARG_EXPAND);
#define glGetIntegeri_v_INDEX 803
#define glGetIntegeri_v_RETURN void
#define glGetIntegeri_v_ARG_NAMES target, index, data
#define glGetIntegeri_v_ARG_EXPAND GLenum target, GLuint index, GLint * data
#define glGetIntegeri_v_PACKED PACKED_glGetIntegeri_v
#define glGetIntegeri_v_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetIntegeri_v_NOT_VOID_WRAP(...) {}
#define pack_glGetIntegeri_v(_target, _index, _data) ({ \
    glGetIntegeri_v_PACKED *packed_data = malloc(sizeof(glGetIntegeri_v_PACKED)); \
    packed_data->index = glGetIntegeri_v_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.data = (GLint *)_data; \
    (packed_call_t *)packed_data; \
})
#define call_glGetIntegeri_v(packed, ret_v) do { \
    PACKED_glGetIntegeri_v *unpacked = (PACKED_glGetIntegeri_v *)packed; \
    ARGS_glGetIntegeri_v *args = (ARGS_glGetIntegeri_v *)&unpacked->args; \
    glGetIntegeri_v(args->target, args->index, args->data);; \
} while(0)
void glGetIntegeri_v(glGetIntegeri_v_ARG_EXPAND);
typedef void (*glGetIntegeri_v_PTR)(glGetIntegeri_v_ARG_EXPAND);
#define glGetIntegerui64i_vNV_INDEX 804
#define glGetIntegerui64i_vNV_RETURN void
#define glGetIntegerui64i_vNV_ARG_NAMES value, index, result
#define glGetIntegerui64i_vNV_ARG_EXPAND GLenum value, GLuint index, GLuint64EXT * result
#define glGetIntegerui64i_vNV_PACKED PACKED_glGetIntegerui64i_vNV
#define glGetIntegerui64i_vNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetIntegerui64i_vNV_NOT_VOID_WRAP(...) {}
#define pack_glGetIntegerui64i_vNV(_value, _index, _result) ({ \
    glGetIntegerui64i_vNV_PACKED *packed_data = malloc(sizeof(glGetIntegerui64i_vNV_PACKED)); \
    packed_data->index = glGetIntegerui64i_vNV_INDEX; \
    packed_data->args.value = (GLenum)_value; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.result = (GLuint64EXT *)_result; \
    (packed_call_t *)packed_data; \
})
#define call_glGetIntegerui64i_vNV(packed, ret_v) do { \
    PACKED_glGetIntegerui64i_vNV *unpacked = (PACKED_glGetIntegerui64i_vNV *)packed; \
    ARGS_glGetIntegerui64i_vNV *args = (ARGS_glGetIntegerui64i_vNV *)&unpacked->args; \
    glGetIntegerui64i_vNV(args->value, args->index, args->result);; \
} while(0)
void glGetIntegerui64i_vNV(glGetIntegerui64i_vNV_ARG_EXPAND);
typedef void (*glGetIntegerui64i_vNV_PTR)(glGetIntegerui64i_vNV_ARG_EXPAND);
#define glGetIntegerui64vNV_INDEX 805
#define glGetIntegerui64vNV_RETURN void
#define glGetIntegerui64vNV_ARG_NAMES value, result
#define glGetIntegerui64vNV_ARG_EXPAND GLenum value, GLuint64EXT * result
#define glGetIntegerui64vNV_PACKED PACKED_glGetIntegerui64vNV
#define glGetIntegerui64vNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetIntegerui64vNV_NOT_VOID_WRAP(...) {}
#define pack_glGetIntegerui64vNV(_value, _result) ({ \
    glGetIntegerui64vNV_PACKED *packed_data = malloc(sizeof(glGetIntegerui64vNV_PACKED)); \
    packed_data->index = glGetIntegerui64vNV_INDEX; \
    packed_data->args.value = (GLenum)_value; \
    packed_data->args.result = (GLuint64EXT *)_result; \
    (packed_call_t *)packed_data; \
})
#define call_glGetIntegerui64vNV(packed, ret_v) do { \
    PACKED_glGetIntegerui64vNV *unpacked = (PACKED_glGetIntegerui64vNV *)packed; \
    ARGS_glGetIntegerui64vNV *args = (ARGS_glGetIntegerui64vNV *)&unpacked->args; \
    glGetIntegerui64vNV(args->value, args->result);; \
} while(0)
void glGetIntegerui64vNV(glGetIntegerui64vNV_ARG_EXPAND);
typedef void (*glGetIntegerui64vNV_PTR)(glGetIntegerui64vNV_ARG_EXPAND);
#define glGetIntegerv_INDEX 806
#define glGetIntegerv_RETURN void
#define glGetIntegerv_ARG_NAMES pname, params
#define glGetIntegerv_ARG_EXPAND GLenum pname, GLint * params
#define glGetIntegerv_PACKED PACKED_glGetIntegerv
#define glGetIntegerv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetIntegerv_NOT_VOID_WRAP(...) {}
#define pack_glGetIntegerv(_pname, _params) ({ \
    glGetIntegerv_PACKED *packed_data = malloc(sizeof(glGetIntegerv_PACKED)); \
    packed_data->index = glGetIntegerv_INDEX; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetIntegerv(packed, ret_v) do { \
    PACKED_glGetIntegerv *unpacked = (PACKED_glGetIntegerv *)packed; \
    ARGS_glGetIntegerv *args = (ARGS_glGetIntegerv *)&unpacked->args; \
    glGetIntegerv(args->pname, args->params);; \
} while(0)
void glGetIntegerv(glGetIntegerv_ARG_EXPAND);
typedef void (*glGetIntegerv_PTR)(glGetIntegerv_ARG_EXPAND);
#define glGetInternalformati64v_INDEX 807
#define glGetInternalformati64v_RETURN void
#define glGetInternalformati64v_ARG_NAMES target, internalformat, pname, bufSize, params
#define glGetInternalformati64v_ARG_EXPAND GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint64 * params
#define glGetInternalformati64v_PACKED PACKED_glGetInternalformati64v
#define glGetInternalformati64v_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetInternalformati64v_NOT_VOID_WRAP(...) {}
#define pack_glGetInternalformati64v(_target, _internalformat, _pname, _bufSize, _params) ({ \
    glGetInternalformati64v_PACKED *packed_data = malloc(sizeof(glGetInternalformati64v_PACKED)); \
    packed_data->index = glGetInternalformati64v_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.internalformat = (GLenum)_internalformat; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.bufSize = (GLsizei)_bufSize; \
    packed_data->args.params = (GLint64 *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetInternalformati64v(packed, ret_v) do { \
    PACKED_glGetInternalformati64v *unpacked = (PACKED_glGetInternalformati64v *)packed; \
    ARGS_glGetInternalformati64v *args = (ARGS_glGetInternalformati64v *)&unpacked->args; \
    glGetInternalformati64v(args->target, args->internalformat, args->pname, args->bufSize, args->params);; \
} while(0)
void glGetInternalformati64v(glGetInternalformati64v_ARG_EXPAND);
typedef void (*glGetInternalformati64v_PTR)(glGetInternalformati64v_ARG_EXPAND);
#define glGetInternalformativ_INDEX 808
#define glGetInternalformativ_RETURN void
#define glGetInternalformativ_ARG_NAMES target, internalformat, pname, bufSize, params
#define glGetInternalformativ_ARG_EXPAND GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint * params
#define glGetInternalformativ_PACKED PACKED_glGetInternalformativ
#define glGetInternalformativ_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetInternalformativ_NOT_VOID_WRAP(...) {}
#define pack_glGetInternalformativ(_target, _internalformat, _pname, _bufSize, _params) ({ \
    glGetInternalformativ_PACKED *packed_data = malloc(sizeof(glGetInternalformativ_PACKED)); \
    packed_data->index = glGetInternalformativ_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.internalformat = (GLenum)_internalformat; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.bufSize = (GLsizei)_bufSize; \
    packed_data->args.params = (GLint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetInternalformativ(packed, ret_v) do { \
    PACKED_glGetInternalformativ *unpacked = (PACKED_glGetInternalformativ *)packed; \
    ARGS_glGetInternalformativ *args = (ARGS_glGetInternalformativ *)&unpacked->args; \
    glGetInternalformativ(args->target, args->internalformat, args->pname, args->bufSize, args->params);; \
} while(0)
void glGetInternalformativ(glGetInternalformativ_ARG_EXPAND);
typedef void (*glGetInternalformativ_PTR)(glGetInternalformativ_ARG_EXPAND);
#define glGetInvariantBooleanvEXT_INDEX 809
#define glGetInvariantBooleanvEXT_RETURN void
#define glGetInvariantBooleanvEXT_ARG_NAMES id, value, data
#define glGetInvariantBooleanvEXT_ARG_EXPAND GLuint id, GLenum value, GLboolean * data
#define glGetInvariantBooleanvEXT_PACKED PACKED_glGetInvariantBooleanvEXT
#define glGetInvariantBooleanvEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetInvariantBooleanvEXT_NOT_VOID_WRAP(...) {}
#define pack_glGetInvariantBooleanvEXT(_id, _value, _data) ({ \
    glGetInvariantBooleanvEXT_PACKED *packed_data = malloc(sizeof(glGetInvariantBooleanvEXT_PACKED)); \
    packed_data->index = glGetInvariantBooleanvEXT_INDEX; \
    packed_data->args.id = (GLuint)_id; \
    packed_data->args.value = (GLenum)_value; \
    packed_data->args.data = (GLboolean *)_data; \
    (packed_call_t *)packed_data; \
})
#define call_glGetInvariantBooleanvEXT(packed, ret_v) do { \
    PACKED_glGetInvariantBooleanvEXT *unpacked = (PACKED_glGetInvariantBooleanvEXT *)packed; \
    ARGS_glGetInvariantBooleanvEXT *args = (ARGS_glGetInvariantBooleanvEXT *)&unpacked->args; \
    glGetInvariantBooleanvEXT(args->id, args->value, args->data);; \
} while(0)
void glGetInvariantBooleanvEXT(glGetInvariantBooleanvEXT_ARG_EXPAND);
typedef void (*glGetInvariantBooleanvEXT_PTR)(glGetInvariantBooleanvEXT_ARG_EXPAND);
#define glGetInvariantFloatvEXT_INDEX 810
#define glGetInvariantFloatvEXT_RETURN void
#define glGetInvariantFloatvEXT_ARG_NAMES id, value, data
#define glGetInvariantFloatvEXT_ARG_EXPAND GLuint id, GLenum value, GLfloat * data
#define glGetInvariantFloatvEXT_PACKED PACKED_glGetInvariantFloatvEXT
#define glGetInvariantFloatvEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetInvariantFloatvEXT_NOT_VOID_WRAP(...) {}
#define pack_glGetInvariantFloatvEXT(_id, _value, _data) ({ \
    glGetInvariantFloatvEXT_PACKED *packed_data = malloc(sizeof(glGetInvariantFloatvEXT_PACKED)); \
    packed_data->index = glGetInvariantFloatvEXT_INDEX; \
    packed_data->args.id = (GLuint)_id; \
    packed_data->args.value = (GLenum)_value; \
    packed_data->args.data = (GLfloat *)_data; \
    (packed_call_t *)packed_data; \
})
#define call_glGetInvariantFloatvEXT(packed, ret_v) do { \
    PACKED_glGetInvariantFloatvEXT *unpacked = (PACKED_glGetInvariantFloatvEXT *)packed; \
    ARGS_glGetInvariantFloatvEXT *args = (ARGS_glGetInvariantFloatvEXT *)&unpacked->args; \
    glGetInvariantFloatvEXT(args->id, args->value, args->data);; \
} while(0)
void glGetInvariantFloatvEXT(glGetInvariantFloatvEXT_ARG_EXPAND);
typedef void (*glGetInvariantFloatvEXT_PTR)(glGetInvariantFloatvEXT_ARG_EXPAND);
#define glGetInvariantIntegervEXT_INDEX 811
#define glGetInvariantIntegervEXT_RETURN void
#define glGetInvariantIntegervEXT_ARG_NAMES id, value, data
#define glGetInvariantIntegervEXT_ARG_EXPAND GLuint id, GLenum value, GLint * data
#define glGetInvariantIntegervEXT_PACKED PACKED_glGetInvariantIntegervEXT
#define glGetInvariantIntegervEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetInvariantIntegervEXT_NOT_VOID_WRAP(...) {}
#define pack_glGetInvariantIntegervEXT(_id, _value, _data) ({ \
    glGetInvariantIntegervEXT_PACKED *packed_data = malloc(sizeof(glGetInvariantIntegervEXT_PACKED)); \
    packed_data->index = glGetInvariantIntegervEXT_INDEX; \
    packed_data->args.id = (GLuint)_id; \
    packed_data->args.value = (GLenum)_value; \
    packed_data->args.data = (GLint *)_data; \
    (packed_call_t *)packed_data; \
})
#define call_glGetInvariantIntegervEXT(packed, ret_v) do { \
    PACKED_glGetInvariantIntegervEXT *unpacked = (PACKED_glGetInvariantIntegervEXT *)packed; \
    ARGS_glGetInvariantIntegervEXT *args = (ARGS_glGetInvariantIntegervEXT *)&unpacked->args; \
    glGetInvariantIntegervEXT(args->id, args->value, args->data);; \
} while(0)
void glGetInvariantIntegervEXT(glGetInvariantIntegervEXT_ARG_EXPAND);
typedef void (*glGetInvariantIntegervEXT_PTR)(glGetInvariantIntegervEXT_ARG_EXPAND);
#define glGetLightfv_INDEX 812
#define glGetLightfv_RETURN void
#define glGetLightfv_ARG_NAMES light, pname, params
#define glGetLightfv_ARG_EXPAND GLenum light, GLenum pname, GLfloat * params
#define glGetLightfv_PACKED PACKED_glGetLightfv
#define glGetLightfv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetLightfv_NOT_VOID_WRAP(...) {}
#define pack_glGetLightfv(_light, _pname, _params) ({ \
    glGetLightfv_PACKED *packed_data = malloc(sizeof(glGetLightfv_PACKED)); \
    packed_data->index = glGetLightfv_INDEX; \
    packed_data->args.light = (GLenum)_light; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLfloat *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetLightfv(packed, ret_v) do { \
    PACKED_glGetLightfv *unpacked = (PACKED_glGetLightfv *)packed; \
    ARGS_glGetLightfv *args = (ARGS_glGetLightfv *)&unpacked->args; \
    glGetLightfv(args->light, args->pname, args->params);; \
} while(0)
void glGetLightfv(glGetLightfv_ARG_EXPAND);
typedef void (*glGetLightfv_PTR)(glGetLightfv_ARG_EXPAND);
#define glGetLightiv_INDEX 813
#define glGetLightiv_RETURN void
#define glGetLightiv_ARG_NAMES light, pname, params
#define glGetLightiv_ARG_EXPAND GLenum light, GLenum pname, GLint * params
#define glGetLightiv_PACKED PACKED_glGetLightiv
#define glGetLightiv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetLightiv_NOT_VOID_WRAP(...) {}
#define pack_glGetLightiv(_light, _pname, _params) ({ \
    glGetLightiv_PACKED *packed_data = malloc(sizeof(glGetLightiv_PACKED)); \
    packed_data->index = glGetLightiv_INDEX; \
    packed_data->args.light = (GLenum)_light; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetLightiv(packed, ret_v) do { \
    PACKED_glGetLightiv *unpacked = (PACKED_glGetLightiv *)packed; \
    ARGS_glGetLightiv *args = (ARGS_glGetLightiv *)&unpacked->args; \
    glGetLightiv(args->light, args->pname, args->params);; \
} while(0)
void glGetLightiv(glGetLightiv_ARG_EXPAND);
typedef void (*glGetLightiv_PTR)(glGetLightiv_ARG_EXPAND);
#define glGetLightxOES_INDEX 814
#define glGetLightxOES_RETURN void
#define glGetLightxOES_ARG_NAMES light, pname, params
#define glGetLightxOES_ARG_EXPAND GLenum light, GLenum pname, GLfixed * params
#define glGetLightxOES_PACKED PACKED_glGetLightxOES
#define glGetLightxOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetLightxOES_NOT_VOID_WRAP(...) {}
#define pack_glGetLightxOES(_light, _pname, _params) ({ \
    glGetLightxOES_PACKED *packed_data = malloc(sizeof(glGetLightxOES_PACKED)); \
    packed_data->index = glGetLightxOES_INDEX; \
    packed_data->args.light = (GLenum)_light; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLfixed *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetLightxOES(packed, ret_v) do { \
    PACKED_glGetLightxOES *unpacked = (PACKED_glGetLightxOES *)packed; \
    ARGS_glGetLightxOES *args = (ARGS_glGetLightxOES *)&unpacked->args; \
    glGetLightxOES(args->light, args->pname, args->params);; \
} while(0)
void glGetLightxOES(glGetLightxOES_ARG_EXPAND);
typedef void (*glGetLightxOES_PTR)(glGetLightxOES_ARG_EXPAND);
#define glGetLightxv_INDEX 815
#define glGetLightxv_RETURN void
#define glGetLightxv_ARG_NAMES light, pname, params
#define glGetLightxv_ARG_EXPAND GLenum light, GLenum pname, GLfixed * params
#define glGetLightxv_PACKED PACKED_glGetLightxv
#define glGetLightxv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetLightxv_NOT_VOID_WRAP(...) {}
#define pack_glGetLightxv(_light, _pname, _params) ({ \
    glGetLightxv_PACKED *packed_data = malloc(sizeof(glGetLightxv_PACKED)); \
    packed_data->index = glGetLightxv_INDEX; \
    packed_data->args.light = (GLenum)_light; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLfixed *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetLightxv(packed, ret_v) do { \
    PACKED_glGetLightxv *unpacked = (PACKED_glGetLightxv *)packed; \
    ARGS_glGetLightxv *args = (ARGS_glGetLightxv *)&unpacked->args; \
    glGetLightxv(args->light, args->pname, args->params);; \
} while(0)
void glGetLightxv(glGetLightxv_ARG_EXPAND);
typedef void (*glGetLightxv_PTR)(glGetLightxv_ARG_EXPAND);
#define glGetListParameterfvSGIX_INDEX 816
#define glGetListParameterfvSGIX_RETURN void
#define glGetListParameterfvSGIX_ARG_NAMES list, pname, params
#define glGetListParameterfvSGIX_ARG_EXPAND GLuint list, GLenum pname, GLfloat * params
#define glGetListParameterfvSGIX_PACKED PACKED_glGetListParameterfvSGIX
#define glGetListParameterfvSGIX_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetListParameterfvSGIX_NOT_VOID_WRAP(...) {}
#define pack_glGetListParameterfvSGIX(_list, _pname, _params) ({ \
    glGetListParameterfvSGIX_PACKED *packed_data = malloc(sizeof(glGetListParameterfvSGIX_PACKED)); \
    packed_data->index = glGetListParameterfvSGIX_INDEX; \
    packed_data->args.list = (GLuint)_list; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLfloat *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetListParameterfvSGIX(packed, ret_v) do { \
    PACKED_glGetListParameterfvSGIX *unpacked = (PACKED_glGetListParameterfvSGIX *)packed; \
    ARGS_glGetListParameterfvSGIX *args = (ARGS_glGetListParameterfvSGIX *)&unpacked->args; \
    glGetListParameterfvSGIX(args->list, args->pname, args->params);; \
} while(0)
void glGetListParameterfvSGIX(glGetListParameterfvSGIX_ARG_EXPAND);
typedef void (*glGetListParameterfvSGIX_PTR)(glGetListParameterfvSGIX_ARG_EXPAND);
#define glGetListParameterivSGIX_INDEX 817
#define glGetListParameterivSGIX_RETURN void
#define glGetListParameterivSGIX_ARG_NAMES list, pname, params
#define glGetListParameterivSGIX_ARG_EXPAND GLuint list, GLenum pname, GLint * params
#define glGetListParameterivSGIX_PACKED PACKED_glGetListParameterivSGIX
#define glGetListParameterivSGIX_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetListParameterivSGIX_NOT_VOID_WRAP(...) {}
#define pack_glGetListParameterivSGIX(_list, _pname, _params) ({ \
    glGetListParameterivSGIX_PACKED *packed_data = malloc(sizeof(glGetListParameterivSGIX_PACKED)); \
    packed_data->index = glGetListParameterivSGIX_INDEX; \
    packed_data->args.list = (GLuint)_list; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetListParameterivSGIX(packed, ret_v) do { \
    PACKED_glGetListParameterivSGIX *unpacked = (PACKED_glGetListParameterivSGIX *)packed; \
    ARGS_glGetListParameterivSGIX *args = (ARGS_glGetListParameterivSGIX *)&unpacked->args; \
    glGetListParameterivSGIX(args->list, args->pname, args->params);; \
} while(0)
void glGetListParameterivSGIX(glGetListParameterivSGIX_ARG_EXPAND);
typedef void (*glGetListParameterivSGIX_PTR)(glGetListParameterivSGIX_ARG_EXPAND);
#define glGetLocalConstantBooleanvEXT_INDEX 818
#define glGetLocalConstantBooleanvEXT_RETURN void
#define glGetLocalConstantBooleanvEXT_ARG_NAMES id, value, data
#define glGetLocalConstantBooleanvEXT_ARG_EXPAND GLuint id, GLenum value, GLboolean * data
#define glGetLocalConstantBooleanvEXT_PACKED PACKED_glGetLocalConstantBooleanvEXT
#define glGetLocalConstantBooleanvEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetLocalConstantBooleanvEXT_NOT_VOID_WRAP(...) {}
#define pack_glGetLocalConstantBooleanvEXT(_id, _value, _data) ({ \
    glGetLocalConstantBooleanvEXT_PACKED *packed_data = malloc(sizeof(glGetLocalConstantBooleanvEXT_PACKED)); \
    packed_data->index = glGetLocalConstantBooleanvEXT_INDEX; \
    packed_data->args.id = (GLuint)_id; \
    packed_data->args.value = (GLenum)_value; \
    packed_data->args.data = (GLboolean *)_data; \
    (packed_call_t *)packed_data; \
})
#define call_glGetLocalConstantBooleanvEXT(packed, ret_v) do { \
    PACKED_glGetLocalConstantBooleanvEXT *unpacked = (PACKED_glGetLocalConstantBooleanvEXT *)packed; \
    ARGS_glGetLocalConstantBooleanvEXT *args = (ARGS_glGetLocalConstantBooleanvEXT *)&unpacked->args; \
    glGetLocalConstantBooleanvEXT(args->id, args->value, args->data);; \
} while(0)
void glGetLocalConstantBooleanvEXT(glGetLocalConstantBooleanvEXT_ARG_EXPAND);
typedef void (*glGetLocalConstantBooleanvEXT_PTR)(glGetLocalConstantBooleanvEXT_ARG_EXPAND);
#define glGetLocalConstantFloatvEXT_INDEX 819
#define glGetLocalConstantFloatvEXT_RETURN void
#define glGetLocalConstantFloatvEXT_ARG_NAMES id, value, data
#define glGetLocalConstantFloatvEXT_ARG_EXPAND GLuint id, GLenum value, GLfloat * data
#define glGetLocalConstantFloatvEXT_PACKED PACKED_glGetLocalConstantFloatvEXT
#define glGetLocalConstantFloatvEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetLocalConstantFloatvEXT_NOT_VOID_WRAP(...) {}
#define pack_glGetLocalConstantFloatvEXT(_id, _value, _data) ({ \
    glGetLocalConstantFloatvEXT_PACKED *packed_data = malloc(sizeof(glGetLocalConstantFloatvEXT_PACKED)); \
    packed_data->index = glGetLocalConstantFloatvEXT_INDEX; \
    packed_data->args.id = (GLuint)_id; \
    packed_data->args.value = (GLenum)_value; \
    packed_data->args.data = (GLfloat *)_data; \
    (packed_call_t *)packed_data; \
})
#define call_glGetLocalConstantFloatvEXT(packed, ret_v) do { \
    PACKED_glGetLocalConstantFloatvEXT *unpacked = (PACKED_glGetLocalConstantFloatvEXT *)packed; \
    ARGS_glGetLocalConstantFloatvEXT *args = (ARGS_glGetLocalConstantFloatvEXT *)&unpacked->args; \
    glGetLocalConstantFloatvEXT(args->id, args->value, args->data);; \
} while(0)
void glGetLocalConstantFloatvEXT(glGetLocalConstantFloatvEXT_ARG_EXPAND);
typedef void (*glGetLocalConstantFloatvEXT_PTR)(glGetLocalConstantFloatvEXT_ARG_EXPAND);
#define glGetLocalConstantIntegervEXT_INDEX 820
#define glGetLocalConstantIntegervEXT_RETURN void
#define glGetLocalConstantIntegervEXT_ARG_NAMES id, value, data
#define glGetLocalConstantIntegervEXT_ARG_EXPAND GLuint id, GLenum value, GLint * data
#define glGetLocalConstantIntegervEXT_PACKED PACKED_glGetLocalConstantIntegervEXT
#define glGetLocalConstantIntegervEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetLocalConstantIntegervEXT_NOT_VOID_WRAP(...) {}
#define pack_glGetLocalConstantIntegervEXT(_id, _value, _data) ({ \
    glGetLocalConstantIntegervEXT_PACKED *packed_data = malloc(sizeof(glGetLocalConstantIntegervEXT_PACKED)); \
    packed_data->index = glGetLocalConstantIntegervEXT_INDEX; \
    packed_data->args.id = (GLuint)_id; \
    packed_data->args.value = (GLenum)_value; \
    packed_data->args.data = (GLint *)_data; \
    (packed_call_t *)packed_data; \
})
#define call_glGetLocalConstantIntegervEXT(packed, ret_v) do { \
    PACKED_glGetLocalConstantIntegervEXT *unpacked = (PACKED_glGetLocalConstantIntegervEXT *)packed; \
    ARGS_glGetLocalConstantIntegervEXT *args = (ARGS_glGetLocalConstantIntegervEXT *)&unpacked->args; \
    glGetLocalConstantIntegervEXT(args->id, args->value, args->data);; \
} while(0)
void glGetLocalConstantIntegervEXT(glGetLocalConstantIntegervEXT_ARG_EXPAND);
typedef void (*glGetLocalConstantIntegervEXT_PTR)(glGetLocalConstantIntegervEXT_ARG_EXPAND);
#define glGetMapAttribParameterfvNV_INDEX 821
#define glGetMapAttribParameterfvNV_RETURN void
#define glGetMapAttribParameterfvNV_ARG_NAMES target, index, pname, params
#define glGetMapAttribParameterfvNV_ARG_EXPAND GLenum target, GLuint index, GLenum pname, GLfloat * params
#define glGetMapAttribParameterfvNV_PACKED PACKED_glGetMapAttribParameterfvNV
#define glGetMapAttribParameterfvNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetMapAttribParameterfvNV_NOT_VOID_WRAP(...) {}
#define pack_glGetMapAttribParameterfvNV(_target, _index, _pname, _params) ({ \
    glGetMapAttribParameterfvNV_PACKED *packed_data = malloc(sizeof(glGetMapAttribParameterfvNV_PACKED)); \
    packed_data->index = glGetMapAttribParameterfvNV_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLfloat *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetMapAttribParameterfvNV(packed, ret_v) do { \
    PACKED_glGetMapAttribParameterfvNV *unpacked = (PACKED_glGetMapAttribParameterfvNV *)packed; \
    ARGS_glGetMapAttribParameterfvNV *args = (ARGS_glGetMapAttribParameterfvNV *)&unpacked->args; \
    glGetMapAttribParameterfvNV(args->target, args->index, args->pname, args->params);; \
} while(0)
void glGetMapAttribParameterfvNV(glGetMapAttribParameterfvNV_ARG_EXPAND);
typedef void (*glGetMapAttribParameterfvNV_PTR)(glGetMapAttribParameterfvNV_ARG_EXPAND);
#define glGetMapAttribParameterivNV_INDEX 822
#define glGetMapAttribParameterivNV_RETURN void
#define glGetMapAttribParameterivNV_ARG_NAMES target, index, pname, params
#define glGetMapAttribParameterivNV_ARG_EXPAND GLenum target, GLuint index, GLenum pname, GLint * params
#define glGetMapAttribParameterivNV_PACKED PACKED_glGetMapAttribParameterivNV
#define glGetMapAttribParameterivNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetMapAttribParameterivNV_NOT_VOID_WRAP(...) {}
#define pack_glGetMapAttribParameterivNV(_target, _index, _pname, _params) ({ \
    glGetMapAttribParameterivNV_PACKED *packed_data = malloc(sizeof(glGetMapAttribParameterivNV_PACKED)); \
    packed_data->index = glGetMapAttribParameterivNV_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetMapAttribParameterivNV(packed, ret_v) do { \
    PACKED_glGetMapAttribParameterivNV *unpacked = (PACKED_glGetMapAttribParameterivNV *)packed; \
    ARGS_glGetMapAttribParameterivNV *args = (ARGS_glGetMapAttribParameterivNV *)&unpacked->args; \
    glGetMapAttribParameterivNV(args->target, args->index, args->pname, args->params);; \
} while(0)
void glGetMapAttribParameterivNV(glGetMapAttribParameterivNV_ARG_EXPAND);
typedef void (*glGetMapAttribParameterivNV_PTR)(glGetMapAttribParameterivNV_ARG_EXPAND);
#define glGetMapControlPointsNV_INDEX 823
#define glGetMapControlPointsNV_RETURN void
#define glGetMapControlPointsNV_ARG_NAMES target, index, type, ustride, vstride, packed, points
#define glGetMapControlPointsNV_ARG_EXPAND GLenum target, GLuint index, GLenum type, GLsizei ustride, GLsizei vstride, GLboolean packed, GLvoid * points
#define glGetMapControlPointsNV_PACKED PACKED_glGetMapControlPointsNV
#define glGetMapControlPointsNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetMapControlPointsNV_NOT_VOID_WRAP(...) {}
#define pack_glGetMapControlPointsNV(_target, _index, _type, _ustride, _vstride, _packed, _points) ({ \
    glGetMapControlPointsNV_PACKED *packed_data = malloc(sizeof(glGetMapControlPointsNV_PACKED)); \
    packed_data->index = glGetMapControlPointsNV_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.ustride = (GLsizei)_ustride; \
    packed_data->args.vstride = (GLsizei)_vstride; \
    packed_data->args.packed = (GLboolean)_packed; \
    packed_data->args.points = (GLvoid *)_points; \
    (packed_call_t *)packed_data; \
})
#define call_glGetMapControlPointsNV(packed, ret_v) do { \
    PACKED_glGetMapControlPointsNV *unpacked = (PACKED_glGetMapControlPointsNV *)packed; \
    ARGS_glGetMapControlPointsNV *args = (ARGS_glGetMapControlPointsNV *)&unpacked->args; \
    glGetMapControlPointsNV(args->target, args->index, args->type, args->ustride, args->vstride, args->packed, args->points);; \
} while(0)
void glGetMapControlPointsNV(glGetMapControlPointsNV_ARG_EXPAND);
typedef void (*glGetMapControlPointsNV_PTR)(glGetMapControlPointsNV_ARG_EXPAND);
#define glGetMapParameterfvNV_INDEX 824
#define glGetMapParameterfvNV_RETURN void
#define glGetMapParameterfvNV_ARG_NAMES target, pname, params
#define glGetMapParameterfvNV_ARG_EXPAND GLenum target, GLenum pname, GLfloat * params
#define glGetMapParameterfvNV_PACKED PACKED_glGetMapParameterfvNV
#define glGetMapParameterfvNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetMapParameterfvNV_NOT_VOID_WRAP(...) {}
#define pack_glGetMapParameterfvNV(_target, _pname, _params) ({ \
    glGetMapParameterfvNV_PACKED *packed_data = malloc(sizeof(glGetMapParameterfvNV_PACKED)); \
    packed_data->index = glGetMapParameterfvNV_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLfloat *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetMapParameterfvNV(packed, ret_v) do { \
    PACKED_glGetMapParameterfvNV *unpacked = (PACKED_glGetMapParameterfvNV *)packed; \
    ARGS_glGetMapParameterfvNV *args = (ARGS_glGetMapParameterfvNV *)&unpacked->args; \
    glGetMapParameterfvNV(args->target, args->pname, args->params);; \
} while(0)
void glGetMapParameterfvNV(glGetMapParameterfvNV_ARG_EXPAND);
typedef void (*glGetMapParameterfvNV_PTR)(glGetMapParameterfvNV_ARG_EXPAND);
#define glGetMapParameterivNV_INDEX 825
#define glGetMapParameterivNV_RETURN void
#define glGetMapParameterivNV_ARG_NAMES target, pname, params
#define glGetMapParameterivNV_ARG_EXPAND GLenum target, GLenum pname, GLint * params
#define glGetMapParameterivNV_PACKED PACKED_glGetMapParameterivNV
#define glGetMapParameterivNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetMapParameterivNV_NOT_VOID_WRAP(...) {}
#define pack_glGetMapParameterivNV(_target, _pname, _params) ({ \
    glGetMapParameterivNV_PACKED *packed_data = malloc(sizeof(glGetMapParameterivNV_PACKED)); \
    packed_data->index = glGetMapParameterivNV_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetMapParameterivNV(packed, ret_v) do { \
    PACKED_glGetMapParameterivNV *unpacked = (PACKED_glGetMapParameterivNV *)packed; \
    ARGS_glGetMapParameterivNV *args = (ARGS_glGetMapParameterivNV *)&unpacked->args; \
    glGetMapParameterivNV(args->target, args->pname, args->params);; \
} while(0)
void glGetMapParameterivNV(glGetMapParameterivNV_ARG_EXPAND);
typedef void (*glGetMapParameterivNV_PTR)(glGetMapParameterivNV_ARG_EXPAND);
#define glGetMapdv_INDEX 826
#define glGetMapdv_RETURN void
#define glGetMapdv_ARG_NAMES target, query, v
#define glGetMapdv_ARG_EXPAND GLenum target, GLenum query, GLdouble * v
#define glGetMapdv_PACKED PACKED_glGetMapdv
#define glGetMapdv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetMapdv_NOT_VOID_WRAP(...) {}
#define pack_glGetMapdv(_target, _query, _v) ({ \
    glGetMapdv_PACKED *packed_data = malloc(sizeof(glGetMapdv_PACKED)); \
    packed_data->index = glGetMapdv_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.query = (GLenum)_query; \
    packed_data->args.v = (GLdouble *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glGetMapdv(packed, ret_v) do { \
    PACKED_glGetMapdv *unpacked = (PACKED_glGetMapdv *)packed; \
    ARGS_glGetMapdv *args = (ARGS_glGetMapdv *)&unpacked->args; \
    glGetMapdv(args->target, args->query, args->v);; \
} while(0)
void glGetMapdv(glGetMapdv_ARG_EXPAND);
typedef void (*glGetMapdv_PTR)(glGetMapdv_ARG_EXPAND);
#define glGetMapfv_INDEX 827
#define glGetMapfv_RETURN void
#define glGetMapfv_ARG_NAMES target, query, v
#define glGetMapfv_ARG_EXPAND GLenum target, GLenum query, GLfloat * v
#define glGetMapfv_PACKED PACKED_glGetMapfv
#define glGetMapfv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetMapfv_NOT_VOID_WRAP(...) {}
#define pack_glGetMapfv(_target, _query, _v) ({ \
    glGetMapfv_PACKED *packed_data = malloc(sizeof(glGetMapfv_PACKED)); \
    packed_data->index = glGetMapfv_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.query = (GLenum)_query; \
    packed_data->args.v = (GLfloat *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glGetMapfv(packed, ret_v) do { \
    PACKED_glGetMapfv *unpacked = (PACKED_glGetMapfv *)packed; \
    ARGS_glGetMapfv *args = (ARGS_glGetMapfv *)&unpacked->args; \
    glGetMapfv(args->target, args->query, args->v);; \
} while(0)
void glGetMapfv(glGetMapfv_ARG_EXPAND);
typedef void (*glGetMapfv_PTR)(glGetMapfv_ARG_EXPAND);
#define glGetMapiv_INDEX 828
#define glGetMapiv_RETURN void
#define glGetMapiv_ARG_NAMES target, query, v
#define glGetMapiv_ARG_EXPAND GLenum target, GLenum query, GLint * v
#define glGetMapiv_PACKED PACKED_glGetMapiv
#define glGetMapiv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetMapiv_NOT_VOID_WRAP(...) {}
#define pack_glGetMapiv(_target, _query, _v) ({ \
    glGetMapiv_PACKED *packed_data = malloc(sizeof(glGetMapiv_PACKED)); \
    packed_data->index = glGetMapiv_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.query = (GLenum)_query; \
    packed_data->args.v = (GLint *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glGetMapiv(packed, ret_v) do { \
    PACKED_glGetMapiv *unpacked = (PACKED_glGetMapiv *)packed; \
    ARGS_glGetMapiv *args = (ARGS_glGetMapiv *)&unpacked->args; \
    glGetMapiv(args->target, args->query, args->v);; \
} while(0)
void glGetMapiv(glGetMapiv_ARG_EXPAND);
typedef void (*glGetMapiv_PTR)(glGetMapiv_ARG_EXPAND);
#define glGetMapxvOES_INDEX 829
#define glGetMapxvOES_RETURN void
#define glGetMapxvOES_ARG_NAMES target, query, v
#define glGetMapxvOES_ARG_EXPAND GLenum target, GLenum query, GLfixed * v
#define glGetMapxvOES_PACKED PACKED_glGetMapxvOES
#define glGetMapxvOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetMapxvOES_NOT_VOID_WRAP(...) {}
#define pack_glGetMapxvOES(_target, _query, _v) ({ \
    glGetMapxvOES_PACKED *packed_data = malloc(sizeof(glGetMapxvOES_PACKED)); \
    packed_data->index = glGetMapxvOES_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.query = (GLenum)_query; \
    packed_data->args.v = (GLfixed *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glGetMapxvOES(packed, ret_v) do { \
    PACKED_glGetMapxvOES *unpacked = (PACKED_glGetMapxvOES *)packed; \
    ARGS_glGetMapxvOES *args = (ARGS_glGetMapxvOES *)&unpacked->args; \
    glGetMapxvOES(args->target, args->query, args->v);; \
} while(0)
void glGetMapxvOES(glGetMapxvOES_ARG_EXPAND);
typedef void (*glGetMapxvOES_PTR)(glGetMapxvOES_ARG_EXPAND);
#define glGetMaterialfv_INDEX 830
#define glGetMaterialfv_RETURN void
#define glGetMaterialfv_ARG_NAMES face, pname, params
#define glGetMaterialfv_ARG_EXPAND GLenum face, GLenum pname, GLfloat * params
#define glGetMaterialfv_PACKED PACKED_glGetMaterialfv
#define glGetMaterialfv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetMaterialfv_NOT_VOID_WRAP(...) {}
#define pack_glGetMaterialfv(_face, _pname, _params) ({ \
    glGetMaterialfv_PACKED *packed_data = malloc(sizeof(glGetMaterialfv_PACKED)); \
    packed_data->index = glGetMaterialfv_INDEX; \
    packed_data->args.face = (GLenum)_face; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLfloat *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetMaterialfv(packed, ret_v) do { \
    PACKED_glGetMaterialfv *unpacked = (PACKED_glGetMaterialfv *)packed; \
    ARGS_glGetMaterialfv *args = (ARGS_glGetMaterialfv *)&unpacked->args; \
    glGetMaterialfv(args->face, args->pname, args->params);; \
} while(0)
void glGetMaterialfv(glGetMaterialfv_ARG_EXPAND);
typedef void (*glGetMaterialfv_PTR)(glGetMaterialfv_ARG_EXPAND);
#define glGetMaterialiv_INDEX 831
#define glGetMaterialiv_RETURN void
#define glGetMaterialiv_ARG_NAMES face, pname, params
#define glGetMaterialiv_ARG_EXPAND GLenum face, GLenum pname, GLint * params
#define glGetMaterialiv_PACKED PACKED_glGetMaterialiv
#define glGetMaterialiv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetMaterialiv_NOT_VOID_WRAP(...) {}
#define pack_glGetMaterialiv(_face, _pname, _params) ({ \
    glGetMaterialiv_PACKED *packed_data = malloc(sizeof(glGetMaterialiv_PACKED)); \
    packed_data->index = glGetMaterialiv_INDEX; \
    packed_data->args.face = (GLenum)_face; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetMaterialiv(packed, ret_v) do { \
    PACKED_glGetMaterialiv *unpacked = (PACKED_glGetMaterialiv *)packed; \
    ARGS_glGetMaterialiv *args = (ARGS_glGetMaterialiv *)&unpacked->args; \
    glGetMaterialiv(args->face, args->pname, args->params);; \
} while(0)
void glGetMaterialiv(glGetMaterialiv_ARG_EXPAND);
typedef void (*glGetMaterialiv_PTR)(glGetMaterialiv_ARG_EXPAND);
#define glGetMaterialxOES_INDEX 832
#define glGetMaterialxOES_RETURN void
#define glGetMaterialxOES_ARG_NAMES face, pname, param
#define glGetMaterialxOES_ARG_EXPAND GLenum face, GLenum pname, GLfixed param
#define glGetMaterialxOES_PACKED PACKED_glGetMaterialxOES
#define glGetMaterialxOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetMaterialxOES_NOT_VOID_WRAP(...) {}
#define pack_glGetMaterialxOES(_face, _pname, _param) ({ \
    glGetMaterialxOES_PACKED *packed_data = malloc(sizeof(glGetMaterialxOES_PACKED)); \
    packed_data->index = glGetMaterialxOES_INDEX; \
    packed_data->args.face = (GLenum)_face; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.param = (GLfixed)_param; \
    (packed_call_t *)packed_data; \
})
#define call_glGetMaterialxOES(packed, ret_v) do { \
    PACKED_glGetMaterialxOES *unpacked = (PACKED_glGetMaterialxOES *)packed; \
    ARGS_glGetMaterialxOES *args = (ARGS_glGetMaterialxOES *)&unpacked->args; \
    glGetMaterialxOES(args->face, args->pname, args->param);; \
} while(0)
void glGetMaterialxOES(glGetMaterialxOES_ARG_EXPAND);
typedef void (*glGetMaterialxOES_PTR)(glGetMaterialxOES_ARG_EXPAND);
#define glGetMaterialxv_INDEX 833
#define glGetMaterialxv_RETURN void
#define glGetMaterialxv_ARG_NAMES face, pname, params
#define glGetMaterialxv_ARG_EXPAND GLenum face, GLenum pname, GLfixed * params
#define glGetMaterialxv_PACKED PACKED_glGetMaterialxv
#define glGetMaterialxv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetMaterialxv_NOT_VOID_WRAP(...) {}
#define pack_glGetMaterialxv(_face, _pname, _params) ({ \
    glGetMaterialxv_PACKED *packed_data = malloc(sizeof(glGetMaterialxv_PACKED)); \
    packed_data->index = glGetMaterialxv_INDEX; \
    packed_data->args.face = (GLenum)_face; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLfixed *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetMaterialxv(packed, ret_v) do { \
    PACKED_glGetMaterialxv *unpacked = (PACKED_glGetMaterialxv *)packed; \
    ARGS_glGetMaterialxv *args = (ARGS_glGetMaterialxv *)&unpacked->args; \
    glGetMaterialxv(args->face, args->pname, args->params);; \
} while(0)
void glGetMaterialxv(glGetMaterialxv_ARG_EXPAND);
typedef void (*glGetMaterialxv_PTR)(glGetMaterialxv_ARG_EXPAND);
#define glGetMinmax_INDEX 834
#define glGetMinmax_RETURN void
#define glGetMinmax_ARG_NAMES target, reset, format, type, values
#define glGetMinmax_ARG_EXPAND GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid * values
#define glGetMinmax_PACKED PACKED_glGetMinmax
#define glGetMinmax_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetMinmax_NOT_VOID_WRAP(...) {}
#define pack_glGetMinmax(_target, _reset, _format, _type, _values) ({ \
    glGetMinmax_PACKED *packed_data = malloc(sizeof(glGetMinmax_PACKED)); \
    packed_data->index = glGetMinmax_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.reset = (GLboolean)_reset; \
    packed_data->args.format = (GLenum)_format; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.values = (GLvoid *)_values; \
    (packed_call_t *)packed_data; \
})
#define call_glGetMinmax(packed, ret_v) do { \
    PACKED_glGetMinmax *unpacked = (PACKED_glGetMinmax *)packed; \
    ARGS_glGetMinmax *args = (ARGS_glGetMinmax *)&unpacked->args; \
    glGetMinmax(args->target, args->reset, args->format, args->type, args->values);; \
} while(0)
void glGetMinmax(glGetMinmax_ARG_EXPAND);
typedef void (*glGetMinmax_PTR)(glGetMinmax_ARG_EXPAND);
#define glGetMinmaxEXT_INDEX 835
#define glGetMinmaxEXT_RETURN void
#define glGetMinmaxEXT_ARG_NAMES target, reset, format, type, values
#define glGetMinmaxEXT_ARG_EXPAND GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid * values
#define glGetMinmaxEXT_PACKED PACKED_glGetMinmaxEXT
#define glGetMinmaxEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetMinmaxEXT_NOT_VOID_WRAP(...) {}
#define pack_glGetMinmaxEXT(_target, _reset, _format, _type, _values) ({ \
    glGetMinmaxEXT_PACKED *packed_data = malloc(sizeof(glGetMinmaxEXT_PACKED)); \
    packed_data->index = glGetMinmaxEXT_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.reset = (GLboolean)_reset; \
    packed_data->args.format = (GLenum)_format; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.values = (GLvoid *)_values; \
    (packed_call_t *)packed_data; \
})
#define call_glGetMinmaxEXT(packed, ret_v) do { \
    PACKED_glGetMinmaxEXT *unpacked = (PACKED_glGetMinmaxEXT *)packed; \
    ARGS_glGetMinmaxEXT *args = (ARGS_glGetMinmaxEXT *)&unpacked->args; \
    glGetMinmaxEXT(args->target, args->reset, args->format, args->type, args->values);; \
} while(0)
void glGetMinmaxEXT(glGetMinmaxEXT_ARG_EXPAND);
typedef void (*glGetMinmaxEXT_PTR)(glGetMinmaxEXT_ARG_EXPAND);
#define glGetMinmaxParameterfv_INDEX 836
#define glGetMinmaxParameterfv_RETURN void
#define glGetMinmaxParameterfv_ARG_NAMES target, pname, params
#define glGetMinmaxParameterfv_ARG_EXPAND GLenum target, GLenum pname, GLfloat * params
#define glGetMinmaxParameterfv_PACKED PACKED_glGetMinmaxParameterfv
#define glGetMinmaxParameterfv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetMinmaxParameterfv_NOT_VOID_WRAP(...) {}
#define pack_glGetMinmaxParameterfv(_target, _pname, _params) ({ \
    glGetMinmaxParameterfv_PACKED *packed_data = malloc(sizeof(glGetMinmaxParameterfv_PACKED)); \
    packed_data->index = glGetMinmaxParameterfv_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLfloat *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetMinmaxParameterfv(packed, ret_v) do { \
    PACKED_glGetMinmaxParameterfv *unpacked = (PACKED_glGetMinmaxParameterfv *)packed; \
    ARGS_glGetMinmaxParameterfv *args = (ARGS_glGetMinmaxParameterfv *)&unpacked->args; \
    glGetMinmaxParameterfv(args->target, args->pname, args->params);; \
} while(0)
void glGetMinmaxParameterfv(glGetMinmaxParameterfv_ARG_EXPAND);
typedef void (*glGetMinmaxParameterfv_PTR)(glGetMinmaxParameterfv_ARG_EXPAND);
#define glGetMinmaxParameterfvEXT_INDEX 837
#define glGetMinmaxParameterfvEXT_RETURN void
#define glGetMinmaxParameterfvEXT_ARG_NAMES target, pname, params
#define glGetMinmaxParameterfvEXT_ARG_EXPAND GLenum target, GLenum pname, GLfloat * params
#define glGetMinmaxParameterfvEXT_PACKED PACKED_glGetMinmaxParameterfvEXT
#define glGetMinmaxParameterfvEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetMinmaxParameterfvEXT_NOT_VOID_WRAP(...) {}
#define pack_glGetMinmaxParameterfvEXT(_target, _pname, _params) ({ \
    glGetMinmaxParameterfvEXT_PACKED *packed_data = malloc(sizeof(glGetMinmaxParameterfvEXT_PACKED)); \
    packed_data->index = glGetMinmaxParameterfvEXT_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLfloat *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetMinmaxParameterfvEXT(packed, ret_v) do { \
    PACKED_glGetMinmaxParameterfvEXT *unpacked = (PACKED_glGetMinmaxParameterfvEXT *)packed; \
    ARGS_glGetMinmaxParameterfvEXT *args = (ARGS_glGetMinmaxParameterfvEXT *)&unpacked->args; \
    glGetMinmaxParameterfvEXT(args->target, args->pname, args->params);; \
} while(0)
void glGetMinmaxParameterfvEXT(glGetMinmaxParameterfvEXT_ARG_EXPAND);
typedef void (*glGetMinmaxParameterfvEXT_PTR)(glGetMinmaxParameterfvEXT_ARG_EXPAND);
#define glGetMinmaxParameteriv_INDEX 838
#define glGetMinmaxParameteriv_RETURN void
#define glGetMinmaxParameteriv_ARG_NAMES target, pname, params
#define glGetMinmaxParameteriv_ARG_EXPAND GLenum target, GLenum pname, GLint * params
#define glGetMinmaxParameteriv_PACKED PACKED_glGetMinmaxParameteriv
#define glGetMinmaxParameteriv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetMinmaxParameteriv_NOT_VOID_WRAP(...) {}
#define pack_glGetMinmaxParameteriv(_target, _pname, _params) ({ \
    glGetMinmaxParameteriv_PACKED *packed_data = malloc(sizeof(glGetMinmaxParameteriv_PACKED)); \
    packed_data->index = glGetMinmaxParameteriv_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetMinmaxParameteriv(packed, ret_v) do { \
    PACKED_glGetMinmaxParameteriv *unpacked = (PACKED_glGetMinmaxParameteriv *)packed; \
    ARGS_glGetMinmaxParameteriv *args = (ARGS_glGetMinmaxParameteriv *)&unpacked->args; \
    glGetMinmaxParameteriv(args->target, args->pname, args->params);; \
} while(0)
void glGetMinmaxParameteriv(glGetMinmaxParameteriv_ARG_EXPAND);
typedef void (*glGetMinmaxParameteriv_PTR)(glGetMinmaxParameteriv_ARG_EXPAND);
#define glGetMinmaxParameterivEXT_INDEX 839
#define glGetMinmaxParameterivEXT_RETURN void
#define glGetMinmaxParameterivEXT_ARG_NAMES target, pname, params
#define glGetMinmaxParameterivEXT_ARG_EXPAND GLenum target, GLenum pname, GLint * params
#define glGetMinmaxParameterivEXT_PACKED PACKED_glGetMinmaxParameterivEXT
#define glGetMinmaxParameterivEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetMinmaxParameterivEXT_NOT_VOID_WRAP(...) {}
#define pack_glGetMinmaxParameterivEXT(_target, _pname, _params) ({ \
    glGetMinmaxParameterivEXT_PACKED *packed_data = malloc(sizeof(glGetMinmaxParameterivEXT_PACKED)); \
    packed_data->index = glGetMinmaxParameterivEXT_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetMinmaxParameterivEXT(packed, ret_v) do { \
    PACKED_glGetMinmaxParameterivEXT *unpacked = (PACKED_glGetMinmaxParameterivEXT *)packed; \
    ARGS_glGetMinmaxParameterivEXT *args = (ARGS_glGetMinmaxParameterivEXT *)&unpacked->args; \
    glGetMinmaxParameterivEXT(args->target, args->pname, args->params);; \
} while(0)
void glGetMinmaxParameterivEXT(glGetMinmaxParameterivEXT_ARG_EXPAND);
typedef void (*glGetMinmaxParameterivEXT_PTR)(glGetMinmaxParameterivEXT_ARG_EXPAND);
#define glGetMultiTexEnvfvEXT_INDEX 840
#define glGetMultiTexEnvfvEXT_RETURN void
#define glGetMultiTexEnvfvEXT_ARG_NAMES texunit, target, pname, params
#define glGetMultiTexEnvfvEXT_ARG_EXPAND GLenum texunit, GLenum target, GLenum pname, GLfloat * params
#define glGetMultiTexEnvfvEXT_PACKED PACKED_glGetMultiTexEnvfvEXT
#define glGetMultiTexEnvfvEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetMultiTexEnvfvEXT_NOT_VOID_WRAP(...) {}
#define pack_glGetMultiTexEnvfvEXT(_texunit, _target, _pname, _params) ({ \
    glGetMultiTexEnvfvEXT_PACKED *packed_data = malloc(sizeof(glGetMultiTexEnvfvEXT_PACKED)); \
    packed_data->index = glGetMultiTexEnvfvEXT_INDEX; \
    packed_data->args.texunit = (GLenum)_texunit; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLfloat *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetMultiTexEnvfvEXT(packed, ret_v) do { \
    PACKED_glGetMultiTexEnvfvEXT *unpacked = (PACKED_glGetMultiTexEnvfvEXT *)packed; \
    ARGS_glGetMultiTexEnvfvEXT *args = (ARGS_glGetMultiTexEnvfvEXT *)&unpacked->args; \
    glGetMultiTexEnvfvEXT(args->texunit, args->target, args->pname, args->params);; \
} while(0)
void glGetMultiTexEnvfvEXT(glGetMultiTexEnvfvEXT_ARG_EXPAND);
typedef void (*glGetMultiTexEnvfvEXT_PTR)(glGetMultiTexEnvfvEXT_ARG_EXPAND);
#define glGetMultiTexEnvivEXT_INDEX 841
#define glGetMultiTexEnvivEXT_RETURN void
#define glGetMultiTexEnvivEXT_ARG_NAMES texunit, target, pname, params
#define glGetMultiTexEnvivEXT_ARG_EXPAND GLenum texunit, GLenum target, GLenum pname, GLint * params
#define glGetMultiTexEnvivEXT_PACKED PACKED_glGetMultiTexEnvivEXT
#define glGetMultiTexEnvivEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetMultiTexEnvivEXT_NOT_VOID_WRAP(...) {}
#define pack_glGetMultiTexEnvivEXT(_texunit, _target, _pname, _params) ({ \
    glGetMultiTexEnvivEXT_PACKED *packed_data = malloc(sizeof(glGetMultiTexEnvivEXT_PACKED)); \
    packed_data->index = glGetMultiTexEnvivEXT_INDEX; \
    packed_data->args.texunit = (GLenum)_texunit; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetMultiTexEnvivEXT(packed, ret_v) do { \
    PACKED_glGetMultiTexEnvivEXT *unpacked = (PACKED_glGetMultiTexEnvivEXT *)packed; \
    ARGS_glGetMultiTexEnvivEXT *args = (ARGS_glGetMultiTexEnvivEXT *)&unpacked->args; \
    glGetMultiTexEnvivEXT(args->texunit, args->target, args->pname, args->params);; \
} while(0)
void glGetMultiTexEnvivEXT(glGetMultiTexEnvivEXT_ARG_EXPAND);
typedef void (*glGetMultiTexEnvivEXT_PTR)(glGetMultiTexEnvivEXT_ARG_EXPAND);
#define glGetMultiTexGendvEXT_INDEX 842
#define glGetMultiTexGendvEXT_RETURN void
#define glGetMultiTexGendvEXT_ARG_NAMES texunit, coord, pname, params
#define glGetMultiTexGendvEXT_ARG_EXPAND GLenum texunit, GLenum coord, GLenum pname, GLdouble * params
#define glGetMultiTexGendvEXT_PACKED PACKED_glGetMultiTexGendvEXT
#define glGetMultiTexGendvEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetMultiTexGendvEXT_NOT_VOID_WRAP(...) {}
#define pack_glGetMultiTexGendvEXT(_texunit, _coord, _pname, _params) ({ \
    glGetMultiTexGendvEXT_PACKED *packed_data = malloc(sizeof(glGetMultiTexGendvEXT_PACKED)); \
    packed_data->index = glGetMultiTexGendvEXT_INDEX; \
    packed_data->args.texunit = (GLenum)_texunit; \
    packed_data->args.coord = (GLenum)_coord; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLdouble *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetMultiTexGendvEXT(packed, ret_v) do { \
    PACKED_glGetMultiTexGendvEXT *unpacked = (PACKED_glGetMultiTexGendvEXT *)packed; \
    ARGS_glGetMultiTexGendvEXT *args = (ARGS_glGetMultiTexGendvEXT *)&unpacked->args; \
    glGetMultiTexGendvEXT(args->texunit, args->coord, args->pname, args->params);; \
} while(0)
void glGetMultiTexGendvEXT(glGetMultiTexGendvEXT_ARG_EXPAND);
typedef void (*glGetMultiTexGendvEXT_PTR)(glGetMultiTexGendvEXT_ARG_EXPAND);
#define glGetMultiTexGenfvEXT_INDEX 843
#define glGetMultiTexGenfvEXT_RETURN void
#define glGetMultiTexGenfvEXT_ARG_NAMES texunit, coord, pname, params
#define glGetMultiTexGenfvEXT_ARG_EXPAND GLenum texunit, GLenum coord, GLenum pname, GLfloat * params
#define glGetMultiTexGenfvEXT_PACKED PACKED_glGetMultiTexGenfvEXT
#define glGetMultiTexGenfvEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetMultiTexGenfvEXT_NOT_VOID_WRAP(...) {}
#define pack_glGetMultiTexGenfvEXT(_texunit, _coord, _pname, _params) ({ \
    glGetMultiTexGenfvEXT_PACKED *packed_data = malloc(sizeof(glGetMultiTexGenfvEXT_PACKED)); \
    packed_data->index = glGetMultiTexGenfvEXT_INDEX; \
    packed_data->args.texunit = (GLenum)_texunit; \
    packed_data->args.coord = (GLenum)_coord; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLfloat *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetMultiTexGenfvEXT(packed, ret_v) do { \
    PACKED_glGetMultiTexGenfvEXT *unpacked = (PACKED_glGetMultiTexGenfvEXT *)packed; \
    ARGS_glGetMultiTexGenfvEXT *args = (ARGS_glGetMultiTexGenfvEXT *)&unpacked->args; \
    glGetMultiTexGenfvEXT(args->texunit, args->coord, args->pname, args->params);; \
} while(0)
void glGetMultiTexGenfvEXT(glGetMultiTexGenfvEXT_ARG_EXPAND);
typedef void (*glGetMultiTexGenfvEXT_PTR)(glGetMultiTexGenfvEXT_ARG_EXPAND);
#define glGetMultiTexGenivEXT_INDEX 844
#define glGetMultiTexGenivEXT_RETURN void
#define glGetMultiTexGenivEXT_ARG_NAMES texunit, coord, pname, params
#define glGetMultiTexGenivEXT_ARG_EXPAND GLenum texunit, GLenum coord, GLenum pname, GLint * params
#define glGetMultiTexGenivEXT_PACKED PACKED_glGetMultiTexGenivEXT
#define glGetMultiTexGenivEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetMultiTexGenivEXT_NOT_VOID_WRAP(...) {}
#define pack_glGetMultiTexGenivEXT(_texunit, _coord, _pname, _params) ({ \
    glGetMultiTexGenivEXT_PACKED *packed_data = malloc(sizeof(glGetMultiTexGenivEXT_PACKED)); \
    packed_data->index = glGetMultiTexGenivEXT_INDEX; \
    packed_data->args.texunit = (GLenum)_texunit; \
    packed_data->args.coord = (GLenum)_coord; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetMultiTexGenivEXT(packed, ret_v) do { \
    PACKED_glGetMultiTexGenivEXT *unpacked = (PACKED_glGetMultiTexGenivEXT *)packed; \
    ARGS_glGetMultiTexGenivEXT *args = (ARGS_glGetMultiTexGenivEXT *)&unpacked->args; \
    glGetMultiTexGenivEXT(args->texunit, args->coord, args->pname, args->params);; \
} while(0)
void glGetMultiTexGenivEXT(glGetMultiTexGenivEXT_ARG_EXPAND);
typedef void (*glGetMultiTexGenivEXT_PTR)(glGetMultiTexGenivEXT_ARG_EXPAND);
#define glGetMultiTexImageEXT_INDEX 845
#define glGetMultiTexImageEXT_RETURN void
#define glGetMultiTexImageEXT_ARG_NAMES texunit, target, level, format, type, pixels
#define glGetMultiTexImageEXT_ARG_EXPAND GLenum texunit, GLenum target, GLint level, GLenum format, GLenum type, GLvoid * pixels
#define glGetMultiTexImageEXT_PACKED PACKED_glGetMultiTexImageEXT
#define glGetMultiTexImageEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetMultiTexImageEXT_NOT_VOID_WRAP(...) {}
#define pack_glGetMultiTexImageEXT(_texunit, _target, _level, _format, _type, _pixels) ({ \
    glGetMultiTexImageEXT_PACKED *packed_data = malloc(sizeof(glGetMultiTexImageEXT_PACKED)); \
    packed_data->index = glGetMultiTexImageEXT_INDEX; \
    packed_data->args.texunit = (GLenum)_texunit; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.level = (GLint)_level; \
    packed_data->args.format = (GLenum)_format; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.pixels = (GLvoid *)_pixels; \
    (packed_call_t *)packed_data; \
})
#define call_glGetMultiTexImageEXT(packed, ret_v) do { \
    PACKED_glGetMultiTexImageEXT *unpacked = (PACKED_glGetMultiTexImageEXT *)packed; \
    ARGS_glGetMultiTexImageEXT *args = (ARGS_glGetMultiTexImageEXT *)&unpacked->args; \
    glGetMultiTexImageEXT(args->texunit, args->target, args->level, args->format, args->type, args->pixels);; \
} while(0)
void glGetMultiTexImageEXT(glGetMultiTexImageEXT_ARG_EXPAND);
typedef void (*glGetMultiTexImageEXT_PTR)(glGetMultiTexImageEXT_ARG_EXPAND);
#define glGetMultiTexLevelParameterfvEXT_INDEX 846
#define glGetMultiTexLevelParameterfvEXT_RETURN void
#define glGetMultiTexLevelParameterfvEXT_ARG_NAMES texunit, target, level, pname, params
#define glGetMultiTexLevelParameterfvEXT_ARG_EXPAND GLenum texunit, GLenum target, GLint level, GLenum pname, GLfloat * params
#define glGetMultiTexLevelParameterfvEXT_PACKED PACKED_glGetMultiTexLevelParameterfvEXT
#define glGetMultiTexLevelParameterfvEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetMultiTexLevelParameterfvEXT_NOT_VOID_WRAP(...) {}
#define pack_glGetMultiTexLevelParameterfvEXT(_texunit, _target, _level, _pname, _params) ({ \
    glGetMultiTexLevelParameterfvEXT_PACKED *packed_data = malloc(sizeof(glGetMultiTexLevelParameterfvEXT_PACKED)); \
    packed_data->index = glGetMultiTexLevelParameterfvEXT_INDEX; \
    packed_data->args.texunit = (GLenum)_texunit; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.level = (GLint)_level; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLfloat *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetMultiTexLevelParameterfvEXT(packed, ret_v) do { \
    PACKED_glGetMultiTexLevelParameterfvEXT *unpacked = (PACKED_glGetMultiTexLevelParameterfvEXT *)packed; \
    ARGS_glGetMultiTexLevelParameterfvEXT *args = (ARGS_glGetMultiTexLevelParameterfvEXT *)&unpacked->args; \
    glGetMultiTexLevelParameterfvEXT(args->texunit, args->target, args->level, args->pname, args->params);; \
} while(0)
void glGetMultiTexLevelParameterfvEXT(glGetMultiTexLevelParameterfvEXT_ARG_EXPAND);
typedef void (*glGetMultiTexLevelParameterfvEXT_PTR)(glGetMultiTexLevelParameterfvEXT_ARG_EXPAND);
#define glGetMultiTexLevelParameterivEXT_INDEX 847
#define glGetMultiTexLevelParameterivEXT_RETURN void
#define glGetMultiTexLevelParameterivEXT_ARG_NAMES texunit, target, level, pname, params
#define glGetMultiTexLevelParameterivEXT_ARG_EXPAND GLenum texunit, GLenum target, GLint level, GLenum pname, GLint * params
#define glGetMultiTexLevelParameterivEXT_PACKED PACKED_glGetMultiTexLevelParameterivEXT
#define glGetMultiTexLevelParameterivEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetMultiTexLevelParameterivEXT_NOT_VOID_WRAP(...) {}
#define pack_glGetMultiTexLevelParameterivEXT(_texunit, _target, _level, _pname, _params) ({ \
    glGetMultiTexLevelParameterivEXT_PACKED *packed_data = malloc(sizeof(glGetMultiTexLevelParameterivEXT_PACKED)); \
    packed_data->index = glGetMultiTexLevelParameterivEXT_INDEX; \
    packed_data->args.texunit = (GLenum)_texunit; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.level = (GLint)_level; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetMultiTexLevelParameterivEXT(packed, ret_v) do { \
    PACKED_glGetMultiTexLevelParameterivEXT *unpacked = (PACKED_glGetMultiTexLevelParameterivEXT *)packed; \
    ARGS_glGetMultiTexLevelParameterivEXT *args = (ARGS_glGetMultiTexLevelParameterivEXT *)&unpacked->args; \
    glGetMultiTexLevelParameterivEXT(args->texunit, args->target, args->level, args->pname, args->params);; \
} while(0)
void glGetMultiTexLevelParameterivEXT(glGetMultiTexLevelParameterivEXT_ARG_EXPAND);
typedef void (*glGetMultiTexLevelParameterivEXT_PTR)(glGetMultiTexLevelParameterivEXT_ARG_EXPAND);
#define glGetMultiTexParameterIivEXT_INDEX 848
#define glGetMultiTexParameterIivEXT_RETURN void
#define glGetMultiTexParameterIivEXT_ARG_NAMES texunit, target, pname, params
#define glGetMultiTexParameterIivEXT_ARG_EXPAND GLenum texunit, GLenum target, GLenum pname, GLint * params
#define glGetMultiTexParameterIivEXT_PACKED PACKED_glGetMultiTexParameterIivEXT
#define glGetMultiTexParameterIivEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetMultiTexParameterIivEXT_NOT_VOID_WRAP(...) {}
#define pack_glGetMultiTexParameterIivEXT(_texunit, _target, _pname, _params) ({ \
    glGetMultiTexParameterIivEXT_PACKED *packed_data = malloc(sizeof(glGetMultiTexParameterIivEXT_PACKED)); \
    packed_data->index = glGetMultiTexParameterIivEXT_INDEX; \
    packed_data->args.texunit = (GLenum)_texunit; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetMultiTexParameterIivEXT(packed, ret_v) do { \
    PACKED_glGetMultiTexParameterIivEXT *unpacked = (PACKED_glGetMultiTexParameterIivEXT *)packed; \
    ARGS_glGetMultiTexParameterIivEXT *args = (ARGS_glGetMultiTexParameterIivEXT *)&unpacked->args; \
    glGetMultiTexParameterIivEXT(args->texunit, args->target, args->pname, args->params);; \
} while(0)
void glGetMultiTexParameterIivEXT(glGetMultiTexParameterIivEXT_ARG_EXPAND);
typedef void (*glGetMultiTexParameterIivEXT_PTR)(glGetMultiTexParameterIivEXT_ARG_EXPAND);
#define glGetMultiTexParameterIuivEXT_INDEX 849
#define glGetMultiTexParameterIuivEXT_RETURN void
#define glGetMultiTexParameterIuivEXT_ARG_NAMES texunit, target, pname, params
#define glGetMultiTexParameterIuivEXT_ARG_EXPAND GLenum texunit, GLenum target, GLenum pname, GLuint * params
#define glGetMultiTexParameterIuivEXT_PACKED PACKED_glGetMultiTexParameterIuivEXT
#define glGetMultiTexParameterIuivEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetMultiTexParameterIuivEXT_NOT_VOID_WRAP(...) {}
#define pack_glGetMultiTexParameterIuivEXT(_texunit, _target, _pname, _params) ({ \
    glGetMultiTexParameterIuivEXT_PACKED *packed_data = malloc(sizeof(glGetMultiTexParameterIuivEXT_PACKED)); \
    packed_data->index = glGetMultiTexParameterIuivEXT_INDEX; \
    packed_data->args.texunit = (GLenum)_texunit; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLuint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetMultiTexParameterIuivEXT(packed, ret_v) do { \
    PACKED_glGetMultiTexParameterIuivEXT *unpacked = (PACKED_glGetMultiTexParameterIuivEXT *)packed; \
    ARGS_glGetMultiTexParameterIuivEXT *args = (ARGS_glGetMultiTexParameterIuivEXT *)&unpacked->args; \
    glGetMultiTexParameterIuivEXT(args->texunit, args->target, args->pname, args->params);; \
} while(0)
void glGetMultiTexParameterIuivEXT(glGetMultiTexParameterIuivEXT_ARG_EXPAND);
typedef void (*glGetMultiTexParameterIuivEXT_PTR)(glGetMultiTexParameterIuivEXT_ARG_EXPAND);
#define glGetMultiTexParameterfvEXT_INDEX 850
#define glGetMultiTexParameterfvEXT_RETURN void
#define glGetMultiTexParameterfvEXT_ARG_NAMES texunit, target, pname, params
#define glGetMultiTexParameterfvEXT_ARG_EXPAND GLenum texunit, GLenum target, GLenum pname, GLfloat * params
#define glGetMultiTexParameterfvEXT_PACKED PACKED_glGetMultiTexParameterfvEXT
#define glGetMultiTexParameterfvEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetMultiTexParameterfvEXT_NOT_VOID_WRAP(...) {}
#define pack_glGetMultiTexParameterfvEXT(_texunit, _target, _pname, _params) ({ \
    glGetMultiTexParameterfvEXT_PACKED *packed_data = malloc(sizeof(glGetMultiTexParameterfvEXT_PACKED)); \
    packed_data->index = glGetMultiTexParameterfvEXT_INDEX; \
    packed_data->args.texunit = (GLenum)_texunit; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLfloat *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetMultiTexParameterfvEXT(packed, ret_v) do { \
    PACKED_glGetMultiTexParameterfvEXT *unpacked = (PACKED_glGetMultiTexParameterfvEXT *)packed; \
    ARGS_glGetMultiTexParameterfvEXT *args = (ARGS_glGetMultiTexParameterfvEXT *)&unpacked->args; \
    glGetMultiTexParameterfvEXT(args->texunit, args->target, args->pname, args->params);; \
} while(0)
void glGetMultiTexParameterfvEXT(glGetMultiTexParameterfvEXT_ARG_EXPAND);
typedef void (*glGetMultiTexParameterfvEXT_PTR)(glGetMultiTexParameterfvEXT_ARG_EXPAND);
#define glGetMultiTexParameterivEXT_INDEX 851
#define glGetMultiTexParameterivEXT_RETURN void
#define glGetMultiTexParameterivEXT_ARG_NAMES texunit, target, pname, params
#define glGetMultiTexParameterivEXT_ARG_EXPAND GLenum texunit, GLenum target, GLenum pname, GLint * params
#define glGetMultiTexParameterivEXT_PACKED PACKED_glGetMultiTexParameterivEXT
#define glGetMultiTexParameterivEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetMultiTexParameterivEXT_NOT_VOID_WRAP(...) {}
#define pack_glGetMultiTexParameterivEXT(_texunit, _target, _pname, _params) ({ \
    glGetMultiTexParameterivEXT_PACKED *packed_data = malloc(sizeof(glGetMultiTexParameterivEXT_PACKED)); \
    packed_data->index = glGetMultiTexParameterivEXT_INDEX; \
    packed_data->args.texunit = (GLenum)_texunit; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetMultiTexParameterivEXT(packed, ret_v) do { \
    PACKED_glGetMultiTexParameterivEXT *unpacked = (PACKED_glGetMultiTexParameterivEXT *)packed; \
    ARGS_glGetMultiTexParameterivEXT *args = (ARGS_glGetMultiTexParameterivEXT *)&unpacked->args; \
    glGetMultiTexParameterivEXT(args->texunit, args->target, args->pname, args->params);; \
} while(0)
void glGetMultiTexParameterivEXT(glGetMultiTexParameterivEXT_ARG_EXPAND);
typedef void (*glGetMultiTexParameterivEXT_PTR)(glGetMultiTexParameterivEXT_ARG_EXPAND);
#define glGetMultisamplefv_INDEX 852
#define glGetMultisamplefv_RETURN void
#define glGetMultisamplefv_ARG_NAMES pname, index, val
#define glGetMultisamplefv_ARG_EXPAND GLenum pname, GLuint index, GLfloat * val
#define glGetMultisamplefv_PACKED PACKED_glGetMultisamplefv
#define glGetMultisamplefv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetMultisamplefv_NOT_VOID_WRAP(...) {}
#define pack_glGetMultisamplefv(_pname, _index, _val) ({ \
    glGetMultisamplefv_PACKED *packed_data = malloc(sizeof(glGetMultisamplefv_PACKED)); \
    packed_data->index = glGetMultisamplefv_INDEX; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.val = (GLfloat *)_val; \
    (packed_call_t *)packed_data; \
})
#define call_glGetMultisamplefv(packed, ret_v) do { \
    PACKED_glGetMultisamplefv *unpacked = (PACKED_glGetMultisamplefv *)packed; \
    ARGS_glGetMultisamplefv *args = (ARGS_glGetMultisamplefv *)&unpacked->args; \
    glGetMultisamplefv(args->pname, args->index, args->val);; \
} while(0)
void glGetMultisamplefv(glGetMultisamplefv_ARG_EXPAND);
typedef void (*glGetMultisamplefv_PTR)(glGetMultisamplefv_ARG_EXPAND);
#define glGetMultisamplefvNV_INDEX 853
#define glGetMultisamplefvNV_RETURN void
#define glGetMultisamplefvNV_ARG_NAMES pname, index, val
#define glGetMultisamplefvNV_ARG_EXPAND GLenum pname, GLuint index, GLfloat * val
#define glGetMultisamplefvNV_PACKED PACKED_glGetMultisamplefvNV
#define glGetMultisamplefvNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetMultisamplefvNV_NOT_VOID_WRAP(...) {}
#define pack_glGetMultisamplefvNV(_pname, _index, _val) ({ \
    glGetMultisamplefvNV_PACKED *packed_data = malloc(sizeof(glGetMultisamplefvNV_PACKED)); \
    packed_data->index = glGetMultisamplefvNV_INDEX; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.val = (GLfloat *)_val; \
    (packed_call_t *)packed_data; \
})
#define call_glGetMultisamplefvNV(packed, ret_v) do { \
    PACKED_glGetMultisamplefvNV *unpacked = (PACKED_glGetMultisamplefvNV *)packed; \
    ARGS_glGetMultisamplefvNV *args = (ARGS_glGetMultisamplefvNV *)&unpacked->args; \
    glGetMultisamplefvNV(args->pname, args->index, args->val);; \
} while(0)
void glGetMultisamplefvNV(glGetMultisamplefvNV_ARG_EXPAND);
typedef void (*glGetMultisamplefvNV_PTR)(glGetMultisamplefvNV_ARG_EXPAND);
#define glGetNamedBufferParameterivEXT_INDEX 854
#define glGetNamedBufferParameterivEXT_RETURN void
#define glGetNamedBufferParameterivEXT_ARG_NAMES buffer, pname, params
#define glGetNamedBufferParameterivEXT_ARG_EXPAND GLuint buffer, GLenum pname, GLint * params
#define glGetNamedBufferParameterivEXT_PACKED PACKED_glGetNamedBufferParameterivEXT
#define glGetNamedBufferParameterivEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetNamedBufferParameterivEXT_NOT_VOID_WRAP(...) {}
#define pack_glGetNamedBufferParameterivEXT(_buffer, _pname, _params) ({ \
    glGetNamedBufferParameterivEXT_PACKED *packed_data = malloc(sizeof(glGetNamedBufferParameterivEXT_PACKED)); \
    packed_data->index = glGetNamedBufferParameterivEXT_INDEX; \
    packed_data->args.buffer = (GLuint)_buffer; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetNamedBufferParameterivEXT(packed, ret_v) do { \
    PACKED_glGetNamedBufferParameterivEXT *unpacked = (PACKED_glGetNamedBufferParameterivEXT *)packed; \
    ARGS_glGetNamedBufferParameterivEXT *args = (ARGS_glGetNamedBufferParameterivEXT *)&unpacked->args; \
    glGetNamedBufferParameterivEXT(args->buffer, args->pname, args->params);; \
} while(0)
void glGetNamedBufferParameterivEXT(glGetNamedBufferParameterivEXT_ARG_EXPAND);
typedef void (*glGetNamedBufferParameterivEXT_PTR)(glGetNamedBufferParameterivEXT_ARG_EXPAND);
#define glGetNamedBufferParameterui64vNV_INDEX 855
#define glGetNamedBufferParameterui64vNV_RETURN void
#define glGetNamedBufferParameterui64vNV_ARG_NAMES buffer, pname, params
#define glGetNamedBufferParameterui64vNV_ARG_EXPAND GLuint buffer, GLenum pname, GLuint64EXT * params
#define glGetNamedBufferParameterui64vNV_PACKED PACKED_glGetNamedBufferParameterui64vNV
#define glGetNamedBufferParameterui64vNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetNamedBufferParameterui64vNV_NOT_VOID_WRAP(...) {}
#define pack_glGetNamedBufferParameterui64vNV(_buffer, _pname, _params) ({ \
    glGetNamedBufferParameterui64vNV_PACKED *packed_data = malloc(sizeof(glGetNamedBufferParameterui64vNV_PACKED)); \
    packed_data->index = glGetNamedBufferParameterui64vNV_INDEX; \
    packed_data->args.buffer = (GLuint)_buffer; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLuint64EXT *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetNamedBufferParameterui64vNV(packed, ret_v) do { \
    PACKED_glGetNamedBufferParameterui64vNV *unpacked = (PACKED_glGetNamedBufferParameterui64vNV *)packed; \
    ARGS_glGetNamedBufferParameterui64vNV *args = (ARGS_glGetNamedBufferParameterui64vNV *)&unpacked->args; \
    glGetNamedBufferParameterui64vNV(args->buffer, args->pname, args->params);; \
} while(0)
void glGetNamedBufferParameterui64vNV(glGetNamedBufferParameterui64vNV_ARG_EXPAND);
typedef void (*glGetNamedBufferParameterui64vNV_PTR)(glGetNamedBufferParameterui64vNV_ARG_EXPAND);
#define glGetNamedBufferPointervEXT_INDEX 856
#define glGetNamedBufferPointervEXT_RETURN void
#define glGetNamedBufferPointervEXT_ARG_NAMES buffer, pname, params
#define glGetNamedBufferPointervEXT_ARG_EXPAND GLuint buffer, GLenum pname, GLvoid * params
#define glGetNamedBufferPointervEXT_PACKED PACKED_glGetNamedBufferPointervEXT
#define glGetNamedBufferPointervEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetNamedBufferPointervEXT_NOT_VOID_WRAP(...) {}
#define pack_glGetNamedBufferPointervEXT(_buffer, _pname, _params) ({ \
    glGetNamedBufferPointervEXT_PACKED *packed_data = malloc(sizeof(glGetNamedBufferPointervEXT_PACKED)); \
    packed_data->index = glGetNamedBufferPointervEXT_INDEX; \
    packed_data->args.buffer = (GLuint)_buffer; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLvoid *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetNamedBufferPointervEXT(packed, ret_v) do { \
    PACKED_glGetNamedBufferPointervEXT *unpacked = (PACKED_glGetNamedBufferPointervEXT *)packed; \
    ARGS_glGetNamedBufferPointervEXT *args = (ARGS_glGetNamedBufferPointervEXT *)&unpacked->args; \
    glGetNamedBufferPointervEXT(args->buffer, args->pname, args->params);; \
} while(0)
void glGetNamedBufferPointervEXT(glGetNamedBufferPointervEXT_ARG_EXPAND);
typedef void (*glGetNamedBufferPointervEXT_PTR)(glGetNamedBufferPointervEXT_ARG_EXPAND);
#define glGetNamedBufferSubDataEXT_INDEX 857
#define glGetNamedBufferSubDataEXT_RETURN void
#define glGetNamedBufferSubDataEXT_ARG_NAMES buffer, offset, size, data
#define glGetNamedBufferSubDataEXT_ARG_EXPAND GLuint buffer, GLintptr offset, GLsizeiptr size, GLvoid * data
#define glGetNamedBufferSubDataEXT_PACKED PACKED_glGetNamedBufferSubDataEXT
#define glGetNamedBufferSubDataEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetNamedBufferSubDataEXT_NOT_VOID_WRAP(...) {}
#define pack_glGetNamedBufferSubDataEXT(_buffer, _offset, _size, _data) ({ \
    glGetNamedBufferSubDataEXT_PACKED *packed_data = malloc(sizeof(glGetNamedBufferSubDataEXT_PACKED)); \
    packed_data->index = glGetNamedBufferSubDataEXT_INDEX; \
    packed_data->args.buffer = (GLuint)_buffer; \
    packed_data->args.offset = (GLintptr)_offset; \
    packed_data->args.size = (GLsizeiptr)_size; \
    packed_data->args.data = (GLvoid *)_data; \
    (packed_call_t *)packed_data; \
})
#define call_glGetNamedBufferSubDataEXT(packed, ret_v) do { \
    PACKED_glGetNamedBufferSubDataEXT *unpacked = (PACKED_glGetNamedBufferSubDataEXT *)packed; \
    ARGS_glGetNamedBufferSubDataEXT *args = (ARGS_glGetNamedBufferSubDataEXT *)&unpacked->args; \
    glGetNamedBufferSubDataEXT(args->buffer, args->offset, args->size, args->data);; \
} while(0)
void glGetNamedBufferSubDataEXT(glGetNamedBufferSubDataEXT_ARG_EXPAND);
typedef void (*glGetNamedBufferSubDataEXT_PTR)(glGetNamedBufferSubDataEXT_ARG_EXPAND);
#define glGetNamedFramebufferAttachmentParameterivEXT_INDEX 858
#define glGetNamedFramebufferAttachmentParameterivEXT_RETURN void
#define glGetNamedFramebufferAttachmentParameterivEXT_ARG_NAMES framebuffer, attachment, pname, params
#define glGetNamedFramebufferAttachmentParameterivEXT_ARG_EXPAND GLuint framebuffer, GLenum attachment, GLenum pname, GLint * params
#define glGetNamedFramebufferAttachmentParameterivEXT_PACKED PACKED_glGetNamedFramebufferAttachmentParameterivEXT
#define glGetNamedFramebufferAttachmentParameterivEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetNamedFramebufferAttachmentParameterivEXT_NOT_VOID_WRAP(...) {}
#define pack_glGetNamedFramebufferAttachmentParameterivEXT(_framebuffer, _attachment, _pname, _params) ({ \
    glGetNamedFramebufferAttachmentParameterivEXT_PACKED *packed_data = malloc(sizeof(glGetNamedFramebufferAttachmentParameterivEXT_PACKED)); \
    packed_data->index = glGetNamedFramebufferAttachmentParameterivEXT_INDEX; \
    packed_data->args.framebuffer = (GLuint)_framebuffer; \
    packed_data->args.attachment = (GLenum)_attachment; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetNamedFramebufferAttachmentParameterivEXT(packed, ret_v) do { \
    PACKED_glGetNamedFramebufferAttachmentParameterivEXT *unpacked = (PACKED_glGetNamedFramebufferAttachmentParameterivEXT *)packed; \
    ARGS_glGetNamedFramebufferAttachmentParameterivEXT *args = (ARGS_glGetNamedFramebufferAttachmentParameterivEXT *)&unpacked->args; \
    glGetNamedFramebufferAttachmentParameterivEXT(args->framebuffer, args->attachment, args->pname, args->params);; \
} while(0)
void glGetNamedFramebufferAttachmentParameterivEXT(glGetNamedFramebufferAttachmentParameterivEXT_ARG_EXPAND);
typedef void (*glGetNamedFramebufferAttachmentParameterivEXT_PTR)(glGetNamedFramebufferAttachmentParameterivEXT_ARG_EXPAND);
#define glGetNamedFramebufferParameterivEXT_INDEX 859
#define glGetNamedFramebufferParameterivEXT_RETURN void
#define glGetNamedFramebufferParameterivEXT_ARG_NAMES framebuffer, pname, params
#define glGetNamedFramebufferParameterivEXT_ARG_EXPAND GLuint framebuffer, GLenum pname, GLint * params
#define glGetNamedFramebufferParameterivEXT_PACKED PACKED_glGetNamedFramebufferParameterivEXT
#define glGetNamedFramebufferParameterivEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetNamedFramebufferParameterivEXT_NOT_VOID_WRAP(...) {}
#define pack_glGetNamedFramebufferParameterivEXT(_framebuffer, _pname, _params) ({ \
    glGetNamedFramebufferParameterivEXT_PACKED *packed_data = malloc(sizeof(glGetNamedFramebufferParameterivEXT_PACKED)); \
    packed_data->index = glGetNamedFramebufferParameterivEXT_INDEX; \
    packed_data->args.framebuffer = (GLuint)_framebuffer; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetNamedFramebufferParameterivEXT(packed, ret_v) do { \
    PACKED_glGetNamedFramebufferParameterivEXT *unpacked = (PACKED_glGetNamedFramebufferParameterivEXT *)packed; \
    ARGS_glGetNamedFramebufferParameterivEXT *args = (ARGS_glGetNamedFramebufferParameterivEXT *)&unpacked->args; \
    glGetNamedFramebufferParameterivEXT(args->framebuffer, args->pname, args->params);; \
} while(0)
void glGetNamedFramebufferParameterivEXT(glGetNamedFramebufferParameterivEXT_ARG_EXPAND);
typedef void (*glGetNamedFramebufferParameterivEXT_PTR)(glGetNamedFramebufferParameterivEXT_ARG_EXPAND);
#define glGetNamedProgramLocalParameterIivEXT_INDEX 860
#define glGetNamedProgramLocalParameterIivEXT_RETURN void
#define glGetNamedProgramLocalParameterIivEXT_ARG_NAMES program, target, index, params
#define glGetNamedProgramLocalParameterIivEXT_ARG_EXPAND GLuint program, GLenum target, GLuint index, GLint * params
#define glGetNamedProgramLocalParameterIivEXT_PACKED PACKED_glGetNamedProgramLocalParameterIivEXT
#define glGetNamedProgramLocalParameterIivEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetNamedProgramLocalParameterIivEXT_NOT_VOID_WRAP(...) {}
#define pack_glGetNamedProgramLocalParameterIivEXT(_program, _target, _index, _params) ({ \
    glGetNamedProgramLocalParameterIivEXT_PACKED *packed_data = malloc(sizeof(glGetNamedProgramLocalParameterIivEXT_PACKED)); \
    packed_data->index = glGetNamedProgramLocalParameterIivEXT_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.params = (GLint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetNamedProgramLocalParameterIivEXT(packed, ret_v) do { \
    PACKED_glGetNamedProgramLocalParameterIivEXT *unpacked = (PACKED_glGetNamedProgramLocalParameterIivEXT *)packed; \
    ARGS_glGetNamedProgramLocalParameterIivEXT *args = (ARGS_glGetNamedProgramLocalParameterIivEXT *)&unpacked->args; \
    glGetNamedProgramLocalParameterIivEXT(args->program, args->target, args->index, args->params);; \
} while(0)
void glGetNamedProgramLocalParameterIivEXT(glGetNamedProgramLocalParameterIivEXT_ARG_EXPAND);
typedef void (*glGetNamedProgramLocalParameterIivEXT_PTR)(glGetNamedProgramLocalParameterIivEXT_ARG_EXPAND);
#define glGetNamedProgramLocalParameterIuivEXT_INDEX 861
#define glGetNamedProgramLocalParameterIuivEXT_RETURN void
#define glGetNamedProgramLocalParameterIuivEXT_ARG_NAMES program, target, index, params
#define glGetNamedProgramLocalParameterIuivEXT_ARG_EXPAND GLuint program, GLenum target, GLuint index, GLuint * params
#define glGetNamedProgramLocalParameterIuivEXT_PACKED PACKED_glGetNamedProgramLocalParameterIuivEXT
#define glGetNamedProgramLocalParameterIuivEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetNamedProgramLocalParameterIuivEXT_NOT_VOID_WRAP(...) {}
#define pack_glGetNamedProgramLocalParameterIuivEXT(_program, _target, _index, _params) ({ \
    glGetNamedProgramLocalParameterIuivEXT_PACKED *packed_data = malloc(sizeof(glGetNamedProgramLocalParameterIuivEXT_PACKED)); \
    packed_data->index = glGetNamedProgramLocalParameterIuivEXT_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.params = (GLuint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetNamedProgramLocalParameterIuivEXT(packed, ret_v) do { \
    PACKED_glGetNamedProgramLocalParameterIuivEXT *unpacked = (PACKED_glGetNamedProgramLocalParameterIuivEXT *)packed; \
    ARGS_glGetNamedProgramLocalParameterIuivEXT *args = (ARGS_glGetNamedProgramLocalParameterIuivEXT *)&unpacked->args; \
    glGetNamedProgramLocalParameterIuivEXT(args->program, args->target, args->index, args->params);; \
} while(0)
void glGetNamedProgramLocalParameterIuivEXT(glGetNamedProgramLocalParameterIuivEXT_ARG_EXPAND);
typedef void (*glGetNamedProgramLocalParameterIuivEXT_PTR)(glGetNamedProgramLocalParameterIuivEXT_ARG_EXPAND);
#define glGetNamedProgramLocalParameterdvEXT_INDEX 862
#define glGetNamedProgramLocalParameterdvEXT_RETURN void
#define glGetNamedProgramLocalParameterdvEXT_ARG_NAMES program, target, index, params
#define glGetNamedProgramLocalParameterdvEXT_ARG_EXPAND GLuint program, GLenum target, GLuint index, GLdouble * params
#define glGetNamedProgramLocalParameterdvEXT_PACKED PACKED_glGetNamedProgramLocalParameterdvEXT
#define glGetNamedProgramLocalParameterdvEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetNamedProgramLocalParameterdvEXT_NOT_VOID_WRAP(...) {}
#define pack_glGetNamedProgramLocalParameterdvEXT(_program, _target, _index, _params) ({ \
    glGetNamedProgramLocalParameterdvEXT_PACKED *packed_data = malloc(sizeof(glGetNamedProgramLocalParameterdvEXT_PACKED)); \
    packed_data->index = glGetNamedProgramLocalParameterdvEXT_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.params = (GLdouble *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetNamedProgramLocalParameterdvEXT(packed, ret_v) do { \
    PACKED_glGetNamedProgramLocalParameterdvEXT *unpacked = (PACKED_glGetNamedProgramLocalParameterdvEXT *)packed; \
    ARGS_glGetNamedProgramLocalParameterdvEXT *args = (ARGS_glGetNamedProgramLocalParameterdvEXT *)&unpacked->args; \
    glGetNamedProgramLocalParameterdvEXT(args->program, args->target, args->index, args->params);; \
} while(0)
void glGetNamedProgramLocalParameterdvEXT(glGetNamedProgramLocalParameterdvEXT_ARG_EXPAND);
typedef void (*glGetNamedProgramLocalParameterdvEXT_PTR)(glGetNamedProgramLocalParameterdvEXT_ARG_EXPAND);
#define glGetNamedProgramLocalParameterfvEXT_INDEX 863
#define glGetNamedProgramLocalParameterfvEXT_RETURN void
#define glGetNamedProgramLocalParameterfvEXT_ARG_NAMES program, target, index, params
#define glGetNamedProgramLocalParameterfvEXT_ARG_EXPAND GLuint program, GLenum target, GLuint index, GLfloat * params
#define glGetNamedProgramLocalParameterfvEXT_PACKED PACKED_glGetNamedProgramLocalParameterfvEXT
#define glGetNamedProgramLocalParameterfvEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetNamedProgramLocalParameterfvEXT_NOT_VOID_WRAP(...) {}
#define pack_glGetNamedProgramLocalParameterfvEXT(_program, _target, _index, _params) ({ \
    glGetNamedProgramLocalParameterfvEXT_PACKED *packed_data = malloc(sizeof(glGetNamedProgramLocalParameterfvEXT_PACKED)); \
    packed_data->index = glGetNamedProgramLocalParameterfvEXT_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.params = (GLfloat *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetNamedProgramLocalParameterfvEXT(packed, ret_v) do { \
    PACKED_glGetNamedProgramLocalParameterfvEXT *unpacked = (PACKED_glGetNamedProgramLocalParameterfvEXT *)packed; \
    ARGS_glGetNamedProgramLocalParameterfvEXT *args = (ARGS_glGetNamedProgramLocalParameterfvEXT *)&unpacked->args; \
    glGetNamedProgramLocalParameterfvEXT(args->program, args->target, args->index, args->params);; \
} while(0)
void glGetNamedProgramLocalParameterfvEXT(glGetNamedProgramLocalParameterfvEXT_ARG_EXPAND);
typedef void (*glGetNamedProgramLocalParameterfvEXT_PTR)(glGetNamedProgramLocalParameterfvEXT_ARG_EXPAND);
#define glGetNamedProgramStringEXT_INDEX 864
#define glGetNamedProgramStringEXT_RETURN void
#define glGetNamedProgramStringEXT_ARG_NAMES program, target, pname, string
#define glGetNamedProgramStringEXT_ARG_EXPAND GLuint program, GLenum target, GLenum pname, GLvoid * string
#define glGetNamedProgramStringEXT_PACKED PACKED_glGetNamedProgramStringEXT
#define glGetNamedProgramStringEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetNamedProgramStringEXT_NOT_VOID_WRAP(...) {}
#define pack_glGetNamedProgramStringEXT(_program, _target, _pname, _string) ({ \
    glGetNamedProgramStringEXT_PACKED *packed_data = malloc(sizeof(glGetNamedProgramStringEXT_PACKED)); \
    packed_data->index = glGetNamedProgramStringEXT_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.string = (GLvoid *)_string; \
    (packed_call_t *)packed_data; \
})
#define call_glGetNamedProgramStringEXT(packed, ret_v) do { \
    PACKED_glGetNamedProgramStringEXT *unpacked = (PACKED_glGetNamedProgramStringEXT *)packed; \
    ARGS_glGetNamedProgramStringEXT *args = (ARGS_glGetNamedProgramStringEXT *)&unpacked->args; \
    glGetNamedProgramStringEXT(args->program, args->target, args->pname, args->string);; \
} while(0)
void glGetNamedProgramStringEXT(glGetNamedProgramStringEXT_ARG_EXPAND);
typedef void (*glGetNamedProgramStringEXT_PTR)(glGetNamedProgramStringEXT_ARG_EXPAND);
#define glGetNamedProgramivEXT_INDEX 865
#define glGetNamedProgramivEXT_RETURN void
#define glGetNamedProgramivEXT_ARG_NAMES program, target, pname, params
#define glGetNamedProgramivEXT_ARG_EXPAND GLuint program, GLenum target, GLenum pname, GLint * params
#define glGetNamedProgramivEXT_PACKED PACKED_glGetNamedProgramivEXT
#define glGetNamedProgramivEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetNamedProgramivEXT_NOT_VOID_WRAP(...) {}
#define pack_glGetNamedProgramivEXT(_program, _target, _pname, _params) ({ \
    glGetNamedProgramivEXT_PACKED *packed_data = malloc(sizeof(glGetNamedProgramivEXT_PACKED)); \
    packed_data->index = glGetNamedProgramivEXT_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetNamedProgramivEXT(packed, ret_v) do { \
    PACKED_glGetNamedProgramivEXT *unpacked = (PACKED_glGetNamedProgramivEXT *)packed; \
    ARGS_glGetNamedProgramivEXT *args = (ARGS_glGetNamedProgramivEXT *)&unpacked->args; \
    glGetNamedProgramivEXT(args->program, args->target, args->pname, args->params);; \
} while(0)
void glGetNamedProgramivEXT(glGetNamedProgramivEXT_ARG_EXPAND);
typedef void (*glGetNamedProgramivEXT_PTR)(glGetNamedProgramivEXT_ARG_EXPAND);
#define glGetNamedRenderbufferParameterivEXT_INDEX 866
#define glGetNamedRenderbufferParameterivEXT_RETURN void
#define glGetNamedRenderbufferParameterivEXT_ARG_NAMES renderbuffer, pname, params
#define glGetNamedRenderbufferParameterivEXT_ARG_EXPAND GLuint renderbuffer, GLenum pname, GLint * params
#define glGetNamedRenderbufferParameterivEXT_PACKED PACKED_glGetNamedRenderbufferParameterivEXT
#define glGetNamedRenderbufferParameterivEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetNamedRenderbufferParameterivEXT_NOT_VOID_WRAP(...) {}
#define pack_glGetNamedRenderbufferParameterivEXT(_renderbuffer, _pname, _params) ({ \
    glGetNamedRenderbufferParameterivEXT_PACKED *packed_data = malloc(sizeof(glGetNamedRenderbufferParameterivEXT_PACKED)); \
    packed_data->index = glGetNamedRenderbufferParameterivEXT_INDEX; \
    packed_data->args.renderbuffer = (GLuint)_renderbuffer; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetNamedRenderbufferParameterivEXT(packed, ret_v) do { \
    PACKED_glGetNamedRenderbufferParameterivEXT *unpacked = (PACKED_glGetNamedRenderbufferParameterivEXT *)packed; \
    ARGS_glGetNamedRenderbufferParameterivEXT *args = (ARGS_glGetNamedRenderbufferParameterivEXT *)&unpacked->args; \
    glGetNamedRenderbufferParameterivEXT(args->renderbuffer, args->pname, args->params);; \
} while(0)
void glGetNamedRenderbufferParameterivEXT(glGetNamedRenderbufferParameterivEXT_ARG_EXPAND);
typedef void (*glGetNamedRenderbufferParameterivEXT_PTR)(glGetNamedRenderbufferParameterivEXT_ARG_EXPAND);
#define glGetNamedStringARB_INDEX 867
#define glGetNamedStringARB_RETURN void
#define glGetNamedStringARB_ARG_NAMES namelen, name, bufSize, stringlen, string
#define glGetNamedStringARB_ARG_EXPAND GLint namelen, const GLchar * name, GLsizei bufSize, GLint * stringlen, GLchar * string
#define glGetNamedStringARB_PACKED PACKED_glGetNamedStringARB
#define glGetNamedStringARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetNamedStringARB_NOT_VOID_WRAP(...) {}
#define pack_glGetNamedStringARB(_namelen, _name, _bufSize, _stringlen, _string) ({ \
    glGetNamedStringARB_PACKED *packed_data = malloc(sizeof(glGetNamedStringARB_PACKED)); \
    packed_data->index = glGetNamedStringARB_INDEX; \
    packed_data->args.namelen = (GLint)_namelen; \
    packed_data->args.name = (GLchar *)_name; \
    packed_data->args.bufSize = (GLsizei)_bufSize; \
    packed_data->args.stringlen = (GLint *)_stringlen; \
    packed_data->args.string = (GLchar *)_string; \
    (packed_call_t *)packed_data; \
})
#define call_glGetNamedStringARB(packed, ret_v) do { \
    PACKED_glGetNamedStringARB *unpacked = (PACKED_glGetNamedStringARB *)packed; \
    ARGS_glGetNamedStringARB *args = (ARGS_glGetNamedStringARB *)&unpacked->args; \
    glGetNamedStringARB(args->namelen, args->name, args->bufSize, args->stringlen, args->string);; \
} while(0)
void glGetNamedStringARB(glGetNamedStringARB_ARG_EXPAND);
typedef void (*glGetNamedStringARB_PTR)(glGetNamedStringARB_ARG_EXPAND);
#define glGetNamedStringivARB_INDEX 868
#define glGetNamedStringivARB_RETURN void
#define glGetNamedStringivARB_ARG_NAMES namelen, name, pname, params
#define glGetNamedStringivARB_ARG_EXPAND GLint namelen, const GLchar * name, GLenum pname, GLint * params
#define glGetNamedStringivARB_PACKED PACKED_glGetNamedStringivARB
#define glGetNamedStringivARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetNamedStringivARB_NOT_VOID_WRAP(...) {}
#define pack_glGetNamedStringivARB(_namelen, _name, _pname, _params) ({ \
    glGetNamedStringivARB_PACKED *packed_data = malloc(sizeof(glGetNamedStringivARB_PACKED)); \
    packed_data->index = glGetNamedStringivARB_INDEX; \
    packed_data->args.namelen = (GLint)_namelen; \
    packed_data->args.name = (GLchar *)_name; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetNamedStringivARB(packed, ret_v) do { \
    PACKED_glGetNamedStringivARB *unpacked = (PACKED_glGetNamedStringivARB *)packed; \
    ARGS_glGetNamedStringivARB *args = (ARGS_glGetNamedStringivARB *)&unpacked->args; \
    glGetNamedStringivARB(args->namelen, args->name, args->pname, args->params);; \
} while(0)
void glGetNamedStringivARB(glGetNamedStringivARB_ARG_EXPAND);
typedef void (*glGetNamedStringivARB_PTR)(glGetNamedStringivARB_ARG_EXPAND);
#define glGetObjectBufferfvATI_INDEX 869
#define glGetObjectBufferfvATI_RETURN void
#define glGetObjectBufferfvATI_ARG_NAMES buffer, pname, params
#define glGetObjectBufferfvATI_ARG_EXPAND GLuint buffer, GLenum pname, GLfloat * params
#define glGetObjectBufferfvATI_PACKED PACKED_glGetObjectBufferfvATI
#define glGetObjectBufferfvATI_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetObjectBufferfvATI_NOT_VOID_WRAP(...) {}
#define pack_glGetObjectBufferfvATI(_buffer, _pname, _params) ({ \
    glGetObjectBufferfvATI_PACKED *packed_data = malloc(sizeof(glGetObjectBufferfvATI_PACKED)); \
    packed_data->index = glGetObjectBufferfvATI_INDEX; \
    packed_data->args.buffer = (GLuint)_buffer; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLfloat *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetObjectBufferfvATI(packed, ret_v) do { \
    PACKED_glGetObjectBufferfvATI *unpacked = (PACKED_glGetObjectBufferfvATI *)packed; \
    ARGS_glGetObjectBufferfvATI *args = (ARGS_glGetObjectBufferfvATI *)&unpacked->args; \
    glGetObjectBufferfvATI(args->buffer, args->pname, args->params);; \
} while(0)
void glGetObjectBufferfvATI(glGetObjectBufferfvATI_ARG_EXPAND);
typedef void (*glGetObjectBufferfvATI_PTR)(glGetObjectBufferfvATI_ARG_EXPAND);
#define glGetObjectBufferivATI_INDEX 870
#define glGetObjectBufferivATI_RETURN void
#define glGetObjectBufferivATI_ARG_NAMES buffer, pname, params
#define glGetObjectBufferivATI_ARG_EXPAND GLuint buffer, GLenum pname, GLint * params
#define glGetObjectBufferivATI_PACKED PACKED_glGetObjectBufferivATI
#define glGetObjectBufferivATI_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetObjectBufferivATI_NOT_VOID_WRAP(...) {}
#define pack_glGetObjectBufferivATI(_buffer, _pname, _params) ({ \
    glGetObjectBufferivATI_PACKED *packed_data = malloc(sizeof(glGetObjectBufferivATI_PACKED)); \
    packed_data->index = glGetObjectBufferivATI_INDEX; \
    packed_data->args.buffer = (GLuint)_buffer; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetObjectBufferivATI(packed, ret_v) do { \
    PACKED_glGetObjectBufferivATI *unpacked = (PACKED_glGetObjectBufferivATI *)packed; \
    ARGS_glGetObjectBufferivATI *args = (ARGS_glGetObjectBufferivATI *)&unpacked->args; \
    glGetObjectBufferivATI(args->buffer, args->pname, args->params);; \
} while(0)
void glGetObjectBufferivATI(glGetObjectBufferivATI_ARG_EXPAND);
typedef void (*glGetObjectBufferivATI_PTR)(glGetObjectBufferivATI_ARG_EXPAND);
#define glGetObjectLabel_INDEX 871
#define glGetObjectLabel_RETURN void
#define glGetObjectLabel_ARG_NAMES identifier, name, bufSize, length, label
#define glGetObjectLabel_ARG_EXPAND GLenum identifier, GLuint name, GLsizei bufSize, GLsizei * length, GLchar * label
#define glGetObjectLabel_PACKED PACKED_glGetObjectLabel
#define glGetObjectLabel_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetObjectLabel_NOT_VOID_WRAP(...) {}
#define pack_glGetObjectLabel(_identifier, _name, _bufSize, _length, _label) ({ \
    glGetObjectLabel_PACKED *packed_data = malloc(sizeof(glGetObjectLabel_PACKED)); \
    packed_data->index = glGetObjectLabel_INDEX; \
    packed_data->args.identifier = (GLenum)_identifier; \
    packed_data->args.name = (GLuint)_name; \
    packed_data->args.bufSize = (GLsizei)_bufSize; \
    packed_data->args.length = (GLsizei *)_length; \
    packed_data->args.label = (GLchar *)_label; \
    (packed_call_t *)packed_data; \
})
#define call_glGetObjectLabel(packed, ret_v) do { \
    PACKED_glGetObjectLabel *unpacked = (PACKED_glGetObjectLabel *)packed; \
    ARGS_glGetObjectLabel *args = (ARGS_glGetObjectLabel *)&unpacked->args; \
    glGetObjectLabel(args->identifier, args->name, args->bufSize, args->length, args->label);; \
} while(0)
void glGetObjectLabel(glGetObjectLabel_ARG_EXPAND);
typedef void (*glGetObjectLabel_PTR)(glGetObjectLabel_ARG_EXPAND);
#define glGetObjectParameterfvARB_INDEX 872
#define glGetObjectParameterfvARB_RETURN void
#define glGetObjectParameterfvARB_ARG_NAMES obj, pname, params
#define glGetObjectParameterfvARB_ARG_EXPAND GLhandleARB obj, GLenum pname, GLfloat * params
#define glGetObjectParameterfvARB_PACKED PACKED_glGetObjectParameterfvARB
#define glGetObjectParameterfvARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetObjectParameterfvARB_NOT_VOID_WRAP(...) {}
#define pack_glGetObjectParameterfvARB(_obj, _pname, _params) ({ \
    glGetObjectParameterfvARB_PACKED *packed_data = malloc(sizeof(glGetObjectParameterfvARB_PACKED)); \
    packed_data->index = glGetObjectParameterfvARB_INDEX; \
    packed_data->args.obj = (GLhandleARB)_obj; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLfloat *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetObjectParameterfvARB(packed, ret_v) do { \
    PACKED_glGetObjectParameterfvARB *unpacked = (PACKED_glGetObjectParameterfvARB *)packed; \
    ARGS_glGetObjectParameterfvARB *args = (ARGS_glGetObjectParameterfvARB *)&unpacked->args; \
    glGetObjectParameterfvARB(args->obj, args->pname, args->params);; \
} while(0)
void glGetObjectParameterfvARB(glGetObjectParameterfvARB_ARG_EXPAND);
typedef void (*glGetObjectParameterfvARB_PTR)(glGetObjectParameterfvARB_ARG_EXPAND);
#define glGetObjectParameterivAPPLE_INDEX 873
#define glGetObjectParameterivAPPLE_RETURN void
#define glGetObjectParameterivAPPLE_ARG_NAMES objectType, name, pname, params
#define glGetObjectParameterivAPPLE_ARG_EXPAND GLenum objectType, GLuint name, GLenum pname, GLint * params
#define glGetObjectParameterivAPPLE_PACKED PACKED_glGetObjectParameterivAPPLE
#define glGetObjectParameterivAPPLE_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetObjectParameterivAPPLE_NOT_VOID_WRAP(...) {}
#define pack_glGetObjectParameterivAPPLE(_objectType, _name, _pname, _params) ({ \
    glGetObjectParameterivAPPLE_PACKED *packed_data = malloc(sizeof(glGetObjectParameterivAPPLE_PACKED)); \
    packed_data->index = glGetObjectParameterivAPPLE_INDEX; \
    packed_data->args.objectType = (GLenum)_objectType; \
    packed_data->args.name = (GLuint)_name; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetObjectParameterivAPPLE(packed, ret_v) do { \
    PACKED_glGetObjectParameterivAPPLE *unpacked = (PACKED_glGetObjectParameterivAPPLE *)packed; \
    ARGS_glGetObjectParameterivAPPLE *args = (ARGS_glGetObjectParameterivAPPLE *)&unpacked->args; \
    glGetObjectParameterivAPPLE(args->objectType, args->name, args->pname, args->params);; \
} while(0)
void glGetObjectParameterivAPPLE(glGetObjectParameterivAPPLE_ARG_EXPAND);
typedef void (*glGetObjectParameterivAPPLE_PTR)(glGetObjectParameterivAPPLE_ARG_EXPAND);
#define glGetObjectParameterivARB_INDEX 874
#define glGetObjectParameterivARB_RETURN void
#define glGetObjectParameterivARB_ARG_NAMES obj, pname, params
#define glGetObjectParameterivARB_ARG_EXPAND GLhandleARB obj, GLenum pname, GLint * params
#define glGetObjectParameterivARB_PACKED PACKED_glGetObjectParameterivARB
#define glGetObjectParameterivARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetObjectParameterivARB_NOT_VOID_WRAP(...) {}
#define pack_glGetObjectParameterivARB(_obj, _pname, _params) ({ \
    glGetObjectParameterivARB_PACKED *packed_data = malloc(sizeof(glGetObjectParameterivARB_PACKED)); \
    packed_data->index = glGetObjectParameterivARB_INDEX; \
    packed_data->args.obj = (GLhandleARB)_obj; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetObjectParameterivARB(packed, ret_v) do { \
    PACKED_glGetObjectParameterivARB *unpacked = (PACKED_glGetObjectParameterivARB *)packed; \
    ARGS_glGetObjectParameterivARB *args = (ARGS_glGetObjectParameterivARB *)&unpacked->args; \
    glGetObjectParameterivARB(args->obj, args->pname, args->params);; \
} while(0)
void glGetObjectParameterivARB(glGetObjectParameterivARB_ARG_EXPAND);
typedef void (*glGetObjectParameterivARB_PTR)(glGetObjectParameterivARB_ARG_EXPAND);
#define glGetObjectPtrLabel_INDEX 875
#define glGetObjectPtrLabel_RETURN void
#define glGetObjectPtrLabel_ARG_NAMES ptr, bufSize, length, label
#define glGetObjectPtrLabel_ARG_EXPAND const void * ptr, GLsizei bufSize, GLsizei * length, GLchar * label
#define glGetObjectPtrLabel_PACKED PACKED_glGetObjectPtrLabel
#define glGetObjectPtrLabel_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetObjectPtrLabel_NOT_VOID_WRAP(...) {}
#define pack_glGetObjectPtrLabel(_ptr, _bufSize, _length, _label) ({ \
    glGetObjectPtrLabel_PACKED *packed_data = malloc(sizeof(glGetObjectPtrLabel_PACKED)); \
    packed_data->index = glGetObjectPtrLabel_INDEX; \
    packed_data->args.ptr = (void *)_ptr; \
    packed_data->args.bufSize = (GLsizei)_bufSize; \
    packed_data->args.length = (GLsizei *)_length; \
    packed_data->args.label = (GLchar *)_label; \
    (packed_call_t *)packed_data; \
})
#define call_glGetObjectPtrLabel(packed, ret_v) do { \
    PACKED_glGetObjectPtrLabel *unpacked = (PACKED_glGetObjectPtrLabel *)packed; \
    ARGS_glGetObjectPtrLabel *args = (ARGS_glGetObjectPtrLabel *)&unpacked->args; \
    glGetObjectPtrLabel(args->ptr, args->bufSize, args->length, args->label);; \
} while(0)
void glGetObjectPtrLabel(glGetObjectPtrLabel_ARG_EXPAND);
typedef void (*glGetObjectPtrLabel_PTR)(glGetObjectPtrLabel_ARG_EXPAND);
#define glGetOcclusionQueryivNV_INDEX 876
#define glGetOcclusionQueryivNV_RETURN void
#define glGetOcclusionQueryivNV_ARG_NAMES id, pname, params
#define glGetOcclusionQueryivNV_ARG_EXPAND GLuint id, GLenum pname, GLint * params
#define glGetOcclusionQueryivNV_PACKED PACKED_glGetOcclusionQueryivNV
#define glGetOcclusionQueryivNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetOcclusionQueryivNV_NOT_VOID_WRAP(...) {}
#define pack_glGetOcclusionQueryivNV(_id, _pname, _params) ({ \
    glGetOcclusionQueryivNV_PACKED *packed_data = malloc(sizeof(glGetOcclusionQueryivNV_PACKED)); \
    packed_data->index = glGetOcclusionQueryivNV_INDEX; \
    packed_data->args.id = (GLuint)_id; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetOcclusionQueryivNV(packed, ret_v) do { \
    PACKED_glGetOcclusionQueryivNV *unpacked = (PACKED_glGetOcclusionQueryivNV *)packed; \
    ARGS_glGetOcclusionQueryivNV *args = (ARGS_glGetOcclusionQueryivNV *)&unpacked->args; \
    glGetOcclusionQueryivNV(args->id, args->pname, args->params);; \
} while(0)
void glGetOcclusionQueryivNV(glGetOcclusionQueryivNV_ARG_EXPAND);
typedef void (*glGetOcclusionQueryivNV_PTR)(glGetOcclusionQueryivNV_ARG_EXPAND);
#define glGetOcclusionQueryuivNV_INDEX 877
#define glGetOcclusionQueryuivNV_RETURN void
#define glGetOcclusionQueryuivNV_ARG_NAMES id, pname, params
#define glGetOcclusionQueryuivNV_ARG_EXPAND GLuint id, GLenum pname, GLuint * params
#define glGetOcclusionQueryuivNV_PACKED PACKED_glGetOcclusionQueryuivNV
#define glGetOcclusionQueryuivNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetOcclusionQueryuivNV_NOT_VOID_WRAP(...) {}
#define pack_glGetOcclusionQueryuivNV(_id, _pname, _params) ({ \
    glGetOcclusionQueryuivNV_PACKED *packed_data = malloc(sizeof(glGetOcclusionQueryuivNV_PACKED)); \
    packed_data->index = glGetOcclusionQueryuivNV_INDEX; \
    packed_data->args.id = (GLuint)_id; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLuint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetOcclusionQueryuivNV(packed, ret_v) do { \
    PACKED_glGetOcclusionQueryuivNV *unpacked = (PACKED_glGetOcclusionQueryuivNV *)packed; \
    ARGS_glGetOcclusionQueryuivNV *args = (ARGS_glGetOcclusionQueryuivNV *)&unpacked->args; \
    glGetOcclusionQueryuivNV(args->id, args->pname, args->params);; \
} while(0)
void glGetOcclusionQueryuivNV(glGetOcclusionQueryuivNV_ARG_EXPAND);
typedef void (*glGetOcclusionQueryuivNV_PTR)(glGetOcclusionQueryuivNV_ARG_EXPAND);
#define glGetPathColorGenfvNV_INDEX 878
#define glGetPathColorGenfvNV_RETURN void
#define glGetPathColorGenfvNV_ARG_NAMES color, pname, value
#define glGetPathColorGenfvNV_ARG_EXPAND GLenum color, GLenum pname, GLfloat * value
#define glGetPathColorGenfvNV_PACKED PACKED_glGetPathColorGenfvNV
#define glGetPathColorGenfvNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetPathColorGenfvNV_NOT_VOID_WRAP(...) {}
#define pack_glGetPathColorGenfvNV(_color, _pname, _value) ({ \
    glGetPathColorGenfvNV_PACKED *packed_data = malloc(sizeof(glGetPathColorGenfvNV_PACKED)); \
    packed_data->index = glGetPathColorGenfvNV_INDEX; \
    packed_data->args.color = (GLenum)_color; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.value = (GLfloat *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glGetPathColorGenfvNV(packed, ret_v) do { \
    PACKED_glGetPathColorGenfvNV *unpacked = (PACKED_glGetPathColorGenfvNV *)packed; \
    ARGS_glGetPathColorGenfvNV *args = (ARGS_glGetPathColorGenfvNV *)&unpacked->args; \
    glGetPathColorGenfvNV(args->color, args->pname, args->value);; \
} while(0)
void glGetPathColorGenfvNV(glGetPathColorGenfvNV_ARG_EXPAND);
typedef void (*glGetPathColorGenfvNV_PTR)(glGetPathColorGenfvNV_ARG_EXPAND);
#define glGetPathColorGenivNV_INDEX 879
#define glGetPathColorGenivNV_RETURN void
#define glGetPathColorGenivNV_ARG_NAMES color, pname, value
#define glGetPathColorGenivNV_ARG_EXPAND GLenum color, GLenum pname, GLint * value
#define glGetPathColorGenivNV_PACKED PACKED_glGetPathColorGenivNV
#define glGetPathColorGenivNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetPathColorGenivNV_NOT_VOID_WRAP(...) {}
#define pack_glGetPathColorGenivNV(_color, _pname, _value) ({ \
    glGetPathColorGenivNV_PACKED *packed_data = malloc(sizeof(glGetPathColorGenivNV_PACKED)); \
    packed_data->index = glGetPathColorGenivNV_INDEX; \
    packed_data->args.color = (GLenum)_color; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.value = (GLint *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glGetPathColorGenivNV(packed, ret_v) do { \
    PACKED_glGetPathColorGenivNV *unpacked = (PACKED_glGetPathColorGenivNV *)packed; \
    ARGS_glGetPathColorGenivNV *args = (ARGS_glGetPathColorGenivNV *)&unpacked->args; \
    glGetPathColorGenivNV(args->color, args->pname, args->value);; \
} while(0)
void glGetPathColorGenivNV(glGetPathColorGenivNV_ARG_EXPAND);
typedef void (*glGetPathColorGenivNV_PTR)(glGetPathColorGenivNV_ARG_EXPAND);
#define glGetPathCommandsNV_INDEX 880
#define glGetPathCommandsNV_RETURN void
#define glGetPathCommandsNV_ARG_NAMES path, commands
#define glGetPathCommandsNV_ARG_EXPAND GLuint path, GLubyte * commands
#define glGetPathCommandsNV_PACKED PACKED_glGetPathCommandsNV
#define glGetPathCommandsNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetPathCommandsNV_NOT_VOID_WRAP(...) {}
#define pack_glGetPathCommandsNV(_path, _commands) ({ \
    glGetPathCommandsNV_PACKED *packed_data = malloc(sizeof(glGetPathCommandsNV_PACKED)); \
    packed_data->index = glGetPathCommandsNV_INDEX; \
    packed_data->args.path = (GLuint)_path; \
    packed_data->args.commands = (GLubyte *)_commands; \
    (packed_call_t *)packed_data; \
})
#define call_glGetPathCommandsNV(packed, ret_v) do { \
    PACKED_glGetPathCommandsNV *unpacked = (PACKED_glGetPathCommandsNV *)packed; \
    ARGS_glGetPathCommandsNV *args = (ARGS_glGetPathCommandsNV *)&unpacked->args; \
    glGetPathCommandsNV(args->path, args->commands);; \
} while(0)
void glGetPathCommandsNV(glGetPathCommandsNV_ARG_EXPAND);
typedef void (*glGetPathCommandsNV_PTR)(glGetPathCommandsNV_ARG_EXPAND);
#define glGetPathCoordsNV_INDEX 881
#define glGetPathCoordsNV_RETURN void
#define glGetPathCoordsNV_ARG_NAMES path, coords
#define glGetPathCoordsNV_ARG_EXPAND GLuint path, GLfloat * coords
#define glGetPathCoordsNV_PACKED PACKED_glGetPathCoordsNV
#define glGetPathCoordsNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetPathCoordsNV_NOT_VOID_WRAP(...) {}
#define pack_glGetPathCoordsNV(_path, _coords) ({ \
    glGetPathCoordsNV_PACKED *packed_data = malloc(sizeof(glGetPathCoordsNV_PACKED)); \
    packed_data->index = glGetPathCoordsNV_INDEX; \
    packed_data->args.path = (GLuint)_path; \
    packed_data->args.coords = (GLfloat *)_coords; \
    (packed_call_t *)packed_data; \
})
#define call_glGetPathCoordsNV(packed, ret_v) do { \
    PACKED_glGetPathCoordsNV *unpacked = (PACKED_glGetPathCoordsNV *)packed; \
    ARGS_glGetPathCoordsNV *args = (ARGS_glGetPathCoordsNV *)&unpacked->args; \
    glGetPathCoordsNV(args->path, args->coords);; \
} while(0)
void glGetPathCoordsNV(glGetPathCoordsNV_ARG_EXPAND);
typedef void (*glGetPathCoordsNV_PTR)(glGetPathCoordsNV_ARG_EXPAND);
#define glGetPathDashArrayNV_INDEX 882
#define glGetPathDashArrayNV_RETURN void
#define glGetPathDashArrayNV_ARG_NAMES path, dashArray
#define glGetPathDashArrayNV_ARG_EXPAND GLuint path, GLfloat * dashArray
#define glGetPathDashArrayNV_PACKED PACKED_glGetPathDashArrayNV
#define glGetPathDashArrayNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetPathDashArrayNV_NOT_VOID_WRAP(...) {}
#define pack_glGetPathDashArrayNV(_path, _dashArray) ({ \
    glGetPathDashArrayNV_PACKED *packed_data = malloc(sizeof(glGetPathDashArrayNV_PACKED)); \
    packed_data->index = glGetPathDashArrayNV_INDEX; \
    packed_data->args.path = (GLuint)_path; \
    packed_data->args.dashArray = (GLfloat *)_dashArray; \
    (packed_call_t *)packed_data; \
})
#define call_glGetPathDashArrayNV(packed, ret_v) do { \
    PACKED_glGetPathDashArrayNV *unpacked = (PACKED_glGetPathDashArrayNV *)packed; \
    ARGS_glGetPathDashArrayNV *args = (ARGS_glGetPathDashArrayNV *)&unpacked->args; \
    glGetPathDashArrayNV(args->path, args->dashArray);; \
} while(0)
void glGetPathDashArrayNV(glGetPathDashArrayNV_ARG_EXPAND);
typedef void (*glGetPathDashArrayNV_PTR)(glGetPathDashArrayNV_ARG_EXPAND);
#define glGetPathLengthNV_INDEX 883
#define glGetPathLengthNV_RETURN GLfloat
#define glGetPathLengthNV_ARG_NAMES path, startSegment, numSegments
#define glGetPathLengthNV_ARG_EXPAND GLuint path, GLsizei startSegment, GLsizei numSegments
#define glGetPathLengthNV_PACKED PACKED_glGetPathLengthNV
#define glGetPathLengthNV_VOID_ONLY_WRAP(...) {}
#define glGetPathLengthNV_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glGetPathLengthNV(_path, _startSegment, _numSegments) ({ \
    glGetPathLengthNV_PACKED *packed_data = malloc(sizeof(glGetPathLengthNV_PACKED)); \
    packed_data->index = glGetPathLengthNV_INDEX; \
    packed_data->args.path = (GLuint)_path; \
    packed_data->args.startSegment = (GLsizei)_startSegment; \
    packed_data->args.numSegments = (GLsizei)_numSegments; \
    (packed_call_t *)packed_data; \
})
#define call_glGetPathLengthNV(packed, ret_v) do { \
    PACKED_glGetPathLengthNV *unpacked = (PACKED_glGetPathLengthNV *)packed; \
    ARGS_glGetPathLengthNV *args = (ARGS_glGetPathLengthNV *)&unpacked->args; \
    GLfloat *ret = (GLfloat *)ret_v; \
    if (ret != NULL) { \
        *ret = glGetPathLengthNV(args->path, args->startSegment, args->numSegments);; \
    } else { \
        glGetPathLengthNV(args->path, args->startSegment, args->numSegments);; \
    } \
} while(0)
GLfloat glGetPathLengthNV(glGetPathLengthNV_ARG_EXPAND);
typedef GLfloat (*glGetPathLengthNV_PTR)(glGetPathLengthNV_ARG_EXPAND);
#define glGetPathMetricRangeNV_INDEX 884
#define glGetPathMetricRangeNV_RETURN void
#define glGetPathMetricRangeNV_ARG_NAMES metricQueryMask, firstPathName, numPaths, stride, metrics
#define glGetPathMetricRangeNV_ARG_EXPAND GLbitfield metricQueryMask, GLuint firstPathName, GLsizei numPaths, GLsizei stride, GLfloat * metrics
#define glGetPathMetricRangeNV_PACKED PACKED_glGetPathMetricRangeNV
#define glGetPathMetricRangeNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetPathMetricRangeNV_NOT_VOID_WRAP(...) {}
#define pack_glGetPathMetricRangeNV(_metricQueryMask, _firstPathName, _numPaths, _stride, _metrics) ({ \
    glGetPathMetricRangeNV_PACKED *packed_data = malloc(sizeof(glGetPathMetricRangeNV_PACKED)); \
    packed_data->index = glGetPathMetricRangeNV_INDEX; \
    packed_data->args.metricQueryMask = (GLbitfield)_metricQueryMask; \
    packed_data->args.firstPathName = (GLuint)_firstPathName; \
    packed_data->args.numPaths = (GLsizei)_numPaths; \
    packed_data->args.stride = (GLsizei)_stride; \
    packed_data->args.metrics = (GLfloat *)_metrics; \
    (packed_call_t *)packed_data; \
})
#define call_glGetPathMetricRangeNV(packed, ret_v) do { \
    PACKED_glGetPathMetricRangeNV *unpacked = (PACKED_glGetPathMetricRangeNV *)packed; \
    ARGS_glGetPathMetricRangeNV *args = (ARGS_glGetPathMetricRangeNV *)&unpacked->args; \
    glGetPathMetricRangeNV(args->metricQueryMask, args->firstPathName, args->numPaths, args->stride, args->metrics);; \
} while(0)
void glGetPathMetricRangeNV(glGetPathMetricRangeNV_ARG_EXPAND);
typedef void (*glGetPathMetricRangeNV_PTR)(glGetPathMetricRangeNV_ARG_EXPAND);
#define glGetPathMetricsNV_INDEX 885
#define glGetPathMetricsNV_RETURN void
#define glGetPathMetricsNV_ARG_NAMES metricQueryMask, numPaths, pathNameType, paths, pathBase, stride, metrics
#define glGetPathMetricsNV_ARG_EXPAND GLbitfield metricQueryMask, GLsizei numPaths, GLenum pathNameType, const GLvoid * paths, GLuint pathBase, GLsizei stride, GLfloat * metrics
#define glGetPathMetricsNV_PACKED PACKED_glGetPathMetricsNV
#define glGetPathMetricsNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetPathMetricsNV_NOT_VOID_WRAP(...) {}
#define pack_glGetPathMetricsNV(_metricQueryMask, _numPaths, _pathNameType, _paths, _pathBase, _stride, _metrics) ({ \
    glGetPathMetricsNV_PACKED *packed_data = malloc(sizeof(glGetPathMetricsNV_PACKED)); \
    packed_data->index = glGetPathMetricsNV_INDEX; \
    packed_data->args.metricQueryMask = (GLbitfield)_metricQueryMask; \
    packed_data->args.numPaths = (GLsizei)_numPaths; \
    packed_data->args.pathNameType = (GLenum)_pathNameType; \
    packed_data->args.paths = (GLvoid *)_paths; \
    packed_data->args.pathBase = (GLuint)_pathBase; \
    packed_data->args.stride = (GLsizei)_stride; \
    packed_data->args.metrics = (GLfloat *)_metrics; \
    (packed_call_t *)packed_data; \
})
#define call_glGetPathMetricsNV(packed, ret_v) do { \
    PACKED_glGetPathMetricsNV *unpacked = (PACKED_glGetPathMetricsNV *)packed; \
    ARGS_glGetPathMetricsNV *args = (ARGS_glGetPathMetricsNV *)&unpacked->args; \
    glGetPathMetricsNV(args->metricQueryMask, args->numPaths, args->pathNameType, args->paths, args->pathBase, args->stride, args->metrics);; \
} while(0)
void glGetPathMetricsNV(glGetPathMetricsNV_ARG_EXPAND);
typedef void (*glGetPathMetricsNV_PTR)(glGetPathMetricsNV_ARG_EXPAND);
#define glGetPathParameterfvNV_INDEX 886
#define glGetPathParameterfvNV_RETURN void
#define glGetPathParameterfvNV_ARG_NAMES path, pname, value
#define glGetPathParameterfvNV_ARG_EXPAND GLuint path, GLenum pname, GLfloat * value
#define glGetPathParameterfvNV_PACKED PACKED_glGetPathParameterfvNV
#define glGetPathParameterfvNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetPathParameterfvNV_NOT_VOID_WRAP(...) {}
#define pack_glGetPathParameterfvNV(_path, _pname, _value) ({ \
    glGetPathParameterfvNV_PACKED *packed_data = malloc(sizeof(glGetPathParameterfvNV_PACKED)); \
    packed_data->index = glGetPathParameterfvNV_INDEX; \
    packed_data->args.path = (GLuint)_path; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.value = (GLfloat *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glGetPathParameterfvNV(packed, ret_v) do { \
    PACKED_glGetPathParameterfvNV *unpacked = (PACKED_glGetPathParameterfvNV *)packed; \
    ARGS_glGetPathParameterfvNV *args = (ARGS_glGetPathParameterfvNV *)&unpacked->args; \
    glGetPathParameterfvNV(args->path, args->pname, args->value);; \
} while(0)
void glGetPathParameterfvNV(glGetPathParameterfvNV_ARG_EXPAND);
typedef void (*glGetPathParameterfvNV_PTR)(glGetPathParameterfvNV_ARG_EXPAND);
#define glGetPathParameterivNV_INDEX 887
#define glGetPathParameterivNV_RETURN void
#define glGetPathParameterivNV_ARG_NAMES path, pname, value
#define glGetPathParameterivNV_ARG_EXPAND GLuint path, GLenum pname, GLint * value
#define glGetPathParameterivNV_PACKED PACKED_glGetPathParameterivNV
#define glGetPathParameterivNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetPathParameterivNV_NOT_VOID_WRAP(...) {}
#define pack_glGetPathParameterivNV(_path, _pname, _value) ({ \
    glGetPathParameterivNV_PACKED *packed_data = malloc(sizeof(glGetPathParameterivNV_PACKED)); \
    packed_data->index = glGetPathParameterivNV_INDEX; \
    packed_data->args.path = (GLuint)_path; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.value = (GLint *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glGetPathParameterivNV(packed, ret_v) do { \
    PACKED_glGetPathParameterivNV *unpacked = (PACKED_glGetPathParameterivNV *)packed; \
    ARGS_glGetPathParameterivNV *args = (ARGS_glGetPathParameterivNV *)&unpacked->args; \
    glGetPathParameterivNV(args->path, args->pname, args->value);; \
} while(0)
void glGetPathParameterivNV(glGetPathParameterivNV_ARG_EXPAND);
typedef void (*glGetPathParameterivNV_PTR)(glGetPathParameterivNV_ARG_EXPAND);
#define glGetPathSpacingNV_INDEX 888
#define glGetPathSpacingNV_RETURN void
#define glGetPathSpacingNV_ARG_NAMES pathListMode, numPaths, pathNameType, paths, pathBase, advanceScale, kerningScale, transformType, returnedSpacing
#define glGetPathSpacingNV_ARG_EXPAND GLenum pathListMode, GLsizei numPaths, GLenum pathNameType, const GLvoid * paths, GLuint pathBase, GLfloat advanceScale, GLfloat kerningScale, GLenum transformType, GLfloat * returnedSpacing
#define glGetPathSpacingNV_PACKED PACKED_glGetPathSpacingNV
#define glGetPathSpacingNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetPathSpacingNV_NOT_VOID_WRAP(...) {}
#define pack_glGetPathSpacingNV(_pathListMode, _numPaths, _pathNameType, _paths, _pathBase, _advanceScale, _kerningScale, _transformType, _returnedSpacing) ({ \
    glGetPathSpacingNV_PACKED *packed_data = malloc(sizeof(glGetPathSpacingNV_PACKED)); \
    packed_data->index = glGetPathSpacingNV_INDEX; \
    packed_data->args.pathListMode = (GLenum)_pathListMode; \
    packed_data->args.numPaths = (GLsizei)_numPaths; \
    packed_data->args.pathNameType = (GLenum)_pathNameType; \
    packed_data->args.paths = (GLvoid *)_paths; \
    packed_data->args.pathBase = (GLuint)_pathBase; \
    packed_data->args.advanceScale = (GLfloat)_advanceScale; \
    packed_data->args.kerningScale = (GLfloat)_kerningScale; \
    packed_data->args.transformType = (GLenum)_transformType; \
    packed_data->args.returnedSpacing = (GLfloat *)_returnedSpacing; \
    (packed_call_t *)packed_data; \
})
#define call_glGetPathSpacingNV(packed, ret_v) do { \
    PACKED_glGetPathSpacingNV *unpacked = (PACKED_glGetPathSpacingNV *)packed; \
    ARGS_glGetPathSpacingNV *args = (ARGS_glGetPathSpacingNV *)&unpacked->args; \
    glGetPathSpacingNV(args->pathListMode, args->numPaths, args->pathNameType, args->paths, args->pathBase, args->advanceScale, args->kerningScale, args->transformType, args->returnedSpacing);; \
} while(0)
void glGetPathSpacingNV(glGetPathSpacingNV_ARG_EXPAND);
typedef void (*glGetPathSpacingNV_PTR)(glGetPathSpacingNV_ARG_EXPAND);
#define glGetPathTexGenfvNV_INDEX 889
#define glGetPathTexGenfvNV_RETURN void
#define glGetPathTexGenfvNV_ARG_NAMES texCoordSet, pname, value
#define glGetPathTexGenfvNV_ARG_EXPAND GLenum texCoordSet, GLenum pname, GLfloat * value
#define glGetPathTexGenfvNV_PACKED PACKED_glGetPathTexGenfvNV
#define glGetPathTexGenfvNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetPathTexGenfvNV_NOT_VOID_WRAP(...) {}
#define pack_glGetPathTexGenfvNV(_texCoordSet, _pname, _value) ({ \
    glGetPathTexGenfvNV_PACKED *packed_data = malloc(sizeof(glGetPathTexGenfvNV_PACKED)); \
    packed_data->index = glGetPathTexGenfvNV_INDEX; \
    packed_data->args.texCoordSet = (GLenum)_texCoordSet; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.value = (GLfloat *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glGetPathTexGenfvNV(packed, ret_v) do { \
    PACKED_glGetPathTexGenfvNV *unpacked = (PACKED_glGetPathTexGenfvNV *)packed; \
    ARGS_glGetPathTexGenfvNV *args = (ARGS_glGetPathTexGenfvNV *)&unpacked->args; \
    glGetPathTexGenfvNV(args->texCoordSet, args->pname, args->value);; \
} while(0)
void glGetPathTexGenfvNV(glGetPathTexGenfvNV_ARG_EXPAND);
typedef void (*glGetPathTexGenfvNV_PTR)(glGetPathTexGenfvNV_ARG_EXPAND);
#define glGetPathTexGenivNV_INDEX 890
#define glGetPathTexGenivNV_RETURN void
#define glGetPathTexGenivNV_ARG_NAMES texCoordSet, pname, value
#define glGetPathTexGenivNV_ARG_EXPAND GLenum texCoordSet, GLenum pname, GLint * value
#define glGetPathTexGenivNV_PACKED PACKED_glGetPathTexGenivNV
#define glGetPathTexGenivNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetPathTexGenivNV_NOT_VOID_WRAP(...) {}
#define pack_glGetPathTexGenivNV(_texCoordSet, _pname, _value) ({ \
    glGetPathTexGenivNV_PACKED *packed_data = malloc(sizeof(glGetPathTexGenivNV_PACKED)); \
    packed_data->index = glGetPathTexGenivNV_INDEX; \
    packed_data->args.texCoordSet = (GLenum)_texCoordSet; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.value = (GLint *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glGetPathTexGenivNV(packed, ret_v) do { \
    PACKED_glGetPathTexGenivNV *unpacked = (PACKED_glGetPathTexGenivNV *)packed; \
    ARGS_glGetPathTexGenivNV *args = (ARGS_glGetPathTexGenivNV *)&unpacked->args; \
    glGetPathTexGenivNV(args->texCoordSet, args->pname, args->value);; \
} while(0)
void glGetPathTexGenivNV(glGetPathTexGenivNV_ARG_EXPAND);
typedef void (*glGetPathTexGenivNV_PTR)(glGetPathTexGenivNV_ARG_EXPAND);
#define glGetPerfMonitorCounterDataAMD_INDEX 891
#define glGetPerfMonitorCounterDataAMD_RETURN void
#define glGetPerfMonitorCounterDataAMD_ARG_NAMES monitor, pname, dataSize, data, bytesWritten
#define glGetPerfMonitorCounterDataAMD_ARG_EXPAND GLuint monitor, GLenum pname, GLsizei dataSize, GLuint * data, GLint * bytesWritten
#define glGetPerfMonitorCounterDataAMD_PACKED PACKED_glGetPerfMonitorCounterDataAMD
#define glGetPerfMonitorCounterDataAMD_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetPerfMonitorCounterDataAMD_NOT_VOID_WRAP(...) {}
#define pack_glGetPerfMonitorCounterDataAMD(_monitor, _pname, _dataSize, _data, _bytesWritten) ({ \
    glGetPerfMonitorCounterDataAMD_PACKED *packed_data = malloc(sizeof(glGetPerfMonitorCounterDataAMD_PACKED)); \
    packed_data->index = glGetPerfMonitorCounterDataAMD_INDEX; \
    packed_data->args.monitor = (GLuint)_monitor; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.dataSize = (GLsizei)_dataSize; \
    packed_data->args.data = (GLuint *)_data; \
    packed_data->args.bytesWritten = (GLint *)_bytesWritten; \
    (packed_call_t *)packed_data; \
})
#define call_glGetPerfMonitorCounterDataAMD(packed, ret_v) do { \
    PACKED_glGetPerfMonitorCounterDataAMD *unpacked = (PACKED_glGetPerfMonitorCounterDataAMD *)packed; \
    ARGS_glGetPerfMonitorCounterDataAMD *args = (ARGS_glGetPerfMonitorCounterDataAMD *)&unpacked->args; \
    glGetPerfMonitorCounterDataAMD(args->monitor, args->pname, args->dataSize, args->data, args->bytesWritten);; \
} while(0)
void glGetPerfMonitorCounterDataAMD(glGetPerfMonitorCounterDataAMD_ARG_EXPAND);
typedef void (*glGetPerfMonitorCounterDataAMD_PTR)(glGetPerfMonitorCounterDataAMD_ARG_EXPAND);
#define glGetPerfMonitorCounterInfoAMD_INDEX 892
#define glGetPerfMonitorCounterInfoAMD_RETURN void
#define glGetPerfMonitorCounterInfoAMD_ARG_NAMES group, counter, pname, data
#define glGetPerfMonitorCounterInfoAMD_ARG_EXPAND GLuint group, GLuint counter, GLenum pname, GLvoid * data
#define glGetPerfMonitorCounterInfoAMD_PACKED PACKED_glGetPerfMonitorCounterInfoAMD
#define glGetPerfMonitorCounterInfoAMD_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetPerfMonitorCounterInfoAMD_NOT_VOID_WRAP(...) {}
#define pack_glGetPerfMonitorCounterInfoAMD(_group, _counter, _pname, _data) ({ \
    glGetPerfMonitorCounterInfoAMD_PACKED *packed_data = malloc(sizeof(glGetPerfMonitorCounterInfoAMD_PACKED)); \
    packed_data->index = glGetPerfMonitorCounterInfoAMD_INDEX; \
    packed_data->args.group = (GLuint)_group; \
    packed_data->args.counter = (GLuint)_counter; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.data = (GLvoid *)_data; \
    (packed_call_t *)packed_data; \
})
#define call_glGetPerfMonitorCounterInfoAMD(packed, ret_v) do { \
    PACKED_glGetPerfMonitorCounterInfoAMD *unpacked = (PACKED_glGetPerfMonitorCounterInfoAMD *)packed; \
    ARGS_glGetPerfMonitorCounterInfoAMD *args = (ARGS_glGetPerfMonitorCounterInfoAMD *)&unpacked->args; \
    glGetPerfMonitorCounterInfoAMD(args->group, args->counter, args->pname, args->data);; \
} while(0)
void glGetPerfMonitorCounterInfoAMD(glGetPerfMonitorCounterInfoAMD_ARG_EXPAND);
typedef void (*glGetPerfMonitorCounterInfoAMD_PTR)(glGetPerfMonitorCounterInfoAMD_ARG_EXPAND);
#define glGetPerfMonitorCounterStringAMD_INDEX 893
#define glGetPerfMonitorCounterStringAMD_RETURN void
#define glGetPerfMonitorCounterStringAMD_ARG_NAMES group, counter, bufSize, length, counterString
#define glGetPerfMonitorCounterStringAMD_ARG_EXPAND GLuint group, GLuint counter, GLsizei bufSize, GLsizei * length, GLchar * counterString
#define glGetPerfMonitorCounterStringAMD_PACKED PACKED_glGetPerfMonitorCounterStringAMD
#define glGetPerfMonitorCounterStringAMD_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetPerfMonitorCounterStringAMD_NOT_VOID_WRAP(...) {}
#define pack_glGetPerfMonitorCounterStringAMD(_group, _counter, _bufSize, _length, _counterString) ({ \
    glGetPerfMonitorCounterStringAMD_PACKED *packed_data = malloc(sizeof(glGetPerfMonitorCounterStringAMD_PACKED)); \
    packed_data->index = glGetPerfMonitorCounterStringAMD_INDEX; \
    packed_data->args.group = (GLuint)_group; \
    packed_data->args.counter = (GLuint)_counter; \
    packed_data->args.bufSize = (GLsizei)_bufSize; \
    packed_data->args.length = (GLsizei *)_length; \
    packed_data->args.counterString = (GLchar *)_counterString; \
    (packed_call_t *)packed_data; \
})
#define call_glGetPerfMonitorCounterStringAMD(packed, ret_v) do { \
    PACKED_glGetPerfMonitorCounterStringAMD *unpacked = (PACKED_glGetPerfMonitorCounterStringAMD *)packed; \
    ARGS_glGetPerfMonitorCounterStringAMD *args = (ARGS_glGetPerfMonitorCounterStringAMD *)&unpacked->args; \
    glGetPerfMonitorCounterStringAMD(args->group, args->counter, args->bufSize, args->length, args->counterString);; \
} while(0)
void glGetPerfMonitorCounterStringAMD(glGetPerfMonitorCounterStringAMD_ARG_EXPAND);
typedef void (*glGetPerfMonitorCounterStringAMD_PTR)(glGetPerfMonitorCounterStringAMD_ARG_EXPAND);
#define glGetPerfMonitorCountersAMD_INDEX 894
#define glGetPerfMonitorCountersAMD_RETURN void
#define glGetPerfMonitorCountersAMD_ARG_NAMES group, numCounters, maxActiveCounters, counterSize, counters
#define glGetPerfMonitorCountersAMD_ARG_EXPAND GLuint group, GLint * numCounters, GLint * maxActiveCounters, GLsizei counterSize, GLuint * counters
#define glGetPerfMonitorCountersAMD_PACKED PACKED_glGetPerfMonitorCountersAMD
#define glGetPerfMonitorCountersAMD_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetPerfMonitorCountersAMD_NOT_VOID_WRAP(...) {}
#define pack_glGetPerfMonitorCountersAMD(_group, _numCounters, _maxActiveCounters, _counterSize, _counters) ({ \
    glGetPerfMonitorCountersAMD_PACKED *packed_data = malloc(sizeof(glGetPerfMonitorCountersAMD_PACKED)); \
    packed_data->index = glGetPerfMonitorCountersAMD_INDEX; \
    packed_data->args.group = (GLuint)_group; \
    packed_data->args.numCounters = (GLint *)_numCounters; \
    packed_data->args.maxActiveCounters = (GLint *)_maxActiveCounters; \
    packed_data->args.counterSize = (GLsizei)_counterSize; \
    packed_data->args.counters = (GLuint *)_counters; \
    (packed_call_t *)packed_data; \
})
#define call_glGetPerfMonitorCountersAMD(packed, ret_v) do { \
    PACKED_glGetPerfMonitorCountersAMD *unpacked = (PACKED_glGetPerfMonitorCountersAMD *)packed; \
    ARGS_glGetPerfMonitorCountersAMD *args = (ARGS_glGetPerfMonitorCountersAMD *)&unpacked->args; \
    glGetPerfMonitorCountersAMD(args->group, args->numCounters, args->maxActiveCounters, args->counterSize, args->counters);; \
} while(0)
void glGetPerfMonitorCountersAMD(glGetPerfMonitorCountersAMD_ARG_EXPAND);
typedef void (*glGetPerfMonitorCountersAMD_PTR)(glGetPerfMonitorCountersAMD_ARG_EXPAND);
#define glGetPerfMonitorGroupStringAMD_INDEX 895
#define glGetPerfMonitorGroupStringAMD_RETURN void
#define glGetPerfMonitorGroupStringAMD_ARG_NAMES group, bufSize, length, groupString
#define glGetPerfMonitorGroupStringAMD_ARG_EXPAND GLuint group, GLsizei bufSize, GLsizei * length, GLchar * groupString
#define glGetPerfMonitorGroupStringAMD_PACKED PACKED_glGetPerfMonitorGroupStringAMD
#define glGetPerfMonitorGroupStringAMD_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetPerfMonitorGroupStringAMD_NOT_VOID_WRAP(...) {}
#define pack_glGetPerfMonitorGroupStringAMD(_group, _bufSize, _length, _groupString) ({ \
    glGetPerfMonitorGroupStringAMD_PACKED *packed_data = malloc(sizeof(glGetPerfMonitorGroupStringAMD_PACKED)); \
    packed_data->index = glGetPerfMonitorGroupStringAMD_INDEX; \
    packed_data->args.group = (GLuint)_group; \
    packed_data->args.bufSize = (GLsizei)_bufSize; \
    packed_data->args.length = (GLsizei *)_length; \
    packed_data->args.groupString = (GLchar *)_groupString; \
    (packed_call_t *)packed_data; \
})
#define call_glGetPerfMonitorGroupStringAMD(packed, ret_v) do { \
    PACKED_glGetPerfMonitorGroupStringAMD *unpacked = (PACKED_glGetPerfMonitorGroupStringAMD *)packed; \
    ARGS_glGetPerfMonitorGroupStringAMD *args = (ARGS_glGetPerfMonitorGroupStringAMD *)&unpacked->args; \
    glGetPerfMonitorGroupStringAMD(args->group, args->bufSize, args->length, args->groupString);; \
} while(0)
void glGetPerfMonitorGroupStringAMD(glGetPerfMonitorGroupStringAMD_ARG_EXPAND);
typedef void (*glGetPerfMonitorGroupStringAMD_PTR)(glGetPerfMonitorGroupStringAMD_ARG_EXPAND);
#define glGetPerfMonitorGroupsAMD_INDEX 896
#define glGetPerfMonitorGroupsAMD_RETURN void
#define glGetPerfMonitorGroupsAMD_ARG_NAMES numGroups, groupsSize, groups
#define glGetPerfMonitorGroupsAMD_ARG_EXPAND GLint * numGroups, GLsizei groupsSize, GLuint * groups
#define glGetPerfMonitorGroupsAMD_PACKED PACKED_glGetPerfMonitorGroupsAMD
#define glGetPerfMonitorGroupsAMD_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetPerfMonitorGroupsAMD_NOT_VOID_WRAP(...) {}
#define pack_glGetPerfMonitorGroupsAMD(_numGroups, _groupsSize, _groups) ({ \
    glGetPerfMonitorGroupsAMD_PACKED *packed_data = malloc(sizeof(glGetPerfMonitorGroupsAMD_PACKED)); \
    packed_data->index = glGetPerfMonitorGroupsAMD_INDEX; \
    packed_data->args.numGroups = (GLint *)_numGroups; \
    packed_data->args.groupsSize = (GLsizei)_groupsSize; \
    packed_data->args.groups = (GLuint *)_groups; \
    (packed_call_t *)packed_data; \
})
#define call_glGetPerfMonitorGroupsAMD(packed, ret_v) do { \
    PACKED_glGetPerfMonitorGroupsAMD *unpacked = (PACKED_glGetPerfMonitorGroupsAMD *)packed; \
    ARGS_glGetPerfMonitorGroupsAMD *args = (ARGS_glGetPerfMonitorGroupsAMD *)&unpacked->args; \
    glGetPerfMonitorGroupsAMD(args->numGroups, args->groupsSize, args->groups);; \
} while(0)
void glGetPerfMonitorGroupsAMD(glGetPerfMonitorGroupsAMD_ARG_EXPAND);
typedef void (*glGetPerfMonitorGroupsAMD_PTR)(glGetPerfMonitorGroupsAMD_ARG_EXPAND);
#define glGetPixelMapfv_INDEX 897
#define glGetPixelMapfv_RETURN void
#define glGetPixelMapfv_ARG_NAMES map, values
#define glGetPixelMapfv_ARG_EXPAND GLenum map, GLfloat * values
#define glGetPixelMapfv_PACKED PACKED_glGetPixelMapfv
#define glGetPixelMapfv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetPixelMapfv_NOT_VOID_WRAP(...) {}
#define pack_glGetPixelMapfv(_map, _values) ({ \
    glGetPixelMapfv_PACKED *packed_data = malloc(sizeof(glGetPixelMapfv_PACKED)); \
    packed_data->index = glGetPixelMapfv_INDEX; \
    packed_data->args.map = (GLenum)_map; \
    packed_data->args.values = (GLfloat *)_values; \
    (packed_call_t *)packed_data; \
})
#define call_glGetPixelMapfv(packed, ret_v) do { \
    PACKED_glGetPixelMapfv *unpacked = (PACKED_glGetPixelMapfv *)packed; \
    ARGS_glGetPixelMapfv *args = (ARGS_glGetPixelMapfv *)&unpacked->args; \
    glGetPixelMapfv(args->map, args->values);; \
} while(0)
void glGetPixelMapfv(glGetPixelMapfv_ARG_EXPAND);
typedef void (*glGetPixelMapfv_PTR)(glGetPixelMapfv_ARG_EXPAND);
#define glGetPixelMapuiv_INDEX 898
#define glGetPixelMapuiv_RETURN void
#define glGetPixelMapuiv_ARG_NAMES map, values
#define glGetPixelMapuiv_ARG_EXPAND GLenum map, GLuint * values
#define glGetPixelMapuiv_PACKED PACKED_glGetPixelMapuiv
#define glGetPixelMapuiv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetPixelMapuiv_NOT_VOID_WRAP(...) {}
#define pack_glGetPixelMapuiv(_map, _values) ({ \
    glGetPixelMapuiv_PACKED *packed_data = malloc(sizeof(glGetPixelMapuiv_PACKED)); \
    packed_data->index = glGetPixelMapuiv_INDEX; \
    packed_data->args.map = (GLenum)_map; \
    packed_data->args.values = (GLuint *)_values; \
    (packed_call_t *)packed_data; \
})
#define call_glGetPixelMapuiv(packed, ret_v) do { \
    PACKED_glGetPixelMapuiv *unpacked = (PACKED_glGetPixelMapuiv *)packed; \
    ARGS_glGetPixelMapuiv *args = (ARGS_glGetPixelMapuiv *)&unpacked->args; \
    glGetPixelMapuiv(args->map, args->values);; \
} while(0)
void glGetPixelMapuiv(glGetPixelMapuiv_ARG_EXPAND);
typedef void (*glGetPixelMapuiv_PTR)(glGetPixelMapuiv_ARG_EXPAND);
#define glGetPixelMapusv_INDEX 899
#define glGetPixelMapusv_RETURN void
#define glGetPixelMapusv_ARG_NAMES map, values
#define glGetPixelMapusv_ARG_EXPAND GLenum map, GLushort * values
#define glGetPixelMapusv_PACKED PACKED_glGetPixelMapusv
#define glGetPixelMapusv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetPixelMapusv_NOT_VOID_WRAP(...) {}
#define pack_glGetPixelMapusv(_map, _values) ({ \
    glGetPixelMapusv_PACKED *packed_data = malloc(sizeof(glGetPixelMapusv_PACKED)); \
    packed_data->index = glGetPixelMapusv_INDEX; \
    packed_data->args.map = (GLenum)_map; \
    packed_data->args.values = (GLushort *)_values; \
    (packed_call_t *)packed_data; \
})
#define call_glGetPixelMapusv(packed, ret_v) do { \
    PACKED_glGetPixelMapusv *unpacked = (PACKED_glGetPixelMapusv *)packed; \
    ARGS_glGetPixelMapusv *args = (ARGS_glGetPixelMapusv *)&unpacked->args; \
    glGetPixelMapusv(args->map, args->values);; \
} while(0)
void glGetPixelMapusv(glGetPixelMapusv_ARG_EXPAND);
typedef void (*glGetPixelMapusv_PTR)(glGetPixelMapusv_ARG_EXPAND);
#define glGetPixelMapxv_INDEX 900
#define glGetPixelMapxv_RETURN void
#define glGetPixelMapxv_ARG_NAMES map, size, values
#define glGetPixelMapxv_ARG_EXPAND GLenum map, GLint size, GLfixed * values
#define glGetPixelMapxv_PACKED PACKED_glGetPixelMapxv
#define glGetPixelMapxv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetPixelMapxv_NOT_VOID_WRAP(...) {}
#define pack_glGetPixelMapxv(_map, _size, _values) ({ \
    glGetPixelMapxv_PACKED *packed_data = malloc(sizeof(glGetPixelMapxv_PACKED)); \
    packed_data->index = glGetPixelMapxv_INDEX; \
    packed_data->args.map = (GLenum)_map; \
    packed_data->args.size = (GLint)_size; \
    packed_data->args.values = (GLfixed *)_values; \
    (packed_call_t *)packed_data; \
})
#define call_glGetPixelMapxv(packed, ret_v) do { \
    PACKED_glGetPixelMapxv *unpacked = (PACKED_glGetPixelMapxv *)packed; \
    ARGS_glGetPixelMapxv *args = (ARGS_glGetPixelMapxv *)&unpacked->args; \
    glGetPixelMapxv(args->map, args->size, args->values);; \
} while(0)
void glGetPixelMapxv(glGetPixelMapxv_ARG_EXPAND);
typedef void (*glGetPixelMapxv_PTR)(glGetPixelMapxv_ARG_EXPAND);
#define glGetPixelTexGenParameterfvSGIS_INDEX 901
#define glGetPixelTexGenParameterfvSGIS_RETURN void
#define glGetPixelTexGenParameterfvSGIS_ARG_NAMES pname, params
#define glGetPixelTexGenParameterfvSGIS_ARG_EXPAND GLenum pname, GLfloat * params
#define glGetPixelTexGenParameterfvSGIS_PACKED PACKED_glGetPixelTexGenParameterfvSGIS
#define glGetPixelTexGenParameterfvSGIS_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetPixelTexGenParameterfvSGIS_NOT_VOID_WRAP(...) {}
#define pack_glGetPixelTexGenParameterfvSGIS(_pname, _params) ({ \
    glGetPixelTexGenParameterfvSGIS_PACKED *packed_data = malloc(sizeof(glGetPixelTexGenParameterfvSGIS_PACKED)); \
    packed_data->index = glGetPixelTexGenParameterfvSGIS_INDEX; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLfloat *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetPixelTexGenParameterfvSGIS(packed, ret_v) do { \
    PACKED_glGetPixelTexGenParameterfvSGIS *unpacked = (PACKED_glGetPixelTexGenParameterfvSGIS *)packed; \
    ARGS_glGetPixelTexGenParameterfvSGIS *args = (ARGS_glGetPixelTexGenParameterfvSGIS *)&unpacked->args; \
    glGetPixelTexGenParameterfvSGIS(args->pname, args->params);; \
} while(0)
void glGetPixelTexGenParameterfvSGIS(glGetPixelTexGenParameterfvSGIS_ARG_EXPAND);
typedef void (*glGetPixelTexGenParameterfvSGIS_PTR)(glGetPixelTexGenParameterfvSGIS_ARG_EXPAND);
#define glGetPixelTexGenParameterivSGIS_INDEX 902
#define glGetPixelTexGenParameterivSGIS_RETURN void
#define glGetPixelTexGenParameterivSGIS_ARG_NAMES pname, params
#define glGetPixelTexGenParameterivSGIS_ARG_EXPAND GLenum pname, GLint * params
#define glGetPixelTexGenParameterivSGIS_PACKED PACKED_glGetPixelTexGenParameterivSGIS
#define glGetPixelTexGenParameterivSGIS_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetPixelTexGenParameterivSGIS_NOT_VOID_WRAP(...) {}
#define pack_glGetPixelTexGenParameterivSGIS(_pname, _params) ({ \
    glGetPixelTexGenParameterivSGIS_PACKED *packed_data = malloc(sizeof(glGetPixelTexGenParameterivSGIS_PACKED)); \
    packed_data->index = glGetPixelTexGenParameterivSGIS_INDEX; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetPixelTexGenParameterivSGIS(packed, ret_v) do { \
    PACKED_glGetPixelTexGenParameterivSGIS *unpacked = (PACKED_glGetPixelTexGenParameterivSGIS *)packed; \
    ARGS_glGetPixelTexGenParameterivSGIS *args = (ARGS_glGetPixelTexGenParameterivSGIS *)&unpacked->args; \
    glGetPixelTexGenParameterivSGIS(args->pname, args->params);; \
} while(0)
void glGetPixelTexGenParameterivSGIS(glGetPixelTexGenParameterivSGIS_ARG_EXPAND);
typedef void (*glGetPixelTexGenParameterivSGIS_PTR)(glGetPixelTexGenParameterivSGIS_ARG_EXPAND);
#define glGetPixelTransformParameterfvEXT_INDEX 903
#define glGetPixelTransformParameterfvEXT_RETURN void
#define glGetPixelTransformParameterfvEXT_ARG_NAMES target, pname, params
#define glGetPixelTransformParameterfvEXT_ARG_EXPAND GLenum target, GLenum pname, GLfloat * params
#define glGetPixelTransformParameterfvEXT_PACKED PACKED_glGetPixelTransformParameterfvEXT
#define glGetPixelTransformParameterfvEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetPixelTransformParameterfvEXT_NOT_VOID_WRAP(...) {}
#define pack_glGetPixelTransformParameterfvEXT(_target, _pname, _params) ({ \
    glGetPixelTransformParameterfvEXT_PACKED *packed_data = malloc(sizeof(glGetPixelTransformParameterfvEXT_PACKED)); \
    packed_data->index = glGetPixelTransformParameterfvEXT_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLfloat *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetPixelTransformParameterfvEXT(packed, ret_v) do { \
    PACKED_glGetPixelTransformParameterfvEXT *unpacked = (PACKED_glGetPixelTransformParameterfvEXT *)packed; \
    ARGS_glGetPixelTransformParameterfvEXT *args = (ARGS_glGetPixelTransformParameterfvEXT *)&unpacked->args; \
    glGetPixelTransformParameterfvEXT(args->target, args->pname, args->params);; \
} while(0)
void glGetPixelTransformParameterfvEXT(glGetPixelTransformParameterfvEXT_ARG_EXPAND);
typedef void (*glGetPixelTransformParameterfvEXT_PTR)(glGetPixelTransformParameterfvEXT_ARG_EXPAND);
#define glGetPixelTransformParameterivEXT_INDEX 904
#define glGetPixelTransformParameterivEXT_RETURN void
#define glGetPixelTransformParameterivEXT_ARG_NAMES target, pname, params
#define glGetPixelTransformParameterivEXT_ARG_EXPAND GLenum target, GLenum pname, GLint * params
#define glGetPixelTransformParameterivEXT_PACKED PACKED_glGetPixelTransformParameterivEXT
#define glGetPixelTransformParameterivEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetPixelTransformParameterivEXT_NOT_VOID_WRAP(...) {}
#define pack_glGetPixelTransformParameterivEXT(_target, _pname, _params) ({ \
    glGetPixelTransformParameterivEXT_PACKED *packed_data = malloc(sizeof(glGetPixelTransformParameterivEXT_PACKED)); \
    packed_data->index = glGetPixelTransformParameterivEXT_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetPixelTransformParameterivEXT(packed, ret_v) do { \
    PACKED_glGetPixelTransformParameterivEXT *unpacked = (PACKED_glGetPixelTransformParameterivEXT *)packed; \
    ARGS_glGetPixelTransformParameterivEXT *args = (ARGS_glGetPixelTransformParameterivEXT *)&unpacked->args; \
    glGetPixelTransformParameterivEXT(args->target, args->pname, args->params);; \
} while(0)
void glGetPixelTransformParameterivEXT(glGetPixelTransformParameterivEXT_ARG_EXPAND);
typedef void (*glGetPixelTransformParameterivEXT_PTR)(glGetPixelTransformParameterivEXT_ARG_EXPAND);
#define glGetPointerIndexedvEXT_INDEX 905
#define glGetPointerIndexedvEXT_RETURN void
#define glGetPointerIndexedvEXT_ARG_NAMES target, index, data
#define glGetPointerIndexedvEXT_ARG_EXPAND GLenum target, GLuint index, GLvoid * data
#define glGetPointerIndexedvEXT_PACKED PACKED_glGetPointerIndexedvEXT
#define glGetPointerIndexedvEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetPointerIndexedvEXT_NOT_VOID_WRAP(...) {}
#define pack_glGetPointerIndexedvEXT(_target, _index, _data) ({ \
    glGetPointerIndexedvEXT_PACKED *packed_data = malloc(sizeof(glGetPointerIndexedvEXT_PACKED)); \
    packed_data->index = glGetPointerIndexedvEXT_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.data = (GLvoid *)_data; \
    (packed_call_t *)packed_data; \
})
#define call_glGetPointerIndexedvEXT(packed, ret_v) do { \
    PACKED_glGetPointerIndexedvEXT *unpacked = (PACKED_glGetPointerIndexedvEXT *)packed; \
    ARGS_glGetPointerIndexedvEXT *args = (ARGS_glGetPointerIndexedvEXT *)&unpacked->args; \
    glGetPointerIndexedvEXT(args->target, args->index, args->data);; \
} while(0)
void glGetPointerIndexedvEXT(glGetPointerIndexedvEXT_ARG_EXPAND);
typedef void (*glGetPointerIndexedvEXT_PTR)(glGetPointerIndexedvEXT_ARG_EXPAND);
#define glGetPointeri_vEXT_INDEX 906
#define glGetPointeri_vEXT_RETURN void
#define glGetPointeri_vEXT_ARG_NAMES target, index, data
#define glGetPointeri_vEXT_ARG_EXPAND GLenum target, GLuint index, GLvoid * data
#define glGetPointeri_vEXT_PACKED PACKED_glGetPointeri_vEXT
#define glGetPointeri_vEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetPointeri_vEXT_NOT_VOID_WRAP(...) {}
#define pack_glGetPointeri_vEXT(_target, _index, _data) ({ \
    glGetPointeri_vEXT_PACKED *packed_data = malloc(sizeof(glGetPointeri_vEXT_PACKED)); \
    packed_data->index = glGetPointeri_vEXT_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.data = (GLvoid *)_data; \
    (packed_call_t *)packed_data; \
})
#define call_glGetPointeri_vEXT(packed, ret_v) do { \
    PACKED_glGetPointeri_vEXT *unpacked = (PACKED_glGetPointeri_vEXT *)packed; \
    ARGS_glGetPointeri_vEXT *args = (ARGS_glGetPointeri_vEXT *)&unpacked->args; \
    glGetPointeri_vEXT(args->target, args->index, args->data);; \
} while(0)
void glGetPointeri_vEXT(glGetPointeri_vEXT_ARG_EXPAND);
typedef void (*glGetPointeri_vEXT_PTR)(glGetPointeri_vEXT_ARG_EXPAND);
#define glGetPointerv_INDEX 907
#define glGetPointerv_RETURN void
#define glGetPointerv_ARG_NAMES pname, params
#define glGetPointerv_ARG_EXPAND GLenum pname, GLvoid ** params
#define glGetPointerv_PACKED PACKED_glGetPointerv
#define glGetPointerv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetPointerv_NOT_VOID_WRAP(...) {}
#define pack_glGetPointerv(_pname, _params) ({ \
    glGetPointerv_PACKED *packed_data = malloc(sizeof(glGetPointerv_PACKED)); \
    packed_data->index = glGetPointerv_INDEX; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLvoid **)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetPointerv(packed, ret_v) do { \
    PACKED_glGetPointerv *unpacked = (PACKED_glGetPointerv *)packed; \
    ARGS_glGetPointerv *args = (ARGS_glGetPointerv *)&unpacked->args; \
    glGetPointerv(args->pname, args->params);; \
} while(0)
void glGetPointerv(glGetPointerv_ARG_EXPAND);
typedef void (*glGetPointerv_PTR)(glGetPointerv_ARG_EXPAND);
#define glGetPointervEXT_INDEX 908
#define glGetPointervEXT_RETURN void
#define glGetPointervEXT_ARG_NAMES pname, params
#define glGetPointervEXT_ARG_EXPAND GLenum pname, GLvoid * params
#define glGetPointervEXT_PACKED PACKED_glGetPointervEXT
#define glGetPointervEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetPointervEXT_NOT_VOID_WRAP(...) {}
#define pack_glGetPointervEXT(_pname, _params) ({ \
    glGetPointervEXT_PACKED *packed_data = malloc(sizeof(glGetPointervEXT_PACKED)); \
    packed_data->index = glGetPointervEXT_INDEX; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLvoid *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetPointervEXT(packed, ret_v) do { \
    PACKED_glGetPointervEXT *unpacked = (PACKED_glGetPointervEXT *)packed; \
    ARGS_glGetPointervEXT *args = (ARGS_glGetPointervEXT *)&unpacked->args; \
    glGetPointervEXT(args->pname, args->params);; \
} while(0)
void glGetPointervEXT(glGetPointervEXT_ARG_EXPAND);
typedef void (*glGetPointervEXT_PTR)(glGetPointervEXT_ARG_EXPAND);
#define glGetPolygonStipple_INDEX 909
#define glGetPolygonStipple_RETURN void
#define glGetPolygonStipple_ARG_NAMES mask
#define glGetPolygonStipple_ARG_EXPAND GLubyte * mask
#define glGetPolygonStipple_PACKED PACKED_glGetPolygonStipple
#define glGetPolygonStipple_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetPolygonStipple_NOT_VOID_WRAP(...) {}
#define pack_glGetPolygonStipple(_mask) ({ \
    glGetPolygonStipple_PACKED *packed_data = malloc(sizeof(glGetPolygonStipple_PACKED)); \
    packed_data->index = glGetPolygonStipple_INDEX; \
    packed_data->args.mask = (GLubyte *)_mask; \
    (packed_call_t *)packed_data; \
})
#define call_glGetPolygonStipple(packed, ret_v) do { \
    PACKED_glGetPolygonStipple *unpacked = (PACKED_glGetPolygonStipple *)packed; \
    ARGS_glGetPolygonStipple *args = (ARGS_glGetPolygonStipple *)&unpacked->args; \
    glGetPolygonStipple(args->mask);; \
} while(0)
void glGetPolygonStipple(glGetPolygonStipple_ARG_EXPAND);
typedef void (*glGetPolygonStipple_PTR)(glGetPolygonStipple_ARG_EXPAND);
#define glGetProgramBinary_INDEX 910
#define glGetProgramBinary_RETURN void
#define glGetProgramBinary_ARG_NAMES program, bufSize, length, binaryFormat, binary
#define glGetProgramBinary_ARG_EXPAND GLuint program, GLsizei bufSize, GLsizei * length, GLenum * binaryFormat, GLvoid * binary
#define glGetProgramBinary_PACKED PACKED_glGetProgramBinary
#define glGetProgramBinary_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetProgramBinary_NOT_VOID_WRAP(...) {}
#define pack_glGetProgramBinary(_program, _bufSize, _length, _binaryFormat, _binary) ({ \
    glGetProgramBinary_PACKED *packed_data = malloc(sizeof(glGetProgramBinary_PACKED)); \
    packed_data->index = glGetProgramBinary_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.bufSize = (GLsizei)_bufSize; \
    packed_data->args.length = (GLsizei *)_length; \
    packed_data->args.binaryFormat = (GLenum *)_binaryFormat; \
    packed_data->args.binary = (GLvoid *)_binary; \
    (packed_call_t *)packed_data; \
})
#define call_glGetProgramBinary(packed, ret_v) do { \
    PACKED_glGetProgramBinary *unpacked = (PACKED_glGetProgramBinary *)packed; \
    ARGS_glGetProgramBinary *args = (ARGS_glGetProgramBinary *)&unpacked->args; \
    glGetProgramBinary(args->program, args->bufSize, args->length, args->binaryFormat, args->binary);; \
} while(0)
void glGetProgramBinary(glGetProgramBinary_ARG_EXPAND);
typedef void (*glGetProgramBinary_PTR)(glGetProgramBinary_ARG_EXPAND);
#define glGetProgramEnvParameterIivNV_INDEX 911
#define glGetProgramEnvParameterIivNV_RETURN void
#define glGetProgramEnvParameterIivNV_ARG_NAMES target, index, params
#define glGetProgramEnvParameterIivNV_ARG_EXPAND GLenum target, GLuint index, GLint * params
#define glGetProgramEnvParameterIivNV_PACKED PACKED_glGetProgramEnvParameterIivNV
#define glGetProgramEnvParameterIivNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetProgramEnvParameterIivNV_NOT_VOID_WRAP(...) {}
#define pack_glGetProgramEnvParameterIivNV(_target, _index, _params) ({ \
    glGetProgramEnvParameterIivNV_PACKED *packed_data = malloc(sizeof(glGetProgramEnvParameterIivNV_PACKED)); \
    packed_data->index = glGetProgramEnvParameterIivNV_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.params = (GLint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetProgramEnvParameterIivNV(packed, ret_v) do { \
    PACKED_glGetProgramEnvParameterIivNV *unpacked = (PACKED_glGetProgramEnvParameterIivNV *)packed; \
    ARGS_glGetProgramEnvParameterIivNV *args = (ARGS_glGetProgramEnvParameterIivNV *)&unpacked->args; \
    glGetProgramEnvParameterIivNV(args->target, args->index, args->params);; \
} while(0)
void glGetProgramEnvParameterIivNV(glGetProgramEnvParameterIivNV_ARG_EXPAND);
typedef void (*glGetProgramEnvParameterIivNV_PTR)(glGetProgramEnvParameterIivNV_ARG_EXPAND);
#define glGetProgramEnvParameterIuivNV_INDEX 912
#define glGetProgramEnvParameterIuivNV_RETURN void
#define glGetProgramEnvParameterIuivNV_ARG_NAMES target, index, params
#define glGetProgramEnvParameterIuivNV_ARG_EXPAND GLenum target, GLuint index, GLuint * params
#define glGetProgramEnvParameterIuivNV_PACKED PACKED_glGetProgramEnvParameterIuivNV
#define glGetProgramEnvParameterIuivNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetProgramEnvParameterIuivNV_NOT_VOID_WRAP(...) {}
#define pack_glGetProgramEnvParameterIuivNV(_target, _index, _params) ({ \
    glGetProgramEnvParameterIuivNV_PACKED *packed_data = malloc(sizeof(glGetProgramEnvParameterIuivNV_PACKED)); \
    packed_data->index = glGetProgramEnvParameterIuivNV_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.params = (GLuint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetProgramEnvParameterIuivNV(packed, ret_v) do { \
    PACKED_glGetProgramEnvParameterIuivNV *unpacked = (PACKED_glGetProgramEnvParameterIuivNV *)packed; \
    ARGS_glGetProgramEnvParameterIuivNV *args = (ARGS_glGetProgramEnvParameterIuivNV *)&unpacked->args; \
    glGetProgramEnvParameterIuivNV(args->target, args->index, args->params);; \
} while(0)
void glGetProgramEnvParameterIuivNV(glGetProgramEnvParameterIuivNV_ARG_EXPAND);
typedef void (*glGetProgramEnvParameterIuivNV_PTR)(glGetProgramEnvParameterIuivNV_ARG_EXPAND);
#define glGetProgramEnvParameterdvARB_INDEX 913
#define glGetProgramEnvParameterdvARB_RETURN void
#define glGetProgramEnvParameterdvARB_ARG_NAMES target, index, params
#define glGetProgramEnvParameterdvARB_ARG_EXPAND GLenum target, GLuint index, GLdouble * params
#define glGetProgramEnvParameterdvARB_PACKED PACKED_glGetProgramEnvParameterdvARB
#define glGetProgramEnvParameterdvARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetProgramEnvParameterdvARB_NOT_VOID_WRAP(...) {}
#define pack_glGetProgramEnvParameterdvARB(_target, _index, _params) ({ \
    glGetProgramEnvParameterdvARB_PACKED *packed_data = malloc(sizeof(glGetProgramEnvParameterdvARB_PACKED)); \
    packed_data->index = glGetProgramEnvParameterdvARB_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.params = (GLdouble *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetProgramEnvParameterdvARB(packed, ret_v) do { \
    PACKED_glGetProgramEnvParameterdvARB *unpacked = (PACKED_glGetProgramEnvParameterdvARB *)packed; \
    ARGS_glGetProgramEnvParameterdvARB *args = (ARGS_glGetProgramEnvParameterdvARB *)&unpacked->args; \
    glGetProgramEnvParameterdvARB(args->target, args->index, args->params);; \
} while(0)
void glGetProgramEnvParameterdvARB(glGetProgramEnvParameterdvARB_ARG_EXPAND);
typedef void (*glGetProgramEnvParameterdvARB_PTR)(glGetProgramEnvParameterdvARB_ARG_EXPAND);
#define glGetProgramEnvParameterfvARB_INDEX 914
#define glGetProgramEnvParameterfvARB_RETURN void
#define glGetProgramEnvParameterfvARB_ARG_NAMES target, index, params
#define glGetProgramEnvParameterfvARB_ARG_EXPAND GLenum target, GLuint index, GLfloat * params
#define glGetProgramEnvParameterfvARB_PACKED PACKED_glGetProgramEnvParameterfvARB
#define glGetProgramEnvParameterfvARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetProgramEnvParameterfvARB_NOT_VOID_WRAP(...) {}
#define pack_glGetProgramEnvParameterfvARB(_target, _index, _params) ({ \
    glGetProgramEnvParameterfvARB_PACKED *packed_data = malloc(sizeof(glGetProgramEnvParameterfvARB_PACKED)); \
    packed_data->index = glGetProgramEnvParameterfvARB_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.params = (GLfloat *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetProgramEnvParameterfvARB(packed, ret_v) do { \
    PACKED_glGetProgramEnvParameterfvARB *unpacked = (PACKED_glGetProgramEnvParameterfvARB *)packed; \
    ARGS_glGetProgramEnvParameterfvARB *args = (ARGS_glGetProgramEnvParameterfvARB *)&unpacked->args; \
    glGetProgramEnvParameterfvARB(args->target, args->index, args->params);; \
} while(0)
void glGetProgramEnvParameterfvARB(glGetProgramEnvParameterfvARB_ARG_EXPAND);
typedef void (*glGetProgramEnvParameterfvARB_PTR)(glGetProgramEnvParameterfvARB_ARG_EXPAND);
#define glGetProgramInfoLog_INDEX 915
#define glGetProgramInfoLog_RETURN void
#define glGetProgramInfoLog_ARG_NAMES program, bufSize, length, infoLog
#define glGetProgramInfoLog_ARG_EXPAND GLuint program, GLsizei bufSize, GLsizei * length, GLchar * infoLog
#define glGetProgramInfoLog_PACKED PACKED_glGetProgramInfoLog
#define glGetProgramInfoLog_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetProgramInfoLog_NOT_VOID_WRAP(...) {}
#define pack_glGetProgramInfoLog(_program, _bufSize, _length, _infoLog) ({ \
    glGetProgramInfoLog_PACKED *packed_data = malloc(sizeof(glGetProgramInfoLog_PACKED)); \
    packed_data->index = glGetProgramInfoLog_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.bufSize = (GLsizei)_bufSize; \
    packed_data->args.length = (GLsizei *)_length; \
    packed_data->args.infoLog = (GLchar *)_infoLog; \
    (packed_call_t *)packed_data; \
})
#define call_glGetProgramInfoLog(packed, ret_v) do { \
    PACKED_glGetProgramInfoLog *unpacked = (PACKED_glGetProgramInfoLog *)packed; \
    ARGS_glGetProgramInfoLog *args = (ARGS_glGetProgramInfoLog *)&unpacked->args; \
    glGetProgramInfoLog(args->program, args->bufSize, args->length, args->infoLog);; \
} while(0)
void glGetProgramInfoLog(glGetProgramInfoLog_ARG_EXPAND);
typedef void (*glGetProgramInfoLog_PTR)(glGetProgramInfoLog_ARG_EXPAND);
#define glGetProgramInterfaceiv_INDEX 916
#define glGetProgramInterfaceiv_RETURN void
#define glGetProgramInterfaceiv_ARG_NAMES program, programInterface, pname, params
#define glGetProgramInterfaceiv_ARG_EXPAND GLuint program, GLenum programInterface, GLenum pname, GLint * params
#define glGetProgramInterfaceiv_PACKED PACKED_glGetProgramInterfaceiv
#define glGetProgramInterfaceiv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetProgramInterfaceiv_NOT_VOID_WRAP(...) {}
#define pack_glGetProgramInterfaceiv(_program, _programInterface, _pname, _params) ({ \
    glGetProgramInterfaceiv_PACKED *packed_data = malloc(sizeof(glGetProgramInterfaceiv_PACKED)); \
    packed_data->index = glGetProgramInterfaceiv_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.programInterface = (GLenum)_programInterface; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetProgramInterfaceiv(packed, ret_v) do { \
    PACKED_glGetProgramInterfaceiv *unpacked = (PACKED_glGetProgramInterfaceiv *)packed; \
    ARGS_glGetProgramInterfaceiv *args = (ARGS_glGetProgramInterfaceiv *)&unpacked->args; \
    glGetProgramInterfaceiv(args->program, args->programInterface, args->pname, args->params);; \
} while(0)
void glGetProgramInterfaceiv(glGetProgramInterfaceiv_ARG_EXPAND);
typedef void (*glGetProgramInterfaceiv_PTR)(glGetProgramInterfaceiv_ARG_EXPAND);
#define glGetProgramLocalParameterIivNV_INDEX 917
#define glGetProgramLocalParameterIivNV_RETURN void
#define glGetProgramLocalParameterIivNV_ARG_NAMES target, index, params
#define glGetProgramLocalParameterIivNV_ARG_EXPAND GLenum target, GLuint index, GLint * params
#define glGetProgramLocalParameterIivNV_PACKED PACKED_glGetProgramLocalParameterIivNV
#define glGetProgramLocalParameterIivNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetProgramLocalParameterIivNV_NOT_VOID_WRAP(...) {}
#define pack_glGetProgramLocalParameterIivNV(_target, _index, _params) ({ \
    glGetProgramLocalParameterIivNV_PACKED *packed_data = malloc(sizeof(glGetProgramLocalParameterIivNV_PACKED)); \
    packed_data->index = glGetProgramLocalParameterIivNV_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.params = (GLint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetProgramLocalParameterIivNV(packed, ret_v) do { \
    PACKED_glGetProgramLocalParameterIivNV *unpacked = (PACKED_glGetProgramLocalParameterIivNV *)packed; \
    ARGS_glGetProgramLocalParameterIivNV *args = (ARGS_glGetProgramLocalParameterIivNV *)&unpacked->args; \
    glGetProgramLocalParameterIivNV(args->target, args->index, args->params);; \
} while(0)
void glGetProgramLocalParameterIivNV(glGetProgramLocalParameterIivNV_ARG_EXPAND);
typedef void (*glGetProgramLocalParameterIivNV_PTR)(glGetProgramLocalParameterIivNV_ARG_EXPAND);
#define glGetProgramLocalParameterIuivNV_INDEX 918
#define glGetProgramLocalParameterIuivNV_RETURN void
#define glGetProgramLocalParameterIuivNV_ARG_NAMES target, index, params
#define glGetProgramLocalParameterIuivNV_ARG_EXPAND GLenum target, GLuint index, GLuint * params
#define glGetProgramLocalParameterIuivNV_PACKED PACKED_glGetProgramLocalParameterIuivNV
#define glGetProgramLocalParameterIuivNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetProgramLocalParameterIuivNV_NOT_VOID_WRAP(...) {}
#define pack_glGetProgramLocalParameterIuivNV(_target, _index, _params) ({ \
    glGetProgramLocalParameterIuivNV_PACKED *packed_data = malloc(sizeof(glGetProgramLocalParameterIuivNV_PACKED)); \
    packed_data->index = glGetProgramLocalParameterIuivNV_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.params = (GLuint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetProgramLocalParameterIuivNV(packed, ret_v) do { \
    PACKED_glGetProgramLocalParameterIuivNV *unpacked = (PACKED_glGetProgramLocalParameterIuivNV *)packed; \
    ARGS_glGetProgramLocalParameterIuivNV *args = (ARGS_glGetProgramLocalParameterIuivNV *)&unpacked->args; \
    glGetProgramLocalParameterIuivNV(args->target, args->index, args->params);; \
} while(0)
void glGetProgramLocalParameterIuivNV(glGetProgramLocalParameterIuivNV_ARG_EXPAND);
typedef void (*glGetProgramLocalParameterIuivNV_PTR)(glGetProgramLocalParameterIuivNV_ARG_EXPAND);
#define glGetProgramLocalParameterdvARB_INDEX 919
#define glGetProgramLocalParameterdvARB_RETURN void
#define glGetProgramLocalParameterdvARB_ARG_NAMES target, index, params
#define glGetProgramLocalParameterdvARB_ARG_EXPAND GLenum target, GLuint index, GLdouble * params
#define glGetProgramLocalParameterdvARB_PACKED PACKED_glGetProgramLocalParameterdvARB
#define glGetProgramLocalParameterdvARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetProgramLocalParameterdvARB_NOT_VOID_WRAP(...) {}
#define pack_glGetProgramLocalParameterdvARB(_target, _index, _params) ({ \
    glGetProgramLocalParameterdvARB_PACKED *packed_data = malloc(sizeof(glGetProgramLocalParameterdvARB_PACKED)); \
    packed_data->index = glGetProgramLocalParameterdvARB_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.params = (GLdouble *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetProgramLocalParameterdvARB(packed, ret_v) do { \
    PACKED_glGetProgramLocalParameterdvARB *unpacked = (PACKED_glGetProgramLocalParameterdvARB *)packed; \
    ARGS_glGetProgramLocalParameterdvARB *args = (ARGS_glGetProgramLocalParameterdvARB *)&unpacked->args; \
    glGetProgramLocalParameterdvARB(args->target, args->index, args->params);; \
} while(0)
void glGetProgramLocalParameterdvARB(glGetProgramLocalParameterdvARB_ARG_EXPAND);
typedef void (*glGetProgramLocalParameterdvARB_PTR)(glGetProgramLocalParameterdvARB_ARG_EXPAND);
#define glGetProgramLocalParameterfvARB_INDEX 920
#define glGetProgramLocalParameterfvARB_RETURN void
#define glGetProgramLocalParameterfvARB_ARG_NAMES target, index, params
#define glGetProgramLocalParameterfvARB_ARG_EXPAND GLenum target, GLuint index, GLfloat * params
#define glGetProgramLocalParameterfvARB_PACKED PACKED_glGetProgramLocalParameterfvARB
#define glGetProgramLocalParameterfvARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetProgramLocalParameterfvARB_NOT_VOID_WRAP(...) {}
#define pack_glGetProgramLocalParameterfvARB(_target, _index, _params) ({ \
    glGetProgramLocalParameterfvARB_PACKED *packed_data = malloc(sizeof(glGetProgramLocalParameterfvARB_PACKED)); \
    packed_data->index = glGetProgramLocalParameterfvARB_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.params = (GLfloat *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetProgramLocalParameterfvARB(packed, ret_v) do { \
    PACKED_glGetProgramLocalParameterfvARB *unpacked = (PACKED_glGetProgramLocalParameterfvARB *)packed; \
    ARGS_glGetProgramLocalParameterfvARB *args = (ARGS_glGetProgramLocalParameterfvARB *)&unpacked->args; \
    glGetProgramLocalParameterfvARB(args->target, args->index, args->params);; \
} while(0)
void glGetProgramLocalParameterfvARB(glGetProgramLocalParameterfvARB_ARG_EXPAND);
typedef void (*glGetProgramLocalParameterfvARB_PTR)(glGetProgramLocalParameterfvARB_ARG_EXPAND);
#define glGetProgramNamedParameterdvNV_INDEX 921
#define glGetProgramNamedParameterdvNV_RETURN void
#define glGetProgramNamedParameterdvNV_ARG_NAMES id, len, name, params
#define glGetProgramNamedParameterdvNV_ARG_EXPAND GLuint id, GLsizei len, const GLubyte * name, GLdouble * params
#define glGetProgramNamedParameterdvNV_PACKED PACKED_glGetProgramNamedParameterdvNV
#define glGetProgramNamedParameterdvNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetProgramNamedParameterdvNV_NOT_VOID_WRAP(...) {}
#define pack_glGetProgramNamedParameterdvNV(_id, _len, _name, _params) ({ \
    glGetProgramNamedParameterdvNV_PACKED *packed_data = malloc(sizeof(glGetProgramNamedParameterdvNV_PACKED)); \
    packed_data->index = glGetProgramNamedParameterdvNV_INDEX; \
    packed_data->args.id = (GLuint)_id; \
    packed_data->args.len = (GLsizei)_len; \
    packed_data->args.name = (GLubyte *)_name; \
    packed_data->args.params = (GLdouble *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetProgramNamedParameterdvNV(packed, ret_v) do { \
    PACKED_glGetProgramNamedParameterdvNV *unpacked = (PACKED_glGetProgramNamedParameterdvNV *)packed; \
    ARGS_glGetProgramNamedParameterdvNV *args = (ARGS_glGetProgramNamedParameterdvNV *)&unpacked->args; \
    glGetProgramNamedParameterdvNV(args->id, args->len, args->name, args->params);; \
} while(0)
void glGetProgramNamedParameterdvNV(glGetProgramNamedParameterdvNV_ARG_EXPAND);
typedef void (*glGetProgramNamedParameterdvNV_PTR)(glGetProgramNamedParameterdvNV_ARG_EXPAND);
#define glGetProgramNamedParameterfvNV_INDEX 922
#define glGetProgramNamedParameterfvNV_RETURN void
#define glGetProgramNamedParameterfvNV_ARG_NAMES id, len, name, params
#define glGetProgramNamedParameterfvNV_ARG_EXPAND GLuint id, GLsizei len, const GLubyte * name, GLfloat * params
#define glGetProgramNamedParameterfvNV_PACKED PACKED_glGetProgramNamedParameterfvNV
#define glGetProgramNamedParameterfvNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetProgramNamedParameterfvNV_NOT_VOID_WRAP(...) {}
#define pack_glGetProgramNamedParameterfvNV(_id, _len, _name, _params) ({ \
    glGetProgramNamedParameterfvNV_PACKED *packed_data = malloc(sizeof(glGetProgramNamedParameterfvNV_PACKED)); \
    packed_data->index = glGetProgramNamedParameterfvNV_INDEX; \
    packed_data->args.id = (GLuint)_id; \
    packed_data->args.len = (GLsizei)_len; \
    packed_data->args.name = (GLubyte *)_name; \
    packed_data->args.params = (GLfloat *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetProgramNamedParameterfvNV(packed, ret_v) do { \
    PACKED_glGetProgramNamedParameterfvNV *unpacked = (PACKED_glGetProgramNamedParameterfvNV *)packed; \
    ARGS_glGetProgramNamedParameterfvNV *args = (ARGS_glGetProgramNamedParameterfvNV *)&unpacked->args; \
    glGetProgramNamedParameterfvNV(args->id, args->len, args->name, args->params);; \
} while(0)
void glGetProgramNamedParameterfvNV(glGetProgramNamedParameterfvNV_ARG_EXPAND);
typedef void (*glGetProgramNamedParameterfvNV_PTR)(glGetProgramNamedParameterfvNV_ARG_EXPAND);
#define glGetProgramParameterdvNV_INDEX 923
#define glGetProgramParameterdvNV_RETURN void
#define glGetProgramParameterdvNV_ARG_NAMES target, index, pname, params
#define glGetProgramParameterdvNV_ARG_EXPAND GLenum target, GLuint index, GLenum pname, GLdouble * params
#define glGetProgramParameterdvNV_PACKED PACKED_glGetProgramParameterdvNV
#define glGetProgramParameterdvNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetProgramParameterdvNV_NOT_VOID_WRAP(...) {}
#define pack_glGetProgramParameterdvNV(_target, _index, _pname, _params) ({ \
    glGetProgramParameterdvNV_PACKED *packed_data = malloc(sizeof(glGetProgramParameterdvNV_PACKED)); \
    packed_data->index = glGetProgramParameterdvNV_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLdouble *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetProgramParameterdvNV(packed, ret_v) do { \
    PACKED_glGetProgramParameterdvNV *unpacked = (PACKED_glGetProgramParameterdvNV *)packed; \
    ARGS_glGetProgramParameterdvNV *args = (ARGS_glGetProgramParameterdvNV *)&unpacked->args; \
    glGetProgramParameterdvNV(args->target, args->index, args->pname, args->params);; \
} while(0)
void glGetProgramParameterdvNV(glGetProgramParameterdvNV_ARG_EXPAND);
typedef void (*glGetProgramParameterdvNV_PTR)(glGetProgramParameterdvNV_ARG_EXPAND);
#define glGetProgramParameterfvNV_INDEX 924
#define glGetProgramParameterfvNV_RETURN void
#define glGetProgramParameterfvNV_ARG_NAMES target, index, pname, params
#define glGetProgramParameterfvNV_ARG_EXPAND GLenum target, GLuint index, GLenum pname, GLfloat * params
#define glGetProgramParameterfvNV_PACKED PACKED_glGetProgramParameterfvNV
#define glGetProgramParameterfvNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetProgramParameterfvNV_NOT_VOID_WRAP(...) {}
#define pack_glGetProgramParameterfvNV(_target, _index, _pname, _params) ({ \
    glGetProgramParameterfvNV_PACKED *packed_data = malloc(sizeof(glGetProgramParameterfvNV_PACKED)); \
    packed_data->index = glGetProgramParameterfvNV_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLfloat *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetProgramParameterfvNV(packed, ret_v) do { \
    PACKED_glGetProgramParameterfvNV *unpacked = (PACKED_glGetProgramParameterfvNV *)packed; \
    ARGS_glGetProgramParameterfvNV *args = (ARGS_glGetProgramParameterfvNV *)&unpacked->args; \
    glGetProgramParameterfvNV(args->target, args->index, args->pname, args->params);; \
} while(0)
void glGetProgramParameterfvNV(glGetProgramParameterfvNV_ARG_EXPAND);
typedef void (*glGetProgramParameterfvNV_PTR)(glGetProgramParameterfvNV_ARG_EXPAND);
#define glGetProgramPipelineInfoLog_INDEX 925
#define glGetProgramPipelineInfoLog_RETURN void
#define glGetProgramPipelineInfoLog_ARG_NAMES pipeline, bufSize, length, infoLog
#define glGetProgramPipelineInfoLog_ARG_EXPAND GLuint pipeline, GLsizei bufSize, GLsizei * length, GLchar * infoLog
#define glGetProgramPipelineInfoLog_PACKED PACKED_glGetProgramPipelineInfoLog
#define glGetProgramPipelineInfoLog_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetProgramPipelineInfoLog_NOT_VOID_WRAP(...) {}
#define pack_glGetProgramPipelineInfoLog(_pipeline, _bufSize, _length, _infoLog) ({ \
    glGetProgramPipelineInfoLog_PACKED *packed_data = malloc(sizeof(glGetProgramPipelineInfoLog_PACKED)); \
    packed_data->index = glGetProgramPipelineInfoLog_INDEX; \
    packed_data->args.pipeline = (GLuint)_pipeline; \
    packed_data->args.bufSize = (GLsizei)_bufSize; \
    packed_data->args.length = (GLsizei *)_length; \
    packed_data->args.infoLog = (GLchar *)_infoLog; \
    (packed_call_t *)packed_data; \
})
#define call_glGetProgramPipelineInfoLog(packed, ret_v) do { \
    PACKED_glGetProgramPipelineInfoLog *unpacked = (PACKED_glGetProgramPipelineInfoLog *)packed; \
    ARGS_glGetProgramPipelineInfoLog *args = (ARGS_glGetProgramPipelineInfoLog *)&unpacked->args; \
    glGetProgramPipelineInfoLog(args->pipeline, args->bufSize, args->length, args->infoLog);; \
} while(0)
void glGetProgramPipelineInfoLog(glGetProgramPipelineInfoLog_ARG_EXPAND);
typedef void (*glGetProgramPipelineInfoLog_PTR)(glGetProgramPipelineInfoLog_ARG_EXPAND);
#define glGetProgramPipelineiv_INDEX 926
#define glGetProgramPipelineiv_RETURN void
#define glGetProgramPipelineiv_ARG_NAMES pipeline, pname, params
#define glGetProgramPipelineiv_ARG_EXPAND GLuint pipeline, GLenum pname, GLint * params
#define glGetProgramPipelineiv_PACKED PACKED_glGetProgramPipelineiv
#define glGetProgramPipelineiv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetProgramPipelineiv_NOT_VOID_WRAP(...) {}
#define pack_glGetProgramPipelineiv(_pipeline, _pname, _params) ({ \
    glGetProgramPipelineiv_PACKED *packed_data = malloc(sizeof(glGetProgramPipelineiv_PACKED)); \
    packed_data->index = glGetProgramPipelineiv_INDEX; \
    packed_data->args.pipeline = (GLuint)_pipeline; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetProgramPipelineiv(packed, ret_v) do { \
    PACKED_glGetProgramPipelineiv *unpacked = (PACKED_glGetProgramPipelineiv *)packed; \
    ARGS_glGetProgramPipelineiv *args = (ARGS_glGetProgramPipelineiv *)&unpacked->args; \
    glGetProgramPipelineiv(args->pipeline, args->pname, args->params);; \
} while(0)
void glGetProgramPipelineiv(glGetProgramPipelineiv_ARG_EXPAND);
typedef void (*glGetProgramPipelineiv_PTR)(glGetProgramPipelineiv_ARG_EXPAND);
#define glGetProgramResourceIndex_INDEX 927
#define glGetProgramResourceIndex_RETURN GLuint
#define glGetProgramResourceIndex_ARG_NAMES program, programInterface, name
#define glGetProgramResourceIndex_ARG_EXPAND GLuint program, GLenum programInterface, const GLchar * name
#define glGetProgramResourceIndex_PACKED PACKED_glGetProgramResourceIndex
#define glGetProgramResourceIndex_VOID_ONLY_WRAP(...) {}
#define glGetProgramResourceIndex_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glGetProgramResourceIndex(_program, _programInterface, _name) ({ \
    glGetProgramResourceIndex_PACKED *packed_data = malloc(sizeof(glGetProgramResourceIndex_PACKED)); \
    packed_data->index = glGetProgramResourceIndex_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.programInterface = (GLenum)_programInterface; \
    packed_data->args.name = (GLchar *)_name; \
    (packed_call_t *)packed_data; \
})
#define call_glGetProgramResourceIndex(packed, ret_v) do { \
    PACKED_glGetProgramResourceIndex *unpacked = (PACKED_glGetProgramResourceIndex *)packed; \
    ARGS_glGetProgramResourceIndex *args = (ARGS_glGetProgramResourceIndex *)&unpacked->args; \
    GLuint *ret = (GLuint *)ret_v; \
    if (ret != NULL) { \
        *ret = glGetProgramResourceIndex(args->program, args->programInterface, args->name);; \
    } else { \
        glGetProgramResourceIndex(args->program, args->programInterface, args->name);; \
    } \
} while(0)
GLuint glGetProgramResourceIndex(glGetProgramResourceIndex_ARG_EXPAND);
typedef GLuint (*glGetProgramResourceIndex_PTR)(glGetProgramResourceIndex_ARG_EXPAND);
#define glGetProgramResourceLocation_INDEX 928
#define glGetProgramResourceLocation_RETURN GLint
#define glGetProgramResourceLocation_ARG_NAMES program, programInterface, name
#define glGetProgramResourceLocation_ARG_EXPAND GLuint program, GLenum programInterface, const GLchar * name
#define glGetProgramResourceLocation_PACKED PACKED_glGetProgramResourceLocation
#define glGetProgramResourceLocation_VOID_ONLY_WRAP(...) {}
#define glGetProgramResourceLocation_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glGetProgramResourceLocation(_program, _programInterface, _name) ({ \
    glGetProgramResourceLocation_PACKED *packed_data = malloc(sizeof(glGetProgramResourceLocation_PACKED)); \
    packed_data->index = glGetProgramResourceLocation_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.programInterface = (GLenum)_programInterface; \
    packed_data->args.name = (GLchar *)_name; \
    (packed_call_t *)packed_data; \
})
#define call_glGetProgramResourceLocation(packed, ret_v) do { \
    PACKED_glGetProgramResourceLocation *unpacked = (PACKED_glGetProgramResourceLocation *)packed; \
    ARGS_glGetProgramResourceLocation *args = (ARGS_glGetProgramResourceLocation *)&unpacked->args; \
    GLint *ret = (GLint *)ret_v; \
    if (ret != NULL) { \
        *ret = glGetProgramResourceLocation(args->program, args->programInterface, args->name);; \
    } else { \
        glGetProgramResourceLocation(args->program, args->programInterface, args->name);; \
    } \
} while(0)
GLint glGetProgramResourceLocation(glGetProgramResourceLocation_ARG_EXPAND);
typedef GLint (*glGetProgramResourceLocation_PTR)(glGetProgramResourceLocation_ARG_EXPAND);
#define glGetProgramResourceLocationIndex_INDEX 929
#define glGetProgramResourceLocationIndex_RETURN GLint
#define glGetProgramResourceLocationIndex_ARG_NAMES program, programInterface, name
#define glGetProgramResourceLocationIndex_ARG_EXPAND GLuint program, GLenum programInterface, const GLchar * name
#define glGetProgramResourceLocationIndex_PACKED PACKED_glGetProgramResourceLocationIndex
#define glGetProgramResourceLocationIndex_VOID_ONLY_WRAP(...) {}
#define glGetProgramResourceLocationIndex_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glGetProgramResourceLocationIndex(_program, _programInterface, _name) ({ \
    glGetProgramResourceLocationIndex_PACKED *packed_data = malloc(sizeof(glGetProgramResourceLocationIndex_PACKED)); \
    packed_data->index = glGetProgramResourceLocationIndex_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.programInterface = (GLenum)_programInterface; \
    packed_data->args.name = (GLchar *)_name; \
    (packed_call_t *)packed_data; \
})
#define call_glGetProgramResourceLocationIndex(packed, ret_v) do { \
    PACKED_glGetProgramResourceLocationIndex *unpacked = (PACKED_glGetProgramResourceLocationIndex *)packed; \
    ARGS_glGetProgramResourceLocationIndex *args = (ARGS_glGetProgramResourceLocationIndex *)&unpacked->args; \
    GLint *ret = (GLint *)ret_v; \
    if (ret != NULL) { \
        *ret = glGetProgramResourceLocationIndex(args->program, args->programInterface, args->name);; \
    } else { \
        glGetProgramResourceLocationIndex(args->program, args->programInterface, args->name);; \
    } \
} while(0)
GLint glGetProgramResourceLocationIndex(glGetProgramResourceLocationIndex_ARG_EXPAND);
typedef GLint (*glGetProgramResourceLocationIndex_PTR)(glGetProgramResourceLocationIndex_ARG_EXPAND);
#define glGetProgramResourceName_INDEX 930
#define glGetProgramResourceName_RETURN void
#define glGetProgramResourceName_ARG_NAMES program, programInterface, index, bufSize, length, name
#define glGetProgramResourceName_ARG_EXPAND GLuint program, GLenum programInterface, GLuint index, GLsizei bufSize, GLsizei * length, GLchar * name
#define glGetProgramResourceName_PACKED PACKED_glGetProgramResourceName
#define glGetProgramResourceName_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetProgramResourceName_NOT_VOID_WRAP(...) {}
#define pack_glGetProgramResourceName(_program, _programInterface, _index, _bufSize, _length, _name) ({ \
    glGetProgramResourceName_PACKED *packed_data = malloc(sizeof(glGetProgramResourceName_PACKED)); \
    packed_data->index = glGetProgramResourceName_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.programInterface = (GLenum)_programInterface; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.bufSize = (GLsizei)_bufSize; \
    packed_data->args.length = (GLsizei *)_length; \
    packed_data->args.name = (GLchar *)_name; \
    (packed_call_t *)packed_data; \
})
#define call_glGetProgramResourceName(packed, ret_v) do { \
    PACKED_glGetProgramResourceName *unpacked = (PACKED_glGetProgramResourceName *)packed; \
    ARGS_glGetProgramResourceName *args = (ARGS_glGetProgramResourceName *)&unpacked->args; \
    glGetProgramResourceName(args->program, args->programInterface, args->index, args->bufSize, args->length, args->name);; \
} while(0)
void glGetProgramResourceName(glGetProgramResourceName_ARG_EXPAND);
typedef void (*glGetProgramResourceName_PTR)(glGetProgramResourceName_ARG_EXPAND);
#define glGetProgramResourceiv_INDEX 931
#define glGetProgramResourceiv_RETURN void
#define glGetProgramResourceiv_ARG_NAMES program, programInterface, index, propCount, props, bufSize, length, params
#define glGetProgramResourceiv_ARG_EXPAND GLuint program, GLenum programInterface, GLuint index, GLsizei propCount, const GLenum * props, GLsizei bufSize, GLsizei * length, GLint * params
#define glGetProgramResourceiv_PACKED PACKED_glGetProgramResourceiv
#define glGetProgramResourceiv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetProgramResourceiv_NOT_VOID_WRAP(...) {}
#define pack_glGetProgramResourceiv(_program, _programInterface, _index, _propCount, _props, _bufSize, _length, _params) ({ \
    glGetProgramResourceiv_PACKED *packed_data = malloc(sizeof(glGetProgramResourceiv_PACKED)); \
    packed_data->index = glGetProgramResourceiv_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.programInterface = (GLenum)_programInterface; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.propCount = (GLsizei)_propCount; \
    packed_data->args.props = (GLenum *)_props; \
    packed_data->args.bufSize = (GLsizei)_bufSize; \
    packed_data->args.length = (GLsizei *)_length; \
    packed_data->args.params = (GLint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetProgramResourceiv(packed, ret_v) do { \
    PACKED_glGetProgramResourceiv *unpacked = (PACKED_glGetProgramResourceiv *)packed; \
    ARGS_glGetProgramResourceiv *args = (ARGS_glGetProgramResourceiv *)&unpacked->args; \
    glGetProgramResourceiv(args->program, args->programInterface, args->index, args->propCount, args->props, args->bufSize, args->length, args->params);; \
} while(0)
void glGetProgramResourceiv(glGetProgramResourceiv_ARG_EXPAND);
typedef void (*glGetProgramResourceiv_PTR)(glGetProgramResourceiv_ARG_EXPAND);
#define glGetProgramStageiv_INDEX 932
#define glGetProgramStageiv_RETURN void
#define glGetProgramStageiv_ARG_NAMES program, shadertype, pname, values
#define glGetProgramStageiv_ARG_EXPAND GLuint program, GLenum shadertype, GLenum pname, GLint * values
#define glGetProgramStageiv_PACKED PACKED_glGetProgramStageiv
#define glGetProgramStageiv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetProgramStageiv_NOT_VOID_WRAP(...) {}
#define pack_glGetProgramStageiv(_program, _shadertype, _pname, _values) ({ \
    glGetProgramStageiv_PACKED *packed_data = malloc(sizeof(glGetProgramStageiv_PACKED)); \
    packed_data->index = glGetProgramStageiv_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.shadertype = (GLenum)_shadertype; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.values = (GLint *)_values; \
    (packed_call_t *)packed_data; \
})
#define call_glGetProgramStageiv(packed, ret_v) do { \
    PACKED_glGetProgramStageiv *unpacked = (PACKED_glGetProgramStageiv *)packed; \
    ARGS_glGetProgramStageiv *args = (ARGS_glGetProgramStageiv *)&unpacked->args; \
    glGetProgramStageiv(args->program, args->shadertype, args->pname, args->values);; \
} while(0)
void glGetProgramStageiv(glGetProgramStageiv_ARG_EXPAND);
typedef void (*glGetProgramStageiv_PTR)(glGetProgramStageiv_ARG_EXPAND);
#define glGetProgramStringARB_INDEX 933
#define glGetProgramStringARB_RETURN void
#define glGetProgramStringARB_ARG_NAMES target, pname, string
#define glGetProgramStringARB_ARG_EXPAND GLenum target, GLenum pname, GLvoid * string
#define glGetProgramStringARB_PACKED PACKED_glGetProgramStringARB
#define glGetProgramStringARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetProgramStringARB_NOT_VOID_WRAP(...) {}
#define pack_glGetProgramStringARB(_target, _pname, _string) ({ \
    glGetProgramStringARB_PACKED *packed_data = malloc(sizeof(glGetProgramStringARB_PACKED)); \
    packed_data->index = glGetProgramStringARB_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.string = (GLvoid *)_string; \
    (packed_call_t *)packed_data; \
})
#define call_glGetProgramStringARB(packed, ret_v) do { \
    PACKED_glGetProgramStringARB *unpacked = (PACKED_glGetProgramStringARB *)packed; \
    ARGS_glGetProgramStringARB *args = (ARGS_glGetProgramStringARB *)&unpacked->args; \
    glGetProgramStringARB(args->target, args->pname, args->string);; \
} while(0)
void glGetProgramStringARB(glGetProgramStringARB_ARG_EXPAND);
typedef void (*glGetProgramStringARB_PTR)(glGetProgramStringARB_ARG_EXPAND);
#define glGetProgramStringNV_INDEX 934
#define glGetProgramStringNV_RETURN void
#define glGetProgramStringNV_ARG_NAMES id, pname, program
#define glGetProgramStringNV_ARG_EXPAND GLuint id, GLenum pname, GLubyte * program
#define glGetProgramStringNV_PACKED PACKED_glGetProgramStringNV
#define glGetProgramStringNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetProgramStringNV_NOT_VOID_WRAP(...) {}
#define pack_glGetProgramStringNV(_id, _pname, _program) ({ \
    glGetProgramStringNV_PACKED *packed_data = malloc(sizeof(glGetProgramStringNV_PACKED)); \
    packed_data->index = glGetProgramStringNV_INDEX; \
    packed_data->args.id = (GLuint)_id; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.program = (GLubyte *)_program; \
    (packed_call_t *)packed_data; \
})
#define call_glGetProgramStringNV(packed, ret_v) do { \
    PACKED_glGetProgramStringNV *unpacked = (PACKED_glGetProgramStringNV *)packed; \
    ARGS_glGetProgramStringNV *args = (ARGS_glGetProgramStringNV *)&unpacked->args; \
    glGetProgramStringNV(args->id, args->pname, args->program);; \
} while(0)
void glGetProgramStringNV(glGetProgramStringNV_ARG_EXPAND);
typedef void (*glGetProgramStringNV_PTR)(glGetProgramStringNV_ARG_EXPAND);
#define glGetProgramSubroutineParameteruivNV_INDEX 935
#define glGetProgramSubroutineParameteruivNV_RETURN void
#define glGetProgramSubroutineParameteruivNV_ARG_NAMES target, index, param
#define glGetProgramSubroutineParameteruivNV_ARG_EXPAND GLenum target, GLuint index, GLuint * param
#define glGetProgramSubroutineParameteruivNV_PACKED PACKED_glGetProgramSubroutineParameteruivNV
#define glGetProgramSubroutineParameteruivNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetProgramSubroutineParameteruivNV_NOT_VOID_WRAP(...) {}
#define pack_glGetProgramSubroutineParameteruivNV(_target, _index, _param) ({ \
    glGetProgramSubroutineParameteruivNV_PACKED *packed_data = malloc(sizeof(glGetProgramSubroutineParameteruivNV_PACKED)); \
    packed_data->index = glGetProgramSubroutineParameteruivNV_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.param = (GLuint *)_param; \
    (packed_call_t *)packed_data; \
})
#define call_glGetProgramSubroutineParameteruivNV(packed, ret_v) do { \
    PACKED_glGetProgramSubroutineParameteruivNV *unpacked = (PACKED_glGetProgramSubroutineParameteruivNV *)packed; \
    ARGS_glGetProgramSubroutineParameteruivNV *args = (ARGS_glGetProgramSubroutineParameteruivNV *)&unpacked->args; \
    glGetProgramSubroutineParameteruivNV(args->target, args->index, args->param);; \
} while(0)
void glGetProgramSubroutineParameteruivNV(glGetProgramSubroutineParameteruivNV_ARG_EXPAND);
typedef void (*glGetProgramSubroutineParameteruivNV_PTR)(glGetProgramSubroutineParameteruivNV_ARG_EXPAND);
#define glGetProgramiv_INDEX 936
#define glGetProgramiv_RETURN void
#define glGetProgramiv_ARG_NAMES program, pname, params
#define glGetProgramiv_ARG_EXPAND GLuint program, GLenum pname, GLint * params
#define glGetProgramiv_PACKED PACKED_glGetProgramiv
#define glGetProgramiv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetProgramiv_NOT_VOID_WRAP(...) {}
#define pack_glGetProgramiv(_program, _pname, _params) ({ \
    glGetProgramiv_PACKED *packed_data = malloc(sizeof(glGetProgramiv_PACKED)); \
    packed_data->index = glGetProgramiv_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetProgramiv(packed, ret_v) do { \
    PACKED_glGetProgramiv *unpacked = (PACKED_glGetProgramiv *)packed; \
    ARGS_glGetProgramiv *args = (ARGS_glGetProgramiv *)&unpacked->args; \
    glGetProgramiv(args->program, args->pname, args->params);; \
} while(0)
void glGetProgramiv(glGetProgramiv_ARG_EXPAND);
typedef void (*glGetProgramiv_PTR)(glGetProgramiv_ARG_EXPAND);
#define glGetProgramivARB_INDEX 937
#define glGetProgramivARB_RETURN void
#define glGetProgramivARB_ARG_NAMES target, pname, params
#define glGetProgramivARB_ARG_EXPAND GLenum target, GLenum pname, GLint * params
#define glGetProgramivARB_PACKED PACKED_glGetProgramivARB
#define glGetProgramivARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetProgramivARB_NOT_VOID_WRAP(...) {}
#define pack_glGetProgramivARB(_target, _pname, _params) ({ \
    glGetProgramivARB_PACKED *packed_data = malloc(sizeof(glGetProgramivARB_PACKED)); \
    packed_data->index = glGetProgramivARB_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetProgramivARB(packed, ret_v) do { \
    PACKED_glGetProgramivARB *unpacked = (PACKED_glGetProgramivARB *)packed; \
    ARGS_glGetProgramivARB *args = (ARGS_glGetProgramivARB *)&unpacked->args; \
    glGetProgramivARB(args->target, args->pname, args->params);; \
} while(0)
void glGetProgramivARB(glGetProgramivARB_ARG_EXPAND);
typedef void (*glGetProgramivARB_PTR)(glGetProgramivARB_ARG_EXPAND);
#define glGetProgramivNV_INDEX 938
#define glGetProgramivNV_RETURN void
#define glGetProgramivNV_ARG_NAMES id, pname, params
#define glGetProgramivNV_ARG_EXPAND GLuint id, GLenum pname, GLint * params
#define glGetProgramivNV_PACKED PACKED_glGetProgramivNV
#define glGetProgramivNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetProgramivNV_NOT_VOID_WRAP(...) {}
#define pack_glGetProgramivNV(_id, _pname, _params) ({ \
    glGetProgramivNV_PACKED *packed_data = malloc(sizeof(glGetProgramivNV_PACKED)); \
    packed_data->index = glGetProgramivNV_INDEX; \
    packed_data->args.id = (GLuint)_id; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetProgramivNV(packed, ret_v) do { \
    PACKED_glGetProgramivNV *unpacked = (PACKED_glGetProgramivNV *)packed; \
    ARGS_glGetProgramivNV *args = (ARGS_glGetProgramivNV *)&unpacked->args; \
    glGetProgramivNV(args->id, args->pname, args->params);; \
} while(0)
void glGetProgramivNV(glGetProgramivNV_ARG_EXPAND);
typedef void (*glGetProgramivNV_PTR)(glGetProgramivNV_ARG_EXPAND);
#define glGetQueryIndexediv_INDEX 939
#define glGetQueryIndexediv_RETURN void
#define glGetQueryIndexediv_ARG_NAMES target, index, pname, params
#define glGetQueryIndexediv_ARG_EXPAND GLenum target, GLuint index, GLenum pname, GLint * params
#define glGetQueryIndexediv_PACKED PACKED_glGetQueryIndexediv
#define glGetQueryIndexediv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetQueryIndexediv_NOT_VOID_WRAP(...) {}
#define pack_glGetQueryIndexediv(_target, _index, _pname, _params) ({ \
    glGetQueryIndexediv_PACKED *packed_data = malloc(sizeof(glGetQueryIndexediv_PACKED)); \
    packed_data->index = glGetQueryIndexediv_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetQueryIndexediv(packed, ret_v) do { \
    PACKED_glGetQueryIndexediv *unpacked = (PACKED_glGetQueryIndexediv *)packed; \
    ARGS_glGetQueryIndexediv *args = (ARGS_glGetQueryIndexediv *)&unpacked->args; \
    glGetQueryIndexediv(args->target, args->index, args->pname, args->params);; \
} while(0)
void glGetQueryIndexediv(glGetQueryIndexediv_ARG_EXPAND);
typedef void (*glGetQueryIndexediv_PTR)(glGetQueryIndexediv_ARG_EXPAND);
#define glGetQueryObjecti64v_INDEX 940
#define glGetQueryObjecti64v_RETURN void
#define glGetQueryObjecti64v_ARG_NAMES id, pname, params
#define glGetQueryObjecti64v_ARG_EXPAND GLuint id, GLenum pname, GLint64 * params
#define glGetQueryObjecti64v_PACKED PACKED_glGetQueryObjecti64v
#define glGetQueryObjecti64v_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetQueryObjecti64v_NOT_VOID_WRAP(...) {}
#define pack_glGetQueryObjecti64v(_id, _pname, _params) ({ \
    glGetQueryObjecti64v_PACKED *packed_data = malloc(sizeof(glGetQueryObjecti64v_PACKED)); \
    packed_data->index = glGetQueryObjecti64v_INDEX; \
    packed_data->args.id = (GLuint)_id; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLint64 *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetQueryObjecti64v(packed, ret_v) do { \
    PACKED_glGetQueryObjecti64v *unpacked = (PACKED_glGetQueryObjecti64v *)packed; \
    ARGS_glGetQueryObjecti64v *args = (ARGS_glGetQueryObjecti64v *)&unpacked->args; \
    glGetQueryObjecti64v(args->id, args->pname, args->params);; \
} while(0)
void glGetQueryObjecti64v(glGetQueryObjecti64v_ARG_EXPAND);
typedef void (*glGetQueryObjecti64v_PTR)(glGetQueryObjecti64v_ARG_EXPAND);
#define glGetQueryObjecti64vEXT_INDEX 941
#define glGetQueryObjecti64vEXT_RETURN void
#define glGetQueryObjecti64vEXT_ARG_NAMES id, pname, params
#define glGetQueryObjecti64vEXT_ARG_EXPAND GLuint id, GLenum pname, GLint64EXT * params
#define glGetQueryObjecti64vEXT_PACKED PACKED_glGetQueryObjecti64vEXT
#define glGetQueryObjecti64vEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetQueryObjecti64vEXT_NOT_VOID_WRAP(...) {}
#define pack_glGetQueryObjecti64vEXT(_id, _pname, _params) ({ \
    glGetQueryObjecti64vEXT_PACKED *packed_data = malloc(sizeof(glGetQueryObjecti64vEXT_PACKED)); \
    packed_data->index = glGetQueryObjecti64vEXT_INDEX; \
    packed_data->args.id = (GLuint)_id; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLint64EXT *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetQueryObjecti64vEXT(packed, ret_v) do { \
    PACKED_glGetQueryObjecti64vEXT *unpacked = (PACKED_glGetQueryObjecti64vEXT *)packed; \
    ARGS_glGetQueryObjecti64vEXT *args = (ARGS_glGetQueryObjecti64vEXT *)&unpacked->args; \
    glGetQueryObjecti64vEXT(args->id, args->pname, args->params);; \
} while(0)
void glGetQueryObjecti64vEXT(glGetQueryObjecti64vEXT_ARG_EXPAND);
typedef void (*glGetQueryObjecti64vEXT_PTR)(glGetQueryObjecti64vEXT_ARG_EXPAND);
#define glGetQueryObjectiv_INDEX 942
#define glGetQueryObjectiv_RETURN void
#define glGetQueryObjectiv_ARG_NAMES id, pname, params
#define glGetQueryObjectiv_ARG_EXPAND GLuint id, GLenum pname, GLint * params
#define glGetQueryObjectiv_PACKED PACKED_glGetQueryObjectiv
#define glGetQueryObjectiv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetQueryObjectiv_NOT_VOID_WRAP(...) {}
#define pack_glGetQueryObjectiv(_id, _pname, _params) ({ \
    glGetQueryObjectiv_PACKED *packed_data = malloc(sizeof(glGetQueryObjectiv_PACKED)); \
    packed_data->index = glGetQueryObjectiv_INDEX; \
    packed_data->args.id = (GLuint)_id; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetQueryObjectiv(packed, ret_v) do { \
    PACKED_glGetQueryObjectiv *unpacked = (PACKED_glGetQueryObjectiv *)packed; \
    ARGS_glGetQueryObjectiv *args = (ARGS_glGetQueryObjectiv *)&unpacked->args; \
    glGetQueryObjectiv(args->id, args->pname, args->params);; \
} while(0)
void glGetQueryObjectiv(glGetQueryObjectiv_ARG_EXPAND);
typedef void (*glGetQueryObjectiv_PTR)(glGetQueryObjectiv_ARG_EXPAND);
#define glGetQueryObjectivARB_INDEX 943
#define glGetQueryObjectivARB_RETURN void
#define glGetQueryObjectivARB_ARG_NAMES id, pname, params
#define glGetQueryObjectivARB_ARG_EXPAND GLuint id, GLenum pname, GLint * params
#define glGetQueryObjectivARB_PACKED PACKED_glGetQueryObjectivARB
#define glGetQueryObjectivARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetQueryObjectivARB_NOT_VOID_WRAP(...) {}
#define pack_glGetQueryObjectivARB(_id, _pname, _params) ({ \
    glGetQueryObjectivARB_PACKED *packed_data = malloc(sizeof(glGetQueryObjectivARB_PACKED)); \
    packed_data->index = glGetQueryObjectivARB_INDEX; \
    packed_data->args.id = (GLuint)_id; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetQueryObjectivARB(packed, ret_v) do { \
    PACKED_glGetQueryObjectivARB *unpacked = (PACKED_glGetQueryObjectivARB *)packed; \
    ARGS_glGetQueryObjectivARB *args = (ARGS_glGetQueryObjectivARB *)&unpacked->args; \
    glGetQueryObjectivARB(args->id, args->pname, args->params);; \
} while(0)
void glGetQueryObjectivARB(glGetQueryObjectivARB_ARG_EXPAND);
typedef void (*glGetQueryObjectivARB_PTR)(glGetQueryObjectivARB_ARG_EXPAND);
#define glGetQueryObjectui64v_INDEX 944
#define glGetQueryObjectui64v_RETURN void
#define glGetQueryObjectui64v_ARG_NAMES id, pname, params
#define glGetQueryObjectui64v_ARG_EXPAND GLuint id, GLenum pname, GLuint64 * params
#define glGetQueryObjectui64v_PACKED PACKED_glGetQueryObjectui64v
#define glGetQueryObjectui64v_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetQueryObjectui64v_NOT_VOID_WRAP(...) {}
#define pack_glGetQueryObjectui64v(_id, _pname, _params) ({ \
    glGetQueryObjectui64v_PACKED *packed_data = malloc(sizeof(glGetQueryObjectui64v_PACKED)); \
    packed_data->index = glGetQueryObjectui64v_INDEX; \
    packed_data->args.id = (GLuint)_id; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLuint64 *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetQueryObjectui64v(packed, ret_v) do { \
    PACKED_glGetQueryObjectui64v *unpacked = (PACKED_glGetQueryObjectui64v *)packed; \
    ARGS_glGetQueryObjectui64v *args = (ARGS_glGetQueryObjectui64v *)&unpacked->args; \
    glGetQueryObjectui64v(args->id, args->pname, args->params);; \
} while(0)
void glGetQueryObjectui64v(glGetQueryObjectui64v_ARG_EXPAND);
typedef void (*glGetQueryObjectui64v_PTR)(glGetQueryObjectui64v_ARG_EXPAND);
#define glGetQueryObjectui64vEXT_INDEX 945
#define glGetQueryObjectui64vEXT_RETURN void
#define glGetQueryObjectui64vEXT_ARG_NAMES id, pname, params
#define glGetQueryObjectui64vEXT_ARG_EXPAND GLuint id, GLenum pname, GLuint64EXT * params
#define glGetQueryObjectui64vEXT_PACKED PACKED_glGetQueryObjectui64vEXT
#define glGetQueryObjectui64vEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetQueryObjectui64vEXT_NOT_VOID_WRAP(...) {}
#define pack_glGetQueryObjectui64vEXT(_id, _pname, _params) ({ \
    glGetQueryObjectui64vEXT_PACKED *packed_data = malloc(sizeof(glGetQueryObjectui64vEXT_PACKED)); \
    packed_data->index = glGetQueryObjectui64vEXT_INDEX; \
    packed_data->args.id = (GLuint)_id; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLuint64EXT *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetQueryObjectui64vEXT(packed, ret_v) do { \
    PACKED_glGetQueryObjectui64vEXT *unpacked = (PACKED_glGetQueryObjectui64vEXT *)packed; \
    ARGS_glGetQueryObjectui64vEXT *args = (ARGS_glGetQueryObjectui64vEXT *)&unpacked->args; \
    glGetQueryObjectui64vEXT(args->id, args->pname, args->params);; \
} while(0)
void glGetQueryObjectui64vEXT(glGetQueryObjectui64vEXT_ARG_EXPAND);
typedef void (*glGetQueryObjectui64vEXT_PTR)(glGetQueryObjectui64vEXT_ARG_EXPAND);
#define glGetQueryObjectuiv_INDEX 946
#define glGetQueryObjectuiv_RETURN void
#define glGetQueryObjectuiv_ARG_NAMES id, pname, params
#define glGetQueryObjectuiv_ARG_EXPAND GLuint id, GLenum pname, GLuint * params
#define glGetQueryObjectuiv_PACKED PACKED_glGetQueryObjectuiv
#define glGetQueryObjectuiv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetQueryObjectuiv_NOT_VOID_WRAP(...) {}
#define pack_glGetQueryObjectuiv(_id, _pname, _params) ({ \
    glGetQueryObjectuiv_PACKED *packed_data = malloc(sizeof(glGetQueryObjectuiv_PACKED)); \
    packed_data->index = glGetQueryObjectuiv_INDEX; \
    packed_data->args.id = (GLuint)_id; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLuint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetQueryObjectuiv(packed, ret_v) do { \
    PACKED_glGetQueryObjectuiv *unpacked = (PACKED_glGetQueryObjectuiv *)packed; \
    ARGS_glGetQueryObjectuiv *args = (ARGS_glGetQueryObjectuiv *)&unpacked->args; \
    glGetQueryObjectuiv(args->id, args->pname, args->params);; \
} while(0)
void glGetQueryObjectuiv(glGetQueryObjectuiv_ARG_EXPAND);
typedef void (*glGetQueryObjectuiv_PTR)(glGetQueryObjectuiv_ARG_EXPAND);
#define glGetQueryObjectuivARB_INDEX 947
#define glGetQueryObjectuivARB_RETURN void
#define glGetQueryObjectuivARB_ARG_NAMES id, pname, params
#define glGetQueryObjectuivARB_ARG_EXPAND GLuint id, GLenum pname, GLuint * params
#define glGetQueryObjectuivARB_PACKED PACKED_glGetQueryObjectuivARB
#define glGetQueryObjectuivARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetQueryObjectuivARB_NOT_VOID_WRAP(...) {}
#define pack_glGetQueryObjectuivARB(_id, _pname, _params) ({ \
    glGetQueryObjectuivARB_PACKED *packed_data = malloc(sizeof(glGetQueryObjectuivARB_PACKED)); \
    packed_data->index = glGetQueryObjectuivARB_INDEX; \
    packed_data->args.id = (GLuint)_id; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLuint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetQueryObjectuivARB(packed, ret_v) do { \
    PACKED_glGetQueryObjectuivARB *unpacked = (PACKED_glGetQueryObjectuivARB *)packed; \
    ARGS_glGetQueryObjectuivARB *args = (ARGS_glGetQueryObjectuivARB *)&unpacked->args; \
    glGetQueryObjectuivARB(args->id, args->pname, args->params);; \
} while(0)
void glGetQueryObjectuivARB(glGetQueryObjectuivARB_ARG_EXPAND);
typedef void (*glGetQueryObjectuivARB_PTR)(glGetQueryObjectuivARB_ARG_EXPAND);
#define glGetQueryiv_INDEX 948
#define glGetQueryiv_RETURN void
#define glGetQueryiv_ARG_NAMES target, pname, params
#define glGetQueryiv_ARG_EXPAND GLenum target, GLenum pname, GLint * params
#define glGetQueryiv_PACKED PACKED_glGetQueryiv
#define glGetQueryiv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetQueryiv_NOT_VOID_WRAP(...) {}
#define pack_glGetQueryiv(_target, _pname, _params) ({ \
    glGetQueryiv_PACKED *packed_data = malloc(sizeof(glGetQueryiv_PACKED)); \
    packed_data->index = glGetQueryiv_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetQueryiv(packed, ret_v) do { \
    PACKED_glGetQueryiv *unpacked = (PACKED_glGetQueryiv *)packed; \
    ARGS_glGetQueryiv *args = (ARGS_glGetQueryiv *)&unpacked->args; \
    glGetQueryiv(args->target, args->pname, args->params);; \
} while(0)
void glGetQueryiv(glGetQueryiv_ARG_EXPAND);
typedef void (*glGetQueryiv_PTR)(glGetQueryiv_ARG_EXPAND);
#define glGetQueryivARB_INDEX 949
#define glGetQueryivARB_RETURN void
#define glGetQueryivARB_ARG_NAMES target, pname, params
#define glGetQueryivARB_ARG_EXPAND GLenum target, GLenum pname, GLint * params
#define glGetQueryivARB_PACKED PACKED_glGetQueryivARB
#define glGetQueryivARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetQueryivARB_NOT_VOID_WRAP(...) {}
#define pack_glGetQueryivARB(_target, _pname, _params) ({ \
    glGetQueryivARB_PACKED *packed_data = malloc(sizeof(glGetQueryivARB_PACKED)); \
    packed_data->index = glGetQueryivARB_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetQueryivARB(packed, ret_v) do { \
    PACKED_glGetQueryivARB *unpacked = (PACKED_glGetQueryivARB *)packed; \
    ARGS_glGetQueryivARB *args = (ARGS_glGetQueryivARB *)&unpacked->args; \
    glGetQueryivARB(args->target, args->pname, args->params);; \
} while(0)
void glGetQueryivARB(glGetQueryivARB_ARG_EXPAND);
typedef void (*glGetQueryivARB_PTR)(glGetQueryivARB_ARG_EXPAND);
#define glGetRenderbufferParameteriv_INDEX 950
#define glGetRenderbufferParameteriv_RETURN void
#define glGetRenderbufferParameteriv_ARG_NAMES target, pname, params
#define glGetRenderbufferParameteriv_ARG_EXPAND GLenum target, GLenum pname, GLint * params
#define glGetRenderbufferParameteriv_PACKED PACKED_glGetRenderbufferParameteriv
#define glGetRenderbufferParameteriv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetRenderbufferParameteriv_NOT_VOID_WRAP(...) {}
#define pack_glGetRenderbufferParameteriv(_target, _pname, _params) ({ \
    glGetRenderbufferParameteriv_PACKED *packed_data = malloc(sizeof(glGetRenderbufferParameteriv_PACKED)); \
    packed_data->index = glGetRenderbufferParameteriv_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetRenderbufferParameteriv(packed, ret_v) do { \
    PACKED_glGetRenderbufferParameteriv *unpacked = (PACKED_glGetRenderbufferParameteriv *)packed; \
    ARGS_glGetRenderbufferParameteriv *args = (ARGS_glGetRenderbufferParameteriv *)&unpacked->args; \
    glGetRenderbufferParameteriv(args->target, args->pname, args->params);; \
} while(0)
void glGetRenderbufferParameteriv(glGetRenderbufferParameteriv_ARG_EXPAND);
typedef void (*glGetRenderbufferParameteriv_PTR)(glGetRenderbufferParameteriv_ARG_EXPAND);
#define glGetRenderbufferParameterivEXT_INDEX 951
#define glGetRenderbufferParameterivEXT_RETURN void
#define glGetRenderbufferParameterivEXT_ARG_NAMES target, pname, params
#define glGetRenderbufferParameterivEXT_ARG_EXPAND GLenum target, GLenum pname, GLint * params
#define glGetRenderbufferParameterivEXT_PACKED PACKED_glGetRenderbufferParameterivEXT
#define glGetRenderbufferParameterivEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetRenderbufferParameterivEXT_NOT_VOID_WRAP(...) {}
#define pack_glGetRenderbufferParameterivEXT(_target, _pname, _params) ({ \
    glGetRenderbufferParameterivEXT_PACKED *packed_data = malloc(sizeof(glGetRenderbufferParameterivEXT_PACKED)); \
    packed_data->index = glGetRenderbufferParameterivEXT_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetRenderbufferParameterivEXT(packed, ret_v) do { \
    PACKED_glGetRenderbufferParameterivEXT *unpacked = (PACKED_glGetRenderbufferParameterivEXT *)packed; \
    ARGS_glGetRenderbufferParameterivEXT *args = (ARGS_glGetRenderbufferParameterivEXT *)&unpacked->args; \
    glGetRenderbufferParameterivEXT(args->target, args->pname, args->params);; \
} while(0)
void glGetRenderbufferParameterivEXT(glGetRenderbufferParameterivEXT_ARG_EXPAND);
typedef void (*glGetRenderbufferParameterivEXT_PTR)(glGetRenderbufferParameterivEXT_ARG_EXPAND);
#define glGetSamplerParameterIiv_INDEX 952
#define glGetSamplerParameterIiv_RETURN void
#define glGetSamplerParameterIiv_ARG_NAMES sampler, pname, params
#define glGetSamplerParameterIiv_ARG_EXPAND GLuint sampler, GLenum pname, GLint * params
#define glGetSamplerParameterIiv_PACKED PACKED_glGetSamplerParameterIiv
#define glGetSamplerParameterIiv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetSamplerParameterIiv_NOT_VOID_WRAP(...) {}
#define pack_glGetSamplerParameterIiv(_sampler, _pname, _params) ({ \
    glGetSamplerParameterIiv_PACKED *packed_data = malloc(sizeof(glGetSamplerParameterIiv_PACKED)); \
    packed_data->index = glGetSamplerParameterIiv_INDEX; \
    packed_data->args.sampler = (GLuint)_sampler; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetSamplerParameterIiv(packed, ret_v) do { \
    PACKED_glGetSamplerParameterIiv *unpacked = (PACKED_glGetSamplerParameterIiv *)packed; \
    ARGS_glGetSamplerParameterIiv *args = (ARGS_glGetSamplerParameterIiv *)&unpacked->args; \
    glGetSamplerParameterIiv(args->sampler, args->pname, args->params);; \
} while(0)
void glGetSamplerParameterIiv(glGetSamplerParameterIiv_ARG_EXPAND);
typedef void (*glGetSamplerParameterIiv_PTR)(glGetSamplerParameterIiv_ARG_EXPAND);
#define glGetSamplerParameterIuiv_INDEX 953
#define glGetSamplerParameterIuiv_RETURN void
#define glGetSamplerParameterIuiv_ARG_NAMES sampler, pname, params
#define glGetSamplerParameterIuiv_ARG_EXPAND GLuint sampler, GLenum pname, GLuint * params
#define glGetSamplerParameterIuiv_PACKED PACKED_glGetSamplerParameterIuiv
#define glGetSamplerParameterIuiv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetSamplerParameterIuiv_NOT_VOID_WRAP(...) {}
#define pack_glGetSamplerParameterIuiv(_sampler, _pname, _params) ({ \
    glGetSamplerParameterIuiv_PACKED *packed_data = malloc(sizeof(glGetSamplerParameterIuiv_PACKED)); \
    packed_data->index = glGetSamplerParameterIuiv_INDEX; \
    packed_data->args.sampler = (GLuint)_sampler; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLuint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetSamplerParameterIuiv(packed, ret_v) do { \
    PACKED_glGetSamplerParameterIuiv *unpacked = (PACKED_glGetSamplerParameterIuiv *)packed; \
    ARGS_glGetSamplerParameterIuiv *args = (ARGS_glGetSamplerParameterIuiv *)&unpacked->args; \
    glGetSamplerParameterIuiv(args->sampler, args->pname, args->params);; \
} while(0)
void glGetSamplerParameterIuiv(glGetSamplerParameterIuiv_ARG_EXPAND);
typedef void (*glGetSamplerParameterIuiv_PTR)(glGetSamplerParameterIuiv_ARG_EXPAND);
#define glGetSamplerParameterfv_INDEX 954
#define glGetSamplerParameterfv_RETURN void
#define glGetSamplerParameterfv_ARG_NAMES sampler, pname, params
#define glGetSamplerParameterfv_ARG_EXPAND GLuint sampler, GLenum pname, GLfloat * params
#define glGetSamplerParameterfv_PACKED PACKED_glGetSamplerParameterfv
#define glGetSamplerParameterfv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetSamplerParameterfv_NOT_VOID_WRAP(...) {}
#define pack_glGetSamplerParameterfv(_sampler, _pname, _params) ({ \
    glGetSamplerParameterfv_PACKED *packed_data = malloc(sizeof(glGetSamplerParameterfv_PACKED)); \
    packed_data->index = glGetSamplerParameterfv_INDEX; \
    packed_data->args.sampler = (GLuint)_sampler; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLfloat *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetSamplerParameterfv(packed, ret_v) do { \
    PACKED_glGetSamplerParameterfv *unpacked = (PACKED_glGetSamplerParameterfv *)packed; \
    ARGS_glGetSamplerParameterfv *args = (ARGS_glGetSamplerParameterfv *)&unpacked->args; \
    glGetSamplerParameterfv(args->sampler, args->pname, args->params);; \
} while(0)
void glGetSamplerParameterfv(glGetSamplerParameterfv_ARG_EXPAND);
typedef void (*glGetSamplerParameterfv_PTR)(glGetSamplerParameterfv_ARG_EXPAND);
#define glGetSamplerParameteriv_INDEX 955
#define glGetSamplerParameteriv_RETURN void
#define glGetSamplerParameteriv_ARG_NAMES sampler, pname, params
#define glGetSamplerParameteriv_ARG_EXPAND GLuint sampler, GLenum pname, GLint * params
#define glGetSamplerParameteriv_PACKED PACKED_glGetSamplerParameteriv
#define glGetSamplerParameteriv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetSamplerParameteriv_NOT_VOID_WRAP(...) {}
#define pack_glGetSamplerParameteriv(_sampler, _pname, _params) ({ \
    glGetSamplerParameteriv_PACKED *packed_data = malloc(sizeof(glGetSamplerParameteriv_PACKED)); \
    packed_data->index = glGetSamplerParameteriv_INDEX; \
    packed_data->args.sampler = (GLuint)_sampler; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetSamplerParameteriv(packed, ret_v) do { \
    PACKED_glGetSamplerParameteriv *unpacked = (PACKED_glGetSamplerParameteriv *)packed; \
    ARGS_glGetSamplerParameteriv *args = (ARGS_glGetSamplerParameteriv *)&unpacked->args; \
    glGetSamplerParameteriv(args->sampler, args->pname, args->params);; \
} while(0)
void glGetSamplerParameteriv(glGetSamplerParameteriv_ARG_EXPAND);
typedef void (*glGetSamplerParameteriv_PTR)(glGetSamplerParameteriv_ARG_EXPAND);
#define glGetSeparableFilter_INDEX 956
#define glGetSeparableFilter_RETURN void
#define glGetSeparableFilter_ARG_NAMES target, format, type, row, column, span
#define glGetSeparableFilter_ARG_EXPAND GLenum target, GLenum format, GLenum type, GLvoid * row, GLvoid * column, GLvoid * span
#define glGetSeparableFilter_PACKED PACKED_glGetSeparableFilter
#define glGetSeparableFilter_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetSeparableFilter_NOT_VOID_WRAP(...) {}
#define pack_glGetSeparableFilter(_target, _format, _type, _row, _column, _span) ({ \
    glGetSeparableFilter_PACKED *packed_data = malloc(sizeof(glGetSeparableFilter_PACKED)); \
    packed_data->index = glGetSeparableFilter_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.format = (GLenum)_format; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.row = (GLvoid *)_row; \
    packed_data->args.column = (GLvoid *)_column; \
    packed_data->args.span = (GLvoid *)_span; \
    (packed_call_t *)packed_data; \
})
#define call_glGetSeparableFilter(packed, ret_v) do { \
    PACKED_glGetSeparableFilter *unpacked = (PACKED_glGetSeparableFilter *)packed; \
    ARGS_glGetSeparableFilter *args = (ARGS_glGetSeparableFilter *)&unpacked->args; \
    glGetSeparableFilter(args->target, args->format, args->type, args->row, args->column, args->span);; \
} while(0)
void glGetSeparableFilter(glGetSeparableFilter_ARG_EXPAND);
typedef void (*glGetSeparableFilter_PTR)(glGetSeparableFilter_ARG_EXPAND);
#define glGetSeparableFilterEXT_INDEX 957
#define glGetSeparableFilterEXT_RETURN void
#define glGetSeparableFilterEXT_ARG_NAMES target, format, type, row, column, span
#define glGetSeparableFilterEXT_ARG_EXPAND GLenum target, GLenum format, GLenum type, GLvoid * row, GLvoid * column, GLvoid * span
#define glGetSeparableFilterEXT_PACKED PACKED_glGetSeparableFilterEXT
#define glGetSeparableFilterEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetSeparableFilterEXT_NOT_VOID_WRAP(...) {}
#define pack_glGetSeparableFilterEXT(_target, _format, _type, _row, _column, _span) ({ \
    glGetSeparableFilterEXT_PACKED *packed_data = malloc(sizeof(glGetSeparableFilterEXT_PACKED)); \
    packed_data->index = glGetSeparableFilterEXT_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.format = (GLenum)_format; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.row = (GLvoid *)_row; \
    packed_data->args.column = (GLvoid *)_column; \
    packed_data->args.span = (GLvoid *)_span; \
    (packed_call_t *)packed_data; \
})
#define call_glGetSeparableFilterEXT(packed, ret_v) do { \
    PACKED_glGetSeparableFilterEXT *unpacked = (PACKED_glGetSeparableFilterEXT *)packed; \
    ARGS_glGetSeparableFilterEXT *args = (ARGS_glGetSeparableFilterEXT *)&unpacked->args; \
    glGetSeparableFilterEXT(args->target, args->format, args->type, args->row, args->column, args->span);; \
} while(0)
void glGetSeparableFilterEXT(glGetSeparableFilterEXT_ARG_EXPAND);
typedef void (*glGetSeparableFilterEXT_PTR)(glGetSeparableFilterEXT_ARG_EXPAND);
#define glGetShaderInfoLog_INDEX 958
#define glGetShaderInfoLog_RETURN void
#define glGetShaderInfoLog_ARG_NAMES shader, bufSize, length, infoLog
#define glGetShaderInfoLog_ARG_EXPAND GLuint shader, GLsizei bufSize, GLsizei * length, GLchar * infoLog
#define glGetShaderInfoLog_PACKED PACKED_glGetShaderInfoLog
#define glGetShaderInfoLog_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetShaderInfoLog_NOT_VOID_WRAP(...) {}
#define pack_glGetShaderInfoLog(_shader, _bufSize, _length, _infoLog) ({ \
    glGetShaderInfoLog_PACKED *packed_data = malloc(sizeof(glGetShaderInfoLog_PACKED)); \
    packed_data->index = glGetShaderInfoLog_INDEX; \
    packed_data->args.shader = (GLuint)_shader; \
    packed_data->args.bufSize = (GLsizei)_bufSize; \
    packed_data->args.length = (GLsizei *)_length; \
    packed_data->args.infoLog = (GLchar *)_infoLog; \
    (packed_call_t *)packed_data; \
})
#define call_glGetShaderInfoLog(packed, ret_v) do { \
    PACKED_glGetShaderInfoLog *unpacked = (PACKED_glGetShaderInfoLog *)packed; \
    ARGS_glGetShaderInfoLog *args = (ARGS_glGetShaderInfoLog *)&unpacked->args; \
    glGetShaderInfoLog(args->shader, args->bufSize, args->length, args->infoLog);; \
} while(0)
void glGetShaderInfoLog(glGetShaderInfoLog_ARG_EXPAND);
typedef void (*glGetShaderInfoLog_PTR)(glGetShaderInfoLog_ARG_EXPAND);
#define glGetShaderPrecisionFormat_INDEX 959
#define glGetShaderPrecisionFormat_RETURN void
#define glGetShaderPrecisionFormat_ARG_NAMES shadertype, precisiontype, range, precision
#define glGetShaderPrecisionFormat_ARG_EXPAND GLenum shadertype, GLenum precisiontype, GLint * range, GLint * precision
#define glGetShaderPrecisionFormat_PACKED PACKED_glGetShaderPrecisionFormat
#define glGetShaderPrecisionFormat_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetShaderPrecisionFormat_NOT_VOID_WRAP(...) {}
#define pack_glGetShaderPrecisionFormat(_shadertype, _precisiontype, _range, _precision) ({ \
    glGetShaderPrecisionFormat_PACKED *packed_data = malloc(sizeof(glGetShaderPrecisionFormat_PACKED)); \
    packed_data->index = glGetShaderPrecisionFormat_INDEX; \
    packed_data->args.shadertype = (GLenum)_shadertype; \
    packed_data->args.precisiontype = (GLenum)_precisiontype; \
    packed_data->args.range = (GLint *)_range; \
    packed_data->args.precision = (GLint *)_precision; \
    (packed_call_t *)packed_data; \
})
#define call_glGetShaderPrecisionFormat(packed, ret_v) do { \
    PACKED_glGetShaderPrecisionFormat *unpacked = (PACKED_glGetShaderPrecisionFormat *)packed; \
    ARGS_glGetShaderPrecisionFormat *args = (ARGS_glGetShaderPrecisionFormat *)&unpacked->args; \
    glGetShaderPrecisionFormat(args->shadertype, args->precisiontype, args->range, args->precision);; \
} while(0)
void glGetShaderPrecisionFormat(glGetShaderPrecisionFormat_ARG_EXPAND);
typedef void (*glGetShaderPrecisionFormat_PTR)(glGetShaderPrecisionFormat_ARG_EXPAND);
#define glGetShaderSource_INDEX 960
#define glGetShaderSource_RETURN void
#define glGetShaderSource_ARG_NAMES shader, bufSize, length, source
#define glGetShaderSource_ARG_EXPAND GLuint shader, GLsizei bufSize, GLsizei * length, GLchar * source
#define glGetShaderSource_PACKED PACKED_glGetShaderSource
#define glGetShaderSource_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetShaderSource_NOT_VOID_WRAP(...) {}
#define pack_glGetShaderSource(_shader, _bufSize, _length, _source) ({ \
    glGetShaderSource_PACKED *packed_data = malloc(sizeof(glGetShaderSource_PACKED)); \
    packed_data->index = glGetShaderSource_INDEX; \
    packed_data->args.shader = (GLuint)_shader; \
    packed_data->args.bufSize = (GLsizei)_bufSize; \
    packed_data->args.length = (GLsizei *)_length; \
    packed_data->args.source = (GLchar *)_source; \
    (packed_call_t *)packed_data; \
})
#define call_glGetShaderSource(packed, ret_v) do { \
    PACKED_glGetShaderSource *unpacked = (PACKED_glGetShaderSource *)packed; \
    ARGS_glGetShaderSource *args = (ARGS_glGetShaderSource *)&unpacked->args; \
    glGetShaderSource(args->shader, args->bufSize, args->length, args->source);; \
} while(0)
void glGetShaderSource(glGetShaderSource_ARG_EXPAND);
typedef void (*glGetShaderSource_PTR)(glGetShaderSource_ARG_EXPAND);
#define glGetShaderSourceARB_INDEX 961
#define glGetShaderSourceARB_RETURN void
#define glGetShaderSourceARB_ARG_NAMES obj, maxLength, length, source
#define glGetShaderSourceARB_ARG_EXPAND GLhandleARB obj, GLsizei maxLength, GLsizei * length, GLcharARB * source
#define glGetShaderSourceARB_PACKED PACKED_glGetShaderSourceARB
#define glGetShaderSourceARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetShaderSourceARB_NOT_VOID_WRAP(...) {}
#define pack_glGetShaderSourceARB(_obj, _maxLength, _length, _source) ({ \
    glGetShaderSourceARB_PACKED *packed_data = malloc(sizeof(glGetShaderSourceARB_PACKED)); \
    packed_data->index = glGetShaderSourceARB_INDEX; \
    packed_data->args.obj = (GLhandleARB)_obj; \
    packed_data->args.maxLength = (GLsizei)_maxLength; \
    packed_data->args.length = (GLsizei *)_length; \
    packed_data->args.source = (GLcharARB *)_source; \
    (packed_call_t *)packed_data; \
})
#define call_glGetShaderSourceARB(packed, ret_v) do { \
    PACKED_glGetShaderSourceARB *unpacked = (PACKED_glGetShaderSourceARB *)packed; \
    ARGS_glGetShaderSourceARB *args = (ARGS_glGetShaderSourceARB *)&unpacked->args; \
    glGetShaderSourceARB(args->obj, args->maxLength, args->length, args->source);; \
} while(0)
void glGetShaderSourceARB(glGetShaderSourceARB_ARG_EXPAND);
typedef void (*glGetShaderSourceARB_PTR)(glGetShaderSourceARB_ARG_EXPAND);
#define glGetShaderiv_INDEX 962
#define glGetShaderiv_RETURN void
#define glGetShaderiv_ARG_NAMES shader, pname, params
#define glGetShaderiv_ARG_EXPAND GLuint shader, GLenum pname, GLint * params
#define glGetShaderiv_PACKED PACKED_glGetShaderiv
#define glGetShaderiv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetShaderiv_NOT_VOID_WRAP(...) {}
#define pack_glGetShaderiv(_shader, _pname, _params) ({ \
    glGetShaderiv_PACKED *packed_data = malloc(sizeof(glGetShaderiv_PACKED)); \
    packed_data->index = glGetShaderiv_INDEX; \
    packed_data->args.shader = (GLuint)_shader; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetShaderiv(packed, ret_v) do { \
    PACKED_glGetShaderiv *unpacked = (PACKED_glGetShaderiv *)packed; \
    ARGS_glGetShaderiv *args = (ARGS_glGetShaderiv *)&unpacked->args; \
    glGetShaderiv(args->shader, args->pname, args->params);; \
} while(0)
void glGetShaderiv(glGetShaderiv_ARG_EXPAND);
typedef void (*glGetShaderiv_PTR)(glGetShaderiv_ARG_EXPAND);
#define glGetSharpenTexFuncSGIS_INDEX 963
#define glGetSharpenTexFuncSGIS_RETURN void
#define glGetSharpenTexFuncSGIS_ARG_NAMES target, points
#define glGetSharpenTexFuncSGIS_ARG_EXPAND GLenum target, GLfloat * points
#define glGetSharpenTexFuncSGIS_PACKED PACKED_glGetSharpenTexFuncSGIS
#define glGetSharpenTexFuncSGIS_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetSharpenTexFuncSGIS_NOT_VOID_WRAP(...) {}
#define pack_glGetSharpenTexFuncSGIS(_target, _points) ({ \
    glGetSharpenTexFuncSGIS_PACKED *packed_data = malloc(sizeof(glGetSharpenTexFuncSGIS_PACKED)); \
    packed_data->index = glGetSharpenTexFuncSGIS_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.points = (GLfloat *)_points; \
    (packed_call_t *)packed_data; \
})
#define call_glGetSharpenTexFuncSGIS(packed, ret_v) do { \
    PACKED_glGetSharpenTexFuncSGIS *unpacked = (PACKED_glGetSharpenTexFuncSGIS *)packed; \
    ARGS_glGetSharpenTexFuncSGIS *args = (ARGS_glGetSharpenTexFuncSGIS *)&unpacked->args; \
    glGetSharpenTexFuncSGIS(args->target, args->points);; \
} while(0)
void glGetSharpenTexFuncSGIS(glGetSharpenTexFuncSGIS_ARG_EXPAND);
typedef void (*glGetSharpenTexFuncSGIS_PTR)(glGetSharpenTexFuncSGIS_ARG_EXPAND);
#define glGetString_INDEX 964
#define glGetString_RETURN const GLubyte *
#define glGetString_ARG_NAMES name
#define glGetString_ARG_EXPAND GLenum name
#define glGetString_PACKED PACKED_glGetString
#define glGetString_VOID_ONLY_WRAP(...) {}
#define glGetString_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glGetString(_name) ({ \
    glGetString_PACKED *packed_data = malloc(sizeof(glGetString_PACKED)); \
    packed_data->index = glGetString_INDEX; \
    packed_data->args.name = (GLenum)_name; \
    (packed_call_t *)packed_data; \
})
#define call_glGetString(packed, ret_v) do { \
    PACKED_glGetString *unpacked = (PACKED_glGetString *)packed; \
    ARGS_glGetString *args = (ARGS_glGetString *)&unpacked->args; \
    const GLubyte * *ret = (const GLubyte * *)ret_v; \
    if (ret != NULL) { \
        *ret = glGetString(args->name);; \
    } else { \
        glGetString(args->name);; \
    } \
} while(0)
const GLubyte * glGetString(glGetString_ARG_EXPAND);
typedef const GLubyte * (*glGetString_PTR)(glGetString_ARG_EXPAND);
#define glGetStringi_INDEX 965
#define glGetStringi_RETURN const GLubyte *
#define glGetStringi_ARG_NAMES name, index
#define glGetStringi_ARG_EXPAND GLenum name, GLuint index
#define glGetStringi_PACKED PACKED_glGetStringi
#define glGetStringi_VOID_ONLY_WRAP(...) {}
#define glGetStringi_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glGetStringi(_name, _index) ({ \
    glGetStringi_PACKED *packed_data = malloc(sizeof(glGetStringi_PACKED)); \
    packed_data->index = glGetStringi_INDEX; \
    packed_data->args.name = (GLenum)_name; \
    packed_data->args.index = (GLuint)_index; \
    (packed_call_t *)packed_data; \
})
#define call_glGetStringi(packed, ret_v) do { \
    PACKED_glGetStringi *unpacked = (PACKED_glGetStringi *)packed; \
    ARGS_glGetStringi *args = (ARGS_glGetStringi *)&unpacked->args; \
    const GLubyte * *ret = (const GLubyte * *)ret_v; \
    if (ret != NULL) { \
        *ret = glGetStringi(args->name, args->index);; \
    } else { \
        glGetStringi(args->name, args->index);; \
    } \
} while(0)
const GLubyte * glGetStringi(glGetStringi_ARG_EXPAND);
typedef const GLubyte * (*glGetStringi_PTR)(glGetStringi_ARG_EXPAND);
#define glGetSubroutineIndex_INDEX 966
#define glGetSubroutineIndex_RETURN GLuint
#define glGetSubroutineIndex_ARG_NAMES program, shadertype, name
#define glGetSubroutineIndex_ARG_EXPAND GLuint program, GLenum shadertype, const GLchar * name
#define glGetSubroutineIndex_PACKED PACKED_glGetSubroutineIndex
#define glGetSubroutineIndex_VOID_ONLY_WRAP(...) {}
#define glGetSubroutineIndex_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glGetSubroutineIndex(_program, _shadertype, _name) ({ \
    glGetSubroutineIndex_PACKED *packed_data = malloc(sizeof(glGetSubroutineIndex_PACKED)); \
    packed_data->index = glGetSubroutineIndex_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.shadertype = (GLenum)_shadertype; \
    packed_data->args.name = (GLchar *)_name; \
    (packed_call_t *)packed_data; \
})
#define call_glGetSubroutineIndex(packed, ret_v) do { \
    PACKED_glGetSubroutineIndex *unpacked = (PACKED_glGetSubroutineIndex *)packed; \
    ARGS_glGetSubroutineIndex *args = (ARGS_glGetSubroutineIndex *)&unpacked->args; \
    GLuint *ret = (GLuint *)ret_v; \
    if (ret != NULL) { \
        *ret = glGetSubroutineIndex(args->program, args->shadertype, args->name);; \
    } else { \
        glGetSubroutineIndex(args->program, args->shadertype, args->name);; \
    } \
} while(0)
GLuint glGetSubroutineIndex(glGetSubroutineIndex_ARG_EXPAND);
typedef GLuint (*glGetSubroutineIndex_PTR)(glGetSubroutineIndex_ARG_EXPAND);
#define glGetSubroutineUniformLocation_INDEX 967
#define glGetSubroutineUniformLocation_RETURN GLint
#define glGetSubroutineUniformLocation_ARG_NAMES program, shadertype, name
#define glGetSubroutineUniformLocation_ARG_EXPAND GLuint program, GLenum shadertype, const GLchar * name
#define glGetSubroutineUniformLocation_PACKED PACKED_glGetSubroutineUniformLocation
#define glGetSubroutineUniformLocation_VOID_ONLY_WRAP(...) {}
#define glGetSubroutineUniformLocation_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glGetSubroutineUniformLocation(_program, _shadertype, _name) ({ \
    glGetSubroutineUniformLocation_PACKED *packed_data = malloc(sizeof(glGetSubroutineUniformLocation_PACKED)); \
    packed_data->index = glGetSubroutineUniformLocation_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.shadertype = (GLenum)_shadertype; \
    packed_data->args.name = (GLchar *)_name; \
    (packed_call_t *)packed_data; \
})
#define call_glGetSubroutineUniformLocation(packed, ret_v) do { \
    PACKED_glGetSubroutineUniformLocation *unpacked = (PACKED_glGetSubroutineUniformLocation *)packed; \
    ARGS_glGetSubroutineUniformLocation *args = (ARGS_glGetSubroutineUniformLocation *)&unpacked->args; \
    GLint *ret = (GLint *)ret_v; \
    if (ret != NULL) { \
        *ret = glGetSubroutineUniformLocation(args->program, args->shadertype, args->name);; \
    } else { \
        glGetSubroutineUniformLocation(args->program, args->shadertype, args->name);; \
    } \
} while(0)
GLint glGetSubroutineUniformLocation(glGetSubroutineUniformLocation_ARG_EXPAND);
typedef GLint (*glGetSubroutineUniformLocation_PTR)(glGetSubroutineUniformLocation_ARG_EXPAND);
#define glGetSynciv_INDEX 968
#define glGetSynciv_RETURN void
#define glGetSynciv_ARG_NAMES sync, pname, bufSize, length, values
#define glGetSynciv_ARG_EXPAND GLsync sync, GLenum pname, GLsizei bufSize, GLsizei * length, GLint * values
#define glGetSynciv_PACKED PACKED_glGetSynciv
#define glGetSynciv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetSynciv_NOT_VOID_WRAP(...) {}
#define pack_glGetSynciv(_sync, _pname, _bufSize, _length, _values) ({ \
    glGetSynciv_PACKED *packed_data = malloc(sizeof(glGetSynciv_PACKED)); \
    packed_data->index = glGetSynciv_INDEX; \
    packed_data->args.sync = (GLsync)_sync; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.bufSize = (GLsizei)_bufSize; \
    packed_data->args.length = (GLsizei *)_length; \
    packed_data->args.values = (GLint *)_values; \
    (packed_call_t *)packed_data; \
})
#define call_glGetSynciv(packed, ret_v) do { \
    PACKED_glGetSynciv *unpacked = (PACKED_glGetSynciv *)packed; \
    ARGS_glGetSynciv *args = (ARGS_glGetSynciv *)&unpacked->args; \
    glGetSynciv(args->sync, args->pname, args->bufSize, args->length, args->values);; \
} while(0)
void glGetSynciv(glGetSynciv_ARG_EXPAND);
typedef void (*glGetSynciv_PTR)(glGetSynciv_ARG_EXPAND);
#define glGetTexBumpParameterfvATI_INDEX 969
#define glGetTexBumpParameterfvATI_RETURN void
#define glGetTexBumpParameterfvATI_ARG_NAMES pname, param
#define glGetTexBumpParameterfvATI_ARG_EXPAND GLenum pname, GLfloat * param
#define glGetTexBumpParameterfvATI_PACKED PACKED_glGetTexBumpParameterfvATI
#define glGetTexBumpParameterfvATI_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetTexBumpParameterfvATI_NOT_VOID_WRAP(...) {}
#define pack_glGetTexBumpParameterfvATI(_pname, _param) ({ \
    glGetTexBumpParameterfvATI_PACKED *packed_data = malloc(sizeof(glGetTexBumpParameterfvATI_PACKED)); \
    packed_data->index = glGetTexBumpParameterfvATI_INDEX; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.param = (GLfloat *)_param; \
    (packed_call_t *)packed_data; \
})
#define call_glGetTexBumpParameterfvATI(packed, ret_v) do { \
    PACKED_glGetTexBumpParameterfvATI *unpacked = (PACKED_glGetTexBumpParameterfvATI *)packed; \
    ARGS_glGetTexBumpParameterfvATI *args = (ARGS_glGetTexBumpParameterfvATI *)&unpacked->args; \
    glGetTexBumpParameterfvATI(args->pname, args->param);; \
} while(0)
void glGetTexBumpParameterfvATI(glGetTexBumpParameterfvATI_ARG_EXPAND);
typedef void (*glGetTexBumpParameterfvATI_PTR)(glGetTexBumpParameterfvATI_ARG_EXPAND);
#define glGetTexBumpParameterivATI_INDEX 970
#define glGetTexBumpParameterivATI_RETURN void
#define glGetTexBumpParameterivATI_ARG_NAMES pname, param
#define glGetTexBumpParameterivATI_ARG_EXPAND GLenum pname, GLint * param
#define glGetTexBumpParameterivATI_PACKED PACKED_glGetTexBumpParameterivATI
#define glGetTexBumpParameterivATI_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetTexBumpParameterivATI_NOT_VOID_WRAP(...) {}
#define pack_glGetTexBumpParameterivATI(_pname, _param) ({ \
    glGetTexBumpParameterivATI_PACKED *packed_data = malloc(sizeof(glGetTexBumpParameterivATI_PACKED)); \
    packed_data->index = glGetTexBumpParameterivATI_INDEX; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.param = (GLint *)_param; \
    (packed_call_t *)packed_data; \
})
#define call_glGetTexBumpParameterivATI(packed, ret_v) do { \
    PACKED_glGetTexBumpParameterivATI *unpacked = (PACKED_glGetTexBumpParameterivATI *)packed; \
    ARGS_glGetTexBumpParameterivATI *args = (ARGS_glGetTexBumpParameterivATI *)&unpacked->args; \
    glGetTexBumpParameterivATI(args->pname, args->param);; \
} while(0)
void glGetTexBumpParameterivATI(glGetTexBumpParameterivATI_ARG_EXPAND);
typedef void (*glGetTexBumpParameterivATI_PTR)(glGetTexBumpParameterivATI_ARG_EXPAND);
#define glGetTexEnvfv_INDEX 971
#define glGetTexEnvfv_RETURN void
#define glGetTexEnvfv_ARG_NAMES target, pname, params
#define glGetTexEnvfv_ARG_EXPAND GLenum target, GLenum pname, GLfloat * params
#define glGetTexEnvfv_PACKED PACKED_glGetTexEnvfv
#define glGetTexEnvfv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetTexEnvfv_NOT_VOID_WRAP(...) {}
#define pack_glGetTexEnvfv(_target, _pname, _params) ({ \
    glGetTexEnvfv_PACKED *packed_data = malloc(sizeof(glGetTexEnvfv_PACKED)); \
    packed_data->index = glGetTexEnvfv_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLfloat *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetTexEnvfv(packed, ret_v) do { \
    PACKED_glGetTexEnvfv *unpacked = (PACKED_glGetTexEnvfv *)packed; \
    ARGS_glGetTexEnvfv *args = (ARGS_glGetTexEnvfv *)&unpacked->args; \
    glGetTexEnvfv(args->target, args->pname, args->params);; \
} while(0)
void glGetTexEnvfv(glGetTexEnvfv_ARG_EXPAND);
typedef void (*glGetTexEnvfv_PTR)(glGetTexEnvfv_ARG_EXPAND);
#define glGetTexEnviv_INDEX 972
#define glGetTexEnviv_RETURN void
#define glGetTexEnviv_ARG_NAMES target, pname, params
#define glGetTexEnviv_ARG_EXPAND GLenum target, GLenum pname, GLint * params
#define glGetTexEnviv_PACKED PACKED_glGetTexEnviv
#define glGetTexEnviv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetTexEnviv_NOT_VOID_WRAP(...) {}
#define pack_glGetTexEnviv(_target, _pname, _params) ({ \
    glGetTexEnviv_PACKED *packed_data = malloc(sizeof(glGetTexEnviv_PACKED)); \
    packed_data->index = glGetTexEnviv_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetTexEnviv(packed, ret_v) do { \
    PACKED_glGetTexEnviv *unpacked = (PACKED_glGetTexEnviv *)packed; \
    ARGS_glGetTexEnviv *args = (ARGS_glGetTexEnviv *)&unpacked->args; \
    glGetTexEnviv(args->target, args->pname, args->params);; \
} while(0)
void glGetTexEnviv(glGetTexEnviv_ARG_EXPAND);
typedef void (*glGetTexEnviv_PTR)(glGetTexEnviv_ARG_EXPAND);
#define glGetTexEnvxv_INDEX 973
#define glGetTexEnvxv_RETURN void
#define glGetTexEnvxv_ARG_NAMES target, pname, params
#define glGetTexEnvxv_ARG_EXPAND GLenum target, GLenum pname, GLfixed * params
#define glGetTexEnvxv_PACKED PACKED_glGetTexEnvxv
#define glGetTexEnvxv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetTexEnvxv_NOT_VOID_WRAP(...) {}
#define pack_glGetTexEnvxv(_target, _pname, _params) ({ \
    glGetTexEnvxv_PACKED *packed_data = malloc(sizeof(glGetTexEnvxv_PACKED)); \
    packed_data->index = glGetTexEnvxv_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLfixed *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetTexEnvxv(packed, ret_v) do { \
    PACKED_glGetTexEnvxv *unpacked = (PACKED_glGetTexEnvxv *)packed; \
    ARGS_glGetTexEnvxv *args = (ARGS_glGetTexEnvxv *)&unpacked->args; \
    glGetTexEnvxv(args->target, args->pname, args->params);; \
} while(0)
void glGetTexEnvxv(glGetTexEnvxv_ARG_EXPAND);
typedef void (*glGetTexEnvxv_PTR)(glGetTexEnvxv_ARG_EXPAND);
#define glGetTexEnvxvOES_INDEX 974
#define glGetTexEnvxvOES_RETURN void
#define glGetTexEnvxvOES_ARG_NAMES target, pname, params
#define glGetTexEnvxvOES_ARG_EXPAND GLenum target, GLenum pname, GLfixed * params
#define glGetTexEnvxvOES_PACKED PACKED_glGetTexEnvxvOES
#define glGetTexEnvxvOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetTexEnvxvOES_NOT_VOID_WRAP(...) {}
#define pack_glGetTexEnvxvOES(_target, _pname, _params) ({ \
    glGetTexEnvxvOES_PACKED *packed_data = malloc(sizeof(glGetTexEnvxvOES_PACKED)); \
    packed_data->index = glGetTexEnvxvOES_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLfixed *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetTexEnvxvOES(packed, ret_v) do { \
    PACKED_glGetTexEnvxvOES *unpacked = (PACKED_glGetTexEnvxvOES *)packed; \
    ARGS_glGetTexEnvxvOES *args = (ARGS_glGetTexEnvxvOES *)&unpacked->args; \
    glGetTexEnvxvOES(args->target, args->pname, args->params);; \
} while(0)
void glGetTexEnvxvOES(glGetTexEnvxvOES_ARG_EXPAND);
typedef void (*glGetTexEnvxvOES_PTR)(glGetTexEnvxvOES_ARG_EXPAND);
#define glGetTexFilterFuncSGIS_INDEX 975
#define glGetTexFilterFuncSGIS_RETURN void
#define glGetTexFilterFuncSGIS_ARG_NAMES target, filter, weights
#define glGetTexFilterFuncSGIS_ARG_EXPAND GLenum target, GLenum filter, GLfloat * weights
#define glGetTexFilterFuncSGIS_PACKED PACKED_glGetTexFilterFuncSGIS
#define glGetTexFilterFuncSGIS_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetTexFilterFuncSGIS_NOT_VOID_WRAP(...) {}
#define pack_glGetTexFilterFuncSGIS(_target, _filter, _weights) ({ \
    glGetTexFilterFuncSGIS_PACKED *packed_data = malloc(sizeof(glGetTexFilterFuncSGIS_PACKED)); \
    packed_data->index = glGetTexFilterFuncSGIS_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.filter = (GLenum)_filter; \
    packed_data->args.weights = (GLfloat *)_weights; \
    (packed_call_t *)packed_data; \
})
#define call_glGetTexFilterFuncSGIS(packed, ret_v) do { \
    PACKED_glGetTexFilterFuncSGIS *unpacked = (PACKED_glGetTexFilterFuncSGIS *)packed; \
    ARGS_glGetTexFilterFuncSGIS *args = (ARGS_glGetTexFilterFuncSGIS *)&unpacked->args; \
    glGetTexFilterFuncSGIS(args->target, args->filter, args->weights);; \
} while(0)
void glGetTexFilterFuncSGIS(glGetTexFilterFuncSGIS_ARG_EXPAND);
typedef void (*glGetTexFilterFuncSGIS_PTR)(glGetTexFilterFuncSGIS_ARG_EXPAND);
#define glGetTexGendv_INDEX 976
#define glGetTexGendv_RETURN void
#define glGetTexGendv_ARG_NAMES coord, pname, params
#define glGetTexGendv_ARG_EXPAND GLenum coord, GLenum pname, GLdouble * params
#define glGetTexGendv_PACKED PACKED_glGetTexGendv
#define glGetTexGendv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetTexGendv_NOT_VOID_WRAP(...) {}
#define pack_glGetTexGendv(_coord, _pname, _params) ({ \
    glGetTexGendv_PACKED *packed_data = malloc(sizeof(glGetTexGendv_PACKED)); \
    packed_data->index = glGetTexGendv_INDEX; \
    packed_data->args.coord = (GLenum)_coord; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLdouble *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetTexGendv(packed, ret_v) do { \
    PACKED_glGetTexGendv *unpacked = (PACKED_glGetTexGendv *)packed; \
    ARGS_glGetTexGendv *args = (ARGS_glGetTexGendv *)&unpacked->args; \
    glGetTexGendv(args->coord, args->pname, args->params);; \
} while(0)
void glGetTexGendv(glGetTexGendv_ARG_EXPAND);
typedef void (*glGetTexGendv_PTR)(glGetTexGendv_ARG_EXPAND);
#define glGetTexGenfv_INDEX 977
#define glGetTexGenfv_RETURN void
#define glGetTexGenfv_ARG_NAMES coord, pname, params
#define glGetTexGenfv_ARG_EXPAND GLenum coord, GLenum pname, GLfloat * params
#define glGetTexGenfv_PACKED PACKED_glGetTexGenfv
#define glGetTexGenfv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetTexGenfv_NOT_VOID_WRAP(...) {}
#define pack_glGetTexGenfv(_coord, _pname, _params) ({ \
    glGetTexGenfv_PACKED *packed_data = malloc(sizeof(glGetTexGenfv_PACKED)); \
    packed_data->index = glGetTexGenfv_INDEX; \
    packed_data->args.coord = (GLenum)_coord; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLfloat *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetTexGenfv(packed, ret_v) do { \
    PACKED_glGetTexGenfv *unpacked = (PACKED_glGetTexGenfv *)packed; \
    ARGS_glGetTexGenfv *args = (ARGS_glGetTexGenfv *)&unpacked->args; \
    glGetTexGenfv(args->coord, args->pname, args->params);; \
} while(0)
void glGetTexGenfv(glGetTexGenfv_ARG_EXPAND);
typedef void (*glGetTexGenfv_PTR)(glGetTexGenfv_ARG_EXPAND);
#define glGetTexGeniv_INDEX 978
#define glGetTexGeniv_RETURN void
#define glGetTexGeniv_ARG_NAMES coord, pname, params
#define glGetTexGeniv_ARG_EXPAND GLenum coord, GLenum pname, GLint * params
#define glGetTexGeniv_PACKED PACKED_glGetTexGeniv
#define glGetTexGeniv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetTexGeniv_NOT_VOID_WRAP(...) {}
#define pack_glGetTexGeniv(_coord, _pname, _params) ({ \
    glGetTexGeniv_PACKED *packed_data = malloc(sizeof(glGetTexGeniv_PACKED)); \
    packed_data->index = glGetTexGeniv_INDEX; \
    packed_data->args.coord = (GLenum)_coord; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetTexGeniv(packed, ret_v) do { \
    PACKED_glGetTexGeniv *unpacked = (PACKED_glGetTexGeniv *)packed; \
    ARGS_glGetTexGeniv *args = (ARGS_glGetTexGeniv *)&unpacked->args; \
    glGetTexGeniv(args->coord, args->pname, args->params);; \
} while(0)
void glGetTexGeniv(glGetTexGeniv_ARG_EXPAND);
typedef void (*glGetTexGeniv_PTR)(glGetTexGeniv_ARG_EXPAND);
#define glGetTexGenxvOES_INDEX 979
#define glGetTexGenxvOES_RETURN void
#define glGetTexGenxvOES_ARG_NAMES coord, pname, params
#define glGetTexGenxvOES_ARG_EXPAND GLenum coord, GLenum pname, GLfixed * params
#define glGetTexGenxvOES_PACKED PACKED_glGetTexGenxvOES
#define glGetTexGenxvOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetTexGenxvOES_NOT_VOID_WRAP(...) {}
#define pack_glGetTexGenxvOES(_coord, _pname, _params) ({ \
    glGetTexGenxvOES_PACKED *packed_data = malloc(sizeof(glGetTexGenxvOES_PACKED)); \
    packed_data->index = glGetTexGenxvOES_INDEX; \
    packed_data->args.coord = (GLenum)_coord; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLfixed *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetTexGenxvOES(packed, ret_v) do { \
    PACKED_glGetTexGenxvOES *unpacked = (PACKED_glGetTexGenxvOES *)packed; \
    ARGS_glGetTexGenxvOES *args = (ARGS_glGetTexGenxvOES *)&unpacked->args; \
    glGetTexGenxvOES(args->coord, args->pname, args->params);; \
} while(0)
void glGetTexGenxvOES(glGetTexGenxvOES_ARG_EXPAND);
typedef void (*glGetTexGenxvOES_PTR)(glGetTexGenxvOES_ARG_EXPAND);
#define glGetTexImage_INDEX 980
#define glGetTexImage_RETURN void
#define glGetTexImage_ARG_NAMES target, level, format, type, pixels
#define glGetTexImage_ARG_EXPAND GLenum target, GLint level, GLenum format, GLenum type, GLvoid * pixels
#define glGetTexImage_PACKED PACKED_glGetTexImage
#define glGetTexImage_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetTexImage_NOT_VOID_WRAP(...) {}
#define pack_glGetTexImage(_target, _level, _format, _type, _pixels) ({ \
    glGetTexImage_PACKED *packed_data = malloc(sizeof(glGetTexImage_PACKED)); \
    packed_data->index = glGetTexImage_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.level = (GLint)_level; \
    packed_data->args.format = (GLenum)_format; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.pixels = (GLvoid *)_pixels; \
    (packed_call_t *)packed_data; \
})
#define call_glGetTexImage(packed, ret_v) do { \
    PACKED_glGetTexImage *unpacked = (PACKED_glGetTexImage *)packed; \
    ARGS_glGetTexImage *args = (ARGS_glGetTexImage *)&unpacked->args; \
    glGetTexImage(args->target, args->level, args->format, args->type, args->pixels);; \
} while(0)
void glGetTexImage(glGetTexImage_ARG_EXPAND);
typedef void (*glGetTexImage_PTR)(glGetTexImage_ARG_EXPAND);
#define glGetTexLevelParameterfv_INDEX 981
#define glGetTexLevelParameterfv_RETURN void
#define glGetTexLevelParameterfv_ARG_NAMES target, level, pname, params
#define glGetTexLevelParameterfv_ARG_EXPAND GLenum target, GLint level, GLenum pname, GLfloat * params
#define glGetTexLevelParameterfv_PACKED PACKED_glGetTexLevelParameterfv
#define glGetTexLevelParameterfv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetTexLevelParameterfv_NOT_VOID_WRAP(...) {}
#define pack_glGetTexLevelParameterfv(_target, _level, _pname, _params) ({ \
    glGetTexLevelParameterfv_PACKED *packed_data = malloc(sizeof(glGetTexLevelParameterfv_PACKED)); \
    packed_data->index = glGetTexLevelParameterfv_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.level = (GLint)_level; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLfloat *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetTexLevelParameterfv(packed, ret_v) do { \
    PACKED_glGetTexLevelParameterfv *unpacked = (PACKED_glGetTexLevelParameterfv *)packed; \
    ARGS_glGetTexLevelParameterfv *args = (ARGS_glGetTexLevelParameterfv *)&unpacked->args; \
    glGetTexLevelParameterfv(args->target, args->level, args->pname, args->params);; \
} while(0)
void glGetTexLevelParameterfv(glGetTexLevelParameterfv_ARG_EXPAND);
typedef void (*glGetTexLevelParameterfv_PTR)(glGetTexLevelParameterfv_ARG_EXPAND);
#define glGetTexLevelParameteriv_INDEX 982
#define glGetTexLevelParameteriv_RETURN void
#define glGetTexLevelParameteriv_ARG_NAMES target, level, pname, params
#define glGetTexLevelParameteriv_ARG_EXPAND GLenum target, GLint level, GLenum pname, GLint * params
#define glGetTexLevelParameteriv_PACKED PACKED_glGetTexLevelParameteriv
#define glGetTexLevelParameteriv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetTexLevelParameteriv_NOT_VOID_WRAP(...) {}
#define pack_glGetTexLevelParameteriv(_target, _level, _pname, _params) ({ \
    glGetTexLevelParameteriv_PACKED *packed_data = malloc(sizeof(glGetTexLevelParameteriv_PACKED)); \
    packed_data->index = glGetTexLevelParameteriv_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.level = (GLint)_level; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetTexLevelParameteriv(packed, ret_v) do { \
    PACKED_glGetTexLevelParameteriv *unpacked = (PACKED_glGetTexLevelParameteriv *)packed; \
    ARGS_glGetTexLevelParameteriv *args = (ARGS_glGetTexLevelParameteriv *)&unpacked->args; \
    glGetTexLevelParameteriv(args->target, args->level, args->pname, args->params);; \
} while(0)
void glGetTexLevelParameteriv(glGetTexLevelParameteriv_ARG_EXPAND);
typedef void (*glGetTexLevelParameteriv_PTR)(glGetTexLevelParameteriv_ARG_EXPAND);
#define glGetTexLevelParameterxvOES_INDEX 983
#define glGetTexLevelParameterxvOES_RETURN void
#define glGetTexLevelParameterxvOES_ARG_NAMES target, level, pname, params
#define glGetTexLevelParameterxvOES_ARG_EXPAND GLenum target, GLint level, GLenum pname, GLfixed * params
#define glGetTexLevelParameterxvOES_PACKED PACKED_glGetTexLevelParameterxvOES
#define glGetTexLevelParameterxvOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetTexLevelParameterxvOES_NOT_VOID_WRAP(...) {}
#define pack_glGetTexLevelParameterxvOES(_target, _level, _pname, _params) ({ \
    glGetTexLevelParameterxvOES_PACKED *packed_data = malloc(sizeof(glGetTexLevelParameterxvOES_PACKED)); \
    packed_data->index = glGetTexLevelParameterxvOES_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.level = (GLint)_level; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLfixed *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetTexLevelParameterxvOES(packed, ret_v) do { \
    PACKED_glGetTexLevelParameterxvOES *unpacked = (PACKED_glGetTexLevelParameterxvOES *)packed; \
    ARGS_glGetTexLevelParameterxvOES *args = (ARGS_glGetTexLevelParameterxvOES *)&unpacked->args; \
    glGetTexLevelParameterxvOES(args->target, args->level, args->pname, args->params);; \
} while(0)
void glGetTexLevelParameterxvOES(glGetTexLevelParameterxvOES_ARG_EXPAND);
typedef void (*glGetTexLevelParameterxvOES_PTR)(glGetTexLevelParameterxvOES_ARG_EXPAND);
#define glGetTexParameterIiv_INDEX 984
#define glGetTexParameterIiv_RETURN void
#define glGetTexParameterIiv_ARG_NAMES target, pname, params
#define glGetTexParameterIiv_ARG_EXPAND GLenum target, GLenum pname, GLint * params
#define glGetTexParameterIiv_PACKED PACKED_glGetTexParameterIiv
#define glGetTexParameterIiv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetTexParameterIiv_NOT_VOID_WRAP(...) {}
#define pack_glGetTexParameterIiv(_target, _pname, _params) ({ \
    glGetTexParameterIiv_PACKED *packed_data = malloc(sizeof(glGetTexParameterIiv_PACKED)); \
    packed_data->index = glGetTexParameterIiv_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetTexParameterIiv(packed, ret_v) do { \
    PACKED_glGetTexParameterIiv *unpacked = (PACKED_glGetTexParameterIiv *)packed; \
    ARGS_glGetTexParameterIiv *args = (ARGS_glGetTexParameterIiv *)&unpacked->args; \
    glGetTexParameterIiv(args->target, args->pname, args->params);; \
} while(0)
void glGetTexParameterIiv(glGetTexParameterIiv_ARG_EXPAND);
typedef void (*glGetTexParameterIiv_PTR)(glGetTexParameterIiv_ARG_EXPAND);
#define glGetTexParameterIivEXT_INDEX 985
#define glGetTexParameterIivEXT_RETURN void
#define glGetTexParameterIivEXT_ARG_NAMES target, pname, params
#define glGetTexParameterIivEXT_ARG_EXPAND GLenum target, GLenum pname, GLint * params
#define glGetTexParameterIivEXT_PACKED PACKED_glGetTexParameterIivEXT
#define glGetTexParameterIivEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetTexParameterIivEXT_NOT_VOID_WRAP(...) {}
#define pack_glGetTexParameterIivEXT(_target, _pname, _params) ({ \
    glGetTexParameterIivEXT_PACKED *packed_data = malloc(sizeof(glGetTexParameterIivEXT_PACKED)); \
    packed_data->index = glGetTexParameterIivEXT_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetTexParameterIivEXT(packed, ret_v) do { \
    PACKED_glGetTexParameterIivEXT *unpacked = (PACKED_glGetTexParameterIivEXT *)packed; \
    ARGS_glGetTexParameterIivEXT *args = (ARGS_glGetTexParameterIivEXT *)&unpacked->args; \
    glGetTexParameterIivEXT(args->target, args->pname, args->params);; \
} while(0)
void glGetTexParameterIivEXT(glGetTexParameterIivEXT_ARG_EXPAND);
typedef void (*glGetTexParameterIivEXT_PTR)(glGetTexParameterIivEXT_ARG_EXPAND);
#define glGetTexParameterIuiv_INDEX 986
#define glGetTexParameterIuiv_RETURN void
#define glGetTexParameterIuiv_ARG_NAMES target, pname, params
#define glGetTexParameterIuiv_ARG_EXPAND GLenum target, GLenum pname, GLuint * params
#define glGetTexParameterIuiv_PACKED PACKED_glGetTexParameterIuiv
#define glGetTexParameterIuiv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetTexParameterIuiv_NOT_VOID_WRAP(...) {}
#define pack_glGetTexParameterIuiv(_target, _pname, _params) ({ \
    glGetTexParameterIuiv_PACKED *packed_data = malloc(sizeof(glGetTexParameterIuiv_PACKED)); \
    packed_data->index = glGetTexParameterIuiv_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLuint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetTexParameterIuiv(packed, ret_v) do { \
    PACKED_glGetTexParameterIuiv *unpacked = (PACKED_glGetTexParameterIuiv *)packed; \
    ARGS_glGetTexParameterIuiv *args = (ARGS_glGetTexParameterIuiv *)&unpacked->args; \
    glGetTexParameterIuiv(args->target, args->pname, args->params);; \
} while(0)
void glGetTexParameterIuiv(glGetTexParameterIuiv_ARG_EXPAND);
typedef void (*glGetTexParameterIuiv_PTR)(glGetTexParameterIuiv_ARG_EXPAND);
#define glGetTexParameterIuivEXT_INDEX 987
#define glGetTexParameterIuivEXT_RETURN void
#define glGetTexParameterIuivEXT_ARG_NAMES target, pname, params
#define glGetTexParameterIuivEXT_ARG_EXPAND GLenum target, GLenum pname, GLuint * params
#define glGetTexParameterIuivEXT_PACKED PACKED_glGetTexParameterIuivEXT
#define glGetTexParameterIuivEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetTexParameterIuivEXT_NOT_VOID_WRAP(...) {}
#define pack_glGetTexParameterIuivEXT(_target, _pname, _params) ({ \
    glGetTexParameterIuivEXT_PACKED *packed_data = malloc(sizeof(glGetTexParameterIuivEXT_PACKED)); \
    packed_data->index = glGetTexParameterIuivEXT_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLuint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetTexParameterIuivEXT(packed, ret_v) do { \
    PACKED_glGetTexParameterIuivEXT *unpacked = (PACKED_glGetTexParameterIuivEXT *)packed; \
    ARGS_glGetTexParameterIuivEXT *args = (ARGS_glGetTexParameterIuivEXT *)&unpacked->args; \
    glGetTexParameterIuivEXT(args->target, args->pname, args->params);; \
} while(0)
void glGetTexParameterIuivEXT(glGetTexParameterIuivEXT_ARG_EXPAND);
typedef void (*glGetTexParameterIuivEXT_PTR)(glGetTexParameterIuivEXT_ARG_EXPAND);
#define glGetTexParameterPointervAPPLE_INDEX 988
#define glGetTexParameterPointervAPPLE_RETURN void
#define glGetTexParameterPointervAPPLE_ARG_NAMES target, pname, params
#define glGetTexParameterPointervAPPLE_ARG_EXPAND GLenum target, GLenum pname, GLvoid * params
#define glGetTexParameterPointervAPPLE_PACKED PACKED_glGetTexParameterPointervAPPLE
#define glGetTexParameterPointervAPPLE_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetTexParameterPointervAPPLE_NOT_VOID_WRAP(...) {}
#define pack_glGetTexParameterPointervAPPLE(_target, _pname, _params) ({ \
    glGetTexParameterPointervAPPLE_PACKED *packed_data = malloc(sizeof(glGetTexParameterPointervAPPLE_PACKED)); \
    packed_data->index = glGetTexParameterPointervAPPLE_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLvoid *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetTexParameterPointervAPPLE(packed, ret_v) do { \
    PACKED_glGetTexParameterPointervAPPLE *unpacked = (PACKED_glGetTexParameterPointervAPPLE *)packed; \
    ARGS_glGetTexParameterPointervAPPLE *args = (ARGS_glGetTexParameterPointervAPPLE *)&unpacked->args; \
    glGetTexParameterPointervAPPLE(args->target, args->pname, args->params);; \
} while(0)
void glGetTexParameterPointervAPPLE(glGetTexParameterPointervAPPLE_ARG_EXPAND);
typedef void (*glGetTexParameterPointervAPPLE_PTR)(glGetTexParameterPointervAPPLE_ARG_EXPAND);
#define glGetTexParameterfv_INDEX 989
#define glGetTexParameterfv_RETURN void
#define glGetTexParameterfv_ARG_NAMES target, pname, params
#define glGetTexParameterfv_ARG_EXPAND GLenum target, GLenum pname, GLfloat * params
#define glGetTexParameterfv_PACKED PACKED_glGetTexParameterfv
#define glGetTexParameterfv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetTexParameterfv_NOT_VOID_WRAP(...) {}
#define pack_glGetTexParameterfv(_target, _pname, _params) ({ \
    glGetTexParameterfv_PACKED *packed_data = malloc(sizeof(glGetTexParameterfv_PACKED)); \
    packed_data->index = glGetTexParameterfv_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLfloat *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetTexParameterfv(packed, ret_v) do { \
    PACKED_glGetTexParameterfv *unpacked = (PACKED_glGetTexParameterfv *)packed; \
    ARGS_glGetTexParameterfv *args = (ARGS_glGetTexParameterfv *)&unpacked->args; \
    glGetTexParameterfv(args->target, args->pname, args->params);; \
} while(0)
void glGetTexParameterfv(glGetTexParameterfv_ARG_EXPAND);
typedef void (*glGetTexParameterfv_PTR)(glGetTexParameterfv_ARG_EXPAND);
#define glGetTexParameteriv_INDEX 990
#define glGetTexParameteriv_RETURN void
#define glGetTexParameteriv_ARG_NAMES target, pname, params
#define glGetTexParameteriv_ARG_EXPAND GLenum target, GLenum pname, GLint * params
#define glGetTexParameteriv_PACKED PACKED_glGetTexParameteriv
#define glGetTexParameteriv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetTexParameteriv_NOT_VOID_WRAP(...) {}
#define pack_glGetTexParameteriv(_target, _pname, _params) ({ \
    glGetTexParameteriv_PACKED *packed_data = malloc(sizeof(glGetTexParameteriv_PACKED)); \
    packed_data->index = glGetTexParameteriv_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetTexParameteriv(packed, ret_v) do { \
    PACKED_glGetTexParameteriv *unpacked = (PACKED_glGetTexParameteriv *)packed; \
    ARGS_glGetTexParameteriv *args = (ARGS_glGetTexParameteriv *)&unpacked->args; \
    glGetTexParameteriv(args->target, args->pname, args->params);; \
} while(0)
void glGetTexParameteriv(glGetTexParameteriv_ARG_EXPAND);
typedef void (*glGetTexParameteriv_PTR)(glGetTexParameteriv_ARG_EXPAND);
#define glGetTexParameterxv_INDEX 991
#define glGetTexParameterxv_RETURN void
#define glGetTexParameterxv_ARG_NAMES target, pname, params
#define glGetTexParameterxv_ARG_EXPAND GLenum target, GLenum pname, GLfixed * params
#define glGetTexParameterxv_PACKED PACKED_glGetTexParameterxv
#define glGetTexParameterxv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetTexParameterxv_NOT_VOID_WRAP(...) {}
#define pack_glGetTexParameterxv(_target, _pname, _params) ({ \
    glGetTexParameterxv_PACKED *packed_data = malloc(sizeof(glGetTexParameterxv_PACKED)); \
    packed_data->index = glGetTexParameterxv_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLfixed *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetTexParameterxv(packed, ret_v) do { \
    PACKED_glGetTexParameterxv *unpacked = (PACKED_glGetTexParameterxv *)packed; \
    ARGS_glGetTexParameterxv *args = (ARGS_glGetTexParameterxv *)&unpacked->args; \
    glGetTexParameterxv(args->target, args->pname, args->params);; \
} while(0)
void glGetTexParameterxv(glGetTexParameterxv_ARG_EXPAND);
typedef void (*glGetTexParameterxv_PTR)(glGetTexParameterxv_ARG_EXPAND);
#define glGetTexParameterxvOES_INDEX 992
#define glGetTexParameterxvOES_RETURN void
#define glGetTexParameterxvOES_ARG_NAMES target, pname, params
#define glGetTexParameterxvOES_ARG_EXPAND GLenum target, GLenum pname, GLfixed * params
#define glGetTexParameterxvOES_PACKED PACKED_glGetTexParameterxvOES
#define glGetTexParameterxvOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetTexParameterxvOES_NOT_VOID_WRAP(...) {}
#define pack_glGetTexParameterxvOES(_target, _pname, _params) ({ \
    glGetTexParameterxvOES_PACKED *packed_data = malloc(sizeof(glGetTexParameterxvOES_PACKED)); \
    packed_data->index = glGetTexParameterxvOES_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLfixed *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetTexParameterxvOES(packed, ret_v) do { \
    PACKED_glGetTexParameterxvOES *unpacked = (PACKED_glGetTexParameterxvOES *)packed; \
    ARGS_glGetTexParameterxvOES *args = (ARGS_glGetTexParameterxvOES *)&unpacked->args; \
    glGetTexParameterxvOES(args->target, args->pname, args->params);; \
} while(0)
void glGetTexParameterxvOES(glGetTexParameterxvOES_ARG_EXPAND);
typedef void (*glGetTexParameterxvOES_PTR)(glGetTexParameterxvOES_ARG_EXPAND);
#define glGetTextureHandleNV_INDEX 993
#define glGetTextureHandleNV_RETURN GLuint64
#define glGetTextureHandleNV_ARG_NAMES texture
#define glGetTextureHandleNV_ARG_EXPAND GLuint texture
#define glGetTextureHandleNV_PACKED PACKED_glGetTextureHandleNV
#define glGetTextureHandleNV_VOID_ONLY_WRAP(...) {}
#define glGetTextureHandleNV_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glGetTextureHandleNV(_texture) ({ \
    glGetTextureHandleNV_PACKED *packed_data = malloc(sizeof(glGetTextureHandleNV_PACKED)); \
    packed_data->index = glGetTextureHandleNV_INDEX; \
    packed_data->args.texture = (GLuint)_texture; \
    (packed_call_t *)packed_data; \
})
#define call_glGetTextureHandleNV(packed, ret_v) do { \
    PACKED_glGetTextureHandleNV *unpacked = (PACKED_glGetTextureHandleNV *)packed; \
    ARGS_glGetTextureHandleNV *args = (ARGS_glGetTextureHandleNV *)&unpacked->args; \
    GLuint64 *ret = (GLuint64 *)ret_v; \
    if (ret != NULL) { \
        *ret = glGetTextureHandleNV(args->texture);; \
    } else { \
        glGetTextureHandleNV(args->texture);; \
    } \
} while(0)
GLuint64 glGetTextureHandleNV(glGetTextureHandleNV_ARG_EXPAND);
typedef GLuint64 (*glGetTextureHandleNV_PTR)(glGetTextureHandleNV_ARG_EXPAND);
#define glGetTextureImageEXT_INDEX 994
#define glGetTextureImageEXT_RETURN void
#define glGetTextureImageEXT_ARG_NAMES texture, target, level, format, type, pixels
#define glGetTextureImageEXT_ARG_EXPAND GLuint texture, GLenum target, GLint level, GLenum format, GLenum type, GLvoid * pixels
#define glGetTextureImageEXT_PACKED PACKED_glGetTextureImageEXT
#define glGetTextureImageEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetTextureImageEXT_NOT_VOID_WRAP(...) {}
#define pack_glGetTextureImageEXT(_texture, _target, _level, _format, _type, _pixels) ({ \
    glGetTextureImageEXT_PACKED *packed_data = malloc(sizeof(glGetTextureImageEXT_PACKED)); \
    packed_data->index = glGetTextureImageEXT_INDEX; \
    packed_data->args.texture = (GLuint)_texture; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.level = (GLint)_level; \
    packed_data->args.format = (GLenum)_format; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.pixels = (GLvoid *)_pixels; \
    (packed_call_t *)packed_data; \
})
#define call_glGetTextureImageEXT(packed, ret_v) do { \
    PACKED_glGetTextureImageEXT *unpacked = (PACKED_glGetTextureImageEXT *)packed; \
    ARGS_glGetTextureImageEXT *args = (ARGS_glGetTextureImageEXT *)&unpacked->args; \
    glGetTextureImageEXT(args->texture, args->target, args->level, args->format, args->type, args->pixels);; \
} while(0)
void glGetTextureImageEXT(glGetTextureImageEXT_ARG_EXPAND);
typedef void (*glGetTextureImageEXT_PTR)(glGetTextureImageEXT_ARG_EXPAND);
#define glGetTextureLevelParameterfvEXT_INDEX 995
#define glGetTextureLevelParameterfvEXT_RETURN void
#define glGetTextureLevelParameterfvEXT_ARG_NAMES texture, target, level, pname, params
#define glGetTextureLevelParameterfvEXT_ARG_EXPAND GLuint texture, GLenum target, GLint level, GLenum pname, GLfloat * params
#define glGetTextureLevelParameterfvEXT_PACKED PACKED_glGetTextureLevelParameterfvEXT
#define glGetTextureLevelParameterfvEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetTextureLevelParameterfvEXT_NOT_VOID_WRAP(...) {}
#define pack_glGetTextureLevelParameterfvEXT(_texture, _target, _level, _pname, _params) ({ \
    glGetTextureLevelParameterfvEXT_PACKED *packed_data = malloc(sizeof(glGetTextureLevelParameterfvEXT_PACKED)); \
    packed_data->index = glGetTextureLevelParameterfvEXT_INDEX; \
    packed_data->args.texture = (GLuint)_texture; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.level = (GLint)_level; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLfloat *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetTextureLevelParameterfvEXT(packed, ret_v) do { \
    PACKED_glGetTextureLevelParameterfvEXT *unpacked = (PACKED_glGetTextureLevelParameterfvEXT *)packed; \
    ARGS_glGetTextureLevelParameterfvEXT *args = (ARGS_glGetTextureLevelParameterfvEXT *)&unpacked->args; \
    glGetTextureLevelParameterfvEXT(args->texture, args->target, args->level, args->pname, args->params);; \
} while(0)
void glGetTextureLevelParameterfvEXT(glGetTextureLevelParameterfvEXT_ARG_EXPAND);
typedef void (*glGetTextureLevelParameterfvEXT_PTR)(glGetTextureLevelParameterfvEXT_ARG_EXPAND);
#define glGetTextureLevelParameterivEXT_INDEX 996
#define glGetTextureLevelParameterivEXT_RETURN void
#define glGetTextureLevelParameterivEXT_ARG_NAMES texture, target, level, pname, params
#define glGetTextureLevelParameterivEXT_ARG_EXPAND GLuint texture, GLenum target, GLint level, GLenum pname, GLint * params
#define glGetTextureLevelParameterivEXT_PACKED PACKED_glGetTextureLevelParameterivEXT
#define glGetTextureLevelParameterivEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetTextureLevelParameterivEXT_NOT_VOID_WRAP(...) {}
#define pack_glGetTextureLevelParameterivEXT(_texture, _target, _level, _pname, _params) ({ \
    glGetTextureLevelParameterivEXT_PACKED *packed_data = malloc(sizeof(glGetTextureLevelParameterivEXT_PACKED)); \
    packed_data->index = glGetTextureLevelParameterivEXT_INDEX; \
    packed_data->args.texture = (GLuint)_texture; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.level = (GLint)_level; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetTextureLevelParameterivEXT(packed, ret_v) do { \
    PACKED_glGetTextureLevelParameterivEXT *unpacked = (PACKED_glGetTextureLevelParameterivEXT *)packed; \
    ARGS_glGetTextureLevelParameterivEXT *args = (ARGS_glGetTextureLevelParameterivEXT *)&unpacked->args; \
    glGetTextureLevelParameterivEXT(args->texture, args->target, args->level, args->pname, args->params);; \
} while(0)
void glGetTextureLevelParameterivEXT(glGetTextureLevelParameterivEXT_ARG_EXPAND);
typedef void (*glGetTextureLevelParameterivEXT_PTR)(glGetTextureLevelParameterivEXT_ARG_EXPAND);
#define glGetTextureParameterIivEXT_INDEX 997
#define glGetTextureParameterIivEXT_RETURN void
#define glGetTextureParameterIivEXT_ARG_NAMES texture, target, pname, params
#define glGetTextureParameterIivEXT_ARG_EXPAND GLuint texture, GLenum target, GLenum pname, GLint * params
#define glGetTextureParameterIivEXT_PACKED PACKED_glGetTextureParameterIivEXT
#define glGetTextureParameterIivEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetTextureParameterIivEXT_NOT_VOID_WRAP(...) {}
#define pack_glGetTextureParameterIivEXT(_texture, _target, _pname, _params) ({ \
    glGetTextureParameterIivEXT_PACKED *packed_data = malloc(sizeof(glGetTextureParameterIivEXT_PACKED)); \
    packed_data->index = glGetTextureParameterIivEXT_INDEX; \
    packed_data->args.texture = (GLuint)_texture; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetTextureParameterIivEXT(packed, ret_v) do { \
    PACKED_glGetTextureParameterIivEXT *unpacked = (PACKED_glGetTextureParameterIivEXT *)packed; \
    ARGS_glGetTextureParameterIivEXT *args = (ARGS_glGetTextureParameterIivEXT *)&unpacked->args; \
    glGetTextureParameterIivEXT(args->texture, args->target, args->pname, args->params);; \
} while(0)
void glGetTextureParameterIivEXT(glGetTextureParameterIivEXT_ARG_EXPAND);
typedef void (*glGetTextureParameterIivEXT_PTR)(glGetTextureParameterIivEXT_ARG_EXPAND);
#define glGetTextureParameterIuivEXT_INDEX 998
#define glGetTextureParameterIuivEXT_RETURN void
#define glGetTextureParameterIuivEXT_ARG_NAMES texture, target, pname, params
#define glGetTextureParameterIuivEXT_ARG_EXPAND GLuint texture, GLenum target, GLenum pname, GLuint * params
#define glGetTextureParameterIuivEXT_PACKED PACKED_glGetTextureParameterIuivEXT
#define glGetTextureParameterIuivEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetTextureParameterIuivEXT_NOT_VOID_WRAP(...) {}
#define pack_glGetTextureParameterIuivEXT(_texture, _target, _pname, _params) ({ \
    glGetTextureParameterIuivEXT_PACKED *packed_data = malloc(sizeof(glGetTextureParameterIuivEXT_PACKED)); \
    packed_data->index = glGetTextureParameterIuivEXT_INDEX; \
    packed_data->args.texture = (GLuint)_texture; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLuint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetTextureParameterIuivEXT(packed, ret_v) do { \
    PACKED_glGetTextureParameterIuivEXT *unpacked = (PACKED_glGetTextureParameterIuivEXT *)packed; \
    ARGS_glGetTextureParameterIuivEXT *args = (ARGS_glGetTextureParameterIuivEXT *)&unpacked->args; \
    glGetTextureParameterIuivEXT(args->texture, args->target, args->pname, args->params);; \
} while(0)
void glGetTextureParameterIuivEXT(glGetTextureParameterIuivEXT_ARG_EXPAND);
typedef void (*glGetTextureParameterIuivEXT_PTR)(glGetTextureParameterIuivEXT_ARG_EXPAND);
#define glGetTextureParameterfvEXT_INDEX 999
#define glGetTextureParameterfvEXT_RETURN void
#define glGetTextureParameterfvEXT_ARG_NAMES texture, target, pname, params
#define glGetTextureParameterfvEXT_ARG_EXPAND GLuint texture, GLenum target, GLenum pname, GLfloat * params
#define glGetTextureParameterfvEXT_PACKED PACKED_glGetTextureParameterfvEXT
#define glGetTextureParameterfvEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetTextureParameterfvEXT_NOT_VOID_WRAP(...) {}
#define pack_glGetTextureParameterfvEXT(_texture, _target, _pname, _params) ({ \
    glGetTextureParameterfvEXT_PACKED *packed_data = malloc(sizeof(glGetTextureParameterfvEXT_PACKED)); \
    packed_data->index = glGetTextureParameterfvEXT_INDEX; \
    packed_data->args.texture = (GLuint)_texture; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLfloat *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetTextureParameterfvEXT(packed, ret_v) do { \
    PACKED_glGetTextureParameterfvEXT *unpacked = (PACKED_glGetTextureParameterfvEXT *)packed; \
    ARGS_glGetTextureParameterfvEXT *args = (ARGS_glGetTextureParameterfvEXT *)&unpacked->args; \
    glGetTextureParameterfvEXT(args->texture, args->target, args->pname, args->params);; \
} while(0)
void glGetTextureParameterfvEXT(glGetTextureParameterfvEXT_ARG_EXPAND);
typedef void (*glGetTextureParameterfvEXT_PTR)(glGetTextureParameterfvEXT_ARG_EXPAND);
#define glGetTextureParameterivEXT_INDEX 1000
#define glGetTextureParameterivEXT_RETURN void
#define glGetTextureParameterivEXT_ARG_NAMES texture, target, pname, params
#define glGetTextureParameterivEXT_ARG_EXPAND GLuint texture, GLenum target, GLenum pname, GLint * params
#define glGetTextureParameterivEXT_PACKED PACKED_glGetTextureParameterivEXT
#define glGetTextureParameterivEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetTextureParameterivEXT_NOT_VOID_WRAP(...) {}
#define pack_glGetTextureParameterivEXT(_texture, _target, _pname, _params) ({ \
    glGetTextureParameterivEXT_PACKED *packed_data = malloc(sizeof(glGetTextureParameterivEXT_PACKED)); \
    packed_data->index = glGetTextureParameterivEXT_INDEX; \
    packed_data->args.texture = (GLuint)_texture; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetTextureParameterivEXT(packed, ret_v) do { \
    PACKED_glGetTextureParameterivEXT *unpacked = (PACKED_glGetTextureParameterivEXT *)packed; \
    ARGS_glGetTextureParameterivEXT *args = (ARGS_glGetTextureParameterivEXT *)&unpacked->args; \
    glGetTextureParameterivEXT(args->texture, args->target, args->pname, args->params);; \
} while(0)
void glGetTextureParameterivEXT(glGetTextureParameterivEXT_ARG_EXPAND);
typedef void (*glGetTextureParameterivEXT_PTR)(glGetTextureParameterivEXT_ARG_EXPAND);
#define glGetTextureSamplerHandleNV_INDEX 1001
#define glGetTextureSamplerHandleNV_RETURN GLuint64
#define glGetTextureSamplerHandleNV_ARG_NAMES texture, sampler
#define glGetTextureSamplerHandleNV_ARG_EXPAND GLuint texture, GLuint sampler
#define glGetTextureSamplerHandleNV_PACKED PACKED_glGetTextureSamplerHandleNV
#define glGetTextureSamplerHandleNV_VOID_ONLY_WRAP(...) {}
#define glGetTextureSamplerHandleNV_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glGetTextureSamplerHandleNV(_texture, _sampler) ({ \
    glGetTextureSamplerHandleNV_PACKED *packed_data = malloc(sizeof(glGetTextureSamplerHandleNV_PACKED)); \
    packed_data->index = glGetTextureSamplerHandleNV_INDEX; \
    packed_data->args.texture = (GLuint)_texture; \
    packed_data->args.sampler = (GLuint)_sampler; \
    (packed_call_t *)packed_data; \
})
#define call_glGetTextureSamplerHandleNV(packed, ret_v) do { \
    PACKED_glGetTextureSamplerHandleNV *unpacked = (PACKED_glGetTextureSamplerHandleNV *)packed; \
    ARGS_glGetTextureSamplerHandleNV *args = (ARGS_glGetTextureSamplerHandleNV *)&unpacked->args; \
    GLuint64 *ret = (GLuint64 *)ret_v; \
    if (ret != NULL) { \
        *ret = glGetTextureSamplerHandleNV(args->texture, args->sampler);; \
    } else { \
        glGetTextureSamplerHandleNV(args->texture, args->sampler);; \
    } \
} while(0)
GLuint64 glGetTextureSamplerHandleNV(glGetTextureSamplerHandleNV_ARG_EXPAND);
typedef GLuint64 (*glGetTextureSamplerHandleNV_PTR)(glGetTextureSamplerHandleNV_ARG_EXPAND);
#define glGetTrackMatrixivNV_INDEX 1002
#define glGetTrackMatrixivNV_RETURN void
#define glGetTrackMatrixivNV_ARG_NAMES target, address, pname, params
#define glGetTrackMatrixivNV_ARG_EXPAND GLenum target, GLuint address, GLenum pname, GLint * params
#define glGetTrackMatrixivNV_PACKED PACKED_glGetTrackMatrixivNV
#define glGetTrackMatrixivNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetTrackMatrixivNV_NOT_VOID_WRAP(...) {}
#define pack_glGetTrackMatrixivNV(_target, _address, _pname, _params) ({ \
    glGetTrackMatrixivNV_PACKED *packed_data = malloc(sizeof(glGetTrackMatrixivNV_PACKED)); \
    packed_data->index = glGetTrackMatrixivNV_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.address = (GLuint)_address; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetTrackMatrixivNV(packed, ret_v) do { \
    PACKED_glGetTrackMatrixivNV *unpacked = (PACKED_glGetTrackMatrixivNV *)packed; \
    ARGS_glGetTrackMatrixivNV *args = (ARGS_glGetTrackMatrixivNV *)&unpacked->args; \
    glGetTrackMatrixivNV(args->target, args->address, args->pname, args->params);; \
} while(0)
void glGetTrackMatrixivNV(glGetTrackMatrixivNV_ARG_EXPAND);
typedef void (*glGetTrackMatrixivNV_PTR)(glGetTrackMatrixivNV_ARG_EXPAND);
#define glGetTransformFeedbackVarying_INDEX 1003
#define glGetTransformFeedbackVarying_RETURN void
#define glGetTransformFeedbackVarying_ARG_NAMES program, index, bufSize, length, size, type, name
#define glGetTransformFeedbackVarying_ARG_EXPAND GLuint program, GLuint index, GLsizei bufSize, GLsizei * length, GLsizei * size, GLenum * type, GLchar * name
#define glGetTransformFeedbackVarying_PACKED PACKED_glGetTransformFeedbackVarying
#define glGetTransformFeedbackVarying_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetTransformFeedbackVarying_NOT_VOID_WRAP(...) {}
#define pack_glGetTransformFeedbackVarying(_program, _index, _bufSize, _length, _size, _type, _name) ({ \
    glGetTransformFeedbackVarying_PACKED *packed_data = malloc(sizeof(glGetTransformFeedbackVarying_PACKED)); \
    packed_data->index = glGetTransformFeedbackVarying_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.bufSize = (GLsizei)_bufSize; \
    packed_data->args.length = (GLsizei *)_length; \
    packed_data->args.size = (GLsizei *)_size; \
    packed_data->args.type = (GLenum *)_type; \
    packed_data->args.name = (GLchar *)_name; \
    (packed_call_t *)packed_data; \
})
#define call_glGetTransformFeedbackVarying(packed, ret_v) do { \
    PACKED_glGetTransformFeedbackVarying *unpacked = (PACKED_glGetTransformFeedbackVarying *)packed; \
    ARGS_glGetTransformFeedbackVarying *args = (ARGS_glGetTransformFeedbackVarying *)&unpacked->args; \
    glGetTransformFeedbackVarying(args->program, args->index, args->bufSize, args->length, args->size, args->type, args->name);; \
} while(0)
void glGetTransformFeedbackVarying(glGetTransformFeedbackVarying_ARG_EXPAND);
typedef void (*glGetTransformFeedbackVarying_PTR)(glGetTransformFeedbackVarying_ARG_EXPAND);
#define glGetTransformFeedbackVaryingEXT_INDEX 1004
#define glGetTransformFeedbackVaryingEXT_RETURN void
#define glGetTransformFeedbackVaryingEXT_ARG_NAMES program, index, bufSize, length, size, type, name
#define glGetTransformFeedbackVaryingEXT_ARG_EXPAND GLuint program, GLuint index, GLsizei bufSize, GLsizei * length, GLsizei * size, GLenum * type, GLchar * name
#define glGetTransformFeedbackVaryingEXT_PACKED PACKED_glGetTransformFeedbackVaryingEXT
#define glGetTransformFeedbackVaryingEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetTransformFeedbackVaryingEXT_NOT_VOID_WRAP(...) {}
#define pack_glGetTransformFeedbackVaryingEXT(_program, _index, _bufSize, _length, _size, _type, _name) ({ \
    glGetTransformFeedbackVaryingEXT_PACKED *packed_data = malloc(sizeof(glGetTransformFeedbackVaryingEXT_PACKED)); \
    packed_data->index = glGetTransformFeedbackVaryingEXT_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.bufSize = (GLsizei)_bufSize; \
    packed_data->args.length = (GLsizei *)_length; \
    packed_data->args.size = (GLsizei *)_size; \
    packed_data->args.type = (GLenum *)_type; \
    packed_data->args.name = (GLchar *)_name; \
    (packed_call_t *)packed_data; \
})
#define call_glGetTransformFeedbackVaryingEXT(packed, ret_v) do { \
    PACKED_glGetTransformFeedbackVaryingEXT *unpacked = (PACKED_glGetTransformFeedbackVaryingEXT *)packed; \
    ARGS_glGetTransformFeedbackVaryingEXT *args = (ARGS_glGetTransformFeedbackVaryingEXT *)&unpacked->args; \
    glGetTransformFeedbackVaryingEXT(args->program, args->index, args->bufSize, args->length, args->size, args->type, args->name);; \
} while(0)
void glGetTransformFeedbackVaryingEXT(glGetTransformFeedbackVaryingEXT_ARG_EXPAND);
typedef void (*glGetTransformFeedbackVaryingEXT_PTR)(glGetTransformFeedbackVaryingEXT_ARG_EXPAND);
#define glGetTransformFeedbackVaryingNV_INDEX 1005
#define glGetTransformFeedbackVaryingNV_RETURN void
#define glGetTransformFeedbackVaryingNV_ARG_NAMES program, index, location
#define glGetTransformFeedbackVaryingNV_ARG_EXPAND GLuint program, GLuint index, GLint * location
#define glGetTransformFeedbackVaryingNV_PACKED PACKED_glGetTransformFeedbackVaryingNV
#define glGetTransformFeedbackVaryingNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetTransformFeedbackVaryingNV_NOT_VOID_WRAP(...) {}
#define pack_glGetTransformFeedbackVaryingNV(_program, _index, _location) ({ \
    glGetTransformFeedbackVaryingNV_PACKED *packed_data = malloc(sizeof(glGetTransformFeedbackVaryingNV_PACKED)); \
    packed_data->index = glGetTransformFeedbackVaryingNV_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.location = (GLint *)_location; \
    (packed_call_t *)packed_data; \
})
#define call_glGetTransformFeedbackVaryingNV(packed, ret_v) do { \
    PACKED_glGetTransformFeedbackVaryingNV *unpacked = (PACKED_glGetTransformFeedbackVaryingNV *)packed; \
    ARGS_glGetTransformFeedbackVaryingNV *args = (ARGS_glGetTransformFeedbackVaryingNV *)&unpacked->args; \
    glGetTransformFeedbackVaryingNV(args->program, args->index, args->location);; \
} while(0)
void glGetTransformFeedbackVaryingNV(glGetTransformFeedbackVaryingNV_ARG_EXPAND);
typedef void (*glGetTransformFeedbackVaryingNV_PTR)(glGetTransformFeedbackVaryingNV_ARG_EXPAND);
#define glGetUniformBlockIndex_INDEX 1006
#define glGetUniformBlockIndex_RETURN GLuint
#define glGetUniformBlockIndex_ARG_NAMES program, uniformBlockName
#define glGetUniformBlockIndex_ARG_EXPAND GLuint program, const GLchar * uniformBlockName
#define glGetUniformBlockIndex_PACKED PACKED_glGetUniformBlockIndex
#define glGetUniformBlockIndex_VOID_ONLY_WRAP(...) {}
#define glGetUniformBlockIndex_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glGetUniformBlockIndex(_program, _uniformBlockName) ({ \
    glGetUniformBlockIndex_PACKED *packed_data = malloc(sizeof(glGetUniformBlockIndex_PACKED)); \
    packed_data->index = glGetUniformBlockIndex_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.uniformBlockName = (GLchar *)_uniformBlockName; \
    (packed_call_t *)packed_data; \
})
#define call_glGetUniformBlockIndex(packed, ret_v) do { \
    PACKED_glGetUniformBlockIndex *unpacked = (PACKED_glGetUniformBlockIndex *)packed; \
    ARGS_glGetUniformBlockIndex *args = (ARGS_glGetUniformBlockIndex *)&unpacked->args; \
    GLuint *ret = (GLuint *)ret_v; \
    if (ret != NULL) { \
        *ret = glGetUniformBlockIndex(args->program, args->uniformBlockName);; \
    } else { \
        glGetUniformBlockIndex(args->program, args->uniformBlockName);; \
    } \
} while(0)
GLuint glGetUniformBlockIndex(glGetUniformBlockIndex_ARG_EXPAND);
typedef GLuint (*glGetUniformBlockIndex_PTR)(glGetUniformBlockIndex_ARG_EXPAND);
#define glGetUniformBufferSizeEXT_INDEX 1007
#define glGetUniformBufferSizeEXT_RETURN GLint
#define glGetUniformBufferSizeEXT_ARG_NAMES program, location
#define glGetUniformBufferSizeEXT_ARG_EXPAND GLuint program, GLint location
#define glGetUniformBufferSizeEXT_PACKED PACKED_glGetUniformBufferSizeEXT
#define glGetUniformBufferSizeEXT_VOID_ONLY_WRAP(...) {}
#define glGetUniformBufferSizeEXT_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glGetUniformBufferSizeEXT(_program, _location) ({ \
    glGetUniformBufferSizeEXT_PACKED *packed_data = malloc(sizeof(glGetUniformBufferSizeEXT_PACKED)); \
    packed_data->index = glGetUniformBufferSizeEXT_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    (packed_call_t *)packed_data; \
})
#define call_glGetUniformBufferSizeEXT(packed, ret_v) do { \
    PACKED_glGetUniformBufferSizeEXT *unpacked = (PACKED_glGetUniformBufferSizeEXT *)packed; \
    ARGS_glGetUniformBufferSizeEXT *args = (ARGS_glGetUniformBufferSizeEXT *)&unpacked->args; \
    GLint *ret = (GLint *)ret_v; \
    if (ret != NULL) { \
        *ret = glGetUniformBufferSizeEXT(args->program, args->location);; \
    } else { \
        glGetUniformBufferSizeEXT(args->program, args->location);; \
    } \
} while(0)
GLint glGetUniformBufferSizeEXT(glGetUniformBufferSizeEXT_ARG_EXPAND);
typedef GLint (*glGetUniformBufferSizeEXT_PTR)(glGetUniformBufferSizeEXT_ARG_EXPAND);
#define glGetUniformIndices_INDEX 1008
#define glGetUniformIndices_RETURN void
#define glGetUniformIndices_ARG_NAMES program, uniformCount, uniformNames, uniformIndices
#define glGetUniformIndices_ARG_EXPAND GLuint program, GLsizei uniformCount, GLchar*const * uniformNames, GLuint * uniformIndices
#define glGetUniformIndices_PACKED PACKED_glGetUniformIndices
#define glGetUniformIndices_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetUniformIndices_NOT_VOID_WRAP(...) {}
#define pack_glGetUniformIndices(_program, _uniformCount, _uniformNames, _uniformIndices) ({ \
    glGetUniformIndices_PACKED *packed_data = malloc(sizeof(glGetUniformIndices_PACKED)); \
    packed_data->index = glGetUniformIndices_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.uniformCount = (GLsizei)_uniformCount; \
    packed_data->args.uniformNames = (GLchar*const *)_uniformNames; \
    packed_data->args.uniformIndices = (GLuint *)_uniformIndices; \
    (packed_call_t *)packed_data; \
})
#define call_glGetUniformIndices(packed, ret_v) do { \
    PACKED_glGetUniformIndices *unpacked = (PACKED_glGetUniformIndices *)packed; \
    ARGS_glGetUniformIndices *args = (ARGS_glGetUniformIndices *)&unpacked->args; \
    glGetUniformIndices(args->program, args->uniformCount, args->uniformNames, args->uniformIndices);; \
} while(0)
void glGetUniformIndices(glGetUniformIndices_ARG_EXPAND);
typedef void (*glGetUniformIndices_PTR)(glGetUniformIndices_ARG_EXPAND);
#define glGetUniformLocation_INDEX 1009
#define glGetUniformLocation_RETURN GLint
#define glGetUniformLocation_ARG_NAMES program, name
#define glGetUniformLocation_ARG_EXPAND GLuint program, const GLchar * name
#define glGetUniformLocation_PACKED PACKED_glGetUniformLocation
#define glGetUniformLocation_VOID_ONLY_WRAP(...) {}
#define glGetUniformLocation_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glGetUniformLocation(_program, _name) ({ \
    glGetUniformLocation_PACKED *packed_data = malloc(sizeof(glGetUniformLocation_PACKED)); \
    packed_data->index = glGetUniformLocation_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.name = (GLchar *)_name; \
    (packed_call_t *)packed_data; \
})
#define call_glGetUniformLocation(packed, ret_v) do { \
    PACKED_glGetUniformLocation *unpacked = (PACKED_glGetUniformLocation *)packed; \
    ARGS_glGetUniformLocation *args = (ARGS_glGetUniformLocation *)&unpacked->args; \
    GLint *ret = (GLint *)ret_v; \
    if (ret != NULL) { \
        *ret = glGetUniformLocation(args->program, args->name);; \
    } else { \
        glGetUniformLocation(args->program, args->name);; \
    } \
} while(0)
GLint glGetUniformLocation(glGetUniformLocation_ARG_EXPAND);
typedef GLint (*glGetUniformLocation_PTR)(glGetUniformLocation_ARG_EXPAND);
#define glGetUniformLocationARB_INDEX 1010
#define glGetUniformLocationARB_RETURN GLint
#define glGetUniformLocationARB_ARG_NAMES programObj, name
#define glGetUniformLocationARB_ARG_EXPAND GLhandleARB programObj, const GLcharARB * name
#define glGetUniformLocationARB_PACKED PACKED_glGetUniformLocationARB
#define glGetUniformLocationARB_VOID_ONLY_WRAP(...) {}
#define glGetUniformLocationARB_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glGetUniformLocationARB(_programObj, _name) ({ \
    glGetUniformLocationARB_PACKED *packed_data = malloc(sizeof(glGetUniformLocationARB_PACKED)); \
    packed_data->index = glGetUniformLocationARB_INDEX; \
    packed_data->args.programObj = (GLhandleARB)_programObj; \
    packed_data->args.name = (GLcharARB *)_name; \
    (packed_call_t *)packed_data; \
})
#define call_glGetUniformLocationARB(packed, ret_v) do { \
    PACKED_glGetUniformLocationARB *unpacked = (PACKED_glGetUniformLocationARB *)packed; \
    ARGS_glGetUniformLocationARB *args = (ARGS_glGetUniformLocationARB *)&unpacked->args; \
    GLint *ret = (GLint *)ret_v; \
    if (ret != NULL) { \
        *ret = glGetUniformLocationARB(args->programObj, args->name);; \
    } else { \
        glGetUniformLocationARB(args->programObj, args->name);; \
    } \
} while(0)
GLint glGetUniformLocationARB(glGetUniformLocationARB_ARG_EXPAND);
typedef GLint (*glGetUniformLocationARB_PTR)(glGetUniformLocationARB_ARG_EXPAND);
#define glGetUniformOffsetEXT_INDEX 1011
#define glGetUniformOffsetEXT_RETURN GLintptr
#define glGetUniformOffsetEXT_ARG_NAMES program, location
#define glGetUniformOffsetEXT_ARG_EXPAND GLuint program, GLint location
#define glGetUniformOffsetEXT_PACKED PACKED_glGetUniformOffsetEXT
#define glGetUniformOffsetEXT_VOID_ONLY_WRAP(...) {}
#define glGetUniformOffsetEXT_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glGetUniformOffsetEXT(_program, _location) ({ \
    glGetUniformOffsetEXT_PACKED *packed_data = malloc(sizeof(glGetUniformOffsetEXT_PACKED)); \
    packed_data->index = glGetUniformOffsetEXT_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    (packed_call_t *)packed_data; \
})
#define call_glGetUniformOffsetEXT(packed, ret_v) do { \
    PACKED_glGetUniformOffsetEXT *unpacked = (PACKED_glGetUniformOffsetEXT *)packed; \
    ARGS_glGetUniformOffsetEXT *args = (ARGS_glGetUniformOffsetEXT *)&unpacked->args; \
    GLintptr *ret = (GLintptr *)ret_v; \
    if (ret != NULL) { \
        *ret = glGetUniformOffsetEXT(args->program, args->location);; \
    } else { \
        glGetUniformOffsetEXT(args->program, args->location);; \
    } \
} while(0)
GLintptr glGetUniformOffsetEXT(glGetUniformOffsetEXT_ARG_EXPAND);
typedef GLintptr (*glGetUniformOffsetEXT_PTR)(glGetUniformOffsetEXT_ARG_EXPAND);
#define glGetUniformSubroutineuiv_INDEX 1012
#define glGetUniformSubroutineuiv_RETURN void
#define glGetUniformSubroutineuiv_ARG_NAMES shadertype, location, params
#define glGetUniformSubroutineuiv_ARG_EXPAND GLenum shadertype, GLint location, GLuint * params
#define glGetUniformSubroutineuiv_PACKED PACKED_glGetUniformSubroutineuiv
#define glGetUniformSubroutineuiv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetUniformSubroutineuiv_NOT_VOID_WRAP(...) {}
#define pack_glGetUniformSubroutineuiv(_shadertype, _location, _params) ({ \
    glGetUniformSubroutineuiv_PACKED *packed_data = malloc(sizeof(glGetUniformSubroutineuiv_PACKED)); \
    packed_data->index = glGetUniformSubroutineuiv_INDEX; \
    packed_data->args.shadertype = (GLenum)_shadertype; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.params = (GLuint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetUniformSubroutineuiv(packed, ret_v) do { \
    PACKED_glGetUniformSubroutineuiv *unpacked = (PACKED_glGetUniformSubroutineuiv *)packed; \
    ARGS_glGetUniformSubroutineuiv *args = (ARGS_glGetUniformSubroutineuiv *)&unpacked->args; \
    glGetUniformSubroutineuiv(args->shadertype, args->location, args->params);; \
} while(0)
void glGetUniformSubroutineuiv(glGetUniformSubroutineuiv_ARG_EXPAND);
typedef void (*glGetUniformSubroutineuiv_PTR)(glGetUniformSubroutineuiv_ARG_EXPAND);
#define glGetUniformdv_INDEX 1013
#define glGetUniformdv_RETURN void
#define glGetUniformdv_ARG_NAMES program, location, params
#define glGetUniformdv_ARG_EXPAND GLuint program, GLint location, GLdouble * params
#define glGetUniformdv_PACKED PACKED_glGetUniformdv
#define glGetUniformdv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetUniformdv_NOT_VOID_WRAP(...) {}
#define pack_glGetUniformdv(_program, _location, _params) ({ \
    glGetUniformdv_PACKED *packed_data = malloc(sizeof(glGetUniformdv_PACKED)); \
    packed_data->index = glGetUniformdv_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.params = (GLdouble *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetUniformdv(packed, ret_v) do { \
    PACKED_glGetUniformdv *unpacked = (PACKED_glGetUniformdv *)packed; \
    ARGS_glGetUniformdv *args = (ARGS_glGetUniformdv *)&unpacked->args; \
    glGetUniformdv(args->program, args->location, args->params);; \
} while(0)
void glGetUniformdv(glGetUniformdv_ARG_EXPAND);
typedef void (*glGetUniformdv_PTR)(glGetUniformdv_ARG_EXPAND);
#define glGetUniformfv_INDEX 1014
#define glGetUniformfv_RETURN void
#define glGetUniformfv_ARG_NAMES program, location, params
#define glGetUniformfv_ARG_EXPAND GLuint program, GLint location, GLfloat * params
#define glGetUniformfv_PACKED PACKED_glGetUniformfv
#define glGetUniformfv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetUniformfv_NOT_VOID_WRAP(...) {}
#define pack_glGetUniformfv(_program, _location, _params) ({ \
    glGetUniformfv_PACKED *packed_data = malloc(sizeof(glGetUniformfv_PACKED)); \
    packed_data->index = glGetUniformfv_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.params = (GLfloat *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetUniformfv(packed, ret_v) do { \
    PACKED_glGetUniformfv *unpacked = (PACKED_glGetUniformfv *)packed; \
    ARGS_glGetUniformfv *args = (ARGS_glGetUniformfv *)&unpacked->args; \
    glGetUniformfv(args->program, args->location, args->params);; \
} while(0)
void glGetUniformfv(glGetUniformfv_ARG_EXPAND);
typedef void (*glGetUniformfv_PTR)(glGetUniformfv_ARG_EXPAND);
#define glGetUniformfvARB_INDEX 1015
#define glGetUniformfvARB_RETURN void
#define glGetUniformfvARB_ARG_NAMES programObj, location, params
#define glGetUniformfvARB_ARG_EXPAND GLhandleARB programObj, GLint location, GLfloat * params
#define glGetUniformfvARB_PACKED PACKED_glGetUniformfvARB
#define glGetUniformfvARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetUniformfvARB_NOT_VOID_WRAP(...) {}
#define pack_glGetUniformfvARB(_programObj, _location, _params) ({ \
    glGetUniformfvARB_PACKED *packed_data = malloc(sizeof(glGetUniformfvARB_PACKED)); \
    packed_data->index = glGetUniformfvARB_INDEX; \
    packed_data->args.programObj = (GLhandleARB)_programObj; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.params = (GLfloat *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetUniformfvARB(packed, ret_v) do { \
    PACKED_glGetUniformfvARB *unpacked = (PACKED_glGetUniformfvARB *)packed; \
    ARGS_glGetUniformfvARB *args = (ARGS_glGetUniformfvARB *)&unpacked->args; \
    glGetUniformfvARB(args->programObj, args->location, args->params);; \
} while(0)
void glGetUniformfvARB(glGetUniformfvARB_ARG_EXPAND);
typedef void (*glGetUniformfvARB_PTR)(glGetUniformfvARB_ARG_EXPAND);
#define glGetUniformi64vNV_INDEX 1016
#define glGetUniformi64vNV_RETURN void
#define glGetUniformi64vNV_ARG_NAMES program, location, params
#define glGetUniformi64vNV_ARG_EXPAND GLuint program, GLint location, GLint64EXT * params
#define glGetUniformi64vNV_PACKED PACKED_glGetUniformi64vNV
#define glGetUniformi64vNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetUniformi64vNV_NOT_VOID_WRAP(...) {}
#define pack_glGetUniformi64vNV(_program, _location, _params) ({ \
    glGetUniformi64vNV_PACKED *packed_data = malloc(sizeof(glGetUniformi64vNV_PACKED)); \
    packed_data->index = glGetUniformi64vNV_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.params = (GLint64EXT *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetUniformi64vNV(packed, ret_v) do { \
    PACKED_glGetUniformi64vNV *unpacked = (PACKED_glGetUniformi64vNV *)packed; \
    ARGS_glGetUniformi64vNV *args = (ARGS_glGetUniformi64vNV *)&unpacked->args; \
    glGetUniformi64vNV(args->program, args->location, args->params);; \
} while(0)
void glGetUniformi64vNV(glGetUniformi64vNV_ARG_EXPAND);
typedef void (*glGetUniformi64vNV_PTR)(glGetUniformi64vNV_ARG_EXPAND);
#define glGetUniformiv_INDEX 1017
#define glGetUniformiv_RETURN void
#define glGetUniformiv_ARG_NAMES program, location, params
#define glGetUniformiv_ARG_EXPAND GLuint program, GLint location, GLint * params
#define glGetUniformiv_PACKED PACKED_glGetUniformiv
#define glGetUniformiv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetUniformiv_NOT_VOID_WRAP(...) {}
#define pack_glGetUniformiv(_program, _location, _params) ({ \
    glGetUniformiv_PACKED *packed_data = malloc(sizeof(glGetUniformiv_PACKED)); \
    packed_data->index = glGetUniformiv_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.params = (GLint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetUniformiv(packed, ret_v) do { \
    PACKED_glGetUniformiv *unpacked = (PACKED_glGetUniformiv *)packed; \
    ARGS_glGetUniformiv *args = (ARGS_glGetUniformiv *)&unpacked->args; \
    glGetUniformiv(args->program, args->location, args->params);; \
} while(0)
void glGetUniformiv(glGetUniformiv_ARG_EXPAND);
typedef void (*glGetUniformiv_PTR)(glGetUniformiv_ARG_EXPAND);
#define glGetUniformivARB_INDEX 1018
#define glGetUniformivARB_RETURN void
#define glGetUniformivARB_ARG_NAMES programObj, location, params
#define glGetUniformivARB_ARG_EXPAND GLhandleARB programObj, GLint location, GLint * params
#define glGetUniformivARB_PACKED PACKED_glGetUniformivARB
#define glGetUniformivARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetUniformivARB_NOT_VOID_WRAP(...) {}
#define pack_glGetUniformivARB(_programObj, _location, _params) ({ \
    glGetUniformivARB_PACKED *packed_data = malloc(sizeof(glGetUniformivARB_PACKED)); \
    packed_data->index = glGetUniformivARB_INDEX; \
    packed_data->args.programObj = (GLhandleARB)_programObj; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.params = (GLint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetUniformivARB(packed, ret_v) do { \
    PACKED_glGetUniformivARB *unpacked = (PACKED_glGetUniformivARB *)packed; \
    ARGS_glGetUniformivARB *args = (ARGS_glGetUniformivARB *)&unpacked->args; \
    glGetUniformivARB(args->programObj, args->location, args->params);; \
} while(0)
void glGetUniformivARB(glGetUniformivARB_ARG_EXPAND);
typedef void (*glGetUniformivARB_PTR)(glGetUniformivARB_ARG_EXPAND);
#define glGetUniformui64vNV_INDEX 1019
#define glGetUniformui64vNV_RETURN void
#define glGetUniformui64vNV_ARG_NAMES program, location, params
#define glGetUniformui64vNV_ARG_EXPAND GLuint program, GLint location, GLuint64EXT * params
#define glGetUniformui64vNV_PACKED PACKED_glGetUniformui64vNV
#define glGetUniformui64vNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetUniformui64vNV_NOT_VOID_WRAP(...) {}
#define pack_glGetUniformui64vNV(_program, _location, _params) ({ \
    glGetUniformui64vNV_PACKED *packed_data = malloc(sizeof(glGetUniformui64vNV_PACKED)); \
    packed_data->index = glGetUniformui64vNV_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.params = (GLuint64EXT *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetUniformui64vNV(packed, ret_v) do { \
    PACKED_glGetUniformui64vNV *unpacked = (PACKED_glGetUniformui64vNV *)packed; \
    ARGS_glGetUniformui64vNV *args = (ARGS_glGetUniformui64vNV *)&unpacked->args; \
    glGetUniformui64vNV(args->program, args->location, args->params);; \
} while(0)
void glGetUniformui64vNV(glGetUniformui64vNV_ARG_EXPAND);
typedef void (*glGetUniformui64vNV_PTR)(glGetUniformui64vNV_ARG_EXPAND);
#define glGetUniformuiv_INDEX 1020
#define glGetUniformuiv_RETURN void
#define glGetUniformuiv_ARG_NAMES program, location, params
#define glGetUniformuiv_ARG_EXPAND GLuint program, GLint location, GLuint * params
#define glGetUniformuiv_PACKED PACKED_glGetUniformuiv
#define glGetUniformuiv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetUniformuiv_NOT_VOID_WRAP(...) {}
#define pack_glGetUniformuiv(_program, _location, _params) ({ \
    glGetUniformuiv_PACKED *packed_data = malloc(sizeof(glGetUniformuiv_PACKED)); \
    packed_data->index = glGetUniformuiv_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.params = (GLuint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetUniformuiv(packed, ret_v) do { \
    PACKED_glGetUniformuiv *unpacked = (PACKED_glGetUniformuiv *)packed; \
    ARGS_glGetUniformuiv *args = (ARGS_glGetUniformuiv *)&unpacked->args; \
    glGetUniformuiv(args->program, args->location, args->params);; \
} while(0)
void glGetUniformuiv(glGetUniformuiv_ARG_EXPAND);
typedef void (*glGetUniformuiv_PTR)(glGetUniformuiv_ARG_EXPAND);
#define glGetUniformuivEXT_INDEX 1021
#define glGetUniformuivEXT_RETURN void
#define glGetUniformuivEXT_ARG_NAMES program, location, params
#define glGetUniformuivEXT_ARG_EXPAND GLuint program, GLint location, GLuint * params
#define glGetUniformuivEXT_PACKED PACKED_glGetUniformuivEXT
#define glGetUniformuivEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetUniformuivEXT_NOT_VOID_WRAP(...) {}
#define pack_glGetUniformuivEXT(_program, _location, _params) ({ \
    glGetUniformuivEXT_PACKED *packed_data = malloc(sizeof(glGetUniformuivEXT_PACKED)); \
    packed_data->index = glGetUniformuivEXT_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.params = (GLuint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetUniformuivEXT(packed, ret_v) do { \
    PACKED_glGetUniformuivEXT *unpacked = (PACKED_glGetUniformuivEXT *)packed; \
    ARGS_glGetUniformuivEXT *args = (ARGS_glGetUniformuivEXT *)&unpacked->args; \
    glGetUniformuivEXT(args->program, args->location, args->params);; \
} while(0)
void glGetUniformuivEXT(glGetUniformuivEXT_ARG_EXPAND);
typedef void (*glGetUniformuivEXT_PTR)(glGetUniformuivEXT_ARG_EXPAND);
#define glGetVariantArrayObjectfvATI_INDEX 1022
#define glGetVariantArrayObjectfvATI_RETURN void
#define glGetVariantArrayObjectfvATI_ARG_NAMES id, pname, params
#define glGetVariantArrayObjectfvATI_ARG_EXPAND GLuint id, GLenum pname, GLfloat * params
#define glGetVariantArrayObjectfvATI_PACKED PACKED_glGetVariantArrayObjectfvATI
#define glGetVariantArrayObjectfvATI_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetVariantArrayObjectfvATI_NOT_VOID_WRAP(...) {}
#define pack_glGetVariantArrayObjectfvATI(_id, _pname, _params) ({ \
    glGetVariantArrayObjectfvATI_PACKED *packed_data = malloc(sizeof(glGetVariantArrayObjectfvATI_PACKED)); \
    packed_data->index = glGetVariantArrayObjectfvATI_INDEX; \
    packed_data->args.id = (GLuint)_id; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLfloat *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetVariantArrayObjectfvATI(packed, ret_v) do { \
    PACKED_glGetVariantArrayObjectfvATI *unpacked = (PACKED_glGetVariantArrayObjectfvATI *)packed; \
    ARGS_glGetVariantArrayObjectfvATI *args = (ARGS_glGetVariantArrayObjectfvATI *)&unpacked->args; \
    glGetVariantArrayObjectfvATI(args->id, args->pname, args->params);; \
} while(0)
void glGetVariantArrayObjectfvATI(glGetVariantArrayObjectfvATI_ARG_EXPAND);
typedef void (*glGetVariantArrayObjectfvATI_PTR)(glGetVariantArrayObjectfvATI_ARG_EXPAND);
#define glGetVariantArrayObjectivATI_INDEX 1023
#define glGetVariantArrayObjectivATI_RETURN void
#define glGetVariantArrayObjectivATI_ARG_NAMES id, pname, params
#define glGetVariantArrayObjectivATI_ARG_EXPAND GLuint id, GLenum pname, GLint * params
#define glGetVariantArrayObjectivATI_PACKED PACKED_glGetVariantArrayObjectivATI
#define glGetVariantArrayObjectivATI_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetVariantArrayObjectivATI_NOT_VOID_WRAP(...) {}
#define pack_glGetVariantArrayObjectivATI(_id, _pname, _params) ({ \
    glGetVariantArrayObjectivATI_PACKED *packed_data = malloc(sizeof(glGetVariantArrayObjectivATI_PACKED)); \
    packed_data->index = glGetVariantArrayObjectivATI_INDEX; \
    packed_data->args.id = (GLuint)_id; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetVariantArrayObjectivATI(packed, ret_v) do { \
    PACKED_glGetVariantArrayObjectivATI *unpacked = (PACKED_glGetVariantArrayObjectivATI *)packed; \
    ARGS_glGetVariantArrayObjectivATI *args = (ARGS_glGetVariantArrayObjectivATI *)&unpacked->args; \
    glGetVariantArrayObjectivATI(args->id, args->pname, args->params);; \
} while(0)
void glGetVariantArrayObjectivATI(glGetVariantArrayObjectivATI_ARG_EXPAND);
typedef void (*glGetVariantArrayObjectivATI_PTR)(glGetVariantArrayObjectivATI_ARG_EXPAND);
#define glGetVariantBooleanvEXT_INDEX 1024
#define glGetVariantBooleanvEXT_RETURN void
#define glGetVariantBooleanvEXT_ARG_NAMES id, value, data
#define glGetVariantBooleanvEXT_ARG_EXPAND GLuint id, GLenum value, GLboolean * data
#define glGetVariantBooleanvEXT_PACKED PACKED_glGetVariantBooleanvEXT
#define glGetVariantBooleanvEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetVariantBooleanvEXT_NOT_VOID_WRAP(...) {}
#define pack_glGetVariantBooleanvEXT(_id, _value, _data) ({ \
    glGetVariantBooleanvEXT_PACKED *packed_data = malloc(sizeof(glGetVariantBooleanvEXT_PACKED)); \
    packed_data->index = glGetVariantBooleanvEXT_INDEX; \
    packed_data->args.id = (GLuint)_id; \
    packed_data->args.value = (GLenum)_value; \
    packed_data->args.data = (GLboolean *)_data; \
    (packed_call_t *)packed_data; \
})
#define call_glGetVariantBooleanvEXT(packed, ret_v) do { \
    PACKED_glGetVariantBooleanvEXT *unpacked = (PACKED_glGetVariantBooleanvEXT *)packed; \
    ARGS_glGetVariantBooleanvEXT *args = (ARGS_glGetVariantBooleanvEXT *)&unpacked->args; \
    glGetVariantBooleanvEXT(args->id, args->value, args->data);; \
} while(0)
void glGetVariantBooleanvEXT(glGetVariantBooleanvEXT_ARG_EXPAND);
typedef void (*glGetVariantBooleanvEXT_PTR)(glGetVariantBooleanvEXT_ARG_EXPAND);
#define glGetVariantFloatvEXT_INDEX 1025
#define glGetVariantFloatvEXT_RETURN void
#define glGetVariantFloatvEXT_ARG_NAMES id, value, data
#define glGetVariantFloatvEXT_ARG_EXPAND GLuint id, GLenum value, GLfloat * data
#define glGetVariantFloatvEXT_PACKED PACKED_glGetVariantFloatvEXT
#define glGetVariantFloatvEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetVariantFloatvEXT_NOT_VOID_WRAP(...) {}
#define pack_glGetVariantFloatvEXT(_id, _value, _data) ({ \
    glGetVariantFloatvEXT_PACKED *packed_data = malloc(sizeof(glGetVariantFloatvEXT_PACKED)); \
    packed_data->index = glGetVariantFloatvEXT_INDEX; \
    packed_data->args.id = (GLuint)_id; \
    packed_data->args.value = (GLenum)_value; \
    packed_data->args.data = (GLfloat *)_data; \
    (packed_call_t *)packed_data; \
})
#define call_glGetVariantFloatvEXT(packed, ret_v) do { \
    PACKED_glGetVariantFloatvEXT *unpacked = (PACKED_glGetVariantFloatvEXT *)packed; \
    ARGS_glGetVariantFloatvEXT *args = (ARGS_glGetVariantFloatvEXT *)&unpacked->args; \
    glGetVariantFloatvEXT(args->id, args->value, args->data);; \
} while(0)
void glGetVariantFloatvEXT(glGetVariantFloatvEXT_ARG_EXPAND);
typedef void (*glGetVariantFloatvEXT_PTR)(glGetVariantFloatvEXT_ARG_EXPAND);
#define glGetVariantIntegervEXT_INDEX 1026
#define glGetVariantIntegervEXT_RETURN void
#define glGetVariantIntegervEXT_ARG_NAMES id, value, data
#define glGetVariantIntegervEXT_ARG_EXPAND GLuint id, GLenum value, GLint * data
#define glGetVariantIntegervEXT_PACKED PACKED_glGetVariantIntegervEXT
#define glGetVariantIntegervEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetVariantIntegervEXT_NOT_VOID_WRAP(...) {}
#define pack_glGetVariantIntegervEXT(_id, _value, _data) ({ \
    glGetVariantIntegervEXT_PACKED *packed_data = malloc(sizeof(glGetVariantIntegervEXT_PACKED)); \
    packed_data->index = glGetVariantIntegervEXT_INDEX; \
    packed_data->args.id = (GLuint)_id; \
    packed_data->args.value = (GLenum)_value; \
    packed_data->args.data = (GLint *)_data; \
    (packed_call_t *)packed_data; \
})
#define call_glGetVariantIntegervEXT(packed, ret_v) do { \
    PACKED_glGetVariantIntegervEXT *unpacked = (PACKED_glGetVariantIntegervEXT *)packed; \
    ARGS_glGetVariantIntegervEXT *args = (ARGS_glGetVariantIntegervEXT *)&unpacked->args; \
    glGetVariantIntegervEXT(args->id, args->value, args->data);; \
} while(0)
void glGetVariantIntegervEXT(glGetVariantIntegervEXT_ARG_EXPAND);
typedef void (*glGetVariantIntegervEXT_PTR)(glGetVariantIntegervEXT_ARG_EXPAND);
#define glGetVariantPointervEXT_INDEX 1027
#define glGetVariantPointervEXT_RETURN void
#define glGetVariantPointervEXT_ARG_NAMES id, value, data
#define glGetVariantPointervEXT_ARG_EXPAND GLuint id, GLenum value, GLvoid * data
#define glGetVariantPointervEXT_PACKED PACKED_glGetVariantPointervEXT
#define glGetVariantPointervEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetVariantPointervEXT_NOT_VOID_WRAP(...) {}
#define pack_glGetVariantPointervEXT(_id, _value, _data) ({ \
    glGetVariantPointervEXT_PACKED *packed_data = malloc(sizeof(glGetVariantPointervEXT_PACKED)); \
    packed_data->index = glGetVariantPointervEXT_INDEX; \
    packed_data->args.id = (GLuint)_id; \
    packed_data->args.value = (GLenum)_value; \
    packed_data->args.data = (GLvoid *)_data; \
    (packed_call_t *)packed_data; \
})
#define call_glGetVariantPointervEXT(packed, ret_v) do { \
    PACKED_glGetVariantPointervEXT *unpacked = (PACKED_glGetVariantPointervEXT *)packed; \
    ARGS_glGetVariantPointervEXT *args = (ARGS_glGetVariantPointervEXT *)&unpacked->args; \
    glGetVariantPointervEXT(args->id, args->value, args->data);; \
} while(0)
void glGetVariantPointervEXT(glGetVariantPointervEXT_ARG_EXPAND);
typedef void (*glGetVariantPointervEXT_PTR)(glGetVariantPointervEXT_ARG_EXPAND);
#define glGetVaryingLocationNV_INDEX 1028
#define glGetVaryingLocationNV_RETURN GLint
#define glGetVaryingLocationNV_ARG_NAMES program, name
#define glGetVaryingLocationNV_ARG_EXPAND GLuint program, const GLchar * name
#define glGetVaryingLocationNV_PACKED PACKED_glGetVaryingLocationNV
#define glGetVaryingLocationNV_VOID_ONLY_WRAP(...) {}
#define glGetVaryingLocationNV_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glGetVaryingLocationNV(_program, _name) ({ \
    glGetVaryingLocationNV_PACKED *packed_data = malloc(sizeof(glGetVaryingLocationNV_PACKED)); \
    packed_data->index = glGetVaryingLocationNV_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.name = (GLchar *)_name; \
    (packed_call_t *)packed_data; \
})
#define call_glGetVaryingLocationNV(packed, ret_v) do { \
    PACKED_glGetVaryingLocationNV *unpacked = (PACKED_glGetVaryingLocationNV *)packed; \
    ARGS_glGetVaryingLocationNV *args = (ARGS_glGetVaryingLocationNV *)&unpacked->args; \
    GLint *ret = (GLint *)ret_v; \
    if (ret != NULL) { \
        *ret = glGetVaryingLocationNV(args->program, args->name);; \
    } else { \
        glGetVaryingLocationNV(args->program, args->name);; \
    } \
} while(0)
GLint glGetVaryingLocationNV(glGetVaryingLocationNV_ARG_EXPAND);
typedef GLint (*glGetVaryingLocationNV_PTR)(glGetVaryingLocationNV_ARG_EXPAND);
#define glGetVertexArrayIntegeri_vEXT_INDEX 1029
#define glGetVertexArrayIntegeri_vEXT_RETURN void
#define glGetVertexArrayIntegeri_vEXT_ARG_NAMES vaobj, index, pname, param
#define glGetVertexArrayIntegeri_vEXT_ARG_EXPAND GLuint vaobj, GLuint index, GLenum pname, GLint * param
#define glGetVertexArrayIntegeri_vEXT_PACKED PACKED_glGetVertexArrayIntegeri_vEXT
#define glGetVertexArrayIntegeri_vEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetVertexArrayIntegeri_vEXT_NOT_VOID_WRAP(...) {}
#define pack_glGetVertexArrayIntegeri_vEXT(_vaobj, _index, _pname, _param) ({ \
    glGetVertexArrayIntegeri_vEXT_PACKED *packed_data = malloc(sizeof(glGetVertexArrayIntegeri_vEXT_PACKED)); \
    packed_data->index = glGetVertexArrayIntegeri_vEXT_INDEX; \
    packed_data->args.vaobj = (GLuint)_vaobj; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.param = (GLint *)_param; \
    (packed_call_t *)packed_data; \
})
#define call_glGetVertexArrayIntegeri_vEXT(packed, ret_v) do { \
    PACKED_glGetVertexArrayIntegeri_vEXT *unpacked = (PACKED_glGetVertexArrayIntegeri_vEXT *)packed; \
    ARGS_glGetVertexArrayIntegeri_vEXT *args = (ARGS_glGetVertexArrayIntegeri_vEXT *)&unpacked->args; \
    glGetVertexArrayIntegeri_vEXT(args->vaobj, args->index, args->pname, args->param);; \
} while(0)
void glGetVertexArrayIntegeri_vEXT(glGetVertexArrayIntegeri_vEXT_ARG_EXPAND);
typedef void (*glGetVertexArrayIntegeri_vEXT_PTR)(glGetVertexArrayIntegeri_vEXT_ARG_EXPAND);
#define glGetVertexArrayIntegervEXT_INDEX 1030
#define glGetVertexArrayIntegervEXT_RETURN void
#define glGetVertexArrayIntegervEXT_ARG_NAMES vaobj, pname, param
#define glGetVertexArrayIntegervEXT_ARG_EXPAND GLuint vaobj, GLenum pname, GLint * param
#define glGetVertexArrayIntegervEXT_PACKED PACKED_glGetVertexArrayIntegervEXT
#define glGetVertexArrayIntegervEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetVertexArrayIntegervEXT_NOT_VOID_WRAP(...) {}
#define pack_glGetVertexArrayIntegervEXT(_vaobj, _pname, _param) ({ \
    glGetVertexArrayIntegervEXT_PACKED *packed_data = malloc(sizeof(glGetVertexArrayIntegervEXT_PACKED)); \
    packed_data->index = glGetVertexArrayIntegervEXT_INDEX; \
    packed_data->args.vaobj = (GLuint)_vaobj; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.param = (GLint *)_param; \
    (packed_call_t *)packed_data; \
})
#define call_glGetVertexArrayIntegervEXT(packed, ret_v) do { \
    PACKED_glGetVertexArrayIntegervEXT *unpacked = (PACKED_glGetVertexArrayIntegervEXT *)packed; \
    ARGS_glGetVertexArrayIntegervEXT *args = (ARGS_glGetVertexArrayIntegervEXT *)&unpacked->args; \
    glGetVertexArrayIntegervEXT(args->vaobj, args->pname, args->param);; \
} while(0)
void glGetVertexArrayIntegervEXT(glGetVertexArrayIntegervEXT_ARG_EXPAND);
typedef void (*glGetVertexArrayIntegervEXT_PTR)(glGetVertexArrayIntegervEXT_ARG_EXPAND);
#define glGetVertexArrayPointeri_vEXT_INDEX 1031
#define glGetVertexArrayPointeri_vEXT_RETURN void
#define glGetVertexArrayPointeri_vEXT_ARG_NAMES vaobj, index, pname, param
#define glGetVertexArrayPointeri_vEXT_ARG_EXPAND GLuint vaobj, GLuint index, GLenum pname, GLvoid * param
#define glGetVertexArrayPointeri_vEXT_PACKED PACKED_glGetVertexArrayPointeri_vEXT
#define glGetVertexArrayPointeri_vEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetVertexArrayPointeri_vEXT_NOT_VOID_WRAP(...) {}
#define pack_glGetVertexArrayPointeri_vEXT(_vaobj, _index, _pname, _param) ({ \
    glGetVertexArrayPointeri_vEXT_PACKED *packed_data = malloc(sizeof(glGetVertexArrayPointeri_vEXT_PACKED)); \
    packed_data->index = glGetVertexArrayPointeri_vEXT_INDEX; \
    packed_data->args.vaobj = (GLuint)_vaobj; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.param = (GLvoid *)_param; \
    (packed_call_t *)packed_data; \
})
#define call_glGetVertexArrayPointeri_vEXT(packed, ret_v) do { \
    PACKED_glGetVertexArrayPointeri_vEXT *unpacked = (PACKED_glGetVertexArrayPointeri_vEXT *)packed; \
    ARGS_glGetVertexArrayPointeri_vEXT *args = (ARGS_glGetVertexArrayPointeri_vEXT *)&unpacked->args; \
    glGetVertexArrayPointeri_vEXT(args->vaobj, args->index, args->pname, args->param);; \
} while(0)
void glGetVertexArrayPointeri_vEXT(glGetVertexArrayPointeri_vEXT_ARG_EXPAND);
typedef void (*glGetVertexArrayPointeri_vEXT_PTR)(glGetVertexArrayPointeri_vEXT_ARG_EXPAND);
#define glGetVertexArrayPointervEXT_INDEX 1032
#define glGetVertexArrayPointervEXT_RETURN void
#define glGetVertexArrayPointervEXT_ARG_NAMES vaobj, pname, param
#define glGetVertexArrayPointervEXT_ARG_EXPAND GLuint vaobj, GLenum pname, GLvoid * param
#define glGetVertexArrayPointervEXT_PACKED PACKED_glGetVertexArrayPointervEXT
#define glGetVertexArrayPointervEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetVertexArrayPointervEXT_NOT_VOID_WRAP(...) {}
#define pack_glGetVertexArrayPointervEXT(_vaobj, _pname, _param) ({ \
    glGetVertexArrayPointervEXT_PACKED *packed_data = malloc(sizeof(glGetVertexArrayPointervEXT_PACKED)); \
    packed_data->index = glGetVertexArrayPointervEXT_INDEX; \
    packed_data->args.vaobj = (GLuint)_vaobj; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.param = (GLvoid *)_param; \
    (packed_call_t *)packed_data; \
})
#define call_glGetVertexArrayPointervEXT(packed, ret_v) do { \
    PACKED_glGetVertexArrayPointervEXT *unpacked = (PACKED_glGetVertexArrayPointervEXT *)packed; \
    ARGS_glGetVertexArrayPointervEXT *args = (ARGS_glGetVertexArrayPointervEXT *)&unpacked->args; \
    glGetVertexArrayPointervEXT(args->vaobj, args->pname, args->param);; \
} while(0)
void glGetVertexArrayPointervEXT(glGetVertexArrayPointervEXT_ARG_EXPAND);
typedef void (*glGetVertexArrayPointervEXT_PTR)(glGetVertexArrayPointervEXT_ARG_EXPAND);
#define glGetVertexAttribArrayObjectfvATI_INDEX 1033
#define glGetVertexAttribArrayObjectfvATI_RETURN void
#define glGetVertexAttribArrayObjectfvATI_ARG_NAMES index, pname, params
#define glGetVertexAttribArrayObjectfvATI_ARG_EXPAND GLuint index, GLenum pname, GLfloat * params
#define glGetVertexAttribArrayObjectfvATI_PACKED PACKED_glGetVertexAttribArrayObjectfvATI
#define glGetVertexAttribArrayObjectfvATI_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetVertexAttribArrayObjectfvATI_NOT_VOID_WRAP(...) {}
#define pack_glGetVertexAttribArrayObjectfvATI(_index, _pname, _params) ({ \
    glGetVertexAttribArrayObjectfvATI_PACKED *packed_data = malloc(sizeof(glGetVertexAttribArrayObjectfvATI_PACKED)); \
    packed_data->index = glGetVertexAttribArrayObjectfvATI_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLfloat *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetVertexAttribArrayObjectfvATI(packed, ret_v) do { \
    PACKED_glGetVertexAttribArrayObjectfvATI *unpacked = (PACKED_glGetVertexAttribArrayObjectfvATI *)packed; \
    ARGS_glGetVertexAttribArrayObjectfvATI *args = (ARGS_glGetVertexAttribArrayObjectfvATI *)&unpacked->args; \
    glGetVertexAttribArrayObjectfvATI(args->index, args->pname, args->params);; \
} while(0)
void glGetVertexAttribArrayObjectfvATI(glGetVertexAttribArrayObjectfvATI_ARG_EXPAND);
typedef void (*glGetVertexAttribArrayObjectfvATI_PTR)(glGetVertexAttribArrayObjectfvATI_ARG_EXPAND);
#define glGetVertexAttribArrayObjectivATI_INDEX 1034
#define glGetVertexAttribArrayObjectivATI_RETURN void
#define glGetVertexAttribArrayObjectivATI_ARG_NAMES index, pname, params
#define glGetVertexAttribArrayObjectivATI_ARG_EXPAND GLuint index, GLenum pname, GLint * params
#define glGetVertexAttribArrayObjectivATI_PACKED PACKED_glGetVertexAttribArrayObjectivATI
#define glGetVertexAttribArrayObjectivATI_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetVertexAttribArrayObjectivATI_NOT_VOID_WRAP(...) {}
#define pack_glGetVertexAttribArrayObjectivATI(_index, _pname, _params) ({ \
    glGetVertexAttribArrayObjectivATI_PACKED *packed_data = malloc(sizeof(glGetVertexAttribArrayObjectivATI_PACKED)); \
    packed_data->index = glGetVertexAttribArrayObjectivATI_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetVertexAttribArrayObjectivATI(packed, ret_v) do { \
    PACKED_glGetVertexAttribArrayObjectivATI *unpacked = (PACKED_glGetVertexAttribArrayObjectivATI *)packed; \
    ARGS_glGetVertexAttribArrayObjectivATI *args = (ARGS_glGetVertexAttribArrayObjectivATI *)&unpacked->args; \
    glGetVertexAttribArrayObjectivATI(args->index, args->pname, args->params);; \
} while(0)
void glGetVertexAttribArrayObjectivATI(glGetVertexAttribArrayObjectivATI_ARG_EXPAND);
typedef void (*glGetVertexAttribArrayObjectivATI_PTR)(glGetVertexAttribArrayObjectivATI_ARG_EXPAND);
#define glGetVertexAttribIiv_INDEX 1035
#define glGetVertexAttribIiv_RETURN void
#define glGetVertexAttribIiv_ARG_NAMES index, pname, params
#define glGetVertexAttribIiv_ARG_EXPAND GLuint index, GLenum pname, GLint * params
#define glGetVertexAttribIiv_PACKED PACKED_glGetVertexAttribIiv
#define glGetVertexAttribIiv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetVertexAttribIiv_NOT_VOID_WRAP(...) {}
#define pack_glGetVertexAttribIiv(_index, _pname, _params) ({ \
    glGetVertexAttribIiv_PACKED *packed_data = malloc(sizeof(glGetVertexAttribIiv_PACKED)); \
    packed_data->index = glGetVertexAttribIiv_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetVertexAttribIiv(packed, ret_v) do { \
    PACKED_glGetVertexAttribIiv *unpacked = (PACKED_glGetVertexAttribIiv *)packed; \
    ARGS_glGetVertexAttribIiv *args = (ARGS_glGetVertexAttribIiv *)&unpacked->args; \
    glGetVertexAttribIiv(args->index, args->pname, args->params);; \
} while(0)
void glGetVertexAttribIiv(glGetVertexAttribIiv_ARG_EXPAND);
typedef void (*glGetVertexAttribIiv_PTR)(glGetVertexAttribIiv_ARG_EXPAND);
#define glGetVertexAttribIivEXT_INDEX 1036
#define glGetVertexAttribIivEXT_RETURN void
#define glGetVertexAttribIivEXT_ARG_NAMES index, pname, params
#define glGetVertexAttribIivEXT_ARG_EXPAND GLuint index, GLenum pname, GLint * params
#define glGetVertexAttribIivEXT_PACKED PACKED_glGetVertexAttribIivEXT
#define glGetVertexAttribIivEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetVertexAttribIivEXT_NOT_VOID_WRAP(...) {}
#define pack_glGetVertexAttribIivEXT(_index, _pname, _params) ({ \
    glGetVertexAttribIivEXT_PACKED *packed_data = malloc(sizeof(glGetVertexAttribIivEXT_PACKED)); \
    packed_data->index = glGetVertexAttribIivEXT_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetVertexAttribIivEXT(packed, ret_v) do { \
    PACKED_glGetVertexAttribIivEXT *unpacked = (PACKED_glGetVertexAttribIivEXT *)packed; \
    ARGS_glGetVertexAttribIivEXT *args = (ARGS_glGetVertexAttribIivEXT *)&unpacked->args; \
    glGetVertexAttribIivEXT(args->index, args->pname, args->params);; \
} while(0)
void glGetVertexAttribIivEXT(glGetVertexAttribIivEXT_ARG_EXPAND);
typedef void (*glGetVertexAttribIivEXT_PTR)(glGetVertexAttribIivEXT_ARG_EXPAND);
#define glGetVertexAttribIuiv_INDEX 1037
#define glGetVertexAttribIuiv_RETURN void
#define glGetVertexAttribIuiv_ARG_NAMES index, pname, params
#define glGetVertexAttribIuiv_ARG_EXPAND GLuint index, GLenum pname, GLuint * params
#define glGetVertexAttribIuiv_PACKED PACKED_glGetVertexAttribIuiv
#define glGetVertexAttribIuiv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetVertexAttribIuiv_NOT_VOID_WRAP(...) {}
#define pack_glGetVertexAttribIuiv(_index, _pname, _params) ({ \
    glGetVertexAttribIuiv_PACKED *packed_data = malloc(sizeof(glGetVertexAttribIuiv_PACKED)); \
    packed_data->index = glGetVertexAttribIuiv_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLuint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetVertexAttribIuiv(packed, ret_v) do { \
    PACKED_glGetVertexAttribIuiv *unpacked = (PACKED_glGetVertexAttribIuiv *)packed; \
    ARGS_glGetVertexAttribIuiv *args = (ARGS_glGetVertexAttribIuiv *)&unpacked->args; \
    glGetVertexAttribIuiv(args->index, args->pname, args->params);; \
} while(0)
void glGetVertexAttribIuiv(glGetVertexAttribIuiv_ARG_EXPAND);
typedef void (*glGetVertexAttribIuiv_PTR)(glGetVertexAttribIuiv_ARG_EXPAND);
#define glGetVertexAttribIuivEXT_INDEX 1038
#define glGetVertexAttribIuivEXT_RETURN void
#define glGetVertexAttribIuivEXT_ARG_NAMES index, pname, params
#define glGetVertexAttribIuivEXT_ARG_EXPAND GLuint index, GLenum pname, GLuint * params
#define glGetVertexAttribIuivEXT_PACKED PACKED_glGetVertexAttribIuivEXT
#define glGetVertexAttribIuivEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetVertexAttribIuivEXT_NOT_VOID_WRAP(...) {}
#define pack_glGetVertexAttribIuivEXT(_index, _pname, _params) ({ \
    glGetVertexAttribIuivEXT_PACKED *packed_data = malloc(sizeof(glGetVertexAttribIuivEXT_PACKED)); \
    packed_data->index = glGetVertexAttribIuivEXT_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLuint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetVertexAttribIuivEXT(packed, ret_v) do { \
    PACKED_glGetVertexAttribIuivEXT *unpacked = (PACKED_glGetVertexAttribIuivEXT *)packed; \
    ARGS_glGetVertexAttribIuivEXT *args = (ARGS_glGetVertexAttribIuivEXT *)&unpacked->args; \
    glGetVertexAttribIuivEXT(args->index, args->pname, args->params);; \
} while(0)
void glGetVertexAttribIuivEXT(glGetVertexAttribIuivEXT_ARG_EXPAND);
typedef void (*glGetVertexAttribIuivEXT_PTR)(glGetVertexAttribIuivEXT_ARG_EXPAND);
#define glGetVertexAttribLdv_INDEX 1039
#define glGetVertexAttribLdv_RETURN void
#define glGetVertexAttribLdv_ARG_NAMES index, pname, params
#define glGetVertexAttribLdv_ARG_EXPAND GLuint index, GLenum pname, GLdouble * params
#define glGetVertexAttribLdv_PACKED PACKED_glGetVertexAttribLdv
#define glGetVertexAttribLdv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetVertexAttribLdv_NOT_VOID_WRAP(...) {}
#define pack_glGetVertexAttribLdv(_index, _pname, _params) ({ \
    glGetVertexAttribLdv_PACKED *packed_data = malloc(sizeof(glGetVertexAttribLdv_PACKED)); \
    packed_data->index = glGetVertexAttribLdv_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLdouble *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetVertexAttribLdv(packed, ret_v) do { \
    PACKED_glGetVertexAttribLdv *unpacked = (PACKED_glGetVertexAttribLdv *)packed; \
    ARGS_glGetVertexAttribLdv *args = (ARGS_glGetVertexAttribLdv *)&unpacked->args; \
    glGetVertexAttribLdv(args->index, args->pname, args->params);; \
} while(0)
void glGetVertexAttribLdv(glGetVertexAttribLdv_ARG_EXPAND);
typedef void (*glGetVertexAttribLdv_PTR)(glGetVertexAttribLdv_ARG_EXPAND);
#define glGetVertexAttribLdvEXT_INDEX 1040
#define glGetVertexAttribLdvEXT_RETURN void
#define glGetVertexAttribLdvEXT_ARG_NAMES index, pname, params
#define glGetVertexAttribLdvEXT_ARG_EXPAND GLuint index, GLenum pname, GLdouble * params
#define glGetVertexAttribLdvEXT_PACKED PACKED_glGetVertexAttribLdvEXT
#define glGetVertexAttribLdvEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetVertexAttribLdvEXT_NOT_VOID_WRAP(...) {}
#define pack_glGetVertexAttribLdvEXT(_index, _pname, _params) ({ \
    glGetVertexAttribLdvEXT_PACKED *packed_data = malloc(sizeof(glGetVertexAttribLdvEXT_PACKED)); \
    packed_data->index = glGetVertexAttribLdvEXT_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLdouble *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetVertexAttribLdvEXT(packed, ret_v) do { \
    PACKED_glGetVertexAttribLdvEXT *unpacked = (PACKED_glGetVertexAttribLdvEXT *)packed; \
    ARGS_glGetVertexAttribLdvEXT *args = (ARGS_glGetVertexAttribLdvEXT *)&unpacked->args; \
    glGetVertexAttribLdvEXT(args->index, args->pname, args->params);; \
} while(0)
void glGetVertexAttribLdvEXT(glGetVertexAttribLdvEXT_ARG_EXPAND);
typedef void (*glGetVertexAttribLdvEXT_PTR)(glGetVertexAttribLdvEXT_ARG_EXPAND);
#define glGetVertexAttribLi64vNV_INDEX 1041
#define glGetVertexAttribLi64vNV_RETURN void
#define glGetVertexAttribLi64vNV_ARG_NAMES index, pname, params
#define glGetVertexAttribLi64vNV_ARG_EXPAND GLuint index, GLenum pname, GLint64EXT * params
#define glGetVertexAttribLi64vNV_PACKED PACKED_glGetVertexAttribLi64vNV
#define glGetVertexAttribLi64vNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetVertexAttribLi64vNV_NOT_VOID_WRAP(...) {}
#define pack_glGetVertexAttribLi64vNV(_index, _pname, _params) ({ \
    glGetVertexAttribLi64vNV_PACKED *packed_data = malloc(sizeof(glGetVertexAttribLi64vNV_PACKED)); \
    packed_data->index = glGetVertexAttribLi64vNV_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLint64EXT *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetVertexAttribLi64vNV(packed, ret_v) do { \
    PACKED_glGetVertexAttribLi64vNV *unpacked = (PACKED_glGetVertexAttribLi64vNV *)packed; \
    ARGS_glGetVertexAttribLi64vNV *args = (ARGS_glGetVertexAttribLi64vNV *)&unpacked->args; \
    glGetVertexAttribLi64vNV(args->index, args->pname, args->params);; \
} while(0)
void glGetVertexAttribLi64vNV(glGetVertexAttribLi64vNV_ARG_EXPAND);
typedef void (*glGetVertexAttribLi64vNV_PTR)(glGetVertexAttribLi64vNV_ARG_EXPAND);
#define glGetVertexAttribLui64vNV_INDEX 1042
#define glGetVertexAttribLui64vNV_RETURN void
#define glGetVertexAttribLui64vNV_ARG_NAMES index, pname, params
#define glGetVertexAttribLui64vNV_ARG_EXPAND GLuint index, GLenum pname, GLuint64EXT * params
#define glGetVertexAttribLui64vNV_PACKED PACKED_glGetVertexAttribLui64vNV
#define glGetVertexAttribLui64vNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetVertexAttribLui64vNV_NOT_VOID_WRAP(...) {}
#define pack_glGetVertexAttribLui64vNV(_index, _pname, _params) ({ \
    glGetVertexAttribLui64vNV_PACKED *packed_data = malloc(sizeof(glGetVertexAttribLui64vNV_PACKED)); \
    packed_data->index = glGetVertexAttribLui64vNV_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLuint64EXT *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetVertexAttribLui64vNV(packed, ret_v) do { \
    PACKED_glGetVertexAttribLui64vNV *unpacked = (PACKED_glGetVertexAttribLui64vNV *)packed; \
    ARGS_glGetVertexAttribLui64vNV *args = (ARGS_glGetVertexAttribLui64vNV *)&unpacked->args; \
    glGetVertexAttribLui64vNV(args->index, args->pname, args->params);; \
} while(0)
void glGetVertexAttribLui64vNV(glGetVertexAttribLui64vNV_ARG_EXPAND);
typedef void (*glGetVertexAttribLui64vNV_PTR)(glGetVertexAttribLui64vNV_ARG_EXPAND);
#define glGetVertexAttribPointerv_INDEX 1043
#define glGetVertexAttribPointerv_RETURN void
#define glGetVertexAttribPointerv_ARG_NAMES index, pname, pointer
#define glGetVertexAttribPointerv_ARG_EXPAND GLuint index, GLenum pname, GLvoid ** pointer
#define glGetVertexAttribPointerv_PACKED PACKED_glGetVertexAttribPointerv
#define glGetVertexAttribPointerv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetVertexAttribPointerv_NOT_VOID_WRAP(...) {}
#define pack_glGetVertexAttribPointerv(_index, _pname, _pointer) ({ \
    glGetVertexAttribPointerv_PACKED *packed_data = malloc(sizeof(glGetVertexAttribPointerv_PACKED)); \
    packed_data->index = glGetVertexAttribPointerv_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.pointer = (GLvoid **)_pointer; \
    (packed_call_t *)packed_data; \
})
#define call_glGetVertexAttribPointerv(packed, ret_v) do { \
    PACKED_glGetVertexAttribPointerv *unpacked = (PACKED_glGetVertexAttribPointerv *)packed; \
    ARGS_glGetVertexAttribPointerv *args = (ARGS_glGetVertexAttribPointerv *)&unpacked->args; \
    glGetVertexAttribPointerv(args->index, args->pname, args->pointer);; \
} while(0)
void glGetVertexAttribPointerv(glGetVertexAttribPointerv_ARG_EXPAND);
typedef void (*glGetVertexAttribPointerv_PTR)(glGetVertexAttribPointerv_ARG_EXPAND);
#define glGetVertexAttribPointervARB_INDEX 1044
#define glGetVertexAttribPointervARB_RETURN void
#define glGetVertexAttribPointervARB_ARG_NAMES index, pname, pointer
#define glGetVertexAttribPointervARB_ARG_EXPAND GLuint index, GLenum pname, GLvoid * pointer
#define glGetVertexAttribPointervARB_PACKED PACKED_glGetVertexAttribPointervARB
#define glGetVertexAttribPointervARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetVertexAttribPointervARB_NOT_VOID_WRAP(...) {}
#define pack_glGetVertexAttribPointervARB(_index, _pname, _pointer) ({ \
    glGetVertexAttribPointervARB_PACKED *packed_data = malloc(sizeof(glGetVertexAttribPointervARB_PACKED)); \
    packed_data->index = glGetVertexAttribPointervARB_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.pointer = (GLvoid *)_pointer; \
    (packed_call_t *)packed_data; \
})
#define call_glGetVertexAttribPointervARB(packed, ret_v) do { \
    PACKED_glGetVertexAttribPointervARB *unpacked = (PACKED_glGetVertexAttribPointervARB *)packed; \
    ARGS_glGetVertexAttribPointervARB *args = (ARGS_glGetVertexAttribPointervARB *)&unpacked->args; \
    glGetVertexAttribPointervARB(args->index, args->pname, args->pointer);; \
} while(0)
void glGetVertexAttribPointervARB(glGetVertexAttribPointervARB_ARG_EXPAND);
typedef void (*glGetVertexAttribPointervARB_PTR)(glGetVertexAttribPointervARB_ARG_EXPAND);
#define glGetVertexAttribPointervNV_INDEX 1045
#define glGetVertexAttribPointervNV_RETURN void
#define glGetVertexAttribPointervNV_ARG_NAMES index, pname, pointer
#define glGetVertexAttribPointervNV_ARG_EXPAND GLuint index, GLenum pname, GLvoid * pointer
#define glGetVertexAttribPointervNV_PACKED PACKED_glGetVertexAttribPointervNV
#define glGetVertexAttribPointervNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetVertexAttribPointervNV_NOT_VOID_WRAP(...) {}
#define pack_glGetVertexAttribPointervNV(_index, _pname, _pointer) ({ \
    glGetVertexAttribPointervNV_PACKED *packed_data = malloc(sizeof(glGetVertexAttribPointervNV_PACKED)); \
    packed_data->index = glGetVertexAttribPointervNV_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.pointer = (GLvoid *)_pointer; \
    (packed_call_t *)packed_data; \
})
#define call_glGetVertexAttribPointervNV(packed, ret_v) do { \
    PACKED_glGetVertexAttribPointervNV *unpacked = (PACKED_glGetVertexAttribPointervNV *)packed; \
    ARGS_glGetVertexAttribPointervNV *args = (ARGS_glGetVertexAttribPointervNV *)&unpacked->args; \
    glGetVertexAttribPointervNV(args->index, args->pname, args->pointer);; \
} while(0)
void glGetVertexAttribPointervNV(glGetVertexAttribPointervNV_ARG_EXPAND);
typedef void (*glGetVertexAttribPointervNV_PTR)(glGetVertexAttribPointervNV_ARG_EXPAND);
#define glGetVertexAttribdv_INDEX 1046
#define glGetVertexAttribdv_RETURN void
#define glGetVertexAttribdv_ARG_NAMES index, pname, params
#define glGetVertexAttribdv_ARG_EXPAND GLuint index, GLenum pname, GLdouble * params
#define glGetVertexAttribdv_PACKED PACKED_glGetVertexAttribdv
#define glGetVertexAttribdv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetVertexAttribdv_NOT_VOID_WRAP(...) {}
#define pack_glGetVertexAttribdv(_index, _pname, _params) ({ \
    glGetVertexAttribdv_PACKED *packed_data = malloc(sizeof(glGetVertexAttribdv_PACKED)); \
    packed_data->index = glGetVertexAttribdv_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLdouble *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetVertexAttribdv(packed, ret_v) do { \
    PACKED_glGetVertexAttribdv *unpacked = (PACKED_glGetVertexAttribdv *)packed; \
    ARGS_glGetVertexAttribdv *args = (ARGS_glGetVertexAttribdv *)&unpacked->args; \
    glGetVertexAttribdv(args->index, args->pname, args->params);; \
} while(0)
void glGetVertexAttribdv(glGetVertexAttribdv_ARG_EXPAND);
typedef void (*glGetVertexAttribdv_PTR)(glGetVertexAttribdv_ARG_EXPAND);
#define glGetVertexAttribdvARB_INDEX 1047
#define glGetVertexAttribdvARB_RETURN void
#define glGetVertexAttribdvARB_ARG_NAMES index, pname, params
#define glGetVertexAttribdvARB_ARG_EXPAND GLuint index, GLenum pname, GLdouble * params
#define glGetVertexAttribdvARB_PACKED PACKED_glGetVertexAttribdvARB
#define glGetVertexAttribdvARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetVertexAttribdvARB_NOT_VOID_WRAP(...) {}
#define pack_glGetVertexAttribdvARB(_index, _pname, _params) ({ \
    glGetVertexAttribdvARB_PACKED *packed_data = malloc(sizeof(glGetVertexAttribdvARB_PACKED)); \
    packed_data->index = glGetVertexAttribdvARB_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLdouble *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetVertexAttribdvARB(packed, ret_v) do { \
    PACKED_glGetVertexAttribdvARB *unpacked = (PACKED_glGetVertexAttribdvARB *)packed; \
    ARGS_glGetVertexAttribdvARB *args = (ARGS_glGetVertexAttribdvARB *)&unpacked->args; \
    glGetVertexAttribdvARB(args->index, args->pname, args->params);; \
} while(0)
void glGetVertexAttribdvARB(glGetVertexAttribdvARB_ARG_EXPAND);
typedef void (*glGetVertexAttribdvARB_PTR)(glGetVertexAttribdvARB_ARG_EXPAND);
#define glGetVertexAttribdvNV_INDEX 1048
#define glGetVertexAttribdvNV_RETURN void
#define glGetVertexAttribdvNV_ARG_NAMES index, pname, params
#define glGetVertexAttribdvNV_ARG_EXPAND GLuint index, GLenum pname, GLdouble * params
#define glGetVertexAttribdvNV_PACKED PACKED_glGetVertexAttribdvNV
#define glGetVertexAttribdvNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetVertexAttribdvNV_NOT_VOID_WRAP(...) {}
#define pack_glGetVertexAttribdvNV(_index, _pname, _params) ({ \
    glGetVertexAttribdvNV_PACKED *packed_data = malloc(sizeof(glGetVertexAttribdvNV_PACKED)); \
    packed_data->index = glGetVertexAttribdvNV_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLdouble *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetVertexAttribdvNV(packed, ret_v) do { \
    PACKED_glGetVertexAttribdvNV *unpacked = (PACKED_glGetVertexAttribdvNV *)packed; \
    ARGS_glGetVertexAttribdvNV *args = (ARGS_glGetVertexAttribdvNV *)&unpacked->args; \
    glGetVertexAttribdvNV(args->index, args->pname, args->params);; \
} while(0)
void glGetVertexAttribdvNV(glGetVertexAttribdvNV_ARG_EXPAND);
typedef void (*glGetVertexAttribdvNV_PTR)(glGetVertexAttribdvNV_ARG_EXPAND);
#define glGetVertexAttribfv_INDEX 1049
#define glGetVertexAttribfv_RETURN void
#define glGetVertexAttribfv_ARG_NAMES index, pname, params
#define glGetVertexAttribfv_ARG_EXPAND GLuint index, GLenum pname, GLfloat * params
#define glGetVertexAttribfv_PACKED PACKED_glGetVertexAttribfv
#define glGetVertexAttribfv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetVertexAttribfv_NOT_VOID_WRAP(...) {}
#define pack_glGetVertexAttribfv(_index, _pname, _params) ({ \
    glGetVertexAttribfv_PACKED *packed_data = malloc(sizeof(glGetVertexAttribfv_PACKED)); \
    packed_data->index = glGetVertexAttribfv_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLfloat *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetVertexAttribfv(packed, ret_v) do { \
    PACKED_glGetVertexAttribfv *unpacked = (PACKED_glGetVertexAttribfv *)packed; \
    ARGS_glGetVertexAttribfv *args = (ARGS_glGetVertexAttribfv *)&unpacked->args; \
    glGetVertexAttribfv(args->index, args->pname, args->params);; \
} while(0)
void glGetVertexAttribfv(glGetVertexAttribfv_ARG_EXPAND);
typedef void (*glGetVertexAttribfv_PTR)(glGetVertexAttribfv_ARG_EXPAND);
#define glGetVertexAttribfvARB_INDEX 1050
#define glGetVertexAttribfvARB_RETURN void
#define glGetVertexAttribfvARB_ARG_NAMES index, pname, params
#define glGetVertexAttribfvARB_ARG_EXPAND GLuint index, GLenum pname, GLfloat * params
#define glGetVertexAttribfvARB_PACKED PACKED_glGetVertexAttribfvARB
#define glGetVertexAttribfvARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetVertexAttribfvARB_NOT_VOID_WRAP(...) {}
#define pack_glGetVertexAttribfvARB(_index, _pname, _params) ({ \
    glGetVertexAttribfvARB_PACKED *packed_data = malloc(sizeof(glGetVertexAttribfvARB_PACKED)); \
    packed_data->index = glGetVertexAttribfvARB_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLfloat *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetVertexAttribfvARB(packed, ret_v) do { \
    PACKED_glGetVertexAttribfvARB *unpacked = (PACKED_glGetVertexAttribfvARB *)packed; \
    ARGS_glGetVertexAttribfvARB *args = (ARGS_glGetVertexAttribfvARB *)&unpacked->args; \
    glGetVertexAttribfvARB(args->index, args->pname, args->params);; \
} while(0)
void glGetVertexAttribfvARB(glGetVertexAttribfvARB_ARG_EXPAND);
typedef void (*glGetVertexAttribfvARB_PTR)(glGetVertexAttribfvARB_ARG_EXPAND);
#define glGetVertexAttribfvNV_INDEX 1051
#define glGetVertexAttribfvNV_RETURN void
#define glGetVertexAttribfvNV_ARG_NAMES index, pname, params
#define glGetVertexAttribfvNV_ARG_EXPAND GLuint index, GLenum pname, GLfloat * params
#define glGetVertexAttribfvNV_PACKED PACKED_glGetVertexAttribfvNV
#define glGetVertexAttribfvNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetVertexAttribfvNV_NOT_VOID_WRAP(...) {}
#define pack_glGetVertexAttribfvNV(_index, _pname, _params) ({ \
    glGetVertexAttribfvNV_PACKED *packed_data = malloc(sizeof(glGetVertexAttribfvNV_PACKED)); \
    packed_data->index = glGetVertexAttribfvNV_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLfloat *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetVertexAttribfvNV(packed, ret_v) do { \
    PACKED_glGetVertexAttribfvNV *unpacked = (PACKED_glGetVertexAttribfvNV *)packed; \
    ARGS_glGetVertexAttribfvNV *args = (ARGS_glGetVertexAttribfvNV *)&unpacked->args; \
    glGetVertexAttribfvNV(args->index, args->pname, args->params);; \
} while(0)
void glGetVertexAttribfvNV(glGetVertexAttribfvNV_ARG_EXPAND);
typedef void (*glGetVertexAttribfvNV_PTR)(glGetVertexAttribfvNV_ARG_EXPAND);
#define glGetVertexAttribiv_INDEX 1052
#define glGetVertexAttribiv_RETURN void
#define glGetVertexAttribiv_ARG_NAMES index, pname, params
#define glGetVertexAttribiv_ARG_EXPAND GLuint index, GLenum pname, GLint * params
#define glGetVertexAttribiv_PACKED PACKED_glGetVertexAttribiv
#define glGetVertexAttribiv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetVertexAttribiv_NOT_VOID_WRAP(...) {}
#define pack_glGetVertexAttribiv(_index, _pname, _params) ({ \
    glGetVertexAttribiv_PACKED *packed_data = malloc(sizeof(glGetVertexAttribiv_PACKED)); \
    packed_data->index = glGetVertexAttribiv_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetVertexAttribiv(packed, ret_v) do { \
    PACKED_glGetVertexAttribiv *unpacked = (PACKED_glGetVertexAttribiv *)packed; \
    ARGS_glGetVertexAttribiv *args = (ARGS_glGetVertexAttribiv *)&unpacked->args; \
    glGetVertexAttribiv(args->index, args->pname, args->params);; \
} while(0)
void glGetVertexAttribiv(glGetVertexAttribiv_ARG_EXPAND);
typedef void (*glGetVertexAttribiv_PTR)(glGetVertexAttribiv_ARG_EXPAND);
#define glGetVertexAttribivARB_INDEX 1053
#define glGetVertexAttribivARB_RETURN void
#define glGetVertexAttribivARB_ARG_NAMES index, pname, params
#define glGetVertexAttribivARB_ARG_EXPAND GLuint index, GLenum pname, GLint * params
#define glGetVertexAttribivARB_PACKED PACKED_glGetVertexAttribivARB
#define glGetVertexAttribivARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetVertexAttribivARB_NOT_VOID_WRAP(...) {}
#define pack_glGetVertexAttribivARB(_index, _pname, _params) ({ \
    glGetVertexAttribivARB_PACKED *packed_data = malloc(sizeof(glGetVertexAttribivARB_PACKED)); \
    packed_data->index = glGetVertexAttribivARB_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetVertexAttribivARB(packed, ret_v) do { \
    PACKED_glGetVertexAttribivARB *unpacked = (PACKED_glGetVertexAttribivARB *)packed; \
    ARGS_glGetVertexAttribivARB *args = (ARGS_glGetVertexAttribivARB *)&unpacked->args; \
    glGetVertexAttribivARB(args->index, args->pname, args->params);; \
} while(0)
void glGetVertexAttribivARB(glGetVertexAttribivARB_ARG_EXPAND);
typedef void (*glGetVertexAttribivARB_PTR)(glGetVertexAttribivARB_ARG_EXPAND);
#define glGetVertexAttribivNV_INDEX 1054
#define glGetVertexAttribivNV_RETURN void
#define glGetVertexAttribivNV_ARG_NAMES index, pname, params
#define glGetVertexAttribivNV_ARG_EXPAND GLuint index, GLenum pname, GLint * params
#define glGetVertexAttribivNV_PACKED PACKED_glGetVertexAttribivNV
#define glGetVertexAttribivNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetVertexAttribivNV_NOT_VOID_WRAP(...) {}
#define pack_glGetVertexAttribivNV(_index, _pname, _params) ({ \
    glGetVertexAttribivNV_PACKED *packed_data = malloc(sizeof(glGetVertexAttribivNV_PACKED)); \
    packed_data->index = glGetVertexAttribivNV_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetVertexAttribivNV(packed, ret_v) do { \
    PACKED_glGetVertexAttribivNV *unpacked = (PACKED_glGetVertexAttribivNV *)packed; \
    ARGS_glGetVertexAttribivNV *args = (ARGS_glGetVertexAttribivNV *)&unpacked->args; \
    glGetVertexAttribivNV(args->index, args->pname, args->params);; \
} while(0)
void glGetVertexAttribivNV(glGetVertexAttribivNV_ARG_EXPAND);
typedef void (*glGetVertexAttribivNV_PTR)(glGetVertexAttribivNV_ARG_EXPAND);
#define glGetVideoCaptureStreamdvNV_INDEX 1055
#define glGetVideoCaptureStreamdvNV_RETURN void
#define glGetVideoCaptureStreamdvNV_ARG_NAMES video_capture_slot, stream, pname, params
#define glGetVideoCaptureStreamdvNV_ARG_EXPAND GLuint video_capture_slot, GLuint stream, GLenum pname, GLdouble * params
#define glGetVideoCaptureStreamdvNV_PACKED PACKED_glGetVideoCaptureStreamdvNV
#define glGetVideoCaptureStreamdvNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetVideoCaptureStreamdvNV_NOT_VOID_WRAP(...) {}
#define pack_glGetVideoCaptureStreamdvNV(_video_capture_slot, _stream, _pname, _params) ({ \
    glGetVideoCaptureStreamdvNV_PACKED *packed_data = malloc(sizeof(glGetVideoCaptureStreamdvNV_PACKED)); \
    packed_data->index = glGetVideoCaptureStreamdvNV_INDEX; \
    packed_data->args.video_capture_slot = (GLuint)_video_capture_slot; \
    packed_data->args.stream = (GLuint)_stream; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLdouble *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetVideoCaptureStreamdvNV(packed, ret_v) do { \
    PACKED_glGetVideoCaptureStreamdvNV *unpacked = (PACKED_glGetVideoCaptureStreamdvNV *)packed; \
    ARGS_glGetVideoCaptureStreamdvNV *args = (ARGS_glGetVideoCaptureStreamdvNV *)&unpacked->args; \
    glGetVideoCaptureStreamdvNV(args->video_capture_slot, args->stream, args->pname, args->params);; \
} while(0)
void glGetVideoCaptureStreamdvNV(glGetVideoCaptureStreamdvNV_ARG_EXPAND);
typedef void (*glGetVideoCaptureStreamdvNV_PTR)(glGetVideoCaptureStreamdvNV_ARG_EXPAND);
#define glGetVideoCaptureStreamfvNV_INDEX 1056
#define glGetVideoCaptureStreamfvNV_RETURN void
#define glGetVideoCaptureStreamfvNV_ARG_NAMES video_capture_slot, stream, pname, params
#define glGetVideoCaptureStreamfvNV_ARG_EXPAND GLuint video_capture_slot, GLuint stream, GLenum pname, GLfloat * params
#define glGetVideoCaptureStreamfvNV_PACKED PACKED_glGetVideoCaptureStreamfvNV
#define glGetVideoCaptureStreamfvNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetVideoCaptureStreamfvNV_NOT_VOID_WRAP(...) {}
#define pack_glGetVideoCaptureStreamfvNV(_video_capture_slot, _stream, _pname, _params) ({ \
    glGetVideoCaptureStreamfvNV_PACKED *packed_data = malloc(sizeof(glGetVideoCaptureStreamfvNV_PACKED)); \
    packed_data->index = glGetVideoCaptureStreamfvNV_INDEX; \
    packed_data->args.video_capture_slot = (GLuint)_video_capture_slot; \
    packed_data->args.stream = (GLuint)_stream; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLfloat *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetVideoCaptureStreamfvNV(packed, ret_v) do { \
    PACKED_glGetVideoCaptureStreamfvNV *unpacked = (PACKED_glGetVideoCaptureStreamfvNV *)packed; \
    ARGS_glGetVideoCaptureStreamfvNV *args = (ARGS_glGetVideoCaptureStreamfvNV *)&unpacked->args; \
    glGetVideoCaptureStreamfvNV(args->video_capture_slot, args->stream, args->pname, args->params);; \
} while(0)
void glGetVideoCaptureStreamfvNV(glGetVideoCaptureStreamfvNV_ARG_EXPAND);
typedef void (*glGetVideoCaptureStreamfvNV_PTR)(glGetVideoCaptureStreamfvNV_ARG_EXPAND);
#define glGetVideoCaptureStreamivNV_INDEX 1057
#define glGetVideoCaptureStreamivNV_RETURN void
#define glGetVideoCaptureStreamivNV_ARG_NAMES video_capture_slot, stream, pname, params
#define glGetVideoCaptureStreamivNV_ARG_EXPAND GLuint video_capture_slot, GLuint stream, GLenum pname, GLint * params
#define glGetVideoCaptureStreamivNV_PACKED PACKED_glGetVideoCaptureStreamivNV
#define glGetVideoCaptureStreamivNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetVideoCaptureStreamivNV_NOT_VOID_WRAP(...) {}
#define pack_glGetVideoCaptureStreamivNV(_video_capture_slot, _stream, _pname, _params) ({ \
    glGetVideoCaptureStreamivNV_PACKED *packed_data = malloc(sizeof(glGetVideoCaptureStreamivNV_PACKED)); \
    packed_data->index = glGetVideoCaptureStreamivNV_INDEX; \
    packed_data->args.video_capture_slot = (GLuint)_video_capture_slot; \
    packed_data->args.stream = (GLuint)_stream; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetVideoCaptureStreamivNV(packed, ret_v) do { \
    PACKED_glGetVideoCaptureStreamivNV *unpacked = (PACKED_glGetVideoCaptureStreamivNV *)packed; \
    ARGS_glGetVideoCaptureStreamivNV *args = (ARGS_glGetVideoCaptureStreamivNV *)&unpacked->args; \
    glGetVideoCaptureStreamivNV(args->video_capture_slot, args->stream, args->pname, args->params);; \
} while(0)
void glGetVideoCaptureStreamivNV(glGetVideoCaptureStreamivNV_ARG_EXPAND);
typedef void (*glGetVideoCaptureStreamivNV_PTR)(glGetVideoCaptureStreamivNV_ARG_EXPAND);
#define glGetVideoCaptureivNV_INDEX 1058
#define glGetVideoCaptureivNV_RETURN void
#define glGetVideoCaptureivNV_ARG_NAMES video_capture_slot, pname, params
#define glGetVideoCaptureivNV_ARG_EXPAND GLuint video_capture_slot, GLenum pname, GLint * params
#define glGetVideoCaptureivNV_PACKED PACKED_glGetVideoCaptureivNV
#define glGetVideoCaptureivNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetVideoCaptureivNV_NOT_VOID_WRAP(...) {}
#define pack_glGetVideoCaptureivNV(_video_capture_slot, _pname, _params) ({ \
    glGetVideoCaptureivNV_PACKED *packed_data = malloc(sizeof(glGetVideoCaptureivNV_PACKED)); \
    packed_data->index = glGetVideoCaptureivNV_INDEX; \
    packed_data->args.video_capture_slot = (GLuint)_video_capture_slot; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetVideoCaptureivNV(packed, ret_v) do { \
    PACKED_glGetVideoCaptureivNV *unpacked = (PACKED_glGetVideoCaptureivNV *)packed; \
    ARGS_glGetVideoCaptureivNV *args = (ARGS_glGetVideoCaptureivNV *)&unpacked->args; \
    glGetVideoCaptureivNV(args->video_capture_slot, args->pname, args->params);; \
} while(0)
void glGetVideoCaptureivNV(glGetVideoCaptureivNV_ARG_EXPAND);
typedef void (*glGetVideoCaptureivNV_PTR)(glGetVideoCaptureivNV_ARG_EXPAND);
#define glGetVideoi64vNV_INDEX 1059
#define glGetVideoi64vNV_RETURN void
#define glGetVideoi64vNV_ARG_NAMES video_slot, pname, params
#define glGetVideoi64vNV_ARG_EXPAND GLuint video_slot, GLenum pname, GLint64EXT * params
#define glGetVideoi64vNV_PACKED PACKED_glGetVideoi64vNV
#define glGetVideoi64vNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetVideoi64vNV_NOT_VOID_WRAP(...) {}
#define pack_glGetVideoi64vNV(_video_slot, _pname, _params) ({ \
    glGetVideoi64vNV_PACKED *packed_data = malloc(sizeof(glGetVideoi64vNV_PACKED)); \
    packed_data->index = glGetVideoi64vNV_INDEX; \
    packed_data->args.video_slot = (GLuint)_video_slot; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLint64EXT *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetVideoi64vNV(packed, ret_v) do { \
    PACKED_glGetVideoi64vNV *unpacked = (PACKED_glGetVideoi64vNV *)packed; \
    ARGS_glGetVideoi64vNV *args = (ARGS_glGetVideoi64vNV *)&unpacked->args; \
    glGetVideoi64vNV(args->video_slot, args->pname, args->params);; \
} while(0)
void glGetVideoi64vNV(glGetVideoi64vNV_ARG_EXPAND);
typedef void (*glGetVideoi64vNV_PTR)(glGetVideoi64vNV_ARG_EXPAND);
#define glGetVideoivNV_INDEX 1060
#define glGetVideoivNV_RETURN void
#define glGetVideoivNV_ARG_NAMES video_slot, pname, params
#define glGetVideoivNV_ARG_EXPAND GLuint video_slot, GLenum pname, GLint * params
#define glGetVideoivNV_PACKED PACKED_glGetVideoivNV
#define glGetVideoivNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetVideoivNV_NOT_VOID_WRAP(...) {}
#define pack_glGetVideoivNV(_video_slot, _pname, _params) ({ \
    glGetVideoivNV_PACKED *packed_data = malloc(sizeof(glGetVideoivNV_PACKED)); \
    packed_data->index = glGetVideoivNV_INDEX; \
    packed_data->args.video_slot = (GLuint)_video_slot; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetVideoivNV(packed, ret_v) do { \
    PACKED_glGetVideoivNV *unpacked = (PACKED_glGetVideoivNV *)packed; \
    ARGS_glGetVideoivNV *args = (ARGS_glGetVideoivNV *)&unpacked->args; \
    glGetVideoivNV(args->video_slot, args->pname, args->params);; \
} while(0)
void glGetVideoivNV(glGetVideoivNV_ARG_EXPAND);
typedef void (*glGetVideoivNV_PTR)(glGetVideoivNV_ARG_EXPAND);
#define glGetVideoui64vNV_INDEX 1061
#define glGetVideoui64vNV_RETURN void
#define glGetVideoui64vNV_ARG_NAMES video_slot, pname, params
#define glGetVideoui64vNV_ARG_EXPAND GLuint video_slot, GLenum pname, GLuint64EXT * params
#define glGetVideoui64vNV_PACKED PACKED_glGetVideoui64vNV
#define glGetVideoui64vNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetVideoui64vNV_NOT_VOID_WRAP(...) {}
#define pack_glGetVideoui64vNV(_video_slot, _pname, _params) ({ \
    glGetVideoui64vNV_PACKED *packed_data = malloc(sizeof(glGetVideoui64vNV_PACKED)); \
    packed_data->index = glGetVideoui64vNV_INDEX; \
    packed_data->args.video_slot = (GLuint)_video_slot; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLuint64EXT *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetVideoui64vNV(packed, ret_v) do { \
    PACKED_glGetVideoui64vNV *unpacked = (PACKED_glGetVideoui64vNV *)packed; \
    ARGS_glGetVideoui64vNV *args = (ARGS_glGetVideoui64vNV *)&unpacked->args; \
    glGetVideoui64vNV(args->video_slot, args->pname, args->params);; \
} while(0)
void glGetVideoui64vNV(glGetVideoui64vNV_ARG_EXPAND);
typedef void (*glGetVideoui64vNV_PTR)(glGetVideoui64vNV_ARG_EXPAND);
#define glGetVideouivNV_INDEX 1062
#define glGetVideouivNV_RETURN void
#define glGetVideouivNV_ARG_NAMES video_slot, pname, params
#define glGetVideouivNV_ARG_EXPAND GLuint video_slot, GLenum pname, GLuint * params
#define glGetVideouivNV_PACKED PACKED_glGetVideouivNV
#define glGetVideouivNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetVideouivNV_NOT_VOID_WRAP(...) {}
#define pack_glGetVideouivNV(_video_slot, _pname, _params) ({ \
    glGetVideouivNV_PACKED *packed_data = malloc(sizeof(glGetVideouivNV_PACKED)); \
    packed_data->index = glGetVideouivNV_INDEX; \
    packed_data->args.video_slot = (GLuint)_video_slot; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLuint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetVideouivNV(packed, ret_v) do { \
    PACKED_glGetVideouivNV *unpacked = (PACKED_glGetVideouivNV *)packed; \
    ARGS_glGetVideouivNV *args = (ARGS_glGetVideouivNV *)&unpacked->args; \
    glGetVideouivNV(args->video_slot, args->pname, args->params);; \
} while(0)
void glGetVideouivNV(glGetVideouivNV_ARG_EXPAND);
typedef void (*glGetVideouivNV_PTR)(glGetVideouivNV_ARG_EXPAND);
#define glGetnColorTableARB_INDEX 1063
#define glGetnColorTableARB_RETURN void
#define glGetnColorTableARB_ARG_NAMES target, format, type, bufSize, table
#define glGetnColorTableARB_ARG_EXPAND GLenum target, GLenum format, GLenum type, GLsizei bufSize, GLvoid * table
#define glGetnColorTableARB_PACKED PACKED_glGetnColorTableARB
#define glGetnColorTableARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetnColorTableARB_NOT_VOID_WRAP(...) {}
#define pack_glGetnColorTableARB(_target, _format, _type, _bufSize, _table) ({ \
    glGetnColorTableARB_PACKED *packed_data = malloc(sizeof(glGetnColorTableARB_PACKED)); \
    packed_data->index = glGetnColorTableARB_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.format = (GLenum)_format; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.bufSize = (GLsizei)_bufSize; \
    packed_data->args.table = (GLvoid *)_table; \
    (packed_call_t *)packed_data; \
})
#define call_glGetnColorTableARB(packed, ret_v) do { \
    PACKED_glGetnColorTableARB *unpacked = (PACKED_glGetnColorTableARB *)packed; \
    ARGS_glGetnColorTableARB *args = (ARGS_glGetnColorTableARB *)&unpacked->args; \
    glGetnColorTableARB(args->target, args->format, args->type, args->bufSize, args->table);; \
} while(0)
void glGetnColorTableARB(glGetnColorTableARB_ARG_EXPAND);
typedef void (*glGetnColorTableARB_PTR)(glGetnColorTableARB_ARG_EXPAND);
#define glGetnCompressedTexImageARB_INDEX 1064
#define glGetnCompressedTexImageARB_RETURN void
#define glGetnCompressedTexImageARB_ARG_NAMES target, lod, bufSize, img
#define glGetnCompressedTexImageARB_ARG_EXPAND GLenum target, GLint lod, GLsizei bufSize, GLvoid * img
#define glGetnCompressedTexImageARB_PACKED PACKED_glGetnCompressedTexImageARB
#define glGetnCompressedTexImageARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetnCompressedTexImageARB_NOT_VOID_WRAP(...) {}
#define pack_glGetnCompressedTexImageARB(_target, _lod, _bufSize, _img) ({ \
    glGetnCompressedTexImageARB_PACKED *packed_data = malloc(sizeof(glGetnCompressedTexImageARB_PACKED)); \
    packed_data->index = glGetnCompressedTexImageARB_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.lod = (GLint)_lod; \
    packed_data->args.bufSize = (GLsizei)_bufSize; \
    packed_data->args.img = (GLvoid *)_img; \
    (packed_call_t *)packed_data; \
})
#define call_glGetnCompressedTexImageARB(packed, ret_v) do { \
    PACKED_glGetnCompressedTexImageARB *unpacked = (PACKED_glGetnCompressedTexImageARB *)packed; \
    ARGS_glGetnCompressedTexImageARB *args = (ARGS_glGetnCompressedTexImageARB *)&unpacked->args; \
    glGetnCompressedTexImageARB(args->target, args->lod, args->bufSize, args->img);; \
} while(0)
void glGetnCompressedTexImageARB(glGetnCompressedTexImageARB_ARG_EXPAND);
typedef void (*glGetnCompressedTexImageARB_PTR)(glGetnCompressedTexImageARB_ARG_EXPAND);
#define glGetnConvolutionFilterARB_INDEX 1065
#define glGetnConvolutionFilterARB_RETURN void
#define glGetnConvolutionFilterARB_ARG_NAMES target, format, type, bufSize, image
#define glGetnConvolutionFilterARB_ARG_EXPAND GLenum target, GLenum format, GLenum type, GLsizei bufSize, GLvoid * image
#define glGetnConvolutionFilterARB_PACKED PACKED_glGetnConvolutionFilterARB
#define glGetnConvolutionFilterARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetnConvolutionFilterARB_NOT_VOID_WRAP(...) {}
#define pack_glGetnConvolutionFilterARB(_target, _format, _type, _bufSize, _image) ({ \
    glGetnConvolutionFilterARB_PACKED *packed_data = malloc(sizeof(glGetnConvolutionFilterARB_PACKED)); \
    packed_data->index = glGetnConvolutionFilterARB_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.format = (GLenum)_format; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.bufSize = (GLsizei)_bufSize; \
    packed_data->args.image = (GLvoid *)_image; \
    (packed_call_t *)packed_data; \
})
#define call_glGetnConvolutionFilterARB(packed, ret_v) do { \
    PACKED_glGetnConvolutionFilterARB *unpacked = (PACKED_glGetnConvolutionFilterARB *)packed; \
    ARGS_glGetnConvolutionFilterARB *args = (ARGS_glGetnConvolutionFilterARB *)&unpacked->args; \
    glGetnConvolutionFilterARB(args->target, args->format, args->type, args->bufSize, args->image);; \
} while(0)
void glGetnConvolutionFilterARB(glGetnConvolutionFilterARB_ARG_EXPAND);
typedef void (*glGetnConvolutionFilterARB_PTR)(glGetnConvolutionFilterARB_ARG_EXPAND);
#define glGetnHistogramARB_INDEX 1066
#define glGetnHistogramARB_RETURN void
#define glGetnHistogramARB_ARG_NAMES target, reset, format, type, bufSize, values
#define glGetnHistogramARB_ARG_EXPAND GLenum target, GLboolean reset, GLenum format, GLenum type, GLsizei bufSize, GLvoid * values
#define glGetnHistogramARB_PACKED PACKED_glGetnHistogramARB
#define glGetnHistogramARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetnHistogramARB_NOT_VOID_WRAP(...) {}
#define pack_glGetnHistogramARB(_target, _reset, _format, _type, _bufSize, _values) ({ \
    glGetnHistogramARB_PACKED *packed_data = malloc(sizeof(glGetnHistogramARB_PACKED)); \
    packed_data->index = glGetnHistogramARB_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.reset = (GLboolean)_reset; \
    packed_data->args.format = (GLenum)_format; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.bufSize = (GLsizei)_bufSize; \
    packed_data->args.values = (GLvoid *)_values; \
    (packed_call_t *)packed_data; \
})
#define call_glGetnHistogramARB(packed, ret_v) do { \
    PACKED_glGetnHistogramARB *unpacked = (PACKED_glGetnHistogramARB *)packed; \
    ARGS_glGetnHistogramARB *args = (ARGS_glGetnHistogramARB *)&unpacked->args; \
    glGetnHistogramARB(args->target, args->reset, args->format, args->type, args->bufSize, args->values);; \
} while(0)
void glGetnHistogramARB(glGetnHistogramARB_ARG_EXPAND);
typedef void (*glGetnHistogramARB_PTR)(glGetnHistogramARB_ARG_EXPAND);
#define glGetnMapdvARB_INDEX 1067
#define glGetnMapdvARB_RETURN void
#define glGetnMapdvARB_ARG_NAMES target, query, bufSize, v
#define glGetnMapdvARB_ARG_EXPAND GLenum target, GLenum query, GLsizei bufSize, GLdouble * v
#define glGetnMapdvARB_PACKED PACKED_glGetnMapdvARB
#define glGetnMapdvARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetnMapdvARB_NOT_VOID_WRAP(...) {}
#define pack_glGetnMapdvARB(_target, _query, _bufSize, _v) ({ \
    glGetnMapdvARB_PACKED *packed_data = malloc(sizeof(glGetnMapdvARB_PACKED)); \
    packed_data->index = glGetnMapdvARB_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.query = (GLenum)_query; \
    packed_data->args.bufSize = (GLsizei)_bufSize; \
    packed_data->args.v = (GLdouble *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glGetnMapdvARB(packed, ret_v) do { \
    PACKED_glGetnMapdvARB *unpacked = (PACKED_glGetnMapdvARB *)packed; \
    ARGS_glGetnMapdvARB *args = (ARGS_glGetnMapdvARB *)&unpacked->args; \
    glGetnMapdvARB(args->target, args->query, args->bufSize, args->v);; \
} while(0)
void glGetnMapdvARB(glGetnMapdvARB_ARG_EXPAND);
typedef void (*glGetnMapdvARB_PTR)(glGetnMapdvARB_ARG_EXPAND);
#define glGetnMapfvARB_INDEX 1068
#define glGetnMapfvARB_RETURN void
#define glGetnMapfvARB_ARG_NAMES target, query, bufSize, v
#define glGetnMapfvARB_ARG_EXPAND GLenum target, GLenum query, GLsizei bufSize, GLfloat * v
#define glGetnMapfvARB_PACKED PACKED_glGetnMapfvARB
#define glGetnMapfvARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetnMapfvARB_NOT_VOID_WRAP(...) {}
#define pack_glGetnMapfvARB(_target, _query, _bufSize, _v) ({ \
    glGetnMapfvARB_PACKED *packed_data = malloc(sizeof(glGetnMapfvARB_PACKED)); \
    packed_data->index = glGetnMapfvARB_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.query = (GLenum)_query; \
    packed_data->args.bufSize = (GLsizei)_bufSize; \
    packed_data->args.v = (GLfloat *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glGetnMapfvARB(packed, ret_v) do { \
    PACKED_glGetnMapfvARB *unpacked = (PACKED_glGetnMapfvARB *)packed; \
    ARGS_glGetnMapfvARB *args = (ARGS_glGetnMapfvARB *)&unpacked->args; \
    glGetnMapfvARB(args->target, args->query, args->bufSize, args->v);; \
} while(0)
void glGetnMapfvARB(glGetnMapfvARB_ARG_EXPAND);
typedef void (*glGetnMapfvARB_PTR)(glGetnMapfvARB_ARG_EXPAND);
#define glGetnMapivARB_INDEX 1069
#define glGetnMapivARB_RETURN void
#define glGetnMapivARB_ARG_NAMES target, query, bufSize, v
#define glGetnMapivARB_ARG_EXPAND GLenum target, GLenum query, GLsizei bufSize, GLint * v
#define glGetnMapivARB_PACKED PACKED_glGetnMapivARB
#define glGetnMapivARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetnMapivARB_NOT_VOID_WRAP(...) {}
#define pack_glGetnMapivARB(_target, _query, _bufSize, _v) ({ \
    glGetnMapivARB_PACKED *packed_data = malloc(sizeof(glGetnMapivARB_PACKED)); \
    packed_data->index = glGetnMapivARB_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.query = (GLenum)_query; \
    packed_data->args.bufSize = (GLsizei)_bufSize; \
    packed_data->args.v = (GLint *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glGetnMapivARB(packed, ret_v) do { \
    PACKED_glGetnMapivARB *unpacked = (PACKED_glGetnMapivARB *)packed; \
    ARGS_glGetnMapivARB *args = (ARGS_glGetnMapivARB *)&unpacked->args; \
    glGetnMapivARB(args->target, args->query, args->bufSize, args->v);; \
} while(0)
void glGetnMapivARB(glGetnMapivARB_ARG_EXPAND);
typedef void (*glGetnMapivARB_PTR)(glGetnMapivARB_ARG_EXPAND);
#define glGetnMinmaxARB_INDEX 1070
#define glGetnMinmaxARB_RETURN void
#define glGetnMinmaxARB_ARG_NAMES target, reset, format, type, bufSize, values
#define glGetnMinmaxARB_ARG_EXPAND GLenum target, GLboolean reset, GLenum format, GLenum type, GLsizei bufSize, GLvoid * values
#define glGetnMinmaxARB_PACKED PACKED_glGetnMinmaxARB
#define glGetnMinmaxARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetnMinmaxARB_NOT_VOID_WRAP(...) {}
#define pack_glGetnMinmaxARB(_target, _reset, _format, _type, _bufSize, _values) ({ \
    glGetnMinmaxARB_PACKED *packed_data = malloc(sizeof(glGetnMinmaxARB_PACKED)); \
    packed_data->index = glGetnMinmaxARB_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.reset = (GLboolean)_reset; \
    packed_data->args.format = (GLenum)_format; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.bufSize = (GLsizei)_bufSize; \
    packed_data->args.values = (GLvoid *)_values; \
    (packed_call_t *)packed_data; \
})
#define call_glGetnMinmaxARB(packed, ret_v) do { \
    PACKED_glGetnMinmaxARB *unpacked = (PACKED_glGetnMinmaxARB *)packed; \
    ARGS_glGetnMinmaxARB *args = (ARGS_glGetnMinmaxARB *)&unpacked->args; \
    glGetnMinmaxARB(args->target, args->reset, args->format, args->type, args->bufSize, args->values);; \
} while(0)
void glGetnMinmaxARB(glGetnMinmaxARB_ARG_EXPAND);
typedef void (*glGetnMinmaxARB_PTR)(glGetnMinmaxARB_ARG_EXPAND);
#define glGetnPixelMapfvARB_INDEX 1071
#define glGetnPixelMapfvARB_RETURN void
#define glGetnPixelMapfvARB_ARG_NAMES map, bufSize, values
#define glGetnPixelMapfvARB_ARG_EXPAND GLenum map, GLsizei bufSize, GLfloat * values
#define glGetnPixelMapfvARB_PACKED PACKED_glGetnPixelMapfvARB
#define glGetnPixelMapfvARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetnPixelMapfvARB_NOT_VOID_WRAP(...) {}
#define pack_glGetnPixelMapfvARB(_map, _bufSize, _values) ({ \
    glGetnPixelMapfvARB_PACKED *packed_data = malloc(sizeof(glGetnPixelMapfvARB_PACKED)); \
    packed_data->index = glGetnPixelMapfvARB_INDEX; \
    packed_data->args.map = (GLenum)_map; \
    packed_data->args.bufSize = (GLsizei)_bufSize; \
    packed_data->args.values = (GLfloat *)_values; \
    (packed_call_t *)packed_data; \
})
#define call_glGetnPixelMapfvARB(packed, ret_v) do { \
    PACKED_glGetnPixelMapfvARB *unpacked = (PACKED_glGetnPixelMapfvARB *)packed; \
    ARGS_glGetnPixelMapfvARB *args = (ARGS_glGetnPixelMapfvARB *)&unpacked->args; \
    glGetnPixelMapfvARB(args->map, args->bufSize, args->values);; \
} while(0)
void glGetnPixelMapfvARB(glGetnPixelMapfvARB_ARG_EXPAND);
typedef void (*glGetnPixelMapfvARB_PTR)(glGetnPixelMapfvARB_ARG_EXPAND);
#define glGetnPixelMapuivARB_INDEX 1072
#define glGetnPixelMapuivARB_RETURN void
#define glGetnPixelMapuivARB_ARG_NAMES map, bufSize, values
#define glGetnPixelMapuivARB_ARG_EXPAND GLenum map, GLsizei bufSize, GLuint * values
#define glGetnPixelMapuivARB_PACKED PACKED_glGetnPixelMapuivARB
#define glGetnPixelMapuivARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetnPixelMapuivARB_NOT_VOID_WRAP(...) {}
#define pack_glGetnPixelMapuivARB(_map, _bufSize, _values) ({ \
    glGetnPixelMapuivARB_PACKED *packed_data = malloc(sizeof(glGetnPixelMapuivARB_PACKED)); \
    packed_data->index = glGetnPixelMapuivARB_INDEX; \
    packed_data->args.map = (GLenum)_map; \
    packed_data->args.bufSize = (GLsizei)_bufSize; \
    packed_data->args.values = (GLuint *)_values; \
    (packed_call_t *)packed_data; \
})
#define call_glGetnPixelMapuivARB(packed, ret_v) do { \
    PACKED_glGetnPixelMapuivARB *unpacked = (PACKED_glGetnPixelMapuivARB *)packed; \
    ARGS_glGetnPixelMapuivARB *args = (ARGS_glGetnPixelMapuivARB *)&unpacked->args; \
    glGetnPixelMapuivARB(args->map, args->bufSize, args->values);; \
} while(0)
void glGetnPixelMapuivARB(glGetnPixelMapuivARB_ARG_EXPAND);
typedef void (*glGetnPixelMapuivARB_PTR)(glGetnPixelMapuivARB_ARG_EXPAND);
#define glGetnPixelMapusvARB_INDEX 1073
#define glGetnPixelMapusvARB_RETURN void
#define glGetnPixelMapusvARB_ARG_NAMES map, bufSize, values
#define glGetnPixelMapusvARB_ARG_EXPAND GLenum map, GLsizei bufSize, GLushort * values
#define glGetnPixelMapusvARB_PACKED PACKED_glGetnPixelMapusvARB
#define glGetnPixelMapusvARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetnPixelMapusvARB_NOT_VOID_WRAP(...) {}
#define pack_glGetnPixelMapusvARB(_map, _bufSize, _values) ({ \
    glGetnPixelMapusvARB_PACKED *packed_data = malloc(sizeof(glGetnPixelMapusvARB_PACKED)); \
    packed_data->index = glGetnPixelMapusvARB_INDEX; \
    packed_data->args.map = (GLenum)_map; \
    packed_data->args.bufSize = (GLsizei)_bufSize; \
    packed_data->args.values = (GLushort *)_values; \
    (packed_call_t *)packed_data; \
})
#define call_glGetnPixelMapusvARB(packed, ret_v) do { \
    PACKED_glGetnPixelMapusvARB *unpacked = (PACKED_glGetnPixelMapusvARB *)packed; \
    ARGS_glGetnPixelMapusvARB *args = (ARGS_glGetnPixelMapusvARB *)&unpacked->args; \
    glGetnPixelMapusvARB(args->map, args->bufSize, args->values);; \
} while(0)
void glGetnPixelMapusvARB(glGetnPixelMapusvARB_ARG_EXPAND);
typedef void (*glGetnPixelMapusvARB_PTR)(glGetnPixelMapusvARB_ARG_EXPAND);
#define glGetnPolygonStippleARB_INDEX 1074
#define glGetnPolygonStippleARB_RETURN void
#define glGetnPolygonStippleARB_ARG_NAMES bufSize, pattern
#define glGetnPolygonStippleARB_ARG_EXPAND GLsizei bufSize, GLubyte * pattern
#define glGetnPolygonStippleARB_PACKED PACKED_glGetnPolygonStippleARB
#define glGetnPolygonStippleARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetnPolygonStippleARB_NOT_VOID_WRAP(...) {}
#define pack_glGetnPolygonStippleARB(_bufSize, _pattern) ({ \
    glGetnPolygonStippleARB_PACKED *packed_data = malloc(sizeof(glGetnPolygonStippleARB_PACKED)); \
    packed_data->index = glGetnPolygonStippleARB_INDEX; \
    packed_data->args.bufSize = (GLsizei)_bufSize; \
    packed_data->args.pattern = (GLubyte *)_pattern; \
    (packed_call_t *)packed_data; \
})
#define call_glGetnPolygonStippleARB(packed, ret_v) do { \
    PACKED_glGetnPolygonStippleARB *unpacked = (PACKED_glGetnPolygonStippleARB *)packed; \
    ARGS_glGetnPolygonStippleARB *args = (ARGS_glGetnPolygonStippleARB *)&unpacked->args; \
    glGetnPolygonStippleARB(args->bufSize, args->pattern);; \
} while(0)
void glGetnPolygonStippleARB(glGetnPolygonStippleARB_ARG_EXPAND);
typedef void (*glGetnPolygonStippleARB_PTR)(glGetnPolygonStippleARB_ARG_EXPAND);
#define glGetnSeparableFilterARB_INDEX 1075
#define glGetnSeparableFilterARB_RETURN void
#define glGetnSeparableFilterARB_ARG_NAMES target, format, type, rowBufSize, row, columnBufSize, column, span
#define glGetnSeparableFilterARB_ARG_EXPAND GLenum target, GLenum format, GLenum type, GLsizei rowBufSize, GLvoid * row, GLsizei columnBufSize, GLvoid * column, GLvoid * span
#define glGetnSeparableFilterARB_PACKED PACKED_glGetnSeparableFilterARB
#define glGetnSeparableFilterARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetnSeparableFilterARB_NOT_VOID_WRAP(...) {}
#define pack_glGetnSeparableFilterARB(_target, _format, _type, _rowBufSize, _row, _columnBufSize, _column, _span) ({ \
    glGetnSeparableFilterARB_PACKED *packed_data = malloc(sizeof(glGetnSeparableFilterARB_PACKED)); \
    packed_data->index = glGetnSeparableFilterARB_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.format = (GLenum)_format; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.rowBufSize = (GLsizei)_rowBufSize; \
    packed_data->args.row = (GLvoid *)_row; \
    packed_data->args.columnBufSize = (GLsizei)_columnBufSize; \
    packed_data->args.column = (GLvoid *)_column; \
    packed_data->args.span = (GLvoid *)_span; \
    (packed_call_t *)packed_data; \
})
#define call_glGetnSeparableFilterARB(packed, ret_v) do { \
    PACKED_glGetnSeparableFilterARB *unpacked = (PACKED_glGetnSeparableFilterARB *)packed; \
    ARGS_glGetnSeparableFilterARB *args = (ARGS_glGetnSeparableFilterARB *)&unpacked->args; \
    glGetnSeparableFilterARB(args->target, args->format, args->type, args->rowBufSize, args->row, args->columnBufSize, args->column, args->span);; \
} while(0)
void glGetnSeparableFilterARB(glGetnSeparableFilterARB_ARG_EXPAND);
typedef void (*glGetnSeparableFilterARB_PTR)(glGetnSeparableFilterARB_ARG_EXPAND);
#define glGetnTexImageARB_INDEX 1076
#define glGetnTexImageARB_RETURN void
#define glGetnTexImageARB_ARG_NAMES target, level, format, type, bufSize, img
#define glGetnTexImageARB_ARG_EXPAND GLenum target, GLint level, GLenum format, GLenum type, GLsizei bufSize, GLvoid * img
#define glGetnTexImageARB_PACKED PACKED_glGetnTexImageARB
#define glGetnTexImageARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetnTexImageARB_NOT_VOID_WRAP(...) {}
#define pack_glGetnTexImageARB(_target, _level, _format, _type, _bufSize, _img) ({ \
    glGetnTexImageARB_PACKED *packed_data = malloc(sizeof(glGetnTexImageARB_PACKED)); \
    packed_data->index = glGetnTexImageARB_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.level = (GLint)_level; \
    packed_data->args.format = (GLenum)_format; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.bufSize = (GLsizei)_bufSize; \
    packed_data->args.img = (GLvoid *)_img; \
    (packed_call_t *)packed_data; \
})
#define call_glGetnTexImageARB(packed, ret_v) do { \
    PACKED_glGetnTexImageARB *unpacked = (PACKED_glGetnTexImageARB *)packed; \
    ARGS_glGetnTexImageARB *args = (ARGS_glGetnTexImageARB *)&unpacked->args; \
    glGetnTexImageARB(args->target, args->level, args->format, args->type, args->bufSize, args->img);; \
} while(0)
void glGetnTexImageARB(glGetnTexImageARB_ARG_EXPAND);
typedef void (*glGetnTexImageARB_PTR)(glGetnTexImageARB_ARG_EXPAND);
#define glGetnUniformdvARB_INDEX 1077
#define glGetnUniformdvARB_RETURN void
#define glGetnUniformdvARB_ARG_NAMES program, location, bufSize, params
#define glGetnUniformdvARB_ARG_EXPAND GLuint program, GLint location, GLsizei bufSize, GLdouble * params
#define glGetnUniformdvARB_PACKED PACKED_glGetnUniformdvARB
#define glGetnUniformdvARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetnUniformdvARB_NOT_VOID_WRAP(...) {}
#define pack_glGetnUniformdvARB(_program, _location, _bufSize, _params) ({ \
    glGetnUniformdvARB_PACKED *packed_data = malloc(sizeof(glGetnUniformdvARB_PACKED)); \
    packed_data->index = glGetnUniformdvARB_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.bufSize = (GLsizei)_bufSize; \
    packed_data->args.params = (GLdouble *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetnUniformdvARB(packed, ret_v) do { \
    PACKED_glGetnUniformdvARB *unpacked = (PACKED_glGetnUniformdvARB *)packed; \
    ARGS_glGetnUniformdvARB *args = (ARGS_glGetnUniformdvARB *)&unpacked->args; \
    glGetnUniformdvARB(args->program, args->location, args->bufSize, args->params);; \
} while(0)
void glGetnUniformdvARB(glGetnUniformdvARB_ARG_EXPAND);
typedef void (*glGetnUniformdvARB_PTR)(glGetnUniformdvARB_ARG_EXPAND);
#define glGetnUniformfvARB_INDEX 1078
#define glGetnUniformfvARB_RETURN void
#define glGetnUniformfvARB_ARG_NAMES program, location, bufSize, params
#define glGetnUniformfvARB_ARG_EXPAND GLuint program, GLint location, GLsizei bufSize, GLfloat * params
#define glGetnUniformfvARB_PACKED PACKED_glGetnUniformfvARB
#define glGetnUniformfvARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetnUniformfvARB_NOT_VOID_WRAP(...) {}
#define pack_glGetnUniformfvARB(_program, _location, _bufSize, _params) ({ \
    glGetnUniformfvARB_PACKED *packed_data = malloc(sizeof(glGetnUniformfvARB_PACKED)); \
    packed_data->index = glGetnUniformfvARB_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.bufSize = (GLsizei)_bufSize; \
    packed_data->args.params = (GLfloat *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetnUniformfvARB(packed, ret_v) do { \
    PACKED_glGetnUniformfvARB *unpacked = (PACKED_glGetnUniformfvARB *)packed; \
    ARGS_glGetnUniformfvARB *args = (ARGS_glGetnUniformfvARB *)&unpacked->args; \
    glGetnUniformfvARB(args->program, args->location, args->bufSize, args->params);; \
} while(0)
void glGetnUniformfvARB(glGetnUniformfvARB_ARG_EXPAND);
typedef void (*glGetnUniformfvARB_PTR)(glGetnUniformfvARB_ARG_EXPAND);
#define glGetnUniformivARB_INDEX 1079
#define glGetnUniformivARB_RETURN void
#define glGetnUniformivARB_ARG_NAMES program, location, bufSize, params
#define glGetnUniformivARB_ARG_EXPAND GLuint program, GLint location, GLsizei bufSize, GLint * params
#define glGetnUniformivARB_PACKED PACKED_glGetnUniformivARB
#define glGetnUniformivARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetnUniformivARB_NOT_VOID_WRAP(...) {}
#define pack_glGetnUniformivARB(_program, _location, _bufSize, _params) ({ \
    glGetnUniformivARB_PACKED *packed_data = malloc(sizeof(glGetnUniformivARB_PACKED)); \
    packed_data->index = glGetnUniformivARB_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.bufSize = (GLsizei)_bufSize; \
    packed_data->args.params = (GLint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetnUniformivARB(packed, ret_v) do { \
    PACKED_glGetnUniformivARB *unpacked = (PACKED_glGetnUniformivARB *)packed; \
    ARGS_glGetnUniformivARB *args = (ARGS_glGetnUniformivARB *)&unpacked->args; \
    glGetnUniformivARB(args->program, args->location, args->bufSize, args->params);; \
} while(0)
void glGetnUniformivARB(glGetnUniformivARB_ARG_EXPAND);
typedef void (*glGetnUniformivARB_PTR)(glGetnUniformivARB_ARG_EXPAND);
#define glGetnUniformuivARB_INDEX 1080
#define glGetnUniformuivARB_RETURN void
#define glGetnUniformuivARB_ARG_NAMES program, location, bufSize, params
#define glGetnUniformuivARB_ARG_EXPAND GLuint program, GLint location, GLsizei bufSize, GLuint * params
#define glGetnUniformuivARB_PACKED PACKED_glGetnUniformuivARB
#define glGetnUniformuivARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGetnUniformuivARB_NOT_VOID_WRAP(...) {}
#define pack_glGetnUniformuivARB(_program, _location, _bufSize, _params) ({ \
    glGetnUniformuivARB_PACKED *packed_data = malloc(sizeof(glGetnUniformuivARB_PACKED)); \
    packed_data->index = glGetnUniformuivARB_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.bufSize = (GLsizei)_bufSize; \
    packed_data->args.params = (GLuint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glGetnUniformuivARB(packed, ret_v) do { \
    PACKED_glGetnUniformuivARB *unpacked = (PACKED_glGetnUniformuivARB *)packed; \
    ARGS_glGetnUniformuivARB *args = (ARGS_glGetnUniformuivARB *)&unpacked->args; \
    glGetnUniformuivARB(args->program, args->location, args->bufSize, args->params);; \
} while(0)
void glGetnUniformuivARB(glGetnUniformuivARB_ARG_EXPAND);
typedef void (*glGetnUniformuivARB_PTR)(glGetnUniformuivARB_ARG_EXPAND);
#define glGlobalAlphaFactorbSUN_INDEX 1081
#define glGlobalAlphaFactorbSUN_RETURN void
#define glGlobalAlphaFactorbSUN_ARG_NAMES factor
#define glGlobalAlphaFactorbSUN_ARG_EXPAND GLbyte factor
#define glGlobalAlphaFactorbSUN_PACKED PACKED_glGlobalAlphaFactorbSUN
#define glGlobalAlphaFactorbSUN_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGlobalAlphaFactorbSUN_NOT_VOID_WRAP(...) {}
#define pack_glGlobalAlphaFactorbSUN(_factor) ({ \
    glGlobalAlphaFactorbSUN_PACKED *packed_data = malloc(sizeof(glGlobalAlphaFactorbSUN_PACKED)); \
    packed_data->index = glGlobalAlphaFactorbSUN_INDEX; \
    packed_data->args.factor = (GLbyte)_factor; \
    (packed_call_t *)packed_data; \
})
#define call_glGlobalAlphaFactorbSUN(packed, ret_v) do { \
    PACKED_glGlobalAlphaFactorbSUN *unpacked = (PACKED_glGlobalAlphaFactorbSUN *)packed; \
    ARGS_glGlobalAlphaFactorbSUN *args = (ARGS_glGlobalAlphaFactorbSUN *)&unpacked->args; \
    glGlobalAlphaFactorbSUN(args->factor);; \
} while(0)
void glGlobalAlphaFactorbSUN(glGlobalAlphaFactorbSUN_ARG_EXPAND);
typedef void (*glGlobalAlphaFactorbSUN_PTR)(glGlobalAlphaFactorbSUN_ARG_EXPAND);
#define glGlobalAlphaFactordSUN_INDEX 1082
#define glGlobalAlphaFactordSUN_RETURN void
#define glGlobalAlphaFactordSUN_ARG_NAMES factor
#define glGlobalAlphaFactordSUN_ARG_EXPAND GLdouble factor
#define glGlobalAlphaFactordSUN_PACKED PACKED_glGlobalAlphaFactordSUN
#define glGlobalAlphaFactordSUN_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGlobalAlphaFactordSUN_NOT_VOID_WRAP(...) {}
#define pack_glGlobalAlphaFactordSUN(_factor) ({ \
    glGlobalAlphaFactordSUN_PACKED *packed_data = malloc(sizeof(glGlobalAlphaFactordSUN_PACKED)); \
    packed_data->index = glGlobalAlphaFactordSUN_INDEX; \
    packed_data->args.factor = (GLdouble)_factor; \
    (packed_call_t *)packed_data; \
})
#define call_glGlobalAlphaFactordSUN(packed, ret_v) do { \
    PACKED_glGlobalAlphaFactordSUN *unpacked = (PACKED_glGlobalAlphaFactordSUN *)packed; \
    ARGS_glGlobalAlphaFactordSUN *args = (ARGS_glGlobalAlphaFactordSUN *)&unpacked->args; \
    glGlobalAlphaFactordSUN(args->factor);; \
} while(0)
void glGlobalAlphaFactordSUN(glGlobalAlphaFactordSUN_ARG_EXPAND);
typedef void (*glGlobalAlphaFactordSUN_PTR)(glGlobalAlphaFactordSUN_ARG_EXPAND);
#define glGlobalAlphaFactorfSUN_INDEX 1083
#define glGlobalAlphaFactorfSUN_RETURN void
#define glGlobalAlphaFactorfSUN_ARG_NAMES factor
#define glGlobalAlphaFactorfSUN_ARG_EXPAND GLfloat factor
#define glGlobalAlphaFactorfSUN_PACKED PACKED_glGlobalAlphaFactorfSUN
#define glGlobalAlphaFactorfSUN_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGlobalAlphaFactorfSUN_NOT_VOID_WRAP(...) {}
#define pack_glGlobalAlphaFactorfSUN(_factor) ({ \
    glGlobalAlphaFactorfSUN_PACKED *packed_data = malloc(sizeof(glGlobalAlphaFactorfSUN_PACKED)); \
    packed_data->index = glGlobalAlphaFactorfSUN_INDEX; \
    packed_data->args.factor = (GLfloat)_factor; \
    (packed_call_t *)packed_data; \
})
#define call_glGlobalAlphaFactorfSUN(packed, ret_v) do { \
    PACKED_glGlobalAlphaFactorfSUN *unpacked = (PACKED_glGlobalAlphaFactorfSUN *)packed; \
    ARGS_glGlobalAlphaFactorfSUN *args = (ARGS_glGlobalAlphaFactorfSUN *)&unpacked->args; \
    glGlobalAlphaFactorfSUN(args->factor);; \
} while(0)
void glGlobalAlphaFactorfSUN(glGlobalAlphaFactorfSUN_ARG_EXPAND);
typedef void (*glGlobalAlphaFactorfSUN_PTR)(glGlobalAlphaFactorfSUN_ARG_EXPAND);
#define glGlobalAlphaFactoriSUN_INDEX 1084
#define glGlobalAlphaFactoriSUN_RETURN void
#define glGlobalAlphaFactoriSUN_ARG_NAMES factor
#define glGlobalAlphaFactoriSUN_ARG_EXPAND GLint factor
#define glGlobalAlphaFactoriSUN_PACKED PACKED_glGlobalAlphaFactoriSUN
#define glGlobalAlphaFactoriSUN_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGlobalAlphaFactoriSUN_NOT_VOID_WRAP(...) {}
#define pack_glGlobalAlphaFactoriSUN(_factor) ({ \
    glGlobalAlphaFactoriSUN_PACKED *packed_data = malloc(sizeof(glGlobalAlphaFactoriSUN_PACKED)); \
    packed_data->index = glGlobalAlphaFactoriSUN_INDEX; \
    packed_data->args.factor = (GLint)_factor; \
    (packed_call_t *)packed_data; \
})
#define call_glGlobalAlphaFactoriSUN(packed, ret_v) do { \
    PACKED_glGlobalAlphaFactoriSUN *unpacked = (PACKED_glGlobalAlphaFactoriSUN *)packed; \
    ARGS_glGlobalAlphaFactoriSUN *args = (ARGS_glGlobalAlphaFactoriSUN *)&unpacked->args; \
    glGlobalAlphaFactoriSUN(args->factor);; \
} while(0)
void glGlobalAlphaFactoriSUN(glGlobalAlphaFactoriSUN_ARG_EXPAND);
typedef void (*glGlobalAlphaFactoriSUN_PTR)(glGlobalAlphaFactoriSUN_ARG_EXPAND);
#define glGlobalAlphaFactorsSUN_INDEX 1085
#define glGlobalAlphaFactorsSUN_RETURN void
#define glGlobalAlphaFactorsSUN_ARG_NAMES factor
#define glGlobalAlphaFactorsSUN_ARG_EXPAND GLshort factor
#define glGlobalAlphaFactorsSUN_PACKED PACKED_glGlobalAlphaFactorsSUN
#define glGlobalAlphaFactorsSUN_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGlobalAlphaFactorsSUN_NOT_VOID_WRAP(...) {}
#define pack_glGlobalAlphaFactorsSUN(_factor) ({ \
    glGlobalAlphaFactorsSUN_PACKED *packed_data = malloc(sizeof(glGlobalAlphaFactorsSUN_PACKED)); \
    packed_data->index = glGlobalAlphaFactorsSUN_INDEX; \
    packed_data->args.factor = (GLshort)_factor; \
    (packed_call_t *)packed_data; \
})
#define call_glGlobalAlphaFactorsSUN(packed, ret_v) do { \
    PACKED_glGlobalAlphaFactorsSUN *unpacked = (PACKED_glGlobalAlphaFactorsSUN *)packed; \
    ARGS_glGlobalAlphaFactorsSUN *args = (ARGS_glGlobalAlphaFactorsSUN *)&unpacked->args; \
    glGlobalAlphaFactorsSUN(args->factor);; \
} while(0)
void glGlobalAlphaFactorsSUN(glGlobalAlphaFactorsSUN_ARG_EXPAND);
typedef void (*glGlobalAlphaFactorsSUN_PTR)(glGlobalAlphaFactorsSUN_ARG_EXPAND);
#define glGlobalAlphaFactorubSUN_INDEX 1086
#define glGlobalAlphaFactorubSUN_RETURN void
#define glGlobalAlphaFactorubSUN_ARG_NAMES factor
#define glGlobalAlphaFactorubSUN_ARG_EXPAND GLubyte factor
#define glGlobalAlphaFactorubSUN_PACKED PACKED_glGlobalAlphaFactorubSUN
#define glGlobalAlphaFactorubSUN_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGlobalAlphaFactorubSUN_NOT_VOID_WRAP(...) {}
#define pack_glGlobalAlphaFactorubSUN(_factor) ({ \
    glGlobalAlphaFactorubSUN_PACKED *packed_data = malloc(sizeof(glGlobalAlphaFactorubSUN_PACKED)); \
    packed_data->index = glGlobalAlphaFactorubSUN_INDEX; \
    packed_data->args.factor = (GLubyte)_factor; \
    (packed_call_t *)packed_data; \
})
#define call_glGlobalAlphaFactorubSUN(packed, ret_v) do { \
    PACKED_glGlobalAlphaFactorubSUN *unpacked = (PACKED_glGlobalAlphaFactorubSUN *)packed; \
    ARGS_glGlobalAlphaFactorubSUN *args = (ARGS_glGlobalAlphaFactorubSUN *)&unpacked->args; \
    glGlobalAlphaFactorubSUN(args->factor);; \
} while(0)
void glGlobalAlphaFactorubSUN(glGlobalAlphaFactorubSUN_ARG_EXPAND);
typedef void (*glGlobalAlphaFactorubSUN_PTR)(glGlobalAlphaFactorubSUN_ARG_EXPAND);
#define glGlobalAlphaFactoruiSUN_INDEX 1087
#define glGlobalAlphaFactoruiSUN_RETURN void
#define glGlobalAlphaFactoruiSUN_ARG_NAMES factor
#define glGlobalAlphaFactoruiSUN_ARG_EXPAND GLuint factor
#define glGlobalAlphaFactoruiSUN_PACKED PACKED_glGlobalAlphaFactoruiSUN
#define glGlobalAlphaFactoruiSUN_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGlobalAlphaFactoruiSUN_NOT_VOID_WRAP(...) {}
#define pack_glGlobalAlphaFactoruiSUN(_factor) ({ \
    glGlobalAlphaFactoruiSUN_PACKED *packed_data = malloc(sizeof(glGlobalAlphaFactoruiSUN_PACKED)); \
    packed_data->index = glGlobalAlphaFactoruiSUN_INDEX; \
    packed_data->args.factor = (GLuint)_factor; \
    (packed_call_t *)packed_data; \
})
#define call_glGlobalAlphaFactoruiSUN(packed, ret_v) do { \
    PACKED_glGlobalAlphaFactoruiSUN *unpacked = (PACKED_glGlobalAlphaFactoruiSUN *)packed; \
    ARGS_glGlobalAlphaFactoruiSUN *args = (ARGS_glGlobalAlphaFactoruiSUN *)&unpacked->args; \
    glGlobalAlphaFactoruiSUN(args->factor);; \
} while(0)
void glGlobalAlphaFactoruiSUN(glGlobalAlphaFactoruiSUN_ARG_EXPAND);
typedef void (*glGlobalAlphaFactoruiSUN_PTR)(glGlobalAlphaFactoruiSUN_ARG_EXPAND);
#define glGlobalAlphaFactorusSUN_INDEX 1088
#define glGlobalAlphaFactorusSUN_RETURN void
#define glGlobalAlphaFactorusSUN_ARG_NAMES factor
#define glGlobalAlphaFactorusSUN_ARG_EXPAND GLushort factor
#define glGlobalAlphaFactorusSUN_PACKED PACKED_glGlobalAlphaFactorusSUN
#define glGlobalAlphaFactorusSUN_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glGlobalAlphaFactorusSUN_NOT_VOID_WRAP(...) {}
#define pack_glGlobalAlphaFactorusSUN(_factor) ({ \
    glGlobalAlphaFactorusSUN_PACKED *packed_data = malloc(sizeof(glGlobalAlphaFactorusSUN_PACKED)); \
    packed_data->index = glGlobalAlphaFactorusSUN_INDEX; \
    packed_data->args.factor = (GLushort)_factor; \
    (packed_call_t *)packed_data; \
})
#define call_glGlobalAlphaFactorusSUN(packed, ret_v) do { \
    PACKED_glGlobalAlphaFactorusSUN *unpacked = (PACKED_glGlobalAlphaFactorusSUN *)packed; \
    ARGS_glGlobalAlphaFactorusSUN *args = (ARGS_glGlobalAlphaFactorusSUN *)&unpacked->args; \
    glGlobalAlphaFactorusSUN(args->factor);; \
} while(0)
void glGlobalAlphaFactorusSUN(glGlobalAlphaFactorusSUN_ARG_EXPAND);
typedef void (*glGlobalAlphaFactorusSUN_PTR)(glGlobalAlphaFactorusSUN_ARG_EXPAND);
#define glHint_INDEX 1089
#define glHint_RETURN void
#define glHint_ARG_NAMES target, mode
#define glHint_ARG_EXPAND GLenum target, GLenum mode
#define glHint_PACKED PACKED_glHint
#define glHint_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glHint_NOT_VOID_WRAP(...) {}
#define pack_glHint(_target, _mode) ({ \
    glHint_PACKED *packed_data = malloc(sizeof(glHint_PACKED)); \
    packed_data->index = glHint_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.mode = (GLenum)_mode; \
    (packed_call_t *)packed_data; \
})
#define call_glHint(packed, ret_v) do { \
    PACKED_glHint *unpacked = (PACKED_glHint *)packed; \
    ARGS_glHint *args = (ARGS_glHint *)&unpacked->args; \
    glHint(args->target, args->mode);; \
} while(0)
void glHint(glHint_ARG_EXPAND);
typedef void (*glHint_PTR)(glHint_ARG_EXPAND);
#define glHintPGI_INDEX 1090
#define glHintPGI_RETURN void
#define glHintPGI_ARG_NAMES target, mode
#define glHintPGI_ARG_EXPAND GLenum target, GLint mode
#define glHintPGI_PACKED PACKED_glHintPGI
#define glHintPGI_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glHintPGI_NOT_VOID_WRAP(...) {}
#define pack_glHintPGI(_target, _mode) ({ \
    glHintPGI_PACKED *packed_data = malloc(sizeof(glHintPGI_PACKED)); \
    packed_data->index = glHintPGI_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.mode = (GLint)_mode; \
    (packed_call_t *)packed_data; \
})
#define call_glHintPGI(packed, ret_v) do { \
    PACKED_glHintPGI *unpacked = (PACKED_glHintPGI *)packed; \
    ARGS_glHintPGI *args = (ARGS_glHintPGI *)&unpacked->args; \
    glHintPGI(args->target, args->mode);; \
} while(0)
void glHintPGI(glHintPGI_ARG_EXPAND);
typedef void (*glHintPGI_PTR)(glHintPGI_ARG_EXPAND);
#define glHistogram_INDEX 1091
#define glHistogram_RETURN void
#define glHistogram_ARG_NAMES target, width, internalformat, sink
#define glHistogram_ARG_EXPAND GLenum target, GLsizei width, GLenum internalformat, GLboolean sink
#define glHistogram_PACKED PACKED_glHistogram
#define glHistogram_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glHistogram_NOT_VOID_WRAP(...) {}
#define pack_glHistogram(_target, _width, _internalformat, _sink) ({ \
    glHistogram_PACKED *packed_data = malloc(sizeof(glHistogram_PACKED)); \
    packed_data->index = glHistogram_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.width = (GLsizei)_width; \
    packed_data->args.internalformat = (GLenum)_internalformat; \
    packed_data->args.sink = (GLboolean)_sink; \
    (packed_call_t *)packed_data; \
})
#define call_glHistogram(packed, ret_v) do { \
    PACKED_glHistogram *unpacked = (PACKED_glHistogram *)packed; \
    ARGS_glHistogram *args = (ARGS_glHistogram *)&unpacked->args; \
    glHistogram(args->target, args->width, args->internalformat, args->sink);; \
} while(0)
void glHistogram(glHistogram_ARG_EXPAND);
typedef void (*glHistogram_PTR)(glHistogram_ARG_EXPAND);
#define glHistogramEXT_INDEX 1092
#define glHistogramEXT_RETURN void
#define glHistogramEXT_ARG_NAMES target, width, internalformat, sink
#define glHistogramEXT_ARG_EXPAND GLenum target, GLsizei width, GLenum internalformat, GLboolean sink
#define glHistogramEXT_PACKED PACKED_glHistogramEXT
#define glHistogramEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glHistogramEXT_NOT_VOID_WRAP(...) {}
#define pack_glHistogramEXT(_target, _width, _internalformat, _sink) ({ \
    glHistogramEXT_PACKED *packed_data = malloc(sizeof(glHistogramEXT_PACKED)); \
    packed_data->index = glHistogramEXT_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.width = (GLsizei)_width; \
    packed_data->args.internalformat = (GLenum)_internalformat; \
    packed_data->args.sink = (GLboolean)_sink; \
    (packed_call_t *)packed_data; \
})
#define call_glHistogramEXT(packed, ret_v) do { \
    PACKED_glHistogramEXT *unpacked = (PACKED_glHistogramEXT *)packed; \
    ARGS_glHistogramEXT *args = (ARGS_glHistogramEXT *)&unpacked->args; \
    glHistogramEXT(args->target, args->width, args->internalformat, args->sink);; \
} while(0)
void glHistogramEXT(glHistogramEXT_ARG_EXPAND);
typedef void (*glHistogramEXT_PTR)(glHistogramEXT_ARG_EXPAND);
#define glIglooInterfaceSGIX_INDEX 1093
#define glIglooInterfaceSGIX_RETURN void
#define glIglooInterfaceSGIX_ARG_NAMES pname, params
#define glIglooInterfaceSGIX_ARG_EXPAND GLenum pname, const GLvoid * params
#define glIglooInterfaceSGIX_PACKED PACKED_glIglooInterfaceSGIX
#define glIglooInterfaceSGIX_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glIglooInterfaceSGIX_NOT_VOID_WRAP(...) {}
#define pack_glIglooInterfaceSGIX(_pname, _params) ({ \
    glIglooInterfaceSGIX_PACKED *packed_data = malloc(sizeof(glIglooInterfaceSGIX_PACKED)); \
    packed_data->index = glIglooInterfaceSGIX_INDEX; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLvoid *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glIglooInterfaceSGIX(packed, ret_v) do { \
    PACKED_glIglooInterfaceSGIX *unpacked = (PACKED_glIglooInterfaceSGIX *)packed; \
    ARGS_glIglooInterfaceSGIX *args = (ARGS_glIglooInterfaceSGIX *)&unpacked->args; \
    glIglooInterfaceSGIX(args->pname, args->params);; \
} while(0)
void glIglooInterfaceSGIX(glIglooInterfaceSGIX_ARG_EXPAND);
typedef void (*glIglooInterfaceSGIX_PTR)(glIglooInterfaceSGIX_ARG_EXPAND);
#define glImageTransformParameterfHP_INDEX 1094
#define glImageTransformParameterfHP_RETURN void
#define glImageTransformParameterfHP_ARG_NAMES target, pname, param
#define glImageTransformParameterfHP_ARG_EXPAND GLenum target, GLenum pname, GLfloat param
#define glImageTransformParameterfHP_PACKED PACKED_glImageTransformParameterfHP
#define glImageTransformParameterfHP_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glImageTransformParameterfHP_NOT_VOID_WRAP(...) {}
#define pack_glImageTransformParameterfHP(_target, _pname, _param) ({ \
    glImageTransformParameterfHP_PACKED *packed_data = malloc(sizeof(glImageTransformParameterfHP_PACKED)); \
    packed_data->index = glImageTransformParameterfHP_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.param = (GLfloat)_param; \
    (packed_call_t *)packed_data; \
})
#define call_glImageTransformParameterfHP(packed, ret_v) do { \
    PACKED_glImageTransformParameterfHP *unpacked = (PACKED_glImageTransformParameterfHP *)packed; \
    ARGS_glImageTransformParameterfHP *args = (ARGS_glImageTransformParameterfHP *)&unpacked->args; \
    glImageTransformParameterfHP(args->target, args->pname, args->param);; \
} while(0)
void glImageTransformParameterfHP(glImageTransformParameterfHP_ARG_EXPAND);
typedef void (*glImageTransformParameterfHP_PTR)(glImageTransformParameterfHP_ARG_EXPAND);
#define glImageTransformParameterfvHP_INDEX 1095
#define glImageTransformParameterfvHP_RETURN void
#define glImageTransformParameterfvHP_ARG_NAMES target, pname, params
#define glImageTransformParameterfvHP_ARG_EXPAND GLenum target, GLenum pname, const GLfloat * params
#define glImageTransformParameterfvHP_PACKED PACKED_glImageTransformParameterfvHP
#define glImageTransformParameterfvHP_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glImageTransformParameterfvHP_NOT_VOID_WRAP(...) {}
#define pack_glImageTransformParameterfvHP(_target, _pname, _params) ({ \
    glImageTransformParameterfvHP_PACKED *packed_data = malloc(sizeof(glImageTransformParameterfvHP_PACKED)); \
    packed_data->index = glImageTransformParameterfvHP_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLfloat *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glImageTransformParameterfvHP(packed, ret_v) do { \
    PACKED_glImageTransformParameterfvHP *unpacked = (PACKED_glImageTransformParameterfvHP *)packed; \
    ARGS_glImageTransformParameterfvHP *args = (ARGS_glImageTransformParameterfvHP *)&unpacked->args; \
    glImageTransformParameterfvHP(args->target, args->pname, args->params);; \
} while(0)
void glImageTransformParameterfvHP(glImageTransformParameterfvHP_ARG_EXPAND);
typedef void (*glImageTransformParameterfvHP_PTR)(glImageTransformParameterfvHP_ARG_EXPAND);
#define glImageTransformParameteriHP_INDEX 1096
#define glImageTransformParameteriHP_RETURN void
#define glImageTransformParameteriHP_ARG_NAMES target, pname, param
#define glImageTransformParameteriHP_ARG_EXPAND GLenum target, GLenum pname, GLint param
#define glImageTransformParameteriHP_PACKED PACKED_glImageTransformParameteriHP
#define glImageTransformParameteriHP_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glImageTransformParameteriHP_NOT_VOID_WRAP(...) {}
#define pack_glImageTransformParameteriHP(_target, _pname, _param) ({ \
    glImageTransformParameteriHP_PACKED *packed_data = malloc(sizeof(glImageTransformParameteriHP_PACKED)); \
    packed_data->index = glImageTransformParameteriHP_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.param = (GLint)_param; \
    (packed_call_t *)packed_data; \
})
#define call_glImageTransformParameteriHP(packed, ret_v) do { \
    PACKED_glImageTransformParameteriHP *unpacked = (PACKED_glImageTransformParameteriHP *)packed; \
    ARGS_glImageTransformParameteriHP *args = (ARGS_glImageTransformParameteriHP *)&unpacked->args; \
    glImageTransformParameteriHP(args->target, args->pname, args->param);; \
} while(0)
void glImageTransformParameteriHP(glImageTransformParameteriHP_ARG_EXPAND);
typedef void (*glImageTransformParameteriHP_PTR)(glImageTransformParameteriHP_ARG_EXPAND);
#define glImageTransformParameterivHP_INDEX 1097
#define glImageTransformParameterivHP_RETURN void
#define glImageTransformParameterivHP_ARG_NAMES target, pname, params
#define glImageTransformParameterivHP_ARG_EXPAND GLenum target, GLenum pname, const GLint * params
#define glImageTransformParameterivHP_PACKED PACKED_glImageTransformParameterivHP
#define glImageTransformParameterivHP_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glImageTransformParameterivHP_NOT_VOID_WRAP(...) {}
#define pack_glImageTransformParameterivHP(_target, _pname, _params) ({ \
    glImageTransformParameterivHP_PACKED *packed_data = malloc(sizeof(glImageTransformParameterivHP_PACKED)); \
    packed_data->index = glImageTransformParameterivHP_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glImageTransformParameterivHP(packed, ret_v) do { \
    PACKED_glImageTransformParameterivHP *unpacked = (PACKED_glImageTransformParameterivHP *)packed; \
    ARGS_glImageTransformParameterivHP *args = (ARGS_glImageTransformParameterivHP *)&unpacked->args; \
    glImageTransformParameterivHP(args->target, args->pname, args->params);; \
} while(0)
void glImageTransformParameterivHP(glImageTransformParameterivHP_ARG_EXPAND);
typedef void (*glImageTransformParameterivHP_PTR)(glImageTransformParameterivHP_ARG_EXPAND);
#define glImportSyncEXT_INDEX 1098
#define glImportSyncEXT_RETURN GLsync
#define glImportSyncEXT_ARG_NAMES external_sync_type, external_sync, flags
#define glImportSyncEXT_ARG_EXPAND GLenum external_sync_type, GLintptr external_sync, GLbitfield flags
#define glImportSyncEXT_PACKED PACKED_glImportSyncEXT
#define glImportSyncEXT_VOID_ONLY_WRAP(...) {}
#define glImportSyncEXT_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glImportSyncEXT(_external_sync_type, _external_sync, _flags) ({ \
    glImportSyncEXT_PACKED *packed_data = malloc(sizeof(glImportSyncEXT_PACKED)); \
    packed_data->index = glImportSyncEXT_INDEX; \
    packed_data->args.external_sync_type = (GLenum)_external_sync_type; \
    packed_data->args.external_sync = (GLintptr)_external_sync; \
    packed_data->args.flags = (GLbitfield)_flags; \
    (packed_call_t *)packed_data; \
})
#define call_glImportSyncEXT(packed, ret_v) do { \
    PACKED_glImportSyncEXT *unpacked = (PACKED_glImportSyncEXT *)packed; \
    ARGS_glImportSyncEXT *args = (ARGS_glImportSyncEXT *)&unpacked->args; \
    GLsync *ret = (GLsync *)ret_v; \
    if (ret != NULL) { \
        *ret = glImportSyncEXT(args->external_sync_type, args->external_sync, args->flags);; \
    } else { \
        glImportSyncEXT(args->external_sync_type, args->external_sync, args->flags);; \
    } \
} while(0)
GLsync glImportSyncEXT(glImportSyncEXT_ARG_EXPAND);
typedef GLsync (*glImportSyncEXT_PTR)(glImportSyncEXT_ARG_EXPAND);
#define glIndexFormatNV_INDEX 1099
#define glIndexFormatNV_RETURN void
#define glIndexFormatNV_ARG_NAMES type, stride
#define glIndexFormatNV_ARG_EXPAND GLenum type, GLsizei stride
#define glIndexFormatNV_PACKED PACKED_glIndexFormatNV
#define glIndexFormatNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glIndexFormatNV_NOT_VOID_WRAP(...) {}
#define pack_glIndexFormatNV(_type, _stride) ({ \
    glIndexFormatNV_PACKED *packed_data = malloc(sizeof(glIndexFormatNV_PACKED)); \
    packed_data->index = glIndexFormatNV_INDEX; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.stride = (GLsizei)_stride; \
    (packed_call_t *)packed_data; \
})
#define call_glIndexFormatNV(packed, ret_v) do { \
    PACKED_glIndexFormatNV *unpacked = (PACKED_glIndexFormatNV *)packed; \
    ARGS_glIndexFormatNV *args = (ARGS_glIndexFormatNV *)&unpacked->args; \
    glIndexFormatNV(args->type, args->stride);; \
} while(0)
void glIndexFormatNV(glIndexFormatNV_ARG_EXPAND);
typedef void (*glIndexFormatNV_PTR)(glIndexFormatNV_ARG_EXPAND);
#define glIndexFuncEXT_INDEX 1100
#define glIndexFuncEXT_RETURN void
#define glIndexFuncEXT_ARG_NAMES func, ref
#define glIndexFuncEXT_ARG_EXPAND GLenum func, GLclampf ref
#define glIndexFuncEXT_PACKED PACKED_glIndexFuncEXT
#define glIndexFuncEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glIndexFuncEXT_NOT_VOID_WRAP(...) {}
#define pack_glIndexFuncEXT(_func, _ref) ({ \
    glIndexFuncEXT_PACKED *packed_data = malloc(sizeof(glIndexFuncEXT_PACKED)); \
    packed_data->index = glIndexFuncEXT_INDEX; \
    packed_data->args.func = (GLenum)_func; \
    packed_data->args.ref = (GLclampf)_ref; \
    (packed_call_t *)packed_data; \
})
#define call_glIndexFuncEXT(packed, ret_v) do { \
    PACKED_glIndexFuncEXT *unpacked = (PACKED_glIndexFuncEXT *)packed; \
    ARGS_glIndexFuncEXT *args = (ARGS_glIndexFuncEXT *)&unpacked->args; \
    glIndexFuncEXT(args->func, args->ref);; \
} while(0)
void glIndexFuncEXT(glIndexFuncEXT_ARG_EXPAND);
typedef void (*glIndexFuncEXT_PTR)(glIndexFuncEXT_ARG_EXPAND);
#define glIndexMask_INDEX 1101
#define glIndexMask_RETURN void
#define glIndexMask_ARG_NAMES mask
#define glIndexMask_ARG_EXPAND GLuint mask
#define glIndexMask_PACKED PACKED_glIndexMask
#define glIndexMask_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glIndexMask_NOT_VOID_WRAP(...) {}
#define pack_glIndexMask(_mask) ({ \
    glIndexMask_PACKED *packed_data = malloc(sizeof(glIndexMask_PACKED)); \
    packed_data->index = glIndexMask_INDEX; \
    packed_data->args.mask = (GLuint)_mask; \
    (packed_call_t *)packed_data; \
})
#define call_glIndexMask(packed, ret_v) do { \
    PACKED_glIndexMask *unpacked = (PACKED_glIndexMask *)packed; \
    ARGS_glIndexMask *args = (ARGS_glIndexMask *)&unpacked->args; \
    glIndexMask(args->mask);; \
} while(0)
void glIndexMask(glIndexMask_ARG_EXPAND);
typedef void (*glIndexMask_PTR)(glIndexMask_ARG_EXPAND);
#define glIndexMaterialEXT_INDEX 1102
#define glIndexMaterialEXT_RETURN void
#define glIndexMaterialEXT_ARG_NAMES face, mode
#define glIndexMaterialEXT_ARG_EXPAND GLenum face, GLenum mode
#define glIndexMaterialEXT_PACKED PACKED_glIndexMaterialEXT
#define glIndexMaterialEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glIndexMaterialEXT_NOT_VOID_WRAP(...) {}
#define pack_glIndexMaterialEXT(_face, _mode) ({ \
    glIndexMaterialEXT_PACKED *packed_data = malloc(sizeof(glIndexMaterialEXT_PACKED)); \
    packed_data->index = glIndexMaterialEXT_INDEX; \
    packed_data->args.face = (GLenum)_face; \
    packed_data->args.mode = (GLenum)_mode; \
    (packed_call_t *)packed_data; \
})
#define call_glIndexMaterialEXT(packed, ret_v) do { \
    PACKED_glIndexMaterialEXT *unpacked = (PACKED_glIndexMaterialEXT *)packed; \
    ARGS_glIndexMaterialEXT *args = (ARGS_glIndexMaterialEXT *)&unpacked->args; \
    glIndexMaterialEXT(args->face, args->mode);; \
} while(0)
void glIndexMaterialEXT(glIndexMaterialEXT_ARG_EXPAND);
typedef void (*glIndexMaterialEXT_PTR)(glIndexMaterialEXT_ARG_EXPAND);
#define glIndexPointer_INDEX 1103
#define glIndexPointer_RETURN void
#define glIndexPointer_ARG_NAMES type, stride, pointer
#define glIndexPointer_ARG_EXPAND GLenum type, GLsizei stride, const GLvoid * pointer
#define glIndexPointer_PACKED PACKED_glIndexPointer
#define glIndexPointer_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glIndexPointer_NOT_VOID_WRAP(...) {}
#define pack_glIndexPointer(_type, _stride, _pointer) ({ \
    glIndexPointer_PACKED *packed_data = malloc(sizeof(glIndexPointer_PACKED)); \
    packed_data->index = glIndexPointer_INDEX; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.stride = (GLsizei)_stride; \
    packed_data->args.pointer = (GLvoid *)_pointer; \
    (packed_call_t *)packed_data; \
})
#define call_glIndexPointer(packed, ret_v) do { \
    PACKED_glIndexPointer *unpacked = (PACKED_glIndexPointer *)packed; \
    ARGS_glIndexPointer *args = (ARGS_glIndexPointer *)&unpacked->args; \
    glIndexPointer(args->type, args->stride, args->pointer);; \
} while(0)
void glIndexPointer(glIndexPointer_ARG_EXPAND);
typedef void (*glIndexPointer_PTR)(glIndexPointer_ARG_EXPAND);
#define glIndexPointerEXT_INDEX 1104
#define glIndexPointerEXT_RETURN void
#define glIndexPointerEXT_ARG_NAMES type, stride, count, pointer
#define glIndexPointerEXT_ARG_EXPAND GLenum type, GLsizei stride, GLsizei count, const GLvoid * pointer
#define glIndexPointerEXT_PACKED PACKED_glIndexPointerEXT
#define glIndexPointerEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glIndexPointerEXT_NOT_VOID_WRAP(...) {}
#define pack_glIndexPointerEXT(_type, _stride, _count, _pointer) ({ \
    glIndexPointerEXT_PACKED *packed_data = malloc(sizeof(glIndexPointerEXT_PACKED)); \
    packed_data->index = glIndexPointerEXT_INDEX; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.stride = (GLsizei)_stride; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.pointer = (GLvoid *)_pointer; \
    (packed_call_t *)packed_data; \
})
#define call_glIndexPointerEXT(packed, ret_v) do { \
    PACKED_glIndexPointerEXT *unpacked = (PACKED_glIndexPointerEXT *)packed; \
    ARGS_glIndexPointerEXT *args = (ARGS_glIndexPointerEXT *)&unpacked->args; \
    glIndexPointerEXT(args->type, args->stride, args->count, args->pointer);; \
} while(0)
void glIndexPointerEXT(glIndexPointerEXT_ARG_EXPAND);
typedef void (*glIndexPointerEXT_PTR)(glIndexPointerEXT_ARG_EXPAND);
#define glIndexPointerListIBM_INDEX 1105
#define glIndexPointerListIBM_RETURN void
#define glIndexPointerListIBM_ARG_NAMES type, stride, pointer, ptrstride
#define glIndexPointerListIBM_ARG_EXPAND GLenum type, GLint stride, const GLvoid * pointer, GLint ptrstride
#define glIndexPointerListIBM_PACKED PACKED_glIndexPointerListIBM
#define glIndexPointerListIBM_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glIndexPointerListIBM_NOT_VOID_WRAP(...) {}
#define pack_glIndexPointerListIBM(_type, _stride, _pointer, _ptrstride) ({ \
    glIndexPointerListIBM_PACKED *packed_data = malloc(sizeof(glIndexPointerListIBM_PACKED)); \
    packed_data->index = glIndexPointerListIBM_INDEX; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.stride = (GLint)_stride; \
    packed_data->args.pointer = (GLvoid *)_pointer; \
    packed_data->args.ptrstride = (GLint)_ptrstride; \
    (packed_call_t *)packed_data; \
})
#define call_glIndexPointerListIBM(packed, ret_v) do { \
    PACKED_glIndexPointerListIBM *unpacked = (PACKED_glIndexPointerListIBM *)packed; \
    ARGS_glIndexPointerListIBM *args = (ARGS_glIndexPointerListIBM *)&unpacked->args; \
    glIndexPointerListIBM(args->type, args->stride, args->pointer, args->ptrstride);; \
} while(0)
void glIndexPointerListIBM(glIndexPointerListIBM_ARG_EXPAND);
typedef void (*glIndexPointerListIBM_PTR)(glIndexPointerListIBM_ARG_EXPAND);
#define glIndexd_INDEX 1106
#define glIndexd_RETURN void
#define glIndexd_ARG_NAMES c
#define glIndexd_ARG_EXPAND GLdouble c
#define glIndexd_PACKED PACKED_glIndexd
#define glIndexd_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glIndexd_NOT_VOID_WRAP(...) {}
#define pack_glIndexd(_c) ({ \
    glIndexd_PACKED *packed_data = malloc(sizeof(glIndexd_PACKED)); \
    packed_data->index = glIndexd_INDEX; \
    packed_data->args.c = (GLdouble)_c; \
    (packed_call_t *)packed_data; \
})
#define call_glIndexd(packed, ret_v) do { \
    PACKED_glIndexd *unpacked = (PACKED_glIndexd *)packed; \
    ARGS_glIndexd *args = (ARGS_glIndexd *)&unpacked->args; \
    glIndexd(args->c);; \
} while(0)
void glIndexd(glIndexd_ARG_EXPAND);
typedef void (*glIndexd_PTR)(glIndexd_ARG_EXPAND);
#define glIndexdv_INDEX 1107
#define glIndexdv_RETURN void
#define glIndexdv_ARG_NAMES c
#define glIndexdv_ARG_EXPAND const GLdouble * c
#define glIndexdv_PACKED PACKED_glIndexdv
#define glIndexdv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glIndexdv_NOT_VOID_WRAP(...) {}
#define pack_glIndexdv(_c) ({ \
    glIndexdv_PACKED *packed_data = malloc(sizeof(glIndexdv_PACKED)); \
    packed_data->index = glIndexdv_INDEX; \
    packed_data->args.c = (GLdouble *)_c; \
    (packed_call_t *)packed_data; \
})
#define call_glIndexdv(packed, ret_v) do { \
    PACKED_glIndexdv *unpacked = (PACKED_glIndexdv *)packed; \
    ARGS_glIndexdv *args = (ARGS_glIndexdv *)&unpacked->args; \
    glIndexdv(args->c);; \
} while(0)
void glIndexdv(glIndexdv_ARG_EXPAND);
typedef void (*glIndexdv_PTR)(glIndexdv_ARG_EXPAND);
#define glIndexf_INDEX 1108
#define glIndexf_RETURN void
#define glIndexf_ARG_NAMES c
#define glIndexf_ARG_EXPAND GLfloat c
#define glIndexf_PACKED PACKED_glIndexf
#define glIndexf_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glIndexf_NOT_VOID_WRAP(...) {}
#define pack_glIndexf(_c) ({ \
    glIndexf_PACKED *packed_data = malloc(sizeof(glIndexf_PACKED)); \
    packed_data->index = glIndexf_INDEX; \
    packed_data->args.c = (GLfloat)_c; \
    (packed_call_t *)packed_data; \
})
#define call_glIndexf(packed, ret_v) do { \
    PACKED_glIndexf *unpacked = (PACKED_glIndexf *)packed; \
    ARGS_glIndexf *args = (ARGS_glIndexf *)&unpacked->args; \
    glIndexf(args->c);; \
} while(0)
void glIndexf(glIndexf_ARG_EXPAND);
typedef void (*glIndexf_PTR)(glIndexf_ARG_EXPAND);
#define glIndexfv_INDEX 1109
#define glIndexfv_RETURN void
#define glIndexfv_ARG_NAMES c
#define glIndexfv_ARG_EXPAND const GLfloat * c
#define glIndexfv_PACKED PACKED_glIndexfv
#define glIndexfv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glIndexfv_NOT_VOID_WRAP(...) {}
#define pack_glIndexfv(_c) ({ \
    glIndexfv_PACKED *packed_data = malloc(sizeof(glIndexfv_PACKED)); \
    packed_data->index = glIndexfv_INDEX; \
    packed_data->args.c = (GLfloat *)_c; \
    (packed_call_t *)packed_data; \
})
#define call_glIndexfv(packed, ret_v) do { \
    PACKED_glIndexfv *unpacked = (PACKED_glIndexfv *)packed; \
    ARGS_glIndexfv *args = (ARGS_glIndexfv *)&unpacked->args; \
    glIndexfv(args->c);; \
} while(0)
void glIndexfv(glIndexfv_ARG_EXPAND);
typedef void (*glIndexfv_PTR)(glIndexfv_ARG_EXPAND);
#define glIndexi_INDEX 1110
#define glIndexi_RETURN void
#define glIndexi_ARG_NAMES c
#define glIndexi_ARG_EXPAND GLint c
#define glIndexi_PACKED PACKED_glIndexi
#define glIndexi_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glIndexi_NOT_VOID_WRAP(...) {}
#define pack_glIndexi(_c) ({ \
    glIndexi_PACKED *packed_data = malloc(sizeof(glIndexi_PACKED)); \
    packed_data->index = glIndexi_INDEX; \
    packed_data->args.c = (GLint)_c; \
    (packed_call_t *)packed_data; \
})
#define call_glIndexi(packed, ret_v) do { \
    PACKED_glIndexi *unpacked = (PACKED_glIndexi *)packed; \
    ARGS_glIndexi *args = (ARGS_glIndexi *)&unpacked->args; \
    glIndexi(args->c);; \
} while(0)
void glIndexi(glIndexi_ARG_EXPAND);
typedef void (*glIndexi_PTR)(glIndexi_ARG_EXPAND);
#define glIndexiv_INDEX 1111
#define glIndexiv_RETURN void
#define glIndexiv_ARG_NAMES c
#define glIndexiv_ARG_EXPAND const GLint * c
#define glIndexiv_PACKED PACKED_glIndexiv
#define glIndexiv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glIndexiv_NOT_VOID_WRAP(...) {}
#define pack_glIndexiv(_c) ({ \
    glIndexiv_PACKED *packed_data = malloc(sizeof(glIndexiv_PACKED)); \
    packed_data->index = glIndexiv_INDEX; \
    packed_data->args.c = (GLint *)_c; \
    (packed_call_t *)packed_data; \
})
#define call_glIndexiv(packed, ret_v) do { \
    PACKED_glIndexiv *unpacked = (PACKED_glIndexiv *)packed; \
    ARGS_glIndexiv *args = (ARGS_glIndexiv *)&unpacked->args; \
    glIndexiv(args->c);; \
} while(0)
void glIndexiv(glIndexiv_ARG_EXPAND);
typedef void (*glIndexiv_PTR)(glIndexiv_ARG_EXPAND);
#define glIndexs_INDEX 1112
#define glIndexs_RETURN void
#define glIndexs_ARG_NAMES c
#define glIndexs_ARG_EXPAND GLshort c
#define glIndexs_PACKED PACKED_glIndexs
#define glIndexs_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glIndexs_NOT_VOID_WRAP(...) {}
#define pack_glIndexs(_c) ({ \
    glIndexs_PACKED *packed_data = malloc(sizeof(glIndexs_PACKED)); \
    packed_data->index = glIndexs_INDEX; \
    packed_data->args.c = (GLshort)_c; \
    (packed_call_t *)packed_data; \
})
#define call_glIndexs(packed, ret_v) do { \
    PACKED_glIndexs *unpacked = (PACKED_glIndexs *)packed; \
    ARGS_glIndexs *args = (ARGS_glIndexs *)&unpacked->args; \
    glIndexs(args->c);; \
} while(0)
void glIndexs(glIndexs_ARG_EXPAND);
typedef void (*glIndexs_PTR)(glIndexs_ARG_EXPAND);
#define glIndexsv_INDEX 1113
#define glIndexsv_RETURN void
#define glIndexsv_ARG_NAMES c
#define glIndexsv_ARG_EXPAND const GLshort * c
#define glIndexsv_PACKED PACKED_glIndexsv
#define glIndexsv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glIndexsv_NOT_VOID_WRAP(...) {}
#define pack_glIndexsv(_c) ({ \
    glIndexsv_PACKED *packed_data = malloc(sizeof(glIndexsv_PACKED)); \
    packed_data->index = glIndexsv_INDEX; \
    packed_data->args.c = (GLshort *)_c; \
    (packed_call_t *)packed_data; \
})
#define call_glIndexsv(packed, ret_v) do { \
    PACKED_glIndexsv *unpacked = (PACKED_glIndexsv *)packed; \
    ARGS_glIndexsv *args = (ARGS_glIndexsv *)&unpacked->args; \
    glIndexsv(args->c);; \
} while(0)
void glIndexsv(glIndexsv_ARG_EXPAND);
typedef void (*glIndexsv_PTR)(glIndexsv_ARG_EXPAND);
#define glIndexub_INDEX 1114
#define glIndexub_RETURN void
#define glIndexub_ARG_NAMES c
#define glIndexub_ARG_EXPAND GLubyte c
#define glIndexub_PACKED PACKED_glIndexub
#define glIndexub_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glIndexub_NOT_VOID_WRAP(...) {}
#define pack_glIndexub(_c) ({ \
    glIndexub_PACKED *packed_data = malloc(sizeof(glIndexub_PACKED)); \
    packed_data->index = glIndexub_INDEX; \
    packed_data->args.c = (GLubyte)_c; \
    (packed_call_t *)packed_data; \
})
#define call_glIndexub(packed, ret_v) do { \
    PACKED_glIndexub *unpacked = (PACKED_glIndexub *)packed; \
    ARGS_glIndexub *args = (ARGS_glIndexub *)&unpacked->args; \
    glIndexub(args->c);; \
} while(0)
void glIndexub(glIndexub_ARG_EXPAND);
typedef void (*glIndexub_PTR)(glIndexub_ARG_EXPAND);
#define glIndexubv_INDEX 1115
#define glIndexubv_RETURN void
#define glIndexubv_ARG_NAMES c
#define glIndexubv_ARG_EXPAND const GLubyte * c
#define glIndexubv_PACKED PACKED_glIndexubv
#define glIndexubv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glIndexubv_NOT_VOID_WRAP(...) {}
#define pack_glIndexubv(_c) ({ \
    glIndexubv_PACKED *packed_data = malloc(sizeof(glIndexubv_PACKED)); \
    packed_data->index = glIndexubv_INDEX; \
    packed_data->args.c = (GLubyte *)_c; \
    (packed_call_t *)packed_data; \
})
#define call_glIndexubv(packed, ret_v) do { \
    PACKED_glIndexubv *unpacked = (PACKED_glIndexubv *)packed; \
    ARGS_glIndexubv *args = (ARGS_glIndexubv *)&unpacked->args; \
    glIndexubv(args->c);; \
} while(0)
void glIndexubv(glIndexubv_ARG_EXPAND);
typedef void (*glIndexubv_PTR)(glIndexubv_ARG_EXPAND);
#define glIndexxOES_INDEX 1116
#define glIndexxOES_RETURN void
#define glIndexxOES_ARG_NAMES component
#define glIndexxOES_ARG_EXPAND GLfixed component
#define glIndexxOES_PACKED PACKED_glIndexxOES
#define glIndexxOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glIndexxOES_NOT_VOID_WRAP(...) {}
#define pack_glIndexxOES(_component) ({ \
    glIndexxOES_PACKED *packed_data = malloc(sizeof(glIndexxOES_PACKED)); \
    packed_data->index = glIndexxOES_INDEX; \
    packed_data->args.component = (GLfixed)_component; \
    (packed_call_t *)packed_data; \
})
#define call_glIndexxOES(packed, ret_v) do { \
    PACKED_glIndexxOES *unpacked = (PACKED_glIndexxOES *)packed; \
    ARGS_glIndexxOES *args = (ARGS_glIndexxOES *)&unpacked->args; \
    glIndexxOES(args->component);; \
} while(0)
void glIndexxOES(glIndexxOES_ARG_EXPAND);
typedef void (*glIndexxOES_PTR)(glIndexxOES_ARG_EXPAND);
#define glIndexxvOES_INDEX 1117
#define glIndexxvOES_RETURN void
#define glIndexxvOES_ARG_NAMES component
#define glIndexxvOES_ARG_EXPAND const GLfixed * component
#define glIndexxvOES_PACKED PACKED_glIndexxvOES
#define glIndexxvOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glIndexxvOES_NOT_VOID_WRAP(...) {}
#define pack_glIndexxvOES(_component) ({ \
    glIndexxvOES_PACKED *packed_data = malloc(sizeof(glIndexxvOES_PACKED)); \
    packed_data->index = glIndexxvOES_INDEX; \
    packed_data->args.component = (GLfixed *)_component; \
    (packed_call_t *)packed_data; \
})
#define call_glIndexxvOES(packed, ret_v) do { \
    PACKED_glIndexxvOES *unpacked = (PACKED_glIndexxvOES *)packed; \
    ARGS_glIndexxvOES *args = (ARGS_glIndexxvOES *)&unpacked->args; \
    glIndexxvOES(args->component);; \
} while(0)
void glIndexxvOES(glIndexxvOES_ARG_EXPAND);
typedef void (*glIndexxvOES_PTR)(glIndexxvOES_ARG_EXPAND);
#define glInitNames_INDEX 1118
#define glInitNames_RETURN void
#define glInitNames_ARG_NAMES 
#define glInitNames_ARG_EXPAND 
#define glInitNames_PACKED PACKED_glInitNames
#define glInitNames_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glInitNames_NOT_VOID_WRAP(...) {}
#define pack_glInitNames() ({ \
    glInitNames_PACKED *packed_data = malloc(sizeof(glInitNames_PACKED)); \
    packed_data->index = glInitNames_INDEX; \
    (packed_call_t *)packed_data; \
})
#define call_glInitNames(packed, ret_v) do { \
    glInitNames();; \
} while(0)
void glInitNames(glInitNames_ARG_EXPAND);
typedef void (*glInitNames_PTR)(glInitNames_ARG_EXPAND);
#define glInsertComponentEXT_INDEX 1119
#define glInsertComponentEXT_RETURN void
#define glInsertComponentEXT_ARG_NAMES res, src, num
#define glInsertComponentEXT_ARG_EXPAND GLuint res, GLuint src, GLuint num
#define glInsertComponentEXT_PACKED PACKED_glInsertComponentEXT
#define glInsertComponentEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glInsertComponentEXT_NOT_VOID_WRAP(...) {}
#define pack_glInsertComponentEXT(_res, _src, _num) ({ \
    glInsertComponentEXT_PACKED *packed_data = malloc(sizeof(glInsertComponentEXT_PACKED)); \
    packed_data->index = glInsertComponentEXT_INDEX; \
    packed_data->args.res = (GLuint)_res; \
    packed_data->args.src = (GLuint)_src; \
    packed_data->args.num = (GLuint)_num; \
    (packed_call_t *)packed_data; \
})
#define call_glInsertComponentEXT(packed, ret_v) do { \
    PACKED_glInsertComponentEXT *unpacked = (PACKED_glInsertComponentEXT *)packed; \
    ARGS_glInsertComponentEXT *args = (ARGS_glInsertComponentEXT *)&unpacked->args; \
    glInsertComponentEXT(args->res, args->src, args->num);; \
} while(0)
void glInsertComponentEXT(glInsertComponentEXT_ARG_EXPAND);
typedef void (*glInsertComponentEXT_PTR)(glInsertComponentEXT_ARG_EXPAND);
#define glInstrumentsBufferSGIX_INDEX 1120
#define glInstrumentsBufferSGIX_RETURN void
#define glInstrumentsBufferSGIX_ARG_NAMES size, buffer
#define glInstrumentsBufferSGIX_ARG_EXPAND GLsizei size, GLint * buffer
#define glInstrumentsBufferSGIX_PACKED PACKED_glInstrumentsBufferSGIX
#define glInstrumentsBufferSGIX_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glInstrumentsBufferSGIX_NOT_VOID_WRAP(...) {}
#define pack_glInstrumentsBufferSGIX(_size, _buffer) ({ \
    glInstrumentsBufferSGIX_PACKED *packed_data = malloc(sizeof(glInstrumentsBufferSGIX_PACKED)); \
    packed_data->index = glInstrumentsBufferSGIX_INDEX; \
    packed_data->args.size = (GLsizei)_size; \
    packed_data->args.buffer = (GLint *)_buffer; \
    (packed_call_t *)packed_data; \
})
#define call_glInstrumentsBufferSGIX(packed, ret_v) do { \
    PACKED_glInstrumentsBufferSGIX *unpacked = (PACKED_glInstrumentsBufferSGIX *)packed; \
    ARGS_glInstrumentsBufferSGIX *args = (ARGS_glInstrumentsBufferSGIX *)&unpacked->args; \
    glInstrumentsBufferSGIX(args->size, args->buffer);; \
} while(0)
void glInstrumentsBufferSGIX(glInstrumentsBufferSGIX_ARG_EXPAND);
typedef void (*glInstrumentsBufferSGIX_PTR)(glInstrumentsBufferSGIX_ARG_EXPAND);
#define glInterleavedArrays_INDEX 1121
#define glInterleavedArrays_RETURN void
#define glInterleavedArrays_ARG_NAMES format, stride, pointer
#define glInterleavedArrays_ARG_EXPAND GLenum format, GLsizei stride, const GLvoid * pointer
#define glInterleavedArrays_PACKED PACKED_glInterleavedArrays
#define glInterleavedArrays_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glInterleavedArrays_NOT_VOID_WRAP(...) {}
#define pack_glInterleavedArrays(_format, _stride, _pointer) ({ \
    glInterleavedArrays_PACKED *packed_data = malloc(sizeof(glInterleavedArrays_PACKED)); \
    packed_data->index = glInterleavedArrays_INDEX; \
    packed_data->args.format = (GLenum)_format; \
    packed_data->args.stride = (GLsizei)_stride; \
    packed_data->args.pointer = (GLvoid *)_pointer; \
    (packed_call_t *)packed_data; \
})
#define call_glInterleavedArrays(packed, ret_v) do { \
    PACKED_glInterleavedArrays *unpacked = (PACKED_glInterleavedArrays *)packed; \
    ARGS_glInterleavedArrays *args = (ARGS_glInterleavedArrays *)&unpacked->args; \
    glInterleavedArrays(args->format, args->stride, args->pointer);; \
} while(0)
void glInterleavedArrays(glInterleavedArrays_ARG_EXPAND);
typedef void (*glInterleavedArrays_PTR)(glInterleavedArrays_ARG_EXPAND);
#define glInterpolatePathsNV_INDEX 1122
#define glInterpolatePathsNV_RETURN void
#define glInterpolatePathsNV_ARG_NAMES resultPath, pathA, pathB, weight
#define glInterpolatePathsNV_ARG_EXPAND GLuint resultPath, GLuint pathA, GLuint pathB, GLfloat weight
#define glInterpolatePathsNV_PACKED PACKED_glInterpolatePathsNV
#define glInterpolatePathsNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glInterpolatePathsNV_NOT_VOID_WRAP(...) {}
#define pack_glInterpolatePathsNV(_resultPath, _pathA, _pathB, _weight) ({ \
    glInterpolatePathsNV_PACKED *packed_data = malloc(sizeof(glInterpolatePathsNV_PACKED)); \
    packed_data->index = glInterpolatePathsNV_INDEX; \
    packed_data->args.resultPath = (GLuint)_resultPath; \
    packed_data->args.pathA = (GLuint)_pathA; \
    packed_data->args.pathB = (GLuint)_pathB; \
    packed_data->args.weight = (GLfloat)_weight; \
    (packed_call_t *)packed_data; \
})
#define call_glInterpolatePathsNV(packed, ret_v) do { \
    PACKED_glInterpolatePathsNV *unpacked = (PACKED_glInterpolatePathsNV *)packed; \
    ARGS_glInterpolatePathsNV *args = (ARGS_glInterpolatePathsNV *)&unpacked->args; \
    glInterpolatePathsNV(args->resultPath, args->pathA, args->pathB, args->weight);; \
} while(0)
void glInterpolatePathsNV(glInterpolatePathsNV_ARG_EXPAND);
typedef void (*glInterpolatePathsNV_PTR)(glInterpolatePathsNV_ARG_EXPAND);
#define glInvalidateBufferData_INDEX 1123
#define glInvalidateBufferData_RETURN void
#define glInvalidateBufferData_ARG_NAMES buffer
#define glInvalidateBufferData_ARG_EXPAND GLuint buffer
#define glInvalidateBufferData_PACKED PACKED_glInvalidateBufferData
#define glInvalidateBufferData_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glInvalidateBufferData_NOT_VOID_WRAP(...) {}
#define pack_glInvalidateBufferData(_buffer) ({ \
    glInvalidateBufferData_PACKED *packed_data = malloc(sizeof(glInvalidateBufferData_PACKED)); \
    packed_data->index = glInvalidateBufferData_INDEX; \
    packed_data->args.buffer = (GLuint)_buffer; \
    (packed_call_t *)packed_data; \
})
#define call_glInvalidateBufferData(packed, ret_v) do { \
    PACKED_glInvalidateBufferData *unpacked = (PACKED_glInvalidateBufferData *)packed; \
    ARGS_glInvalidateBufferData *args = (ARGS_glInvalidateBufferData *)&unpacked->args; \
    glInvalidateBufferData(args->buffer);; \
} while(0)
void glInvalidateBufferData(glInvalidateBufferData_ARG_EXPAND);
typedef void (*glInvalidateBufferData_PTR)(glInvalidateBufferData_ARG_EXPAND);
#define glInvalidateBufferSubData_INDEX 1124
#define glInvalidateBufferSubData_RETURN void
#define glInvalidateBufferSubData_ARG_NAMES buffer, offset, length
#define glInvalidateBufferSubData_ARG_EXPAND GLuint buffer, GLintptr offset, GLsizeiptr length
#define glInvalidateBufferSubData_PACKED PACKED_glInvalidateBufferSubData
#define glInvalidateBufferSubData_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glInvalidateBufferSubData_NOT_VOID_WRAP(...) {}
#define pack_glInvalidateBufferSubData(_buffer, _offset, _length) ({ \
    glInvalidateBufferSubData_PACKED *packed_data = malloc(sizeof(glInvalidateBufferSubData_PACKED)); \
    packed_data->index = glInvalidateBufferSubData_INDEX; \
    packed_data->args.buffer = (GLuint)_buffer; \
    packed_data->args.offset = (GLintptr)_offset; \
    packed_data->args.length = (GLsizeiptr)_length; \
    (packed_call_t *)packed_data; \
})
#define call_glInvalidateBufferSubData(packed, ret_v) do { \
    PACKED_glInvalidateBufferSubData *unpacked = (PACKED_glInvalidateBufferSubData *)packed; \
    ARGS_glInvalidateBufferSubData *args = (ARGS_glInvalidateBufferSubData *)&unpacked->args; \
    glInvalidateBufferSubData(args->buffer, args->offset, args->length);; \
} while(0)
void glInvalidateBufferSubData(glInvalidateBufferSubData_ARG_EXPAND);
typedef void (*glInvalidateBufferSubData_PTR)(glInvalidateBufferSubData_ARG_EXPAND);
#define glInvalidateFramebuffer_INDEX 1125
#define glInvalidateFramebuffer_RETURN void
#define glInvalidateFramebuffer_ARG_NAMES target, numAttachments, attachments
#define glInvalidateFramebuffer_ARG_EXPAND GLenum target, GLsizei numAttachments, const GLenum * attachments
#define glInvalidateFramebuffer_PACKED PACKED_glInvalidateFramebuffer
#define glInvalidateFramebuffer_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glInvalidateFramebuffer_NOT_VOID_WRAP(...) {}
#define pack_glInvalidateFramebuffer(_target, _numAttachments, _attachments) ({ \
    glInvalidateFramebuffer_PACKED *packed_data = malloc(sizeof(glInvalidateFramebuffer_PACKED)); \
    packed_data->index = glInvalidateFramebuffer_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.numAttachments = (GLsizei)_numAttachments; \
    packed_data->args.attachments = (GLenum *)_attachments; \
    (packed_call_t *)packed_data; \
})
#define call_glInvalidateFramebuffer(packed, ret_v) do { \
    PACKED_glInvalidateFramebuffer *unpacked = (PACKED_glInvalidateFramebuffer *)packed; \
    ARGS_glInvalidateFramebuffer *args = (ARGS_glInvalidateFramebuffer *)&unpacked->args; \
    glInvalidateFramebuffer(args->target, args->numAttachments, args->attachments);; \
} while(0)
void glInvalidateFramebuffer(glInvalidateFramebuffer_ARG_EXPAND);
typedef void (*glInvalidateFramebuffer_PTR)(glInvalidateFramebuffer_ARG_EXPAND);
#define glInvalidateSubFramebuffer_INDEX 1126
#define glInvalidateSubFramebuffer_RETURN void
#define glInvalidateSubFramebuffer_ARG_NAMES target, numAttachments, attachments, x, y, width, height
#define glInvalidateSubFramebuffer_ARG_EXPAND GLenum target, GLsizei numAttachments, const GLenum * attachments, GLint x, GLint y, GLsizei width, GLsizei height
#define glInvalidateSubFramebuffer_PACKED PACKED_glInvalidateSubFramebuffer
#define glInvalidateSubFramebuffer_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glInvalidateSubFramebuffer_NOT_VOID_WRAP(...) {}
#define pack_glInvalidateSubFramebuffer(_target, _numAttachments, _attachments, _x, _y, _width, _height) ({ \
    glInvalidateSubFramebuffer_PACKED *packed_data = malloc(sizeof(glInvalidateSubFramebuffer_PACKED)); \
    packed_data->index = glInvalidateSubFramebuffer_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.numAttachments = (GLsizei)_numAttachments; \
    packed_data->args.attachments = (GLenum *)_attachments; \
    packed_data->args.x = (GLint)_x; \
    packed_data->args.y = (GLint)_y; \
    packed_data->args.width = (GLsizei)_width; \
    packed_data->args.height = (GLsizei)_height; \
    (packed_call_t *)packed_data; \
})
#define call_glInvalidateSubFramebuffer(packed, ret_v) do { \
    PACKED_glInvalidateSubFramebuffer *unpacked = (PACKED_glInvalidateSubFramebuffer *)packed; \
    ARGS_glInvalidateSubFramebuffer *args = (ARGS_glInvalidateSubFramebuffer *)&unpacked->args; \
    glInvalidateSubFramebuffer(args->target, args->numAttachments, args->attachments, args->x, args->y, args->width, args->height);; \
} while(0)
void glInvalidateSubFramebuffer(glInvalidateSubFramebuffer_ARG_EXPAND);
typedef void (*glInvalidateSubFramebuffer_PTR)(glInvalidateSubFramebuffer_ARG_EXPAND);
#define glInvalidateTexImage_INDEX 1127
#define glInvalidateTexImage_RETURN void
#define glInvalidateTexImage_ARG_NAMES texture, level
#define glInvalidateTexImage_ARG_EXPAND GLuint texture, GLint level
#define glInvalidateTexImage_PACKED PACKED_glInvalidateTexImage
#define glInvalidateTexImage_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glInvalidateTexImage_NOT_VOID_WRAP(...) {}
#define pack_glInvalidateTexImage(_texture, _level) ({ \
    glInvalidateTexImage_PACKED *packed_data = malloc(sizeof(glInvalidateTexImage_PACKED)); \
    packed_data->index = glInvalidateTexImage_INDEX; \
    packed_data->args.texture = (GLuint)_texture; \
    packed_data->args.level = (GLint)_level; \
    (packed_call_t *)packed_data; \
})
#define call_glInvalidateTexImage(packed, ret_v) do { \
    PACKED_glInvalidateTexImage *unpacked = (PACKED_glInvalidateTexImage *)packed; \
    ARGS_glInvalidateTexImage *args = (ARGS_glInvalidateTexImage *)&unpacked->args; \
    glInvalidateTexImage(args->texture, args->level);; \
} while(0)
void glInvalidateTexImage(glInvalidateTexImage_ARG_EXPAND);
typedef void (*glInvalidateTexImage_PTR)(glInvalidateTexImage_ARG_EXPAND);
#define glInvalidateTexSubImage_INDEX 1128
#define glInvalidateTexSubImage_RETURN void
#define glInvalidateTexSubImage_ARG_NAMES texture, level, xoffset, yoffset, zoffset, width, height, depth
#define glInvalidateTexSubImage_ARG_EXPAND GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth
#define glInvalidateTexSubImage_PACKED PACKED_glInvalidateTexSubImage
#define glInvalidateTexSubImage_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glInvalidateTexSubImage_NOT_VOID_WRAP(...) {}
#define pack_glInvalidateTexSubImage(_texture, _level, _xoffset, _yoffset, _zoffset, _width, _height, _depth) ({ \
    glInvalidateTexSubImage_PACKED *packed_data = malloc(sizeof(glInvalidateTexSubImage_PACKED)); \
    packed_data->index = glInvalidateTexSubImage_INDEX; \
    packed_data->args.texture = (GLuint)_texture; \
    packed_data->args.level = (GLint)_level; \
    packed_data->args.xoffset = (GLint)_xoffset; \
    packed_data->args.yoffset = (GLint)_yoffset; \
    packed_data->args.zoffset = (GLint)_zoffset; \
    packed_data->args.width = (GLsizei)_width; \
    packed_data->args.height = (GLsizei)_height; \
    packed_data->args.depth = (GLsizei)_depth; \
    (packed_call_t *)packed_data; \
})
#define call_glInvalidateTexSubImage(packed, ret_v) do { \
    PACKED_glInvalidateTexSubImage *unpacked = (PACKED_glInvalidateTexSubImage *)packed; \
    ARGS_glInvalidateTexSubImage *args = (ARGS_glInvalidateTexSubImage *)&unpacked->args; \
    glInvalidateTexSubImage(args->texture, args->level, args->xoffset, args->yoffset, args->zoffset, args->width, args->height, args->depth);; \
} while(0)
void glInvalidateTexSubImage(glInvalidateTexSubImage_ARG_EXPAND);
typedef void (*glInvalidateTexSubImage_PTR)(glInvalidateTexSubImage_ARG_EXPAND);
#define glIsAsyncMarkerSGIX_INDEX 1129
#define glIsAsyncMarkerSGIX_RETURN GLboolean
#define glIsAsyncMarkerSGIX_ARG_NAMES marker
#define glIsAsyncMarkerSGIX_ARG_EXPAND GLuint marker
#define glIsAsyncMarkerSGIX_PACKED PACKED_glIsAsyncMarkerSGIX
#define glIsAsyncMarkerSGIX_VOID_ONLY_WRAP(...) {}
#define glIsAsyncMarkerSGIX_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glIsAsyncMarkerSGIX(_marker) ({ \
    glIsAsyncMarkerSGIX_PACKED *packed_data = malloc(sizeof(glIsAsyncMarkerSGIX_PACKED)); \
    packed_data->index = glIsAsyncMarkerSGIX_INDEX; \
    packed_data->args.marker = (GLuint)_marker; \
    (packed_call_t *)packed_data; \
})
#define call_glIsAsyncMarkerSGIX(packed, ret_v) do { \
    PACKED_glIsAsyncMarkerSGIX *unpacked = (PACKED_glIsAsyncMarkerSGIX *)packed; \
    ARGS_glIsAsyncMarkerSGIX *args = (ARGS_glIsAsyncMarkerSGIX *)&unpacked->args; \
    GLboolean *ret = (GLboolean *)ret_v; \
    if (ret != NULL) { \
        *ret = glIsAsyncMarkerSGIX(args->marker);; \
    } else { \
        glIsAsyncMarkerSGIX(args->marker);; \
    } \
} while(0)
GLboolean glIsAsyncMarkerSGIX(glIsAsyncMarkerSGIX_ARG_EXPAND);
typedef GLboolean (*glIsAsyncMarkerSGIX_PTR)(glIsAsyncMarkerSGIX_ARG_EXPAND);
#define glIsBuffer_INDEX 1130
#define glIsBuffer_RETURN GLboolean
#define glIsBuffer_ARG_NAMES buffer
#define glIsBuffer_ARG_EXPAND GLuint buffer
#define glIsBuffer_PACKED PACKED_glIsBuffer
#define glIsBuffer_VOID_ONLY_WRAP(...) {}
#define glIsBuffer_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glIsBuffer(_buffer) ({ \
    glIsBuffer_PACKED *packed_data = malloc(sizeof(glIsBuffer_PACKED)); \
    packed_data->index = glIsBuffer_INDEX; \
    packed_data->args.buffer = (GLuint)_buffer; \
    (packed_call_t *)packed_data; \
})
#define call_glIsBuffer(packed, ret_v) do { \
    PACKED_glIsBuffer *unpacked = (PACKED_glIsBuffer *)packed; \
    ARGS_glIsBuffer *args = (ARGS_glIsBuffer *)&unpacked->args; \
    GLboolean *ret = (GLboolean *)ret_v; \
    if (ret != NULL) { \
        *ret = glIsBuffer(args->buffer);; \
    } else { \
        glIsBuffer(args->buffer);; \
    } \
} while(0)
GLboolean glIsBuffer(glIsBuffer_ARG_EXPAND);
typedef GLboolean (*glIsBuffer_PTR)(glIsBuffer_ARG_EXPAND);
#define glIsBufferARB_INDEX 1131
#define glIsBufferARB_RETURN GLboolean
#define glIsBufferARB_ARG_NAMES buffer
#define glIsBufferARB_ARG_EXPAND GLuint buffer
#define glIsBufferARB_PACKED PACKED_glIsBufferARB
#define glIsBufferARB_VOID_ONLY_WRAP(...) {}
#define glIsBufferARB_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glIsBufferARB(_buffer) ({ \
    glIsBufferARB_PACKED *packed_data = malloc(sizeof(glIsBufferARB_PACKED)); \
    packed_data->index = glIsBufferARB_INDEX; \
    packed_data->args.buffer = (GLuint)_buffer; \
    (packed_call_t *)packed_data; \
})
#define call_glIsBufferARB(packed, ret_v) do { \
    PACKED_glIsBufferARB *unpacked = (PACKED_glIsBufferARB *)packed; \
    ARGS_glIsBufferARB *args = (ARGS_glIsBufferARB *)&unpacked->args; \
    GLboolean *ret = (GLboolean *)ret_v; \
    if (ret != NULL) { \
        *ret = glIsBufferARB(args->buffer);; \
    } else { \
        glIsBufferARB(args->buffer);; \
    } \
} while(0)
GLboolean glIsBufferARB(glIsBufferARB_ARG_EXPAND);
typedef GLboolean (*glIsBufferARB_PTR)(glIsBufferARB_ARG_EXPAND);
#define glIsBufferResidentNV_INDEX 1132
#define glIsBufferResidentNV_RETURN GLboolean
#define glIsBufferResidentNV_ARG_NAMES target
#define glIsBufferResidentNV_ARG_EXPAND GLenum target
#define glIsBufferResidentNV_PACKED PACKED_glIsBufferResidentNV
#define glIsBufferResidentNV_VOID_ONLY_WRAP(...) {}
#define glIsBufferResidentNV_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glIsBufferResidentNV(_target) ({ \
    glIsBufferResidentNV_PACKED *packed_data = malloc(sizeof(glIsBufferResidentNV_PACKED)); \
    packed_data->index = glIsBufferResidentNV_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    (packed_call_t *)packed_data; \
})
#define call_glIsBufferResidentNV(packed, ret_v) do { \
    PACKED_glIsBufferResidentNV *unpacked = (PACKED_glIsBufferResidentNV *)packed; \
    ARGS_glIsBufferResidentNV *args = (ARGS_glIsBufferResidentNV *)&unpacked->args; \
    GLboolean *ret = (GLboolean *)ret_v; \
    if (ret != NULL) { \
        *ret = glIsBufferResidentNV(args->target);; \
    } else { \
        glIsBufferResidentNV(args->target);; \
    } \
} while(0)
GLboolean glIsBufferResidentNV(glIsBufferResidentNV_ARG_EXPAND);
typedef GLboolean (*glIsBufferResidentNV_PTR)(glIsBufferResidentNV_ARG_EXPAND);
#define glIsEnabled_INDEX 1133
#define glIsEnabled_RETURN GLboolean
#define glIsEnabled_ARG_NAMES cap
#define glIsEnabled_ARG_EXPAND GLenum cap
#define glIsEnabled_PACKED PACKED_glIsEnabled
#define glIsEnabled_VOID_ONLY_WRAP(...) {}
#define glIsEnabled_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glIsEnabled(_cap) ({ \
    glIsEnabled_PACKED *packed_data = malloc(sizeof(glIsEnabled_PACKED)); \
    packed_data->index = glIsEnabled_INDEX; \
    packed_data->args.cap = (GLenum)_cap; \
    (packed_call_t *)packed_data; \
})
#define call_glIsEnabled(packed, ret_v) do { \
    PACKED_glIsEnabled *unpacked = (PACKED_glIsEnabled *)packed; \
    ARGS_glIsEnabled *args = (ARGS_glIsEnabled *)&unpacked->args; \
    GLboolean *ret = (GLboolean *)ret_v; \
    if (ret != NULL) { \
        *ret = glIsEnabled(args->cap);; \
    } else { \
        glIsEnabled(args->cap);; \
    } \
} while(0)
GLboolean glIsEnabled(glIsEnabled_ARG_EXPAND);
typedef GLboolean (*glIsEnabled_PTR)(glIsEnabled_ARG_EXPAND);
#define glIsEnabledIndexedEXT_INDEX 1134
#define glIsEnabledIndexedEXT_RETURN GLboolean
#define glIsEnabledIndexedEXT_ARG_NAMES target, index
#define glIsEnabledIndexedEXT_ARG_EXPAND GLenum target, GLuint index
#define glIsEnabledIndexedEXT_PACKED PACKED_glIsEnabledIndexedEXT
#define glIsEnabledIndexedEXT_VOID_ONLY_WRAP(...) {}
#define glIsEnabledIndexedEXT_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glIsEnabledIndexedEXT(_target, _index) ({ \
    glIsEnabledIndexedEXT_PACKED *packed_data = malloc(sizeof(glIsEnabledIndexedEXT_PACKED)); \
    packed_data->index = glIsEnabledIndexedEXT_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.index = (GLuint)_index; \
    (packed_call_t *)packed_data; \
})
#define call_glIsEnabledIndexedEXT(packed, ret_v) do { \
    PACKED_glIsEnabledIndexedEXT *unpacked = (PACKED_glIsEnabledIndexedEXT *)packed; \
    ARGS_glIsEnabledIndexedEXT *args = (ARGS_glIsEnabledIndexedEXT *)&unpacked->args; \
    GLboolean *ret = (GLboolean *)ret_v; \
    if (ret != NULL) { \
        *ret = glIsEnabledIndexedEXT(args->target, args->index);; \
    } else { \
        glIsEnabledIndexedEXT(args->target, args->index);; \
    } \
} while(0)
GLboolean glIsEnabledIndexedEXT(glIsEnabledIndexedEXT_ARG_EXPAND);
typedef GLboolean (*glIsEnabledIndexedEXT_PTR)(glIsEnabledIndexedEXT_ARG_EXPAND);
#define glIsEnabledi_INDEX 1135
#define glIsEnabledi_RETURN GLboolean
#define glIsEnabledi_ARG_NAMES target, index
#define glIsEnabledi_ARG_EXPAND GLenum target, GLuint index
#define glIsEnabledi_PACKED PACKED_glIsEnabledi
#define glIsEnabledi_VOID_ONLY_WRAP(...) {}
#define glIsEnabledi_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glIsEnabledi(_target, _index) ({ \
    glIsEnabledi_PACKED *packed_data = malloc(sizeof(glIsEnabledi_PACKED)); \
    packed_data->index = glIsEnabledi_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.index = (GLuint)_index; \
    (packed_call_t *)packed_data; \
})
#define call_glIsEnabledi(packed, ret_v) do { \
    PACKED_glIsEnabledi *unpacked = (PACKED_glIsEnabledi *)packed; \
    ARGS_glIsEnabledi *args = (ARGS_glIsEnabledi *)&unpacked->args; \
    GLboolean *ret = (GLboolean *)ret_v; \
    if (ret != NULL) { \
        *ret = glIsEnabledi(args->target, args->index);; \
    } else { \
        glIsEnabledi(args->target, args->index);; \
    } \
} while(0)
GLboolean glIsEnabledi(glIsEnabledi_ARG_EXPAND);
typedef GLboolean (*glIsEnabledi_PTR)(glIsEnabledi_ARG_EXPAND);
#define glIsFenceAPPLE_INDEX 1136
#define glIsFenceAPPLE_RETURN GLboolean
#define glIsFenceAPPLE_ARG_NAMES fence
#define glIsFenceAPPLE_ARG_EXPAND GLuint fence
#define glIsFenceAPPLE_PACKED PACKED_glIsFenceAPPLE
#define glIsFenceAPPLE_VOID_ONLY_WRAP(...) {}
#define glIsFenceAPPLE_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glIsFenceAPPLE(_fence) ({ \
    glIsFenceAPPLE_PACKED *packed_data = malloc(sizeof(glIsFenceAPPLE_PACKED)); \
    packed_data->index = glIsFenceAPPLE_INDEX; \
    packed_data->args.fence = (GLuint)_fence; \
    (packed_call_t *)packed_data; \
})
#define call_glIsFenceAPPLE(packed, ret_v) do { \
    PACKED_glIsFenceAPPLE *unpacked = (PACKED_glIsFenceAPPLE *)packed; \
    ARGS_glIsFenceAPPLE *args = (ARGS_glIsFenceAPPLE *)&unpacked->args; \
    GLboolean *ret = (GLboolean *)ret_v; \
    if (ret != NULL) { \
        *ret = glIsFenceAPPLE(args->fence);; \
    } else { \
        glIsFenceAPPLE(args->fence);; \
    } \
} while(0)
GLboolean glIsFenceAPPLE(glIsFenceAPPLE_ARG_EXPAND);
typedef GLboolean (*glIsFenceAPPLE_PTR)(glIsFenceAPPLE_ARG_EXPAND);
#define glIsFenceNV_INDEX 1137
#define glIsFenceNV_RETURN GLboolean
#define glIsFenceNV_ARG_NAMES fence
#define glIsFenceNV_ARG_EXPAND GLuint fence
#define glIsFenceNV_PACKED PACKED_glIsFenceNV
#define glIsFenceNV_VOID_ONLY_WRAP(...) {}
#define glIsFenceNV_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glIsFenceNV(_fence) ({ \
    glIsFenceNV_PACKED *packed_data = malloc(sizeof(glIsFenceNV_PACKED)); \
    packed_data->index = glIsFenceNV_INDEX; \
    packed_data->args.fence = (GLuint)_fence; \
    (packed_call_t *)packed_data; \
})
#define call_glIsFenceNV(packed, ret_v) do { \
    PACKED_glIsFenceNV *unpacked = (PACKED_glIsFenceNV *)packed; \
    ARGS_glIsFenceNV *args = (ARGS_glIsFenceNV *)&unpacked->args; \
    GLboolean *ret = (GLboolean *)ret_v; \
    if (ret != NULL) { \
        *ret = glIsFenceNV(args->fence);; \
    } else { \
        glIsFenceNV(args->fence);; \
    } \
} while(0)
GLboolean glIsFenceNV(glIsFenceNV_ARG_EXPAND);
typedef GLboolean (*glIsFenceNV_PTR)(glIsFenceNV_ARG_EXPAND);
#define glIsFramebuffer_INDEX 1138
#define glIsFramebuffer_RETURN GLboolean
#define glIsFramebuffer_ARG_NAMES framebuffer
#define glIsFramebuffer_ARG_EXPAND GLuint framebuffer
#define glIsFramebuffer_PACKED PACKED_glIsFramebuffer
#define glIsFramebuffer_VOID_ONLY_WRAP(...) {}
#define glIsFramebuffer_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glIsFramebuffer(_framebuffer) ({ \
    glIsFramebuffer_PACKED *packed_data = malloc(sizeof(glIsFramebuffer_PACKED)); \
    packed_data->index = glIsFramebuffer_INDEX; \
    packed_data->args.framebuffer = (GLuint)_framebuffer; \
    (packed_call_t *)packed_data; \
})
#define call_glIsFramebuffer(packed, ret_v) do { \
    PACKED_glIsFramebuffer *unpacked = (PACKED_glIsFramebuffer *)packed; \
    ARGS_glIsFramebuffer *args = (ARGS_glIsFramebuffer *)&unpacked->args; \
    GLboolean *ret = (GLboolean *)ret_v; \
    if (ret != NULL) { \
        *ret = glIsFramebuffer(args->framebuffer);; \
    } else { \
        glIsFramebuffer(args->framebuffer);; \
    } \
} while(0)
GLboolean glIsFramebuffer(glIsFramebuffer_ARG_EXPAND);
typedef GLboolean (*glIsFramebuffer_PTR)(glIsFramebuffer_ARG_EXPAND);
#define glIsFramebufferEXT_INDEX 1139
#define glIsFramebufferEXT_RETURN GLboolean
#define glIsFramebufferEXT_ARG_NAMES framebuffer
#define glIsFramebufferEXT_ARG_EXPAND GLuint framebuffer
#define glIsFramebufferEXT_PACKED PACKED_glIsFramebufferEXT
#define glIsFramebufferEXT_VOID_ONLY_WRAP(...) {}
#define glIsFramebufferEXT_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glIsFramebufferEXT(_framebuffer) ({ \
    glIsFramebufferEXT_PACKED *packed_data = malloc(sizeof(glIsFramebufferEXT_PACKED)); \
    packed_data->index = glIsFramebufferEXT_INDEX; \
    packed_data->args.framebuffer = (GLuint)_framebuffer; \
    (packed_call_t *)packed_data; \
})
#define call_glIsFramebufferEXT(packed, ret_v) do { \
    PACKED_glIsFramebufferEXT *unpacked = (PACKED_glIsFramebufferEXT *)packed; \
    ARGS_glIsFramebufferEXT *args = (ARGS_glIsFramebufferEXT *)&unpacked->args; \
    GLboolean *ret = (GLboolean *)ret_v; \
    if (ret != NULL) { \
        *ret = glIsFramebufferEXT(args->framebuffer);; \
    } else { \
        glIsFramebufferEXT(args->framebuffer);; \
    } \
} while(0)
GLboolean glIsFramebufferEXT(glIsFramebufferEXT_ARG_EXPAND);
typedef GLboolean (*glIsFramebufferEXT_PTR)(glIsFramebufferEXT_ARG_EXPAND);
#define glIsImageHandleResidentNV_INDEX 1140
#define glIsImageHandleResidentNV_RETURN GLboolean
#define glIsImageHandleResidentNV_ARG_NAMES handle
#define glIsImageHandleResidentNV_ARG_EXPAND GLuint64 handle
#define glIsImageHandleResidentNV_PACKED PACKED_glIsImageHandleResidentNV
#define glIsImageHandleResidentNV_VOID_ONLY_WRAP(...) {}
#define glIsImageHandleResidentNV_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glIsImageHandleResidentNV(_handle) ({ \
    glIsImageHandleResidentNV_PACKED *packed_data = malloc(sizeof(glIsImageHandleResidentNV_PACKED)); \
    packed_data->index = glIsImageHandleResidentNV_INDEX; \
    packed_data->args.handle = (GLuint64)_handle; \
    (packed_call_t *)packed_data; \
})
#define call_glIsImageHandleResidentNV(packed, ret_v) do { \
    PACKED_glIsImageHandleResidentNV *unpacked = (PACKED_glIsImageHandleResidentNV *)packed; \
    ARGS_glIsImageHandleResidentNV *args = (ARGS_glIsImageHandleResidentNV *)&unpacked->args; \
    GLboolean *ret = (GLboolean *)ret_v; \
    if (ret != NULL) { \
        *ret = glIsImageHandleResidentNV(args->handle);; \
    } else { \
        glIsImageHandleResidentNV(args->handle);; \
    } \
} while(0)
GLboolean glIsImageHandleResidentNV(glIsImageHandleResidentNV_ARG_EXPAND);
typedef GLboolean (*glIsImageHandleResidentNV_PTR)(glIsImageHandleResidentNV_ARG_EXPAND);
#define glIsList_INDEX 1141
#define glIsList_RETURN GLboolean
#define glIsList_ARG_NAMES list
#define glIsList_ARG_EXPAND GLuint list
#define glIsList_PACKED PACKED_glIsList
#define glIsList_VOID_ONLY_WRAP(...) {}
#define glIsList_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glIsList(_list) ({ \
    glIsList_PACKED *packed_data = malloc(sizeof(glIsList_PACKED)); \
    packed_data->index = glIsList_INDEX; \
    packed_data->args.list = (GLuint)_list; \
    (packed_call_t *)packed_data; \
})
#define call_glIsList(packed, ret_v) do { \
    PACKED_glIsList *unpacked = (PACKED_glIsList *)packed; \
    ARGS_glIsList *args = (ARGS_glIsList *)&unpacked->args; \
    GLboolean *ret = (GLboolean *)ret_v; \
    if (ret != NULL) { \
        *ret = glIsList(args->list);; \
    } else { \
        glIsList(args->list);; \
    } \
} while(0)
GLboolean glIsList(glIsList_ARG_EXPAND);
typedef GLboolean (*glIsList_PTR)(glIsList_ARG_EXPAND);
#define glIsNameAMD_INDEX 1142
#define glIsNameAMD_RETURN GLboolean
#define glIsNameAMD_ARG_NAMES identifier, name
#define glIsNameAMD_ARG_EXPAND GLenum identifier, GLuint name
#define glIsNameAMD_PACKED PACKED_glIsNameAMD
#define glIsNameAMD_VOID_ONLY_WRAP(...) {}
#define glIsNameAMD_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glIsNameAMD(_identifier, _name) ({ \
    glIsNameAMD_PACKED *packed_data = malloc(sizeof(glIsNameAMD_PACKED)); \
    packed_data->index = glIsNameAMD_INDEX; \
    packed_data->args.identifier = (GLenum)_identifier; \
    packed_data->args.name = (GLuint)_name; \
    (packed_call_t *)packed_data; \
})
#define call_glIsNameAMD(packed, ret_v) do { \
    PACKED_glIsNameAMD *unpacked = (PACKED_glIsNameAMD *)packed; \
    ARGS_glIsNameAMD *args = (ARGS_glIsNameAMD *)&unpacked->args; \
    GLboolean *ret = (GLboolean *)ret_v; \
    if (ret != NULL) { \
        *ret = glIsNameAMD(args->identifier, args->name);; \
    } else { \
        glIsNameAMD(args->identifier, args->name);; \
    } \
} while(0)
GLboolean glIsNameAMD(glIsNameAMD_ARG_EXPAND);
typedef GLboolean (*glIsNameAMD_PTR)(glIsNameAMD_ARG_EXPAND);
#define glIsNamedBufferResidentNV_INDEX 1143
#define glIsNamedBufferResidentNV_RETURN GLboolean
#define glIsNamedBufferResidentNV_ARG_NAMES buffer
#define glIsNamedBufferResidentNV_ARG_EXPAND GLuint buffer
#define glIsNamedBufferResidentNV_PACKED PACKED_glIsNamedBufferResidentNV
#define glIsNamedBufferResidentNV_VOID_ONLY_WRAP(...) {}
#define glIsNamedBufferResidentNV_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glIsNamedBufferResidentNV(_buffer) ({ \
    glIsNamedBufferResidentNV_PACKED *packed_data = malloc(sizeof(glIsNamedBufferResidentNV_PACKED)); \
    packed_data->index = glIsNamedBufferResidentNV_INDEX; \
    packed_data->args.buffer = (GLuint)_buffer; \
    (packed_call_t *)packed_data; \
})
#define call_glIsNamedBufferResidentNV(packed, ret_v) do { \
    PACKED_glIsNamedBufferResidentNV *unpacked = (PACKED_glIsNamedBufferResidentNV *)packed; \
    ARGS_glIsNamedBufferResidentNV *args = (ARGS_glIsNamedBufferResidentNV *)&unpacked->args; \
    GLboolean *ret = (GLboolean *)ret_v; \
    if (ret != NULL) { \
        *ret = glIsNamedBufferResidentNV(args->buffer);; \
    } else { \
        glIsNamedBufferResidentNV(args->buffer);; \
    } \
} while(0)
GLboolean glIsNamedBufferResidentNV(glIsNamedBufferResidentNV_ARG_EXPAND);
typedef GLboolean (*glIsNamedBufferResidentNV_PTR)(glIsNamedBufferResidentNV_ARG_EXPAND);
#define glIsNamedStringARB_INDEX 1144
#define glIsNamedStringARB_RETURN GLboolean
#define glIsNamedStringARB_ARG_NAMES namelen, name
#define glIsNamedStringARB_ARG_EXPAND GLint namelen, const GLchar * name
#define glIsNamedStringARB_PACKED PACKED_glIsNamedStringARB
#define glIsNamedStringARB_VOID_ONLY_WRAP(...) {}
#define glIsNamedStringARB_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glIsNamedStringARB(_namelen, _name) ({ \
    glIsNamedStringARB_PACKED *packed_data = malloc(sizeof(glIsNamedStringARB_PACKED)); \
    packed_data->index = glIsNamedStringARB_INDEX; \
    packed_data->args.namelen = (GLint)_namelen; \
    packed_data->args.name = (GLchar *)_name; \
    (packed_call_t *)packed_data; \
})
#define call_glIsNamedStringARB(packed, ret_v) do { \
    PACKED_glIsNamedStringARB *unpacked = (PACKED_glIsNamedStringARB *)packed; \
    ARGS_glIsNamedStringARB *args = (ARGS_glIsNamedStringARB *)&unpacked->args; \
    GLboolean *ret = (GLboolean *)ret_v; \
    if (ret != NULL) { \
        *ret = glIsNamedStringARB(args->namelen, args->name);; \
    } else { \
        glIsNamedStringARB(args->namelen, args->name);; \
    } \
} while(0)
GLboolean glIsNamedStringARB(glIsNamedStringARB_ARG_EXPAND);
typedef GLboolean (*glIsNamedStringARB_PTR)(glIsNamedStringARB_ARG_EXPAND);
#define glIsObjectBufferATI_INDEX 1145
#define glIsObjectBufferATI_RETURN GLboolean
#define glIsObjectBufferATI_ARG_NAMES buffer
#define glIsObjectBufferATI_ARG_EXPAND GLuint buffer
#define glIsObjectBufferATI_PACKED PACKED_glIsObjectBufferATI
#define glIsObjectBufferATI_VOID_ONLY_WRAP(...) {}
#define glIsObjectBufferATI_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glIsObjectBufferATI(_buffer) ({ \
    glIsObjectBufferATI_PACKED *packed_data = malloc(sizeof(glIsObjectBufferATI_PACKED)); \
    packed_data->index = glIsObjectBufferATI_INDEX; \
    packed_data->args.buffer = (GLuint)_buffer; \
    (packed_call_t *)packed_data; \
})
#define call_glIsObjectBufferATI(packed, ret_v) do { \
    PACKED_glIsObjectBufferATI *unpacked = (PACKED_glIsObjectBufferATI *)packed; \
    ARGS_glIsObjectBufferATI *args = (ARGS_glIsObjectBufferATI *)&unpacked->args; \
    GLboolean *ret = (GLboolean *)ret_v; \
    if (ret != NULL) { \
        *ret = glIsObjectBufferATI(args->buffer);; \
    } else { \
        glIsObjectBufferATI(args->buffer);; \
    } \
} while(0)
GLboolean glIsObjectBufferATI(glIsObjectBufferATI_ARG_EXPAND);
typedef GLboolean (*glIsObjectBufferATI_PTR)(glIsObjectBufferATI_ARG_EXPAND);
#define glIsOcclusionQueryNV_INDEX 1146
#define glIsOcclusionQueryNV_RETURN GLboolean
#define glIsOcclusionQueryNV_ARG_NAMES id
#define glIsOcclusionQueryNV_ARG_EXPAND GLuint id
#define glIsOcclusionQueryNV_PACKED PACKED_glIsOcclusionQueryNV
#define glIsOcclusionQueryNV_VOID_ONLY_WRAP(...) {}
#define glIsOcclusionQueryNV_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glIsOcclusionQueryNV(_id) ({ \
    glIsOcclusionQueryNV_PACKED *packed_data = malloc(sizeof(glIsOcclusionQueryNV_PACKED)); \
    packed_data->index = glIsOcclusionQueryNV_INDEX; \
    packed_data->args.id = (GLuint)_id; \
    (packed_call_t *)packed_data; \
})
#define call_glIsOcclusionQueryNV(packed, ret_v) do { \
    PACKED_glIsOcclusionQueryNV *unpacked = (PACKED_glIsOcclusionQueryNV *)packed; \
    ARGS_glIsOcclusionQueryNV *args = (ARGS_glIsOcclusionQueryNV *)&unpacked->args; \
    GLboolean *ret = (GLboolean *)ret_v; \
    if (ret != NULL) { \
        *ret = glIsOcclusionQueryNV(args->id);; \
    } else { \
        glIsOcclusionQueryNV(args->id);; \
    } \
} while(0)
GLboolean glIsOcclusionQueryNV(glIsOcclusionQueryNV_ARG_EXPAND);
typedef GLboolean (*glIsOcclusionQueryNV_PTR)(glIsOcclusionQueryNV_ARG_EXPAND);
#define glIsPathNV_INDEX 1147
#define glIsPathNV_RETURN GLboolean
#define glIsPathNV_ARG_NAMES path
#define glIsPathNV_ARG_EXPAND GLuint path
#define glIsPathNV_PACKED PACKED_glIsPathNV
#define glIsPathNV_VOID_ONLY_WRAP(...) {}
#define glIsPathNV_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glIsPathNV(_path) ({ \
    glIsPathNV_PACKED *packed_data = malloc(sizeof(glIsPathNV_PACKED)); \
    packed_data->index = glIsPathNV_INDEX; \
    packed_data->args.path = (GLuint)_path; \
    (packed_call_t *)packed_data; \
})
#define call_glIsPathNV(packed, ret_v) do { \
    PACKED_glIsPathNV *unpacked = (PACKED_glIsPathNV *)packed; \
    ARGS_glIsPathNV *args = (ARGS_glIsPathNV *)&unpacked->args; \
    GLboolean *ret = (GLboolean *)ret_v; \
    if (ret != NULL) { \
        *ret = glIsPathNV(args->path);; \
    } else { \
        glIsPathNV(args->path);; \
    } \
} while(0)
GLboolean glIsPathNV(glIsPathNV_ARG_EXPAND);
typedef GLboolean (*glIsPathNV_PTR)(glIsPathNV_ARG_EXPAND);
#define glIsPointInFillPathNV_INDEX 1148
#define glIsPointInFillPathNV_RETURN GLboolean
#define glIsPointInFillPathNV_ARG_NAMES path, mask, x, y
#define glIsPointInFillPathNV_ARG_EXPAND GLuint path, GLuint mask, GLfloat x, GLfloat y
#define glIsPointInFillPathNV_PACKED PACKED_glIsPointInFillPathNV
#define glIsPointInFillPathNV_VOID_ONLY_WRAP(...) {}
#define glIsPointInFillPathNV_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glIsPointInFillPathNV(_path, _mask, _x, _y) ({ \
    glIsPointInFillPathNV_PACKED *packed_data = malloc(sizeof(glIsPointInFillPathNV_PACKED)); \
    packed_data->index = glIsPointInFillPathNV_INDEX; \
    packed_data->args.path = (GLuint)_path; \
    packed_data->args.mask = (GLuint)_mask; \
    packed_data->args.x = (GLfloat)_x; \
    packed_data->args.y = (GLfloat)_y; \
    (packed_call_t *)packed_data; \
})
#define call_glIsPointInFillPathNV(packed, ret_v) do { \
    PACKED_glIsPointInFillPathNV *unpacked = (PACKED_glIsPointInFillPathNV *)packed; \
    ARGS_glIsPointInFillPathNV *args = (ARGS_glIsPointInFillPathNV *)&unpacked->args; \
    GLboolean *ret = (GLboolean *)ret_v; \
    if (ret != NULL) { \
        *ret = glIsPointInFillPathNV(args->path, args->mask, args->x, args->y);; \
    } else { \
        glIsPointInFillPathNV(args->path, args->mask, args->x, args->y);; \
    } \
} while(0)
GLboolean glIsPointInFillPathNV(glIsPointInFillPathNV_ARG_EXPAND);
typedef GLboolean (*glIsPointInFillPathNV_PTR)(glIsPointInFillPathNV_ARG_EXPAND);
#define glIsPointInStrokePathNV_INDEX 1149
#define glIsPointInStrokePathNV_RETURN GLboolean
#define glIsPointInStrokePathNV_ARG_NAMES path, x, y
#define glIsPointInStrokePathNV_ARG_EXPAND GLuint path, GLfloat x, GLfloat y
#define glIsPointInStrokePathNV_PACKED PACKED_glIsPointInStrokePathNV
#define glIsPointInStrokePathNV_VOID_ONLY_WRAP(...) {}
#define glIsPointInStrokePathNV_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glIsPointInStrokePathNV(_path, _x, _y) ({ \
    glIsPointInStrokePathNV_PACKED *packed_data = malloc(sizeof(glIsPointInStrokePathNV_PACKED)); \
    packed_data->index = glIsPointInStrokePathNV_INDEX; \
    packed_data->args.path = (GLuint)_path; \
    packed_data->args.x = (GLfloat)_x; \
    packed_data->args.y = (GLfloat)_y; \
    (packed_call_t *)packed_data; \
})
#define call_glIsPointInStrokePathNV(packed, ret_v) do { \
    PACKED_glIsPointInStrokePathNV *unpacked = (PACKED_glIsPointInStrokePathNV *)packed; \
    ARGS_glIsPointInStrokePathNV *args = (ARGS_glIsPointInStrokePathNV *)&unpacked->args; \
    GLboolean *ret = (GLboolean *)ret_v; \
    if (ret != NULL) { \
        *ret = glIsPointInStrokePathNV(args->path, args->x, args->y);; \
    } else { \
        glIsPointInStrokePathNV(args->path, args->x, args->y);; \
    } \
} while(0)
GLboolean glIsPointInStrokePathNV(glIsPointInStrokePathNV_ARG_EXPAND);
typedef GLboolean (*glIsPointInStrokePathNV_PTR)(glIsPointInStrokePathNV_ARG_EXPAND);
#define glIsProgram_INDEX 1150
#define glIsProgram_RETURN GLboolean
#define glIsProgram_ARG_NAMES program
#define glIsProgram_ARG_EXPAND GLuint program
#define glIsProgram_PACKED PACKED_glIsProgram
#define glIsProgram_VOID_ONLY_WRAP(...) {}
#define glIsProgram_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glIsProgram(_program) ({ \
    glIsProgram_PACKED *packed_data = malloc(sizeof(glIsProgram_PACKED)); \
    packed_data->index = glIsProgram_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    (packed_call_t *)packed_data; \
})
#define call_glIsProgram(packed, ret_v) do { \
    PACKED_glIsProgram *unpacked = (PACKED_glIsProgram *)packed; \
    ARGS_glIsProgram *args = (ARGS_glIsProgram *)&unpacked->args; \
    GLboolean *ret = (GLboolean *)ret_v; \
    if (ret != NULL) { \
        *ret = glIsProgram(args->program);; \
    } else { \
        glIsProgram(args->program);; \
    } \
} while(0)
GLboolean glIsProgram(glIsProgram_ARG_EXPAND);
typedef GLboolean (*glIsProgram_PTR)(glIsProgram_ARG_EXPAND);
#define glIsProgramARB_INDEX 1151
#define glIsProgramARB_RETURN GLboolean
#define glIsProgramARB_ARG_NAMES program
#define glIsProgramARB_ARG_EXPAND GLuint program
#define glIsProgramARB_PACKED PACKED_glIsProgramARB
#define glIsProgramARB_VOID_ONLY_WRAP(...) {}
#define glIsProgramARB_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glIsProgramARB(_program) ({ \
    glIsProgramARB_PACKED *packed_data = malloc(sizeof(glIsProgramARB_PACKED)); \
    packed_data->index = glIsProgramARB_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    (packed_call_t *)packed_data; \
})
#define call_glIsProgramARB(packed, ret_v) do { \
    PACKED_glIsProgramARB *unpacked = (PACKED_glIsProgramARB *)packed; \
    ARGS_glIsProgramARB *args = (ARGS_glIsProgramARB *)&unpacked->args; \
    GLboolean *ret = (GLboolean *)ret_v; \
    if (ret != NULL) { \
        *ret = glIsProgramARB(args->program);; \
    } else { \
        glIsProgramARB(args->program);; \
    } \
} while(0)
GLboolean glIsProgramARB(glIsProgramARB_ARG_EXPAND);
typedef GLboolean (*glIsProgramARB_PTR)(glIsProgramARB_ARG_EXPAND);
#define glIsProgramNV_INDEX 1152
#define glIsProgramNV_RETURN GLboolean
#define glIsProgramNV_ARG_NAMES id
#define glIsProgramNV_ARG_EXPAND GLuint id
#define glIsProgramNV_PACKED PACKED_glIsProgramNV
#define glIsProgramNV_VOID_ONLY_WRAP(...) {}
#define glIsProgramNV_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glIsProgramNV(_id) ({ \
    glIsProgramNV_PACKED *packed_data = malloc(sizeof(glIsProgramNV_PACKED)); \
    packed_data->index = glIsProgramNV_INDEX; \
    packed_data->args.id = (GLuint)_id; \
    (packed_call_t *)packed_data; \
})
#define call_glIsProgramNV(packed, ret_v) do { \
    PACKED_glIsProgramNV *unpacked = (PACKED_glIsProgramNV *)packed; \
    ARGS_glIsProgramNV *args = (ARGS_glIsProgramNV *)&unpacked->args; \
    GLboolean *ret = (GLboolean *)ret_v; \
    if (ret != NULL) { \
        *ret = glIsProgramNV(args->id);; \
    } else { \
        glIsProgramNV(args->id);; \
    } \
} while(0)
GLboolean glIsProgramNV(glIsProgramNV_ARG_EXPAND);
typedef GLboolean (*glIsProgramNV_PTR)(glIsProgramNV_ARG_EXPAND);
#define glIsProgramPipeline_INDEX 1153
#define glIsProgramPipeline_RETURN GLboolean
#define glIsProgramPipeline_ARG_NAMES pipeline
#define glIsProgramPipeline_ARG_EXPAND GLuint pipeline
#define glIsProgramPipeline_PACKED PACKED_glIsProgramPipeline
#define glIsProgramPipeline_VOID_ONLY_WRAP(...) {}
#define glIsProgramPipeline_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glIsProgramPipeline(_pipeline) ({ \
    glIsProgramPipeline_PACKED *packed_data = malloc(sizeof(glIsProgramPipeline_PACKED)); \
    packed_data->index = glIsProgramPipeline_INDEX; \
    packed_data->args.pipeline = (GLuint)_pipeline; \
    (packed_call_t *)packed_data; \
})
#define call_glIsProgramPipeline(packed, ret_v) do { \
    PACKED_glIsProgramPipeline *unpacked = (PACKED_glIsProgramPipeline *)packed; \
    ARGS_glIsProgramPipeline *args = (ARGS_glIsProgramPipeline *)&unpacked->args; \
    GLboolean *ret = (GLboolean *)ret_v; \
    if (ret != NULL) { \
        *ret = glIsProgramPipeline(args->pipeline);; \
    } else { \
        glIsProgramPipeline(args->pipeline);; \
    } \
} while(0)
GLboolean glIsProgramPipeline(glIsProgramPipeline_ARG_EXPAND);
typedef GLboolean (*glIsProgramPipeline_PTR)(glIsProgramPipeline_ARG_EXPAND);
#define glIsQuery_INDEX 1154
#define glIsQuery_RETURN GLboolean
#define glIsQuery_ARG_NAMES id
#define glIsQuery_ARG_EXPAND GLuint id
#define glIsQuery_PACKED PACKED_glIsQuery
#define glIsQuery_VOID_ONLY_WRAP(...) {}
#define glIsQuery_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glIsQuery(_id) ({ \
    glIsQuery_PACKED *packed_data = malloc(sizeof(glIsQuery_PACKED)); \
    packed_data->index = glIsQuery_INDEX; \
    packed_data->args.id = (GLuint)_id; \
    (packed_call_t *)packed_data; \
})
#define call_glIsQuery(packed, ret_v) do { \
    PACKED_glIsQuery *unpacked = (PACKED_glIsQuery *)packed; \
    ARGS_glIsQuery *args = (ARGS_glIsQuery *)&unpacked->args; \
    GLboolean *ret = (GLboolean *)ret_v; \
    if (ret != NULL) { \
        *ret = glIsQuery(args->id);; \
    } else { \
        glIsQuery(args->id);; \
    } \
} while(0)
GLboolean glIsQuery(glIsQuery_ARG_EXPAND);
typedef GLboolean (*glIsQuery_PTR)(glIsQuery_ARG_EXPAND);
#define glIsQueryARB_INDEX 1155
#define glIsQueryARB_RETURN GLboolean
#define glIsQueryARB_ARG_NAMES id
#define glIsQueryARB_ARG_EXPAND GLuint id
#define glIsQueryARB_PACKED PACKED_glIsQueryARB
#define glIsQueryARB_VOID_ONLY_WRAP(...) {}
#define glIsQueryARB_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glIsQueryARB(_id) ({ \
    glIsQueryARB_PACKED *packed_data = malloc(sizeof(glIsQueryARB_PACKED)); \
    packed_data->index = glIsQueryARB_INDEX; \
    packed_data->args.id = (GLuint)_id; \
    (packed_call_t *)packed_data; \
})
#define call_glIsQueryARB(packed, ret_v) do { \
    PACKED_glIsQueryARB *unpacked = (PACKED_glIsQueryARB *)packed; \
    ARGS_glIsQueryARB *args = (ARGS_glIsQueryARB *)&unpacked->args; \
    GLboolean *ret = (GLboolean *)ret_v; \
    if (ret != NULL) { \
        *ret = glIsQueryARB(args->id);; \
    } else { \
        glIsQueryARB(args->id);; \
    } \
} while(0)
GLboolean glIsQueryARB(glIsQueryARB_ARG_EXPAND);
typedef GLboolean (*glIsQueryARB_PTR)(glIsQueryARB_ARG_EXPAND);
#define glIsRenderbuffer_INDEX 1156
#define glIsRenderbuffer_RETURN GLboolean
#define glIsRenderbuffer_ARG_NAMES renderbuffer
#define glIsRenderbuffer_ARG_EXPAND GLuint renderbuffer
#define glIsRenderbuffer_PACKED PACKED_glIsRenderbuffer
#define glIsRenderbuffer_VOID_ONLY_WRAP(...) {}
#define glIsRenderbuffer_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glIsRenderbuffer(_renderbuffer) ({ \
    glIsRenderbuffer_PACKED *packed_data = malloc(sizeof(glIsRenderbuffer_PACKED)); \
    packed_data->index = glIsRenderbuffer_INDEX; \
    packed_data->args.renderbuffer = (GLuint)_renderbuffer; \
    (packed_call_t *)packed_data; \
})
#define call_glIsRenderbuffer(packed, ret_v) do { \
    PACKED_glIsRenderbuffer *unpacked = (PACKED_glIsRenderbuffer *)packed; \
    ARGS_glIsRenderbuffer *args = (ARGS_glIsRenderbuffer *)&unpacked->args; \
    GLboolean *ret = (GLboolean *)ret_v; \
    if (ret != NULL) { \
        *ret = glIsRenderbuffer(args->renderbuffer);; \
    } else { \
        glIsRenderbuffer(args->renderbuffer);; \
    } \
} while(0)
GLboolean glIsRenderbuffer(glIsRenderbuffer_ARG_EXPAND);
typedef GLboolean (*glIsRenderbuffer_PTR)(glIsRenderbuffer_ARG_EXPAND);
#define glIsRenderbufferEXT_INDEX 1157
#define glIsRenderbufferEXT_RETURN GLboolean
#define glIsRenderbufferEXT_ARG_NAMES renderbuffer
#define glIsRenderbufferEXT_ARG_EXPAND GLuint renderbuffer
#define glIsRenderbufferEXT_PACKED PACKED_glIsRenderbufferEXT
#define glIsRenderbufferEXT_VOID_ONLY_WRAP(...) {}
#define glIsRenderbufferEXT_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glIsRenderbufferEXT(_renderbuffer) ({ \
    glIsRenderbufferEXT_PACKED *packed_data = malloc(sizeof(glIsRenderbufferEXT_PACKED)); \
    packed_data->index = glIsRenderbufferEXT_INDEX; \
    packed_data->args.renderbuffer = (GLuint)_renderbuffer; \
    (packed_call_t *)packed_data; \
})
#define call_glIsRenderbufferEXT(packed, ret_v) do { \
    PACKED_glIsRenderbufferEXT *unpacked = (PACKED_glIsRenderbufferEXT *)packed; \
    ARGS_glIsRenderbufferEXT *args = (ARGS_glIsRenderbufferEXT *)&unpacked->args; \
    GLboolean *ret = (GLboolean *)ret_v; \
    if (ret != NULL) { \
        *ret = glIsRenderbufferEXT(args->renderbuffer);; \
    } else { \
        glIsRenderbufferEXT(args->renderbuffer);; \
    } \
} while(0)
GLboolean glIsRenderbufferEXT(glIsRenderbufferEXT_ARG_EXPAND);
typedef GLboolean (*glIsRenderbufferEXT_PTR)(glIsRenderbufferEXT_ARG_EXPAND);
#define glIsSampler_INDEX 1158
#define glIsSampler_RETURN GLboolean
#define glIsSampler_ARG_NAMES sampler
#define glIsSampler_ARG_EXPAND GLuint sampler
#define glIsSampler_PACKED PACKED_glIsSampler
#define glIsSampler_VOID_ONLY_WRAP(...) {}
#define glIsSampler_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glIsSampler(_sampler) ({ \
    glIsSampler_PACKED *packed_data = malloc(sizeof(glIsSampler_PACKED)); \
    packed_data->index = glIsSampler_INDEX; \
    packed_data->args.sampler = (GLuint)_sampler; \
    (packed_call_t *)packed_data; \
})
#define call_glIsSampler(packed, ret_v) do { \
    PACKED_glIsSampler *unpacked = (PACKED_glIsSampler *)packed; \
    ARGS_glIsSampler *args = (ARGS_glIsSampler *)&unpacked->args; \
    GLboolean *ret = (GLboolean *)ret_v; \
    if (ret != NULL) { \
        *ret = glIsSampler(args->sampler);; \
    } else { \
        glIsSampler(args->sampler);; \
    } \
} while(0)
GLboolean glIsSampler(glIsSampler_ARG_EXPAND);
typedef GLboolean (*glIsSampler_PTR)(glIsSampler_ARG_EXPAND);
#define glIsShader_INDEX 1159
#define glIsShader_RETURN GLboolean
#define glIsShader_ARG_NAMES shader
#define glIsShader_ARG_EXPAND GLuint shader
#define glIsShader_PACKED PACKED_glIsShader
#define glIsShader_VOID_ONLY_WRAP(...) {}
#define glIsShader_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glIsShader(_shader) ({ \
    glIsShader_PACKED *packed_data = malloc(sizeof(glIsShader_PACKED)); \
    packed_data->index = glIsShader_INDEX; \
    packed_data->args.shader = (GLuint)_shader; \
    (packed_call_t *)packed_data; \
})
#define call_glIsShader(packed, ret_v) do { \
    PACKED_glIsShader *unpacked = (PACKED_glIsShader *)packed; \
    ARGS_glIsShader *args = (ARGS_glIsShader *)&unpacked->args; \
    GLboolean *ret = (GLboolean *)ret_v; \
    if (ret != NULL) { \
        *ret = glIsShader(args->shader);; \
    } else { \
        glIsShader(args->shader);; \
    } \
} while(0)
GLboolean glIsShader(glIsShader_ARG_EXPAND);
typedef GLboolean (*glIsShader_PTR)(glIsShader_ARG_EXPAND);
#define glIsSync_INDEX 1160
#define glIsSync_RETURN GLboolean
#define glIsSync_ARG_NAMES sync
#define glIsSync_ARG_EXPAND GLsync sync
#define glIsSync_PACKED PACKED_glIsSync
#define glIsSync_VOID_ONLY_WRAP(...) {}
#define glIsSync_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glIsSync(_sync) ({ \
    glIsSync_PACKED *packed_data = malloc(sizeof(glIsSync_PACKED)); \
    packed_data->index = glIsSync_INDEX; \
    packed_data->args.sync = (GLsync)_sync; \
    (packed_call_t *)packed_data; \
})
#define call_glIsSync(packed, ret_v) do { \
    PACKED_glIsSync *unpacked = (PACKED_glIsSync *)packed; \
    ARGS_glIsSync *args = (ARGS_glIsSync *)&unpacked->args; \
    GLboolean *ret = (GLboolean *)ret_v; \
    if (ret != NULL) { \
        *ret = glIsSync(args->sync);; \
    } else { \
        glIsSync(args->sync);; \
    } \
} while(0)
GLboolean glIsSync(glIsSync_ARG_EXPAND);
typedef GLboolean (*glIsSync_PTR)(glIsSync_ARG_EXPAND);
#define glIsTexture_INDEX 1161
#define glIsTexture_RETURN GLboolean
#define glIsTexture_ARG_NAMES texture
#define glIsTexture_ARG_EXPAND GLuint texture
#define glIsTexture_PACKED PACKED_glIsTexture
#define glIsTexture_VOID_ONLY_WRAP(...) {}
#define glIsTexture_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glIsTexture(_texture) ({ \
    glIsTexture_PACKED *packed_data = malloc(sizeof(glIsTexture_PACKED)); \
    packed_data->index = glIsTexture_INDEX; \
    packed_data->args.texture = (GLuint)_texture; \
    (packed_call_t *)packed_data; \
})
#define call_glIsTexture(packed, ret_v) do { \
    PACKED_glIsTexture *unpacked = (PACKED_glIsTexture *)packed; \
    ARGS_glIsTexture *args = (ARGS_glIsTexture *)&unpacked->args; \
    GLboolean *ret = (GLboolean *)ret_v; \
    if (ret != NULL) { \
        *ret = glIsTexture(args->texture);; \
    } else { \
        glIsTexture(args->texture);; \
    } \
} while(0)
GLboolean glIsTexture(glIsTexture_ARG_EXPAND);
typedef GLboolean (*glIsTexture_PTR)(glIsTexture_ARG_EXPAND);
#define glIsTextureEXT_INDEX 1162
#define glIsTextureEXT_RETURN GLboolean
#define glIsTextureEXT_ARG_NAMES texture
#define glIsTextureEXT_ARG_EXPAND GLuint texture
#define glIsTextureEXT_PACKED PACKED_glIsTextureEXT
#define glIsTextureEXT_VOID_ONLY_WRAP(...) {}
#define glIsTextureEXT_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glIsTextureEXT(_texture) ({ \
    glIsTextureEXT_PACKED *packed_data = malloc(sizeof(glIsTextureEXT_PACKED)); \
    packed_data->index = glIsTextureEXT_INDEX; \
    packed_data->args.texture = (GLuint)_texture; \
    (packed_call_t *)packed_data; \
})
#define call_glIsTextureEXT(packed, ret_v) do { \
    PACKED_glIsTextureEXT *unpacked = (PACKED_glIsTextureEXT *)packed; \
    ARGS_glIsTextureEXT *args = (ARGS_glIsTextureEXT *)&unpacked->args; \
    GLboolean *ret = (GLboolean *)ret_v; \
    if (ret != NULL) { \
        *ret = glIsTextureEXT(args->texture);; \
    } else { \
        glIsTextureEXT(args->texture);; \
    } \
} while(0)
GLboolean glIsTextureEXT(glIsTextureEXT_ARG_EXPAND);
typedef GLboolean (*glIsTextureEXT_PTR)(glIsTextureEXT_ARG_EXPAND);
#define glIsTextureHandleResidentNV_INDEX 1163
#define glIsTextureHandleResidentNV_RETURN GLboolean
#define glIsTextureHandleResidentNV_ARG_NAMES handle
#define glIsTextureHandleResidentNV_ARG_EXPAND GLuint64 handle
#define glIsTextureHandleResidentNV_PACKED PACKED_glIsTextureHandleResidentNV
#define glIsTextureHandleResidentNV_VOID_ONLY_WRAP(...) {}
#define glIsTextureHandleResidentNV_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glIsTextureHandleResidentNV(_handle) ({ \
    glIsTextureHandleResidentNV_PACKED *packed_data = malloc(sizeof(glIsTextureHandleResidentNV_PACKED)); \
    packed_data->index = glIsTextureHandleResidentNV_INDEX; \
    packed_data->args.handle = (GLuint64)_handle; \
    (packed_call_t *)packed_data; \
})
#define call_glIsTextureHandleResidentNV(packed, ret_v) do { \
    PACKED_glIsTextureHandleResidentNV *unpacked = (PACKED_glIsTextureHandleResidentNV *)packed; \
    ARGS_glIsTextureHandleResidentNV *args = (ARGS_glIsTextureHandleResidentNV *)&unpacked->args; \
    GLboolean *ret = (GLboolean *)ret_v; \
    if (ret != NULL) { \
        *ret = glIsTextureHandleResidentNV(args->handle);; \
    } else { \
        glIsTextureHandleResidentNV(args->handle);; \
    } \
} while(0)
GLboolean glIsTextureHandleResidentNV(glIsTextureHandleResidentNV_ARG_EXPAND);
typedef GLboolean (*glIsTextureHandleResidentNV_PTR)(glIsTextureHandleResidentNV_ARG_EXPAND);
#define glIsTransformFeedback_INDEX 1164
#define glIsTransformFeedback_RETURN GLboolean
#define glIsTransformFeedback_ARG_NAMES id
#define glIsTransformFeedback_ARG_EXPAND GLuint id
#define glIsTransformFeedback_PACKED PACKED_glIsTransformFeedback
#define glIsTransformFeedback_VOID_ONLY_WRAP(...) {}
#define glIsTransformFeedback_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glIsTransformFeedback(_id) ({ \
    glIsTransformFeedback_PACKED *packed_data = malloc(sizeof(glIsTransformFeedback_PACKED)); \
    packed_data->index = glIsTransformFeedback_INDEX; \
    packed_data->args.id = (GLuint)_id; \
    (packed_call_t *)packed_data; \
})
#define call_glIsTransformFeedback(packed, ret_v) do { \
    PACKED_glIsTransformFeedback *unpacked = (PACKED_glIsTransformFeedback *)packed; \
    ARGS_glIsTransformFeedback *args = (ARGS_glIsTransformFeedback *)&unpacked->args; \
    GLboolean *ret = (GLboolean *)ret_v; \
    if (ret != NULL) { \
        *ret = glIsTransformFeedback(args->id);; \
    } else { \
        glIsTransformFeedback(args->id);; \
    } \
} while(0)
GLboolean glIsTransformFeedback(glIsTransformFeedback_ARG_EXPAND);
typedef GLboolean (*glIsTransformFeedback_PTR)(glIsTransformFeedback_ARG_EXPAND);
#define glIsTransformFeedbackNV_INDEX 1165
#define glIsTransformFeedbackNV_RETURN GLboolean
#define glIsTransformFeedbackNV_ARG_NAMES id
#define glIsTransformFeedbackNV_ARG_EXPAND GLuint id
#define glIsTransformFeedbackNV_PACKED PACKED_glIsTransformFeedbackNV
#define glIsTransformFeedbackNV_VOID_ONLY_WRAP(...) {}
#define glIsTransformFeedbackNV_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glIsTransformFeedbackNV(_id) ({ \
    glIsTransformFeedbackNV_PACKED *packed_data = malloc(sizeof(glIsTransformFeedbackNV_PACKED)); \
    packed_data->index = glIsTransformFeedbackNV_INDEX; \
    packed_data->args.id = (GLuint)_id; \
    (packed_call_t *)packed_data; \
})
#define call_glIsTransformFeedbackNV(packed, ret_v) do { \
    PACKED_glIsTransformFeedbackNV *unpacked = (PACKED_glIsTransformFeedbackNV *)packed; \
    ARGS_glIsTransformFeedbackNV *args = (ARGS_glIsTransformFeedbackNV *)&unpacked->args; \
    GLboolean *ret = (GLboolean *)ret_v; \
    if (ret != NULL) { \
        *ret = glIsTransformFeedbackNV(args->id);; \
    } else { \
        glIsTransformFeedbackNV(args->id);; \
    } \
} while(0)
GLboolean glIsTransformFeedbackNV(glIsTransformFeedbackNV_ARG_EXPAND);
typedef GLboolean (*glIsTransformFeedbackNV_PTR)(glIsTransformFeedbackNV_ARG_EXPAND);
#define glIsVariantEnabledEXT_INDEX 1166
#define glIsVariantEnabledEXT_RETURN GLboolean
#define glIsVariantEnabledEXT_ARG_NAMES id, cap
#define glIsVariantEnabledEXT_ARG_EXPAND GLuint id, GLenum cap
#define glIsVariantEnabledEXT_PACKED PACKED_glIsVariantEnabledEXT
#define glIsVariantEnabledEXT_VOID_ONLY_WRAP(...) {}
#define glIsVariantEnabledEXT_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glIsVariantEnabledEXT(_id, _cap) ({ \
    glIsVariantEnabledEXT_PACKED *packed_data = malloc(sizeof(glIsVariantEnabledEXT_PACKED)); \
    packed_data->index = glIsVariantEnabledEXT_INDEX; \
    packed_data->args.id = (GLuint)_id; \
    packed_data->args.cap = (GLenum)_cap; \
    (packed_call_t *)packed_data; \
})
#define call_glIsVariantEnabledEXT(packed, ret_v) do { \
    PACKED_glIsVariantEnabledEXT *unpacked = (PACKED_glIsVariantEnabledEXT *)packed; \
    ARGS_glIsVariantEnabledEXT *args = (ARGS_glIsVariantEnabledEXT *)&unpacked->args; \
    GLboolean *ret = (GLboolean *)ret_v; \
    if (ret != NULL) { \
        *ret = glIsVariantEnabledEXT(args->id, args->cap);; \
    } else { \
        glIsVariantEnabledEXT(args->id, args->cap);; \
    } \
} while(0)
GLboolean glIsVariantEnabledEXT(glIsVariantEnabledEXT_ARG_EXPAND);
typedef GLboolean (*glIsVariantEnabledEXT_PTR)(glIsVariantEnabledEXT_ARG_EXPAND);
#define glIsVertexArray_INDEX 1167
#define glIsVertexArray_RETURN GLboolean
#define glIsVertexArray_ARG_NAMES array
#define glIsVertexArray_ARG_EXPAND GLuint array
#define glIsVertexArray_PACKED PACKED_glIsVertexArray
#define glIsVertexArray_VOID_ONLY_WRAP(...) {}
#define glIsVertexArray_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glIsVertexArray(_array) ({ \
    glIsVertexArray_PACKED *packed_data = malloc(sizeof(glIsVertexArray_PACKED)); \
    packed_data->index = glIsVertexArray_INDEX; \
    packed_data->args.array = (GLuint)_array; \
    (packed_call_t *)packed_data; \
})
#define call_glIsVertexArray(packed, ret_v) do { \
    PACKED_glIsVertexArray *unpacked = (PACKED_glIsVertexArray *)packed; \
    ARGS_glIsVertexArray *args = (ARGS_glIsVertexArray *)&unpacked->args; \
    GLboolean *ret = (GLboolean *)ret_v; \
    if (ret != NULL) { \
        *ret = glIsVertexArray(args->array);; \
    } else { \
        glIsVertexArray(args->array);; \
    } \
} while(0)
GLboolean glIsVertexArray(glIsVertexArray_ARG_EXPAND);
typedef GLboolean (*glIsVertexArray_PTR)(glIsVertexArray_ARG_EXPAND);
#define glIsVertexArrayAPPLE_INDEX 1168
#define glIsVertexArrayAPPLE_RETURN GLboolean
#define glIsVertexArrayAPPLE_ARG_NAMES array
#define glIsVertexArrayAPPLE_ARG_EXPAND GLuint array
#define glIsVertexArrayAPPLE_PACKED PACKED_glIsVertexArrayAPPLE
#define glIsVertexArrayAPPLE_VOID_ONLY_WRAP(...) {}
#define glIsVertexArrayAPPLE_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glIsVertexArrayAPPLE(_array) ({ \
    glIsVertexArrayAPPLE_PACKED *packed_data = malloc(sizeof(glIsVertexArrayAPPLE_PACKED)); \
    packed_data->index = glIsVertexArrayAPPLE_INDEX; \
    packed_data->args.array = (GLuint)_array; \
    (packed_call_t *)packed_data; \
})
#define call_glIsVertexArrayAPPLE(packed, ret_v) do { \
    PACKED_glIsVertexArrayAPPLE *unpacked = (PACKED_glIsVertexArrayAPPLE *)packed; \
    ARGS_glIsVertexArrayAPPLE *args = (ARGS_glIsVertexArrayAPPLE *)&unpacked->args; \
    GLboolean *ret = (GLboolean *)ret_v; \
    if (ret != NULL) { \
        *ret = glIsVertexArrayAPPLE(args->array);; \
    } else { \
        glIsVertexArrayAPPLE(args->array);; \
    } \
} while(0)
GLboolean glIsVertexArrayAPPLE(glIsVertexArrayAPPLE_ARG_EXPAND);
typedef GLboolean (*glIsVertexArrayAPPLE_PTR)(glIsVertexArrayAPPLE_ARG_EXPAND);
#define glIsVertexAttribEnabledAPPLE_INDEX 1169
#define glIsVertexAttribEnabledAPPLE_RETURN GLboolean
#define glIsVertexAttribEnabledAPPLE_ARG_NAMES index, pname
#define glIsVertexAttribEnabledAPPLE_ARG_EXPAND GLuint index, GLenum pname
#define glIsVertexAttribEnabledAPPLE_PACKED PACKED_glIsVertexAttribEnabledAPPLE
#define glIsVertexAttribEnabledAPPLE_VOID_ONLY_WRAP(...) {}
#define glIsVertexAttribEnabledAPPLE_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glIsVertexAttribEnabledAPPLE(_index, _pname) ({ \
    glIsVertexAttribEnabledAPPLE_PACKED *packed_data = malloc(sizeof(glIsVertexAttribEnabledAPPLE_PACKED)); \
    packed_data->index = glIsVertexAttribEnabledAPPLE_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.pname = (GLenum)_pname; \
    (packed_call_t *)packed_data; \
})
#define call_glIsVertexAttribEnabledAPPLE(packed, ret_v) do { \
    PACKED_glIsVertexAttribEnabledAPPLE *unpacked = (PACKED_glIsVertexAttribEnabledAPPLE *)packed; \
    ARGS_glIsVertexAttribEnabledAPPLE *args = (ARGS_glIsVertexAttribEnabledAPPLE *)&unpacked->args; \
    GLboolean *ret = (GLboolean *)ret_v; \
    if (ret != NULL) { \
        *ret = glIsVertexAttribEnabledAPPLE(args->index, args->pname);; \
    } else { \
        glIsVertexAttribEnabledAPPLE(args->index, args->pname);; \
    } \
} while(0)
GLboolean glIsVertexAttribEnabledAPPLE(glIsVertexAttribEnabledAPPLE_ARG_EXPAND);
typedef GLboolean (*glIsVertexAttribEnabledAPPLE_PTR)(glIsVertexAttribEnabledAPPLE_ARG_EXPAND);
#define glLightEnviSGIX_INDEX 1170
#define glLightEnviSGIX_RETURN void
#define glLightEnviSGIX_ARG_NAMES pname, param
#define glLightEnviSGIX_ARG_EXPAND GLenum pname, GLint param
#define glLightEnviSGIX_PACKED PACKED_glLightEnviSGIX
#define glLightEnviSGIX_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glLightEnviSGIX_NOT_VOID_WRAP(...) {}
#define pack_glLightEnviSGIX(_pname, _param) ({ \
    glLightEnviSGIX_PACKED *packed_data = malloc(sizeof(glLightEnviSGIX_PACKED)); \
    packed_data->index = glLightEnviSGIX_INDEX; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.param = (GLint)_param; \
    (packed_call_t *)packed_data; \
})
#define call_glLightEnviSGIX(packed, ret_v) do { \
    PACKED_glLightEnviSGIX *unpacked = (PACKED_glLightEnviSGIX *)packed; \
    ARGS_glLightEnviSGIX *args = (ARGS_glLightEnviSGIX *)&unpacked->args; \
    glLightEnviSGIX(args->pname, args->param);; \
} while(0)
void glLightEnviSGIX(glLightEnviSGIX_ARG_EXPAND);
typedef void (*glLightEnviSGIX_PTR)(glLightEnviSGIX_ARG_EXPAND);
#define glLightModelf_INDEX 1171
#define glLightModelf_RETURN void
#define glLightModelf_ARG_NAMES pname, param
#define glLightModelf_ARG_EXPAND GLenum pname, GLfloat param
#define glLightModelf_PACKED PACKED_glLightModelf
#define glLightModelf_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glLightModelf_NOT_VOID_WRAP(...) {}
#define pack_glLightModelf(_pname, _param) ({ \
    glLightModelf_PACKED *packed_data = malloc(sizeof(glLightModelf_PACKED)); \
    packed_data->index = glLightModelf_INDEX; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.param = (GLfloat)_param; \
    (packed_call_t *)packed_data; \
})
#define call_glLightModelf(packed, ret_v) do { \
    PACKED_glLightModelf *unpacked = (PACKED_glLightModelf *)packed; \
    ARGS_glLightModelf *args = (ARGS_glLightModelf *)&unpacked->args; \
    glLightModelf(args->pname, args->param);; \
} while(0)
void glLightModelf(glLightModelf_ARG_EXPAND);
typedef void (*glLightModelf_PTR)(glLightModelf_ARG_EXPAND);
#define glLightModelfv_INDEX 1172
#define glLightModelfv_RETURN void
#define glLightModelfv_ARG_NAMES pname, params
#define glLightModelfv_ARG_EXPAND GLenum pname, const GLfloat * params
#define glLightModelfv_PACKED PACKED_glLightModelfv
#define glLightModelfv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glLightModelfv_NOT_VOID_WRAP(...) {}
#define pack_glLightModelfv(_pname, _params) ({ \
    glLightModelfv_PACKED *packed_data = malloc(sizeof(glLightModelfv_PACKED)); \
    packed_data->index = glLightModelfv_INDEX; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLfloat *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glLightModelfv(packed, ret_v) do { \
    PACKED_glLightModelfv *unpacked = (PACKED_glLightModelfv *)packed; \
    ARGS_glLightModelfv *args = (ARGS_glLightModelfv *)&unpacked->args; \
    glLightModelfv(args->pname, args->params);; \
} while(0)
void glLightModelfv(glLightModelfv_ARG_EXPAND);
typedef void (*glLightModelfv_PTR)(glLightModelfv_ARG_EXPAND);
#define glLightModeli_INDEX 1173
#define glLightModeli_RETURN void
#define glLightModeli_ARG_NAMES pname, param
#define glLightModeli_ARG_EXPAND GLenum pname, GLint param
#define glLightModeli_PACKED PACKED_glLightModeli
#define glLightModeli_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glLightModeli_NOT_VOID_WRAP(...) {}
#define pack_glLightModeli(_pname, _param) ({ \
    glLightModeli_PACKED *packed_data = malloc(sizeof(glLightModeli_PACKED)); \
    packed_data->index = glLightModeli_INDEX; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.param = (GLint)_param; \
    (packed_call_t *)packed_data; \
})
#define call_glLightModeli(packed, ret_v) do { \
    PACKED_glLightModeli *unpacked = (PACKED_glLightModeli *)packed; \
    ARGS_glLightModeli *args = (ARGS_glLightModeli *)&unpacked->args; \
    glLightModeli(args->pname, args->param);; \
} while(0)
void glLightModeli(glLightModeli_ARG_EXPAND);
typedef void (*glLightModeli_PTR)(glLightModeli_ARG_EXPAND);
#define glLightModeliv_INDEX 1174
#define glLightModeliv_RETURN void
#define glLightModeliv_ARG_NAMES pname, params
#define glLightModeliv_ARG_EXPAND GLenum pname, const GLint * params
#define glLightModeliv_PACKED PACKED_glLightModeliv
#define glLightModeliv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glLightModeliv_NOT_VOID_WRAP(...) {}
#define pack_glLightModeliv(_pname, _params) ({ \
    glLightModeliv_PACKED *packed_data = malloc(sizeof(glLightModeliv_PACKED)); \
    packed_data->index = glLightModeliv_INDEX; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glLightModeliv(packed, ret_v) do { \
    PACKED_glLightModeliv *unpacked = (PACKED_glLightModeliv *)packed; \
    ARGS_glLightModeliv *args = (ARGS_glLightModeliv *)&unpacked->args; \
    glLightModeliv(args->pname, args->params);; \
} while(0)
void glLightModeliv(glLightModeliv_ARG_EXPAND);
typedef void (*glLightModeliv_PTR)(glLightModeliv_ARG_EXPAND);
#define glLightModelx_INDEX 1175
#define glLightModelx_RETURN void
#define glLightModelx_ARG_NAMES pname, param
#define glLightModelx_ARG_EXPAND GLenum pname, GLfixed param
#define glLightModelx_PACKED PACKED_glLightModelx
#define glLightModelx_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glLightModelx_NOT_VOID_WRAP(...) {}
#define pack_glLightModelx(_pname, _param) ({ \
    glLightModelx_PACKED *packed_data = malloc(sizeof(glLightModelx_PACKED)); \
    packed_data->index = glLightModelx_INDEX; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.param = (GLfixed)_param; \
    (packed_call_t *)packed_data; \
})
#define call_glLightModelx(packed, ret_v) do { \
    PACKED_glLightModelx *unpacked = (PACKED_glLightModelx *)packed; \
    ARGS_glLightModelx *args = (ARGS_glLightModelx *)&unpacked->args; \
    glLightModelx(args->pname, args->param);; \
} while(0)
void glLightModelx(glLightModelx_ARG_EXPAND);
typedef void (*glLightModelx_PTR)(glLightModelx_ARG_EXPAND);
#define glLightModelxOES_INDEX 1176
#define glLightModelxOES_RETURN void
#define glLightModelxOES_ARG_NAMES pname, param
#define glLightModelxOES_ARG_EXPAND GLenum pname, GLfixed param
#define glLightModelxOES_PACKED PACKED_glLightModelxOES
#define glLightModelxOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glLightModelxOES_NOT_VOID_WRAP(...) {}
#define pack_glLightModelxOES(_pname, _param) ({ \
    glLightModelxOES_PACKED *packed_data = malloc(sizeof(glLightModelxOES_PACKED)); \
    packed_data->index = glLightModelxOES_INDEX; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.param = (GLfixed)_param; \
    (packed_call_t *)packed_data; \
})
#define call_glLightModelxOES(packed, ret_v) do { \
    PACKED_glLightModelxOES *unpacked = (PACKED_glLightModelxOES *)packed; \
    ARGS_glLightModelxOES *args = (ARGS_glLightModelxOES *)&unpacked->args; \
    glLightModelxOES(args->pname, args->param);; \
} while(0)
void glLightModelxOES(glLightModelxOES_ARG_EXPAND);
typedef void (*glLightModelxOES_PTR)(glLightModelxOES_ARG_EXPAND);
#define glLightModelxv_INDEX 1177
#define glLightModelxv_RETURN void
#define glLightModelxv_ARG_NAMES pname, params
#define glLightModelxv_ARG_EXPAND GLenum pname, const GLfixed * params
#define glLightModelxv_PACKED PACKED_glLightModelxv
#define glLightModelxv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glLightModelxv_NOT_VOID_WRAP(...) {}
#define pack_glLightModelxv(_pname, _params) ({ \
    glLightModelxv_PACKED *packed_data = malloc(sizeof(glLightModelxv_PACKED)); \
    packed_data->index = glLightModelxv_INDEX; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLfixed *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glLightModelxv(packed, ret_v) do { \
    PACKED_glLightModelxv *unpacked = (PACKED_glLightModelxv *)packed; \
    ARGS_glLightModelxv *args = (ARGS_glLightModelxv *)&unpacked->args; \
    glLightModelxv(args->pname, args->params);; \
} while(0)
void glLightModelxv(glLightModelxv_ARG_EXPAND);
typedef void (*glLightModelxv_PTR)(glLightModelxv_ARG_EXPAND);
#define glLightModelxvOES_INDEX 1178
#define glLightModelxvOES_RETURN void
#define glLightModelxvOES_ARG_NAMES pname, param
#define glLightModelxvOES_ARG_EXPAND GLenum pname, const GLfixed * param
#define glLightModelxvOES_PACKED PACKED_glLightModelxvOES
#define glLightModelxvOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glLightModelxvOES_NOT_VOID_WRAP(...) {}
#define pack_glLightModelxvOES(_pname, _param) ({ \
    glLightModelxvOES_PACKED *packed_data = malloc(sizeof(glLightModelxvOES_PACKED)); \
    packed_data->index = glLightModelxvOES_INDEX; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.param = (GLfixed *)_param; \
    (packed_call_t *)packed_data; \
})
#define call_glLightModelxvOES(packed, ret_v) do { \
    PACKED_glLightModelxvOES *unpacked = (PACKED_glLightModelxvOES *)packed; \
    ARGS_glLightModelxvOES *args = (ARGS_glLightModelxvOES *)&unpacked->args; \
    glLightModelxvOES(args->pname, args->param);; \
} while(0)
void glLightModelxvOES(glLightModelxvOES_ARG_EXPAND);
typedef void (*glLightModelxvOES_PTR)(glLightModelxvOES_ARG_EXPAND);
#define glLightf_INDEX 1179
#define glLightf_RETURN void
#define glLightf_ARG_NAMES light, pname, param
#define glLightf_ARG_EXPAND GLenum light, GLenum pname, GLfloat param
#define glLightf_PACKED PACKED_glLightf
#define glLightf_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glLightf_NOT_VOID_WRAP(...) {}
#define pack_glLightf(_light, _pname, _param) ({ \
    glLightf_PACKED *packed_data = malloc(sizeof(glLightf_PACKED)); \
    packed_data->index = glLightf_INDEX; \
    packed_data->args.light = (GLenum)_light; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.param = (GLfloat)_param; \
    (packed_call_t *)packed_data; \
})
#define call_glLightf(packed, ret_v) do { \
    PACKED_glLightf *unpacked = (PACKED_glLightf *)packed; \
    ARGS_glLightf *args = (ARGS_glLightf *)&unpacked->args; \
    glLightf(args->light, args->pname, args->param);; \
} while(0)
void glLightf(glLightf_ARG_EXPAND);
typedef void (*glLightf_PTR)(glLightf_ARG_EXPAND);
#define glLightfv_INDEX 1180
#define glLightfv_RETURN void
#define glLightfv_ARG_NAMES light, pname, params
#define glLightfv_ARG_EXPAND GLenum light, GLenum pname, const GLfloat * params
#define glLightfv_PACKED PACKED_glLightfv
#define glLightfv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glLightfv_NOT_VOID_WRAP(...) {}
#define pack_glLightfv(_light, _pname, _params) ({ \
    glLightfv_PACKED *packed_data = malloc(sizeof(glLightfv_PACKED)); \
    packed_data->index = glLightfv_INDEX; \
    packed_data->args.light = (GLenum)_light; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLfloat *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glLightfv(packed, ret_v) do { \
    PACKED_glLightfv *unpacked = (PACKED_glLightfv *)packed; \
    ARGS_glLightfv *args = (ARGS_glLightfv *)&unpacked->args; \
    glLightfv(args->light, args->pname, args->params);; \
} while(0)
void glLightfv(glLightfv_ARG_EXPAND);
typedef void (*glLightfv_PTR)(glLightfv_ARG_EXPAND);
#define glLighti_INDEX 1181
#define glLighti_RETURN void
#define glLighti_ARG_NAMES light, pname, param
#define glLighti_ARG_EXPAND GLenum light, GLenum pname, GLint param
#define glLighti_PACKED PACKED_glLighti
#define glLighti_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glLighti_NOT_VOID_WRAP(...) {}
#define pack_glLighti(_light, _pname, _param) ({ \
    glLighti_PACKED *packed_data = malloc(sizeof(glLighti_PACKED)); \
    packed_data->index = glLighti_INDEX; \
    packed_data->args.light = (GLenum)_light; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.param = (GLint)_param; \
    (packed_call_t *)packed_data; \
})
#define call_glLighti(packed, ret_v) do { \
    PACKED_glLighti *unpacked = (PACKED_glLighti *)packed; \
    ARGS_glLighti *args = (ARGS_glLighti *)&unpacked->args; \
    glLighti(args->light, args->pname, args->param);; \
} while(0)
void glLighti(glLighti_ARG_EXPAND);
typedef void (*glLighti_PTR)(glLighti_ARG_EXPAND);
#define glLightiv_INDEX 1182
#define glLightiv_RETURN void
#define glLightiv_ARG_NAMES light, pname, params
#define glLightiv_ARG_EXPAND GLenum light, GLenum pname, const GLint * params
#define glLightiv_PACKED PACKED_glLightiv
#define glLightiv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glLightiv_NOT_VOID_WRAP(...) {}
#define pack_glLightiv(_light, _pname, _params) ({ \
    glLightiv_PACKED *packed_data = malloc(sizeof(glLightiv_PACKED)); \
    packed_data->index = glLightiv_INDEX; \
    packed_data->args.light = (GLenum)_light; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glLightiv(packed, ret_v) do { \
    PACKED_glLightiv *unpacked = (PACKED_glLightiv *)packed; \
    ARGS_glLightiv *args = (ARGS_glLightiv *)&unpacked->args; \
    glLightiv(args->light, args->pname, args->params);; \
} while(0)
void glLightiv(glLightiv_ARG_EXPAND);
typedef void (*glLightiv_PTR)(glLightiv_ARG_EXPAND);
#define glLightx_INDEX 1183
#define glLightx_RETURN void
#define glLightx_ARG_NAMES light, pname, param
#define glLightx_ARG_EXPAND GLenum light, GLenum pname, GLfixed param
#define glLightx_PACKED PACKED_glLightx
#define glLightx_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glLightx_NOT_VOID_WRAP(...) {}
#define pack_glLightx(_light, _pname, _param) ({ \
    glLightx_PACKED *packed_data = malloc(sizeof(glLightx_PACKED)); \
    packed_data->index = glLightx_INDEX; \
    packed_data->args.light = (GLenum)_light; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.param = (GLfixed)_param; \
    (packed_call_t *)packed_data; \
})
#define call_glLightx(packed, ret_v) do { \
    PACKED_glLightx *unpacked = (PACKED_glLightx *)packed; \
    ARGS_glLightx *args = (ARGS_glLightx *)&unpacked->args; \
    glLightx(args->light, args->pname, args->param);; \
} while(0)
void glLightx(glLightx_ARG_EXPAND);
typedef void (*glLightx_PTR)(glLightx_ARG_EXPAND);
#define glLightxOES_INDEX 1184
#define glLightxOES_RETURN void
#define glLightxOES_ARG_NAMES light, pname, param
#define glLightxOES_ARG_EXPAND GLenum light, GLenum pname, GLfixed param
#define glLightxOES_PACKED PACKED_glLightxOES
#define glLightxOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glLightxOES_NOT_VOID_WRAP(...) {}
#define pack_glLightxOES(_light, _pname, _param) ({ \
    glLightxOES_PACKED *packed_data = malloc(sizeof(glLightxOES_PACKED)); \
    packed_data->index = glLightxOES_INDEX; \
    packed_data->args.light = (GLenum)_light; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.param = (GLfixed)_param; \
    (packed_call_t *)packed_data; \
})
#define call_glLightxOES(packed, ret_v) do { \
    PACKED_glLightxOES *unpacked = (PACKED_glLightxOES *)packed; \
    ARGS_glLightxOES *args = (ARGS_glLightxOES *)&unpacked->args; \
    glLightxOES(args->light, args->pname, args->param);; \
} while(0)
void glLightxOES(glLightxOES_ARG_EXPAND);
typedef void (*glLightxOES_PTR)(glLightxOES_ARG_EXPAND);
#define glLightxv_INDEX 1185
#define glLightxv_RETURN void
#define glLightxv_ARG_NAMES light, pname, params
#define glLightxv_ARG_EXPAND GLenum light, GLenum pname, const GLfixed * params
#define glLightxv_PACKED PACKED_glLightxv
#define glLightxv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glLightxv_NOT_VOID_WRAP(...) {}
#define pack_glLightxv(_light, _pname, _params) ({ \
    glLightxv_PACKED *packed_data = malloc(sizeof(glLightxv_PACKED)); \
    packed_data->index = glLightxv_INDEX; \
    packed_data->args.light = (GLenum)_light; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLfixed *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glLightxv(packed, ret_v) do { \
    PACKED_glLightxv *unpacked = (PACKED_glLightxv *)packed; \
    ARGS_glLightxv *args = (ARGS_glLightxv *)&unpacked->args; \
    glLightxv(args->light, args->pname, args->params);; \
} while(0)
void glLightxv(glLightxv_ARG_EXPAND);
typedef void (*glLightxv_PTR)(glLightxv_ARG_EXPAND);
#define glLightxvOES_INDEX 1186
#define glLightxvOES_RETURN void
#define glLightxvOES_ARG_NAMES light, pname, params
#define glLightxvOES_ARG_EXPAND GLenum light, GLenum pname, const GLfixed * params
#define glLightxvOES_PACKED PACKED_glLightxvOES
#define glLightxvOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glLightxvOES_NOT_VOID_WRAP(...) {}
#define pack_glLightxvOES(_light, _pname, _params) ({ \
    glLightxvOES_PACKED *packed_data = malloc(sizeof(glLightxvOES_PACKED)); \
    packed_data->index = glLightxvOES_INDEX; \
    packed_data->args.light = (GLenum)_light; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLfixed *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glLightxvOES(packed, ret_v) do { \
    PACKED_glLightxvOES *unpacked = (PACKED_glLightxvOES *)packed; \
    ARGS_glLightxvOES *args = (ARGS_glLightxvOES *)&unpacked->args; \
    glLightxvOES(args->light, args->pname, args->params);; \
} while(0)
void glLightxvOES(glLightxvOES_ARG_EXPAND);
typedef void (*glLightxvOES_PTR)(glLightxvOES_ARG_EXPAND);
#define glLineStipple_INDEX 1187
#define glLineStipple_RETURN void
#define glLineStipple_ARG_NAMES factor, pattern
#define glLineStipple_ARG_EXPAND GLint factor, GLushort pattern
#define glLineStipple_PACKED PACKED_glLineStipple
#define glLineStipple_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glLineStipple_NOT_VOID_WRAP(...) {}
#define pack_glLineStipple(_factor, _pattern) ({ \
    glLineStipple_PACKED *packed_data = malloc(sizeof(glLineStipple_PACKED)); \
    packed_data->index = glLineStipple_INDEX; \
    packed_data->args.factor = (GLint)_factor; \
    packed_data->args.pattern = (GLushort)_pattern; \
    (packed_call_t *)packed_data; \
})
#define call_glLineStipple(packed, ret_v) do { \
    PACKED_glLineStipple *unpacked = (PACKED_glLineStipple *)packed; \
    ARGS_glLineStipple *args = (ARGS_glLineStipple *)&unpacked->args; \
    glLineStipple(args->factor, args->pattern);; \
} while(0)
void glLineStipple(glLineStipple_ARG_EXPAND);
typedef void (*glLineStipple_PTR)(glLineStipple_ARG_EXPAND);
#define glLineWidth_INDEX 1188
#define glLineWidth_RETURN void
#define glLineWidth_ARG_NAMES width
#define glLineWidth_ARG_EXPAND GLfloat width
#define glLineWidth_PACKED PACKED_glLineWidth
#define glLineWidth_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glLineWidth_NOT_VOID_WRAP(...) {}
#define pack_glLineWidth(_width) ({ \
    glLineWidth_PACKED *packed_data = malloc(sizeof(glLineWidth_PACKED)); \
    packed_data->index = glLineWidth_INDEX; \
    packed_data->args.width = (GLfloat)_width; \
    (packed_call_t *)packed_data; \
})
#define call_glLineWidth(packed, ret_v) do { \
    PACKED_glLineWidth *unpacked = (PACKED_glLineWidth *)packed; \
    ARGS_glLineWidth *args = (ARGS_glLineWidth *)&unpacked->args; \
    glLineWidth(args->width);; \
} while(0)
void glLineWidth(glLineWidth_ARG_EXPAND);
typedef void (*glLineWidth_PTR)(glLineWidth_ARG_EXPAND);
#define glLineWidthx_INDEX 1189
#define glLineWidthx_RETURN void
#define glLineWidthx_ARG_NAMES width
#define glLineWidthx_ARG_EXPAND GLfixed width
#define glLineWidthx_PACKED PACKED_glLineWidthx
#define glLineWidthx_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glLineWidthx_NOT_VOID_WRAP(...) {}
#define pack_glLineWidthx(_width) ({ \
    glLineWidthx_PACKED *packed_data = malloc(sizeof(glLineWidthx_PACKED)); \
    packed_data->index = glLineWidthx_INDEX; \
    packed_data->args.width = (GLfixed)_width; \
    (packed_call_t *)packed_data; \
})
#define call_glLineWidthx(packed, ret_v) do { \
    PACKED_glLineWidthx *unpacked = (PACKED_glLineWidthx *)packed; \
    ARGS_glLineWidthx *args = (ARGS_glLineWidthx *)&unpacked->args; \
    glLineWidthx(args->width);; \
} while(0)
void glLineWidthx(glLineWidthx_ARG_EXPAND);
typedef void (*glLineWidthx_PTR)(glLineWidthx_ARG_EXPAND);
#define glLineWidthxOES_INDEX 1190
#define glLineWidthxOES_RETURN void
#define glLineWidthxOES_ARG_NAMES width
#define glLineWidthxOES_ARG_EXPAND GLfixed width
#define glLineWidthxOES_PACKED PACKED_glLineWidthxOES
#define glLineWidthxOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glLineWidthxOES_NOT_VOID_WRAP(...) {}
#define pack_glLineWidthxOES(_width) ({ \
    glLineWidthxOES_PACKED *packed_data = malloc(sizeof(glLineWidthxOES_PACKED)); \
    packed_data->index = glLineWidthxOES_INDEX; \
    packed_data->args.width = (GLfixed)_width; \
    (packed_call_t *)packed_data; \
})
#define call_glLineWidthxOES(packed, ret_v) do { \
    PACKED_glLineWidthxOES *unpacked = (PACKED_glLineWidthxOES *)packed; \
    ARGS_glLineWidthxOES *args = (ARGS_glLineWidthxOES *)&unpacked->args; \
    glLineWidthxOES(args->width);; \
} while(0)
void glLineWidthxOES(glLineWidthxOES_ARG_EXPAND);
typedef void (*glLineWidthxOES_PTR)(glLineWidthxOES_ARG_EXPAND);
#define glLinkProgram_INDEX 1191
#define glLinkProgram_RETURN void
#define glLinkProgram_ARG_NAMES program
#define glLinkProgram_ARG_EXPAND GLuint program
#define glLinkProgram_PACKED PACKED_glLinkProgram
#define glLinkProgram_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glLinkProgram_NOT_VOID_WRAP(...) {}
#define pack_glLinkProgram(_program) ({ \
    glLinkProgram_PACKED *packed_data = malloc(sizeof(glLinkProgram_PACKED)); \
    packed_data->index = glLinkProgram_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    (packed_call_t *)packed_data; \
})
#define call_glLinkProgram(packed, ret_v) do { \
    PACKED_glLinkProgram *unpacked = (PACKED_glLinkProgram *)packed; \
    ARGS_glLinkProgram *args = (ARGS_glLinkProgram *)&unpacked->args; \
    glLinkProgram(args->program);; \
} while(0)
void glLinkProgram(glLinkProgram_ARG_EXPAND);
typedef void (*glLinkProgram_PTR)(glLinkProgram_ARG_EXPAND);
#define glLinkProgramARB_INDEX 1192
#define glLinkProgramARB_RETURN void
#define glLinkProgramARB_ARG_NAMES programObj
#define glLinkProgramARB_ARG_EXPAND GLhandleARB programObj
#define glLinkProgramARB_PACKED PACKED_glLinkProgramARB
#define glLinkProgramARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glLinkProgramARB_NOT_VOID_WRAP(...) {}
#define pack_glLinkProgramARB(_programObj) ({ \
    glLinkProgramARB_PACKED *packed_data = malloc(sizeof(glLinkProgramARB_PACKED)); \
    packed_data->index = glLinkProgramARB_INDEX; \
    packed_data->args.programObj = (GLhandleARB)_programObj; \
    (packed_call_t *)packed_data; \
})
#define call_glLinkProgramARB(packed, ret_v) do { \
    PACKED_glLinkProgramARB *unpacked = (PACKED_glLinkProgramARB *)packed; \
    ARGS_glLinkProgramARB *args = (ARGS_glLinkProgramARB *)&unpacked->args; \
    glLinkProgramARB(args->programObj);; \
} while(0)
void glLinkProgramARB(glLinkProgramARB_ARG_EXPAND);
typedef void (*glLinkProgramARB_PTR)(glLinkProgramARB_ARG_EXPAND);
#define glListBase_INDEX 1193
#define glListBase_RETURN void
#define glListBase_ARG_NAMES base
#define glListBase_ARG_EXPAND GLuint base
#define glListBase_PACKED PACKED_glListBase
#define glListBase_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glListBase_NOT_VOID_WRAP(...) {}
#define pack_glListBase(_base) ({ \
    glListBase_PACKED *packed_data = malloc(sizeof(glListBase_PACKED)); \
    packed_data->index = glListBase_INDEX; \
    packed_data->args.base = (GLuint)_base; \
    (packed_call_t *)packed_data; \
})
#define call_glListBase(packed, ret_v) do { \
    PACKED_glListBase *unpacked = (PACKED_glListBase *)packed; \
    ARGS_glListBase *args = (ARGS_glListBase *)&unpacked->args; \
    glListBase(args->base);; \
} while(0)
void glListBase(glListBase_ARG_EXPAND);
typedef void (*glListBase_PTR)(glListBase_ARG_EXPAND);
#define glListParameterfSGIX_INDEX 1194
#define glListParameterfSGIX_RETURN void
#define glListParameterfSGIX_ARG_NAMES list, pname, param
#define glListParameterfSGIX_ARG_EXPAND GLuint list, GLenum pname, GLfloat param
#define glListParameterfSGIX_PACKED PACKED_glListParameterfSGIX
#define glListParameterfSGIX_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glListParameterfSGIX_NOT_VOID_WRAP(...) {}
#define pack_glListParameterfSGIX(_list, _pname, _param) ({ \
    glListParameterfSGIX_PACKED *packed_data = malloc(sizeof(glListParameterfSGIX_PACKED)); \
    packed_data->index = glListParameterfSGIX_INDEX; \
    packed_data->args.list = (GLuint)_list; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.param = (GLfloat)_param; \
    (packed_call_t *)packed_data; \
})
#define call_glListParameterfSGIX(packed, ret_v) do { \
    PACKED_glListParameterfSGIX *unpacked = (PACKED_glListParameterfSGIX *)packed; \
    ARGS_glListParameterfSGIX *args = (ARGS_glListParameterfSGIX *)&unpacked->args; \
    glListParameterfSGIX(args->list, args->pname, args->param);; \
} while(0)
void glListParameterfSGIX(glListParameterfSGIX_ARG_EXPAND);
typedef void (*glListParameterfSGIX_PTR)(glListParameterfSGIX_ARG_EXPAND);
#define glListParameterfvSGIX_INDEX 1195
#define glListParameterfvSGIX_RETURN void
#define glListParameterfvSGIX_ARG_NAMES list, pname, params
#define glListParameterfvSGIX_ARG_EXPAND GLuint list, GLenum pname, const GLfloat * params
#define glListParameterfvSGIX_PACKED PACKED_glListParameterfvSGIX
#define glListParameterfvSGIX_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glListParameterfvSGIX_NOT_VOID_WRAP(...) {}
#define pack_glListParameterfvSGIX(_list, _pname, _params) ({ \
    glListParameterfvSGIX_PACKED *packed_data = malloc(sizeof(glListParameterfvSGIX_PACKED)); \
    packed_data->index = glListParameterfvSGIX_INDEX; \
    packed_data->args.list = (GLuint)_list; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLfloat *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glListParameterfvSGIX(packed, ret_v) do { \
    PACKED_glListParameterfvSGIX *unpacked = (PACKED_glListParameterfvSGIX *)packed; \
    ARGS_glListParameterfvSGIX *args = (ARGS_glListParameterfvSGIX *)&unpacked->args; \
    glListParameterfvSGIX(args->list, args->pname, args->params);; \
} while(0)
void glListParameterfvSGIX(glListParameterfvSGIX_ARG_EXPAND);
typedef void (*glListParameterfvSGIX_PTR)(glListParameterfvSGIX_ARG_EXPAND);
#define glListParameteriSGIX_INDEX 1196
#define glListParameteriSGIX_RETURN void
#define glListParameteriSGIX_ARG_NAMES list, pname, param
#define glListParameteriSGIX_ARG_EXPAND GLuint list, GLenum pname, GLint param
#define glListParameteriSGIX_PACKED PACKED_glListParameteriSGIX
#define glListParameteriSGIX_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glListParameteriSGIX_NOT_VOID_WRAP(...) {}
#define pack_glListParameteriSGIX(_list, _pname, _param) ({ \
    glListParameteriSGIX_PACKED *packed_data = malloc(sizeof(glListParameteriSGIX_PACKED)); \
    packed_data->index = glListParameteriSGIX_INDEX; \
    packed_data->args.list = (GLuint)_list; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.param = (GLint)_param; \
    (packed_call_t *)packed_data; \
})
#define call_glListParameteriSGIX(packed, ret_v) do { \
    PACKED_glListParameteriSGIX *unpacked = (PACKED_glListParameteriSGIX *)packed; \
    ARGS_glListParameteriSGIX *args = (ARGS_glListParameteriSGIX *)&unpacked->args; \
    glListParameteriSGIX(args->list, args->pname, args->param);; \
} while(0)
void glListParameteriSGIX(glListParameteriSGIX_ARG_EXPAND);
typedef void (*glListParameteriSGIX_PTR)(glListParameteriSGIX_ARG_EXPAND);
#define glListParameterivSGIX_INDEX 1197
#define glListParameterivSGIX_RETURN void
#define glListParameterivSGIX_ARG_NAMES list, pname, params
#define glListParameterivSGIX_ARG_EXPAND GLuint list, GLenum pname, const GLint * params
#define glListParameterivSGIX_PACKED PACKED_glListParameterivSGIX
#define glListParameterivSGIX_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glListParameterivSGIX_NOT_VOID_WRAP(...) {}
#define pack_glListParameterivSGIX(_list, _pname, _params) ({ \
    glListParameterivSGIX_PACKED *packed_data = malloc(sizeof(glListParameterivSGIX_PACKED)); \
    packed_data->index = glListParameterivSGIX_INDEX; \
    packed_data->args.list = (GLuint)_list; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glListParameterivSGIX(packed, ret_v) do { \
    PACKED_glListParameterivSGIX *unpacked = (PACKED_glListParameterivSGIX *)packed; \
    ARGS_glListParameterivSGIX *args = (ARGS_glListParameterivSGIX *)&unpacked->args; \
    glListParameterivSGIX(args->list, args->pname, args->params);; \
} while(0)
void glListParameterivSGIX(glListParameterivSGIX_ARG_EXPAND);
typedef void (*glListParameterivSGIX_PTR)(glListParameterivSGIX_ARG_EXPAND);
#define glLoadIdentity_INDEX 1198
#define glLoadIdentity_RETURN void
#define glLoadIdentity_ARG_NAMES 
#define glLoadIdentity_ARG_EXPAND 
#define glLoadIdentity_PACKED PACKED_glLoadIdentity
#define glLoadIdentity_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glLoadIdentity_NOT_VOID_WRAP(...) {}
#define pack_glLoadIdentity() ({ \
    glLoadIdentity_PACKED *packed_data = malloc(sizeof(glLoadIdentity_PACKED)); \
    packed_data->index = glLoadIdentity_INDEX; \
    (packed_call_t *)packed_data; \
})
#define call_glLoadIdentity(packed, ret_v) do { \
    glLoadIdentity();; \
} while(0)
void glLoadIdentity(glLoadIdentity_ARG_EXPAND);
typedef void (*glLoadIdentity_PTR)(glLoadIdentity_ARG_EXPAND);
#define glLoadIdentityDeformationMapSGIX_INDEX 1199
#define glLoadIdentityDeformationMapSGIX_RETURN void
#define glLoadIdentityDeformationMapSGIX_ARG_NAMES mask
#define glLoadIdentityDeformationMapSGIX_ARG_EXPAND GLbitfield mask
#define glLoadIdentityDeformationMapSGIX_PACKED PACKED_glLoadIdentityDeformationMapSGIX
#define glLoadIdentityDeformationMapSGIX_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glLoadIdentityDeformationMapSGIX_NOT_VOID_WRAP(...) {}
#define pack_glLoadIdentityDeformationMapSGIX(_mask) ({ \
    glLoadIdentityDeformationMapSGIX_PACKED *packed_data = malloc(sizeof(glLoadIdentityDeformationMapSGIX_PACKED)); \
    packed_data->index = glLoadIdentityDeformationMapSGIX_INDEX; \
    packed_data->args.mask = (GLbitfield)_mask; \
    (packed_call_t *)packed_data; \
})
#define call_glLoadIdentityDeformationMapSGIX(packed, ret_v) do { \
    PACKED_glLoadIdentityDeformationMapSGIX *unpacked = (PACKED_glLoadIdentityDeformationMapSGIX *)packed; \
    ARGS_glLoadIdentityDeformationMapSGIX *args = (ARGS_glLoadIdentityDeformationMapSGIX *)&unpacked->args; \
    glLoadIdentityDeformationMapSGIX(args->mask);; \
} while(0)
void glLoadIdentityDeformationMapSGIX(glLoadIdentityDeformationMapSGIX_ARG_EXPAND);
typedef void (*glLoadIdentityDeformationMapSGIX_PTR)(glLoadIdentityDeformationMapSGIX_ARG_EXPAND);
#define glLoadMatrixd_INDEX 1200
#define glLoadMatrixd_RETURN void
#define glLoadMatrixd_ARG_NAMES m
#define glLoadMatrixd_ARG_EXPAND const GLdouble * m
#define glLoadMatrixd_PACKED PACKED_glLoadMatrixd
#define glLoadMatrixd_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glLoadMatrixd_NOT_VOID_WRAP(...) {}
#define pack_glLoadMatrixd(_m) ({ \
    glLoadMatrixd_PACKED *packed_data = malloc(sizeof(glLoadMatrixd_PACKED)); \
    packed_data->index = glLoadMatrixd_INDEX; \
    packed_data->args.m = (GLdouble *)_m; \
    (packed_call_t *)packed_data; \
})
#define call_glLoadMatrixd(packed, ret_v) do { \
    PACKED_glLoadMatrixd *unpacked = (PACKED_glLoadMatrixd *)packed; \
    ARGS_glLoadMatrixd *args = (ARGS_glLoadMatrixd *)&unpacked->args; \
    glLoadMatrixd(args->m);; \
} while(0)
void glLoadMatrixd(glLoadMatrixd_ARG_EXPAND);
typedef void (*glLoadMatrixd_PTR)(glLoadMatrixd_ARG_EXPAND);
#define glLoadMatrixf_INDEX 1201
#define glLoadMatrixf_RETURN void
#define glLoadMatrixf_ARG_NAMES m
#define glLoadMatrixf_ARG_EXPAND const GLfloat * m
#define glLoadMatrixf_PACKED PACKED_glLoadMatrixf
#define glLoadMatrixf_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glLoadMatrixf_NOT_VOID_WRAP(...) {}
#define pack_glLoadMatrixf(_m) ({ \
    glLoadMatrixf_PACKED *packed_data = malloc(sizeof(glLoadMatrixf_PACKED)); \
    packed_data->index = glLoadMatrixf_INDEX; \
    packed_data->args.m = (GLfloat *)_m; \
    (packed_call_t *)packed_data; \
})
#define call_glLoadMatrixf(packed, ret_v) do { \
    PACKED_glLoadMatrixf *unpacked = (PACKED_glLoadMatrixf *)packed; \
    ARGS_glLoadMatrixf *args = (ARGS_glLoadMatrixf *)&unpacked->args; \
    glLoadMatrixf(args->m);; \
} while(0)
void glLoadMatrixf(glLoadMatrixf_ARG_EXPAND);
typedef void (*glLoadMatrixf_PTR)(glLoadMatrixf_ARG_EXPAND);
#define glLoadMatrixx_INDEX 1202
#define glLoadMatrixx_RETURN void
#define glLoadMatrixx_ARG_NAMES m
#define glLoadMatrixx_ARG_EXPAND const GLfixed * m
#define glLoadMatrixx_PACKED PACKED_glLoadMatrixx
#define glLoadMatrixx_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glLoadMatrixx_NOT_VOID_WRAP(...) {}
#define pack_glLoadMatrixx(_m) ({ \
    glLoadMatrixx_PACKED *packed_data = malloc(sizeof(glLoadMatrixx_PACKED)); \
    packed_data->index = glLoadMatrixx_INDEX; \
    packed_data->args.m = (GLfixed *)_m; \
    (packed_call_t *)packed_data; \
})
#define call_glLoadMatrixx(packed, ret_v) do { \
    PACKED_glLoadMatrixx *unpacked = (PACKED_glLoadMatrixx *)packed; \
    ARGS_glLoadMatrixx *args = (ARGS_glLoadMatrixx *)&unpacked->args; \
    glLoadMatrixx(args->m);; \
} while(0)
void glLoadMatrixx(glLoadMatrixx_ARG_EXPAND);
typedef void (*glLoadMatrixx_PTR)(glLoadMatrixx_ARG_EXPAND);
#define glLoadMatrixxOES_INDEX 1203
#define glLoadMatrixxOES_RETURN void
#define glLoadMatrixxOES_ARG_NAMES m
#define glLoadMatrixxOES_ARG_EXPAND const GLfixed * m
#define glLoadMatrixxOES_PACKED PACKED_glLoadMatrixxOES
#define glLoadMatrixxOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glLoadMatrixxOES_NOT_VOID_WRAP(...) {}
#define pack_glLoadMatrixxOES(_m) ({ \
    glLoadMatrixxOES_PACKED *packed_data = malloc(sizeof(glLoadMatrixxOES_PACKED)); \
    packed_data->index = glLoadMatrixxOES_INDEX; \
    packed_data->args.m = (GLfixed *)_m; \
    (packed_call_t *)packed_data; \
})
#define call_glLoadMatrixxOES(packed, ret_v) do { \
    PACKED_glLoadMatrixxOES *unpacked = (PACKED_glLoadMatrixxOES *)packed; \
    ARGS_glLoadMatrixxOES *args = (ARGS_glLoadMatrixxOES *)&unpacked->args; \
    glLoadMatrixxOES(args->m);; \
} while(0)
void glLoadMatrixxOES(glLoadMatrixxOES_ARG_EXPAND);
typedef void (*glLoadMatrixxOES_PTR)(glLoadMatrixxOES_ARG_EXPAND);
#define glLoadName_INDEX 1204
#define glLoadName_RETURN void
#define glLoadName_ARG_NAMES name
#define glLoadName_ARG_EXPAND GLuint name
#define glLoadName_PACKED PACKED_glLoadName
#define glLoadName_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glLoadName_NOT_VOID_WRAP(...) {}
#define pack_glLoadName(_name) ({ \
    glLoadName_PACKED *packed_data = malloc(sizeof(glLoadName_PACKED)); \
    packed_data->index = glLoadName_INDEX; \
    packed_data->args.name = (GLuint)_name; \
    (packed_call_t *)packed_data; \
})
#define call_glLoadName(packed, ret_v) do { \
    PACKED_glLoadName *unpacked = (PACKED_glLoadName *)packed; \
    ARGS_glLoadName *args = (ARGS_glLoadName *)&unpacked->args; \
    glLoadName(args->name);; \
} while(0)
void glLoadName(glLoadName_ARG_EXPAND);
typedef void (*glLoadName_PTR)(glLoadName_ARG_EXPAND);
#define glLoadProgramNV_INDEX 1205
#define glLoadProgramNV_RETURN void
#define glLoadProgramNV_ARG_NAMES target, id, len, program
#define glLoadProgramNV_ARG_EXPAND GLenum target, GLuint id, GLsizei len, const GLubyte * program
#define glLoadProgramNV_PACKED PACKED_glLoadProgramNV
#define glLoadProgramNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glLoadProgramNV_NOT_VOID_WRAP(...) {}
#define pack_glLoadProgramNV(_target, _id, _len, _program) ({ \
    glLoadProgramNV_PACKED *packed_data = malloc(sizeof(glLoadProgramNV_PACKED)); \
    packed_data->index = glLoadProgramNV_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.id = (GLuint)_id; \
    packed_data->args.len = (GLsizei)_len; \
    packed_data->args.program = (GLubyte *)_program; \
    (packed_call_t *)packed_data; \
})
#define call_glLoadProgramNV(packed, ret_v) do { \
    PACKED_glLoadProgramNV *unpacked = (PACKED_glLoadProgramNV *)packed; \
    ARGS_glLoadProgramNV *args = (ARGS_glLoadProgramNV *)&unpacked->args; \
    glLoadProgramNV(args->target, args->id, args->len, args->program);; \
} while(0)
void glLoadProgramNV(glLoadProgramNV_ARG_EXPAND);
typedef void (*glLoadProgramNV_PTR)(glLoadProgramNV_ARG_EXPAND);
#define glLoadTransposeMatrixd_INDEX 1206
#define glLoadTransposeMatrixd_RETURN void
#define glLoadTransposeMatrixd_ARG_NAMES m
#define glLoadTransposeMatrixd_ARG_EXPAND const GLdouble * m
#define glLoadTransposeMatrixd_PACKED PACKED_glLoadTransposeMatrixd
#define glLoadTransposeMatrixd_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glLoadTransposeMatrixd_NOT_VOID_WRAP(...) {}
#define pack_glLoadTransposeMatrixd(_m) ({ \
    glLoadTransposeMatrixd_PACKED *packed_data = malloc(sizeof(glLoadTransposeMatrixd_PACKED)); \
    packed_data->index = glLoadTransposeMatrixd_INDEX; \
    packed_data->args.m = (GLdouble *)_m; \
    (packed_call_t *)packed_data; \
})
#define call_glLoadTransposeMatrixd(packed, ret_v) do { \
    PACKED_glLoadTransposeMatrixd *unpacked = (PACKED_glLoadTransposeMatrixd *)packed; \
    ARGS_glLoadTransposeMatrixd *args = (ARGS_glLoadTransposeMatrixd *)&unpacked->args; \
    glLoadTransposeMatrixd(args->m);; \
} while(0)
void glLoadTransposeMatrixd(glLoadTransposeMatrixd_ARG_EXPAND);
typedef void (*glLoadTransposeMatrixd_PTR)(glLoadTransposeMatrixd_ARG_EXPAND);
#define glLoadTransposeMatrixdARB_INDEX 1207
#define glLoadTransposeMatrixdARB_RETURN void
#define glLoadTransposeMatrixdARB_ARG_NAMES m
#define glLoadTransposeMatrixdARB_ARG_EXPAND const GLdouble * m
#define glLoadTransposeMatrixdARB_PACKED PACKED_glLoadTransposeMatrixdARB
#define glLoadTransposeMatrixdARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glLoadTransposeMatrixdARB_NOT_VOID_WRAP(...) {}
#define pack_glLoadTransposeMatrixdARB(_m) ({ \
    glLoadTransposeMatrixdARB_PACKED *packed_data = malloc(sizeof(glLoadTransposeMatrixdARB_PACKED)); \
    packed_data->index = glLoadTransposeMatrixdARB_INDEX; \
    packed_data->args.m = (GLdouble *)_m; \
    (packed_call_t *)packed_data; \
})
#define call_glLoadTransposeMatrixdARB(packed, ret_v) do { \
    PACKED_glLoadTransposeMatrixdARB *unpacked = (PACKED_glLoadTransposeMatrixdARB *)packed; \
    ARGS_glLoadTransposeMatrixdARB *args = (ARGS_glLoadTransposeMatrixdARB *)&unpacked->args; \
    glLoadTransposeMatrixdARB(args->m);; \
} while(0)
void glLoadTransposeMatrixdARB(glLoadTransposeMatrixdARB_ARG_EXPAND);
typedef void (*glLoadTransposeMatrixdARB_PTR)(glLoadTransposeMatrixdARB_ARG_EXPAND);
#define glLoadTransposeMatrixf_INDEX 1208
#define glLoadTransposeMatrixf_RETURN void
#define glLoadTransposeMatrixf_ARG_NAMES m
#define glLoadTransposeMatrixf_ARG_EXPAND const GLfloat * m
#define glLoadTransposeMatrixf_PACKED PACKED_glLoadTransposeMatrixf
#define glLoadTransposeMatrixf_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glLoadTransposeMatrixf_NOT_VOID_WRAP(...) {}
#define pack_glLoadTransposeMatrixf(_m) ({ \
    glLoadTransposeMatrixf_PACKED *packed_data = malloc(sizeof(glLoadTransposeMatrixf_PACKED)); \
    packed_data->index = glLoadTransposeMatrixf_INDEX; \
    packed_data->args.m = (GLfloat *)_m; \
    (packed_call_t *)packed_data; \
})
#define call_glLoadTransposeMatrixf(packed, ret_v) do { \
    PACKED_glLoadTransposeMatrixf *unpacked = (PACKED_glLoadTransposeMatrixf *)packed; \
    ARGS_glLoadTransposeMatrixf *args = (ARGS_glLoadTransposeMatrixf *)&unpacked->args; \
    glLoadTransposeMatrixf(args->m);; \
} while(0)
void glLoadTransposeMatrixf(glLoadTransposeMatrixf_ARG_EXPAND);
typedef void (*glLoadTransposeMatrixf_PTR)(glLoadTransposeMatrixf_ARG_EXPAND);
#define glLoadTransposeMatrixfARB_INDEX 1209
#define glLoadTransposeMatrixfARB_RETURN void
#define glLoadTransposeMatrixfARB_ARG_NAMES m
#define glLoadTransposeMatrixfARB_ARG_EXPAND const GLfloat * m
#define glLoadTransposeMatrixfARB_PACKED PACKED_glLoadTransposeMatrixfARB
#define glLoadTransposeMatrixfARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glLoadTransposeMatrixfARB_NOT_VOID_WRAP(...) {}
#define pack_glLoadTransposeMatrixfARB(_m) ({ \
    glLoadTransposeMatrixfARB_PACKED *packed_data = malloc(sizeof(glLoadTransposeMatrixfARB_PACKED)); \
    packed_data->index = glLoadTransposeMatrixfARB_INDEX; \
    packed_data->args.m = (GLfloat *)_m; \
    (packed_call_t *)packed_data; \
})
#define call_glLoadTransposeMatrixfARB(packed, ret_v) do { \
    PACKED_glLoadTransposeMatrixfARB *unpacked = (PACKED_glLoadTransposeMatrixfARB *)packed; \
    ARGS_glLoadTransposeMatrixfARB *args = (ARGS_glLoadTransposeMatrixfARB *)&unpacked->args; \
    glLoadTransposeMatrixfARB(args->m);; \
} while(0)
void glLoadTransposeMatrixfARB(glLoadTransposeMatrixfARB_ARG_EXPAND);
typedef void (*glLoadTransposeMatrixfARB_PTR)(glLoadTransposeMatrixfARB_ARG_EXPAND);
#define glLoadTransposeMatrixxOES_INDEX 1210
#define glLoadTransposeMatrixxOES_RETURN void
#define glLoadTransposeMatrixxOES_ARG_NAMES m
#define glLoadTransposeMatrixxOES_ARG_EXPAND const GLfixed * m
#define glLoadTransposeMatrixxOES_PACKED PACKED_glLoadTransposeMatrixxOES
#define glLoadTransposeMatrixxOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glLoadTransposeMatrixxOES_NOT_VOID_WRAP(...) {}
#define pack_glLoadTransposeMatrixxOES(_m) ({ \
    glLoadTransposeMatrixxOES_PACKED *packed_data = malloc(sizeof(glLoadTransposeMatrixxOES_PACKED)); \
    packed_data->index = glLoadTransposeMatrixxOES_INDEX; \
    packed_data->args.m = (GLfixed *)_m; \
    (packed_call_t *)packed_data; \
})
#define call_glLoadTransposeMatrixxOES(packed, ret_v) do { \
    PACKED_glLoadTransposeMatrixxOES *unpacked = (PACKED_glLoadTransposeMatrixxOES *)packed; \
    ARGS_glLoadTransposeMatrixxOES *args = (ARGS_glLoadTransposeMatrixxOES *)&unpacked->args; \
    glLoadTransposeMatrixxOES(args->m);; \
} while(0)
void glLoadTransposeMatrixxOES(glLoadTransposeMatrixxOES_ARG_EXPAND);
typedef void (*glLoadTransposeMatrixxOES_PTR)(glLoadTransposeMatrixxOES_ARG_EXPAND);
#define glLockArraysEXT_INDEX 1211
#define glLockArraysEXT_RETURN void
#define glLockArraysEXT_ARG_NAMES first, count
#define glLockArraysEXT_ARG_EXPAND GLint first, GLsizei count
#define glLockArraysEXT_PACKED PACKED_glLockArraysEXT
#define glLockArraysEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glLockArraysEXT_NOT_VOID_WRAP(...) {}
#define pack_glLockArraysEXT(_first, _count) ({ \
    glLockArraysEXT_PACKED *packed_data = malloc(sizeof(glLockArraysEXT_PACKED)); \
    packed_data->index = glLockArraysEXT_INDEX; \
    packed_data->args.first = (GLint)_first; \
    packed_data->args.count = (GLsizei)_count; \
    (packed_call_t *)packed_data; \
})
#define call_glLockArraysEXT(packed, ret_v) do { \
    PACKED_glLockArraysEXT *unpacked = (PACKED_glLockArraysEXT *)packed; \
    ARGS_glLockArraysEXT *args = (ARGS_glLockArraysEXT *)&unpacked->args; \
    glLockArraysEXT(args->first, args->count);; \
} while(0)
void glLockArraysEXT(glLockArraysEXT_ARG_EXPAND);
typedef void (*glLockArraysEXT_PTR)(glLockArraysEXT_ARG_EXPAND);
#define glLogicOp_INDEX 1212
#define glLogicOp_RETURN void
#define glLogicOp_ARG_NAMES opcode
#define glLogicOp_ARG_EXPAND GLenum opcode
#define glLogicOp_PACKED PACKED_glLogicOp
#define glLogicOp_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glLogicOp_NOT_VOID_WRAP(...) {}
#define pack_glLogicOp(_opcode) ({ \
    glLogicOp_PACKED *packed_data = malloc(sizeof(glLogicOp_PACKED)); \
    packed_data->index = glLogicOp_INDEX; \
    packed_data->args.opcode = (GLenum)_opcode; \
    (packed_call_t *)packed_data; \
})
#define call_glLogicOp(packed, ret_v) do { \
    PACKED_glLogicOp *unpacked = (PACKED_glLogicOp *)packed; \
    ARGS_glLogicOp *args = (ARGS_glLogicOp *)&unpacked->args; \
    glLogicOp(args->opcode);; \
} while(0)
void glLogicOp(glLogicOp_ARG_EXPAND);
typedef void (*glLogicOp_PTR)(glLogicOp_ARG_EXPAND);
#define glMakeBufferNonResidentNV_INDEX 1213
#define glMakeBufferNonResidentNV_RETURN void
#define glMakeBufferNonResidentNV_ARG_NAMES target
#define glMakeBufferNonResidentNV_ARG_EXPAND GLenum target
#define glMakeBufferNonResidentNV_PACKED PACKED_glMakeBufferNonResidentNV
#define glMakeBufferNonResidentNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMakeBufferNonResidentNV_NOT_VOID_WRAP(...) {}
#define pack_glMakeBufferNonResidentNV(_target) ({ \
    glMakeBufferNonResidentNV_PACKED *packed_data = malloc(sizeof(glMakeBufferNonResidentNV_PACKED)); \
    packed_data->index = glMakeBufferNonResidentNV_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    (packed_call_t *)packed_data; \
})
#define call_glMakeBufferNonResidentNV(packed, ret_v) do { \
    PACKED_glMakeBufferNonResidentNV *unpacked = (PACKED_glMakeBufferNonResidentNV *)packed; \
    ARGS_glMakeBufferNonResidentNV *args = (ARGS_glMakeBufferNonResidentNV *)&unpacked->args; \
    glMakeBufferNonResidentNV(args->target);; \
} while(0)
void glMakeBufferNonResidentNV(glMakeBufferNonResidentNV_ARG_EXPAND);
typedef void (*glMakeBufferNonResidentNV_PTR)(glMakeBufferNonResidentNV_ARG_EXPAND);
#define glMakeBufferResidentNV_INDEX 1214
#define glMakeBufferResidentNV_RETURN void
#define glMakeBufferResidentNV_ARG_NAMES target, access
#define glMakeBufferResidentNV_ARG_EXPAND GLenum target, GLenum access
#define glMakeBufferResidentNV_PACKED PACKED_glMakeBufferResidentNV
#define glMakeBufferResidentNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMakeBufferResidentNV_NOT_VOID_WRAP(...) {}
#define pack_glMakeBufferResidentNV(_target, _access) ({ \
    glMakeBufferResidentNV_PACKED *packed_data = malloc(sizeof(glMakeBufferResidentNV_PACKED)); \
    packed_data->index = glMakeBufferResidentNV_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.access = (GLenum)_access; \
    (packed_call_t *)packed_data; \
})
#define call_glMakeBufferResidentNV(packed, ret_v) do { \
    PACKED_glMakeBufferResidentNV *unpacked = (PACKED_glMakeBufferResidentNV *)packed; \
    ARGS_glMakeBufferResidentNV *args = (ARGS_glMakeBufferResidentNV *)&unpacked->args; \
    glMakeBufferResidentNV(args->target, args->access);; \
} while(0)
void glMakeBufferResidentNV(glMakeBufferResidentNV_ARG_EXPAND);
typedef void (*glMakeBufferResidentNV_PTR)(glMakeBufferResidentNV_ARG_EXPAND);
#define glMakeImageHandleNonResidentNV_INDEX 1215
#define glMakeImageHandleNonResidentNV_RETURN void
#define glMakeImageHandleNonResidentNV_ARG_NAMES handle
#define glMakeImageHandleNonResidentNV_ARG_EXPAND GLuint64 handle
#define glMakeImageHandleNonResidentNV_PACKED PACKED_glMakeImageHandleNonResidentNV
#define glMakeImageHandleNonResidentNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMakeImageHandleNonResidentNV_NOT_VOID_WRAP(...) {}
#define pack_glMakeImageHandleNonResidentNV(_handle) ({ \
    glMakeImageHandleNonResidentNV_PACKED *packed_data = malloc(sizeof(glMakeImageHandleNonResidentNV_PACKED)); \
    packed_data->index = glMakeImageHandleNonResidentNV_INDEX; \
    packed_data->args.handle = (GLuint64)_handle; \
    (packed_call_t *)packed_data; \
})
#define call_glMakeImageHandleNonResidentNV(packed, ret_v) do { \
    PACKED_glMakeImageHandleNonResidentNV *unpacked = (PACKED_glMakeImageHandleNonResidentNV *)packed; \
    ARGS_glMakeImageHandleNonResidentNV *args = (ARGS_glMakeImageHandleNonResidentNV *)&unpacked->args; \
    glMakeImageHandleNonResidentNV(args->handle);; \
} while(0)
void glMakeImageHandleNonResidentNV(glMakeImageHandleNonResidentNV_ARG_EXPAND);
typedef void (*glMakeImageHandleNonResidentNV_PTR)(glMakeImageHandleNonResidentNV_ARG_EXPAND);
#define glMakeImageHandleResidentNV_INDEX 1216
#define glMakeImageHandleResidentNV_RETURN void
#define glMakeImageHandleResidentNV_ARG_NAMES handle, access
#define glMakeImageHandleResidentNV_ARG_EXPAND GLuint64 handle, GLenum access
#define glMakeImageHandleResidentNV_PACKED PACKED_glMakeImageHandleResidentNV
#define glMakeImageHandleResidentNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMakeImageHandleResidentNV_NOT_VOID_WRAP(...) {}
#define pack_glMakeImageHandleResidentNV(_handle, _access) ({ \
    glMakeImageHandleResidentNV_PACKED *packed_data = malloc(sizeof(glMakeImageHandleResidentNV_PACKED)); \
    packed_data->index = glMakeImageHandleResidentNV_INDEX; \
    packed_data->args.handle = (GLuint64)_handle; \
    packed_data->args.access = (GLenum)_access; \
    (packed_call_t *)packed_data; \
})
#define call_glMakeImageHandleResidentNV(packed, ret_v) do { \
    PACKED_glMakeImageHandleResidentNV *unpacked = (PACKED_glMakeImageHandleResidentNV *)packed; \
    ARGS_glMakeImageHandleResidentNV *args = (ARGS_glMakeImageHandleResidentNV *)&unpacked->args; \
    glMakeImageHandleResidentNV(args->handle, args->access);; \
} while(0)
void glMakeImageHandleResidentNV(glMakeImageHandleResidentNV_ARG_EXPAND);
typedef void (*glMakeImageHandleResidentNV_PTR)(glMakeImageHandleResidentNV_ARG_EXPAND);
#define glMakeNamedBufferNonResidentNV_INDEX 1217
#define glMakeNamedBufferNonResidentNV_RETURN void
#define glMakeNamedBufferNonResidentNV_ARG_NAMES buffer
#define glMakeNamedBufferNonResidentNV_ARG_EXPAND GLuint buffer
#define glMakeNamedBufferNonResidentNV_PACKED PACKED_glMakeNamedBufferNonResidentNV
#define glMakeNamedBufferNonResidentNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMakeNamedBufferNonResidentNV_NOT_VOID_WRAP(...) {}
#define pack_glMakeNamedBufferNonResidentNV(_buffer) ({ \
    glMakeNamedBufferNonResidentNV_PACKED *packed_data = malloc(sizeof(glMakeNamedBufferNonResidentNV_PACKED)); \
    packed_data->index = glMakeNamedBufferNonResidentNV_INDEX; \
    packed_data->args.buffer = (GLuint)_buffer; \
    (packed_call_t *)packed_data; \
})
#define call_glMakeNamedBufferNonResidentNV(packed, ret_v) do { \
    PACKED_glMakeNamedBufferNonResidentNV *unpacked = (PACKED_glMakeNamedBufferNonResidentNV *)packed; \
    ARGS_glMakeNamedBufferNonResidentNV *args = (ARGS_glMakeNamedBufferNonResidentNV *)&unpacked->args; \
    glMakeNamedBufferNonResidentNV(args->buffer);; \
} while(0)
void glMakeNamedBufferNonResidentNV(glMakeNamedBufferNonResidentNV_ARG_EXPAND);
typedef void (*glMakeNamedBufferNonResidentNV_PTR)(glMakeNamedBufferNonResidentNV_ARG_EXPAND);
#define glMakeNamedBufferResidentNV_INDEX 1218
#define glMakeNamedBufferResidentNV_RETURN void
#define glMakeNamedBufferResidentNV_ARG_NAMES buffer, access
#define glMakeNamedBufferResidentNV_ARG_EXPAND GLuint buffer, GLenum access
#define glMakeNamedBufferResidentNV_PACKED PACKED_glMakeNamedBufferResidentNV
#define glMakeNamedBufferResidentNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMakeNamedBufferResidentNV_NOT_VOID_WRAP(...) {}
#define pack_glMakeNamedBufferResidentNV(_buffer, _access) ({ \
    glMakeNamedBufferResidentNV_PACKED *packed_data = malloc(sizeof(glMakeNamedBufferResidentNV_PACKED)); \
    packed_data->index = glMakeNamedBufferResidentNV_INDEX; \
    packed_data->args.buffer = (GLuint)_buffer; \
    packed_data->args.access = (GLenum)_access; \
    (packed_call_t *)packed_data; \
})
#define call_glMakeNamedBufferResidentNV(packed, ret_v) do { \
    PACKED_glMakeNamedBufferResidentNV *unpacked = (PACKED_glMakeNamedBufferResidentNV *)packed; \
    ARGS_glMakeNamedBufferResidentNV *args = (ARGS_glMakeNamedBufferResidentNV *)&unpacked->args; \
    glMakeNamedBufferResidentNV(args->buffer, args->access);; \
} while(0)
void glMakeNamedBufferResidentNV(glMakeNamedBufferResidentNV_ARG_EXPAND);
typedef void (*glMakeNamedBufferResidentNV_PTR)(glMakeNamedBufferResidentNV_ARG_EXPAND);
#define glMakeTextureHandleNonResidentNV_INDEX 1219
#define glMakeTextureHandleNonResidentNV_RETURN void
#define glMakeTextureHandleNonResidentNV_ARG_NAMES handle
#define glMakeTextureHandleNonResidentNV_ARG_EXPAND GLuint64 handle
#define glMakeTextureHandleNonResidentNV_PACKED PACKED_glMakeTextureHandleNonResidentNV
#define glMakeTextureHandleNonResidentNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMakeTextureHandleNonResidentNV_NOT_VOID_WRAP(...) {}
#define pack_glMakeTextureHandleNonResidentNV(_handle) ({ \
    glMakeTextureHandleNonResidentNV_PACKED *packed_data = malloc(sizeof(glMakeTextureHandleNonResidentNV_PACKED)); \
    packed_data->index = glMakeTextureHandleNonResidentNV_INDEX; \
    packed_data->args.handle = (GLuint64)_handle; \
    (packed_call_t *)packed_data; \
})
#define call_glMakeTextureHandleNonResidentNV(packed, ret_v) do { \
    PACKED_glMakeTextureHandleNonResidentNV *unpacked = (PACKED_glMakeTextureHandleNonResidentNV *)packed; \
    ARGS_glMakeTextureHandleNonResidentNV *args = (ARGS_glMakeTextureHandleNonResidentNV *)&unpacked->args; \
    glMakeTextureHandleNonResidentNV(args->handle);; \
} while(0)
void glMakeTextureHandleNonResidentNV(glMakeTextureHandleNonResidentNV_ARG_EXPAND);
typedef void (*glMakeTextureHandleNonResidentNV_PTR)(glMakeTextureHandleNonResidentNV_ARG_EXPAND);
#define glMakeTextureHandleResidentNV_INDEX 1220
#define glMakeTextureHandleResidentNV_RETURN void
#define glMakeTextureHandleResidentNV_ARG_NAMES handle
#define glMakeTextureHandleResidentNV_ARG_EXPAND GLuint64 handle
#define glMakeTextureHandleResidentNV_PACKED PACKED_glMakeTextureHandleResidentNV
#define glMakeTextureHandleResidentNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMakeTextureHandleResidentNV_NOT_VOID_WRAP(...) {}
#define pack_glMakeTextureHandleResidentNV(_handle) ({ \
    glMakeTextureHandleResidentNV_PACKED *packed_data = malloc(sizeof(glMakeTextureHandleResidentNV_PACKED)); \
    packed_data->index = glMakeTextureHandleResidentNV_INDEX; \
    packed_data->args.handle = (GLuint64)_handle; \
    (packed_call_t *)packed_data; \
})
#define call_glMakeTextureHandleResidentNV(packed, ret_v) do { \
    PACKED_glMakeTextureHandleResidentNV *unpacked = (PACKED_glMakeTextureHandleResidentNV *)packed; \
    ARGS_glMakeTextureHandleResidentNV *args = (ARGS_glMakeTextureHandleResidentNV *)&unpacked->args; \
    glMakeTextureHandleResidentNV(args->handle);; \
} while(0)
void glMakeTextureHandleResidentNV(glMakeTextureHandleResidentNV_ARG_EXPAND);
typedef void (*glMakeTextureHandleResidentNV_PTR)(glMakeTextureHandleResidentNV_ARG_EXPAND);
#define glMap1d_INDEX 1221
#define glMap1d_RETURN void
#define glMap1d_ARG_NAMES target, u1, u2, stride, order, points
#define glMap1d_ARG_EXPAND GLenum target, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble * points
#define glMap1d_PACKED PACKED_glMap1d
#define glMap1d_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMap1d_NOT_VOID_WRAP(...) {}
#define pack_glMap1d(_target, _u1, _u2, _stride, _order, _points) ({ \
    glMap1d_PACKED *packed_data = malloc(sizeof(glMap1d_PACKED)); \
    packed_data->index = glMap1d_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.u1 = (GLdouble)_u1; \
    packed_data->args.u2 = (GLdouble)_u2; \
    packed_data->args.stride = (GLint)_stride; \
    packed_data->args.order = (GLint)_order; \
    packed_data->args.points = (GLdouble *)_points; \
    (packed_call_t *)packed_data; \
})
#define call_glMap1d(packed, ret_v) do { \
    PACKED_glMap1d *unpacked = (PACKED_glMap1d *)packed; \
    ARGS_glMap1d *args = (ARGS_glMap1d *)&unpacked->args; \
    glMap1d(args->target, args->u1, args->u2, args->stride, args->order, args->points);; \
} while(0)
void glMap1d(glMap1d_ARG_EXPAND);
typedef void (*glMap1d_PTR)(glMap1d_ARG_EXPAND);
#define glMap1f_INDEX 1222
#define glMap1f_RETURN void
#define glMap1f_ARG_NAMES target, u1, u2, stride, order, points
#define glMap1f_ARG_EXPAND GLenum target, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat * points
#define glMap1f_PACKED PACKED_glMap1f
#define glMap1f_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMap1f_NOT_VOID_WRAP(...) {}
#define pack_glMap1f(_target, _u1, _u2, _stride, _order, _points) ({ \
    glMap1f_PACKED *packed_data = malloc(sizeof(glMap1f_PACKED)); \
    packed_data->index = glMap1f_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.u1 = (GLfloat)_u1; \
    packed_data->args.u2 = (GLfloat)_u2; \
    packed_data->args.stride = (GLint)_stride; \
    packed_data->args.order = (GLint)_order; \
    packed_data->args.points = (GLfloat *)_points; \
    (packed_call_t *)packed_data; \
})
#define call_glMap1f(packed, ret_v) do { \
    PACKED_glMap1f *unpacked = (PACKED_glMap1f *)packed; \
    ARGS_glMap1f *args = (ARGS_glMap1f *)&unpacked->args; \
    glMap1f(args->target, args->u1, args->u2, args->stride, args->order, args->points);; \
} while(0)
void glMap1f(glMap1f_ARG_EXPAND);
typedef void (*glMap1f_PTR)(glMap1f_ARG_EXPAND);
#define glMap1xOES_INDEX 1223
#define glMap1xOES_RETURN void
#define glMap1xOES_ARG_NAMES target, u1, u2, stride, order, points
#define glMap1xOES_ARG_EXPAND GLenum target, GLfixed u1, GLfixed u2, GLint stride, GLint order, GLfixed points
#define glMap1xOES_PACKED PACKED_glMap1xOES
#define glMap1xOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMap1xOES_NOT_VOID_WRAP(...) {}
#define pack_glMap1xOES(_target, _u1, _u2, _stride, _order, _points) ({ \
    glMap1xOES_PACKED *packed_data = malloc(sizeof(glMap1xOES_PACKED)); \
    packed_data->index = glMap1xOES_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.u1 = (GLfixed)_u1; \
    packed_data->args.u2 = (GLfixed)_u2; \
    packed_data->args.stride = (GLint)_stride; \
    packed_data->args.order = (GLint)_order; \
    packed_data->args.points = (GLfixed)_points; \
    (packed_call_t *)packed_data; \
})
#define call_glMap1xOES(packed, ret_v) do { \
    PACKED_glMap1xOES *unpacked = (PACKED_glMap1xOES *)packed; \
    ARGS_glMap1xOES *args = (ARGS_glMap1xOES *)&unpacked->args; \
    glMap1xOES(args->target, args->u1, args->u2, args->stride, args->order, args->points);; \
} while(0)
void glMap1xOES(glMap1xOES_ARG_EXPAND);
typedef void (*glMap1xOES_PTR)(glMap1xOES_ARG_EXPAND);
#define glMap2d_INDEX 1224
#define glMap2d_RETURN void
#define glMap2d_ARG_NAMES target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points
#define glMap2d_ARG_EXPAND GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble * points
#define glMap2d_PACKED PACKED_glMap2d
#define glMap2d_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMap2d_NOT_VOID_WRAP(...) {}
#define pack_glMap2d(_target, _u1, _u2, _ustride, _uorder, _v1, _v2, _vstride, _vorder, _points) ({ \
    glMap2d_PACKED *packed_data = malloc(sizeof(glMap2d_PACKED)); \
    packed_data->index = glMap2d_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.u1 = (GLdouble)_u1; \
    packed_data->args.u2 = (GLdouble)_u2; \
    packed_data->args.ustride = (GLint)_ustride; \
    packed_data->args.uorder = (GLint)_uorder; \
    packed_data->args.v1 = (GLdouble)_v1; \
    packed_data->args.v2 = (GLdouble)_v2; \
    packed_data->args.vstride = (GLint)_vstride; \
    packed_data->args.vorder = (GLint)_vorder; \
    packed_data->args.points = (GLdouble *)_points; \
    (packed_call_t *)packed_data; \
})
#define call_glMap2d(packed, ret_v) do { \
    PACKED_glMap2d *unpacked = (PACKED_glMap2d *)packed; \
    ARGS_glMap2d *args = (ARGS_glMap2d *)&unpacked->args; \
    glMap2d(args->target, args->u1, args->u2, args->ustride, args->uorder, args->v1, args->v2, args->vstride, args->vorder, args->points);; \
} while(0)
void glMap2d(glMap2d_ARG_EXPAND);
typedef void (*glMap2d_PTR)(glMap2d_ARG_EXPAND);
#define glMap2f_INDEX 1225
#define glMap2f_RETURN void
#define glMap2f_ARG_NAMES target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points
#define glMap2f_ARG_EXPAND GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat * points
#define glMap2f_PACKED PACKED_glMap2f
#define glMap2f_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMap2f_NOT_VOID_WRAP(...) {}
#define pack_glMap2f(_target, _u1, _u2, _ustride, _uorder, _v1, _v2, _vstride, _vorder, _points) ({ \
    glMap2f_PACKED *packed_data = malloc(sizeof(glMap2f_PACKED)); \
    packed_data->index = glMap2f_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.u1 = (GLfloat)_u1; \
    packed_data->args.u2 = (GLfloat)_u2; \
    packed_data->args.ustride = (GLint)_ustride; \
    packed_data->args.uorder = (GLint)_uorder; \
    packed_data->args.v1 = (GLfloat)_v1; \
    packed_data->args.v2 = (GLfloat)_v2; \
    packed_data->args.vstride = (GLint)_vstride; \
    packed_data->args.vorder = (GLint)_vorder; \
    packed_data->args.points = (GLfloat *)_points; \
    (packed_call_t *)packed_data; \
})
#define call_glMap2f(packed, ret_v) do { \
    PACKED_glMap2f *unpacked = (PACKED_glMap2f *)packed; \
    ARGS_glMap2f *args = (ARGS_glMap2f *)&unpacked->args; \
    glMap2f(args->target, args->u1, args->u2, args->ustride, args->uorder, args->v1, args->v2, args->vstride, args->vorder, args->points);; \
} while(0)
void glMap2f(glMap2f_ARG_EXPAND);
typedef void (*glMap2f_PTR)(glMap2f_ARG_EXPAND);
#define glMap2xOES_INDEX 1226
#define glMap2xOES_RETURN void
#define glMap2xOES_ARG_NAMES target, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points
#define glMap2xOES_ARG_EXPAND GLenum target, GLfixed u1, GLfixed u2, GLint ustride, GLint uorder, GLfixed v1, GLfixed v2, GLint vstride, GLint vorder, GLfixed points
#define glMap2xOES_PACKED PACKED_glMap2xOES
#define glMap2xOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMap2xOES_NOT_VOID_WRAP(...) {}
#define pack_glMap2xOES(_target, _u1, _u2, _ustride, _uorder, _v1, _v2, _vstride, _vorder, _points) ({ \
    glMap2xOES_PACKED *packed_data = malloc(sizeof(glMap2xOES_PACKED)); \
    packed_data->index = glMap2xOES_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.u1 = (GLfixed)_u1; \
    packed_data->args.u2 = (GLfixed)_u2; \
    packed_data->args.ustride = (GLint)_ustride; \
    packed_data->args.uorder = (GLint)_uorder; \
    packed_data->args.v1 = (GLfixed)_v1; \
    packed_data->args.v2 = (GLfixed)_v2; \
    packed_data->args.vstride = (GLint)_vstride; \
    packed_data->args.vorder = (GLint)_vorder; \
    packed_data->args.points = (GLfixed)_points; \
    (packed_call_t *)packed_data; \
})
#define call_glMap2xOES(packed, ret_v) do { \
    PACKED_glMap2xOES *unpacked = (PACKED_glMap2xOES *)packed; \
    ARGS_glMap2xOES *args = (ARGS_glMap2xOES *)&unpacked->args; \
    glMap2xOES(args->target, args->u1, args->u2, args->ustride, args->uorder, args->v1, args->v2, args->vstride, args->vorder, args->points);; \
} while(0)
void glMap2xOES(glMap2xOES_ARG_EXPAND);
typedef void (*glMap2xOES_PTR)(glMap2xOES_ARG_EXPAND);
#define glMapBuffer_INDEX 1227
#define glMapBuffer_RETURN GLvoid *
#define glMapBuffer_ARG_NAMES target, access
#define glMapBuffer_ARG_EXPAND GLenum target, GLenum access
#define glMapBuffer_PACKED PACKED_glMapBuffer
#define glMapBuffer_VOID_ONLY_WRAP(...) {}
#define glMapBuffer_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glMapBuffer(_target, _access) ({ \
    glMapBuffer_PACKED *packed_data = malloc(sizeof(glMapBuffer_PACKED)); \
    packed_data->index = glMapBuffer_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.access = (GLenum)_access; \
    (packed_call_t *)packed_data; \
})
#define call_glMapBuffer(packed, ret_v) do { \
    PACKED_glMapBuffer *unpacked = (PACKED_glMapBuffer *)packed; \
    ARGS_glMapBuffer *args = (ARGS_glMapBuffer *)&unpacked->args; \
    GLvoid * *ret = (GLvoid * *)ret_v; \
    if (ret != NULL) { \
        *ret = glMapBuffer(args->target, args->access);; \
    } else { \
        glMapBuffer(args->target, args->access);; \
    } \
} while(0)
GLvoid * glMapBuffer(glMapBuffer_ARG_EXPAND);
typedef GLvoid * (*glMapBuffer_PTR)(glMapBuffer_ARG_EXPAND);
#define glMapBufferARB_INDEX 1228
#define glMapBufferARB_RETURN GLvoid *
#define glMapBufferARB_ARG_NAMES target, access
#define glMapBufferARB_ARG_EXPAND GLenum target, GLenum access
#define glMapBufferARB_PACKED PACKED_glMapBufferARB
#define glMapBufferARB_VOID_ONLY_WRAP(...) {}
#define glMapBufferARB_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glMapBufferARB(_target, _access) ({ \
    glMapBufferARB_PACKED *packed_data = malloc(sizeof(glMapBufferARB_PACKED)); \
    packed_data->index = glMapBufferARB_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.access = (GLenum)_access; \
    (packed_call_t *)packed_data; \
})
#define call_glMapBufferARB(packed, ret_v) do { \
    PACKED_glMapBufferARB *unpacked = (PACKED_glMapBufferARB *)packed; \
    ARGS_glMapBufferARB *args = (ARGS_glMapBufferARB *)&unpacked->args; \
    GLvoid * *ret = (GLvoid * *)ret_v; \
    if (ret != NULL) { \
        *ret = glMapBufferARB(args->target, args->access);; \
    } else { \
        glMapBufferARB(args->target, args->access);; \
    } \
} while(0)
GLvoid * glMapBufferARB(glMapBufferARB_ARG_EXPAND);
typedef GLvoid * (*glMapBufferARB_PTR)(glMapBufferARB_ARG_EXPAND);
#define glMapBufferRange_INDEX 1229
#define glMapBufferRange_RETURN GLvoid *
#define glMapBufferRange_ARG_NAMES target, offset, length, access
#define glMapBufferRange_ARG_EXPAND GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access
#define glMapBufferRange_PACKED PACKED_glMapBufferRange
#define glMapBufferRange_VOID_ONLY_WRAP(...) {}
#define glMapBufferRange_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glMapBufferRange(_target, _offset, _length, _access) ({ \
    glMapBufferRange_PACKED *packed_data = malloc(sizeof(glMapBufferRange_PACKED)); \
    packed_data->index = glMapBufferRange_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.offset = (GLintptr)_offset; \
    packed_data->args.length = (GLsizeiptr)_length; \
    packed_data->args.access = (GLbitfield)_access; \
    (packed_call_t *)packed_data; \
})
#define call_glMapBufferRange(packed, ret_v) do { \
    PACKED_glMapBufferRange *unpacked = (PACKED_glMapBufferRange *)packed; \
    ARGS_glMapBufferRange *args = (ARGS_glMapBufferRange *)&unpacked->args; \
    GLvoid * *ret = (GLvoid * *)ret_v; \
    if (ret != NULL) { \
        *ret = glMapBufferRange(args->target, args->offset, args->length, args->access);; \
    } else { \
        glMapBufferRange(args->target, args->offset, args->length, args->access);; \
    } \
} while(0)
GLvoid * glMapBufferRange(glMapBufferRange_ARG_EXPAND);
typedef GLvoid * (*glMapBufferRange_PTR)(glMapBufferRange_ARG_EXPAND);
#define glMapControlPointsNV_INDEX 1230
#define glMapControlPointsNV_RETURN void
#define glMapControlPointsNV_ARG_NAMES target, index, type, ustride, vstride, uorder, vorder, packed, points
#define glMapControlPointsNV_ARG_EXPAND GLenum target, GLuint index, GLenum type, GLsizei ustride, GLsizei vstride, GLint uorder, GLint vorder, GLboolean packed, const GLvoid * points
#define glMapControlPointsNV_PACKED PACKED_glMapControlPointsNV
#define glMapControlPointsNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMapControlPointsNV_NOT_VOID_WRAP(...) {}
#define pack_glMapControlPointsNV(_target, _index, _type, _ustride, _vstride, _uorder, _vorder, _packed, _points) ({ \
    glMapControlPointsNV_PACKED *packed_data = malloc(sizeof(glMapControlPointsNV_PACKED)); \
    packed_data->index = glMapControlPointsNV_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.ustride = (GLsizei)_ustride; \
    packed_data->args.vstride = (GLsizei)_vstride; \
    packed_data->args.uorder = (GLint)_uorder; \
    packed_data->args.vorder = (GLint)_vorder; \
    packed_data->args.packed = (GLboolean)_packed; \
    packed_data->args.points = (GLvoid *)_points; \
    (packed_call_t *)packed_data; \
})
#define call_glMapControlPointsNV(packed, ret_v) do { \
    PACKED_glMapControlPointsNV *unpacked = (PACKED_glMapControlPointsNV *)packed; \
    ARGS_glMapControlPointsNV *args = (ARGS_glMapControlPointsNV *)&unpacked->args; \
    glMapControlPointsNV(args->target, args->index, args->type, args->ustride, args->vstride, args->uorder, args->vorder, args->packed, args->points);; \
} while(0)
void glMapControlPointsNV(glMapControlPointsNV_ARG_EXPAND);
typedef void (*glMapControlPointsNV_PTR)(glMapControlPointsNV_ARG_EXPAND);
#define glMapGrid1d_INDEX 1231
#define glMapGrid1d_RETURN void
#define glMapGrid1d_ARG_NAMES un, u1, u2
#define glMapGrid1d_ARG_EXPAND GLint un, GLdouble u1, GLdouble u2
#define glMapGrid1d_PACKED PACKED_glMapGrid1d
#define glMapGrid1d_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMapGrid1d_NOT_VOID_WRAP(...) {}
#define pack_glMapGrid1d(_un, _u1, _u2) ({ \
    glMapGrid1d_PACKED *packed_data = malloc(sizeof(glMapGrid1d_PACKED)); \
    packed_data->index = glMapGrid1d_INDEX; \
    packed_data->args.un = (GLint)_un; \
    packed_data->args.u1 = (GLdouble)_u1; \
    packed_data->args.u2 = (GLdouble)_u2; \
    (packed_call_t *)packed_data; \
})
#define call_glMapGrid1d(packed, ret_v) do { \
    PACKED_glMapGrid1d *unpacked = (PACKED_glMapGrid1d *)packed; \
    ARGS_glMapGrid1d *args = (ARGS_glMapGrid1d *)&unpacked->args; \
    glMapGrid1d(args->un, args->u1, args->u2);; \
} while(0)
void glMapGrid1d(glMapGrid1d_ARG_EXPAND);
typedef void (*glMapGrid1d_PTR)(glMapGrid1d_ARG_EXPAND);
#define glMapGrid1f_INDEX 1232
#define glMapGrid1f_RETURN void
#define glMapGrid1f_ARG_NAMES un, u1, u2
#define glMapGrid1f_ARG_EXPAND GLint un, GLfloat u1, GLfloat u2
#define glMapGrid1f_PACKED PACKED_glMapGrid1f
#define glMapGrid1f_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMapGrid1f_NOT_VOID_WRAP(...) {}
#define pack_glMapGrid1f(_un, _u1, _u2) ({ \
    glMapGrid1f_PACKED *packed_data = malloc(sizeof(glMapGrid1f_PACKED)); \
    packed_data->index = glMapGrid1f_INDEX; \
    packed_data->args.un = (GLint)_un; \
    packed_data->args.u1 = (GLfloat)_u1; \
    packed_data->args.u2 = (GLfloat)_u2; \
    (packed_call_t *)packed_data; \
})
#define call_glMapGrid1f(packed, ret_v) do { \
    PACKED_glMapGrid1f *unpacked = (PACKED_glMapGrid1f *)packed; \
    ARGS_glMapGrid1f *args = (ARGS_glMapGrid1f *)&unpacked->args; \
    glMapGrid1f(args->un, args->u1, args->u2);; \
} while(0)
void glMapGrid1f(glMapGrid1f_ARG_EXPAND);
typedef void (*glMapGrid1f_PTR)(glMapGrid1f_ARG_EXPAND);
#define glMapGrid1xOES_INDEX 1233
#define glMapGrid1xOES_RETURN void
#define glMapGrid1xOES_ARG_NAMES n, u1, u2
#define glMapGrid1xOES_ARG_EXPAND GLint n, GLfixed u1, GLfixed u2
#define glMapGrid1xOES_PACKED PACKED_glMapGrid1xOES
#define glMapGrid1xOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMapGrid1xOES_NOT_VOID_WRAP(...) {}
#define pack_glMapGrid1xOES(_n, _u1, _u2) ({ \
    glMapGrid1xOES_PACKED *packed_data = malloc(sizeof(glMapGrid1xOES_PACKED)); \
    packed_data->index = glMapGrid1xOES_INDEX; \
    packed_data->args.n = (GLint)_n; \
    packed_data->args.u1 = (GLfixed)_u1; \
    packed_data->args.u2 = (GLfixed)_u2; \
    (packed_call_t *)packed_data; \
})
#define call_glMapGrid1xOES(packed, ret_v) do { \
    PACKED_glMapGrid1xOES *unpacked = (PACKED_glMapGrid1xOES *)packed; \
    ARGS_glMapGrid1xOES *args = (ARGS_glMapGrid1xOES *)&unpacked->args; \
    glMapGrid1xOES(args->n, args->u1, args->u2);; \
} while(0)
void glMapGrid1xOES(glMapGrid1xOES_ARG_EXPAND);
typedef void (*glMapGrid1xOES_PTR)(glMapGrid1xOES_ARG_EXPAND);
#define glMapGrid2d_INDEX 1234
#define glMapGrid2d_RETURN void
#define glMapGrid2d_ARG_NAMES un, u1, u2, vn, v1, v2
#define glMapGrid2d_ARG_EXPAND GLint un, GLdouble u1, GLdouble u2, GLint vn, GLdouble v1, GLdouble v2
#define glMapGrid2d_PACKED PACKED_glMapGrid2d
#define glMapGrid2d_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMapGrid2d_NOT_VOID_WRAP(...) {}
#define pack_glMapGrid2d(_un, _u1, _u2, _vn, _v1, _v2) ({ \
    glMapGrid2d_PACKED *packed_data = malloc(sizeof(glMapGrid2d_PACKED)); \
    packed_data->index = glMapGrid2d_INDEX; \
    packed_data->args.un = (GLint)_un; \
    packed_data->args.u1 = (GLdouble)_u1; \
    packed_data->args.u2 = (GLdouble)_u2; \
    packed_data->args.vn = (GLint)_vn; \
    packed_data->args.v1 = (GLdouble)_v1; \
    packed_data->args.v2 = (GLdouble)_v2; \
    (packed_call_t *)packed_data; \
})
#define call_glMapGrid2d(packed, ret_v) do { \
    PACKED_glMapGrid2d *unpacked = (PACKED_glMapGrid2d *)packed; \
    ARGS_glMapGrid2d *args = (ARGS_glMapGrid2d *)&unpacked->args; \
    glMapGrid2d(args->un, args->u1, args->u2, args->vn, args->v1, args->v2);; \
} while(0)
void glMapGrid2d(glMapGrid2d_ARG_EXPAND);
typedef void (*glMapGrid2d_PTR)(glMapGrid2d_ARG_EXPAND);
#define glMapGrid2f_INDEX 1235
#define glMapGrid2f_RETURN void
#define glMapGrid2f_ARG_NAMES un, u1, u2, vn, v1, v2
#define glMapGrid2f_ARG_EXPAND GLint un, GLfloat u1, GLfloat u2, GLint vn, GLfloat v1, GLfloat v2
#define glMapGrid2f_PACKED PACKED_glMapGrid2f
#define glMapGrid2f_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMapGrid2f_NOT_VOID_WRAP(...) {}
#define pack_glMapGrid2f(_un, _u1, _u2, _vn, _v1, _v2) ({ \
    glMapGrid2f_PACKED *packed_data = malloc(sizeof(glMapGrid2f_PACKED)); \
    packed_data->index = glMapGrid2f_INDEX; \
    packed_data->args.un = (GLint)_un; \
    packed_data->args.u1 = (GLfloat)_u1; \
    packed_data->args.u2 = (GLfloat)_u2; \
    packed_data->args.vn = (GLint)_vn; \
    packed_data->args.v1 = (GLfloat)_v1; \
    packed_data->args.v2 = (GLfloat)_v2; \
    (packed_call_t *)packed_data; \
})
#define call_glMapGrid2f(packed, ret_v) do { \
    PACKED_glMapGrid2f *unpacked = (PACKED_glMapGrid2f *)packed; \
    ARGS_glMapGrid2f *args = (ARGS_glMapGrid2f *)&unpacked->args; \
    glMapGrid2f(args->un, args->u1, args->u2, args->vn, args->v1, args->v2);; \
} while(0)
void glMapGrid2f(glMapGrid2f_ARG_EXPAND);
typedef void (*glMapGrid2f_PTR)(glMapGrid2f_ARG_EXPAND);
#define glMapGrid2xOES_INDEX 1236
#define glMapGrid2xOES_RETURN void
#define glMapGrid2xOES_ARG_NAMES n, u1, u2, v1, v2
#define glMapGrid2xOES_ARG_EXPAND GLint n, GLfixed u1, GLfixed u2, GLfixed v1, GLfixed v2
#define glMapGrid2xOES_PACKED PACKED_glMapGrid2xOES
#define glMapGrid2xOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMapGrid2xOES_NOT_VOID_WRAP(...) {}
#define pack_glMapGrid2xOES(_n, _u1, _u2, _v1, _v2) ({ \
    glMapGrid2xOES_PACKED *packed_data = malloc(sizeof(glMapGrid2xOES_PACKED)); \
    packed_data->index = glMapGrid2xOES_INDEX; \
    packed_data->args.n = (GLint)_n; \
    packed_data->args.u1 = (GLfixed)_u1; \
    packed_data->args.u2 = (GLfixed)_u2; \
    packed_data->args.v1 = (GLfixed)_v1; \
    packed_data->args.v2 = (GLfixed)_v2; \
    (packed_call_t *)packed_data; \
})
#define call_glMapGrid2xOES(packed, ret_v) do { \
    PACKED_glMapGrid2xOES *unpacked = (PACKED_glMapGrid2xOES *)packed; \
    ARGS_glMapGrid2xOES *args = (ARGS_glMapGrid2xOES *)&unpacked->args; \
    glMapGrid2xOES(args->n, args->u1, args->u2, args->v1, args->v2);; \
} while(0)
void glMapGrid2xOES(glMapGrid2xOES_ARG_EXPAND);
typedef void (*glMapGrid2xOES_PTR)(glMapGrid2xOES_ARG_EXPAND);
#define glMapNamedBufferEXT_INDEX 1237
#define glMapNamedBufferEXT_RETURN GLvoid *
#define glMapNamedBufferEXT_ARG_NAMES buffer, access
#define glMapNamedBufferEXT_ARG_EXPAND GLuint buffer, GLenum access
#define glMapNamedBufferEXT_PACKED PACKED_glMapNamedBufferEXT
#define glMapNamedBufferEXT_VOID_ONLY_WRAP(...) {}
#define glMapNamedBufferEXT_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glMapNamedBufferEXT(_buffer, _access) ({ \
    glMapNamedBufferEXT_PACKED *packed_data = malloc(sizeof(glMapNamedBufferEXT_PACKED)); \
    packed_data->index = glMapNamedBufferEXT_INDEX; \
    packed_data->args.buffer = (GLuint)_buffer; \
    packed_data->args.access = (GLenum)_access; \
    (packed_call_t *)packed_data; \
})
#define call_glMapNamedBufferEXT(packed, ret_v) do { \
    PACKED_glMapNamedBufferEXT *unpacked = (PACKED_glMapNamedBufferEXT *)packed; \
    ARGS_glMapNamedBufferEXT *args = (ARGS_glMapNamedBufferEXT *)&unpacked->args; \
    GLvoid * *ret = (GLvoid * *)ret_v; \
    if (ret != NULL) { \
        *ret = glMapNamedBufferEXT(args->buffer, args->access);; \
    } else { \
        glMapNamedBufferEXT(args->buffer, args->access);; \
    } \
} while(0)
GLvoid * glMapNamedBufferEXT(glMapNamedBufferEXT_ARG_EXPAND);
typedef GLvoid * (*glMapNamedBufferEXT_PTR)(glMapNamedBufferEXT_ARG_EXPAND);
#define glMapNamedBufferRangeEXT_INDEX 1238
#define glMapNamedBufferRangeEXT_RETURN GLvoid *
#define glMapNamedBufferRangeEXT_ARG_NAMES buffer, offset, length, access
#define glMapNamedBufferRangeEXT_ARG_EXPAND GLuint buffer, GLintptr offset, GLsizeiptr length, GLbitfield access
#define glMapNamedBufferRangeEXT_PACKED PACKED_glMapNamedBufferRangeEXT
#define glMapNamedBufferRangeEXT_VOID_ONLY_WRAP(...) {}
#define glMapNamedBufferRangeEXT_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glMapNamedBufferRangeEXT(_buffer, _offset, _length, _access) ({ \
    glMapNamedBufferRangeEXT_PACKED *packed_data = malloc(sizeof(glMapNamedBufferRangeEXT_PACKED)); \
    packed_data->index = glMapNamedBufferRangeEXT_INDEX; \
    packed_data->args.buffer = (GLuint)_buffer; \
    packed_data->args.offset = (GLintptr)_offset; \
    packed_data->args.length = (GLsizeiptr)_length; \
    packed_data->args.access = (GLbitfield)_access; \
    (packed_call_t *)packed_data; \
})
#define call_glMapNamedBufferRangeEXT(packed, ret_v) do { \
    PACKED_glMapNamedBufferRangeEXT *unpacked = (PACKED_glMapNamedBufferRangeEXT *)packed; \
    ARGS_glMapNamedBufferRangeEXT *args = (ARGS_glMapNamedBufferRangeEXT *)&unpacked->args; \
    GLvoid * *ret = (GLvoid * *)ret_v; \
    if (ret != NULL) { \
        *ret = glMapNamedBufferRangeEXT(args->buffer, args->offset, args->length, args->access);; \
    } else { \
        glMapNamedBufferRangeEXT(args->buffer, args->offset, args->length, args->access);; \
    } \
} while(0)
GLvoid * glMapNamedBufferRangeEXT(glMapNamedBufferRangeEXT_ARG_EXPAND);
typedef GLvoid * (*glMapNamedBufferRangeEXT_PTR)(glMapNamedBufferRangeEXT_ARG_EXPAND);
#define glMapObjectBufferATI_INDEX 1239
#define glMapObjectBufferATI_RETURN GLvoid *
#define glMapObjectBufferATI_ARG_NAMES buffer
#define glMapObjectBufferATI_ARG_EXPAND GLuint buffer
#define glMapObjectBufferATI_PACKED PACKED_glMapObjectBufferATI
#define glMapObjectBufferATI_VOID_ONLY_WRAP(...) {}
#define glMapObjectBufferATI_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glMapObjectBufferATI(_buffer) ({ \
    glMapObjectBufferATI_PACKED *packed_data = malloc(sizeof(glMapObjectBufferATI_PACKED)); \
    packed_data->index = glMapObjectBufferATI_INDEX; \
    packed_data->args.buffer = (GLuint)_buffer; \
    (packed_call_t *)packed_data; \
})
#define call_glMapObjectBufferATI(packed, ret_v) do { \
    PACKED_glMapObjectBufferATI *unpacked = (PACKED_glMapObjectBufferATI *)packed; \
    ARGS_glMapObjectBufferATI *args = (ARGS_glMapObjectBufferATI *)&unpacked->args; \
    GLvoid * *ret = (GLvoid * *)ret_v; \
    if (ret != NULL) { \
        *ret = glMapObjectBufferATI(args->buffer);; \
    } else { \
        glMapObjectBufferATI(args->buffer);; \
    } \
} while(0)
GLvoid * glMapObjectBufferATI(glMapObjectBufferATI_ARG_EXPAND);
typedef GLvoid * (*glMapObjectBufferATI_PTR)(glMapObjectBufferATI_ARG_EXPAND);
#define glMapParameterfvNV_INDEX 1240
#define glMapParameterfvNV_RETURN void
#define glMapParameterfvNV_ARG_NAMES target, pname, params
#define glMapParameterfvNV_ARG_EXPAND GLenum target, GLenum pname, const GLfloat * params
#define glMapParameterfvNV_PACKED PACKED_glMapParameterfvNV
#define glMapParameterfvNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMapParameterfvNV_NOT_VOID_WRAP(...) {}
#define pack_glMapParameterfvNV(_target, _pname, _params) ({ \
    glMapParameterfvNV_PACKED *packed_data = malloc(sizeof(glMapParameterfvNV_PACKED)); \
    packed_data->index = glMapParameterfvNV_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLfloat *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glMapParameterfvNV(packed, ret_v) do { \
    PACKED_glMapParameterfvNV *unpacked = (PACKED_glMapParameterfvNV *)packed; \
    ARGS_glMapParameterfvNV *args = (ARGS_glMapParameterfvNV *)&unpacked->args; \
    glMapParameterfvNV(args->target, args->pname, args->params);; \
} while(0)
void glMapParameterfvNV(glMapParameterfvNV_ARG_EXPAND);
typedef void (*glMapParameterfvNV_PTR)(glMapParameterfvNV_ARG_EXPAND);
#define glMapParameterivNV_INDEX 1241
#define glMapParameterivNV_RETURN void
#define glMapParameterivNV_ARG_NAMES target, pname, params
#define glMapParameterivNV_ARG_EXPAND GLenum target, GLenum pname, const GLint * params
#define glMapParameterivNV_PACKED PACKED_glMapParameterivNV
#define glMapParameterivNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMapParameterivNV_NOT_VOID_WRAP(...) {}
#define pack_glMapParameterivNV(_target, _pname, _params) ({ \
    glMapParameterivNV_PACKED *packed_data = malloc(sizeof(glMapParameterivNV_PACKED)); \
    packed_data->index = glMapParameterivNV_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glMapParameterivNV(packed, ret_v) do { \
    PACKED_glMapParameterivNV *unpacked = (PACKED_glMapParameterivNV *)packed; \
    ARGS_glMapParameterivNV *args = (ARGS_glMapParameterivNV *)&unpacked->args; \
    glMapParameterivNV(args->target, args->pname, args->params);; \
} while(0)
void glMapParameterivNV(glMapParameterivNV_ARG_EXPAND);
typedef void (*glMapParameterivNV_PTR)(glMapParameterivNV_ARG_EXPAND);
#define glMapTexture2DINTEL_INDEX 1242
#define glMapTexture2DINTEL_RETURN GLvoid *
#define glMapTexture2DINTEL_ARG_NAMES texture, level, access, stride, layout
#define glMapTexture2DINTEL_ARG_EXPAND GLuint texture, GLint level, GLbitfield access, const GLint * stride, const GLenum * layout
#define glMapTexture2DINTEL_PACKED PACKED_glMapTexture2DINTEL
#define glMapTexture2DINTEL_VOID_ONLY_WRAP(...) {}
#define glMapTexture2DINTEL_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glMapTexture2DINTEL(_texture, _level, _access, _stride, _layout) ({ \
    glMapTexture2DINTEL_PACKED *packed_data = malloc(sizeof(glMapTexture2DINTEL_PACKED)); \
    packed_data->index = glMapTexture2DINTEL_INDEX; \
    packed_data->args.texture = (GLuint)_texture; \
    packed_data->args.level = (GLint)_level; \
    packed_data->args.access = (GLbitfield)_access; \
    packed_data->args.stride = (GLint *)_stride; \
    packed_data->args.layout = (GLenum *)_layout; \
    (packed_call_t *)packed_data; \
})
#define call_glMapTexture2DINTEL(packed, ret_v) do { \
    PACKED_glMapTexture2DINTEL *unpacked = (PACKED_glMapTexture2DINTEL *)packed; \
    ARGS_glMapTexture2DINTEL *args = (ARGS_glMapTexture2DINTEL *)&unpacked->args; \
    GLvoid * *ret = (GLvoid * *)ret_v; \
    if (ret != NULL) { \
        *ret = glMapTexture2DINTEL(args->texture, args->level, args->access, args->stride, args->layout);; \
    } else { \
        glMapTexture2DINTEL(args->texture, args->level, args->access, args->stride, args->layout);; \
    } \
} while(0)
GLvoid * glMapTexture2DINTEL(glMapTexture2DINTEL_ARG_EXPAND);
typedef GLvoid * (*glMapTexture2DINTEL_PTR)(glMapTexture2DINTEL_ARG_EXPAND);
#define glMapVertexAttrib1dAPPLE_INDEX 1243
#define glMapVertexAttrib1dAPPLE_RETURN void
#define glMapVertexAttrib1dAPPLE_ARG_NAMES index, size, u1, u2, stride, order, points
#define glMapVertexAttrib1dAPPLE_ARG_EXPAND GLuint index, GLuint size, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble * points
#define glMapVertexAttrib1dAPPLE_PACKED PACKED_glMapVertexAttrib1dAPPLE
#define glMapVertexAttrib1dAPPLE_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMapVertexAttrib1dAPPLE_NOT_VOID_WRAP(...) {}
#define pack_glMapVertexAttrib1dAPPLE(_index, _size, _u1, _u2, _stride, _order, _points) ({ \
    glMapVertexAttrib1dAPPLE_PACKED *packed_data = malloc(sizeof(glMapVertexAttrib1dAPPLE_PACKED)); \
    packed_data->index = glMapVertexAttrib1dAPPLE_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.size = (GLuint)_size; \
    packed_data->args.u1 = (GLdouble)_u1; \
    packed_data->args.u2 = (GLdouble)_u2; \
    packed_data->args.stride = (GLint)_stride; \
    packed_data->args.order = (GLint)_order; \
    packed_data->args.points = (GLdouble *)_points; \
    (packed_call_t *)packed_data; \
})
#define call_glMapVertexAttrib1dAPPLE(packed, ret_v) do { \
    PACKED_glMapVertexAttrib1dAPPLE *unpacked = (PACKED_glMapVertexAttrib1dAPPLE *)packed; \
    ARGS_glMapVertexAttrib1dAPPLE *args = (ARGS_glMapVertexAttrib1dAPPLE *)&unpacked->args; \
    glMapVertexAttrib1dAPPLE(args->index, args->size, args->u1, args->u2, args->stride, args->order, args->points);; \
} while(0)
void glMapVertexAttrib1dAPPLE(glMapVertexAttrib1dAPPLE_ARG_EXPAND);
typedef void (*glMapVertexAttrib1dAPPLE_PTR)(glMapVertexAttrib1dAPPLE_ARG_EXPAND);
#define glMapVertexAttrib1fAPPLE_INDEX 1244
#define glMapVertexAttrib1fAPPLE_RETURN void
#define glMapVertexAttrib1fAPPLE_ARG_NAMES index, size, u1, u2, stride, order, points
#define glMapVertexAttrib1fAPPLE_ARG_EXPAND GLuint index, GLuint size, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat * points
#define glMapVertexAttrib1fAPPLE_PACKED PACKED_glMapVertexAttrib1fAPPLE
#define glMapVertexAttrib1fAPPLE_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMapVertexAttrib1fAPPLE_NOT_VOID_WRAP(...) {}
#define pack_glMapVertexAttrib1fAPPLE(_index, _size, _u1, _u2, _stride, _order, _points) ({ \
    glMapVertexAttrib1fAPPLE_PACKED *packed_data = malloc(sizeof(glMapVertexAttrib1fAPPLE_PACKED)); \
    packed_data->index = glMapVertexAttrib1fAPPLE_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.size = (GLuint)_size; \
    packed_data->args.u1 = (GLfloat)_u1; \
    packed_data->args.u2 = (GLfloat)_u2; \
    packed_data->args.stride = (GLint)_stride; \
    packed_data->args.order = (GLint)_order; \
    packed_data->args.points = (GLfloat *)_points; \
    (packed_call_t *)packed_data; \
})
#define call_glMapVertexAttrib1fAPPLE(packed, ret_v) do { \
    PACKED_glMapVertexAttrib1fAPPLE *unpacked = (PACKED_glMapVertexAttrib1fAPPLE *)packed; \
    ARGS_glMapVertexAttrib1fAPPLE *args = (ARGS_glMapVertexAttrib1fAPPLE *)&unpacked->args; \
    glMapVertexAttrib1fAPPLE(args->index, args->size, args->u1, args->u2, args->stride, args->order, args->points);; \
} while(0)
void glMapVertexAttrib1fAPPLE(glMapVertexAttrib1fAPPLE_ARG_EXPAND);
typedef void (*glMapVertexAttrib1fAPPLE_PTR)(glMapVertexAttrib1fAPPLE_ARG_EXPAND);
#define glMapVertexAttrib2dAPPLE_INDEX 1245
#define glMapVertexAttrib2dAPPLE_RETURN void
#define glMapVertexAttrib2dAPPLE_ARG_NAMES index, size, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points
#define glMapVertexAttrib2dAPPLE_ARG_EXPAND GLuint index, GLuint size, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble * points
#define glMapVertexAttrib2dAPPLE_PACKED PACKED_glMapVertexAttrib2dAPPLE
#define glMapVertexAttrib2dAPPLE_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMapVertexAttrib2dAPPLE_NOT_VOID_WRAP(...) {}
#define pack_glMapVertexAttrib2dAPPLE(_index, _size, _u1, _u2, _ustride, _uorder, _v1, _v2, _vstride, _vorder, _points) ({ \
    glMapVertexAttrib2dAPPLE_PACKED *packed_data = malloc(sizeof(glMapVertexAttrib2dAPPLE_PACKED)); \
    packed_data->index = glMapVertexAttrib2dAPPLE_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.size = (GLuint)_size; \
    packed_data->args.u1 = (GLdouble)_u1; \
    packed_data->args.u2 = (GLdouble)_u2; \
    packed_data->args.ustride = (GLint)_ustride; \
    packed_data->args.uorder = (GLint)_uorder; \
    packed_data->args.v1 = (GLdouble)_v1; \
    packed_data->args.v2 = (GLdouble)_v2; \
    packed_data->args.vstride = (GLint)_vstride; \
    packed_data->args.vorder = (GLint)_vorder; \
    packed_data->args.points = (GLdouble *)_points; \
    (packed_call_t *)packed_data; \
})
#define call_glMapVertexAttrib2dAPPLE(packed, ret_v) do { \
    PACKED_glMapVertexAttrib2dAPPLE *unpacked = (PACKED_glMapVertexAttrib2dAPPLE *)packed; \
    ARGS_glMapVertexAttrib2dAPPLE *args = (ARGS_glMapVertexAttrib2dAPPLE *)&unpacked->args; \
    glMapVertexAttrib2dAPPLE(args->index, args->size, args->u1, args->u2, args->ustride, args->uorder, args->v1, args->v2, args->vstride, args->vorder, args->points);; \
} while(0)
void glMapVertexAttrib2dAPPLE(glMapVertexAttrib2dAPPLE_ARG_EXPAND);
typedef void (*glMapVertexAttrib2dAPPLE_PTR)(glMapVertexAttrib2dAPPLE_ARG_EXPAND);
#define glMapVertexAttrib2fAPPLE_INDEX 1246
#define glMapVertexAttrib2fAPPLE_RETURN void
#define glMapVertexAttrib2fAPPLE_ARG_NAMES index, size, u1, u2, ustride, uorder, v1, v2, vstride, vorder, points
#define glMapVertexAttrib2fAPPLE_ARG_EXPAND GLuint index, GLuint size, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat * points
#define glMapVertexAttrib2fAPPLE_PACKED PACKED_glMapVertexAttrib2fAPPLE
#define glMapVertexAttrib2fAPPLE_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMapVertexAttrib2fAPPLE_NOT_VOID_WRAP(...) {}
#define pack_glMapVertexAttrib2fAPPLE(_index, _size, _u1, _u2, _ustride, _uorder, _v1, _v2, _vstride, _vorder, _points) ({ \
    glMapVertexAttrib2fAPPLE_PACKED *packed_data = malloc(sizeof(glMapVertexAttrib2fAPPLE_PACKED)); \
    packed_data->index = glMapVertexAttrib2fAPPLE_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.size = (GLuint)_size; \
    packed_data->args.u1 = (GLfloat)_u1; \
    packed_data->args.u2 = (GLfloat)_u2; \
    packed_data->args.ustride = (GLint)_ustride; \
    packed_data->args.uorder = (GLint)_uorder; \
    packed_data->args.v1 = (GLfloat)_v1; \
    packed_data->args.v2 = (GLfloat)_v2; \
    packed_data->args.vstride = (GLint)_vstride; \
    packed_data->args.vorder = (GLint)_vorder; \
    packed_data->args.points = (GLfloat *)_points; \
    (packed_call_t *)packed_data; \
})
#define call_glMapVertexAttrib2fAPPLE(packed, ret_v) do { \
    PACKED_glMapVertexAttrib2fAPPLE *unpacked = (PACKED_glMapVertexAttrib2fAPPLE *)packed; \
    ARGS_glMapVertexAttrib2fAPPLE *args = (ARGS_glMapVertexAttrib2fAPPLE *)&unpacked->args; \
    glMapVertexAttrib2fAPPLE(args->index, args->size, args->u1, args->u2, args->ustride, args->uorder, args->v1, args->v2, args->vstride, args->vorder, args->points);; \
} while(0)
void glMapVertexAttrib2fAPPLE(glMapVertexAttrib2fAPPLE_ARG_EXPAND);
typedef void (*glMapVertexAttrib2fAPPLE_PTR)(glMapVertexAttrib2fAPPLE_ARG_EXPAND);
#define glMaterialf_INDEX 1247
#define glMaterialf_RETURN void
#define glMaterialf_ARG_NAMES face, pname, param
#define glMaterialf_ARG_EXPAND GLenum face, GLenum pname, GLfloat param
#define glMaterialf_PACKED PACKED_glMaterialf
#define glMaterialf_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMaterialf_NOT_VOID_WRAP(...) {}
#define pack_glMaterialf(_face, _pname, _param) ({ \
    glMaterialf_PACKED *packed_data = malloc(sizeof(glMaterialf_PACKED)); \
    packed_data->index = glMaterialf_INDEX; \
    packed_data->args.face = (GLenum)_face; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.param = (GLfloat)_param; \
    (packed_call_t *)packed_data; \
})
#define call_glMaterialf(packed, ret_v) do { \
    PACKED_glMaterialf *unpacked = (PACKED_glMaterialf *)packed; \
    ARGS_glMaterialf *args = (ARGS_glMaterialf *)&unpacked->args; \
    glMaterialf(args->face, args->pname, args->param);; \
} while(0)
void glMaterialf(glMaterialf_ARG_EXPAND);
typedef void (*glMaterialf_PTR)(glMaterialf_ARG_EXPAND);
#define glMaterialfv_INDEX 1248
#define glMaterialfv_RETURN void
#define glMaterialfv_ARG_NAMES face, pname, params
#define glMaterialfv_ARG_EXPAND GLenum face, GLenum pname, const GLfloat * params
#define glMaterialfv_PACKED PACKED_glMaterialfv
#define glMaterialfv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMaterialfv_NOT_VOID_WRAP(...) {}
#define pack_glMaterialfv(_face, _pname, _params) ({ \
    glMaterialfv_PACKED *packed_data = malloc(sizeof(glMaterialfv_PACKED)); \
    packed_data->index = glMaterialfv_INDEX; \
    packed_data->args.face = (GLenum)_face; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLfloat *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glMaterialfv(packed, ret_v) do { \
    PACKED_glMaterialfv *unpacked = (PACKED_glMaterialfv *)packed; \
    ARGS_glMaterialfv *args = (ARGS_glMaterialfv *)&unpacked->args; \
    glMaterialfv(args->face, args->pname, args->params);; \
} while(0)
void glMaterialfv(glMaterialfv_ARG_EXPAND);
typedef void (*glMaterialfv_PTR)(glMaterialfv_ARG_EXPAND);
#define glMateriali_INDEX 1249
#define glMateriali_RETURN void
#define glMateriali_ARG_NAMES face, pname, param
#define glMateriali_ARG_EXPAND GLenum face, GLenum pname, GLint param
#define glMateriali_PACKED PACKED_glMateriali
#define glMateriali_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMateriali_NOT_VOID_WRAP(...) {}
#define pack_glMateriali(_face, _pname, _param) ({ \
    glMateriali_PACKED *packed_data = malloc(sizeof(glMateriali_PACKED)); \
    packed_data->index = glMateriali_INDEX; \
    packed_data->args.face = (GLenum)_face; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.param = (GLint)_param; \
    (packed_call_t *)packed_data; \
})
#define call_glMateriali(packed, ret_v) do { \
    PACKED_glMateriali *unpacked = (PACKED_glMateriali *)packed; \
    ARGS_glMateriali *args = (ARGS_glMateriali *)&unpacked->args; \
    glMateriali(args->face, args->pname, args->param);; \
} while(0)
void glMateriali(glMateriali_ARG_EXPAND);
typedef void (*glMateriali_PTR)(glMateriali_ARG_EXPAND);
#define glMaterialiv_INDEX 1250
#define glMaterialiv_RETURN void
#define glMaterialiv_ARG_NAMES face, pname, params
#define glMaterialiv_ARG_EXPAND GLenum face, GLenum pname, const GLint * params
#define glMaterialiv_PACKED PACKED_glMaterialiv
#define glMaterialiv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMaterialiv_NOT_VOID_WRAP(...) {}
#define pack_glMaterialiv(_face, _pname, _params) ({ \
    glMaterialiv_PACKED *packed_data = malloc(sizeof(glMaterialiv_PACKED)); \
    packed_data->index = glMaterialiv_INDEX; \
    packed_data->args.face = (GLenum)_face; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glMaterialiv(packed, ret_v) do { \
    PACKED_glMaterialiv *unpacked = (PACKED_glMaterialiv *)packed; \
    ARGS_glMaterialiv *args = (ARGS_glMaterialiv *)&unpacked->args; \
    glMaterialiv(args->face, args->pname, args->params);; \
} while(0)
void glMaterialiv(glMaterialiv_ARG_EXPAND);
typedef void (*glMaterialiv_PTR)(glMaterialiv_ARG_EXPAND);
#define glMaterialx_INDEX 1251
#define glMaterialx_RETURN void
#define glMaterialx_ARG_NAMES face, pname, param
#define glMaterialx_ARG_EXPAND GLenum face, GLenum pname, GLfixed param
#define glMaterialx_PACKED PACKED_glMaterialx
#define glMaterialx_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMaterialx_NOT_VOID_WRAP(...) {}
#define pack_glMaterialx(_face, _pname, _param) ({ \
    glMaterialx_PACKED *packed_data = malloc(sizeof(glMaterialx_PACKED)); \
    packed_data->index = glMaterialx_INDEX; \
    packed_data->args.face = (GLenum)_face; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.param = (GLfixed)_param; \
    (packed_call_t *)packed_data; \
})
#define call_glMaterialx(packed, ret_v) do { \
    PACKED_glMaterialx *unpacked = (PACKED_glMaterialx *)packed; \
    ARGS_glMaterialx *args = (ARGS_glMaterialx *)&unpacked->args; \
    glMaterialx(args->face, args->pname, args->param);; \
} while(0)
void glMaterialx(glMaterialx_ARG_EXPAND);
typedef void (*glMaterialx_PTR)(glMaterialx_ARG_EXPAND);
#define glMaterialxOES_INDEX 1252
#define glMaterialxOES_RETURN void
#define glMaterialxOES_ARG_NAMES face, pname, param
#define glMaterialxOES_ARG_EXPAND GLenum face, GLenum pname, GLfixed param
#define glMaterialxOES_PACKED PACKED_glMaterialxOES
#define glMaterialxOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMaterialxOES_NOT_VOID_WRAP(...) {}
#define pack_glMaterialxOES(_face, _pname, _param) ({ \
    glMaterialxOES_PACKED *packed_data = malloc(sizeof(glMaterialxOES_PACKED)); \
    packed_data->index = glMaterialxOES_INDEX; \
    packed_data->args.face = (GLenum)_face; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.param = (GLfixed)_param; \
    (packed_call_t *)packed_data; \
})
#define call_glMaterialxOES(packed, ret_v) do { \
    PACKED_glMaterialxOES *unpacked = (PACKED_glMaterialxOES *)packed; \
    ARGS_glMaterialxOES *args = (ARGS_glMaterialxOES *)&unpacked->args; \
    glMaterialxOES(args->face, args->pname, args->param);; \
} while(0)
void glMaterialxOES(glMaterialxOES_ARG_EXPAND);
typedef void (*glMaterialxOES_PTR)(glMaterialxOES_ARG_EXPAND);
#define glMaterialxv_INDEX 1253
#define glMaterialxv_RETURN void
#define glMaterialxv_ARG_NAMES face, pname, params
#define glMaterialxv_ARG_EXPAND GLenum face, GLenum pname, const GLfixed * params
#define glMaterialxv_PACKED PACKED_glMaterialxv
#define glMaterialxv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMaterialxv_NOT_VOID_WRAP(...) {}
#define pack_glMaterialxv(_face, _pname, _params) ({ \
    glMaterialxv_PACKED *packed_data = malloc(sizeof(glMaterialxv_PACKED)); \
    packed_data->index = glMaterialxv_INDEX; \
    packed_data->args.face = (GLenum)_face; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLfixed *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glMaterialxv(packed, ret_v) do { \
    PACKED_glMaterialxv *unpacked = (PACKED_glMaterialxv *)packed; \
    ARGS_glMaterialxv *args = (ARGS_glMaterialxv *)&unpacked->args; \
    glMaterialxv(args->face, args->pname, args->params);; \
} while(0)
void glMaterialxv(glMaterialxv_ARG_EXPAND);
typedef void (*glMaterialxv_PTR)(glMaterialxv_ARG_EXPAND);
#define glMaterialxvOES_INDEX 1254
#define glMaterialxvOES_RETURN void
#define glMaterialxvOES_ARG_NAMES face, pname, param
#define glMaterialxvOES_ARG_EXPAND GLenum face, GLenum pname, const GLfixed * param
#define glMaterialxvOES_PACKED PACKED_glMaterialxvOES
#define glMaterialxvOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMaterialxvOES_NOT_VOID_WRAP(...) {}
#define pack_glMaterialxvOES(_face, _pname, _param) ({ \
    glMaterialxvOES_PACKED *packed_data = malloc(sizeof(glMaterialxvOES_PACKED)); \
    packed_data->index = glMaterialxvOES_INDEX; \
    packed_data->args.face = (GLenum)_face; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.param = (GLfixed *)_param; \
    (packed_call_t *)packed_data; \
})
#define call_glMaterialxvOES(packed, ret_v) do { \
    PACKED_glMaterialxvOES *unpacked = (PACKED_glMaterialxvOES *)packed; \
    ARGS_glMaterialxvOES *args = (ARGS_glMaterialxvOES *)&unpacked->args; \
    glMaterialxvOES(args->face, args->pname, args->param);; \
} while(0)
void glMaterialxvOES(glMaterialxvOES_ARG_EXPAND);
typedef void (*glMaterialxvOES_PTR)(glMaterialxvOES_ARG_EXPAND);
#define glMatrixFrustumEXT_INDEX 1255
#define glMatrixFrustumEXT_RETURN void
#define glMatrixFrustumEXT_ARG_NAMES mode, left, right, bottom, top, zNear, zFar
#define glMatrixFrustumEXT_ARG_EXPAND GLenum mode, GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar
#define glMatrixFrustumEXT_PACKED PACKED_glMatrixFrustumEXT
#define glMatrixFrustumEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMatrixFrustumEXT_NOT_VOID_WRAP(...) {}
#define pack_glMatrixFrustumEXT(_mode, _left, _right, _bottom, _top, _zNear, _zFar) ({ \
    glMatrixFrustumEXT_PACKED *packed_data = malloc(sizeof(glMatrixFrustumEXT_PACKED)); \
    packed_data->index = glMatrixFrustumEXT_INDEX; \
    packed_data->args.mode = (GLenum)_mode; \
    packed_data->args.left = (GLdouble)_left; \
    packed_data->args.right = (GLdouble)_right; \
    packed_data->args.bottom = (GLdouble)_bottom; \
    packed_data->args.top = (GLdouble)_top; \
    packed_data->args.zNear = (GLdouble)_zNear; \
    packed_data->args.zFar = (GLdouble)_zFar; \
    (packed_call_t *)packed_data; \
})
#define call_glMatrixFrustumEXT(packed, ret_v) do { \
    PACKED_glMatrixFrustumEXT *unpacked = (PACKED_glMatrixFrustumEXT *)packed; \
    ARGS_glMatrixFrustumEXT *args = (ARGS_glMatrixFrustumEXT *)&unpacked->args; \
    glMatrixFrustumEXT(args->mode, args->left, args->right, args->bottom, args->top, args->zNear, args->zFar);; \
} while(0)
void glMatrixFrustumEXT(glMatrixFrustumEXT_ARG_EXPAND);
typedef void (*glMatrixFrustumEXT_PTR)(glMatrixFrustumEXT_ARG_EXPAND);
#define glMatrixIndexPointerARB_INDEX 1256
#define glMatrixIndexPointerARB_RETURN void
#define glMatrixIndexPointerARB_ARG_NAMES size, type, stride, pointer
#define glMatrixIndexPointerARB_ARG_EXPAND GLint size, GLenum type, GLsizei stride, const GLvoid * pointer
#define glMatrixIndexPointerARB_PACKED PACKED_glMatrixIndexPointerARB
#define glMatrixIndexPointerARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMatrixIndexPointerARB_NOT_VOID_WRAP(...) {}
#define pack_glMatrixIndexPointerARB(_size, _type, _stride, _pointer) ({ \
    glMatrixIndexPointerARB_PACKED *packed_data = malloc(sizeof(glMatrixIndexPointerARB_PACKED)); \
    packed_data->index = glMatrixIndexPointerARB_INDEX; \
    packed_data->args.size = (GLint)_size; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.stride = (GLsizei)_stride; \
    packed_data->args.pointer = (GLvoid *)_pointer; \
    (packed_call_t *)packed_data; \
})
#define call_glMatrixIndexPointerARB(packed, ret_v) do { \
    PACKED_glMatrixIndexPointerARB *unpacked = (PACKED_glMatrixIndexPointerARB *)packed; \
    ARGS_glMatrixIndexPointerARB *args = (ARGS_glMatrixIndexPointerARB *)&unpacked->args; \
    glMatrixIndexPointerARB(args->size, args->type, args->stride, args->pointer);; \
} while(0)
void glMatrixIndexPointerARB(glMatrixIndexPointerARB_ARG_EXPAND);
typedef void (*glMatrixIndexPointerARB_PTR)(glMatrixIndexPointerARB_ARG_EXPAND);
#define glMatrixIndexubvARB_INDEX 1257
#define glMatrixIndexubvARB_RETURN void
#define glMatrixIndexubvARB_ARG_NAMES size, indices
#define glMatrixIndexubvARB_ARG_EXPAND GLint size, const GLubyte * indices
#define glMatrixIndexubvARB_PACKED PACKED_glMatrixIndexubvARB
#define glMatrixIndexubvARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMatrixIndexubvARB_NOT_VOID_WRAP(...) {}
#define pack_glMatrixIndexubvARB(_size, _indices) ({ \
    glMatrixIndexubvARB_PACKED *packed_data = malloc(sizeof(glMatrixIndexubvARB_PACKED)); \
    packed_data->index = glMatrixIndexubvARB_INDEX; \
    packed_data->args.size = (GLint)_size; \
    packed_data->args.indices = (GLubyte *)_indices; \
    (packed_call_t *)packed_data; \
})
#define call_glMatrixIndexubvARB(packed, ret_v) do { \
    PACKED_glMatrixIndexubvARB *unpacked = (PACKED_glMatrixIndexubvARB *)packed; \
    ARGS_glMatrixIndexubvARB *args = (ARGS_glMatrixIndexubvARB *)&unpacked->args; \
    glMatrixIndexubvARB(args->size, args->indices);; \
} while(0)
void glMatrixIndexubvARB(glMatrixIndexubvARB_ARG_EXPAND);
typedef void (*glMatrixIndexubvARB_PTR)(glMatrixIndexubvARB_ARG_EXPAND);
#define glMatrixIndexuivARB_INDEX 1258
#define glMatrixIndexuivARB_RETURN void
#define glMatrixIndexuivARB_ARG_NAMES size, indices
#define glMatrixIndexuivARB_ARG_EXPAND GLint size, const GLuint * indices
#define glMatrixIndexuivARB_PACKED PACKED_glMatrixIndexuivARB
#define glMatrixIndexuivARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMatrixIndexuivARB_NOT_VOID_WRAP(...) {}
#define pack_glMatrixIndexuivARB(_size, _indices) ({ \
    glMatrixIndexuivARB_PACKED *packed_data = malloc(sizeof(glMatrixIndexuivARB_PACKED)); \
    packed_data->index = glMatrixIndexuivARB_INDEX; \
    packed_data->args.size = (GLint)_size; \
    packed_data->args.indices = (GLuint *)_indices; \
    (packed_call_t *)packed_data; \
})
#define call_glMatrixIndexuivARB(packed, ret_v) do { \
    PACKED_glMatrixIndexuivARB *unpacked = (PACKED_glMatrixIndexuivARB *)packed; \
    ARGS_glMatrixIndexuivARB *args = (ARGS_glMatrixIndexuivARB *)&unpacked->args; \
    glMatrixIndexuivARB(args->size, args->indices);; \
} while(0)
void glMatrixIndexuivARB(glMatrixIndexuivARB_ARG_EXPAND);
typedef void (*glMatrixIndexuivARB_PTR)(glMatrixIndexuivARB_ARG_EXPAND);
#define glMatrixIndexusvARB_INDEX 1259
#define glMatrixIndexusvARB_RETURN void
#define glMatrixIndexusvARB_ARG_NAMES size, indices
#define glMatrixIndexusvARB_ARG_EXPAND GLint size, const GLushort * indices
#define glMatrixIndexusvARB_PACKED PACKED_glMatrixIndexusvARB
#define glMatrixIndexusvARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMatrixIndexusvARB_NOT_VOID_WRAP(...) {}
#define pack_glMatrixIndexusvARB(_size, _indices) ({ \
    glMatrixIndexusvARB_PACKED *packed_data = malloc(sizeof(glMatrixIndexusvARB_PACKED)); \
    packed_data->index = glMatrixIndexusvARB_INDEX; \
    packed_data->args.size = (GLint)_size; \
    packed_data->args.indices = (GLushort *)_indices; \
    (packed_call_t *)packed_data; \
})
#define call_glMatrixIndexusvARB(packed, ret_v) do { \
    PACKED_glMatrixIndexusvARB *unpacked = (PACKED_glMatrixIndexusvARB *)packed; \
    ARGS_glMatrixIndexusvARB *args = (ARGS_glMatrixIndexusvARB *)&unpacked->args; \
    glMatrixIndexusvARB(args->size, args->indices);; \
} while(0)
void glMatrixIndexusvARB(glMatrixIndexusvARB_ARG_EXPAND);
typedef void (*glMatrixIndexusvARB_PTR)(glMatrixIndexusvARB_ARG_EXPAND);
#define glMatrixLoadIdentityEXT_INDEX 1260
#define glMatrixLoadIdentityEXT_RETURN void
#define glMatrixLoadIdentityEXT_ARG_NAMES mode
#define glMatrixLoadIdentityEXT_ARG_EXPAND GLenum mode
#define glMatrixLoadIdentityEXT_PACKED PACKED_glMatrixLoadIdentityEXT
#define glMatrixLoadIdentityEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMatrixLoadIdentityEXT_NOT_VOID_WRAP(...) {}
#define pack_glMatrixLoadIdentityEXT(_mode) ({ \
    glMatrixLoadIdentityEXT_PACKED *packed_data = malloc(sizeof(glMatrixLoadIdentityEXT_PACKED)); \
    packed_data->index = glMatrixLoadIdentityEXT_INDEX; \
    packed_data->args.mode = (GLenum)_mode; \
    (packed_call_t *)packed_data; \
})
#define call_glMatrixLoadIdentityEXT(packed, ret_v) do { \
    PACKED_glMatrixLoadIdentityEXT *unpacked = (PACKED_glMatrixLoadIdentityEXT *)packed; \
    ARGS_glMatrixLoadIdentityEXT *args = (ARGS_glMatrixLoadIdentityEXT *)&unpacked->args; \
    glMatrixLoadIdentityEXT(args->mode);; \
} while(0)
void glMatrixLoadIdentityEXT(glMatrixLoadIdentityEXT_ARG_EXPAND);
typedef void (*glMatrixLoadIdentityEXT_PTR)(glMatrixLoadIdentityEXT_ARG_EXPAND);
#define glMatrixLoadTransposedEXT_INDEX 1261
#define glMatrixLoadTransposedEXT_RETURN void
#define glMatrixLoadTransposedEXT_ARG_NAMES mode, m
#define glMatrixLoadTransposedEXT_ARG_EXPAND GLenum mode, const GLdouble * m
#define glMatrixLoadTransposedEXT_PACKED PACKED_glMatrixLoadTransposedEXT
#define glMatrixLoadTransposedEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMatrixLoadTransposedEXT_NOT_VOID_WRAP(...) {}
#define pack_glMatrixLoadTransposedEXT(_mode, _m) ({ \
    glMatrixLoadTransposedEXT_PACKED *packed_data = malloc(sizeof(glMatrixLoadTransposedEXT_PACKED)); \
    packed_data->index = glMatrixLoadTransposedEXT_INDEX; \
    packed_data->args.mode = (GLenum)_mode; \
    packed_data->args.m = (GLdouble *)_m; \
    (packed_call_t *)packed_data; \
})
#define call_glMatrixLoadTransposedEXT(packed, ret_v) do { \
    PACKED_glMatrixLoadTransposedEXT *unpacked = (PACKED_glMatrixLoadTransposedEXT *)packed; \
    ARGS_glMatrixLoadTransposedEXT *args = (ARGS_glMatrixLoadTransposedEXT *)&unpacked->args; \
    glMatrixLoadTransposedEXT(args->mode, args->m);; \
} while(0)
void glMatrixLoadTransposedEXT(glMatrixLoadTransposedEXT_ARG_EXPAND);
typedef void (*glMatrixLoadTransposedEXT_PTR)(glMatrixLoadTransposedEXT_ARG_EXPAND);
#define glMatrixLoadTransposefEXT_INDEX 1262
#define glMatrixLoadTransposefEXT_RETURN void
#define glMatrixLoadTransposefEXT_ARG_NAMES mode, m
#define glMatrixLoadTransposefEXT_ARG_EXPAND GLenum mode, const GLfloat * m
#define glMatrixLoadTransposefEXT_PACKED PACKED_glMatrixLoadTransposefEXT
#define glMatrixLoadTransposefEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMatrixLoadTransposefEXT_NOT_VOID_WRAP(...) {}
#define pack_glMatrixLoadTransposefEXT(_mode, _m) ({ \
    glMatrixLoadTransposefEXT_PACKED *packed_data = malloc(sizeof(glMatrixLoadTransposefEXT_PACKED)); \
    packed_data->index = glMatrixLoadTransposefEXT_INDEX; \
    packed_data->args.mode = (GLenum)_mode; \
    packed_data->args.m = (GLfloat *)_m; \
    (packed_call_t *)packed_data; \
})
#define call_glMatrixLoadTransposefEXT(packed, ret_v) do { \
    PACKED_glMatrixLoadTransposefEXT *unpacked = (PACKED_glMatrixLoadTransposefEXT *)packed; \
    ARGS_glMatrixLoadTransposefEXT *args = (ARGS_glMatrixLoadTransposefEXT *)&unpacked->args; \
    glMatrixLoadTransposefEXT(args->mode, args->m);; \
} while(0)
void glMatrixLoadTransposefEXT(glMatrixLoadTransposefEXT_ARG_EXPAND);
typedef void (*glMatrixLoadTransposefEXT_PTR)(glMatrixLoadTransposefEXT_ARG_EXPAND);
#define glMatrixLoaddEXT_INDEX 1263
#define glMatrixLoaddEXT_RETURN void
#define glMatrixLoaddEXT_ARG_NAMES mode, m
#define glMatrixLoaddEXT_ARG_EXPAND GLenum mode, const GLdouble * m
#define glMatrixLoaddEXT_PACKED PACKED_glMatrixLoaddEXT
#define glMatrixLoaddEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMatrixLoaddEXT_NOT_VOID_WRAP(...) {}
#define pack_glMatrixLoaddEXT(_mode, _m) ({ \
    glMatrixLoaddEXT_PACKED *packed_data = malloc(sizeof(glMatrixLoaddEXT_PACKED)); \
    packed_data->index = glMatrixLoaddEXT_INDEX; \
    packed_data->args.mode = (GLenum)_mode; \
    packed_data->args.m = (GLdouble *)_m; \
    (packed_call_t *)packed_data; \
})
#define call_glMatrixLoaddEXT(packed, ret_v) do { \
    PACKED_glMatrixLoaddEXT *unpacked = (PACKED_glMatrixLoaddEXT *)packed; \
    ARGS_glMatrixLoaddEXT *args = (ARGS_glMatrixLoaddEXT *)&unpacked->args; \
    glMatrixLoaddEXT(args->mode, args->m);; \
} while(0)
void glMatrixLoaddEXT(glMatrixLoaddEXT_ARG_EXPAND);
typedef void (*glMatrixLoaddEXT_PTR)(glMatrixLoaddEXT_ARG_EXPAND);
#define glMatrixLoadfEXT_INDEX 1264
#define glMatrixLoadfEXT_RETURN void
#define glMatrixLoadfEXT_ARG_NAMES mode, m
#define glMatrixLoadfEXT_ARG_EXPAND GLenum mode, const GLfloat * m
#define glMatrixLoadfEXT_PACKED PACKED_glMatrixLoadfEXT
#define glMatrixLoadfEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMatrixLoadfEXT_NOT_VOID_WRAP(...) {}
#define pack_glMatrixLoadfEXT(_mode, _m) ({ \
    glMatrixLoadfEXT_PACKED *packed_data = malloc(sizeof(glMatrixLoadfEXT_PACKED)); \
    packed_data->index = glMatrixLoadfEXT_INDEX; \
    packed_data->args.mode = (GLenum)_mode; \
    packed_data->args.m = (GLfloat *)_m; \
    (packed_call_t *)packed_data; \
})
#define call_glMatrixLoadfEXT(packed, ret_v) do { \
    PACKED_glMatrixLoadfEXT *unpacked = (PACKED_glMatrixLoadfEXT *)packed; \
    ARGS_glMatrixLoadfEXT *args = (ARGS_glMatrixLoadfEXT *)&unpacked->args; \
    glMatrixLoadfEXT(args->mode, args->m);; \
} while(0)
void glMatrixLoadfEXT(glMatrixLoadfEXT_ARG_EXPAND);
typedef void (*glMatrixLoadfEXT_PTR)(glMatrixLoadfEXT_ARG_EXPAND);
#define glMatrixMode_INDEX 1265
#define glMatrixMode_RETURN void
#define glMatrixMode_ARG_NAMES mode
#define glMatrixMode_ARG_EXPAND GLenum mode
#define glMatrixMode_PACKED PACKED_glMatrixMode
#define glMatrixMode_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMatrixMode_NOT_VOID_WRAP(...) {}
#define pack_glMatrixMode(_mode) ({ \
    glMatrixMode_PACKED *packed_data = malloc(sizeof(glMatrixMode_PACKED)); \
    packed_data->index = glMatrixMode_INDEX; \
    packed_data->args.mode = (GLenum)_mode; \
    (packed_call_t *)packed_data; \
})
#define call_glMatrixMode(packed, ret_v) do { \
    PACKED_glMatrixMode *unpacked = (PACKED_glMatrixMode *)packed; \
    ARGS_glMatrixMode *args = (ARGS_glMatrixMode *)&unpacked->args; \
    glMatrixMode(args->mode);; \
} while(0)
void glMatrixMode(glMatrixMode_ARG_EXPAND);
typedef void (*glMatrixMode_PTR)(glMatrixMode_ARG_EXPAND);
#define glMatrixMultTransposedEXT_INDEX 1266
#define glMatrixMultTransposedEXT_RETURN void
#define glMatrixMultTransposedEXT_ARG_NAMES mode, m
#define glMatrixMultTransposedEXT_ARG_EXPAND GLenum mode, const GLdouble * m
#define glMatrixMultTransposedEXT_PACKED PACKED_glMatrixMultTransposedEXT
#define glMatrixMultTransposedEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMatrixMultTransposedEXT_NOT_VOID_WRAP(...) {}
#define pack_glMatrixMultTransposedEXT(_mode, _m) ({ \
    glMatrixMultTransposedEXT_PACKED *packed_data = malloc(sizeof(glMatrixMultTransposedEXT_PACKED)); \
    packed_data->index = glMatrixMultTransposedEXT_INDEX; \
    packed_data->args.mode = (GLenum)_mode; \
    packed_data->args.m = (GLdouble *)_m; \
    (packed_call_t *)packed_data; \
})
#define call_glMatrixMultTransposedEXT(packed, ret_v) do { \
    PACKED_glMatrixMultTransposedEXT *unpacked = (PACKED_glMatrixMultTransposedEXT *)packed; \
    ARGS_glMatrixMultTransposedEXT *args = (ARGS_glMatrixMultTransposedEXT *)&unpacked->args; \
    glMatrixMultTransposedEXT(args->mode, args->m);; \
} while(0)
void glMatrixMultTransposedEXT(glMatrixMultTransposedEXT_ARG_EXPAND);
typedef void (*glMatrixMultTransposedEXT_PTR)(glMatrixMultTransposedEXT_ARG_EXPAND);
#define glMatrixMultTransposefEXT_INDEX 1267
#define glMatrixMultTransposefEXT_RETURN void
#define glMatrixMultTransposefEXT_ARG_NAMES mode, m
#define glMatrixMultTransposefEXT_ARG_EXPAND GLenum mode, const GLfloat * m
#define glMatrixMultTransposefEXT_PACKED PACKED_glMatrixMultTransposefEXT
#define glMatrixMultTransposefEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMatrixMultTransposefEXT_NOT_VOID_WRAP(...) {}
#define pack_glMatrixMultTransposefEXT(_mode, _m) ({ \
    glMatrixMultTransposefEXT_PACKED *packed_data = malloc(sizeof(glMatrixMultTransposefEXT_PACKED)); \
    packed_data->index = glMatrixMultTransposefEXT_INDEX; \
    packed_data->args.mode = (GLenum)_mode; \
    packed_data->args.m = (GLfloat *)_m; \
    (packed_call_t *)packed_data; \
})
#define call_glMatrixMultTransposefEXT(packed, ret_v) do { \
    PACKED_glMatrixMultTransposefEXT *unpacked = (PACKED_glMatrixMultTransposefEXT *)packed; \
    ARGS_glMatrixMultTransposefEXT *args = (ARGS_glMatrixMultTransposefEXT *)&unpacked->args; \
    glMatrixMultTransposefEXT(args->mode, args->m);; \
} while(0)
void glMatrixMultTransposefEXT(glMatrixMultTransposefEXT_ARG_EXPAND);
typedef void (*glMatrixMultTransposefEXT_PTR)(glMatrixMultTransposefEXT_ARG_EXPAND);
#define glMatrixMultdEXT_INDEX 1268
#define glMatrixMultdEXT_RETURN void
#define glMatrixMultdEXT_ARG_NAMES mode, m
#define glMatrixMultdEXT_ARG_EXPAND GLenum mode, const GLdouble * m
#define glMatrixMultdEXT_PACKED PACKED_glMatrixMultdEXT
#define glMatrixMultdEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMatrixMultdEXT_NOT_VOID_WRAP(...) {}
#define pack_glMatrixMultdEXT(_mode, _m) ({ \
    glMatrixMultdEXT_PACKED *packed_data = malloc(sizeof(glMatrixMultdEXT_PACKED)); \
    packed_data->index = glMatrixMultdEXT_INDEX; \
    packed_data->args.mode = (GLenum)_mode; \
    packed_data->args.m = (GLdouble *)_m; \
    (packed_call_t *)packed_data; \
})
#define call_glMatrixMultdEXT(packed, ret_v) do { \
    PACKED_glMatrixMultdEXT *unpacked = (PACKED_glMatrixMultdEXT *)packed; \
    ARGS_glMatrixMultdEXT *args = (ARGS_glMatrixMultdEXT *)&unpacked->args; \
    glMatrixMultdEXT(args->mode, args->m);; \
} while(0)
void glMatrixMultdEXT(glMatrixMultdEXT_ARG_EXPAND);
typedef void (*glMatrixMultdEXT_PTR)(glMatrixMultdEXT_ARG_EXPAND);
#define glMatrixMultfEXT_INDEX 1269
#define glMatrixMultfEXT_RETURN void
#define glMatrixMultfEXT_ARG_NAMES mode, m
#define glMatrixMultfEXT_ARG_EXPAND GLenum mode, const GLfloat * m
#define glMatrixMultfEXT_PACKED PACKED_glMatrixMultfEXT
#define glMatrixMultfEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMatrixMultfEXT_NOT_VOID_WRAP(...) {}
#define pack_glMatrixMultfEXT(_mode, _m) ({ \
    glMatrixMultfEXT_PACKED *packed_data = malloc(sizeof(glMatrixMultfEXT_PACKED)); \
    packed_data->index = glMatrixMultfEXT_INDEX; \
    packed_data->args.mode = (GLenum)_mode; \
    packed_data->args.m = (GLfloat *)_m; \
    (packed_call_t *)packed_data; \
})
#define call_glMatrixMultfEXT(packed, ret_v) do { \
    PACKED_glMatrixMultfEXT *unpacked = (PACKED_glMatrixMultfEXT *)packed; \
    ARGS_glMatrixMultfEXT *args = (ARGS_glMatrixMultfEXT *)&unpacked->args; \
    glMatrixMultfEXT(args->mode, args->m);; \
} while(0)
void glMatrixMultfEXT(glMatrixMultfEXT_ARG_EXPAND);
typedef void (*glMatrixMultfEXT_PTR)(glMatrixMultfEXT_ARG_EXPAND);
#define glMatrixOrthoEXT_INDEX 1270
#define glMatrixOrthoEXT_RETURN void
#define glMatrixOrthoEXT_ARG_NAMES mode, left, right, bottom, top, zNear, zFar
#define glMatrixOrthoEXT_ARG_EXPAND GLenum mode, GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar
#define glMatrixOrthoEXT_PACKED PACKED_glMatrixOrthoEXT
#define glMatrixOrthoEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMatrixOrthoEXT_NOT_VOID_WRAP(...) {}
#define pack_glMatrixOrthoEXT(_mode, _left, _right, _bottom, _top, _zNear, _zFar) ({ \
    glMatrixOrthoEXT_PACKED *packed_data = malloc(sizeof(glMatrixOrthoEXT_PACKED)); \
    packed_data->index = glMatrixOrthoEXT_INDEX; \
    packed_data->args.mode = (GLenum)_mode; \
    packed_data->args.left = (GLdouble)_left; \
    packed_data->args.right = (GLdouble)_right; \
    packed_data->args.bottom = (GLdouble)_bottom; \
    packed_data->args.top = (GLdouble)_top; \
    packed_data->args.zNear = (GLdouble)_zNear; \
    packed_data->args.zFar = (GLdouble)_zFar; \
    (packed_call_t *)packed_data; \
})
#define call_glMatrixOrthoEXT(packed, ret_v) do { \
    PACKED_glMatrixOrthoEXT *unpacked = (PACKED_glMatrixOrthoEXT *)packed; \
    ARGS_glMatrixOrthoEXT *args = (ARGS_glMatrixOrthoEXT *)&unpacked->args; \
    glMatrixOrthoEXT(args->mode, args->left, args->right, args->bottom, args->top, args->zNear, args->zFar);; \
} while(0)
void glMatrixOrthoEXT(glMatrixOrthoEXT_ARG_EXPAND);
typedef void (*glMatrixOrthoEXT_PTR)(glMatrixOrthoEXT_ARG_EXPAND);
#define glMatrixPopEXT_INDEX 1271
#define glMatrixPopEXT_RETURN void
#define glMatrixPopEXT_ARG_NAMES mode
#define glMatrixPopEXT_ARG_EXPAND GLenum mode
#define glMatrixPopEXT_PACKED PACKED_glMatrixPopEXT
#define glMatrixPopEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMatrixPopEXT_NOT_VOID_WRAP(...) {}
#define pack_glMatrixPopEXT(_mode) ({ \
    glMatrixPopEXT_PACKED *packed_data = malloc(sizeof(glMatrixPopEXT_PACKED)); \
    packed_data->index = glMatrixPopEXT_INDEX; \
    packed_data->args.mode = (GLenum)_mode; \
    (packed_call_t *)packed_data; \
})
#define call_glMatrixPopEXT(packed, ret_v) do { \
    PACKED_glMatrixPopEXT *unpacked = (PACKED_glMatrixPopEXT *)packed; \
    ARGS_glMatrixPopEXT *args = (ARGS_glMatrixPopEXT *)&unpacked->args; \
    glMatrixPopEXT(args->mode);; \
} while(0)
void glMatrixPopEXT(glMatrixPopEXT_ARG_EXPAND);
typedef void (*glMatrixPopEXT_PTR)(glMatrixPopEXT_ARG_EXPAND);
#define glMatrixPushEXT_INDEX 1272
#define glMatrixPushEXT_RETURN void
#define glMatrixPushEXT_ARG_NAMES mode
#define glMatrixPushEXT_ARG_EXPAND GLenum mode
#define glMatrixPushEXT_PACKED PACKED_glMatrixPushEXT
#define glMatrixPushEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMatrixPushEXT_NOT_VOID_WRAP(...) {}
#define pack_glMatrixPushEXT(_mode) ({ \
    glMatrixPushEXT_PACKED *packed_data = malloc(sizeof(glMatrixPushEXT_PACKED)); \
    packed_data->index = glMatrixPushEXT_INDEX; \
    packed_data->args.mode = (GLenum)_mode; \
    (packed_call_t *)packed_data; \
})
#define call_glMatrixPushEXT(packed, ret_v) do { \
    PACKED_glMatrixPushEXT *unpacked = (PACKED_glMatrixPushEXT *)packed; \
    ARGS_glMatrixPushEXT *args = (ARGS_glMatrixPushEXT *)&unpacked->args; \
    glMatrixPushEXT(args->mode);; \
} while(0)
void glMatrixPushEXT(glMatrixPushEXT_ARG_EXPAND);
typedef void (*glMatrixPushEXT_PTR)(glMatrixPushEXT_ARG_EXPAND);
#define glMatrixRotatedEXT_INDEX 1273
#define glMatrixRotatedEXT_RETURN void
#define glMatrixRotatedEXT_ARG_NAMES mode, angle, x, y, z
#define glMatrixRotatedEXT_ARG_EXPAND GLenum mode, GLdouble angle, GLdouble x, GLdouble y, GLdouble z
#define glMatrixRotatedEXT_PACKED PACKED_glMatrixRotatedEXT
#define glMatrixRotatedEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMatrixRotatedEXT_NOT_VOID_WRAP(...) {}
#define pack_glMatrixRotatedEXT(_mode, _angle, _x, _y, _z) ({ \
    glMatrixRotatedEXT_PACKED *packed_data = malloc(sizeof(glMatrixRotatedEXT_PACKED)); \
    packed_data->index = glMatrixRotatedEXT_INDEX; \
    packed_data->args.mode = (GLenum)_mode; \
    packed_data->args.angle = (GLdouble)_angle; \
    packed_data->args.x = (GLdouble)_x; \
    packed_data->args.y = (GLdouble)_y; \
    packed_data->args.z = (GLdouble)_z; \
    (packed_call_t *)packed_data; \
})
#define call_glMatrixRotatedEXT(packed, ret_v) do { \
    PACKED_glMatrixRotatedEXT *unpacked = (PACKED_glMatrixRotatedEXT *)packed; \
    ARGS_glMatrixRotatedEXT *args = (ARGS_glMatrixRotatedEXT *)&unpacked->args; \
    glMatrixRotatedEXT(args->mode, args->angle, args->x, args->y, args->z);; \
} while(0)
void glMatrixRotatedEXT(glMatrixRotatedEXT_ARG_EXPAND);
typedef void (*glMatrixRotatedEXT_PTR)(glMatrixRotatedEXT_ARG_EXPAND);
#define glMatrixRotatefEXT_INDEX 1274
#define glMatrixRotatefEXT_RETURN void
#define glMatrixRotatefEXT_ARG_NAMES mode, angle, x, y, z
#define glMatrixRotatefEXT_ARG_EXPAND GLenum mode, GLfloat angle, GLfloat x, GLfloat y, GLfloat z
#define glMatrixRotatefEXT_PACKED PACKED_glMatrixRotatefEXT
#define glMatrixRotatefEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMatrixRotatefEXT_NOT_VOID_WRAP(...) {}
#define pack_glMatrixRotatefEXT(_mode, _angle, _x, _y, _z) ({ \
    glMatrixRotatefEXT_PACKED *packed_data = malloc(sizeof(glMatrixRotatefEXT_PACKED)); \
    packed_data->index = glMatrixRotatefEXT_INDEX; \
    packed_data->args.mode = (GLenum)_mode; \
    packed_data->args.angle = (GLfloat)_angle; \
    packed_data->args.x = (GLfloat)_x; \
    packed_data->args.y = (GLfloat)_y; \
    packed_data->args.z = (GLfloat)_z; \
    (packed_call_t *)packed_data; \
})
#define call_glMatrixRotatefEXT(packed, ret_v) do { \
    PACKED_glMatrixRotatefEXT *unpacked = (PACKED_glMatrixRotatefEXT *)packed; \
    ARGS_glMatrixRotatefEXT *args = (ARGS_glMatrixRotatefEXT *)&unpacked->args; \
    glMatrixRotatefEXT(args->mode, args->angle, args->x, args->y, args->z);; \
} while(0)
void glMatrixRotatefEXT(glMatrixRotatefEXT_ARG_EXPAND);
typedef void (*glMatrixRotatefEXT_PTR)(glMatrixRotatefEXT_ARG_EXPAND);
#define glMatrixScaledEXT_INDEX 1275
#define glMatrixScaledEXT_RETURN void
#define glMatrixScaledEXT_ARG_NAMES mode, x, y, z
#define glMatrixScaledEXT_ARG_EXPAND GLenum mode, GLdouble x, GLdouble y, GLdouble z
#define glMatrixScaledEXT_PACKED PACKED_glMatrixScaledEXT
#define glMatrixScaledEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMatrixScaledEXT_NOT_VOID_WRAP(...) {}
#define pack_glMatrixScaledEXT(_mode, _x, _y, _z) ({ \
    glMatrixScaledEXT_PACKED *packed_data = malloc(sizeof(glMatrixScaledEXT_PACKED)); \
    packed_data->index = glMatrixScaledEXT_INDEX; \
    packed_data->args.mode = (GLenum)_mode; \
    packed_data->args.x = (GLdouble)_x; \
    packed_data->args.y = (GLdouble)_y; \
    packed_data->args.z = (GLdouble)_z; \
    (packed_call_t *)packed_data; \
})
#define call_glMatrixScaledEXT(packed, ret_v) do { \
    PACKED_glMatrixScaledEXT *unpacked = (PACKED_glMatrixScaledEXT *)packed; \
    ARGS_glMatrixScaledEXT *args = (ARGS_glMatrixScaledEXT *)&unpacked->args; \
    glMatrixScaledEXT(args->mode, args->x, args->y, args->z);; \
} while(0)
void glMatrixScaledEXT(glMatrixScaledEXT_ARG_EXPAND);
typedef void (*glMatrixScaledEXT_PTR)(glMatrixScaledEXT_ARG_EXPAND);
#define glMatrixScalefEXT_INDEX 1276
#define glMatrixScalefEXT_RETURN void
#define glMatrixScalefEXT_ARG_NAMES mode, x, y, z
#define glMatrixScalefEXT_ARG_EXPAND GLenum mode, GLfloat x, GLfloat y, GLfloat z
#define glMatrixScalefEXT_PACKED PACKED_glMatrixScalefEXT
#define glMatrixScalefEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMatrixScalefEXT_NOT_VOID_WRAP(...) {}
#define pack_glMatrixScalefEXT(_mode, _x, _y, _z) ({ \
    glMatrixScalefEXT_PACKED *packed_data = malloc(sizeof(glMatrixScalefEXT_PACKED)); \
    packed_data->index = glMatrixScalefEXT_INDEX; \
    packed_data->args.mode = (GLenum)_mode; \
    packed_data->args.x = (GLfloat)_x; \
    packed_data->args.y = (GLfloat)_y; \
    packed_data->args.z = (GLfloat)_z; \
    (packed_call_t *)packed_data; \
})
#define call_glMatrixScalefEXT(packed, ret_v) do { \
    PACKED_glMatrixScalefEXT *unpacked = (PACKED_glMatrixScalefEXT *)packed; \
    ARGS_glMatrixScalefEXT *args = (ARGS_glMatrixScalefEXT *)&unpacked->args; \
    glMatrixScalefEXT(args->mode, args->x, args->y, args->z);; \
} while(0)
void glMatrixScalefEXT(glMatrixScalefEXT_ARG_EXPAND);
typedef void (*glMatrixScalefEXT_PTR)(glMatrixScalefEXT_ARG_EXPAND);
#define glMatrixTranslatedEXT_INDEX 1277
#define glMatrixTranslatedEXT_RETURN void
#define glMatrixTranslatedEXT_ARG_NAMES mode, x, y, z
#define glMatrixTranslatedEXT_ARG_EXPAND GLenum mode, GLdouble x, GLdouble y, GLdouble z
#define glMatrixTranslatedEXT_PACKED PACKED_glMatrixTranslatedEXT
#define glMatrixTranslatedEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMatrixTranslatedEXT_NOT_VOID_WRAP(...) {}
#define pack_glMatrixTranslatedEXT(_mode, _x, _y, _z) ({ \
    glMatrixTranslatedEXT_PACKED *packed_data = malloc(sizeof(glMatrixTranslatedEXT_PACKED)); \
    packed_data->index = glMatrixTranslatedEXT_INDEX; \
    packed_data->args.mode = (GLenum)_mode; \
    packed_data->args.x = (GLdouble)_x; \
    packed_data->args.y = (GLdouble)_y; \
    packed_data->args.z = (GLdouble)_z; \
    (packed_call_t *)packed_data; \
})
#define call_glMatrixTranslatedEXT(packed, ret_v) do { \
    PACKED_glMatrixTranslatedEXT *unpacked = (PACKED_glMatrixTranslatedEXT *)packed; \
    ARGS_glMatrixTranslatedEXT *args = (ARGS_glMatrixTranslatedEXT *)&unpacked->args; \
    glMatrixTranslatedEXT(args->mode, args->x, args->y, args->z);; \
} while(0)
void glMatrixTranslatedEXT(glMatrixTranslatedEXT_ARG_EXPAND);
typedef void (*glMatrixTranslatedEXT_PTR)(glMatrixTranslatedEXT_ARG_EXPAND);
#define glMatrixTranslatefEXT_INDEX 1278
#define glMatrixTranslatefEXT_RETURN void
#define glMatrixTranslatefEXT_ARG_NAMES mode, x, y, z
#define glMatrixTranslatefEXT_ARG_EXPAND GLenum mode, GLfloat x, GLfloat y, GLfloat z
#define glMatrixTranslatefEXT_PACKED PACKED_glMatrixTranslatefEXT
#define glMatrixTranslatefEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMatrixTranslatefEXT_NOT_VOID_WRAP(...) {}
#define pack_glMatrixTranslatefEXT(_mode, _x, _y, _z) ({ \
    glMatrixTranslatefEXT_PACKED *packed_data = malloc(sizeof(glMatrixTranslatefEXT_PACKED)); \
    packed_data->index = glMatrixTranslatefEXT_INDEX; \
    packed_data->args.mode = (GLenum)_mode; \
    packed_data->args.x = (GLfloat)_x; \
    packed_data->args.y = (GLfloat)_y; \
    packed_data->args.z = (GLfloat)_z; \
    (packed_call_t *)packed_data; \
})
#define call_glMatrixTranslatefEXT(packed, ret_v) do { \
    PACKED_glMatrixTranslatefEXT *unpacked = (PACKED_glMatrixTranslatefEXT *)packed; \
    ARGS_glMatrixTranslatefEXT *args = (ARGS_glMatrixTranslatefEXT *)&unpacked->args; \
    glMatrixTranslatefEXT(args->mode, args->x, args->y, args->z);; \
} while(0)
void glMatrixTranslatefEXT(glMatrixTranslatefEXT_ARG_EXPAND);
typedef void (*glMatrixTranslatefEXT_PTR)(glMatrixTranslatefEXT_ARG_EXPAND);
#define glMemoryBarrier_INDEX 1279
#define glMemoryBarrier_RETURN void
#define glMemoryBarrier_ARG_NAMES barriers
#define glMemoryBarrier_ARG_EXPAND GLbitfield barriers
#define glMemoryBarrier_PACKED PACKED_glMemoryBarrier
#define glMemoryBarrier_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMemoryBarrier_NOT_VOID_WRAP(...) {}
#define pack_glMemoryBarrier(_barriers) ({ \
    glMemoryBarrier_PACKED *packed_data = malloc(sizeof(glMemoryBarrier_PACKED)); \
    packed_data->index = glMemoryBarrier_INDEX; \
    packed_data->args.barriers = (GLbitfield)_barriers; \
    (packed_call_t *)packed_data; \
})
#define call_glMemoryBarrier(packed, ret_v) do { \
    PACKED_glMemoryBarrier *unpacked = (PACKED_glMemoryBarrier *)packed; \
    ARGS_glMemoryBarrier *args = (ARGS_glMemoryBarrier *)&unpacked->args; \
    glMemoryBarrier(args->barriers);; \
} while(0)
void glMemoryBarrier(glMemoryBarrier_ARG_EXPAND);
typedef void (*glMemoryBarrier_PTR)(glMemoryBarrier_ARG_EXPAND);
#define glMemoryBarrierEXT_INDEX 1280
#define glMemoryBarrierEXT_RETURN void
#define glMemoryBarrierEXT_ARG_NAMES barriers
#define glMemoryBarrierEXT_ARG_EXPAND GLbitfield barriers
#define glMemoryBarrierEXT_PACKED PACKED_glMemoryBarrierEXT
#define glMemoryBarrierEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMemoryBarrierEXT_NOT_VOID_WRAP(...) {}
#define pack_glMemoryBarrierEXT(_barriers) ({ \
    glMemoryBarrierEXT_PACKED *packed_data = malloc(sizeof(glMemoryBarrierEXT_PACKED)); \
    packed_data->index = glMemoryBarrierEXT_INDEX; \
    packed_data->args.barriers = (GLbitfield)_barriers; \
    (packed_call_t *)packed_data; \
})
#define call_glMemoryBarrierEXT(packed, ret_v) do { \
    PACKED_glMemoryBarrierEXT *unpacked = (PACKED_glMemoryBarrierEXT *)packed; \
    ARGS_glMemoryBarrierEXT *args = (ARGS_glMemoryBarrierEXT *)&unpacked->args; \
    glMemoryBarrierEXT(args->barriers);; \
} while(0)
void glMemoryBarrierEXT(glMemoryBarrierEXT_ARG_EXPAND);
typedef void (*glMemoryBarrierEXT_PTR)(glMemoryBarrierEXT_ARG_EXPAND);
#define glMinSampleShading_INDEX 1281
#define glMinSampleShading_RETURN void
#define glMinSampleShading_ARG_NAMES value
#define glMinSampleShading_ARG_EXPAND GLfloat value
#define glMinSampleShading_PACKED PACKED_glMinSampleShading
#define glMinSampleShading_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMinSampleShading_NOT_VOID_WRAP(...) {}
#define pack_glMinSampleShading(_value) ({ \
    glMinSampleShading_PACKED *packed_data = malloc(sizeof(glMinSampleShading_PACKED)); \
    packed_data->index = glMinSampleShading_INDEX; \
    packed_data->args.value = (GLfloat)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glMinSampleShading(packed, ret_v) do { \
    PACKED_glMinSampleShading *unpacked = (PACKED_glMinSampleShading *)packed; \
    ARGS_glMinSampleShading *args = (ARGS_glMinSampleShading *)&unpacked->args; \
    glMinSampleShading(args->value);; \
} while(0)
void glMinSampleShading(glMinSampleShading_ARG_EXPAND);
typedef void (*glMinSampleShading_PTR)(glMinSampleShading_ARG_EXPAND);
#define glMinSampleShadingARB_INDEX 1282
#define glMinSampleShadingARB_RETURN void
#define glMinSampleShadingARB_ARG_NAMES value
#define glMinSampleShadingARB_ARG_EXPAND GLfloat value
#define glMinSampleShadingARB_PACKED PACKED_glMinSampleShadingARB
#define glMinSampleShadingARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMinSampleShadingARB_NOT_VOID_WRAP(...) {}
#define pack_glMinSampleShadingARB(_value) ({ \
    glMinSampleShadingARB_PACKED *packed_data = malloc(sizeof(glMinSampleShadingARB_PACKED)); \
    packed_data->index = glMinSampleShadingARB_INDEX; \
    packed_data->args.value = (GLfloat)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glMinSampleShadingARB(packed, ret_v) do { \
    PACKED_glMinSampleShadingARB *unpacked = (PACKED_glMinSampleShadingARB *)packed; \
    ARGS_glMinSampleShadingARB *args = (ARGS_glMinSampleShadingARB *)&unpacked->args; \
    glMinSampleShadingARB(args->value);; \
} while(0)
void glMinSampleShadingARB(glMinSampleShadingARB_ARG_EXPAND);
typedef void (*glMinSampleShadingARB_PTR)(glMinSampleShadingARB_ARG_EXPAND);
#define glMinmax_INDEX 1283
#define glMinmax_RETURN void
#define glMinmax_ARG_NAMES target, internalformat, sink
#define glMinmax_ARG_EXPAND GLenum target, GLenum internalformat, GLboolean sink
#define glMinmax_PACKED PACKED_glMinmax
#define glMinmax_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMinmax_NOT_VOID_WRAP(...) {}
#define pack_glMinmax(_target, _internalformat, _sink) ({ \
    glMinmax_PACKED *packed_data = malloc(sizeof(glMinmax_PACKED)); \
    packed_data->index = glMinmax_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.internalformat = (GLenum)_internalformat; \
    packed_data->args.sink = (GLboolean)_sink; \
    (packed_call_t *)packed_data; \
})
#define call_glMinmax(packed, ret_v) do { \
    PACKED_glMinmax *unpacked = (PACKED_glMinmax *)packed; \
    ARGS_glMinmax *args = (ARGS_glMinmax *)&unpacked->args; \
    glMinmax(args->target, args->internalformat, args->sink);; \
} while(0)
void glMinmax(glMinmax_ARG_EXPAND);
typedef void (*glMinmax_PTR)(glMinmax_ARG_EXPAND);
#define glMinmaxEXT_INDEX 1284
#define glMinmaxEXT_RETURN void
#define glMinmaxEXT_ARG_NAMES target, internalformat, sink
#define glMinmaxEXT_ARG_EXPAND GLenum target, GLenum internalformat, GLboolean sink
#define glMinmaxEXT_PACKED PACKED_glMinmaxEXT
#define glMinmaxEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMinmaxEXT_NOT_VOID_WRAP(...) {}
#define pack_glMinmaxEXT(_target, _internalformat, _sink) ({ \
    glMinmaxEXT_PACKED *packed_data = malloc(sizeof(glMinmaxEXT_PACKED)); \
    packed_data->index = glMinmaxEXT_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.internalformat = (GLenum)_internalformat; \
    packed_data->args.sink = (GLboolean)_sink; \
    (packed_call_t *)packed_data; \
})
#define call_glMinmaxEXT(packed, ret_v) do { \
    PACKED_glMinmaxEXT *unpacked = (PACKED_glMinmaxEXT *)packed; \
    ARGS_glMinmaxEXT *args = (ARGS_glMinmaxEXT *)&unpacked->args; \
    glMinmaxEXT(args->target, args->internalformat, args->sink);; \
} while(0)
void glMinmaxEXT(glMinmaxEXT_ARG_EXPAND);
typedef void (*glMinmaxEXT_PTR)(glMinmaxEXT_ARG_EXPAND);
#define glMultMatrixd_INDEX 1285
#define glMultMatrixd_RETURN void
#define glMultMatrixd_ARG_NAMES m
#define glMultMatrixd_ARG_EXPAND const GLdouble * m
#define glMultMatrixd_PACKED PACKED_glMultMatrixd
#define glMultMatrixd_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultMatrixd_NOT_VOID_WRAP(...) {}
#define pack_glMultMatrixd(_m) ({ \
    glMultMatrixd_PACKED *packed_data = malloc(sizeof(glMultMatrixd_PACKED)); \
    packed_data->index = glMultMatrixd_INDEX; \
    packed_data->args.m = (GLdouble *)_m; \
    (packed_call_t *)packed_data; \
})
#define call_glMultMatrixd(packed, ret_v) do { \
    PACKED_glMultMatrixd *unpacked = (PACKED_glMultMatrixd *)packed; \
    ARGS_glMultMatrixd *args = (ARGS_glMultMatrixd *)&unpacked->args; \
    glMultMatrixd(args->m);; \
} while(0)
void glMultMatrixd(glMultMatrixd_ARG_EXPAND);
typedef void (*glMultMatrixd_PTR)(glMultMatrixd_ARG_EXPAND);
#define glMultMatrixf_INDEX 1286
#define glMultMatrixf_RETURN void
#define glMultMatrixf_ARG_NAMES m
#define glMultMatrixf_ARG_EXPAND const GLfloat * m
#define glMultMatrixf_PACKED PACKED_glMultMatrixf
#define glMultMatrixf_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultMatrixf_NOT_VOID_WRAP(...) {}
#define pack_glMultMatrixf(_m) ({ \
    glMultMatrixf_PACKED *packed_data = malloc(sizeof(glMultMatrixf_PACKED)); \
    packed_data->index = glMultMatrixf_INDEX; \
    packed_data->args.m = (GLfloat *)_m; \
    (packed_call_t *)packed_data; \
})
#define call_glMultMatrixf(packed, ret_v) do { \
    PACKED_glMultMatrixf *unpacked = (PACKED_glMultMatrixf *)packed; \
    ARGS_glMultMatrixf *args = (ARGS_glMultMatrixf *)&unpacked->args; \
    glMultMatrixf(args->m);; \
} while(0)
void glMultMatrixf(glMultMatrixf_ARG_EXPAND);
typedef void (*glMultMatrixf_PTR)(glMultMatrixf_ARG_EXPAND);
#define glMultMatrixx_INDEX 1287
#define glMultMatrixx_RETURN void
#define glMultMatrixx_ARG_NAMES m
#define glMultMatrixx_ARG_EXPAND const GLfixed * m
#define glMultMatrixx_PACKED PACKED_glMultMatrixx
#define glMultMatrixx_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultMatrixx_NOT_VOID_WRAP(...) {}
#define pack_glMultMatrixx(_m) ({ \
    glMultMatrixx_PACKED *packed_data = malloc(sizeof(glMultMatrixx_PACKED)); \
    packed_data->index = glMultMatrixx_INDEX; \
    packed_data->args.m = (GLfixed *)_m; \
    (packed_call_t *)packed_data; \
})
#define call_glMultMatrixx(packed, ret_v) do { \
    PACKED_glMultMatrixx *unpacked = (PACKED_glMultMatrixx *)packed; \
    ARGS_glMultMatrixx *args = (ARGS_glMultMatrixx *)&unpacked->args; \
    glMultMatrixx(args->m);; \
} while(0)
void glMultMatrixx(glMultMatrixx_ARG_EXPAND);
typedef void (*glMultMatrixx_PTR)(glMultMatrixx_ARG_EXPAND);
#define glMultMatrixxOES_INDEX 1288
#define glMultMatrixxOES_RETURN void
#define glMultMatrixxOES_ARG_NAMES m
#define glMultMatrixxOES_ARG_EXPAND const GLfixed * m
#define glMultMatrixxOES_PACKED PACKED_glMultMatrixxOES
#define glMultMatrixxOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultMatrixxOES_NOT_VOID_WRAP(...) {}
#define pack_glMultMatrixxOES(_m) ({ \
    glMultMatrixxOES_PACKED *packed_data = malloc(sizeof(glMultMatrixxOES_PACKED)); \
    packed_data->index = glMultMatrixxOES_INDEX; \
    packed_data->args.m = (GLfixed *)_m; \
    (packed_call_t *)packed_data; \
})
#define call_glMultMatrixxOES(packed, ret_v) do { \
    PACKED_glMultMatrixxOES *unpacked = (PACKED_glMultMatrixxOES *)packed; \
    ARGS_glMultMatrixxOES *args = (ARGS_glMultMatrixxOES *)&unpacked->args; \
    glMultMatrixxOES(args->m);; \
} while(0)
void glMultMatrixxOES(glMultMatrixxOES_ARG_EXPAND);
typedef void (*glMultMatrixxOES_PTR)(glMultMatrixxOES_ARG_EXPAND);
#define glMultTransposeMatrixd_INDEX 1289
#define glMultTransposeMatrixd_RETURN void
#define glMultTransposeMatrixd_ARG_NAMES m
#define glMultTransposeMatrixd_ARG_EXPAND const GLdouble * m
#define glMultTransposeMatrixd_PACKED PACKED_glMultTransposeMatrixd
#define glMultTransposeMatrixd_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultTransposeMatrixd_NOT_VOID_WRAP(...) {}
#define pack_glMultTransposeMatrixd(_m) ({ \
    glMultTransposeMatrixd_PACKED *packed_data = malloc(sizeof(glMultTransposeMatrixd_PACKED)); \
    packed_data->index = glMultTransposeMatrixd_INDEX; \
    packed_data->args.m = (GLdouble *)_m; \
    (packed_call_t *)packed_data; \
})
#define call_glMultTransposeMatrixd(packed, ret_v) do { \
    PACKED_glMultTransposeMatrixd *unpacked = (PACKED_glMultTransposeMatrixd *)packed; \
    ARGS_glMultTransposeMatrixd *args = (ARGS_glMultTransposeMatrixd *)&unpacked->args; \
    glMultTransposeMatrixd(args->m);; \
} while(0)
void glMultTransposeMatrixd(glMultTransposeMatrixd_ARG_EXPAND);
typedef void (*glMultTransposeMatrixd_PTR)(glMultTransposeMatrixd_ARG_EXPAND);
#define glMultTransposeMatrixdARB_INDEX 1290
#define glMultTransposeMatrixdARB_RETURN void
#define glMultTransposeMatrixdARB_ARG_NAMES m
#define glMultTransposeMatrixdARB_ARG_EXPAND const GLdouble * m
#define glMultTransposeMatrixdARB_PACKED PACKED_glMultTransposeMatrixdARB
#define glMultTransposeMatrixdARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultTransposeMatrixdARB_NOT_VOID_WRAP(...) {}
#define pack_glMultTransposeMatrixdARB(_m) ({ \
    glMultTransposeMatrixdARB_PACKED *packed_data = malloc(sizeof(glMultTransposeMatrixdARB_PACKED)); \
    packed_data->index = glMultTransposeMatrixdARB_INDEX; \
    packed_data->args.m = (GLdouble *)_m; \
    (packed_call_t *)packed_data; \
})
#define call_glMultTransposeMatrixdARB(packed, ret_v) do { \
    PACKED_glMultTransposeMatrixdARB *unpacked = (PACKED_glMultTransposeMatrixdARB *)packed; \
    ARGS_glMultTransposeMatrixdARB *args = (ARGS_glMultTransposeMatrixdARB *)&unpacked->args; \
    glMultTransposeMatrixdARB(args->m);; \
} while(0)
void glMultTransposeMatrixdARB(glMultTransposeMatrixdARB_ARG_EXPAND);
typedef void (*glMultTransposeMatrixdARB_PTR)(glMultTransposeMatrixdARB_ARG_EXPAND);
#define glMultTransposeMatrixf_INDEX 1291
#define glMultTransposeMatrixf_RETURN void
#define glMultTransposeMatrixf_ARG_NAMES m
#define glMultTransposeMatrixf_ARG_EXPAND const GLfloat * m
#define glMultTransposeMatrixf_PACKED PACKED_glMultTransposeMatrixf
#define glMultTransposeMatrixf_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultTransposeMatrixf_NOT_VOID_WRAP(...) {}
#define pack_glMultTransposeMatrixf(_m) ({ \
    glMultTransposeMatrixf_PACKED *packed_data = malloc(sizeof(glMultTransposeMatrixf_PACKED)); \
    packed_data->index = glMultTransposeMatrixf_INDEX; \
    packed_data->args.m = (GLfloat *)_m; \
    (packed_call_t *)packed_data; \
})
#define call_glMultTransposeMatrixf(packed, ret_v) do { \
    PACKED_glMultTransposeMatrixf *unpacked = (PACKED_glMultTransposeMatrixf *)packed; \
    ARGS_glMultTransposeMatrixf *args = (ARGS_glMultTransposeMatrixf *)&unpacked->args; \
    glMultTransposeMatrixf(args->m);; \
} while(0)
void glMultTransposeMatrixf(glMultTransposeMatrixf_ARG_EXPAND);
typedef void (*glMultTransposeMatrixf_PTR)(glMultTransposeMatrixf_ARG_EXPAND);
#define glMultTransposeMatrixfARB_INDEX 1292
#define glMultTransposeMatrixfARB_RETURN void
#define glMultTransposeMatrixfARB_ARG_NAMES m
#define glMultTransposeMatrixfARB_ARG_EXPAND const GLfloat * m
#define glMultTransposeMatrixfARB_PACKED PACKED_glMultTransposeMatrixfARB
#define glMultTransposeMatrixfARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultTransposeMatrixfARB_NOT_VOID_WRAP(...) {}
#define pack_glMultTransposeMatrixfARB(_m) ({ \
    glMultTransposeMatrixfARB_PACKED *packed_data = malloc(sizeof(glMultTransposeMatrixfARB_PACKED)); \
    packed_data->index = glMultTransposeMatrixfARB_INDEX; \
    packed_data->args.m = (GLfloat *)_m; \
    (packed_call_t *)packed_data; \
})
#define call_glMultTransposeMatrixfARB(packed, ret_v) do { \
    PACKED_glMultTransposeMatrixfARB *unpacked = (PACKED_glMultTransposeMatrixfARB *)packed; \
    ARGS_glMultTransposeMatrixfARB *args = (ARGS_glMultTransposeMatrixfARB *)&unpacked->args; \
    glMultTransposeMatrixfARB(args->m);; \
} while(0)
void glMultTransposeMatrixfARB(glMultTransposeMatrixfARB_ARG_EXPAND);
typedef void (*glMultTransposeMatrixfARB_PTR)(glMultTransposeMatrixfARB_ARG_EXPAND);
#define glMultTransposeMatrixxOES_INDEX 1293
#define glMultTransposeMatrixxOES_RETURN void
#define glMultTransposeMatrixxOES_ARG_NAMES m
#define glMultTransposeMatrixxOES_ARG_EXPAND const GLfixed * m
#define glMultTransposeMatrixxOES_PACKED PACKED_glMultTransposeMatrixxOES
#define glMultTransposeMatrixxOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultTransposeMatrixxOES_NOT_VOID_WRAP(...) {}
#define pack_glMultTransposeMatrixxOES(_m) ({ \
    glMultTransposeMatrixxOES_PACKED *packed_data = malloc(sizeof(glMultTransposeMatrixxOES_PACKED)); \
    packed_data->index = glMultTransposeMatrixxOES_INDEX; \
    packed_data->args.m = (GLfixed *)_m; \
    (packed_call_t *)packed_data; \
})
#define call_glMultTransposeMatrixxOES(packed, ret_v) do { \
    PACKED_glMultTransposeMatrixxOES *unpacked = (PACKED_glMultTransposeMatrixxOES *)packed; \
    ARGS_glMultTransposeMatrixxOES *args = (ARGS_glMultTransposeMatrixxOES *)&unpacked->args; \
    glMultTransposeMatrixxOES(args->m);; \
} while(0)
void glMultTransposeMatrixxOES(glMultTransposeMatrixxOES_ARG_EXPAND);
typedef void (*glMultTransposeMatrixxOES_PTR)(glMultTransposeMatrixxOES_ARG_EXPAND);
#define glMultiDrawArrays_INDEX 1294
#define glMultiDrawArrays_RETURN void
#define glMultiDrawArrays_ARG_NAMES mode, first, count, drawcount
#define glMultiDrawArrays_ARG_EXPAND GLenum mode, const GLint * first, const GLsizei * count, GLsizei drawcount
#define glMultiDrawArrays_PACKED PACKED_glMultiDrawArrays
#define glMultiDrawArrays_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiDrawArrays_NOT_VOID_WRAP(...) {}
#define pack_glMultiDrawArrays(_mode, _first, _count, _drawcount) ({ \
    glMultiDrawArrays_PACKED *packed_data = malloc(sizeof(glMultiDrawArrays_PACKED)); \
    packed_data->index = glMultiDrawArrays_INDEX; \
    packed_data->args.mode = (GLenum)_mode; \
    packed_data->args.first = (GLint *)_first; \
    packed_data->args.count = (GLsizei *)_count; \
    packed_data->args.drawcount = (GLsizei)_drawcount; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiDrawArrays(packed, ret_v) do { \
    PACKED_glMultiDrawArrays *unpacked = (PACKED_glMultiDrawArrays *)packed; \
    ARGS_glMultiDrawArrays *args = (ARGS_glMultiDrawArrays *)&unpacked->args; \
    glMultiDrawArrays(args->mode, args->first, args->count, args->drawcount);; \
} while(0)
void glMultiDrawArrays(glMultiDrawArrays_ARG_EXPAND);
typedef void (*glMultiDrawArrays_PTR)(glMultiDrawArrays_ARG_EXPAND);
#define glMultiDrawArraysEXT_INDEX 1295
#define glMultiDrawArraysEXT_RETURN void
#define glMultiDrawArraysEXT_ARG_NAMES mode, first, count, primcount
#define glMultiDrawArraysEXT_ARG_EXPAND GLenum mode, const GLint * first, const GLsizei * count, GLsizei primcount
#define glMultiDrawArraysEXT_PACKED PACKED_glMultiDrawArraysEXT
#define glMultiDrawArraysEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiDrawArraysEXT_NOT_VOID_WRAP(...) {}
#define pack_glMultiDrawArraysEXT(_mode, _first, _count, _primcount) ({ \
    glMultiDrawArraysEXT_PACKED *packed_data = malloc(sizeof(glMultiDrawArraysEXT_PACKED)); \
    packed_data->index = glMultiDrawArraysEXT_INDEX; \
    packed_data->args.mode = (GLenum)_mode; \
    packed_data->args.first = (GLint *)_first; \
    packed_data->args.count = (GLsizei *)_count; \
    packed_data->args.primcount = (GLsizei)_primcount; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiDrawArraysEXT(packed, ret_v) do { \
    PACKED_glMultiDrawArraysEXT *unpacked = (PACKED_glMultiDrawArraysEXT *)packed; \
    ARGS_glMultiDrawArraysEXT *args = (ARGS_glMultiDrawArraysEXT *)&unpacked->args; \
    glMultiDrawArraysEXT(args->mode, args->first, args->count, args->primcount);; \
} while(0)
void glMultiDrawArraysEXT(glMultiDrawArraysEXT_ARG_EXPAND);
typedef void (*glMultiDrawArraysEXT_PTR)(glMultiDrawArraysEXT_ARG_EXPAND);
#define glMultiDrawArraysIndirect_INDEX 1296
#define glMultiDrawArraysIndirect_RETURN void
#define glMultiDrawArraysIndirect_ARG_NAMES mode, indirect, drawcount, stride
#define glMultiDrawArraysIndirect_ARG_EXPAND GLenum mode, const void * indirect, GLsizei drawcount, GLsizei stride
#define glMultiDrawArraysIndirect_PACKED PACKED_glMultiDrawArraysIndirect
#define glMultiDrawArraysIndirect_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiDrawArraysIndirect_NOT_VOID_WRAP(...) {}
#define pack_glMultiDrawArraysIndirect(_mode, _indirect, _drawcount, _stride) ({ \
    glMultiDrawArraysIndirect_PACKED *packed_data = malloc(sizeof(glMultiDrawArraysIndirect_PACKED)); \
    packed_data->index = glMultiDrawArraysIndirect_INDEX; \
    packed_data->args.mode = (GLenum)_mode; \
    packed_data->args.indirect = (void *)_indirect; \
    packed_data->args.drawcount = (GLsizei)_drawcount; \
    packed_data->args.stride = (GLsizei)_stride; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiDrawArraysIndirect(packed, ret_v) do { \
    PACKED_glMultiDrawArraysIndirect *unpacked = (PACKED_glMultiDrawArraysIndirect *)packed; \
    ARGS_glMultiDrawArraysIndirect *args = (ARGS_glMultiDrawArraysIndirect *)&unpacked->args; \
    glMultiDrawArraysIndirect(args->mode, args->indirect, args->drawcount, args->stride);; \
} while(0)
void glMultiDrawArraysIndirect(glMultiDrawArraysIndirect_ARG_EXPAND);
typedef void (*glMultiDrawArraysIndirect_PTR)(glMultiDrawArraysIndirect_ARG_EXPAND);
#define glMultiDrawArraysIndirectAMD_INDEX 1297
#define glMultiDrawArraysIndirectAMD_RETURN void
#define glMultiDrawArraysIndirectAMD_ARG_NAMES mode, indirect, primcount, stride
#define glMultiDrawArraysIndirectAMD_ARG_EXPAND GLenum mode, const GLvoid * indirect, GLsizei primcount, GLsizei stride
#define glMultiDrawArraysIndirectAMD_PACKED PACKED_glMultiDrawArraysIndirectAMD
#define glMultiDrawArraysIndirectAMD_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiDrawArraysIndirectAMD_NOT_VOID_WRAP(...) {}
#define pack_glMultiDrawArraysIndirectAMD(_mode, _indirect, _primcount, _stride) ({ \
    glMultiDrawArraysIndirectAMD_PACKED *packed_data = malloc(sizeof(glMultiDrawArraysIndirectAMD_PACKED)); \
    packed_data->index = glMultiDrawArraysIndirectAMD_INDEX; \
    packed_data->args.mode = (GLenum)_mode; \
    packed_data->args.indirect = (GLvoid *)_indirect; \
    packed_data->args.primcount = (GLsizei)_primcount; \
    packed_data->args.stride = (GLsizei)_stride; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiDrawArraysIndirectAMD(packed, ret_v) do { \
    PACKED_glMultiDrawArraysIndirectAMD *unpacked = (PACKED_glMultiDrawArraysIndirectAMD *)packed; \
    ARGS_glMultiDrawArraysIndirectAMD *args = (ARGS_glMultiDrawArraysIndirectAMD *)&unpacked->args; \
    glMultiDrawArraysIndirectAMD(args->mode, args->indirect, args->primcount, args->stride);; \
} while(0)
void glMultiDrawArraysIndirectAMD(glMultiDrawArraysIndirectAMD_ARG_EXPAND);
typedef void (*glMultiDrawArraysIndirectAMD_PTR)(glMultiDrawArraysIndirectAMD_ARG_EXPAND);
#define glMultiDrawElementArrayAPPLE_INDEX 1298
#define glMultiDrawElementArrayAPPLE_RETURN void
#define glMultiDrawElementArrayAPPLE_ARG_NAMES mode, first, count, primcount
#define glMultiDrawElementArrayAPPLE_ARG_EXPAND GLenum mode, const GLint * first, const GLsizei * count, GLsizei primcount
#define glMultiDrawElementArrayAPPLE_PACKED PACKED_glMultiDrawElementArrayAPPLE
#define glMultiDrawElementArrayAPPLE_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiDrawElementArrayAPPLE_NOT_VOID_WRAP(...) {}
#define pack_glMultiDrawElementArrayAPPLE(_mode, _first, _count, _primcount) ({ \
    glMultiDrawElementArrayAPPLE_PACKED *packed_data = malloc(sizeof(glMultiDrawElementArrayAPPLE_PACKED)); \
    packed_data->index = glMultiDrawElementArrayAPPLE_INDEX; \
    packed_data->args.mode = (GLenum)_mode; \
    packed_data->args.first = (GLint *)_first; \
    packed_data->args.count = (GLsizei *)_count; \
    packed_data->args.primcount = (GLsizei)_primcount; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiDrawElementArrayAPPLE(packed, ret_v) do { \
    PACKED_glMultiDrawElementArrayAPPLE *unpacked = (PACKED_glMultiDrawElementArrayAPPLE *)packed; \
    ARGS_glMultiDrawElementArrayAPPLE *args = (ARGS_glMultiDrawElementArrayAPPLE *)&unpacked->args; \
    glMultiDrawElementArrayAPPLE(args->mode, args->first, args->count, args->primcount);; \
} while(0)
void glMultiDrawElementArrayAPPLE(glMultiDrawElementArrayAPPLE_ARG_EXPAND);
typedef void (*glMultiDrawElementArrayAPPLE_PTR)(glMultiDrawElementArrayAPPLE_ARG_EXPAND);
#define glMultiDrawElements_INDEX 1299
#define glMultiDrawElements_RETURN void
#define glMultiDrawElements_ARG_NAMES mode, count, type, indices, drawcount
#define glMultiDrawElements_ARG_EXPAND GLenum mode, const GLsizei * count, GLenum type, GLvoid*const * indices, GLsizei drawcount
#define glMultiDrawElements_PACKED PACKED_glMultiDrawElements
#define glMultiDrawElements_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiDrawElements_NOT_VOID_WRAP(...) {}
#define pack_glMultiDrawElements(_mode, _count, _type, _indices, _drawcount) ({ \
    glMultiDrawElements_PACKED *packed_data = malloc(sizeof(glMultiDrawElements_PACKED)); \
    packed_data->index = glMultiDrawElements_INDEX; \
    packed_data->args.mode = (GLenum)_mode; \
    packed_data->args.count = (GLsizei *)_count; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.indices = (GLvoid*const *)_indices; \
    packed_data->args.drawcount = (GLsizei)_drawcount; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiDrawElements(packed, ret_v) do { \
    PACKED_glMultiDrawElements *unpacked = (PACKED_glMultiDrawElements *)packed; \
    ARGS_glMultiDrawElements *args = (ARGS_glMultiDrawElements *)&unpacked->args; \
    glMultiDrawElements(args->mode, args->count, args->type, args->indices, args->drawcount);; \
} while(0)
void glMultiDrawElements(glMultiDrawElements_ARG_EXPAND);
typedef void (*glMultiDrawElements_PTR)(glMultiDrawElements_ARG_EXPAND);
#define glMultiDrawElementsBaseVertex_INDEX 1300
#define glMultiDrawElementsBaseVertex_RETURN void
#define glMultiDrawElementsBaseVertex_ARG_NAMES mode, count, type, indices, drawcount, basevertex
#define glMultiDrawElementsBaseVertex_ARG_EXPAND GLenum mode, const GLsizei * count, GLenum type, GLvoid*const * indices, GLsizei drawcount, const GLint * basevertex
#define glMultiDrawElementsBaseVertex_PACKED PACKED_glMultiDrawElementsBaseVertex
#define glMultiDrawElementsBaseVertex_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiDrawElementsBaseVertex_NOT_VOID_WRAP(...) {}
#define pack_glMultiDrawElementsBaseVertex(_mode, _count, _type, _indices, _drawcount, _basevertex) ({ \
    glMultiDrawElementsBaseVertex_PACKED *packed_data = malloc(sizeof(glMultiDrawElementsBaseVertex_PACKED)); \
    packed_data->index = glMultiDrawElementsBaseVertex_INDEX; \
    packed_data->args.mode = (GLenum)_mode; \
    packed_data->args.count = (GLsizei *)_count; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.indices = (GLvoid*const *)_indices; \
    packed_data->args.drawcount = (GLsizei)_drawcount; \
    packed_data->args.basevertex = (GLint *)_basevertex; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiDrawElementsBaseVertex(packed, ret_v) do { \
    PACKED_glMultiDrawElementsBaseVertex *unpacked = (PACKED_glMultiDrawElementsBaseVertex *)packed; \
    ARGS_glMultiDrawElementsBaseVertex *args = (ARGS_glMultiDrawElementsBaseVertex *)&unpacked->args; \
    glMultiDrawElementsBaseVertex(args->mode, args->count, args->type, args->indices, args->drawcount, args->basevertex);; \
} while(0)
void glMultiDrawElementsBaseVertex(glMultiDrawElementsBaseVertex_ARG_EXPAND);
typedef void (*glMultiDrawElementsBaseVertex_PTR)(glMultiDrawElementsBaseVertex_ARG_EXPAND);
#define glMultiDrawElementsEXT_INDEX 1301
#define glMultiDrawElementsEXT_RETURN void
#define glMultiDrawElementsEXT_ARG_NAMES mode, count, type, indices, primcount
#define glMultiDrawElementsEXT_ARG_EXPAND GLenum mode, const GLsizei * count, GLenum type, const GLvoid * indices, GLsizei primcount
#define glMultiDrawElementsEXT_PACKED PACKED_glMultiDrawElementsEXT
#define glMultiDrawElementsEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiDrawElementsEXT_NOT_VOID_WRAP(...) {}
#define pack_glMultiDrawElementsEXT(_mode, _count, _type, _indices, _primcount) ({ \
    glMultiDrawElementsEXT_PACKED *packed_data = malloc(sizeof(glMultiDrawElementsEXT_PACKED)); \
    packed_data->index = glMultiDrawElementsEXT_INDEX; \
    packed_data->args.mode = (GLenum)_mode; \
    packed_data->args.count = (GLsizei *)_count; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.indices = (GLvoid *)_indices; \
    packed_data->args.primcount = (GLsizei)_primcount; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiDrawElementsEXT(packed, ret_v) do { \
    PACKED_glMultiDrawElementsEXT *unpacked = (PACKED_glMultiDrawElementsEXT *)packed; \
    ARGS_glMultiDrawElementsEXT *args = (ARGS_glMultiDrawElementsEXT *)&unpacked->args; \
    glMultiDrawElementsEXT(args->mode, args->count, args->type, args->indices, args->primcount);; \
} while(0)
void glMultiDrawElementsEXT(glMultiDrawElementsEXT_ARG_EXPAND);
typedef void (*glMultiDrawElementsEXT_PTR)(glMultiDrawElementsEXT_ARG_EXPAND);
#define glMultiDrawElementsIndirect_INDEX 1302
#define glMultiDrawElementsIndirect_RETURN void
#define glMultiDrawElementsIndirect_ARG_NAMES mode, type, indirect, drawcount, stride
#define glMultiDrawElementsIndirect_ARG_EXPAND GLenum mode, GLenum type, const void * indirect, GLsizei drawcount, GLsizei stride
#define glMultiDrawElementsIndirect_PACKED PACKED_glMultiDrawElementsIndirect
#define glMultiDrawElementsIndirect_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiDrawElementsIndirect_NOT_VOID_WRAP(...) {}
#define pack_glMultiDrawElementsIndirect(_mode, _type, _indirect, _drawcount, _stride) ({ \
    glMultiDrawElementsIndirect_PACKED *packed_data = malloc(sizeof(glMultiDrawElementsIndirect_PACKED)); \
    packed_data->index = glMultiDrawElementsIndirect_INDEX; \
    packed_data->args.mode = (GLenum)_mode; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.indirect = (void *)_indirect; \
    packed_data->args.drawcount = (GLsizei)_drawcount; \
    packed_data->args.stride = (GLsizei)_stride; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiDrawElementsIndirect(packed, ret_v) do { \
    PACKED_glMultiDrawElementsIndirect *unpacked = (PACKED_glMultiDrawElementsIndirect *)packed; \
    ARGS_glMultiDrawElementsIndirect *args = (ARGS_glMultiDrawElementsIndirect *)&unpacked->args; \
    glMultiDrawElementsIndirect(args->mode, args->type, args->indirect, args->drawcount, args->stride);; \
} while(0)
void glMultiDrawElementsIndirect(glMultiDrawElementsIndirect_ARG_EXPAND);
typedef void (*glMultiDrawElementsIndirect_PTR)(glMultiDrawElementsIndirect_ARG_EXPAND);
#define glMultiDrawElementsIndirectAMD_INDEX 1303
#define glMultiDrawElementsIndirectAMD_RETURN void
#define glMultiDrawElementsIndirectAMD_ARG_NAMES mode, type, indirect, primcount, stride
#define glMultiDrawElementsIndirectAMD_ARG_EXPAND GLenum mode, GLenum type, const GLvoid * indirect, GLsizei primcount, GLsizei stride
#define glMultiDrawElementsIndirectAMD_PACKED PACKED_glMultiDrawElementsIndirectAMD
#define glMultiDrawElementsIndirectAMD_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiDrawElementsIndirectAMD_NOT_VOID_WRAP(...) {}
#define pack_glMultiDrawElementsIndirectAMD(_mode, _type, _indirect, _primcount, _stride) ({ \
    glMultiDrawElementsIndirectAMD_PACKED *packed_data = malloc(sizeof(glMultiDrawElementsIndirectAMD_PACKED)); \
    packed_data->index = glMultiDrawElementsIndirectAMD_INDEX; \
    packed_data->args.mode = (GLenum)_mode; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.indirect = (GLvoid *)_indirect; \
    packed_data->args.primcount = (GLsizei)_primcount; \
    packed_data->args.stride = (GLsizei)_stride; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiDrawElementsIndirectAMD(packed, ret_v) do { \
    PACKED_glMultiDrawElementsIndirectAMD *unpacked = (PACKED_glMultiDrawElementsIndirectAMD *)packed; \
    ARGS_glMultiDrawElementsIndirectAMD *args = (ARGS_glMultiDrawElementsIndirectAMD *)&unpacked->args; \
    glMultiDrawElementsIndirectAMD(args->mode, args->type, args->indirect, args->primcount, args->stride);; \
} while(0)
void glMultiDrawElementsIndirectAMD(glMultiDrawElementsIndirectAMD_ARG_EXPAND);
typedef void (*glMultiDrawElementsIndirectAMD_PTR)(glMultiDrawElementsIndirectAMD_ARG_EXPAND);
#define glMultiDrawRangeElementArrayAPPLE_INDEX 1304
#define glMultiDrawRangeElementArrayAPPLE_RETURN void
#define glMultiDrawRangeElementArrayAPPLE_ARG_NAMES mode, start, end, first, count, primcount
#define glMultiDrawRangeElementArrayAPPLE_ARG_EXPAND GLenum mode, GLuint start, GLuint end, const GLint * first, const GLsizei * count, GLsizei primcount
#define glMultiDrawRangeElementArrayAPPLE_PACKED PACKED_glMultiDrawRangeElementArrayAPPLE
#define glMultiDrawRangeElementArrayAPPLE_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiDrawRangeElementArrayAPPLE_NOT_VOID_WRAP(...) {}
#define pack_glMultiDrawRangeElementArrayAPPLE(_mode, _start, _end, _first, _count, _primcount) ({ \
    glMultiDrawRangeElementArrayAPPLE_PACKED *packed_data = malloc(sizeof(glMultiDrawRangeElementArrayAPPLE_PACKED)); \
    packed_data->index = glMultiDrawRangeElementArrayAPPLE_INDEX; \
    packed_data->args.mode = (GLenum)_mode; \
    packed_data->args.start = (GLuint)_start; \
    packed_data->args.end = (GLuint)_end; \
    packed_data->args.first = (GLint *)_first; \
    packed_data->args.count = (GLsizei *)_count; \
    packed_data->args.primcount = (GLsizei)_primcount; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiDrawRangeElementArrayAPPLE(packed, ret_v) do { \
    PACKED_glMultiDrawRangeElementArrayAPPLE *unpacked = (PACKED_glMultiDrawRangeElementArrayAPPLE *)packed; \
    ARGS_glMultiDrawRangeElementArrayAPPLE *args = (ARGS_glMultiDrawRangeElementArrayAPPLE *)&unpacked->args; \
    glMultiDrawRangeElementArrayAPPLE(args->mode, args->start, args->end, args->first, args->count, args->primcount);; \
} while(0)
void glMultiDrawRangeElementArrayAPPLE(glMultiDrawRangeElementArrayAPPLE_ARG_EXPAND);
typedef void (*glMultiDrawRangeElementArrayAPPLE_PTR)(glMultiDrawRangeElementArrayAPPLE_ARG_EXPAND);
#define glMultiModeDrawArraysIBM_INDEX 1305
#define glMultiModeDrawArraysIBM_RETURN void
#define glMultiModeDrawArraysIBM_ARG_NAMES mode, first, count, primcount, modestride
#define glMultiModeDrawArraysIBM_ARG_EXPAND const GLenum * mode, const GLint * first, const GLsizei * count, GLsizei primcount, GLint modestride
#define glMultiModeDrawArraysIBM_PACKED PACKED_glMultiModeDrawArraysIBM
#define glMultiModeDrawArraysIBM_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiModeDrawArraysIBM_NOT_VOID_WRAP(...) {}
#define pack_glMultiModeDrawArraysIBM(_mode, _first, _count, _primcount, _modestride) ({ \
    glMultiModeDrawArraysIBM_PACKED *packed_data = malloc(sizeof(glMultiModeDrawArraysIBM_PACKED)); \
    packed_data->index = glMultiModeDrawArraysIBM_INDEX; \
    packed_data->args.mode = (GLenum *)_mode; \
    packed_data->args.first = (GLint *)_first; \
    packed_data->args.count = (GLsizei *)_count; \
    packed_data->args.primcount = (GLsizei)_primcount; \
    packed_data->args.modestride = (GLint)_modestride; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiModeDrawArraysIBM(packed, ret_v) do { \
    PACKED_glMultiModeDrawArraysIBM *unpacked = (PACKED_glMultiModeDrawArraysIBM *)packed; \
    ARGS_glMultiModeDrawArraysIBM *args = (ARGS_glMultiModeDrawArraysIBM *)&unpacked->args; \
    glMultiModeDrawArraysIBM(args->mode, args->first, args->count, args->primcount, args->modestride);; \
} while(0)
void glMultiModeDrawArraysIBM(glMultiModeDrawArraysIBM_ARG_EXPAND);
typedef void (*glMultiModeDrawArraysIBM_PTR)(glMultiModeDrawArraysIBM_ARG_EXPAND);
#define glMultiModeDrawElementsIBM_INDEX 1306
#define glMultiModeDrawElementsIBM_RETURN void
#define glMultiModeDrawElementsIBM_ARG_NAMES mode, count, type, indices, primcount, modestride
#define glMultiModeDrawElementsIBM_ARG_EXPAND const GLenum * mode, const GLsizei * count, GLenum type, GLvoid*const * indices, GLsizei primcount, GLint modestride
#define glMultiModeDrawElementsIBM_PACKED PACKED_glMultiModeDrawElementsIBM
#define glMultiModeDrawElementsIBM_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiModeDrawElementsIBM_NOT_VOID_WRAP(...) {}
#define pack_glMultiModeDrawElementsIBM(_mode, _count, _type, _indices, _primcount, _modestride) ({ \
    glMultiModeDrawElementsIBM_PACKED *packed_data = malloc(sizeof(glMultiModeDrawElementsIBM_PACKED)); \
    packed_data->index = glMultiModeDrawElementsIBM_INDEX; \
    packed_data->args.mode = (GLenum *)_mode; \
    packed_data->args.count = (GLsizei *)_count; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.indices = (GLvoid*const *)_indices; \
    packed_data->args.primcount = (GLsizei)_primcount; \
    packed_data->args.modestride = (GLint)_modestride; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiModeDrawElementsIBM(packed, ret_v) do { \
    PACKED_glMultiModeDrawElementsIBM *unpacked = (PACKED_glMultiModeDrawElementsIBM *)packed; \
    ARGS_glMultiModeDrawElementsIBM *args = (ARGS_glMultiModeDrawElementsIBM *)&unpacked->args; \
    glMultiModeDrawElementsIBM(args->mode, args->count, args->type, args->indices, args->primcount, args->modestride);; \
} while(0)
void glMultiModeDrawElementsIBM(glMultiModeDrawElementsIBM_ARG_EXPAND);
typedef void (*glMultiModeDrawElementsIBM_PTR)(glMultiModeDrawElementsIBM_ARG_EXPAND);
#define glMultiTexBufferEXT_INDEX 1307
#define glMultiTexBufferEXT_RETURN void
#define glMultiTexBufferEXT_ARG_NAMES texunit, target, internalformat, buffer
#define glMultiTexBufferEXT_ARG_EXPAND GLenum texunit, GLenum target, GLenum internalformat, GLuint buffer
#define glMultiTexBufferEXT_PACKED PACKED_glMultiTexBufferEXT
#define glMultiTexBufferEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiTexBufferEXT_NOT_VOID_WRAP(...) {}
#define pack_glMultiTexBufferEXT(_texunit, _target, _internalformat, _buffer) ({ \
    glMultiTexBufferEXT_PACKED *packed_data = malloc(sizeof(glMultiTexBufferEXT_PACKED)); \
    packed_data->index = glMultiTexBufferEXT_INDEX; \
    packed_data->args.texunit = (GLenum)_texunit; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.internalformat = (GLenum)_internalformat; \
    packed_data->args.buffer = (GLuint)_buffer; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiTexBufferEXT(packed, ret_v) do { \
    PACKED_glMultiTexBufferEXT *unpacked = (PACKED_glMultiTexBufferEXT *)packed; \
    ARGS_glMultiTexBufferEXT *args = (ARGS_glMultiTexBufferEXT *)&unpacked->args; \
    glMultiTexBufferEXT(args->texunit, args->target, args->internalformat, args->buffer);; \
} while(0)
void glMultiTexBufferEXT(glMultiTexBufferEXT_ARG_EXPAND);
typedef void (*glMultiTexBufferEXT_PTR)(glMultiTexBufferEXT_ARG_EXPAND);
#define glMultiTexCoord1bOES_INDEX 1308
#define glMultiTexCoord1bOES_RETURN void
#define glMultiTexCoord1bOES_ARG_NAMES texture, s
#define glMultiTexCoord1bOES_ARG_EXPAND GLenum texture, GLbyte s
#define glMultiTexCoord1bOES_PACKED PACKED_glMultiTexCoord1bOES
#define glMultiTexCoord1bOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiTexCoord1bOES_NOT_VOID_WRAP(...) {}
#define pack_glMultiTexCoord1bOES(_texture, _s) ({ \
    glMultiTexCoord1bOES_PACKED *packed_data = malloc(sizeof(glMultiTexCoord1bOES_PACKED)); \
    packed_data->index = glMultiTexCoord1bOES_INDEX; \
    packed_data->args.texture = (GLenum)_texture; \
    packed_data->args.s = (GLbyte)_s; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiTexCoord1bOES(packed, ret_v) do { \
    PACKED_glMultiTexCoord1bOES *unpacked = (PACKED_glMultiTexCoord1bOES *)packed; \
    ARGS_glMultiTexCoord1bOES *args = (ARGS_glMultiTexCoord1bOES *)&unpacked->args; \
    glMultiTexCoord1bOES(args->texture, args->s);; \
} while(0)
void glMultiTexCoord1bOES(glMultiTexCoord1bOES_ARG_EXPAND);
typedef void (*glMultiTexCoord1bOES_PTR)(glMultiTexCoord1bOES_ARG_EXPAND);
#define glMultiTexCoord1bvOES_INDEX 1309
#define glMultiTexCoord1bvOES_RETURN void
#define glMultiTexCoord1bvOES_ARG_NAMES texture, coords
#define glMultiTexCoord1bvOES_ARG_EXPAND GLenum texture, const GLbyte * coords
#define glMultiTexCoord1bvOES_PACKED PACKED_glMultiTexCoord1bvOES
#define glMultiTexCoord1bvOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiTexCoord1bvOES_NOT_VOID_WRAP(...) {}
#define pack_glMultiTexCoord1bvOES(_texture, _coords) ({ \
    glMultiTexCoord1bvOES_PACKED *packed_data = malloc(sizeof(glMultiTexCoord1bvOES_PACKED)); \
    packed_data->index = glMultiTexCoord1bvOES_INDEX; \
    packed_data->args.texture = (GLenum)_texture; \
    packed_data->args.coords = (GLbyte *)_coords; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiTexCoord1bvOES(packed, ret_v) do { \
    PACKED_glMultiTexCoord1bvOES *unpacked = (PACKED_glMultiTexCoord1bvOES *)packed; \
    ARGS_glMultiTexCoord1bvOES *args = (ARGS_glMultiTexCoord1bvOES *)&unpacked->args; \
    glMultiTexCoord1bvOES(args->texture, args->coords);; \
} while(0)
void glMultiTexCoord1bvOES(glMultiTexCoord1bvOES_ARG_EXPAND);
typedef void (*glMultiTexCoord1bvOES_PTR)(glMultiTexCoord1bvOES_ARG_EXPAND);
#define glMultiTexCoord1d_INDEX 1310
#define glMultiTexCoord1d_RETURN void
#define glMultiTexCoord1d_ARG_NAMES target, s
#define glMultiTexCoord1d_ARG_EXPAND GLenum target, GLdouble s
#define glMultiTexCoord1d_PACKED PACKED_glMultiTexCoord1d
#define glMultiTexCoord1d_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiTexCoord1d_NOT_VOID_WRAP(...) {}
#define pack_glMultiTexCoord1d(_target, _s) ({ \
    glMultiTexCoord1d_PACKED *packed_data = malloc(sizeof(glMultiTexCoord1d_PACKED)); \
    packed_data->index = glMultiTexCoord1d_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.s = (GLdouble)_s; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiTexCoord1d(packed, ret_v) do { \
    PACKED_glMultiTexCoord1d *unpacked = (PACKED_glMultiTexCoord1d *)packed; \
    ARGS_glMultiTexCoord1d *args = (ARGS_glMultiTexCoord1d *)&unpacked->args; \
    glMultiTexCoord1d(args->target, args->s);; \
} while(0)
void glMultiTexCoord1d(glMultiTexCoord1d_ARG_EXPAND);
typedef void (*glMultiTexCoord1d_PTR)(glMultiTexCoord1d_ARG_EXPAND);
#define glMultiTexCoord1dARB_INDEX 1311
#define glMultiTexCoord1dARB_RETURN void
#define glMultiTexCoord1dARB_ARG_NAMES target, s
#define glMultiTexCoord1dARB_ARG_EXPAND GLenum target, GLdouble s
#define glMultiTexCoord1dARB_PACKED PACKED_glMultiTexCoord1dARB
#define glMultiTexCoord1dARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiTexCoord1dARB_NOT_VOID_WRAP(...) {}
#define pack_glMultiTexCoord1dARB(_target, _s) ({ \
    glMultiTexCoord1dARB_PACKED *packed_data = malloc(sizeof(glMultiTexCoord1dARB_PACKED)); \
    packed_data->index = glMultiTexCoord1dARB_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.s = (GLdouble)_s; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiTexCoord1dARB(packed, ret_v) do { \
    PACKED_glMultiTexCoord1dARB *unpacked = (PACKED_glMultiTexCoord1dARB *)packed; \
    ARGS_glMultiTexCoord1dARB *args = (ARGS_glMultiTexCoord1dARB *)&unpacked->args; \
    glMultiTexCoord1dARB(args->target, args->s);; \
} while(0)
void glMultiTexCoord1dARB(glMultiTexCoord1dARB_ARG_EXPAND);
typedef void (*glMultiTexCoord1dARB_PTR)(glMultiTexCoord1dARB_ARG_EXPAND);
#define glMultiTexCoord1dv_INDEX 1312
#define glMultiTexCoord1dv_RETURN void
#define glMultiTexCoord1dv_ARG_NAMES target, v
#define glMultiTexCoord1dv_ARG_EXPAND GLenum target, const GLdouble * v
#define glMultiTexCoord1dv_PACKED PACKED_glMultiTexCoord1dv
#define glMultiTexCoord1dv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiTexCoord1dv_NOT_VOID_WRAP(...) {}
#define pack_glMultiTexCoord1dv(_target, _v) ({ \
    glMultiTexCoord1dv_PACKED *packed_data = malloc(sizeof(glMultiTexCoord1dv_PACKED)); \
    packed_data->index = glMultiTexCoord1dv_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.v = (GLdouble *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiTexCoord1dv(packed, ret_v) do { \
    PACKED_glMultiTexCoord1dv *unpacked = (PACKED_glMultiTexCoord1dv *)packed; \
    ARGS_glMultiTexCoord1dv *args = (ARGS_glMultiTexCoord1dv *)&unpacked->args; \
    glMultiTexCoord1dv(args->target, args->v);; \
} while(0)
void glMultiTexCoord1dv(glMultiTexCoord1dv_ARG_EXPAND);
typedef void (*glMultiTexCoord1dv_PTR)(glMultiTexCoord1dv_ARG_EXPAND);
#define glMultiTexCoord1dvARB_INDEX 1313
#define glMultiTexCoord1dvARB_RETURN void
#define glMultiTexCoord1dvARB_ARG_NAMES target, v
#define glMultiTexCoord1dvARB_ARG_EXPAND GLenum target, const GLdouble * v
#define glMultiTexCoord1dvARB_PACKED PACKED_glMultiTexCoord1dvARB
#define glMultiTexCoord1dvARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiTexCoord1dvARB_NOT_VOID_WRAP(...) {}
#define pack_glMultiTexCoord1dvARB(_target, _v) ({ \
    glMultiTexCoord1dvARB_PACKED *packed_data = malloc(sizeof(glMultiTexCoord1dvARB_PACKED)); \
    packed_data->index = glMultiTexCoord1dvARB_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.v = (GLdouble *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiTexCoord1dvARB(packed, ret_v) do { \
    PACKED_glMultiTexCoord1dvARB *unpacked = (PACKED_glMultiTexCoord1dvARB *)packed; \
    ARGS_glMultiTexCoord1dvARB *args = (ARGS_glMultiTexCoord1dvARB *)&unpacked->args; \
    glMultiTexCoord1dvARB(args->target, args->v);; \
} while(0)
void glMultiTexCoord1dvARB(glMultiTexCoord1dvARB_ARG_EXPAND);
typedef void (*glMultiTexCoord1dvARB_PTR)(glMultiTexCoord1dvARB_ARG_EXPAND);
#define glMultiTexCoord1f_INDEX 1314
#define glMultiTexCoord1f_RETURN void
#define glMultiTexCoord1f_ARG_NAMES target, s
#define glMultiTexCoord1f_ARG_EXPAND GLenum target, GLfloat s
#define glMultiTexCoord1f_PACKED PACKED_glMultiTexCoord1f
#define glMultiTexCoord1f_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiTexCoord1f_NOT_VOID_WRAP(...) {}
#define pack_glMultiTexCoord1f(_target, _s) ({ \
    glMultiTexCoord1f_PACKED *packed_data = malloc(sizeof(glMultiTexCoord1f_PACKED)); \
    packed_data->index = glMultiTexCoord1f_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.s = (GLfloat)_s; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiTexCoord1f(packed, ret_v) do { \
    PACKED_glMultiTexCoord1f *unpacked = (PACKED_glMultiTexCoord1f *)packed; \
    ARGS_glMultiTexCoord1f *args = (ARGS_glMultiTexCoord1f *)&unpacked->args; \
    glMultiTexCoord1f(args->target, args->s);; \
} while(0)
void glMultiTexCoord1f(glMultiTexCoord1f_ARG_EXPAND);
typedef void (*glMultiTexCoord1f_PTR)(glMultiTexCoord1f_ARG_EXPAND);
#define glMultiTexCoord1fARB_INDEX 1315
#define glMultiTexCoord1fARB_RETURN void
#define glMultiTexCoord1fARB_ARG_NAMES target, s
#define glMultiTexCoord1fARB_ARG_EXPAND GLenum target, GLfloat s
#define glMultiTexCoord1fARB_PACKED PACKED_glMultiTexCoord1fARB
#define glMultiTexCoord1fARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiTexCoord1fARB_NOT_VOID_WRAP(...) {}
#define pack_glMultiTexCoord1fARB(_target, _s) ({ \
    glMultiTexCoord1fARB_PACKED *packed_data = malloc(sizeof(glMultiTexCoord1fARB_PACKED)); \
    packed_data->index = glMultiTexCoord1fARB_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.s = (GLfloat)_s; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiTexCoord1fARB(packed, ret_v) do { \
    PACKED_glMultiTexCoord1fARB *unpacked = (PACKED_glMultiTexCoord1fARB *)packed; \
    ARGS_glMultiTexCoord1fARB *args = (ARGS_glMultiTexCoord1fARB *)&unpacked->args; \
    glMultiTexCoord1fARB(args->target, args->s);; \
} while(0)
void glMultiTexCoord1fARB(glMultiTexCoord1fARB_ARG_EXPAND);
typedef void (*glMultiTexCoord1fARB_PTR)(glMultiTexCoord1fARB_ARG_EXPAND);
#define glMultiTexCoord1fv_INDEX 1316
#define glMultiTexCoord1fv_RETURN void
#define glMultiTexCoord1fv_ARG_NAMES target, v
#define glMultiTexCoord1fv_ARG_EXPAND GLenum target, const GLfloat * v
#define glMultiTexCoord1fv_PACKED PACKED_glMultiTexCoord1fv
#define glMultiTexCoord1fv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiTexCoord1fv_NOT_VOID_WRAP(...) {}
#define pack_glMultiTexCoord1fv(_target, _v) ({ \
    glMultiTexCoord1fv_PACKED *packed_data = malloc(sizeof(glMultiTexCoord1fv_PACKED)); \
    packed_data->index = glMultiTexCoord1fv_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.v = (GLfloat *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiTexCoord1fv(packed, ret_v) do { \
    PACKED_glMultiTexCoord1fv *unpacked = (PACKED_glMultiTexCoord1fv *)packed; \
    ARGS_glMultiTexCoord1fv *args = (ARGS_glMultiTexCoord1fv *)&unpacked->args; \
    glMultiTexCoord1fv(args->target, args->v);; \
} while(0)
void glMultiTexCoord1fv(glMultiTexCoord1fv_ARG_EXPAND);
typedef void (*glMultiTexCoord1fv_PTR)(glMultiTexCoord1fv_ARG_EXPAND);
#define glMultiTexCoord1fvARB_INDEX 1317
#define glMultiTexCoord1fvARB_RETURN void
#define glMultiTexCoord1fvARB_ARG_NAMES target, v
#define glMultiTexCoord1fvARB_ARG_EXPAND GLenum target, const GLfloat * v
#define glMultiTexCoord1fvARB_PACKED PACKED_glMultiTexCoord1fvARB
#define glMultiTexCoord1fvARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiTexCoord1fvARB_NOT_VOID_WRAP(...) {}
#define pack_glMultiTexCoord1fvARB(_target, _v) ({ \
    glMultiTexCoord1fvARB_PACKED *packed_data = malloc(sizeof(glMultiTexCoord1fvARB_PACKED)); \
    packed_data->index = glMultiTexCoord1fvARB_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.v = (GLfloat *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiTexCoord1fvARB(packed, ret_v) do { \
    PACKED_glMultiTexCoord1fvARB *unpacked = (PACKED_glMultiTexCoord1fvARB *)packed; \
    ARGS_glMultiTexCoord1fvARB *args = (ARGS_glMultiTexCoord1fvARB *)&unpacked->args; \
    glMultiTexCoord1fvARB(args->target, args->v);; \
} while(0)
void glMultiTexCoord1fvARB(glMultiTexCoord1fvARB_ARG_EXPAND);
typedef void (*glMultiTexCoord1fvARB_PTR)(glMultiTexCoord1fvARB_ARG_EXPAND);
#define glMultiTexCoord1hNV_INDEX 1318
#define glMultiTexCoord1hNV_RETURN void
#define glMultiTexCoord1hNV_ARG_NAMES target, s
#define glMultiTexCoord1hNV_ARG_EXPAND GLenum target, GLhalfNV s
#define glMultiTexCoord1hNV_PACKED PACKED_glMultiTexCoord1hNV
#define glMultiTexCoord1hNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiTexCoord1hNV_NOT_VOID_WRAP(...) {}
#define pack_glMultiTexCoord1hNV(_target, _s) ({ \
    glMultiTexCoord1hNV_PACKED *packed_data = malloc(sizeof(glMultiTexCoord1hNV_PACKED)); \
    packed_data->index = glMultiTexCoord1hNV_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.s = (GLhalfNV)_s; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiTexCoord1hNV(packed, ret_v) do { \
    PACKED_glMultiTexCoord1hNV *unpacked = (PACKED_glMultiTexCoord1hNV *)packed; \
    ARGS_glMultiTexCoord1hNV *args = (ARGS_glMultiTexCoord1hNV *)&unpacked->args; \
    glMultiTexCoord1hNV(args->target, args->s);; \
} while(0)
void glMultiTexCoord1hNV(glMultiTexCoord1hNV_ARG_EXPAND);
typedef void (*glMultiTexCoord1hNV_PTR)(glMultiTexCoord1hNV_ARG_EXPAND);
#define glMultiTexCoord1hvNV_INDEX 1319
#define glMultiTexCoord1hvNV_RETURN void
#define glMultiTexCoord1hvNV_ARG_NAMES target, v
#define glMultiTexCoord1hvNV_ARG_EXPAND GLenum target, const GLhalfNV * v
#define glMultiTexCoord1hvNV_PACKED PACKED_glMultiTexCoord1hvNV
#define glMultiTexCoord1hvNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiTexCoord1hvNV_NOT_VOID_WRAP(...) {}
#define pack_glMultiTexCoord1hvNV(_target, _v) ({ \
    glMultiTexCoord1hvNV_PACKED *packed_data = malloc(sizeof(glMultiTexCoord1hvNV_PACKED)); \
    packed_data->index = glMultiTexCoord1hvNV_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.v = (GLhalfNV *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiTexCoord1hvNV(packed, ret_v) do { \
    PACKED_glMultiTexCoord1hvNV *unpacked = (PACKED_glMultiTexCoord1hvNV *)packed; \
    ARGS_glMultiTexCoord1hvNV *args = (ARGS_glMultiTexCoord1hvNV *)&unpacked->args; \
    glMultiTexCoord1hvNV(args->target, args->v);; \
} while(0)
void glMultiTexCoord1hvNV(glMultiTexCoord1hvNV_ARG_EXPAND);
typedef void (*glMultiTexCoord1hvNV_PTR)(glMultiTexCoord1hvNV_ARG_EXPAND);
#define glMultiTexCoord1i_INDEX 1320
#define glMultiTexCoord1i_RETURN void
#define glMultiTexCoord1i_ARG_NAMES target, s
#define glMultiTexCoord1i_ARG_EXPAND GLenum target, GLint s
#define glMultiTexCoord1i_PACKED PACKED_glMultiTexCoord1i
#define glMultiTexCoord1i_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiTexCoord1i_NOT_VOID_WRAP(...) {}
#define pack_glMultiTexCoord1i(_target, _s) ({ \
    glMultiTexCoord1i_PACKED *packed_data = malloc(sizeof(glMultiTexCoord1i_PACKED)); \
    packed_data->index = glMultiTexCoord1i_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.s = (GLint)_s; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiTexCoord1i(packed, ret_v) do { \
    PACKED_glMultiTexCoord1i *unpacked = (PACKED_glMultiTexCoord1i *)packed; \
    ARGS_glMultiTexCoord1i *args = (ARGS_glMultiTexCoord1i *)&unpacked->args; \
    glMultiTexCoord1i(args->target, args->s);; \
} while(0)
void glMultiTexCoord1i(glMultiTexCoord1i_ARG_EXPAND);
typedef void (*glMultiTexCoord1i_PTR)(glMultiTexCoord1i_ARG_EXPAND);
#define glMultiTexCoord1iARB_INDEX 1321
#define glMultiTexCoord1iARB_RETURN void
#define glMultiTexCoord1iARB_ARG_NAMES target, s
#define glMultiTexCoord1iARB_ARG_EXPAND GLenum target, GLint s
#define glMultiTexCoord1iARB_PACKED PACKED_glMultiTexCoord1iARB
#define glMultiTexCoord1iARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiTexCoord1iARB_NOT_VOID_WRAP(...) {}
#define pack_glMultiTexCoord1iARB(_target, _s) ({ \
    glMultiTexCoord1iARB_PACKED *packed_data = malloc(sizeof(glMultiTexCoord1iARB_PACKED)); \
    packed_data->index = glMultiTexCoord1iARB_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.s = (GLint)_s; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiTexCoord1iARB(packed, ret_v) do { \
    PACKED_glMultiTexCoord1iARB *unpacked = (PACKED_glMultiTexCoord1iARB *)packed; \
    ARGS_glMultiTexCoord1iARB *args = (ARGS_glMultiTexCoord1iARB *)&unpacked->args; \
    glMultiTexCoord1iARB(args->target, args->s);; \
} while(0)
void glMultiTexCoord1iARB(glMultiTexCoord1iARB_ARG_EXPAND);
typedef void (*glMultiTexCoord1iARB_PTR)(glMultiTexCoord1iARB_ARG_EXPAND);
#define glMultiTexCoord1iv_INDEX 1322
#define glMultiTexCoord1iv_RETURN void
#define glMultiTexCoord1iv_ARG_NAMES target, v
#define glMultiTexCoord1iv_ARG_EXPAND GLenum target, const GLint * v
#define glMultiTexCoord1iv_PACKED PACKED_glMultiTexCoord1iv
#define glMultiTexCoord1iv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiTexCoord1iv_NOT_VOID_WRAP(...) {}
#define pack_glMultiTexCoord1iv(_target, _v) ({ \
    glMultiTexCoord1iv_PACKED *packed_data = malloc(sizeof(glMultiTexCoord1iv_PACKED)); \
    packed_data->index = glMultiTexCoord1iv_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.v = (GLint *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiTexCoord1iv(packed, ret_v) do { \
    PACKED_glMultiTexCoord1iv *unpacked = (PACKED_glMultiTexCoord1iv *)packed; \
    ARGS_glMultiTexCoord1iv *args = (ARGS_glMultiTexCoord1iv *)&unpacked->args; \
    glMultiTexCoord1iv(args->target, args->v);; \
} while(0)
void glMultiTexCoord1iv(glMultiTexCoord1iv_ARG_EXPAND);
typedef void (*glMultiTexCoord1iv_PTR)(glMultiTexCoord1iv_ARG_EXPAND);
#define glMultiTexCoord1ivARB_INDEX 1323
#define glMultiTexCoord1ivARB_RETURN void
#define glMultiTexCoord1ivARB_ARG_NAMES target, v
#define glMultiTexCoord1ivARB_ARG_EXPAND GLenum target, const GLint * v
#define glMultiTexCoord1ivARB_PACKED PACKED_glMultiTexCoord1ivARB
#define glMultiTexCoord1ivARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiTexCoord1ivARB_NOT_VOID_WRAP(...) {}
#define pack_glMultiTexCoord1ivARB(_target, _v) ({ \
    glMultiTexCoord1ivARB_PACKED *packed_data = malloc(sizeof(glMultiTexCoord1ivARB_PACKED)); \
    packed_data->index = glMultiTexCoord1ivARB_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.v = (GLint *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiTexCoord1ivARB(packed, ret_v) do { \
    PACKED_glMultiTexCoord1ivARB *unpacked = (PACKED_glMultiTexCoord1ivARB *)packed; \
    ARGS_glMultiTexCoord1ivARB *args = (ARGS_glMultiTexCoord1ivARB *)&unpacked->args; \
    glMultiTexCoord1ivARB(args->target, args->v);; \
} while(0)
void glMultiTexCoord1ivARB(glMultiTexCoord1ivARB_ARG_EXPAND);
typedef void (*glMultiTexCoord1ivARB_PTR)(glMultiTexCoord1ivARB_ARG_EXPAND);
#define glMultiTexCoord1s_INDEX 1324
#define glMultiTexCoord1s_RETURN void
#define glMultiTexCoord1s_ARG_NAMES target, s
#define glMultiTexCoord1s_ARG_EXPAND GLenum target, GLshort s
#define glMultiTexCoord1s_PACKED PACKED_glMultiTexCoord1s
#define glMultiTexCoord1s_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiTexCoord1s_NOT_VOID_WRAP(...) {}
#define pack_glMultiTexCoord1s(_target, _s) ({ \
    glMultiTexCoord1s_PACKED *packed_data = malloc(sizeof(glMultiTexCoord1s_PACKED)); \
    packed_data->index = glMultiTexCoord1s_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.s = (GLshort)_s; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiTexCoord1s(packed, ret_v) do { \
    PACKED_glMultiTexCoord1s *unpacked = (PACKED_glMultiTexCoord1s *)packed; \
    ARGS_glMultiTexCoord1s *args = (ARGS_glMultiTexCoord1s *)&unpacked->args; \
    glMultiTexCoord1s(args->target, args->s);; \
} while(0)
void glMultiTexCoord1s(glMultiTexCoord1s_ARG_EXPAND);
typedef void (*glMultiTexCoord1s_PTR)(glMultiTexCoord1s_ARG_EXPAND);
#define glMultiTexCoord1sARB_INDEX 1325
#define glMultiTexCoord1sARB_RETURN void
#define glMultiTexCoord1sARB_ARG_NAMES target, s
#define glMultiTexCoord1sARB_ARG_EXPAND GLenum target, GLshort s
#define glMultiTexCoord1sARB_PACKED PACKED_glMultiTexCoord1sARB
#define glMultiTexCoord1sARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiTexCoord1sARB_NOT_VOID_WRAP(...) {}
#define pack_glMultiTexCoord1sARB(_target, _s) ({ \
    glMultiTexCoord1sARB_PACKED *packed_data = malloc(sizeof(glMultiTexCoord1sARB_PACKED)); \
    packed_data->index = glMultiTexCoord1sARB_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.s = (GLshort)_s; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiTexCoord1sARB(packed, ret_v) do { \
    PACKED_glMultiTexCoord1sARB *unpacked = (PACKED_glMultiTexCoord1sARB *)packed; \
    ARGS_glMultiTexCoord1sARB *args = (ARGS_glMultiTexCoord1sARB *)&unpacked->args; \
    glMultiTexCoord1sARB(args->target, args->s);; \
} while(0)
void glMultiTexCoord1sARB(glMultiTexCoord1sARB_ARG_EXPAND);
typedef void (*glMultiTexCoord1sARB_PTR)(glMultiTexCoord1sARB_ARG_EXPAND);
#define glMultiTexCoord1sv_INDEX 1326
#define glMultiTexCoord1sv_RETURN void
#define glMultiTexCoord1sv_ARG_NAMES target, v
#define glMultiTexCoord1sv_ARG_EXPAND GLenum target, const GLshort * v
#define glMultiTexCoord1sv_PACKED PACKED_glMultiTexCoord1sv
#define glMultiTexCoord1sv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiTexCoord1sv_NOT_VOID_WRAP(...) {}
#define pack_glMultiTexCoord1sv(_target, _v) ({ \
    glMultiTexCoord1sv_PACKED *packed_data = malloc(sizeof(glMultiTexCoord1sv_PACKED)); \
    packed_data->index = glMultiTexCoord1sv_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.v = (GLshort *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiTexCoord1sv(packed, ret_v) do { \
    PACKED_glMultiTexCoord1sv *unpacked = (PACKED_glMultiTexCoord1sv *)packed; \
    ARGS_glMultiTexCoord1sv *args = (ARGS_glMultiTexCoord1sv *)&unpacked->args; \
    glMultiTexCoord1sv(args->target, args->v);; \
} while(0)
void glMultiTexCoord1sv(glMultiTexCoord1sv_ARG_EXPAND);
typedef void (*glMultiTexCoord1sv_PTR)(glMultiTexCoord1sv_ARG_EXPAND);
#define glMultiTexCoord1svARB_INDEX 1327
#define glMultiTexCoord1svARB_RETURN void
#define glMultiTexCoord1svARB_ARG_NAMES target, v
#define glMultiTexCoord1svARB_ARG_EXPAND GLenum target, const GLshort * v
#define glMultiTexCoord1svARB_PACKED PACKED_glMultiTexCoord1svARB
#define glMultiTexCoord1svARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiTexCoord1svARB_NOT_VOID_WRAP(...) {}
#define pack_glMultiTexCoord1svARB(_target, _v) ({ \
    glMultiTexCoord1svARB_PACKED *packed_data = malloc(sizeof(glMultiTexCoord1svARB_PACKED)); \
    packed_data->index = glMultiTexCoord1svARB_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.v = (GLshort *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiTexCoord1svARB(packed, ret_v) do { \
    PACKED_glMultiTexCoord1svARB *unpacked = (PACKED_glMultiTexCoord1svARB *)packed; \
    ARGS_glMultiTexCoord1svARB *args = (ARGS_glMultiTexCoord1svARB *)&unpacked->args; \
    glMultiTexCoord1svARB(args->target, args->v);; \
} while(0)
void glMultiTexCoord1svARB(glMultiTexCoord1svARB_ARG_EXPAND);
typedef void (*glMultiTexCoord1svARB_PTR)(glMultiTexCoord1svARB_ARG_EXPAND);
#define glMultiTexCoord1xOES_INDEX 1328
#define glMultiTexCoord1xOES_RETURN void
#define glMultiTexCoord1xOES_ARG_NAMES texture, s
#define glMultiTexCoord1xOES_ARG_EXPAND GLenum texture, GLfixed s
#define glMultiTexCoord1xOES_PACKED PACKED_glMultiTexCoord1xOES
#define glMultiTexCoord1xOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiTexCoord1xOES_NOT_VOID_WRAP(...) {}
#define pack_glMultiTexCoord1xOES(_texture, _s) ({ \
    glMultiTexCoord1xOES_PACKED *packed_data = malloc(sizeof(glMultiTexCoord1xOES_PACKED)); \
    packed_data->index = glMultiTexCoord1xOES_INDEX; \
    packed_data->args.texture = (GLenum)_texture; \
    packed_data->args.s = (GLfixed)_s; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiTexCoord1xOES(packed, ret_v) do { \
    PACKED_glMultiTexCoord1xOES *unpacked = (PACKED_glMultiTexCoord1xOES *)packed; \
    ARGS_glMultiTexCoord1xOES *args = (ARGS_glMultiTexCoord1xOES *)&unpacked->args; \
    glMultiTexCoord1xOES(args->texture, args->s);; \
} while(0)
void glMultiTexCoord1xOES(glMultiTexCoord1xOES_ARG_EXPAND);
typedef void (*glMultiTexCoord1xOES_PTR)(glMultiTexCoord1xOES_ARG_EXPAND);
#define glMultiTexCoord1xvOES_INDEX 1329
#define glMultiTexCoord1xvOES_RETURN void
#define glMultiTexCoord1xvOES_ARG_NAMES texture, coords
#define glMultiTexCoord1xvOES_ARG_EXPAND GLenum texture, const GLfixed * coords
#define glMultiTexCoord1xvOES_PACKED PACKED_glMultiTexCoord1xvOES
#define glMultiTexCoord1xvOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiTexCoord1xvOES_NOT_VOID_WRAP(...) {}
#define pack_glMultiTexCoord1xvOES(_texture, _coords) ({ \
    glMultiTexCoord1xvOES_PACKED *packed_data = malloc(sizeof(glMultiTexCoord1xvOES_PACKED)); \
    packed_data->index = glMultiTexCoord1xvOES_INDEX; \
    packed_data->args.texture = (GLenum)_texture; \
    packed_data->args.coords = (GLfixed *)_coords; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiTexCoord1xvOES(packed, ret_v) do { \
    PACKED_glMultiTexCoord1xvOES *unpacked = (PACKED_glMultiTexCoord1xvOES *)packed; \
    ARGS_glMultiTexCoord1xvOES *args = (ARGS_glMultiTexCoord1xvOES *)&unpacked->args; \
    glMultiTexCoord1xvOES(args->texture, args->coords);; \
} while(0)
void glMultiTexCoord1xvOES(glMultiTexCoord1xvOES_ARG_EXPAND);
typedef void (*glMultiTexCoord1xvOES_PTR)(glMultiTexCoord1xvOES_ARG_EXPAND);
#define glMultiTexCoord2bOES_INDEX 1330
#define glMultiTexCoord2bOES_RETURN void
#define glMultiTexCoord2bOES_ARG_NAMES texture, s, t
#define glMultiTexCoord2bOES_ARG_EXPAND GLenum texture, GLbyte s, GLbyte t
#define glMultiTexCoord2bOES_PACKED PACKED_glMultiTexCoord2bOES
#define glMultiTexCoord2bOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiTexCoord2bOES_NOT_VOID_WRAP(...) {}
#define pack_glMultiTexCoord2bOES(_texture, _s, _t) ({ \
    glMultiTexCoord2bOES_PACKED *packed_data = malloc(sizeof(glMultiTexCoord2bOES_PACKED)); \
    packed_data->index = glMultiTexCoord2bOES_INDEX; \
    packed_data->args.texture = (GLenum)_texture; \
    packed_data->args.s = (GLbyte)_s; \
    packed_data->args.t = (GLbyte)_t; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiTexCoord2bOES(packed, ret_v) do { \
    PACKED_glMultiTexCoord2bOES *unpacked = (PACKED_glMultiTexCoord2bOES *)packed; \
    ARGS_glMultiTexCoord2bOES *args = (ARGS_glMultiTexCoord2bOES *)&unpacked->args; \
    glMultiTexCoord2bOES(args->texture, args->s, args->t);; \
} while(0)
void glMultiTexCoord2bOES(glMultiTexCoord2bOES_ARG_EXPAND);
typedef void (*glMultiTexCoord2bOES_PTR)(glMultiTexCoord2bOES_ARG_EXPAND);
#define glMultiTexCoord2bvOES_INDEX 1331
#define glMultiTexCoord2bvOES_RETURN void
#define glMultiTexCoord2bvOES_ARG_NAMES texture, coords
#define glMultiTexCoord2bvOES_ARG_EXPAND GLenum texture, const GLbyte * coords
#define glMultiTexCoord2bvOES_PACKED PACKED_glMultiTexCoord2bvOES
#define glMultiTexCoord2bvOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiTexCoord2bvOES_NOT_VOID_WRAP(...) {}
#define pack_glMultiTexCoord2bvOES(_texture, _coords) ({ \
    glMultiTexCoord2bvOES_PACKED *packed_data = malloc(sizeof(glMultiTexCoord2bvOES_PACKED)); \
    packed_data->index = glMultiTexCoord2bvOES_INDEX; \
    packed_data->args.texture = (GLenum)_texture; \
    packed_data->args.coords = (GLbyte *)_coords; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiTexCoord2bvOES(packed, ret_v) do { \
    PACKED_glMultiTexCoord2bvOES *unpacked = (PACKED_glMultiTexCoord2bvOES *)packed; \
    ARGS_glMultiTexCoord2bvOES *args = (ARGS_glMultiTexCoord2bvOES *)&unpacked->args; \
    glMultiTexCoord2bvOES(args->texture, args->coords);; \
} while(0)
void glMultiTexCoord2bvOES(glMultiTexCoord2bvOES_ARG_EXPAND);
typedef void (*glMultiTexCoord2bvOES_PTR)(glMultiTexCoord2bvOES_ARG_EXPAND);
#define glMultiTexCoord2d_INDEX 1332
#define glMultiTexCoord2d_RETURN void
#define glMultiTexCoord2d_ARG_NAMES target, s, t
#define glMultiTexCoord2d_ARG_EXPAND GLenum target, GLdouble s, GLdouble t
#define glMultiTexCoord2d_PACKED PACKED_glMultiTexCoord2d
#define glMultiTexCoord2d_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiTexCoord2d_NOT_VOID_WRAP(...) {}
#define pack_glMultiTexCoord2d(_target, _s, _t) ({ \
    glMultiTexCoord2d_PACKED *packed_data = malloc(sizeof(glMultiTexCoord2d_PACKED)); \
    packed_data->index = glMultiTexCoord2d_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.s = (GLdouble)_s; \
    packed_data->args.t = (GLdouble)_t; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiTexCoord2d(packed, ret_v) do { \
    PACKED_glMultiTexCoord2d *unpacked = (PACKED_glMultiTexCoord2d *)packed; \
    ARGS_glMultiTexCoord2d *args = (ARGS_glMultiTexCoord2d *)&unpacked->args; \
    glMultiTexCoord2d(args->target, args->s, args->t);; \
} while(0)
void glMultiTexCoord2d(glMultiTexCoord2d_ARG_EXPAND);
typedef void (*glMultiTexCoord2d_PTR)(glMultiTexCoord2d_ARG_EXPAND);
#define glMultiTexCoord2dARB_INDEX 1333
#define glMultiTexCoord2dARB_RETURN void
#define glMultiTexCoord2dARB_ARG_NAMES target, s, t
#define glMultiTexCoord2dARB_ARG_EXPAND GLenum target, GLdouble s, GLdouble t
#define glMultiTexCoord2dARB_PACKED PACKED_glMultiTexCoord2dARB
#define glMultiTexCoord2dARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiTexCoord2dARB_NOT_VOID_WRAP(...) {}
#define pack_glMultiTexCoord2dARB(_target, _s, _t) ({ \
    glMultiTexCoord2dARB_PACKED *packed_data = malloc(sizeof(glMultiTexCoord2dARB_PACKED)); \
    packed_data->index = glMultiTexCoord2dARB_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.s = (GLdouble)_s; \
    packed_data->args.t = (GLdouble)_t; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiTexCoord2dARB(packed, ret_v) do { \
    PACKED_glMultiTexCoord2dARB *unpacked = (PACKED_glMultiTexCoord2dARB *)packed; \
    ARGS_glMultiTexCoord2dARB *args = (ARGS_glMultiTexCoord2dARB *)&unpacked->args; \
    glMultiTexCoord2dARB(args->target, args->s, args->t);; \
} while(0)
void glMultiTexCoord2dARB(glMultiTexCoord2dARB_ARG_EXPAND);
typedef void (*glMultiTexCoord2dARB_PTR)(glMultiTexCoord2dARB_ARG_EXPAND);
#define glMultiTexCoord2dv_INDEX 1334
#define glMultiTexCoord2dv_RETURN void
#define glMultiTexCoord2dv_ARG_NAMES target, v
#define glMultiTexCoord2dv_ARG_EXPAND GLenum target, const GLdouble * v
#define glMultiTexCoord2dv_PACKED PACKED_glMultiTexCoord2dv
#define glMultiTexCoord2dv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiTexCoord2dv_NOT_VOID_WRAP(...) {}
#define pack_glMultiTexCoord2dv(_target, _v) ({ \
    glMultiTexCoord2dv_PACKED *packed_data = malloc(sizeof(glMultiTexCoord2dv_PACKED)); \
    packed_data->index = glMultiTexCoord2dv_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.v = (GLdouble *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiTexCoord2dv(packed, ret_v) do { \
    PACKED_glMultiTexCoord2dv *unpacked = (PACKED_glMultiTexCoord2dv *)packed; \
    ARGS_glMultiTexCoord2dv *args = (ARGS_glMultiTexCoord2dv *)&unpacked->args; \
    glMultiTexCoord2dv(args->target, args->v);; \
} while(0)
void glMultiTexCoord2dv(glMultiTexCoord2dv_ARG_EXPAND);
typedef void (*glMultiTexCoord2dv_PTR)(glMultiTexCoord2dv_ARG_EXPAND);
#define glMultiTexCoord2dvARB_INDEX 1335
#define glMultiTexCoord2dvARB_RETURN void
#define glMultiTexCoord2dvARB_ARG_NAMES target, v
#define glMultiTexCoord2dvARB_ARG_EXPAND GLenum target, const GLdouble * v
#define glMultiTexCoord2dvARB_PACKED PACKED_glMultiTexCoord2dvARB
#define glMultiTexCoord2dvARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiTexCoord2dvARB_NOT_VOID_WRAP(...) {}
#define pack_glMultiTexCoord2dvARB(_target, _v) ({ \
    glMultiTexCoord2dvARB_PACKED *packed_data = malloc(sizeof(glMultiTexCoord2dvARB_PACKED)); \
    packed_data->index = glMultiTexCoord2dvARB_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.v = (GLdouble *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiTexCoord2dvARB(packed, ret_v) do { \
    PACKED_glMultiTexCoord2dvARB *unpacked = (PACKED_glMultiTexCoord2dvARB *)packed; \
    ARGS_glMultiTexCoord2dvARB *args = (ARGS_glMultiTexCoord2dvARB *)&unpacked->args; \
    glMultiTexCoord2dvARB(args->target, args->v);; \
} while(0)
void glMultiTexCoord2dvARB(glMultiTexCoord2dvARB_ARG_EXPAND);
typedef void (*glMultiTexCoord2dvARB_PTR)(glMultiTexCoord2dvARB_ARG_EXPAND);
#define glMultiTexCoord2f_INDEX 1336
#define glMultiTexCoord2f_RETURN void
#define glMultiTexCoord2f_ARG_NAMES target, s, t
#define glMultiTexCoord2f_ARG_EXPAND GLenum target, GLfloat s, GLfloat t
#define glMultiTexCoord2f_PACKED PACKED_glMultiTexCoord2f
#define glMultiTexCoord2f_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiTexCoord2f_NOT_VOID_WRAP(...) {}
#define pack_glMultiTexCoord2f(_target, _s, _t) ({ \
    glMultiTexCoord2f_PACKED *packed_data = malloc(sizeof(glMultiTexCoord2f_PACKED)); \
    packed_data->index = glMultiTexCoord2f_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.s = (GLfloat)_s; \
    packed_data->args.t = (GLfloat)_t; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiTexCoord2f(packed, ret_v) do { \
    PACKED_glMultiTexCoord2f *unpacked = (PACKED_glMultiTexCoord2f *)packed; \
    ARGS_glMultiTexCoord2f *args = (ARGS_glMultiTexCoord2f *)&unpacked->args; \
    glMultiTexCoord2f(args->target, args->s, args->t);; \
} while(0)
void glMultiTexCoord2f(glMultiTexCoord2f_ARG_EXPAND);
typedef void (*glMultiTexCoord2f_PTR)(glMultiTexCoord2f_ARG_EXPAND);
#define glMultiTexCoord2fARB_INDEX 1337
#define glMultiTexCoord2fARB_RETURN void
#define glMultiTexCoord2fARB_ARG_NAMES target, s, t
#define glMultiTexCoord2fARB_ARG_EXPAND GLenum target, GLfloat s, GLfloat t
#define glMultiTexCoord2fARB_PACKED PACKED_glMultiTexCoord2fARB
#define glMultiTexCoord2fARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiTexCoord2fARB_NOT_VOID_WRAP(...) {}
#define pack_glMultiTexCoord2fARB(_target, _s, _t) ({ \
    glMultiTexCoord2fARB_PACKED *packed_data = malloc(sizeof(glMultiTexCoord2fARB_PACKED)); \
    packed_data->index = glMultiTexCoord2fARB_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.s = (GLfloat)_s; \
    packed_data->args.t = (GLfloat)_t; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiTexCoord2fARB(packed, ret_v) do { \
    PACKED_glMultiTexCoord2fARB *unpacked = (PACKED_glMultiTexCoord2fARB *)packed; \
    ARGS_glMultiTexCoord2fARB *args = (ARGS_glMultiTexCoord2fARB *)&unpacked->args; \
    glMultiTexCoord2fARB(args->target, args->s, args->t);; \
} while(0)
void glMultiTexCoord2fARB(glMultiTexCoord2fARB_ARG_EXPAND);
typedef void (*glMultiTexCoord2fARB_PTR)(glMultiTexCoord2fARB_ARG_EXPAND);
#define glMultiTexCoord2fv_INDEX 1338
#define glMultiTexCoord2fv_RETURN void
#define glMultiTexCoord2fv_ARG_NAMES target, v
#define glMultiTexCoord2fv_ARG_EXPAND GLenum target, const GLfloat * v
#define glMultiTexCoord2fv_PACKED PACKED_glMultiTexCoord2fv
#define glMultiTexCoord2fv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiTexCoord2fv_NOT_VOID_WRAP(...) {}
#define pack_glMultiTexCoord2fv(_target, _v) ({ \
    glMultiTexCoord2fv_PACKED *packed_data = malloc(sizeof(glMultiTexCoord2fv_PACKED)); \
    packed_data->index = glMultiTexCoord2fv_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.v = (GLfloat *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiTexCoord2fv(packed, ret_v) do { \
    PACKED_glMultiTexCoord2fv *unpacked = (PACKED_glMultiTexCoord2fv *)packed; \
    ARGS_glMultiTexCoord2fv *args = (ARGS_glMultiTexCoord2fv *)&unpacked->args; \
    glMultiTexCoord2fv(args->target, args->v);; \
} while(0)
void glMultiTexCoord2fv(glMultiTexCoord2fv_ARG_EXPAND);
typedef void (*glMultiTexCoord2fv_PTR)(glMultiTexCoord2fv_ARG_EXPAND);
#define glMultiTexCoord2fvARB_INDEX 1339
#define glMultiTexCoord2fvARB_RETURN void
#define glMultiTexCoord2fvARB_ARG_NAMES target, v
#define glMultiTexCoord2fvARB_ARG_EXPAND GLenum target, const GLfloat * v
#define glMultiTexCoord2fvARB_PACKED PACKED_glMultiTexCoord2fvARB
#define glMultiTexCoord2fvARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiTexCoord2fvARB_NOT_VOID_WRAP(...) {}
#define pack_glMultiTexCoord2fvARB(_target, _v) ({ \
    glMultiTexCoord2fvARB_PACKED *packed_data = malloc(sizeof(glMultiTexCoord2fvARB_PACKED)); \
    packed_data->index = glMultiTexCoord2fvARB_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.v = (GLfloat *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiTexCoord2fvARB(packed, ret_v) do { \
    PACKED_glMultiTexCoord2fvARB *unpacked = (PACKED_glMultiTexCoord2fvARB *)packed; \
    ARGS_glMultiTexCoord2fvARB *args = (ARGS_glMultiTexCoord2fvARB *)&unpacked->args; \
    glMultiTexCoord2fvARB(args->target, args->v);; \
} while(0)
void glMultiTexCoord2fvARB(glMultiTexCoord2fvARB_ARG_EXPAND);
typedef void (*glMultiTexCoord2fvARB_PTR)(glMultiTexCoord2fvARB_ARG_EXPAND);
#define glMultiTexCoord2hNV_INDEX 1340
#define glMultiTexCoord2hNV_RETURN void
#define glMultiTexCoord2hNV_ARG_NAMES target, s, t
#define glMultiTexCoord2hNV_ARG_EXPAND GLenum target, GLhalfNV s, GLhalfNV t
#define glMultiTexCoord2hNV_PACKED PACKED_glMultiTexCoord2hNV
#define glMultiTexCoord2hNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiTexCoord2hNV_NOT_VOID_WRAP(...) {}
#define pack_glMultiTexCoord2hNV(_target, _s, _t) ({ \
    glMultiTexCoord2hNV_PACKED *packed_data = malloc(sizeof(glMultiTexCoord2hNV_PACKED)); \
    packed_data->index = glMultiTexCoord2hNV_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.s = (GLhalfNV)_s; \
    packed_data->args.t = (GLhalfNV)_t; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiTexCoord2hNV(packed, ret_v) do { \
    PACKED_glMultiTexCoord2hNV *unpacked = (PACKED_glMultiTexCoord2hNV *)packed; \
    ARGS_glMultiTexCoord2hNV *args = (ARGS_glMultiTexCoord2hNV *)&unpacked->args; \
    glMultiTexCoord2hNV(args->target, args->s, args->t);; \
} while(0)
void glMultiTexCoord2hNV(glMultiTexCoord2hNV_ARG_EXPAND);
typedef void (*glMultiTexCoord2hNV_PTR)(glMultiTexCoord2hNV_ARG_EXPAND);
#define glMultiTexCoord2hvNV_INDEX 1341
#define glMultiTexCoord2hvNV_RETURN void
#define glMultiTexCoord2hvNV_ARG_NAMES target, v
#define glMultiTexCoord2hvNV_ARG_EXPAND GLenum target, const GLhalfNV * v
#define glMultiTexCoord2hvNV_PACKED PACKED_glMultiTexCoord2hvNV
#define glMultiTexCoord2hvNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiTexCoord2hvNV_NOT_VOID_WRAP(...) {}
#define pack_glMultiTexCoord2hvNV(_target, _v) ({ \
    glMultiTexCoord2hvNV_PACKED *packed_data = malloc(sizeof(glMultiTexCoord2hvNV_PACKED)); \
    packed_data->index = glMultiTexCoord2hvNV_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.v = (GLhalfNV *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiTexCoord2hvNV(packed, ret_v) do { \
    PACKED_glMultiTexCoord2hvNV *unpacked = (PACKED_glMultiTexCoord2hvNV *)packed; \
    ARGS_glMultiTexCoord2hvNV *args = (ARGS_glMultiTexCoord2hvNV *)&unpacked->args; \
    glMultiTexCoord2hvNV(args->target, args->v);; \
} while(0)
void glMultiTexCoord2hvNV(glMultiTexCoord2hvNV_ARG_EXPAND);
typedef void (*glMultiTexCoord2hvNV_PTR)(glMultiTexCoord2hvNV_ARG_EXPAND);
#define glMultiTexCoord2i_INDEX 1342
#define glMultiTexCoord2i_RETURN void
#define glMultiTexCoord2i_ARG_NAMES target, s, t
#define glMultiTexCoord2i_ARG_EXPAND GLenum target, GLint s, GLint t
#define glMultiTexCoord2i_PACKED PACKED_glMultiTexCoord2i
#define glMultiTexCoord2i_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiTexCoord2i_NOT_VOID_WRAP(...) {}
#define pack_glMultiTexCoord2i(_target, _s, _t) ({ \
    glMultiTexCoord2i_PACKED *packed_data = malloc(sizeof(glMultiTexCoord2i_PACKED)); \
    packed_data->index = glMultiTexCoord2i_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.s = (GLint)_s; \
    packed_data->args.t = (GLint)_t; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiTexCoord2i(packed, ret_v) do { \
    PACKED_glMultiTexCoord2i *unpacked = (PACKED_glMultiTexCoord2i *)packed; \
    ARGS_glMultiTexCoord2i *args = (ARGS_glMultiTexCoord2i *)&unpacked->args; \
    glMultiTexCoord2i(args->target, args->s, args->t);; \
} while(0)
void glMultiTexCoord2i(glMultiTexCoord2i_ARG_EXPAND);
typedef void (*glMultiTexCoord2i_PTR)(glMultiTexCoord2i_ARG_EXPAND);
#define glMultiTexCoord2iARB_INDEX 1343
#define glMultiTexCoord2iARB_RETURN void
#define glMultiTexCoord2iARB_ARG_NAMES target, s, t
#define glMultiTexCoord2iARB_ARG_EXPAND GLenum target, GLint s, GLint t
#define glMultiTexCoord2iARB_PACKED PACKED_glMultiTexCoord2iARB
#define glMultiTexCoord2iARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiTexCoord2iARB_NOT_VOID_WRAP(...) {}
#define pack_glMultiTexCoord2iARB(_target, _s, _t) ({ \
    glMultiTexCoord2iARB_PACKED *packed_data = malloc(sizeof(glMultiTexCoord2iARB_PACKED)); \
    packed_data->index = glMultiTexCoord2iARB_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.s = (GLint)_s; \
    packed_data->args.t = (GLint)_t; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiTexCoord2iARB(packed, ret_v) do { \
    PACKED_glMultiTexCoord2iARB *unpacked = (PACKED_glMultiTexCoord2iARB *)packed; \
    ARGS_glMultiTexCoord2iARB *args = (ARGS_glMultiTexCoord2iARB *)&unpacked->args; \
    glMultiTexCoord2iARB(args->target, args->s, args->t);; \
} while(0)
void glMultiTexCoord2iARB(glMultiTexCoord2iARB_ARG_EXPAND);
typedef void (*glMultiTexCoord2iARB_PTR)(glMultiTexCoord2iARB_ARG_EXPAND);
#define glMultiTexCoord2iv_INDEX 1344
#define glMultiTexCoord2iv_RETURN void
#define glMultiTexCoord2iv_ARG_NAMES target, v
#define glMultiTexCoord2iv_ARG_EXPAND GLenum target, const GLint * v
#define glMultiTexCoord2iv_PACKED PACKED_glMultiTexCoord2iv
#define glMultiTexCoord2iv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiTexCoord2iv_NOT_VOID_WRAP(...) {}
#define pack_glMultiTexCoord2iv(_target, _v) ({ \
    glMultiTexCoord2iv_PACKED *packed_data = malloc(sizeof(glMultiTexCoord2iv_PACKED)); \
    packed_data->index = glMultiTexCoord2iv_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.v = (GLint *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiTexCoord2iv(packed, ret_v) do { \
    PACKED_glMultiTexCoord2iv *unpacked = (PACKED_glMultiTexCoord2iv *)packed; \
    ARGS_glMultiTexCoord2iv *args = (ARGS_glMultiTexCoord2iv *)&unpacked->args; \
    glMultiTexCoord2iv(args->target, args->v);; \
} while(0)
void glMultiTexCoord2iv(glMultiTexCoord2iv_ARG_EXPAND);
typedef void (*glMultiTexCoord2iv_PTR)(glMultiTexCoord2iv_ARG_EXPAND);
#define glMultiTexCoord2ivARB_INDEX 1345
#define glMultiTexCoord2ivARB_RETURN void
#define glMultiTexCoord2ivARB_ARG_NAMES target, v
#define glMultiTexCoord2ivARB_ARG_EXPAND GLenum target, const GLint * v
#define glMultiTexCoord2ivARB_PACKED PACKED_glMultiTexCoord2ivARB
#define glMultiTexCoord2ivARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiTexCoord2ivARB_NOT_VOID_WRAP(...) {}
#define pack_glMultiTexCoord2ivARB(_target, _v) ({ \
    glMultiTexCoord2ivARB_PACKED *packed_data = malloc(sizeof(glMultiTexCoord2ivARB_PACKED)); \
    packed_data->index = glMultiTexCoord2ivARB_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.v = (GLint *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiTexCoord2ivARB(packed, ret_v) do { \
    PACKED_glMultiTexCoord2ivARB *unpacked = (PACKED_glMultiTexCoord2ivARB *)packed; \
    ARGS_glMultiTexCoord2ivARB *args = (ARGS_glMultiTexCoord2ivARB *)&unpacked->args; \
    glMultiTexCoord2ivARB(args->target, args->v);; \
} while(0)
void glMultiTexCoord2ivARB(glMultiTexCoord2ivARB_ARG_EXPAND);
typedef void (*glMultiTexCoord2ivARB_PTR)(glMultiTexCoord2ivARB_ARG_EXPAND);
#define glMultiTexCoord2s_INDEX 1346
#define glMultiTexCoord2s_RETURN void
#define glMultiTexCoord2s_ARG_NAMES target, s, t
#define glMultiTexCoord2s_ARG_EXPAND GLenum target, GLshort s, GLshort t
#define glMultiTexCoord2s_PACKED PACKED_glMultiTexCoord2s
#define glMultiTexCoord2s_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiTexCoord2s_NOT_VOID_WRAP(...) {}
#define pack_glMultiTexCoord2s(_target, _s, _t) ({ \
    glMultiTexCoord2s_PACKED *packed_data = malloc(sizeof(glMultiTexCoord2s_PACKED)); \
    packed_data->index = glMultiTexCoord2s_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.s = (GLshort)_s; \
    packed_data->args.t = (GLshort)_t; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiTexCoord2s(packed, ret_v) do { \
    PACKED_glMultiTexCoord2s *unpacked = (PACKED_glMultiTexCoord2s *)packed; \
    ARGS_glMultiTexCoord2s *args = (ARGS_glMultiTexCoord2s *)&unpacked->args; \
    glMultiTexCoord2s(args->target, args->s, args->t);; \
} while(0)
void glMultiTexCoord2s(glMultiTexCoord2s_ARG_EXPAND);
typedef void (*glMultiTexCoord2s_PTR)(glMultiTexCoord2s_ARG_EXPAND);
#define glMultiTexCoord2sARB_INDEX 1347
#define glMultiTexCoord2sARB_RETURN void
#define glMultiTexCoord2sARB_ARG_NAMES target, s, t
#define glMultiTexCoord2sARB_ARG_EXPAND GLenum target, GLshort s, GLshort t
#define glMultiTexCoord2sARB_PACKED PACKED_glMultiTexCoord2sARB
#define glMultiTexCoord2sARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiTexCoord2sARB_NOT_VOID_WRAP(...) {}
#define pack_glMultiTexCoord2sARB(_target, _s, _t) ({ \
    glMultiTexCoord2sARB_PACKED *packed_data = malloc(sizeof(glMultiTexCoord2sARB_PACKED)); \
    packed_data->index = glMultiTexCoord2sARB_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.s = (GLshort)_s; \
    packed_data->args.t = (GLshort)_t; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiTexCoord2sARB(packed, ret_v) do { \
    PACKED_glMultiTexCoord2sARB *unpacked = (PACKED_glMultiTexCoord2sARB *)packed; \
    ARGS_glMultiTexCoord2sARB *args = (ARGS_glMultiTexCoord2sARB *)&unpacked->args; \
    glMultiTexCoord2sARB(args->target, args->s, args->t);; \
} while(0)
void glMultiTexCoord2sARB(glMultiTexCoord2sARB_ARG_EXPAND);
typedef void (*glMultiTexCoord2sARB_PTR)(glMultiTexCoord2sARB_ARG_EXPAND);
#define glMultiTexCoord2sv_INDEX 1348
#define glMultiTexCoord2sv_RETURN void
#define glMultiTexCoord2sv_ARG_NAMES target, v
#define glMultiTexCoord2sv_ARG_EXPAND GLenum target, const GLshort * v
#define glMultiTexCoord2sv_PACKED PACKED_glMultiTexCoord2sv
#define glMultiTexCoord2sv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiTexCoord2sv_NOT_VOID_WRAP(...) {}
#define pack_glMultiTexCoord2sv(_target, _v) ({ \
    glMultiTexCoord2sv_PACKED *packed_data = malloc(sizeof(glMultiTexCoord2sv_PACKED)); \
    packed_data->index = glMultiTexCoord2sv_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.v = (GLshort *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiTexCoord2sv(packed, ret_v) do { \
    PACKED_glMultiTexCoord2sv *unpacked = (PACKED_glMultiTexCoord2sv *)packed; \
    ARGS_glMultiTexCoord2sv *args = (ARGS_glMultiTexCoord2sv *)&unpacked->args; \
    glMultiTexCoord2sv(args->target, args->v);; \
} while(0)
void glMultiTexCoord2sv(glMultiTexCoord2sv_ARG_EXPAND);
typedef void (*glMultiTexCoord2sv_PTR)(glMultiTexCoord2sv_ARG_EXPAND);
#define glMultiTexCoord2svARB_INDEX 1349
#define glMultiTexCoord2svARB_RETURN void
#define glMultiTexCoord2svARB_ARG_NAMES target, v
#define glMultiTexCoord2svARB_ARG_EXPAND GLenum target, const GLshort * v
#define glMultiTexCoord2svARB_PACKED PACKED_glMultiTexCoord2svARB
#define glMultiTexCoord2svARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiTexCoord2svARB_NOT_VOID_WRAP(...) {}
#define pack_glMultiTexCoord2svARB(_target, _v) ({ \
    glMultiTexCoord2svARB_PACKED *packed_data = malloc(sizeof(glMultiTexCoord2svARB_PACKED)); \
    packed_data->index = glMultiTexCoord2svARB_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.v = (GLshort *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiTexCoord2svARB(packed, ret_v) do { \
    PACKED_glMultiTexCoord2svARB *unpacked = (PACKED_glMultiTexCoord2svARB *)packed; \
    ARGS_glMultiTexCoord2svARB *args = (ARGS_glMultiTexCoord2svARB *)&unpacked->args; \
    glMultiTexCoord2svARB(args->target, args->v);; \
} while(0)
void glMultiTexCoord2svARB(glMultiTexCoord2svARB_ARG_EXPAND);
typedef void (*glMultiTexCoord2svARB_PTR)(glMultiTexCoord2svARB_ARG_EXPAND);
#define glMultiTexCoord2xOES_INDEX 1350
#define glMultiTexCoord2xOES_RETURN void
#define glMultiTexCoord2xOES_ARG_NAMES texture, s, t
#define glMultiTexCoord2xOES_ARG_EXPAND GLenum texture, GLfixed s, GLfixed t
#define glMultiTexCoord2xOES_PACKED PACKED_glMultiTexCoord2xOES
#define glMultiTexCoord2xOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiTexCoord2xOES_NOT_VOID_WRAP(...) {}
#define pack_glMultiTexCoord2xOES(_texture, _s, _t) ({ \
    glMultiTexCoord2xOES_PACKED *packed_data = malloc(sizeof(glMultiTexCoord2xOES_PACKED)); \
    packed_data->index = glMultiTexCoord2xOES_INDEX; \
    packed_data->args.texture = (GLenum)_texture; \
    packed_data->args.s = (GLfixed)_s; \
    packed_data->args.t = (GLfixed)_t; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiTexCoord2xOES(packed, ret_v) do { \
    PACKED_glMultiTexCoord2xOES *unpacked = (PACKED_glMultiTexCoord2xOES *)packed; \
    ARGS_glMultiTexCoord2xOES *args = (ARGS_glMultiTexCoord2xOES *)&unpacked->args; \
    glMultiTexCoord2xOES(args->texture, args->s, args->t);; \
} while(0)
void glMultiTexCoord2xOES(glMultiTexCoord2xOES_ARG_EXPAND);
typedef void (*glMultiTexCoord2xOES_PTR)(glMultiTexCoord2xOES_ARG_EXPAND);
#define glMultiTexCoord2xvOES_INDEX 1351
#define glMultiTexCoord2xvOES_RETURN void
#define glMultiTexCoord2xvOES_ARG_NAMES texture, coords
#define glMultiTexCoord2xvOES_ARG_EXPAND GLenum texture, const GLfixed * coords
#define glMultiTexCoord2xvOES_PACKED PACKED_glMultiTexCoord2xvOES
#define glMultiTexCoord2xvOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiTexCoord2xvOES_NOT_VOID_WRAP(...) {}
#define pack_glMultiTexCoord2xvOES(_texture, _coords) ({ \
    glMultiTexCoord2xvOES_PACKED *packed_data = malloc(sizeof(glMultiTexCoord2xvOES_PACKED)); \
    packed_data->index = glMultiTexCoord2xvOES_INDEX; \
    packed_data->args.texture = (GLenum)_texture; \
    packed_data->args.coords = (GLfixed *)_coords; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiTexCoord2xvOES(packed, ret_v) do { \
    PACKED_glMultiTexCoord2xvOES *unpacked = (PACKED_glMultiTexCoord2xvOES *)packed; \
    ARGS_glMultiTexCoord2xvOES *args = (ARGS_glMultiTexCoord2xvOES *)&unpacked->args; \
    glMultiTexCoord2xvOES(args->texture, args->coords);; \
} while(0)
void glMultiTexCoord2xvOES(glMultiTexCoord2xvOES_ARG_EXPAND);
typedef void (*glMultiTexCoord2xvOES_PTR)(glMultiTexCoord2xvOES_ARG_EXPAND);
#define glMultiTexCoord3bOES_INDEX 1352
#define glMultiTexCoord3bOES_RETURN void
#define glMultiTexCoord3bOES_ARG_NAMES texture, s, t, r
#define glMultiTexCoord3bOES_ARG_EXPAND GLenum texture, GLbyte s, GLbyte t, GLbyte r
#define glMultiTexCoord3bOES_PACKED PACKED_glMultiTexCoord3bOES
#define glMultiTexCoord3bOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiTexCoord3bOES_NOT_VOID_WRAP(...) {}
#define pack_glMultiTexCoord3bOES(_texture, _s, _t, _r) ({ \
    glMultiTexCoord3bOES_PACKED *packed_data = malloc(sizeof(glMultiTexCoord3bOES_PACKED)); \
    packed_data->index = glMultiTexCoord3bOES_INDEX; \
    packed_data->args.texture = (GLenum)_texture; \
    packed_data->args.s = (GLbyte)_s; \
    packed_data->args.t = (GLbyte)_t; \
    packed_data->args.r = (GLbyte)_r; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiTexCoord3bOES(packed, ret_v) do { \
    PACKED_glMultiTexCoord3bOES *unpacked = (PACKED_glMultiTexCoord3bOES *)packed; \
    ARGS_glMultiTexCoord3bOES *args = (ARGS_glMultiTexCoord3bOES *)&unpacked->args; \
    glMultiTexCoord3bOES(args->texture, args->s, args->t, args->r);; \
} while(0)
void glMultiTexCoord3bOES(glMultiTexCoord3bOES_ARG_EXPAND);
typedef void (*glMultiTexCoord3bOES_PTR)(glMultiTexCoord3bOES_ARG_EXPAND);
#define glMultiTexCoord3bvOES_INDEX 1353
#define glMultiTexCoord3bvOES_RETURN void
#define glMultiTexCoord3bvOES_ARG_NAMES texture, coords
#define glMultiTexCoord3bvOES_ARG_EXPAND GLenum texture, const GLbyte * coords
#define glMultiTexCoord3bvOES_PACKED PACKED_glMultiTexCoord3bvOES
#define glMultiTexCoord3bvOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiTexCoord3bvOES_NOT_VOID_WRAP(...) {}
#define pack_glMultiTexCoord3bvOES(_texture, _coords) ({ \
    glMultiTexCoord3bvOES_PACKED *packed_data = malloc(sizeof(glMultiTexCoord3bvOES_PACKED)); \
    packed_data->index = glMultiTexCoord3bvOES_INDEX; \
    packed_data->args.texture = (GLenum)_texture; \
    packed_data->args.coords = (GLbyte *)_coords; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiTexCoord3bvOES(packed, ret_v) do { \
    PACKED_glMultiTexCoord3bvOES *unpacked = (PACKED_glMultiTexCoord3bvOES *)packed; \
    ARGS_glMultiTexCoord3bvOES *args = (ARGS_glMultiTexCoord3bvOES *)&unpacked->args; \
    glMultiTexCoord3bvOES(args->texture, args->coords);; \
} while(0)
void glMultiTexCoord3bvOES(glMultiTexCoord3bvOES_ARG_EXPAND);
typedef void (*glMultiTexCoord3bvOES_PTR)(glMultiTexCoord3bvOES_ARG_EXPAND);
#define glMultiTexCoord3d_INDEX 1354
#define glMultiTexCoord3d_RETURN void
#define glMultiTexCoord3d_ARG_NAMES target, s, t, r
#define glMultiTexCoord3d_ARG_EXPAND GLenum target, GLdouble s, GLdouble t, GLdouble r
#define glMultiTexCoord3d_PACKED PACKED_glMultiTexCoord3d
#define glMultiTexCoord3d_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiTexCoord3d_NOT_VOID_WRAP(...) {}
#define pack_glMultiTexCoord3d(_target, _s, _t, _r) ({ \
    glMultiTexCoord3d_PACKED *packed_data = malloc(sizeof(glMultiTexCoord3d_PACKED)); \
    packed_data->index = glMultiTexCoord3d_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.s = (GLdouble)_s; \
    packed_data->args.t = (GLdouble)_t; \
    packed_data->args.r = (GLdouble)_r; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiTexCoord3d(packed, ret_v) do { \
    PACKED_glMultiTexCoord3d *unpacked = (PACKED_glMultiTexCoord3d *)packed; \
    ARGS_glMultiTexCoord3d *args = (ARGS_glMultiTexCoord3d *)&unpacked->args; \
    glMultiTexCoord3d(args->target, args->s, args->t, args->r);; \
} while(0)
void glMultiTexCoord3d(glMultiTexCoord3d_ARG_EXPAND);
typedef void (*glMultiTexCoord3d_PTR)(glMultiTexCoord3d_ARG_EXPAND);
#define glMultiTexCoord3dARB_INDEX 1355
#define glMultiTexCoord3dARB_RETURN void
#define glMultiTexCoord3dARB_ARG_NAMES target, s, t, r
#define glMultiTexCoord3dARB_ARG_EXPAND GLenum target, GLdouble s, GLdouble t, GLdouble r
#define glMultiTexCoord3dARB_PACKED PACKED_glMultiTexCoord3dARB
#define glMultiTexCoord3dARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiTexCoord3dARB_NOT_VOID_WRAP(...) {}
#define pack_glMultiTexCoord3dARB(_target, _s, _t, _r) ({ \
    glMultiTexCoord3dARB_PACKED *packed_data = malloc(sizeof(glMultiTexCoord3dARB_PACKED)); \
    packed_data->index = glMultiTexCoord3dARB_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.s = (GLdouble)_s; \
    packed_data->args.t = (GLdouble)_t; \
    packed_data->args.r = (GLdouble)_r; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiTexCoord3dARB(packed, ret_v) do { \
    PACKED_glMultiTexCoord3dARB *unpacked = (PACKED_glMultiTexCoord3dARB *)packed; \
    ARGS_glMultiTexCoord3dARB *args = (ARGS_glMultiTexCoord3dARB *)&unpacked->args; \
    glMultiTexCoord3dARB(args->target, args->s, args->t, args->r);; \
} while(0)
void glMultiTexCoord3dARB(glMultiTexCoord3dARB_ARG_EXPAND);
typedef void (*glMultiTexCoord3dARB_PTR)(glMultiTexCoord3dARB_ARG_EXPAND);
#define glMultiTexCoord3dv_INDEX 1356
#define glMultiTexCoord3dv_RETURN void
#define glMultiTexCoord3dv_ARG_NAMES target, v
#define glMultiTexCoord3dv_ARG_EXPAND GLenum target, const GLdouble * v
#define glMultiTexCoord3dv_PACKED PACKED_glMultiTexCoord3dv
#define glMultiTexCoord3dv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiTexCoord3dv_NOT_VOID_WRAP(...) {}
#define pack_glMultiTexCoord3dv(_target, _v) ({ \
    glMultiTexCoord3dv_PACKED *packed_data = malloc(sizeof(glMultiTexCoord3dv_PACKED)); \
    packed_data->index = glMultiTexCoord3dv_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.v = (GLdouble *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiTexCoord3dv(packed, ret_v) do { \
    PACKED_glMultiTexCoord3dv *unpacked = (PACKED_glMultiTexCoord3dv *)packed; \
    ARGS_glMultiTexCoord3dv *args = (ARGS_glMultiTexCoord3dv *)&unpacked->args; \
    glMultiTexCoord3dv(args->target, args->v);; \
} while(0)
void glMultiTexCoord3dv(glMultiTexCoord3dv_ARG_EXPAND);
typedef void (*glMultiTexCoord3dv_PTR)(glMultiTexCoord3dv_ARG_EXPAND);
#define glMultiTexCoord3dvARB_INDEX 1357
#define glMultiTexCoord3dvARB_RETURN void
#define glMultiTexCoord3dvARB_ARG_NAMES target, v
#define glMultiTexCoord3dvARB_ARG_EXPAND GLenum target, const GLdouble * v
#define glMultiTexCoord3dvARB_PACKED PACKED_glMultiTexCoord3dvARB
#define glMultiTexCoord3dvARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiTexCoord3dvARB_NOT_VOID_WRAP(...) {}
#define pack_glMultiTexCoord3dvARB(_target, _v) ({ \
    glMultiTexCoord3dvARB_PACKED *packed_data = malloc(sizeof(glMultiTexCoord3dvARB_PACKED)); \
    packed_data->index = glMultiTexCoord3dvARB_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.v = (GLdouble *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiTexCoord3dvARB(packed, ret_v) do { \
    PACKED_glMultiTexCoord3dvARB *unpacked = (PACKED_glMultiTexCoord3dvARB *)packed; \
    ARGS_glMultiTexCoord3dvARB *args = (ARGS_glMultiTexCoord3dvARB *)&unpacked->args; \
    glMultiTexCoord3dvARB(args->target, args->v);; \
} while(0)
void glMultiTexCoord3dvARB(glMultiTexCoord3dvARB_ARG_EXPAND);
typedef void (*glMultiTexCoord3dvARB_PTR)(glMultiTexCoord3dvARB_ARG_EXPAND);
#define glMultiTexCoord3f_INDEX 1358
#define glMultiTexCoord3f_RETURN void
#define glMultiTexCoord3f_ARG_NAMES target, s, t, r
#define glMultiTexCoord3f_ARG_EXPAND GLenum target, GLfloat s, GLfloat t, GLfloat r
#define glMultiTexCoord3f_PACKED PACKED_glMultiTexCoord3f
#define glMultiTexCoord3f_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiTexCoord3f_NOT_VOID_WRAP(...) {}
#define pack_glMultiTexCoord3f(_target, _s, _t, _r) ({ \
    glMultiTexCoord3f_PACKED *packed_data = malloc(sizeof(glMultiTexCoord3f_PACKED)); \
    packed_data->index = glMultiTexCoord3f_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.s = (GLfloat)_s; \
    packed_data->args.t = (GLfloat)_t; \
    packed_data->args.r = (GLfloat)_r; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiTexCoord3f(packed, ret_v) do { \
    PACKED_glMultiTexCoord3f *unpacked = (PACKED_glMultiTexCoord3f *)packed; \
    ARGS_glMultiTexCoord3f *args = (ARGS_glMultiTexCoord3f *)&unpacked->args; \
    glMultiTexCoord3f(args->target, args->s, args->t, args->r);; \
} while(0)
void glMultiTexCoord3f(glMultiTexCoord3f_ARG_EXPAND);
typedef void (*glMultiTexCoord3f_PTR)(glMultiTexCoord3f_ARG_EXPAND);
#define glMultiTexCoord3fARB_INDEX 1359
#define glMultiTexCoord3fARB_RETURN void
#define glMultiTexCoord3fARB_ARG_NAMES target, s, t, r
#define glMultiTexCoord3fARB_ARG_EXPAND GLenum target, GLfloat s, GLfloat t, GLfloat r
#define glMultiTexCoord3fARB_PACKED PACKED_glMultiTexCoord3fARB
#define glMultiTexCoord3fARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiTexCoord3fARB_NOT_VOID_WRAP(...) {}
#define pack_glMultiTexCoord3fARB(_target, _s, _t, _r) ({ \
    glMultiTexCoord3fARB_PACKED *packed_data = malloc(sizeof(glMultiTexCoord3fARB_PACKED)); \
    packed_data->index = glMultiTexCoord3fARB_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.s = (GLfloat)_s; \
    packed_data->args.t = (GLfloat)_t; \
    packed_data->args.r = (GLfloat)_r; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiTexCoord3fARB(packed, ret_v) do { \
    PACKED_glMultiTexCoord3fARB *unpacked = (PACKED_glMultiTexCoord3fARB *)packed; \
    ARGS_glMultiTexCoord3fARB *args = (ARGS_glMultiTexCoord3fARB *)&unpacked->args; \
    glMultiTexCoord3fARB(args->target, args->s, args->t, args->r);; \
} while(0)
void glMultiTexCoord3fARB(glMultiTexCoord3fARB_ARG_EXPAND);
typedef void (*glMultiTexCoord3fARB_PTR)(glMultiTexCoord3fARB_ARG_EXPAND);
#define glMultiTexCoord3fv_INDEX 1360
#define glMultiTexCoord3fv_RETURN void
#define glMultiTexCoord3fv_ARG_NAMES target, v
#define glMultiTexCoord3fv_ARG_EXPAND GLenum target, const GLfloat * v
#define glMultiTexCoord3fv_PACKED PACKED_glMultiTexCoord3fv
#define glMultiTexCoord3fv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiTexCoord3fv_NOT_VOID_WRAP(...) {}
#define pack_glMultiTexCoord3fv(_target, _v) ({ \
    glMultiTexCoord3fv_PACKED *packed_data = malloc(sizeof(glMultiTexCoord3fv_PACKED)); \
    packed_data->index = glMultiTexCoord3fv_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.v = (GLfloat *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiTexCoord3fv(packed, ret_v) do { \
    PACKED_glMultiTexCoord3fv *unpacked = (PACKED_glMultiTexCoord3fv *)packed; \
    ARGS_glMultiTexCoord3fv *args = (ARGS_glMultiTexCoord3fv *)&unpacked->args; \
    glMultiTexCoord3fv(args->target, args->v);; \
} while(0)
void glMultiTexCoord3fv(glMultiTexCoord3fv_ARG_EXPAND);
typedef void (*glMultiTexCoord3fv_PTR)(glMultiTexCoord3fv_ARG_EXPAND);
#define glMultiTexCoord3fvARB_INDEX 1361
#define glMultiTexCoord3fvARB_RETURN void
#define glMultiTexCoord3fvARB_ARG_NAMES target, v
#define glMultiTexCoord3fvARB_ARG_EXPAND GLenum target, const GLfloat * v
#define glMultiTexCoord3fvARB_PACKED PACKED_glMultiTexCoord3fvARB
#define glMultiTexCoord3fvARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiTexCoord3fvARB_NOT_VOID_WRAP(...) {}
#define pack_glMultiTexCoord3fvARB(_target, _v) ({ \
    glMultiTexCoord3fvARB_PACKED *packed_data = malloc(sizeof(glMultiTexCoord3fvARB_PACKED)); \
    packed_data->index = glMultiTexCoord3fvARB_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.v = (GLfloat *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiTexCoord3fvARB(packed, ret_v) do { \
    PACKED_glMultiTexCoord3fvARB *unpacked = (PACKED_glMultiTexCoord3fvARB *)packed; \
    ARGS_glMultiTexCoord3fvARB *args = (ARGS_glMultiTexCoord3fvARB *)&unpacked->args; \
    glMultiTexCoord3fvARB(args->target, args->v);; \
} while(0)
void glMultiTexCoord3fvARB(glMultiTexCoord3fvARB_ARG_EXPAND);
typedef void (*glMultiTexCoord3fvARB_PTR)(glMultiTexCoord3fvARB_ARG_EXPAND);
#define glMultiTexCoord3hNV_INDEX 1362
#define glMultiTexCoord3hNV_RETURN void
#define glMultiTexCoord3hNV_ARG_NAMES target, s, t, r
#define glMultiTexCoord3hNV_ARG_EXPAND GLenum target, GLhalfNV s, GLhalfNV t, GLhalfNV r
#define glMultiTexCoord3hNV_PACKED PACKED_glMultiTexCoord3hNV
#define glMultiTexCoord3hNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiTexCoord3hNV_NOT_VOID_WRAP(...) {}
#define pack_glMultiTexCoord3hNV(_target, _s, _t, _r) ({ \
    glMultiTexCoord3hNV_PACKED *packed_data = malloc(sizeof(glMultiTexCoord3hNV_PACKED)); \
    packed_data->index = glMultiTexCoord3hNV_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.s = (GLhalfNV)_s; \
    packed_data->args.t = (GLhalfNV)_t; \
    packed_data->args.r = (GLhalfNV)_r; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiTexCoord3hNV(packed, ret_v) do { \
    PACKED_glMultiTexCoord3hNV *unpacked = (PACKED_glMultiTexCoord3hNV *)packed; \
    ARGS_glMultiTexCoord3hNV *args = (ARGS_glMultiTexCoord3hNV *)&unpacked->args; \
    glMultiTexCoord3hNV(args->target, args->s, args->t, args->r);; \
} while(0)
void glMultiTexCoord3hNV(glMultiTexCoord3hNV_ARG_EXPAND);
typedef void (*glMultiTexCoord3hNV_PTR)(glMultiTexCoord3hNV_ARG_EXPAND);
#define glMultiTexCoord3hvNV_INDEX 1363
#define glMultiTexCoord3hvNV_RETURN void
#define glMultiTexCoord3hvNV_ARG_NAMES target, v
#define glMultiTexCoord3hvNV_ARG_EXPAND GLenum target, const GLhalfNV * v
#define glMultiTexCoord3hvNV_PACKED PACKED_glMultiTexCoord3hvNV
#define glMultiTexCoord3hvNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiTexCoord3hvNV_NOT_VOID_WRAP(...) {}
#define pack_glMultiTexCoord3hvNV(_target, _v) ({ \
    glMultiTexCoord3hvNV_PACKED *packed_data = malloc(sizeof(glMultiTexCoord3hvNV_PACKED)); \
    packed_data->index = glMultiTexCoord3hvNV_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.v = (GLhalfNV *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiTexCoord3hvNV(packed, ret_v) do { \
    PACKED_glMultiTexCoord3hvNV *unpacked = (PACKED_glMultiTexCoord3hvNV *)packed; \
    ARGS_glMultiTexCoord3hvNV *args = (ARGS_glMultiTexCoord3hvNV *)&unpacked->args; \
    glMultiTexCoord3hvNV(args->target, args->v);; \
} while(0)
void glMultiTexCoord3hvNV(glMultiTexCoord3hvNV_ARG_EXPAND);
typedef void (*glMultiTexCoord3hvNV_PTR)(glMultiTexCoord3hvNV_ARG_EXPAND);
#define glMultiTexCoord3i_INDEX 1364
#define glMultiTexCoord3i_RETURN void
#define glMultiTexCoord3i_ARG_NAMES target, s, t, r
#define glMultiTexCoord3i_ARG_EXPAND GLenum target, GLint s, GLint t, GLint r
#define glMultiTexCoord3i_PACKED PACKED_glMultiTexCoord3i
#define glMultiTexCoord3i_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiTexCoord3i_NOT_VOID_WRAP(...) {}
#define pack_glMultiTexCoord3i(_target, _s, _t, _r) ({ \
    glMultiTexCoord3i_PACKED *packed_data = malloc(sizeof(glMultiTexCoord3i_PACKED)); \
    packed_data->index = glMultiTexCoord3i_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.s = (GLint)_s; \
    packed_data->args.t = (GLint)_t; \
    packed_data->args.r = (GLint)_r; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiTexCoord3i(packed, ret_v) do { \
    PACKED_glMultiTexCoord3i *unpacked = (PACKED_glMultiTexCoord3i *)packed; \
    ARGS_glMultiTexCoord3i *args = (ARGS_glMultiTexCoord3i *)&unpacked->args; \
    glMultiTexCoord3i(args->target, args->s, args->t, args->r);; \
} while(0)
void glMultiTexCoord3i(glMultiTexCoord3i_ARG_EXPAND);
typedef void (*glMultiTexCoord3i_PTR)(glMultiTexCoord3i_ARG_EXPAND);
#define glMultiTexCoord3iARB_INDEX 1365
#define glMultiTexCoord3iARB_RETURN void
#define glMultiTexCoord3iARB_ARG_NAMES target, s, t, r
#define glMultiTexCoord3iARB_ARG_EXPAND GLenum target, GLint s, GLint t, GLint r
#define glMultiTexCoord3iARB_PACKED PACKED_glMultiTexCoord3iARB
#define glMultiTexCoord3iARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiTexCoord3iARB_NOT_VOID_WRAP(...) {}
#define pack_glMultiTexCoord3iARB(_target, _s, _t, _r) ({ \
    glMultiTexCoord3iARB_PACKED *packed_data = malloc(sizeof(glMultiTexCoord3iARB_PACKED)); \
    packed_data->index = glMultiTexCoord3iARB_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.s = (GLint)_s; \
    packed_data->args.t = (GLint)_t; \
    packed_data->args.r = (GLint)_r; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiTexCoord3iARB(packed, ret_v) do { \
    PACKED_glMultiTexCoord3iARB *unpacked = (PACKED_glMultiTexCoord3iARB *)packed; \
    ARGS_glMultiTexCoord3iARB *args = (ARGS_glMultiTexCoord3iARB *)&unpacked->args; \
    glMultiTexCoord3iARB(args->target, args->s, args->t, args->r);; \
} while(0)
void glMultiTexCoord3iARB(glMultiTexCoord3iARB_ARG_EXPAND);
typedef void (*glMultiTexCoord3iARB_PTR)(glMultiTexCoord3iARB_ARG_EXPAND);
#define glMultiTexCoord3iv_INDEX 1366
#define glMultiTexCoord3iv_RETURN void
#define glMultiTexCoord3iv_ARG_NAMES target, v
#define glMultiTexCoord3iv_ARG_EXPAND GLenum target, const GLint * v
#define glMultiTexCoord3iv_PACKED PACKED_glMultiTexCoord3iv
#define glMultiTexCoord3iv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiTexCoord3iv_NOT_VOID_WRAP(...) {}
#define pack_glMultiTexCoord3iv(_target, _v) ({ \
    glMultiTexCoord3iv_PACKED *packed_data = malloc(sizeof(glMultiTexCoord3iv_PACKED)); \
    packed_data->index = glMultiTexCoord3iv_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.v = (GLint *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiTexCoord3iv(packed, ret_v) do { \
    PACKED_glMultiTexCoord3iv *unpacked = (PACKED_glMultiTexCoord3iv *)packed; \
    ARGS_glMultiTexCoord3iv *args = (ARGS_glMultiTexCoord3iv *)&unpacked->args; \
    glMultiTexCoord3iv(args->target, args->v);; \
} while(0)
void glMultiTexCoord3iv(glMultiTexCoord3iv_ARG_EXPAND);
typedef void (*glMultiTexCoord3iv_PTR)(glMultiTexCoord3iv_ARG_EXPAND);
#define glMultiTexCoord3ivARB_INDEX 1367
#define glMultiTexCoord3ivARB_RETURN void
#define glMultiTexCoord3ivARB_ARG_NAMES target, v
#define glMultiTexCoord3ivARB_ARG_EXPAND GLenum target, const GLint * v
#define glMultiTexCoord3ivARB_PACKED PACKED_glMultiTexCoord3ivARB
#define glMultiTexCoord3ivARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiTexCoord3ivARB_NOT_VOID_WRAP(...) {}
#define pack_glMultiTexCoord3ivARB(_target, _v) ({ \
    glMultiTexCoord3ivARB_PACKED *packed_data = malloc(sizeof(glMultiTexCoord3ivARB_PACKED)); \
    packed_data->index = glMultiTexCoord3ivARB_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.v = (GLint *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiTexCoord3ivARB(packed, ret_v) do { \
    PACKED_glMultiTexCoord3ivARB *unpacked = (PACKED_glMultiTexCoord3ivARB *)packed; \
    ARGS_glMultiTexCoord3ivARB *args = (ARGS_glMultiTexCoord3ivARB *)&unpacked->args; \
    glMultiTexCoord3ivARB(args->target, args->v);; \
} while(0)
void glMultiTexCoord3ivARB(glMultiTexCoord3ivARB_ARG_EXPAND);
typedef void (*glMultiTexCoord3ivARB_PTR)(glMultiTexCoord3ivARB_ARG_EXPAND);
#define glMultiTexCoord3s_INDEX 1368
#define glMultiTexCoord3s_RETURN void
#define glMultiTexCoord3s_ARG_NAMES target, s, t, r
#define glMultiTexCoord3s_ARG_EXPAND GLenum target, GLshort s, GLshort t, GLshort r
#define glMultiTexCoord3s_PACKED PACKED_glMultiTexCoord3s
#define glMultiTexCoord3s_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiTexCoord3s_NOT_VOID_WRAP(...) {}
#define pack_glMultiTexCoord3s(_target, _s, _t, _r) ({ \
    glMultiTexCoord3s_PACKED *packed_data = malloc(sizeof(glMultiTexCoord3s_PACKED)); \
    packed_data->index = glMultiTexCoord3s_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.s = (GLshort)_s; \
    packed_data->args.t = (GLshort)_t; \
    packed_data->args.r = (GLshort)_r; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiTexCoord3s(packed, ret_v) do { \
    PACKED_glMultiTexCoord3s *unpacked = (PACKED_glMultiTexCoord3s *)packed; \
    ARGS_glMultiTexCoord3s *args = (ARGS_glMultiTexCoord3s *)&unpacked->args; \
    glMultiTexCoord3s(args->target, args->s, args->t, args->r);; \
} while(0)
void glMultiTexCoord3s(glMultiTexCoord3s_ARG_EXPAND);
typedef void (*glMultiTexCoord3s_PTR)(glMultiTexCoord3s_ARG_EXPAND);
#define glMultiTexCoord3sARB_INDEX 1369
#define glMultiTexCoord3sARB_RETURN void
#define glMultiTexCoord3sARB_ARG_NAMES target, s, t, r
#define glMultiTexCoord3sARB_ARG_EXPAND GLenum target, GLshort s, GLshort t, GLshort r
#define glMultiTexCoord3sARB_PACKED PACKED_glMultiTexCoord3sARB
#define glMultiTexCoord3sARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiTexCoord3sARB_NOT_VOID_WRAP(...) {}
#define pack_glMultiTexCoord3sARB(_target, _s, _t, _r) ({ \
    glMultiTexCoord3sARB_PACKED *packed_data = malloc(sizeof(glMultiTexCoord3sARB_PACKED)); \
    packed_data->index = glMultiTexCoord3sARB_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.s = (GLshort)_s; \
    packed_data->args.t = (GLshort)_t; \
    packed_data->args.r = (GLshort)_r; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiTexCoord3sARB(packed, ret_v) do { \
    PACKED_glMultiTexCoord3sARB *unpacked = (PACKED_glMultiTexCoord3sARB *)packed; \
    ARGS_glMultiTexCoord3sARB *args = (ARGS_glMultiTexCoord3sARB *)&unpacked->args; \
    glMultiTexCoord3sARB(args->target, args->s, args->t, args->r);; \
} while(0)
void glMultiTexCoord3sARB(glMultiTexCoord3sARB_ARG_EXPAND);
typedef void (*glMultiTexCoord3sARB_PTR)(glMultiTexCoord3sARB_ARG_EXPAND);
#define glMultiTexCoord3sv_INDEX 1370
#define glMultiTexCoord3sv_RETURN void
#define glMultiTexCoord3sv_ARG_NAMES target, v
#define glMultiTexCoord3sv_ARG_EXPAND GLenum target, const GLshort * v
#define glMultiTexCoord3sv_PACKED PACKED_glMultiTexCoord3sv
#define glMultiTexCoord3sv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiTexCoord3sv_NOT_VOID_WRAP(...) {}
#define pack_glMultiTexCoord3sv(_target, _v) ({ \
    glMultiTexCoord3sv_PACKED *packed_data = malloc(sizeof(glMultiTexCoord3sv_PACKED)); \
    packed_data->index = glMultiTexCoord3sv_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.v = (GLshort *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiTexCoord3sv(packed, ret_v) do { \
    PACKED_glMultiTexCoord3sv *unpacked = (PACKED_glMultiTexCoord3sv *)packed; \
    ARGS_glMultiTexCoord3sv *args = (ARGS_glMultiTexCoord3sv *)&unpacked->args; \
    glMultiTexCoord3sv(args->target, args->v);; \
} while(0)
void glMultiTexCoord3sv(glMultiTexCoord3sv_ARG_EXPAND);
typedef void (*glMultiTexCoord3sv_PTR)(glMultiTexCoord3sv_ARG_EXPAND);
#define glMultiTexCoord3svARB_INDEX 1371
#define glMultiTexCoord3svARB_RETURN void
#define glMultiTexCoord3svARB_ARG_NAMES target, v
#define glMultiTexCoord3svARB_ARG_EXPAND GLenum target, const GLshort * v
#define glMultiTexCoord3svARB_PACKED PACKED_glMultiTexCoord3svARB
#define glMultiTexCoord3svARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiTexCoord3svARB_NOT_VOID_WRAP(...) {}
#define pack_glMultiTexCoord3svARB(_target, _v) ({ \
    glMultiTexCoord3svARB_PACKED *packed_data = malloc(sizeof(glMultiTexCoord3svARB_PACKED)); \
    packed_data->index = glMultiTexCoord3svARB_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.v = (GLshort *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiTexCoord3svARB(packed, ret_v) do { \
    PACKED_glMultiTexCoord3svARB *unpacked = (PACKED_glMultiTexCoord3svARB *)packed; \
    ARGS_glMultiTexCoord3svARB *args = (ARGS_glMultiTexCoord3svARB *)&unpacked->args; \
    glMultiTexCoord3svARB(args->target, args->v);; \
} while(0)
void glMultiTexCoord3svARB(glMultiTexCoord3svARB_ARG_EXPAND);
typedef void (*glMultiTexCoord3svARB_PTR)(glMultiTexCoord3svARB_ARG_EXPAND);
#define glMultiTexCoord3xOES_INDEX 1372
#define glMultiTexCoord3xOES_RETURN void
#define glMultiTexCoord3xOES_ARG_NAMES texture, s, t, r
#define glMultiTexCoord3xOES_ARG_EXPAND GLenum texture, GLfixed s, GLfixed t, GLfixed r
#define glMultiTexCoord3xOES_PACKED PACKED_glMultiTexCoord3xOES
#define glMultiTexCoord3xOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiTexCoord3xOES_NOT_VOID_WRAP(...) {}
#define pack_glMultiTexCoord3xOES(_texture, _s, _t, _r) ({ \
    glMultiTexCoord3xOES_PACKED *packed_data = malloc(sizeof(glMultiTexCoord3xOES_PACKED)); \
    packed_data->index = glMultiTexCoord3xOES_INDEX; \
    packed_data->args.texture = (GLenum)_texture; \
    packed_data->args.s = (GLfixed)_s; \
    packed_data->args.t = (GLfixed)_t; \
    packed_data->args.r = (GLfixed)_r; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiTexCoord3xOES(packed, ret_v) do { \
    PACKED_glMultiTexCoord3xOES *unpacked = (PACKED_glMultiTexCoord3xOES *)packed; \
    ARGS_glMultiTexCoord3xOES *args = (ARGS_glMultiTexCoord3xOES *)&unpacked->args; \
    glMultiTexCoord3xOES(args->texture, args->s, args->t, args->r);; \
} while(0)
void glMultiTexCoord3xOES(glMultiTexCoord3xOES_ARG_EXPAND);
typedef void (*glMultiTexCoord3xOES_PTR)(glMultiTexCoord3xOES_ARG_EXPAND);
#define glMultiTexCoord3xvOES_INDEX 1373
#define glMultiTexCoord3xvOES_RETURN void
#define glMultiTexCoord3xvOES_ARG_NAMES texture, coords
#define glMultiTexCoord3xvOES_ARG_EXPAND GLenum texture, const GLfixed * coords
#define glMultiTexCoord3xvOES_PACKED PACKED_glMultiTexCoord3xvOES
#define glMultiTexCoord3xvOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiTexCoord3xvOES_NOT_VOID_WRAP(...) {}
#define pack_glMultiTexCoord3xvOES(_texture, _coords) ({ \
    glMultiTexCoord3xvOES_PACKED *packed_data = malloc(sizeof(glMultiTexCoord3xvOES_PACKED)); \
    packed_data->index = glMultiTexCoord3xvOES_INDEX; \
    packed_data->args.texture = (GLenum)_texture; \
    packed_data->args.coords = (GLfixed *)_coords; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiTexCoord3xvOES(packed, ret_v) do { \
    PACKED_glMultiTexCoord3xvOES *unpacked = (PACKED_glMultiTexCoord3xvOES *)packed; \
    ARGS_glMultiTexCoord3xvOES *args = (ARGS_glMultiTexCoord3xvOES *)&unpacked->args; \
    glMultiTexCoord3xvOES(args->texture, args->coords);; \
} while(0)
void glMultiTexCoord3xvOES(glMultiTexCoord3xvOES_ARG_EXPAND);
typedef void (*glMultiTexCoord3xvOES_PTR)(glMultiTexCoord3xvOES_ARG_EXPAND);
#define glMultiTexCoord4bOES_INDEX 1374
#define glMultiTexCoord4bOES_RETURN void
#define glMultiTexCoord4bOES_ARG_NAMES texture, s, t, r, q
#define glMultiTexCoord4bOES_ARG_EXPAND GLenum texture, GLbyte s, GLbyte t, GLbyte r, GLbyte q
#define glMultiTexCoord4bOES_PACKED PACKED_glMultiTexCoord4bOES
#define glMultiTexCoord4bOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiTexCoord4bOES_NOT_VOID_WRAP(...) {}
#define pack_glMultiTexCoord4bOES(_texture, _s, _t, _r, _q) ({ \
    glMultiTexCoord4bOES_PACKED *packed_data = malloc(sizeof(glMultiTexCoord4bOES_PACKED)); \
    packed_data->index = glMultiTexCoord4bOES_INDEX; \
    packed_data->args.texture = (GLenum)_texture; \
    packed_data->args.s = (GLbyte)_s; \
    packed_data->args.t = (GLbyte)_t; \
    packed_data->args.r = (GLbyte)_r; \
    packed_data->args.q = (GLbyte)_q; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiTexCoord4bOES(packed, ret_v) do { \
    PACKED_glMultiTexCoord4bOES *unpacked = (PACKED_glMultiTexCoord4bOES *)packed; \
    ARGS_glMultiTexCoord4bOES *args = (ARGS_glMultiTexCoord4bOES *)&unpacked->args; \
    glMultiTexCoord4bOES(args->texture, args->s, args->t, args->r, args->q);; \
} while(0)
void glMultiTexCoord4bOES(glMultiTexCoord4bOES_ARG_EXPAND);
typedef void (*glMultiTexCoord4bOES_PTR)(glMultiTexCoord4bOES_ARG_EXPAND);
#define glMultiTexCoord4bvOES_INDEX 1375
#define glMultiTexCoord4bvOES_RETURN void
#define glMultiTexCoord4bvOES_ARG_NAMES texture, coords
#define glMultiTexCoord4bvOES_ARG_EXPAND GLenum texture, const GLbyte * coords
#define glMultiTexCoord4bvOES_PACKED PACKED_glMultiTexCoord4bvOES
#define glMultiTexCoord4bvOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiTexCoord4bvOES_NOT_VOID_WRAP(...) {}
#define pack_glMultiTexCoord4bvOES(_texture, _coords) ({ \
    glMultiTexCoord4bvOES_PACKED *packed_data = malloc(sizeof(glMultiTexCoord4bvOES_PACKED)); \
    packed_data->index = glMultiTexCoord4bvOES_INDEX; \
    packed_data->args.texture = (GLenum)_texture; \
    packed_data->args.coords = (GLbyte *)_coords; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiTexCoord4bvOES(packed, ret_v) do { \
    PACKED_glMultiTexCoord4bvOES *unpacked = (PACKED_glMultiTexCoord4bvOES *)packed; \
    ARGS_glMultiTexCoord4bvOES *args = (ARGS_glMultiTexCoord4bvOES *)&unpacked->args; \
    glMultiTexCoord4bvOES(args->texture, args->coords);; \
} while(0)
void glMultiTexCoord4bvOES(glMultiTexCoord4bvOES_ARG_EXPAND);
typedef void (*glMultiTexCoord4bvOES_PTR)(glMultiTexCoord4bvOES_ARG_EXPAND);
#define glMultiTexCoord4d_INDEX 1376
#define glMultiTexCoord4d_RETURN void
#define glMultiTexCoord4d_ARG_NAMES target, s, t, r, q
#define glMultiTexCoord4d_ARG_EXPAND GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q
#define glMultiTexCoord4d_PACKED PACKED_glMultiTexCoord4d
#define glMultiTexCoord4d_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiTexCoord4d_NOT_VOID_WRAP(...) {}
#define pack_glMultiTexCoord4d(_target, _s, _t, _r, _q) ({ \
    glMultiTexCoord4d_PACKED *packed_data = malloc(sizeof(glMultiTexCoord4d_PACKED)); \
    packed_data->index = glMultiTexCoord4d_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.s = (GLdouble)_s; \
    packed_data->args.t = (GLdouble)_t; \
    packed_data->args.r = (GLdouble)_r; \
    packed_data->args.q = (GLdouble)_q; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiTexCoord4d(packed, ret_v) do { \
    PACKED_glMultiTexCoord4d *unpacked = (PACKED_glMultiTexCoord4d *)packed; \
    ARGS_glMultiTexCoord4d *args = (ARGS_glMultiTexCoord4d *)&unpacked->args; \
    glMultiTexCoord4d(args->target, args->s, args->t, args->r, args->q);; \
} while(0)
void glMultiTexCoord4d(glMultiTexCoord4d_ARG_EXPAND);
typedef void (*glMultiTexCoord4d_PTR)(glMultiTexCoord4d_ARG_EXPAND);
#define glMultiTexCoord4dARB_INDEX 1377
#define glMultiTexCoord4dARB_RETURN void
#define glMultiTexCoord4dARB_ARG_NAMES target, s, t, r, q
#define glMultiTexCoord4dARB_ARG_EXPAND GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q
#define glMultiTexCoord4dARB_PACKED PACKED_glMultiTexCoord4dARB
#define glMultiTexCoord4dARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiTexCoord4dARB_NOT_VOID_WRAP(...) {}
#define pack_glMultiTexCoord4dARB(_target, _s, _t, _r, _q) ({ \
    glMultiTexCoord4dARB_PACKED *packed_data = malloc(sizeof(glMultiTexCoord4dARB_PACKED)); \
    packed_data->index = glMultiTexCoord4dARB_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.s = (GLdouble)_s; \
    packed_data->args.t = (GLdouble)_t; \
    packed_data->args.r = (GLdouble)_r; \
    packed_data->args.q = (GLdouble)_q; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiTexCoord4dARB(packed, ret_v) do { \
    PACKED_glMultiTexCoord4dARB *unpacked = (PACKED_glMultiTexCoord4dARB *)packed; \
    ARGS_glMultiTexCoord4dARB *args = (ARGS_glMultiTexCoord4dARB *)&unpacked->args; \
    glMultiTexCoord4dARB(args->target, args->s, args->t, args->r, args->q);; \
} while(0)
void glMultiTexCoord4dARB(glMultiTexCoord4dARB_ARG_EXPAND);
typedef void (*glMultiTexCoord4dARB_PTR)(glMultiTexCoord4dARB_ARG_EXPAND);
#define glMultiTexCoord4dv_INDEX 1378
#define glMultiTexCoord4dv_RETURN void
#define glMultiTexCoord4dv_ARG_NAMES target, v
#define glMultiTexCoord4dv_ARG_EXPAND GLenum target, const GLdouble * v
#define glMultiTexCoord4dv_PACKED PACKED_glMultiTexCoord4dv
#define glMultiTexCoord4dv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiTexCoord4dv_NOT_VOID_WRAP(...) {}
#define pack_glMultiTexCoord4dv(_target, _v) ({ \
    glMultiTexCoord4dv_PACKED *packed_data = malloc(sizeof(glMultiTexCoord4dv_PACKED)); \
    packed_data->index = glMultiTexCoord4dv_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.v = (GLdouble *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiTexCoord4dv(packed, ret_v) do { \
    PACKED_glMultiTexCoord4dv *unpacked = (PACKED_glMultiTexCoord4dv *)packed; \
    ARGS_glMultiTexCoord4dv *args = (ARGS_glMultiTexCoord4dv *)&unpacked->args; \
    glMultiTexCoord4dv(args->target, args->v);; \
} while(0)
void glMultiTexCoord4dv(glMultiTexCoord4dv_ARG_EXPAND);
typedef void (*glMultiTexCoord4dv_PTR)(glMultiTexCoord4dv_ARG_EXPAND);
#define glMultiTexCoord4dvARB_INDEX 1379
#define glMultiTexCoord4dvARB_RETURN void
#define glMultiTexCoord4dvARB_ARG_NAMES target, v
#define glMultiTexCoord4dvARB_ARG_EXPAND GLenum target, const GLdouble * v
#define glMultiTexCoord4dvARB_PACKED PACKED_glMultiTexCoord4dvARB
#define glMultiTexCoord4dvARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiTexCoord4dvARB_NOT_VOID_WRAP(...) {}
#define pack_glMultiTexCoord4dvARB(_target, _v) ({ \
    glMultiTexCoord4dvARB_PACKED *packed_data = malloc(sizeof(glMultiTexCoord4dvARB_PACKED)); \
    packed_data->index = glMultiTexCoord4dvARB_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.v = (GLdouble *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiTexCoord4dvARB(packed, ret_v) do { \
    PACKED_glMultiTexCoord4dvARB *unpacked = (PACKED_glMultiTexCoord4dvARB *)packed; \
    ARGS_glMultiTexCoord4dvARB *args = (ARGS_glMultiTexCoord4dvARB *)&unpacked->args; \
    glMultiTexCoord4dvARB(args->target, args->v);; \
} while(0)
void glMultiTexCoord4dvARB(glMultiTexCoord4dvARB_ARG_EXPAND);
typedef void (*glMultiTexCoord4dvARB_PTR)(glMultiTexCoord4dvARB_ARG_EXPAND);
#define glMultiTexCoord4f_INDEX 1380
#define glMultiTexCoord4f_RETURN void
#define glMultiTexCoord4f_ARG_NAMES target, s, t, r, q
#define glMultiTexCoord4f_ARG_EXPAND GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q
#define glMultiTexCoord4f_PACKED PACKED_glMultiTexCoord4f
#define glMultiTexCoord4f_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiTexCoord4f_NOT_VOID_WRAP(...) {}
#define pack_glMultiTexCoord4f(_target, _s, _t, _r, _q) ({ \
    glMultiTexCoord4f_PACKED *packed_data = malloc(sizeof(glMultiTexCoord4f_PACKED)); \
    packed_data->index = glMultiTexCoord4f_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.s = (GLfloat)_s; \
    packed_data->args.t = (GLfloat)_t; \
    packed_data->args.r = (GLfloat)_r; \
    packed_data->args.q = (GLfloat)_q; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiTexCoord4f(packed, ret_v) do { \
    PACKED_glMultiTexCoord4f *unpacked = (PACKED_glMultiTexCoord4f *)packed; \
    ARGS_glMultiTexCoord4f *args = (ARGS_glMultiTexCoord4f *)&unpacked->args; \
    glMultiTexCoord4f(args->target, args->s, args->t, args->r, args->q);; \
} while(0)
void glMultiTexCoord4f(glMultiTexCoord4f_ARG_EXPAND);
typedef void (*glMultiTexCoord4f_PTR)(glMultiTexCoord4f_ARG_EXPAND);
#define glMultiTexCoord4fARB_INDEX 1381
#define glMultiTexCoord4fARB_RETURN void
#define glMultiTexCoord4fARB_ARG_NAMES target, s, t, r, q
#define glMultiTexCoord4fARB_ARG_EXPAND GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q
#define glMultiTexCoord4fARB_PACKED PACKED_glMultiTexCoord4fARB
#define glMultiTexCoord4fARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiTexCoord4fARB_NOT_VOID_WRAP(...) {}
#define pack_glMultiTexCoord4fARB(_target, _s, _t, _r, _q) ({ \
    glMultiTexCoord4fARB_PACKED *packed_data = malloc(sizeof(glMultiTexCoord4fARB_PACKED)); \
    packed_data->index = glMultiTexCoord4fARB_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.s = (GLfloat)_s; \
    packed_data->args.t = (GLfloat)_t; \
    packed_data->args.r = (GLfloat)_r; \
    packed_data->args.q = (GLfloat)_q; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiTexCoord4fARB(packed, ret_v) do { \
    PACKED_glMultiTexCoord4fARB *unpacked = (PACKED_glMultiTexCoord4fARB *)packed; \
    ARGS_glMultiTexCoord4fARB *args = (ARGS_glMultiTexCoord4fARB *)&unpacked->args; \
    glMultiTexCoord4fARB(args->target, args->s, args->t, args->r, args->q);; \
} while(0)
void glMultiTexCoord4fARB(glMultiTexCoord4fARB_ARG_EXPAND);
typedef void (*glMultiTexCoord4fARB_PTR)(glMultiTexCoord4fARB_ARG_EXPAND);
#define glMultiTexCoord4fv_INDEX 1382
#define glMultiTexCoord4fv_RETURN void
#define glMultiTexCoord4fv_ARG_NAMES target, v
#define glMultiTexCoord4fv_ARG_EXPAND GLenum target, const GLfloat * v
#define glMultiTexCoord4fv_PACKED PACKED_glMultiTexCoord4fv
#define glMultiTexCoord4fv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiTexCoord4fv_NOT_VOID_WRAP(...) {}
#define pack_glMultiTexCoord4fv(_target, _v) ({ \
    glMultiTexCoord4fv_PACKED *packed_data = malloc(sizeof(glMultiTexCoord4fv_PACKED)); \
    packed_data->index = glMultiTexCoord4fv_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.v = (GLfloat *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiTexCoord4fv(packed, ret_v) do { \
    PACKED_glMultiTexCoord4fv *unpacked = (PACKED_glMultiTexCoord4fv *)packed; \
    ARGS_glMultiTexCoord4fv *args = (ARGS_glMultiTexCoord4fv *)&unpacked->args; \
    glMultiTexCoord4fv(args->target, args->v);; \
} while(0)
void glMultiTexCoord4fv(glMultiTexCoord4fv_ARG_EXPAND);
typedef void (*glMultiTexCoord4fv_PTR)(glMultiTexCoord4fv_ARG_EXPAND);
#define glMultiTexCoord4fvARB_INDEX 1383
#define glMultiTexCoord4fvARB_RETURN void
#define glMultiTexCoord4fvARB_ARG_NAMES target, v
#define glMultiTexCoord4fvARB_ARG_EXPAND GLenum target, const GLfloat * v
#define glMultiTexCoord4fvARB_PACKED PACKED_glMultiTexCoord4fvARB
#define glMultiTexCoord4fvARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiTexCoord4fvARB_NOT_VOID_WRAP(...) {}
#define pack_glMultiTexCoord4fvARB(_target, _v) ({ \
    glMultiTexCoord4fvARB_PACKED *packed_data = malloc(sizeof(glMultiTexCoord4fvARB_PACKED)); \
    packed_data->index = glMultiTexCoord4fvARB_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.v = (GLfloat *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiTexCoord4fvARB(packed, ret_v) do { \
    PACKED_glMultiTexCoord4fvARB *unpacked = (PACKED_glMultiTexCoord4fvARB *)packed; \
    ARGS_glMultiTexCoord4fvARB *args = (ARGS_glMultiTexCoord4fvARB *)&unpacked->args; \
    glMultiTexCoord4fvARB(args->target, args->v);; \
} while(0)
void glMultiTexCoord4fvARB(glMultiTexCoord4fvARB_ARG_EXPAND);
typedef void (*glMultiTexCoord4fvARB_PTR)(glMultiTexCoord4fvARB_ARG_EXPAND);
#define glMultiTexCoord4hNV_INDEX 1384
#define glMultiTexCoord4hNV_RETURN void
#define glMultiTexCoord4hNV_ARG_NAMES target, s, t, r, q
#define glMultiTexCoord4hNV_ARG_EXPAND GLenum target, GLhalfNV s, GLhalfNV t, GLhalfNV r, GLhalfNV q
#define glMultiTexCoord4hNV_PACKED PACKED_glMultiTexCoord4hNV
#define glMultiTexCoord4hNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiTexCoord4hNV_NOT_VOID_WRAP(...) {}
#define pack_glMultiTexCoord4hNV(_target, _s, _t, _r, _q) ({ \
    glMultiTexCoord4hNV_PACKED *packed_data = malloc(sizeof(glMultiTexCoord4hNV_PACKED)); \
    packed_data->index = glMultiTexCoord4hNV_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.s = (GLhalfNV)_s; \
    packed_data->args.t = (GLhalfNV)_t; \
    packed_data->args.r = (GLhalfNV)_r; \
    packed_data->args.q = (GLhalfNV)_q; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiTexCoord4hNV(packed, ret_v) do { \
    PACKED_glMultiTexCoord4hNV *unpacked = (PACKED_glMultiTexCoord4hNV *)packed; \
    ARGS_glMultiTexCoord4hNV *args = (ARGS_glMultiTexCoord4hNV *)&unpacked->args; \
    glMultiTexCoord4hNV(args->target, args->s, args->t, args->r, args->q);; \
} while(0)
void glMultiTexCoord4hNV(glMultiTexCoord4hNV_ARG_EXPAND);
typedef void (*glMultiTexCoord4hNV_PTR)(glMultiTexCoord4hNV_ARG_EXPAND);
#define glMultiTexCoord4hvNV_INDEX 1385
#define glMultiTexCoord4hvNV_RETURN void
#define glMultiTexCoord4hvNV_ARG_NAMES target, v
#define glMultiTexCoord4hvNV_ARG_EXPAND GLenum target, const GLhalfNV * v
#define glMultiTexCoord4hvNV_PACKED PACKED_glMultiTexCoord4hvNV
#define glMultiTexCoord4hvNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiTexCoord4hvNV_NOT_VOID_WRAP(...) {}
#define pack_glMultiTexCoord4hvNV(_target, _v) ({ \
    glMultiTexCoord4hvNV_PACKED *packed_data = malloc(sizeof(glMultiTexCoord4hvNV_PACKED)); \
    packed_data->index = glMultiTexCoord4hvNV_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.v = (GLhalfNV *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiTexCoord4hvNV(packed, ret_v) do { \
    PACKED_glMultiTexCoord4hvNV *unpacked = (PACKED_glMultiTexCoord4hvNV *)packed; \
    ARGS_glMultiTexCoord4hvNV *args = (ARGS_glMultiTexCoord4hvNV *)&unpacked->args; \
    glMultiTexCoord4hvNV(args->target, args->v);; \
} while(0)
void glMultiTexCoord4hvNV(glMultiTexCoord4hvNV_ARG_EXPAND);
typedef void (*glMultiTexCoord4hvNV_PTR)(glMultiTexCoord4hvNV_ARG_EXPAND);
#define glMultiTexCoord4i_INDEX 1386
#define glMultiTexCoord4i_RETURN void
#define glMultiTexCoord4i_ARG_NAMES target, s, t, r, q
#define glMultiTexCoord4i_ARG_EXPAND GLenum target, GLint s, GLint t, GLint r, GLint q
#define glMultiTexCoord4i_PACKED PACKED_glMultiTexCoord4i
#define glMultiTexCoord4i_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiTexCoord4i_NOT_VOID_WRAP(...) {}
#define pack_glMultiTexCoord4i(_target, _s, _t, _r, _q) ({ \
    glMultiTexCoord4i_PACKED *packed_data = malloc(sizeof(glMultiTexCoord4i_PACKED)); \
    packed_data->index = glMultiTexCoord4i_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.s = (GLint)_s; \
    packed_data->args.t = (GLint)_t; \
    packed_data->args.r = (GLint)_r; \
    packed_data->args.q = (GLint)_q; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiTexCoord4i(packed, ret_v) do { \
    PACKED_glMultiTexCoord4i *unpacked = (PACKED_glMultiTexCoord4i *)packed; \
    ARGS_glMultiTexCoord4i *args = (ARGS_glMultiTexCoord4i *)&unpacked->args; \
    glMultiTexCoord4i(args->target, args->s, args->t, args->r, args->q);; \
} while(0)
void glMultiTexCoord4i(glMultiTexCoord4i_ARG_EXPAND);
typedef void (*glMultiTexCoord4i_PTR)(glMultiTexCoord4i_ARG_EXPAND);
#define glMultiTexCoord4iARB_INDEX 1387
#define glMultiTexCoord4iARB_RETURN void
#define glMultiTexCoord4iARB_ARG_NAMES target, s, t, r, q
#define glMultiTexCoord4iARB_ARG_EXPAND GLenum target, GLint s, GLint t, GLint r, GLint q
#define glMultiTexCoord4iARB_PACKED PACKED_glMultiTexCoord4iARB
#define glMultiTexCoord4iARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiTexCoord4iARB_NOT_VOID_WRAP(...) {}
#define pack_glMultiTexCoord4iARB(_target, _s, _t, _r, _q) ({ \
    glMultiTexCoord4iARB_PACKED *packed_data = malloc(sizeof(glMultiTexCoord4iARB_PACKED)); \
    packed_data->index = glMultiTexCoord4iARB_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.s = (GLint)_s; \
    packed_data->args.t = (GLint)_t; \
    packed_data->args.r = (GLint)_r; \
    packed_data->args.q = (GLint)_q; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiTexCoord4iARB(packed, ret_v) do { \
    PACKED_glMultiTexCoord4iARB *unpacked = (PACKED_glMultiTexCoord4iARB *)packed; \
    ARGS_glMultiTexCoord4iARB *args = (ARGS_glMultiTexCoord4iARB *)&unpacked->args; \
    glMultiTexCoord4iARB(args->target, args->s, args->t, args->r, args->q);; \
} while(0)
void glMultiTexCoord4iARB(glMultiTexCoord4iARB_ARG_EXPAND);
typedef void (*glMultiTexCoord4iARB_PTR)(glMultiTexCoord4iARB_ARG_EXPAND);
#define glMultiTexCoord4iv_INDEX 1388
#define glMultiTexCoord4iv_RETURN void
#define glMultiTexCoord4iv_ARG_NAMES target, v
#define glMultiTexCoord4iv_ARG_EXPAND GLenum target, const GLint * v
#define glMultiTexCoord4iv_PACKED PACKED_glMultiTexCoord4iv
#define glMultiTexCoord4iv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiTexCoord4iv_NOT_VOID_WRAP(...) {}
#define pack_glMultiTexCoord4iv(_target, _v) ({ \
    glMultiTexCoord4iv_PACKED *packed_data = malloc(sizeof(glMultiTexCoord4iv_PACKED)); \
    packed_data->index = glMultiTexCoord4iv_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.v = (GLint *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiTexCoord4iv(packed, ret_v) do { \
    PACKED_glMultiTexCoord4iv *unpacked = (PACKED_glMultiTexCoord4iv *)packed; \
    ARGS_glMultiTexCoord4iv *args = (ARGS_glMultiTexCoord4iv *)&unpacked->args; \
    glMultiTexCoord4iv(args->target, args->v);; \
} while(0)
void glMultiTexCoord4iv(glMultiTexCoord4iv_ARG_EXPAND);
typedef void (*glMultiTexCoord4iv_PTR)(glMultiTexCoord4iv_ARG_EXPAND);
#define glMultiTexCoord4ivARB_INDEX 1389
#define glMultiTexCoord4ivARB_RETURN void
#define glMultiTexCoord4ivARB_ARG_NAMES target, v
#define glMultiTexCoord4ivARB_ARG_EXPAND GLenum target, const GLint * v
#define glMultiTexCoord4ivARB_PACKED PACKED_glMultiTexCoord4ivARB
#define glMultiTexCoord4ivARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiTexCoord4ivARB_NOT_VOID_WRAP(...) {}
#define pack_glMultiTexCoord4ivARB(_target, _v) ({ \
    glMultiTexCoord4ivARB_PACKED *packed_data = malloc(sizeof(glMultiTexCoord4ivARB_PACKED)); \
    packed_data->index = glMultiTexCoord4ivARB_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.v = (GLint *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiTexCoord4ivARB(packed, ret_v) do { \
    PACKED_glMultiTexCoord4ivARB *unpacked = (PACKED_glMultiTexCoord4ivARB *)packed; \
    ARGS_glMultiTexCoord4ivARB *args = (ARGS_glMultiTexCoord4ivARB *)&unpacked->args; \
    glMultiTexCoord4ivARB(args->target, args->v);; \
} while(0)
void glMultiTexCoord4ivARB(glMultiTexCoord4ivARB_ARG_EXPAND);
typedef void (*glMultiTexCoord4ivARB_PTR)(glMultiTexCoord4ivARB_ARG_EXPAND);
#define glMultiTexCoord4s_INDEX 1390
#define glMultiTexCoord4s_RETURN void
#define glMultiTexCoord4s_ARG_NAMES target, s, t, r, q
#define glMultiTexCoord4s_ARG_EXPAND GLenum target, GLshort s, GLshort t, GLshort r, GLshort q
#define glMultiTexCoord4s_PACKED PACKED_glMultiTexCoord4s
#define glMultiTexCoord4s_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiTexCoord4s_NOT_VOID_WRAP(...) {}
#define pack_glMultiTexCoord4s(_target, _s, _t, _r, _q) ({ \
    glMultiTexCoord4s_PACKED *packed_data = malloc(sizeof(glMultiTexCoord4s_PACKED)); \
    packed_data->index = glMultiTexCoord4s_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.s = (GLshort)_s; \
    packed_data->args.t = (GLshort)_t; \
    packed_data->args.r = (GLshort)_r; \
    packed_data->args.q = (GLshort)_q; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiTexCoord4s(packed, ret_v) do { \
    PACKED_glMultiTexCoord4s *unpacked = (PACKED_glMultiTexCoord4s *)packed; \
    ARGS_glMultiTexCoord4s *args = (ARGS_glMultiTexCoord4s *)&unpacked->args; \
    glMultiTexCoord4s(args->target, args->s, args->t, args->r, args->q);; \
} while(0)
void glMultiTexCoord4s(glMultiTexCoord4s_ARG_EXPAND);
typedef void (*glMultiTexCoord4s_PTR)(glMultiTexCoord4s_ARG_EXPAND);
#define glMultiTexCoord4sARB_INDEX 1391
#define glMultiTexCoord4sARB_RETURN void
#define glMultiTexCoord4sARB_ARG_NAMES target, s, t, r, q
#define glMultiTexCoord4sARB_ARG_EXPAND GLenum target, GLshort s, GLshort t, GLshort r, GLshort q
#define glMultiTexCoord4sARB_PACKED PACKED_glMultiTexCoord4sARB
#define glMultiTexCoord4sARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiTexCoord4sARB_NOT_VOID_WRAP(...) {}
#define pack_glMultiTexCoord4sARB(_target, _s, _t, _r, _q) ({ \
    glMultiTexCoord4sARB_PACKED *packed_data = malloc(sizeof(glMultiTexCoord4sARB_PACKED)); \
    packed_data->index = glMultiTexCoord4sARB_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.s = (GLshort)_s; \
    packed_data->args.t = (GLshort)_t; \
    packed_data->args.r = (GLshort)_r; \
    packed_data->args.q = (GLshort)_q; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiTexCoord4sARB(packed, ret_v) do { \
    PACKED_glMultiTexCoord4sARB *unpacked = (PACKED_glMultiTexCoord4sARB *)packed; \
    ARGS_glMultiTexCoord4sARB *args = (ARGS_glMultiTexCoord4sARB *)&unpacked->args; \
    glMultiTexCoord4sARB(args->target, args->s, args->t, args->r, args->q);; \
} while(0)
void glMultiTexCoord4sARB(glMultiTexCoord4sARB_ARG_EXPAND);
typedef void (*glMultiTexCoord4sARB_PTR)(glMultiTexCoord4sARB_ARG_EXPAND);
#define glMultiTexCoord4sv_INDEX 1392
#define glMultiTexCoord4sv_RETURN void
#define glMultiTexCoord4sv_ARG_NAMES target, v
#define glMultiTexCoord4sv_ARG_EXPAND GLenum target, const GLshort * v
#define glMultiTexCoord4sv_PACKED PACKED_glMultiTexCoord4sv
#define glMultiTexCoord4sv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiTexCoord4sv_NOT_VOID_WRAP(...) {}
#define pack_glMultiTexCoord4sv(_target, _v) ({ \
    glMultiTexCoord4sv_PACKED *packed_data = malloc(sizeof(glMultiTexCoord4sv_PACKED)); \
    packed_data->index = glMultiTexCoord4sv_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.v = (GLshort *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiTexCoord4sv(packed, ret_v) do { \
    PACKED_glMultiTexCoord4sv *unpacked = (PACKED_glMultiTexCoord4sv *)packed; \
    ARGS_glMultiTexCoord4sv *args = (ARGS_glMultiTexCoord4sv *)&unpacked->args; \
    glMultiTexCoord4sv(args->target, args->v);; \
} while(0)
void glMultiTexCoord4sv(glMultiTexCoord4sv_ARG_EXPAND);
typedef void (*glMultiTexCoord4sv_PTR)(glMultiTexCoord4sv_ARG_EXPAND);
#define glMultiTexCoord4svARB_INDEX 1393
#define glMultiTexCoord4svARB_RETURN void
#define glMultiTexCoord4svARB_ARG_NAMES target, v
#define glMultiTexCoord4svARB_ARG_EXPAND GLenum target, const GLshort * v
#define glMultiTexCoord4svARB_PACKED PACKED_glMultiTexCoord4svARB
#define glMultiTexCoord4svARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiTexCoord4svARB_NOT_VOID_WRAP(...) {}
#define pack_glMultiTexCoord4svARB(_target, _v) ({ \
    glMultiTexCoord4svARB_PACKED *packed_data = malloc(sizeof(glMultiTexCoord4svARB_PACKED)); \
    packed_data->index = glMultiTexCoord4svARB_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.v = (GLshort *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiTexCoord4svARB(packed, ret_v) do { \
    PACKED_glMultiTexCoord4svARB *unpacked = (PACKED_glMultiTexCoord4svARB *)packed; \
    ARGS_glMultiTexCoord4svARB *args = (ARGS_glMultiTexCoord4svARB *)&unpacked->args; \
    glMultiTexCoord4svARB(args->target, args->v);; \
} while(0)
void glMultiTexCoord4svARB(glMultiTexCoord4svARB_ARG_EXPAND);
typedef void (*glMultiTexCoord4svARB_PTR)(glMultiTexCoord4svARB_ARG_EXPAND);
#define glMultiTexCoord4x_INDEX 1394
#define glMultiTexCoord4x_RETURN void
#define glMultiTexCoord4x_ARG_NAMES target, s, t, r, q
#define glMultiTexCoord4x_ARG_EXPAND GLenum target, GLfixed s, GLfixed t, GLfixed r, GLfixed q
#define glMultiTexCoord4x_PACKED PACKED_glMultiTexCoord4x
#define glMultiTexCoord4x_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiTexCoord4x_NOT_VOID_WRAP(...) {}
#define pack_glMultiTexCoord4x(_target, _s, _t, _r, _q) ({ \
    glMultiTexCoord4x_PACKED *packed_data = malloc(sizeof(glMultiTexCoord4x_PACKED)); \
    packed_data->index = glMultiTexCoord4x_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.s = (GLfixed)_s; \
    packed_data->args.t = (GLfixed)_t; \
    packed_data->args.r = (GLfixed)_r; \
    packed_data->args.q = (GLfixed)_q; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiTexCoord4x(packed, ret_v) do { \
    PACKED_glMultiTexCoord4x *unpacked = (PACKED_glMultiTexCoord4x *)packed; \
    ARGS_glMultiTexCoord4x *args = (ARGS_glMultiTexCoord4x *)&unpacked->args; \
    glMultiTexCoord4x(args->target, args->s, args->t, args->r, args->q);; \
} while(0)
void glMultiTexCoord4x(glMultiTexCoord4x_ARG_EXPAND);
typedef void (*glMultiTexCoord4x_PTR)(glMultiTexCoord4x_ARG_EXPAND);
#define glMultiTexCoord4xOES_INDEX 1395
#define glMultiTexCoord4xOES_RETURN void
#define glMultiTexCoord4xOES_ARG_NAMES texture, s, t, r, q
#define glMultiTexCoord4xOES_ARG_EXPAND GLenum texture, GLfixed s, GLfixed t, GLfixed r, GLfixed q
#define glMultiTexCoord4xOES_PACKED PACKED_glMultiTexCoord4xOES
#define glMultiTexCoord4xOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiTexCoord4xOES_NOT_VOID_WRAP(...) {}
#define pack_glMultiTexCoord4xOES(_texture, _s, _t, _r, _q) ({ \
    glMultiTexCoord4xOES_PACKED *packed_data = malloc(sizeof(glMultiTexCoord4xOES_PACKED)); \
    packed_data->index = glMultiTexCoord4xOES_INDEX; \
    packed_data->args.texture = (GLenum)_texture; \
    packed_data->args.s = (GLfixed)_s; \
    packed_data->args.t = (GLfixed)_t; \
    packed_data->args.r = (GLfixed)_r; \
    packed_data->args.q = (GLfixed)_q; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiTexCoord4xOES(packed, ret_v) do { \
    PACKED_glMultiTexCoord4xOES *unpacked = (PACKED_glMultiTexCoord4xOES *)packed; \
    ARGS_glMultiTexCoord4xOES *args = (ARGS_glMultiTexCoord4xOES *)&unpacked->args; \
    glMultiTexCoord4xOES(args->texture, args->s, args->t, args->r, args->q);; \
} while(0)
void glMultiTexCoord4xOES(glMultiTexCoord4xOES_ARG_EXPAND);
typedef void (*glMultiTexCoord4xOES_PTR)(glMultiTexCoord4xOES_ARG_EXPAND);
#define glMultiTexCoord4xvOES_INDEX 1396
#define glMultiTexCoord4xvOES_RETURN void
#define glMultiTexCoord4xvOES_ARG_NAMES texture, coords
#define glMultiTexCoord4xvOES_ARG_EXPAND GLenum texture, const GLfixed * coords
#define glMultiTexCoord4xvOES_PACKED PACKED_glMultiTexCoord4xvOES
#define glMultiTexCoord4xvOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiTexCoord4xvOES_NOT_VOID_WRAP(...) {}
#define pack_glMultiTexCoord4xvOES(_texture, _coords) ({ \
    glMultiTexCoord4xvOES_PACKED *packed_data = malloc(sizeof(glMultiTexCoord4xvOES_PACKED)); \
    packed_data->index = glMultiTexCoord4xvOES_INDEX; \
    packed_data->args.texture = (GLenum)_texture; \
    packed_data->args.coords = (GLfixed *)_coords; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiTexCoord4xvOES(packed, ret_v) do { \
    PACKED_glMultiTexCoord4xvOES *unpacked = (PACKED_glMultiTexCoord4xvOES *)packed; \
    ARGS_glMultiTexCoord4xvOES *args = (ARGS_glMultiTexCoord4xvOES *)&unpacked->args; \
    glMultiTexCoord4xvOES(args->texture, args->coords);; \
} while(0)
void glMultiTexCoord4xvOES(glMultiTexCoord4xvOES_ARG_EXPAND);
typedef void (*glMultiTexCoord4xvOES_PTR)(glMultiTexCoord4xvOES_ARG_EXPAND);
#define glMultiTexCoordP1ui_INDEX 1397
#define glMultiTexCoordP1ui_RETURN void
#define glMultiTexCoordP1ui_ARG_NAMES texture, type, coords
#define glMultiTexCoordP1ui_ARG_EXPAND GLenum texture, GLenum type, GLuint coords
#define glMultiTexCoordP1ui_PACKED PACKED_glMultiTexCoordP1ui
#define glMultiTexCoordP1ui_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiTexCoordP1ui_NOT_VOID_WRAP(...) {}
#define pack_glMultiTexCoordP1ui(_texture, _type, _coords) ({ \
    glMultiTexCoordP1ui_PACKED *packed_data = malloc(sizeof(glMultiTexCoordP1ui_PACKED)); \
    packed_data->index = glMultiTexCoordP1ui_INDEX; \
    packed_data->args.texture = (GLenum)_texture; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.coords = (GLuint)_coords; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiTexCoordP1ui(packed, ret_v) do { \
    PACKED_glMultiTexCoordP1ui *unpacked = (PACKED_glMultiTexCoordP1ui *)packed; \
    ARGS_glMultiTexCoordP1ui *args = (ARGS_glMultiTexCoordP1ui *)&unpacked->args; \
    glMultiTexCoordP1ui(args->texture, args->type, args->coords);; \
} while(0)
void glMultiTexCoordP1ui(glMultiTexCoordP1ui_ARG_EXPAND);
typedef void (*glMultiTexCoordP1ui_PTR)(glMultiTexCoordP1ui_ARG_EXPAND);
#define glMultiTexCoordP1uiv_INDEX 1398
#define glMultiTexCoordP1uiv_RETURN void
#define glMultiTexCoordP1uiv_ARG_NAMES texture, type, coords
#define glMultiTexCoordP1uiv_ARG_EXPAND GLenum texture, GLenum type, const GLuint * coords
#define glMultiTexCoordP1uiv_PACKED PACKED_glMultiTexCoordP1uiv
#define glMultiTexCoordP1uiv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiTexCoordP1uiv_NOT_VOID_WRAP(...) {}
#define pack_glMultiTexCoordP1uiv(_texture, _type, _coords) ({ \
    glMultiTexCoordP1uiv_PACKED *packed_data = malloc(sizeof(glMultiTexCoordP1uiv_PACKED)); \
    packed_data->index = glMultiTexCoordP1uiv_INDEX; \
    packed_data->args.texture = (GLenum)_texture; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.coords = (GLuint *)_coords; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiTexCoordP1uiv(packed, ret_v) do { \
    PACKED_glMultiTexCoordP1uiv *unpacked = (PACKED_glMultiTexCoordP1uiv *)packed; \
    ARGS_glMultiTexCoordP1uiv *args = (ARGS_glMultiTexCoordP1uiv *)&unpacked->args; \
    glMultiTexCoordP1uiv(args->texture, args->type, args->coords);; \
} while(0)
void glMultiTexCoordP1uiv(glMultiTexCoordP1uiv_ARG_EXPAND);
typedef void (*glMultiTexCoordP1uiv_PTR)(glMultiTexCoordP1uiv_ARG_EXPAND);
#define glMultiTexCoordP2ui_INDEX 1399
#define glMultiTexCoordP2ui_RETURN void
#define glMultiTexCoordP2ui_ARG_NAMES texture, type, coords
#define glMultiTexCoordP2ui_ARG_EXPAND GLenum texture, GLenum type, GLuint coords
#define glMultiTexCoordP2ui_PACKED PACKED_glMultiTexCoordP2ui
#define glMultiTexCoordP2ui_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiTexCoordP2ui_NOT_VOID_WRAP(...) {}
#define pack_glMultiTexCoordP2ui(_texture, _type, _coords) ({ \
    glMultiTexCoordP2ui_PACKED *packed_data = malloc(sizeof(glMultiTexCoordP2ui_PACKED)); \
    packed_data->index = glMultiTexCoordP2ui_INDEX; \
    packed_data->args.texture = (GLenum)_texture; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.coords = (GLuint)_coords; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiTexCoordP2ui(packed, ret_v) do { \
    PACKED_glMultiTexCoordP2ui *unpacked = (PACKED_glMultiTexCoordP2ui *)packed; \
    ARGS_glMultiTexCoordP2ui *args = (ARGS_glMultiTexCoordP2ui *)&unpacked->args; \
    glMultiTexCoordP2ui(args->texture, args->type, args->coords);; \
} while(0)
void glMultiTexCoordP2ui(glMultiTexCoordP2ui_ARG_EXPAND);
typedef void (*glMultiTexCoordP2ui_PTR)(glMultiTexCoordP2ui_ARG_EXPAND);
#define glMultiTexCoordP2uiv_INDEX 1400
#define glMultiTexCoordP2uiv_RETURN void
#define glMultiTexCoordP2uiv_ARG_NAMES texture, type, coords
#define glMultiTexCoordP2uiv_ARG_EXPAND GLenum texture, GLenum type, const GLuint * coords
#define glMultiTexCoordP2uiv_PACKED PACKED_glMultiTexCoordP2uiv
#define glMultiTexCoordP2uiv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiTexCoordP2uiv_NOT_VOID_WRAP(...) {}
#define pack_glMultiTexCoordP2uiv(_texture, _type, _coords) ({ \
    glMultiTexCoordP2uiv_PACKED *packed_data = malloc(sizeof(glMultiTexCoordP2uiv_PACKED)); \
    packed_data->index = glMultiTexCoordP2uiv_INDEX; \
    packed_data->args.texture = (GLenum)_texture; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.coords = (GLuint *)_coords; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiTexCoordP2uiv(packed, ret_v) do { \
    PACKED_glMultiTexCoordP2uiv *unpacked = (PACKED_glMultiTexCoordP2uiv *)packed; \
    ARGS_glMultiTexCoordP2uiv *args = (ARGS_glMultiTexCoordP2uiv *)&unpacked->args; \
    glMultiTexCoordP2uiv(args->texture, args->type, args->coords);; \
} while(0)
void glMultiTexCoordP2uiv(glMultiTexCoordP2uiv_ARG_EXPAND);
typedef void (*glMultiTexCoordP2uiv_PTR)(glMultiTexCoordP2uiv_ARG_EXPAND);
#define glMultiTexCoordP3ui_INDEX 1401
#define glMultiTexCoordP3ui_RETURN void
#define glMultiTexCoordP3ui_ARG_NAMES texture, type, coords
#define glMultiTexCoordP3ui_ARG_EXPAND GLenum texture, GLenum type, GLuint coords
#define glMultiTexCoordP3ui_PACKED PACKED_glMultiTexCoordP3ui
#define glMultiTexCoordP3ui_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiTexCoordP3ui_NOT_VOID_WRAP(...) {}
#define pack_glMultiTexCoordP3ui(_texture, _type, _coords) ({ \
    glMultiTexCoordP3ui_PACKED *packed_data = malloc(sizeof(glMultiTexCoordP3ui_PACKED)); \
    packed_data->index = glMultiTexCoordP3ui_INDEX; \
    packed_data->args.texture = (GLenum)_texture; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.coords = (GLuint)_coords; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiTexCoordP3ui(packed, ret_v) do { \
    PACKED_glMultiTexCoordP3ui *unpacked = (PACKED_glMultiTexCoordP3ui *)packed; \
    ARGS_glMultiTexCoordP3ui *args = (ARGS_glMultiTexCoordP3ui *)&unpacked->args; \
    glMultiTexCoordP3ui(args->texture, args->type, args->coords);; \
} while(0)
void glMultiTexCoordP3ui(glMultiTexCoordP3ui_ARG_EXPAND);
typedef void (*glMultiTexCoordP3ui_PTR)(glMultiTexCoordP3ui_ARG_EXPAND);
#define glMultiTexCoordP3uiv_INDEX 1402
#define glMultiTexCoordP3uiv_RETURN void
#define glMultiTexCoordP3uiv_ARG_NAMES texture, type, coords
#define glMultiTexCoordP3uiv_ARG_EXPAND GLenum texture, GLenum type, const GLuint * coords
#define glMultiTexCoordP3uiv_PACKED PACKED_glMultiTexCoordP3uiv
#define glMultiTexCoordP3uiv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiTexCoordP3uiv_NOT_VOID_WRAP(...) {}
#define pack_glMultiTexCoordP3uiv(_texture, _type, _coords) ({ \
    glMultiTexCoordP3uiv_PACKED *packed_data = malloc(sizeof(glMultiTexCoordP3uiv_PACKED)); \
    packed_data->index = glMultiTexCoordP3uiv_INDEX; \
    packed_data->args.texture = (GLenum)_texture; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.coords = (GLuint *)_coords; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiTexCoordP3uiv(packed, ret_v) do { \
    PACKED_glMultiTexCoordP3uiv *unpacked = (PACKED_glMultiTexCoordP3uiv *)packed; \
    ARGS_glMultiTexCoordP3uiv *args = (ARGS_glMultiTexCoordP3uiv *)&unpacked->args; \
    glMultiTexCoordP3uiv(args->texture, args->type, args->coords);; \
} while(0)
void glMultiTexCoordP3uiv(glMultiTexCoordP3uiv_ARG_EXPAND);
typedef void (*glMultiTexCoordP3uiv_PTR)(glMultiTexCoordP3uiv_ARG_EXPAND);
#define glMultiTexCoordP4ui_INDEX 1403
#define glMultiTexCoordP4ui_RETURN void
#define glMultiTexCoordP4ui_ARG_NAMES texture, type, coords
#define glMultiTexCoordP4ui_ARG_EXPAND GLenum texture, GLenum type, GLuint coords
#define glMultiTexCoordP4ui_PACKED PACKED_glMultiTexCoordP4ui
#define glMultiTexCoordP4ui_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiTexCoordP4ui_NOT_VOID_WRAP(...) {}
#define pack_glMultiTexCoordP4ui(_texture, _type, _coords) ({ \
    glMultiTexCoordP4ui_PACKED *packed_data = malloc(sizeof(glMultiTexCoordP4ui_PACKED)); \
    packed_data->index = glMultiTexCoordP4ui_INDEX; \
    packed_data->args.texture = (GLenum)_texture; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.coords = (GLuint)_coords; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiTexCoordP4ui(packed, ret_v) do { \
    PACKED_glMultiTexCoordP4ui *unpacked = (PACKED_glMultiTexCoordP4ui *)packed; \
    ARGS_glMultiTexCoordP4ui *args = (ARGS_glMultiTexCoordP4ui *)&unpacked->args; \
    glMultiTexCoordP4ui(args->texture, args->type, args->coords);; \
} while(0)
void glMultiTexCoordP4ui(glMultiTexCoordP4ui_ARG_EXPAND);
typedef void (*glMultiTexCoordP4ui_PTR)(glMultiTexCoordP4ui_ARG_EXPAND);
#define glMultiTexCoordP4uiv_INDEX 1404
#define glMultiTexCoordP4uiv_RETURN void
#define glMultiTexCoordP4uiv_ARG_NAMES texture, type, coords
#define glMultiTexCoordP4uiv_ARG_EXPAND GLenum texture, GLenum type, const GLuint * coords
#define glMultiTexCoordP4uiv_PACKED PACKED_glMultiTexCoordP4uiv
#define glMultiTexCoordP4uiv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiTexCoordP4uiv_NOT_VOID_WRAP(...) {}
#define pack_glMultiTexCoordP4uiv(_texture, _type, _coords) ({ \
    glMultiTexCoordP4uiv_PACKED *packed_data = malloc(sizeof(glMultiTexCoordP4uiv_PACKED)); \
    packed_data->index = glMultiTexCoordP4uiv_INDEX; \
    packed_data->args.texture = (GLenum)_texture; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.coords = (GLuint *)_coords; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiTexCoordP4uiv(packed, ret_v) do { \
    PACKED_glMultiTexCoordP4uiv *unpacked = (PACKED_glMultiTexCoordP4uiv *)packed; \
    ARGS_glMultiTexCoordP4uiv *args = (ARGS_glMultiTexCoordP4uiv *)&unpacked->args; \
    glMultiTexCoordP4uiv(args->texture, args->type, args->coords);; \
} while(0)
void glMultiTexCoordP4uiv(glMultiTexCoordP4uiv_ARG_EXPAND);
typedef void (*glMultiTexCoordP4uiv_PTR)(glMultiTexCoordP4uiv_ARG_EXPAND);
#define glMultiTexCoordPointerEXT_INDEX 1405
#define glMultiTexCoordPointerEXT_RETURN void
#define glMultiTexCoordPointerEXT_ARG_NAMES texunit, size, type, stride, pointer
#define glMultiTexCoordPointerEXT_ARG_EXPAND GLenum texunit, GLint size, GLenum type, GLsizei stride, const GLvoid * pointer
#define glMultiTexCoordPointerEXT_PACKED PACKED_glMultiTexCoordPointerEXT
#define glMultiTexCoordPointerEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiTexCoordPointerEXT_NOT_VOID_WRAP(...) {}
#define pack_glMultiTexCoordPointerEXT(_texunit, _size, _type, _stride, _pointer) ({ \
    glMultiTexCoordPointerEXT_PACKED *packed_data = malloc(sizeof(glMultiTexCoordPointerEXT_PACKED)); \
    packed_data->index = glMultiTexCoordPointerEXT_INDEX; \
    packed_data->args.texunit = (GLenum)_texunit; \
    packed_data->args.size = (GLint)_size; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.stride = (GLsizei)_stride; \
    packed_data->args.pointer = (GLvoid *)_pointer; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiTexCoordPointerEXT(packed, ret_v) do { \
    PACKED_glMultiTexCoordPointerEXT *unpacked = (PACKED_glMultiTexCoordPointerEXT *)packed; \
    ARGS_glMultiTexCoordPointerEXT *args = (ARGS_glMultiTexCoordPointerEXT *)&unpacked->args; \
    glMultiTexCoordPointerEXT(args->texunit, args->size, args->type, args->stride, args->pointer);; \
} while(0)
void glMultiTexCoordPointerEXT(glMultiTexCoordPointerEXT_ARG_EXPAND);
typedef void (*glMultiTexCoordPointerEXT_PTR)(glMultiTexCoordPointerEXT_ARG_EXPAND);
#define glMultiTexEnvfEXT_INDEX 1406
#define glMultiTexEnvfEXT_RETURN void
#define glMultiTexEnvfEXT_ARG_NAMES texunit, target, pname, param
#define glMultiTexEnvfEXT_ARG_EXPAND GLenum texunit, GLenum target, GLenum pname, GLfloat param
#define glMultiTexEnvfEXT_PACKED PACKED_glMultiTexEnvfEXT
#define glMultiTexEnvfEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiTexEnvfEXT_NOT_VOID_WRAP(...) {}
#define pack_glMultiTexEnvfEXT(_texunit, _target, _pname, _param) ({ \
    glMultiTexEnvfEXT_PACKED *packed_data = malloc(sizeof(glMultiTexEnvfEXT_PACKED)); \
    packed_data->index = glMultiTexEnvfEXT_INDEX; \
    packed_data->args.texunit = (GLenum)_texunit; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.param = (GLfloat)_param; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiTexEnvfEXT(packed, ret_v) do { \
    PACKED_glMultiTexEnvfEXT *unpacked = (PACKED_glMultiTexEnvfEXT *)packed; \
    ARGS_glMultiTexEnvfEXT *args = (ARGS_glMultiTexEnvfEXT *)&unpacked->args; \
    glMultiTexEnvfEXT(args->texunit, args->target, args->pname, args->param);; \
} while(0)
void glMultiTexEnvfEXT(glMultiTexEnvfEXT_ARG_EXPAND);
typedef void (*glMultiTexEnvfEXT_PTR)(glMultiTexEnvfEXT_ARG_EXPAND);
#define glMultiTexEnvfvEXT_INDEX 1407
#define glMultiTexEnvfvEXT_RETURN void
#define glMultiTexEnvfvEXT_ARG_NAMES texunit, target, pname, params
#define glMultiTexEnvfvEXT_ARG_EXPAND GLenum texunit, GLenum target, GLenum pname, const GLfloat * params
#define glMultiTexEnvfvEXT_PACKED PACKED_glMultiTexEnvfvEXT
#define glMultiTexEnvfvEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiTexEnvfvEXT_NOT_VOID_WRAP(...) {}
#define pack_glMultiTexEnvfvEXT(_texunit, _target, _pname, _params) ({ \
    glMultiTexEnvfvEXT_PACKED *packed_data = malloc(sizeof(glMultiTexEnvfvEXT_PACKED)); \
    packed_data->index = glMultiTexEnvfvEXT_INDEX; \
    packed_data->args.texunit = (GLenum)_texunit; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLfloat *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiTexEnvfvEXT(packed, ret_v) do { \
    PACKED_glMultiTexEnvfvEXT *unpacked = (PACKED_glMultiTexEnvfvEXT *)packed; \
    ARGS_glMultiTexEnvfvEXT *args = (ARGS_glMultiTexEnvfvEXT *)&unpacked->args; \
    glMultiTexEnvfvEXT(args->texunit, args->target, args->pname, args->params);; \
} while(0)
void glMultiTexEnvfvEXT(glMultiTexEnvfvEXT_ARG_EXPAND);
typedef void (*glMultiTexEnvfvEXT_PTR)(glMultiTexEnvfvEXT_ARG_EXPAND);
#define glMultiTexEnviEXT_INDEX 1408
#define glMultiTexEnviEXT_RETURN void
#define glMultiTexEnviEXT_ARG_NAMES texunit, target, pname, param
#define glMultiTexEnviEXT_ARG_EXPAND GLenum texunit, GLenum target, GLenum pname, GLint param
#define glMultiTexEnviEXT_PACKED PACKED_glMultiTexEnviEXT
#define glMultiTexEnviEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiTexEnviEXT_NOT_VOID_WRAP(...) {}
#define pack_glMultiTexEnviEXT(_texunit, _target, _pname, _param) ({ \
    glMultiTexEnviEXT_PACKED *packed_data = malloc(sizeof(glMultiTexEnviEXT_PACKED)); \
    packed_data->index = glMultiTexEnviEXT_INDEX; \
    packed_data->args.texunit = (GLenum)_texunit; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.param = (GLint)_param; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiTexEnviEXT(packed, ret_v) do { \
    PACKED_glMultiTexEnviEXT *unpacked = (PACKED_glMultiTexEnviEXT *)packed; \
    ARGS_glMultiTexEnviEXT *args = (ARGS_glMultiTexEnviEXT *)&unpacked->args; \
    glMultiTexEnviEXT(args->texunit, args->target, args->pname, args->param);; \
} while(0)
void glMultiTexEnviEXT(glMultiTexEnviEXT_ARG_EXPAND);
typedef void (*glMultiTexEnviEXT_PTR)(glMultiTexEnviEXT_ARG_EXPAND);
#define glMultiTexEnvivEXT_INDEX 1409
#define glMultiTexEnvivEXT_RETURN void
#define glMultiTexEnvivEXT_ARG_NAMES texunit, target, pname, params
#define glMultiTexEnvivEXT_ARG_EXPAND GLenum texunit, GLenum target, GLenum pname, const GLint * params
#define glMultiTexEnvivEXT_PACKED PACKED_glMultiTexEnvivEXT
#define glMultiTexEnvivEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiTexEnvivEXT_NOT_VOID_WRAP(...) {}
#define pack_glMultiTexEnvivEXT(_texunit, _target, _pname, _params) ({ \
    glMultiTexEnvivEXT_PACKED *packed_data = malloc(sizeof(glMultiTexEnvivEXT_PACKED)); \
    packed_data->index = glMultiTexEnvivEXT_INDEX; \
    packed_data->args.texunit = (GLenum)_texunit; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiTexEnvivEXT(packed, ret_v) do { \
    PACKED_glMultiTexEnvivEXT *unpacked = (PACKED_glMultiTexEnvivEXT *)packed; \
    ARGS_glMultiTexEnvivEXT *args = (ARGS_glMultiTexEnvivEXT *)&unpacked->args; \
    glMultiTexEnvivEXT(args->texunit, args->target, args->pname, args->params);; \
} while(0)
void glMultiTexEnvivEXT(glMultiTexEnvivEXT_ARG_EXPAND);
typedef void (*glMultiTexEnvivEXT_PTR)(glMultiTexEnvivEXT_ARG_EXPAND);
#define glMultiTexGendEXT_INDEX 1410
#define glMultiTexGendEXT_RETURN void
#define glMultiTexGendEXT_ARG_NAMES texunit, coord, pname, param
#define glMultiTexGendEXT_ARG_EXPAND GLenum texunit, GLenum coord, GLenum pname, GLdouble param
#define glMultiTexGendEXT_PACKED PACKED_glMultiTexGendEXT
#define glMultiTexGendEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiTexGendEXT_NOT_VOID_WRAP(...) {}
#define pack_glMultiTexGendEXT(_texunit, _coord, _pname, _param) ({ \
    glMultiTexGendEXT_PACKED *packed_data = malloc(sizeof(glMultiTexGendEXT_PACKED)); \
    packed_data->index = glMultiTexGendEXT_INDEX; \
    packed_data->args.texunit = (GLenum)_texunit; \
    packed_data->args.coord = (GLenum)_coord; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.param = (GLdouble)_param; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiTexGendEXT(packed, ret_v) do { \
    PACKED_glMultiTexGendEXT *unpacked = (PACKED_glMultiTexGendEXT *)packed; \
    ARGS_glMultiTexGendEXT *args = (ARGS_glMultiTexGendEXT *)&unpacked->args; \
    glMultiTexGendEXT(args->texunit, args->coord, args->pname, args->param);; \
} while(0)
void glMultiTexGendEXT(glMultiTexGendEXT_ARG_EXPAND);
typedef void (*glMultiTexGendEXT_PTR)(glMultiTexGendEXT_ARG_EXPAND);
#define glMultiTexGendvEXT_INDEX 1411
#define glMultiTexGendvEXT_RETURN void
#define glMultiTexGendvEXT_ARG_NAMES texunit, coord, pname, params
#define glMultiTexGendvEXT_ARG_EXPAND GLenum texunit, GLenum coord, GLenum pname, const GLdouble * params
#define glMultiTexGendvEXT_PACKED PACKED_glMultiTexGendvEXT
#define glMultiTexGendvEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiTexGendvEXT_NOT_VOID_WRAP(...) {}
#define pack_glMultiTexGendvEXT(_texunit, _coord, _pname, _params) ({ \
    glMultiTexGendvEXT_PACKED *packed_data = malloc(sizeof(glMultiTexGendvEXT_PACKED)); \
    packed_data->index = glMultiTexGendvEXT_INDEX; \
    packed_data->args.texunit = (GLenum)_texunit; \
    packed_data->args.coord = (GLenum)_coord; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLdouble *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiTexGendvEXT(packed, ret_v) do { \
    PACKED_glMultiTexGendvEXT *unpacked = (PACKED_glMultiTexGendvEXT *)packed; \
    ARGS_glMultiTexGendvEXT *args = (ARGS_glMultiTexGendvEXT *)&unpacked->args; \
    glMultiTexGendvEXT(args->texunit, args->coord, args->pname, args->params);; \
} while(0)
void glMultiTexGendvEXT(glMultiTexGendvEXT_ARG_EXPAND);
typedef void (*glMultiTexGendvEXT_PTR)(glMultiTexGendvEXT_ARG_EXPAND);
#define glMultiTexGenfEXT_INDEX 1412
#define glMultiTexGenfEXT_RETURN void
#define glMultiTexGenfEXT_ARG_NAMES texunit, coord, pname, param
#define glMultiTexGenfEXT_ARG_EXPAND GLenum texunit, GLenum coord, GLenum pname, GLfloat param
#define glMultiTexGenfEXT_PACKED PACKED_glMultiTexGenfEXT
#define glMultiTexGenfEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiTexGenfEXT_NOT_VOID_WRAP(...) {}
#define pack_glMultiTexGenfEXT(_texunit, _coord, _pname, _param) ({ \
    glMultiTexGenfEXT_PACKED *packed_data = malloc(sizeof(glMultiTexGenfEXT_PACKED)); \
    packed_data->index = glMultiTexGenfEXT_INDEX; \
    packed_data->args.texunit = (GLenum)_texunit; \
    packed_data->args.coord = (GLenum)_coord; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.param = (GLfloat)_param; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiTexGenfEXT(packed, ret_v) do { \
    PACKED_glMultiTexGenfEXT *unpacked = (PACKED_glMultiTexGenfEXT *)packed; \
    ARGS_glMultiTexGenfEXT *args = (ARGS_glMultiTexGenfEXT *)&unpacked->args; \
    glMultiTexGenfEXT(args->texunit, args->coord, args->pname, args->param);; \
} while(0)
void glMultiTexGenfEXT(glMultiTexGenfEXT_ARG_EXPAND);
typedef void (*glMultiTexGenfEXT_PTR)(glMultiTexGenfEXT_ARG_EXPAND);
#define glMultiTexGenfvEXT_INDEX 1413
#define glMultiTexGenfvEXT_RETURN void
#define glMultiTexGenfvEXT_ARG_NAMES texunit, coord, pname, params
#define glMultiTexGenfvEXT_ARG_EXPAND GLenum texunit, GLenum coord, GLenum pname, const GLfloat * params
#define glMultiTexGenfvEXT_PACKED PACKED_glMultiTexGenfvEXT
#define glMultiTexGenfvEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiTexGenfvEXT_NOT_VOID_WRAP(...) {}
#define pack_glMultiTexGenfvEXT(_texunit, _coord, _pname, _params) ({ \
    glMultiTexGenfvEXT_PACKED *packed_data = malloc(sizeof(glMultiTexGenfvEXT_PACKED)); \
    packed_data->index = glMultiTexGenfvEXT_INDEX; \
    packed_data->args.texunit = (GLenum)_texunit; \
    packed_data->args.coord = (GLenum)_coord; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLfloat *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiTexGenfvEXT(packed, ret_v) do { \
    PACKED_glMultiTexGenfvEXT *unpacked = (PACKED_glMultiTexGenfvEXT *)packed; \
    ARGS_glMultiTexGenfvEXT *args = (ARGS_glMultiTexGenfvEXT *)&unpacked->args; \
    glMultiTexGenfvEXT(args->texunit, args->coord, args->pname, args->params);; \
} while(0)
void glMultiTexGenfvEXT(glMultiTexGenfvEXT_ARG_EXPAND);
typedef void (*glMultiTexGenfvEXT_PTR)(glMultiTexGenfvEXT_ARG_EXPAND);
#define glMultiTexGeniEXT_INDEX 1414
#define glMultiTexGeniEXT_RETURN void
#define glMultiTexGeniEXT_ARG_NAMES texunit, coord, pname, param
#define glMultiTexGeniEXT_ARG_EXPAND GLenum texunit, GLenum coord, GLenum pname, GLint param
#define glMultiTexGeniEXT_PACKED PACKED_glMultiTexGeniEXT
#define glMultiTexGeniEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiTexGeniEXT_NOT_VOID_WRAP(...) {}
#define pack_glMultiTexGeniEXT(_texunit, _coord, _pname, _param) ({ \
    glMultiTexGeniEXT_PACKED *packed_data = malloc(sizeof(glMultiTexGeniEXT_PACKED)); \
    packed_data->index = glMultiTexGeniEXT_INDEX; \
    packed_data->args.texunit = (GLenum)_texunit; \
    packed_data->args.coord = (GLenum)_coord; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.param = (GLint)_param; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiTexGeniEXT(packed, ret_v) do { \
    PACKED_glMultiTexGeniEXT *unpacked = (PACKED_glMultiTexGeniEXT *)packed; \
    ARGS_glMultiTexGeniEXT *args = (ARGS_glMultiTexGeniEXT *)&unpacked->args; \
    glMultiTexGeniEXT(args->texunit, args->coord, args->pname, args->param);; \
} while(0)
void glMultiTexGeniEXT(glMultiTexGeniEXT_ARG_EXPAND);
typedef void (*glMultiTexGeniEXT_PTR)(glMultiTexGeniEXT_ARG_EXPAND);
#define glMultiTexGenivEXT_INDEX 1415
#define glMultiTexGenivEXT_RETURN void
#define glMultiTexGenivEXT_ARG_NAMES texunit, coord, pname, params
#define glMultiTexGenivEXT_ARG_EXPAND GLenum texunit, GLenum coord, GLenum pname, const GLint * params
#define glMultiTexGenivEXT_PACKED PACKED_glMultiTexGenivEXT
#define glMultiTexGenivEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiTexGenivEXT_NOT_VOID_WRAP(...) {}
#define pack_glMultiTexGenivEXT(_texunit, _coord, _pname, _params) ({ \
    glMultiTexGenivEXT_PACKED *packed_data = malloc(sizeof(glMultiTexGenivEXT_PACKED)); \
    packed_data->index = glMultiTexGenivEXT_INDEX; \
    packed_data->args.texunit = (GLenum)_texunit; \
    packed_data->args.coord = (GLenum)_coord; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiTexGenivEXT(packed, ret_v) do { \
    PACKED_glMultiTexGenivEXT *unpacked = (PACKED_glMultiTexGenivEXT *)packed; \
    ARGS_glMultiTexGenivEXT *args = (ARGS_glMultiTexGenivEXT *)&unpacked->args; \
    glMultiTexGenivEXT(args->texunit, args->coord, args->pname, args->params);; \
} while(0)
void glMultiTexGenivEXT(glMultiTexGenivEXT_ARG_EXPAND);
typedef void (*glMultiTexGenivEXT_PTR)(glMultiTexGenivEXT_ARG_EXPAND);
#define glMultiTexImage1DEXT_INDEX 1416
#define glMultiTexImage1DEXT_RETURN void
#define glMultiTexImage1DEXT_ARG_NAMES texunit, target, level, internalformat, width, border, format, type, pixels
#define glMultiTexImage1DEXT_ARG_EXPAND GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid * pixels
#define glMultiTexImage1DEXT_PACKED PACKED_glMultiTexImage1DEXT
#define glMultiTexImage1DEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiTexImage1DEXT_NOT_VOID_WRAP(...) {}
#define pack_glMultiTexImage1DEXT(_texunit, _target, _level, _internalformat, _width, _border, _format, _type, _pixels) ({ \
    glMultiTexImage1DEXT_PACKED *packed_data = malloc(sizeof(glMultiTexImage1DEXT_PACKED)); \
    packed_data->index = glMultiTexImage1DEXT_INDEX; \
    packed_data->args.texunit = (GLenum)_texunit; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.level = (GLint)_level; \
    packed_data->args.internalformat = (GLenum)_internalformat; \
    packed_data->args.width = (GLsizei)_width; \
    packed_data->args.border = (GLint)_border; \
    packed_data->args.format = (GLenum)_format; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.pixels = (GLvoid *)_pixels; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiTexImage1DEXT(packed, ret_v) do { \
    PACKED_glMultiTexImage1DEXT *unpacked = (PACKED_glMultiTexImage1DEXT *)packed; \
    ARGS_glMultiTexImage1DEXT *args = (ARGS_glMultiTexImage1DEXT *)&unpacked->args; \
    glMultiTexImage1DEXT(args->texunit, args->target, args->level, args->internalformat, args->width, args->border, args->format, args->type, args->pixels);; \
} while(0)
void glMultiTexImage1DEXT(glMultiTexImage1DEXT_ARG_EXPAND);
typedef void (*glMultiTexImage1DEXT_PTR)(glMultiTexImage1DEXT_ARG_EXPAND);
#define glMultiTexImage2DEXT_INDEX 1417
#define glMultiTexImage2DEXT_RETURN void
#define glMultiTexImage2DEXT_ARG_NAMES texunit, target, level, internalformat, width, height, border, format, type, pixels
#define glMultiTexImage2DEXT_ARG_EXPAND GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid * pixels
#define glMultiTexImage2DEXT_PACKED PACKED_glMultiTexImage2DEXT
#define glMultiTexImage2DEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiTexImage2DEXT_NOT_VOID_WRAP(...) {}
#define pack_glMultiTexImage2DEXT(_texunit, _target, _level, _internalformat, _width, _height, _border, _format, _type, _pixels) ({ \
    glMultiTexImage2DEXT_PACKED *packed_data = malloc(sizeof(glMultiTexImage2DEXT_PACKED)); \
    packed_data->index = glMultiTexImage2DEXT_INDEX; \
    packed_data->args.texunit = (GLenum)_texunit; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.level = (GLint)_level; \
    packed_data->args.internalformat = (GLenum)_internalformat; \
    packed_data->args.width = (GLsizei)_width; \
    packed_data->args.height = (GLsizei)_height; \
    packed_data->args.border = (GLint)_border; \
    packed_data->args.format = (GLenum)_format; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.pixels = (GLvoid *)_pixels; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiTexImage2DEXT(packed, ret_v) do { \
    PACKED_glMultiTexImage2DEXT *unpacked = (PACKED_glMultiTexImage2DEXT *)packed; \
    ARGS_glMultiTexImage2DEXT *args = (ARGS_glMultiTexImage2DEXT *)&unpacked->args; \
    glMultiTexImage2DEXT(args->texunit, args->target, args->level, args->internalformat, args->width, args->height, args->border, args->format, args->type, args->pixels);; \
} while(0)
void glMultiTexImage2DEXT(glMultiTexImage2DEXT_ARG_EXPAND);
typedef void (*glMultiTexImage2DEXT_PTR)(glMultiTexImage2DEXT_ARG_EXPAND);
#define glMultiTexImage3DEXT_INDEX 1418
#define glMultiTexImage3DEXT_RETURN void
#define glMultiTexImage3DEXT_ARG_NAMES texunit, target, level, internalformat, width, height, depth, border, format, type, pixels
#define glMultiTexImage3DEXT_ARG_EXPAND GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid * pixels
#define glMultiTexImage3DEXT_PACKED PACKED_glMultiTexImage3DEXT
#define glMultiTexImage3DEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiTexImage3DEXT_NOT_VOID_WRAP(...) {}
#define pack_glMultiTexImage3DEXT(_texunit, _target, _level, _internalformat, _width, _height, _depth, _border, _format, _type, _pixels) ({ \
    glMultiTexImage3DEXT_PACKED *packed_data = malloc(sizeof(glMultiTexImage3DEXT_PACKED)); \
    packed_data->index = glMultiTexImage3DEXT_INDEX; \
    packed_data->args.texunit = (GLenum)_texunit; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.level = (GLint)_level; \
    packed_data->args.internalformat = (GLenum)_internalformat; \
    packed_data->args.width = (GLsizei)_width; \
    packed_data->args.height = (GLsizei)_height; \
    packed_data->args.depth = (GLsizei)_depth; \
    packed_data->args.border = (GLint)_border; \
    packed_data->args.format = (GLenum)_format; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.pixels = (GLvoid *)_pixels; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiTexImage3DEXT(packed, ret_v) do { \
    PACKED_glMultiTexImage3DEXT *unpacked = (PACKED_glMultiTexImage3DEXT *)packed; \
    ARGS_glMultiTexImage3DEXT *args = (ARGS_glMultiTexImage3DEXT *)&unpacked->args; \
    glMultiTexImage3DEXT(args->texunit, args->target, args->level, args->internalformat, args->width, args->height, args->depth, args->border, args->format, args->type, args->pixels);; \
} while(0)
void glMultiTexImage3DEXT(glMultiTexImage3DEXT_ARG_EXPAND);
typedef void (*glMultiTexImage3DEXT_PTR)(glMultiTexImage3DEXT_ARG_EXPAND);
#define glMultiTexParameterIivEXT_INDEX 1419
#define glMultiTexParameterIivEXT_RETURN void
#define glMultiTexParameterIivEXT_ARG_NAMES texunit, target, pname, params
#define glMultiTexParameterIivEXT_ARG_EXPAND GLenum texunit, GLenum target, GLenum pname, const GLint * params
#define glMultiTexParameterIivEXT_PACKED PACKED_glMultiTexParameterIivEXT
#define glMultiTexParameterIivEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiTexParameterIivEXT_NOT_VOID_WRAP(...) {}
#define pack_glMultiTexParameterIivEXT(_texunit, _target, _pname, _params) ({ \
    glMultiTexParameterIivEXT_PACKED *packed_data = malloc(sizeof(glMultiTexParameterIivEXT_PACKED)); \
    packed_data->index = glMultiTexParameterIivEXT_INDEX; \
    packed_data->args.texunit = (GLenum)_texunit; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiTexParameterIivEXT(packed, ret_v) do { \
    PACKED_glMultiTexParameterIivEXT *unpacked = (PACKED_glMultiTexParameterIivEXT *)packed; \
    ARGS_glMultiTexParameterIivEXT *args = (ARGS_glMultiTexParameterIivEXT *)&unpacked->args; \
    glMultiTexParameterIivEXT(args->texunit, args->target, args->pname, args->params);; \
} while(0)
void glMultiTexParameterIivEXT(glMultiTexParameterIivEXT_ARG_EXPAND);
typedef void (*glMultiTexParameterIivEXT_PTR)(glMultiTexParameterIivEXT_ARG_EXPAND);
#define glMultiTexParameterIuivEXT_INDEX 1420
#define glMultiTexParameterIuivEXT_RETURN void
#define glMultiTexParameterIuivEXT_ARG_NAMES texunit, target, pname, params
#define glMultiTexParameterIuivEXT_ARG_EXPAND GLenum texunit, GLenum target, GLenum pname, const GLuint * params
#define glMultiTexParameterIuivEXT_PACKED PACKED_glMultiTexParameterIuivEXT
#define glMultiTexParameterIuivEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiTexParameterIuivEXT_NOT_VOID_WRAP(...) {}
#define pack_glMultiTexParameterIuivEXT(_texunit, _target, _pname, _params) ({ \
    glMultiTexParameterIuivEXT_PACKED *packed_data = malloc(sizeof(glMultiTexParameterIuivEXT_PACKED)); \
    packed_data->index = glMultiTexParameterIuivEXT_INDEX; \
    packed_data->args.texunit = (GLenum)_texunit; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLuint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiTexParameterIuivEXT(packed, ret_v) do { \
    PACKED_glMultiTexParameterIuivEXT *unpacked = (PACKED_glMultiTexParameterIuivEXT *)packed; \
    ARGS_glMultiTexParameterIuivEXT *args = (ARGS_glMultiTexParameterIuivEXT *)&unpacked->args; \
    glMultiTexParameterIuivEXT(args->texunit, args->target, args->pname, args->params);; \
} while(0)
void glMultiTexParameterIuivEXT(glMultiTexParameterIuivEXT_ARG_EXPAND);
typedef void (*glMultiTexParameterIuivEXT_PTR)(glMultiTexParameterIuivEXT_ARG_EXPAND);
#define glMultiTexParameterfEXT_INDEX 1421
#define glMultiTexParameterfEXT_RETURN void
#define glMultiTexParameterfEXT_ARG_NAMES texunit, target, pname, param
#define glMultiTexParameterfEXT_ARG_EXPAND GLenum texunit, GLenum target, GLenum pname, GLfloat param
#define glMultiTexParameterfEXT_PACKED PACKED_glMultiTexParameterfEXT
#define glMultiTexParameterfEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiTexParameterfEXT_NOT_VOID_WRAP(...) {}
#define pack_glMultiTexParameterfEXT(_texunit, _target, _pname, _param) ({ \
    glMultiTexParameterfEXT_PACKED *packed_data = malloc(sizeof(glMultiTexParameterfEXT_PACKED)); \
    packed_data->index = glMultiTexParameterfEXT_INDEX; \
    packed_data->args.texunit = (GLenum)_texunit; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.param = (GLfloat)_param; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiTexParameterfEXT(packed, ret_v) do { \
    PACKED_glMultiTexParameterfEXT *unpacked = (PACKED_glMultiTexParameterfEXT *)packed; \
    ARGS_glMultiTexParameterfEXT *args = (ARGS_glMultiTexParameterfEXT *)&unpacked->args; \
    glMultiTexParameterfEXT(args->texunit, args->target, args->pname, args->param);; \
} while(0)
void glMultiTexParameterfEXT(glMultiTexParameterfEXT_ARG_EXPAND);
typedef void (*glMultiTexParameterfEXT_PTR)(glMultiTexParameterfEXT_ARG_EXPAND);
#define glMultiTexParameterfvEXT_INDEX 1422
#define glMultiTexParameterfvEXT_RETURN void
#define glMultiTexParameterfvEXT_ARG_NAMES texunit, target, pname, params
#define glMultiTexParameterfvEXT_ARG_EXPAND GLenum texunit, GLenum target, GLenum pname, const GLfloat * params
#define glMultiTexParameterfvEXT_PACKED PACKED_glMultiTexParameterfvEXT
#define glMultiTexParameterfvEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiTexParameterfvEXT_NOT_VOID_WRAP(...) {}
#define pack_glMultiTexParameterfvEXT(_texunit, _target, _pname, _params) ({ \
    glMultiTexParameterfvEXT_PACKED *packed_data = malloc(sizeof(glMultiTexParameterfvEXT_PACKED)); \
    packed_data->index = glMultiTexParameterfvEXT_INDEX; \
    packed_data->args.texunit = (GLenum)_texunit; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLfloat *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiTexParameterfvEXT(packed, ret_v) do { \
    PACKED_glMultiTexParameterfvEXT *unpacked = (PACKED_glMultiTexParameterfvEXT *)packed; \
    ARGS_glMultiTexParameterfvEXT *args = (ARGS_glMultiTexParameterfvEXT *)&unpacked->args; \
    glMultiTexParameterfvEXT(args->texunit, args->target, args->pname, args->params);; \
} while(0)
void glMultiTexParameterfvEXT(glMultiTexParameterfvEXT_ARG_EXPAND);
typedef void (*glMultiTexParameterfvEXT_PTR)(glMultiTexParameterfvEXT_ARG_EXPAND);
#define glMultiTexParameteriEXT_INDEX 1423
#define glMultiTexParameteriEXT_RETURN void
#define glMultiTexParameteriEXT_ARG_NAMES texunit, target, pname, param
#define glMultiTexParameteriEXT_ARG_EXPAND GLenum texunit, GLenum target, GLenum pname, GLint param
#define glMultiTexParameteriEXT_PACKED PACKED_glMultiTexParameteriEXT
#define glMultiTexParameteriEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiTexParameteriEXT_NOT_VOID_WRAP(...) {}
#define pack_glMultiTexParameteriEXT(_texunit, _target, _pname, _param) ({ \
    glMultiTexParameteriEXT_PACKED *packed_data = malloc(sizeof(glMultiTexParameteriEXT_PACKED)); \
    packed_data->index = glMultiTexParameteriEXT_INDEX; \
    packed_data->args.texunit = (GLenum)_texunit; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.param = (GLint)_param; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiTexParameteriEXT(packed, ret_v) do { \
    PACKED_glMultiTexParameteriEXT *unpacked = (PACKED_glMultiTexParameteriEXT *)packed; \
    ARGS_glMultiTexParameteriEXT *args = (ARGS_glMultiTexParameteriEXT *)&unpacked->args; \
    glMultiTexParameteriEXT(args->texunit, args->target, args->pname, args->param);; \
} while(0)
void glMultiTexParameteriEXT(glMultiTexParameteriEXT_ARG_EXPAND);
typedef void (*glMultiTexParameteriEXT_PTR)(glMultiTexParameteriEXT_ARG_EXPAND);
#define glMultiTexParameterivEXT_INDEX 1424
#define glMultiTexParameterivEXT_RETURN void
#define glMultiTexParameterivEXT_ARG_NAMES texunit, target, pname, params
#define glMultiTexParameterivEXT_ARG_EXPAND GLenum texunit, GLenum target, GLenum pname, const GLint * params
#define glMultiTexParameterivEXT_PACKED PACKED_glMultiTexParameterivEXT
#define glMultiTexParameterivEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiTexParameterivEXT_NOT_VOID_WRAP(...) {}
#define pack_glMultiTexParameterivEXT(_texunit, _target, _pname, _params) ({ \
    glMultiTexParameterivEXT_PACKED *packed_data = malloc(sizeof(glMultiTexParameterivEXT_PACKED)); \
    packed_data->index = glMultiTexParameterivEXT_INDEX; \
    packed_data->args.texunit = (GLenum)_texunit; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiTexParameterivEXT(packed, ret_v) do { \
    PACKED_glMultiTexParameterivEXT *unpacked = (PACKED_glMultiTexParameterivEXT *)packed; \
    ARGS_glMultiTexParameterivEXT *args = (ARGS_glMultiTexParameterivEXT *)&unpacked->args; \
    glMultiTexParameterivEXT(args->texunit, args->target, args->pname, args->params);; \
} while(0)
void glMultiTexParameterivEXT(glMultiTexParameterivEXT_ARG_EXPAND);
typedef void (*glMultiTexParameterivEXT_PTR)(glMultiTexParameterivEXT_ARG_EXPAND);
#define glMultiTexRenderbufferEXT_INDEX 1425
#define glMultiTexRenderbufferEXT_RETURN void
#define glMultiTexRenderbufferEXT_ARG_NAMES texunit, target, renderbuffer
#define glMultiTexRenderbufferEXT_ARG_EXPAND GLenum texunit, GLenum target, GLuint renderbuffer
#define glMultiTexRenderbufferEXT_PACKED PACKED_glMultiTexRenderbufferEXT
#define glMultiTexRenderbufferEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiTexRenderbufferEXT_NOT_VOID_WRAP(...) {}
#define pack_glMultiTexRenderbufferEXT(_texunit, _target, _renderbuffer) ({ \
    glMultiTexRenderbufferEXT_PACKED *packed_data = malloc(sizeof(glMultiTexRenderbufferEXT_PACKED)); \
    packed_data->index = glMultiTexRenderbufferEXT_INDEX; \
    packed_data->args.texunit = (GLenum)_texunit; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.renderbuffer = (GLuint)_renderbuffer; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiTexRenderbufferEXT(packed, ret_v) do { \
    PACKED_glMultiTexRenderbufferEXT *unpacked = (PACKED_glMultiTexRenderbufferEXT *)packed; \
    ARGS_glMultiTexRenderbufferEXT *args = (ARGS_glMultiTexRenderbufferEXT *)&unpacked->args; \
    glMultiTexRenderbufferEXT(args->texunit, args->target, args->renderbuffer);; \
} while(0)
void glMultiTexRenderbufferEXT(glMultiTexRenderbufferEXT_ARG_EXPAND);
typedef void (*glMultiTexRenderbufferEXT_PTR)(glMultiTexRenderbufferEXT_ARG_EXPAND);
#define glMultiTexSubImage1DEXT_INDEX 1426
#define glMultiTexSubImage1DEXT_RETURN void
#define glMultiTexSubImage1DEXT_ARG_NAMES texunit, target, level, xoffset, width, format, type, pixels
#define glMultiTexSubImage1DEXT_ARG_EXPAND GLenum texunit, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid * pixels
#define glMultiTexSubImage1DEXT_PACKED PACKED_glMultiTexSubImage1DEXT
#define glMultiTexSubImage1DEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiTexSubImage1DEXT_NOT_VOID_WRAP(...) {}
#define pack_glMultiTexSubImage1DEXT(_texunit, _target, _level, _xoffset, _width, _format, _type, _pixels) ({ \
    glMultiTexSubImage1DEXT_PACKED *packed_data = malloc(sizeof(glMultiTexSubImage1DEXT_PACKED)); \
    packed_data->index = glMultiTexSubImage1DEXT_INDEX; \
    packed_data->args.texunit = (GLenum)_texunit; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.level = (GLint)_level; \
    packed_data->args.xoffset = (GLint)_xoffset; \
    packed_data->args.width = (GLsizei)_width; \
    packed_data->args.format = (GLenum)_format; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.pixels = (GLvoid *)_pixels; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiTexSubImage1DEXT(packed, ret_v) do { \
    PACKED_glMultiTexSubImage1DEXT *unpacked = (PACKED_glMultiTexSubImage1DEXT *)packed; \
    ARGS_glMultiTexSubImage1DEXT *args = (ARGS_glMultiTexSubImage1DEXT *)&unpacked->args; \
    glMultiTexSubImage1DEXT(args->texunit, args->target, args->level, args->xoffset, args->width, args->format, args->type, args->pixels);; \
} while(0)
void glMultiTexSubImage1DEXT(glMultiTexSubImage1DEXT_ARG_EXPAND);
typedef void (*glMultiTexSubImage1DEXT_PTR)(glMultiTexSubImage1DEXT_ARG_EXPAND);
#define glMultiTexSubImage2DEXT_INDEX 1427
#define glMultiTexSubImage2DEXT_RETURN void
#define glMultiTexSubImage2DEXT_ARG_NAMES texunit, target, level, xoffset, yoffset, width, height, format, type, pixels
#define glMultiTexSubImage2DEXT_ARG_EXPAND GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid * pixels
#define glMultiTexSubImage2DEXT_PACKED PACKED_glMultiTexSubImage2DEXT
#define glMultiTexSubImage2DEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiTexSubImage2DEXT_NOT_VOID_WRAP(...) {}
#define pack_glMultiTexSubImage2DEXT(_texunit, _target, _level, _xoffset, _yoffset, _width, _height, _format, _type, _pixels) ({ \
    glMultiTexSubImage2DEXT_PACKED *packed_data = malloc(sizeof(glMultiTexSubImage2DEXT_PACKED)); \
    packed_data->index = glMultiTexSubImage2DEXT_INDEX; \
    packed_data->args.texunit = (GLenum)_texunit; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.level = (GLint)_level; \
    packed_data->args.xoffset = (GLint)_xoffset; \
    packed_data->args.yoffset = (GLint)_yoffset; \
    packed_data->args.width = (GLsizei)_width; \
    packed_data->args.height = (GLsizei)_height; \
    packed_data->args.format = (GLenum)_format; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.pixels = (GLvoid *)_pixels; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiTexSubImage2DEXT(packed, ret_v) do { \
    PACKED_glMultiTexSubImage2DEXT *unpacked = (PACKED_glMultiTexSubImage2DEXT *)packed; \
    ARGS_glMultiTexSubImage2DEXT *args = (ARGS_glMultiTexSubImage2DEXT *)&unpacked->args; \
    glMultiTexSubImage2DEXT(args->texunit, args->target, args->level, args->xoffset, args->yoffset, args->width, args->height, args->format, args->type, args->pixels);; \
} while(0)
void glMultiTexSubImage2DEXT(glMultiTexSubImage2DEXT_ARG_EXPAND);
typedef void (*glMultiTexSubImage2DEXT_PTR)(glMultiTexSubImage2DEXT_ARG_EXPAND);
#define glMultiTexSubImage3DEXT_INDEX 1428
#define glMultiTexSubImage3DEXT_RETURN void
#define glMultiTexSubImage3DEXT_ARG_NAMES texunit, target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels
#define glMultiTexSubImage3DEXT_ARG_EXPAND GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid * pixels
#define glMultiTexSubImage3DEXT_PACKED PACKED_glMultiTexSubImage3DEXT
#define glMultiTexSubImage3DEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glMultiTexSubImage3DEXT_NOT_VOID_WRAP(...) {}
#define pack_glMultiTexSubImage3DEXT(_texunit, _target, _level, _xoffset, _yoffset, _zoffset, _width, _height, _depth, _format, _type, _pixels) ({ \
    glMultiTexSubImage3DEXT_PACKED *packed_data = malloc(sizeof(glMultiTexSubImage3DEXT_PACKED)); \
    packed_data->index = glMultiTexSubImage3DEXT_INDEX; \
    packed_data->args.texunit = (GLenum)_texunit; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.level = (GLint)_level; \
    packed_data->args.xoffset = (GLint)_xoffset; \
    packed_data->args.yoffset = (GLint)_yoffset; \
    packed_data->args.zoffset = (GLint)_zoffset; \
    packed_data->args.width = (GLsizei)_width; \
    packed_data->args.height = (GLsizei)_height; \
    packed_data->args.depth = (GLsizei)_depth; \
    packed_data->args.format = (GLenum)_format; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.pixels = (GLvoid *)_pixels; \
    (packed_call_t *)packed_data; \
})
#define call_glMultiTexSubImage3DEXT(packed, ret_v) do { \
    PACKED_glMultiTexSubImage3DEXT *unpacked = (PACKED_glMultiTexSubImage3DEXT *)packed; \
    ARGS_glMultiTexSubImage3DEXT *args = (ARGS_glMultiTexSubImage3DEXT *)&unpacked->args; \
    glMultiTexSubImage3DEXT(args->texunit, args->target, args->level, args->xoffset, args->yoffset, args->zoffset, args->width, args->height, args->depth, args->format, args->type, args->pixels);; \
} while(0)
void glMultiTexSubImage3DEXT(glMultiTexSubImage3DEXT_ARG_EXPAND);
typedef void (*glMultiTexSubImage3DEXT_PTR)(glMultiTexSubImage3DEXT_ARG_EXPAND);
#define glNamedBufferDataEXT_INDEX 1429
#define glNamedBufferDataEXT_RETURN void
#define glNamedBufferDataEXT_ARG_NAMES buffer, size, data, usage
#define glNamedBufferDataEXT_ARG_EXPAND GLuint buffer, GLsizeiptr size, const GLvoid * data, GLenum usage
#define glNamedBufferDataEXT_PACKED PACKED_glNamedBufferDataEXT
#define glNamedBufferDataEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glNamedBufferDataEXT_NOT_VOID_WRAP(...) {}
#define pack_glNamedBufferDataEXT(_buffer, _size, _data, _usage) ({ \
    glNamedBufferDataEXT_PACKED *packed_data = malloc(sizeof(glNamedBufferDataEXT_PACKED)); \
    packed_data->index = glNamedBufferDataEXT_INDEX; \
    packed_data->args.buffer = (GLuint)_buffer; \
    packed_data->args.size = (GLsizeiptr)_size; \
    packed_data->args.data = (GLvoid *)_data; \
    packed_data->args.usage = (GLenum)_usage; \
    (packed_call_t *)packed_data; \
})
#define call_glNamedBufferDataEXT(packed, ret_v) do { \
    PACKED_glNamedBufferDataEXT *unpacked = (PACKED_glNamedBufferDataEXT *)packed; \
    ARGS_glNamedBufferDataEXT *args = (ARGS_glNamedBufferDataEXT *)&unpacked->args; \
    glNamedBufferDataEXT(args->buffer, args->size, args->data, args->usage);; \
} while(0)
void glNamedBufferDataEXT(glNamedBufferDataEXT_ARG_EXPAND);
typedef void (*glNamedBufferDataEXT_PTR)(glNamedBufferDataEXT_ARG_EXPAND);
#define glNamedBufferSubDataEXT_INDEX 1430
#define glNamedBufferSubDataEXT_RETURN void
#define glNamedBufferSubDataEXT_ARG_NAMES buffer, offset, size, data
#define glNamedBufferSubDataEXT_ARG_EXPAND GLuint buffer, GLintptr offset, GLsizeiptr size, const GLvoid * data
#define glNamedBufferSubDataEXT_PACKED PACKED_glNamedBufferSubDataEXT
#define glNamedBufferSubDataEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glNamedBufferSubDataEXT_NOT_VOID_WRAP(...) {}
#define pack_glNamedBufferSubDataEXT(_buffer, _offset, _size, _data) ({ \
    glNamedBufferSubDataEXT_PACKED *packed_data = malloc(sizeof(glNamedBufferSubDataEXT_PACKED)); \
    packed_data->index = glNamedBufferSubDataEXT_INDEX; \
    packed_data->args.buffer = (GLuint)_buffer; \
    packed_data->args.offset = (GLintptr)_offset; \
    packed_data->args.size = (GLsizeiptr)_size; \
    packed_data->args.data = (GLvoid *)_data; \
    (packed_call_t *)packed_data; \
})
#define call_glNamedBufferSubDataEXT(packed, ret_v) do { \
    PACKED_glNamedBufferSubDataEXT *unpacked = (PACKED_glNamedBufferSubDataEXT *)packed; \
    ARGS_glNamedBufferSubDataEXT *args = (ARGS_glNamedBufferSubDataEXT *)&unpacked->args; \
    glNamedBufferSubDataEXT(args->buffer, args->offset, args->size, args->data);; \
} while(0)
void glNamedBufferSubDataEXT(glNamedBufferSubDataEXT_ARG_EXPAND);
typedef void (*glNamedBufferSubDataEXT_PTR)(glNamedBufferSubDataEXT_ARG_EXPAND);
#define glNamedCopyBufferSubDataEXT_INDEX 1431
#define glNamedCopyBufferSubDataEXT_RETURN void
#define glNamedCopyBufferSubDataEXT_ARG_NAMES readBuffer, writeBuffer, readOffset, writeOffset, size
#define glNamedCopyBufferSubDataEXT_ARG_EXPAND GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size
#define glNamedCopyBufferSubDataEXT_PACKED PACKED_glNamedCopyBufferSubDataEXT
#define glNamedCopyBufferSubDataEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glNamedCopyBufferSubDataEXT_NOT_VOID_WRAP(...) {}
#define pack_glNamedCopyBufferSubDataEXT(_readBuffer, _writeBuffer, _readOffset, _writeOffset, _size) ({ \
    glNamedCopyBufferSubDataEXT_PACKED *packed_data = malloc(sizeof(glNamedCopyBufferSubDataEXT_PACKED)); \
    packed_data->index = glNamedCopyBufferSubDataEXT_INDEX; \
    packed_data->args.readBuffer = (GLuint)_readBuffer; \
    packed_data->args.writeBuffer = (GLuint)_writeBuffer; \
    packed_data->args.readOffset = (GLintptr)_readOffset; \
    packed_data->args.writeOffset = (GLintptr)_writeOffset; \
    packed_data->args.size = (GLsizeiptr)_size; \
    (packed_call_t *)packed_data; \
})
#define call_glNamedCopyBufferSubDataEXT(packed, ret_v) do { \
    PACKED_glNamedCopyBufferSubDataEXT *unpacked = (PACKED_glNamedCopyBufferSubDataEXT *)packed; \
    ARGS_glNamedCopyBufferSubDataEXT *args = (ARGS_glNamedCopyBufferSubDataEXT *)&unpacked->args; \
    glNamedCopyBufferSubDataEXT(args->readBuffer, args->writeBuffer, args->readOffset, args->writeOffset, args->size);; \
} while(0)
void glNamedCopyBufferSubDataEXT(glNamedCopyBufferSubDataEXT_ARG_EXPAND);
typedef void (*glNamedCopyBufferSubDataEXT_PTR)(glNamedCopyBufferSubDataEXT_ARG_EXPAND);
#define glNamedFramebufferParameteriEXT_INDEX 1432
#define glNamedFramebufferParameteriEXT_RETURN void
#define glNamedFramebufferParameteriEXT_ARG_NAMES framebuffer, pname, param
#define glNamedFramebufferParameteriEXT_ARG_EXPAND GLuint framebuffer, GLenum pname, GLint param
#define glNamedFramebufferParameteriEXT_PACKED PACKED_glNamedFramebufferParameteriEXT
#define glNamedFramebufferParameteriEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glNamedFramebufferParameteriEXT_NOT_VOID_WRAP(...) {}
#define pack_glNamedFramebufferParameteriEXT(_framebuffer, _pname, _param) ({ \
    glNamedFramebufferParameteriEXT_PACKED *packed_data = malloc(sizeof(glNamedFramebufferParameteriEXT_PACKED)); \
    packed_data->index = glNamedFramebufferParameteriEXT_INDEX; \
    packed_data->args.framebuffer = (GLuint)_framebuffer; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.param = (GLint)_param; \
    (packed_call_t *)packed_data; \
})
#define call_glNamedFramebufferParameteriEXT(packed, ret_v) do { \
    PACKED_glNamedFramebufferParameteriEXT *unpacked = (PACKED_glNamedFramebufferParameteriEXT *)packed; \
    ARGS_glNamedFramebufferParameteriEXT *args = (ARGS_glNamedFramebufferParameteriEXT *)&unpacked->args; \
    glNamedFramebufferParameteriEXT(args->framebuffer, args->pname, args->param);; \
} while(0)
void glNamedFramebufferParameteriEXT(glNamedFramebufferParameteriEXT_ARG_EXPAND);
typedef void (*glNamedFramebufferParameteriEXT_PTR)(glNamedFramebufferParameteriEXT_ARG_EXPAND);
#define glNamedFramebufferRenderbufferEXT_INDEX 1433
#define glNamedFramebufferRenderbufferEXT_RETURN void
#define glNamedFramebufferRenderbufferEXT_ARG_NAMES framebuffer, attachment, renderbuffertarget, renderbuffer
#define glNamedFramebufferRenderbufferEXT_ARG_EXPAND GLuint framebuffer, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer
#define glNamedFramebufferRenderbufferEXT_PACKED PACKED_glNamedFramebufferRenderbufferEXT
#define glNamedFramebufferRenderbufferEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glNamedFramebufferRenderbufferEXT_NOT_VOID_WRAP(...) {}
#define pack_glNamedFramebufferRenderbufferEXT(_framebuffer, _attachment, _renderbuffertarget, _renderbuffer) ({ \
    glNamedFramebufferRenderbufferEXT_PACKED *packed_data = malloc(sizeof(glNamedFramebufferRenderbufferEXT_PACKED)); \
    packed_data->index = glNamedFramebufferRenderbufferEXT_INDEX; \
    packed_data->args.framebuffer = (GLuint)_framebuffer; \
    packed_data->args.attachment = (GLenum)_attachment; \
    packed_data->args.renderbuffertarget = (GLenum)_renderbuffertarget; \
    packed_data->args.renderbuffer = (GLuint)_renderbuffer; \
    (packed_call_t *)packed_data; \
})
#define call_glNamedFramebufferRenderbufferEXT(packed, ret_v) do { \
    PACKED_glNamedFramebufferRenderbufferEXT *unpacked = (PACKED_glNamedFramebufferRenderbufferEXT *)packed; \
    ARGS_glNamedFramebufferRenderbufferEXT *args = (ARGS_glNamedFramebufferRenderbufferEXT *)&unpacked->args; \
    glNamedFramebufferRenderbufferEXT(args->framebuffer, args->attachment, args->renderbuffertarget, args->renderbuffer);; \
} while(0)
void glNamedFramebufferRenderbufferEXT(glNamedFramebufferRenderbufferEXT_ARG_EXPAND);
typedef void (*glNamedFramebufferRenderbufferEXT_PTR)(glNamedFramebufferRenderbufferEXT_ARG_EXPAND);
#define glNamedFramebufferTexture1DEXT_INDEX 1434
#define glNamedFramebufferTexture1DEXT_RETURN void
#define glNamedFramebufferTexture1DEXT_ARG_NAMES framebuffer, attachment, textarget, texture, level
#define glNamedFramebufferTexture1DEXT_ARG_EXPAND GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level
#define glNamedFramebufferTexture1DEXT_PACKED PACKED_glNamedFramebufferTexture1DEXT
#define glNamedFramebufferTexture1DEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glNamedFramebufferTexture1DEXT_NOT_VOID_WRAP(...) {}
#define pack_glNamedFramebufferTexture1DEXT(_framebuffer, _attachment, _textarget, _texture, _level) ({ \
    glNamedFramebufferTexture1DEXT_PACKED *packed_data = malloc(sizeof(glNamedFramebufferTexture1DEXT_PACKED)); \
    packed_data->index = glNamedFramebufferTexture1DEXT_INDEX; \
    packed_data->args.framebuffer = (GLuint)_framebuffer; \
    packed_data->args.attachment = (GLenum)_attachment; \
    packed_data->args.textarget = (GLenum)_textarget; \
    packed_data->args.texture = (GLuint)_texture; \
    packed_data->args.level = (GLint)_level; \
    (packed_call_t *)packed_data; \
})
#define call_glNamedFramebufferTexture1DEXT(packed, ret_v) do { \
    PACKED_glNamedFramebufferTexture1DEXT *unpacked = (PACKED_glNamedFramebufferTexture1DEXT *)packed; \
    ARGS_glNamedFramebufferTexture1DEXT *args = (ARGS_glNamedFramebufferTexture1DEXT *)&unpacked->args; \
    glNamedFramebufferTexture1DEXT(args->framebuffer, args->attachment, args->textarget, args->texture, args->level);; \
} while(0)
void glNamedFramebufferTexture1DEXT(glNamedFramebufferTexture1DEXT_ARG_EXPAND);
typedef void (*glNamedFramebufferTexture1DEXT_PTR)(glNamedFramebufferTexture1DEXT_ARG_EXPAND);
#define glNamedFramebufferTexture2DEXT_INDEX 1435
#define glNamedFramebufferTexture2DEXT_RETURN void
#define glNamedFramebufferTexture2DEXT_ARG_NAMES framebuffer, attachment, textarget, texture, level
#define glNamedFramebufferTexture2DEXT_ARG_EXPAND GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level
#define glNamedFramebufferTexture2DEXT_PACKED PACKED_glNamedFramebufferTexture2DEXT
#define glNamedFramebufferTexture2DEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glNamedFramebufferTexture2DEXT_NOT_VOID_WRAP(...) {}
#define pack_glNamedFramebufferTexture2DEXT(_framebuffer, _attachment, _textarget, _texture, _level) ({ \
    glNamedFramebufferTexture2DEXT_PACKED *packed_data = malloc(sizeof(glNamedFramebufferTexture2DEXT_PACKED)); \
    packed_data->index = glNamedFramebufferTexture2DEXT_INDEX; \
    packed_data->args.framebuffer = (GLuint)_framebuffer; \
    packed_data->args.attachment = (GLenum)_attachment; \
    packed_data->args.textarget = (GLenum)_textarget; \
    packed_data->args.texture = (GLuint)_texture; \
    packed_data->args.level = (GLint)_level; \
    (packed_call_t *)packed_data; \
})
#define call_glNamedFramebufferTexture2DEXT(packed, ret_v) do { \
    PACKED_glNamedFramebufferTexture2DEXT *unpacked = (PACKED_glNamedFramebufferTexture2DEXT *)packed; \
    ARGS_glNamedFramebufferTexture2DEXT *args = (ARGS_glNamedFramebufferTexture2DEXT *)&unpacked->args; \
    glNamedFramebufferTexture2DEXT(args->framebuffer, args->attachment, args->textarget, args->texture, args->level);; \
} while(0)
void glNamedFramebufferTexture2DEXT(glNamedFramebufferTexture2DEXT_ARG_EXPAND);
typedef void (*glNamedFramebufferTexture2DEXT_PTR)(glNamedFramebufferTexture2DEXT_ARG_EXPAND);
#define glNamedFramebufferTexture3DEXT_INDEX 1436
#define glNamedFramebufferTexture3DEXT_RETURN void
#define glNamedFramebufferTexture3DEXT_ARG_NAMES framebuffer, attachment, textarget, texture, level, zoffset
#define glNamedFramebufferTexture3DEXT_ARG_EXPAND GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset
#define glNamedFramebufferTexture3DEXT_PACKED PACKED_glNamedFramebufferTexture3DEXT
#define glNamedFramebufferTexture3DEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glNamedFramebufferTexture3DEXT_NOT_VOID_WRAP(...) {}
#define pack_glNamedFramebufferTexture3DEXT(_framebuffer, _attachment, _textarget, _texture, _level, _zoffset) ({ \
    glNamedFramebufferTexture3DEXT_PACKED *packed_data = malloc(sizeof(glNamedFramebufferTexture3DEXT_PACKED)); \
    packed_data->index = glNamedFramebufferTexture3DEXT_INDEX; \
    packed_data->args.framebuffer = (GLuint)_framebuffer; \
    packed_data->args.attachment = (GLenum)_attachment; \
    packed_data->args.textarget = (GLenum)_textarget; \
    packed_data->args.texture = (GLuint)_texture; \
    packed_data->args.level = (GLint)_level; \
    packed_data->args.zoffset = (GLint)_zoffset; \
    (packed_call_t *)packed_data; \
})
#define call_glNamedFramebufferTexture3DEXT(packed, ret_v) do { \
    PACKED_glNamedFramebufferTexture3DEXT *unpacked = (PACKED_glNamedFramebufferTexture3DEXT *)packed; \
    ARGS_glNamedFramebufferTexture3DEXT *args = (ARGS_glNamedFramebufferTexture3DEXT *)&unpacked->args; \
    glNamedFramebufferTexture3DEXT(args->framebuffer, args->attachment, args->textarget, args->texture, args->level, args->zoffset);; \
} while(0)
void glNamedFramebufferTexture3DEXT(glNamedFramebufferTexture3DEXT_ARG_EXPAND);
typedef void (*glNamedFramebufferTexture3DEXT_PTR)(glNamedFramebufferTexture3DEXT_ARG_EXPAND);
#define glNamedFramebufferTextureEXT_INDEX 1437
#define glNamedFramebufferTextureEXT_RETURN void
#define glNamedFramebufferTextureEXT_ARG_NAMES framebuffer, attachment, texture, level
#define glNamedFramebufferTextureEXT_ARG_EXPAND GLuint framebuffer, GLenum attachment, GLuint texture, GLint level
#define glNamedFramebufferTextureEXT_PACKED PACKED_glNamedFramebufferTextureEXT
#define glNamedFramebufferTextureEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glNamedFramebufferTextureEXT_NOT_VOID_WRAP(...) {}
#define pack_glNamedFramebufferTextureEXT(_framebuffer, _attachment, _texture, _level) ({ \
    glNamedFramebufferTextureEXT_PACKED *packed_data = malloc(sizeof(glNamedFramebufferTextureEXT_PACKED)); \
    packed_data->index = glNamedFramebufferTextureEXT_INDEX; \
    packed_data->args.framebuffer = (GLuint)_framebuffer; \
    packed_data->args.attachment = (GLenum)_attachment; \
    packed_data->args.texture = (GLuint)_texture; \
    packed_data->args.level = (GLint)_level; \
    (packed_call_t *)packed_data; \
})
#define call_glNamedFramebufferTextureEXT(packed, ret_v) do { \
    PACKED_glNamedFramebufferTextureEXT *unpacked = (PACKED_glNamedFramebufferTextureEXT *)packed; \
    ARGS_glNamedFramebufferTextureEXT *args = (ARGS_glNamedFramebufferTextureEXT *)&unpacked->args; \
    glNamedFramebufferTextureEXT(args->framebuffer, args->attachment, args->texture, args->level);; \
} while(0)
void glNamedFramebufferTextureEXT(glNamedFramebufferTextureEXT_ARG_EXPAND);
typedef void (*glNamedFramebufferTextureEXT_PTR)(glNamedFramebufferTextureEXT_ARG_EXPAND);
#define glNamedFramebufferTextureFaceEXT_INDEX 1438
#define glNamedFramebufferTextureFaceEXT_RETURN void
#define glNamedFramebufferTextureFaceEXT_ARG_NAMES framebuffer, attachment, texture, level, face
#define glNamedFramebufferTextureFaceEXT_ARG_EXPAND GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLenum face
#define glNamedFramebufferTextureFaceEXT_PACKED PACKED_glNamedFramebufferTextureFaceEXT
#define glNamedFramebufferTextureFaceEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glNamedFramebufferTextureFaceEXT_NOT_VOID_WRAP(...) {}
#define pack_glNamedFramebufferTextureFaceEXT(_framebuffer, _attachment, _texture, _level, _face) ({ \
    glNamedFramebufferTextureFaceEXT_PACKED *packed_data = malloc(sizeof(glNamedFramebufferTextureFaceEXT_PACKED)); \
    packed_data->index = glNamedFramebufferTextureFaceEXT_INDEX; \
    packed_data->args.framebuffer = (GLuint)_framebuffer; \
    packed_data->args.attachment = (GLenum)_attachment; \
    packed_data->args.texture = (GLuint)_texture; \
    packed_data->args.level = (GLint)_level; \
    packed_data->args.face = (GLenum)_face; \
    (packed_call_t *)packed_data; \
})
#define call_glNamedFramebufferTextureFaceEXT(packed, ret_v) do { \
    PACKED_glNamedFramebufferTextureFaceEXT *unpacked = (PACKED_glNamedFramebufferTextureFaceEXT *)packed; \
    ARGS_glNamedFramebufferTextureFaceEXT *args = (ARGS_glNamedFramebufferTextureFaceEXT *)&unpacked->args; \
    glNamedFramebufferTextureFaceEXT(args->framebuffer, args->attachment, args->texture, args->level, args->face);; \
} while(0)
void glNamedFramebufferTextureFaceEXT(glNamedFramebufferTextureFaceEXT_ARG_EXPAND);
typedef void (*glNamedFramebufferTextureFaceEXT_PTR)(glNamedFramebufferTextureFaceEXT_ARG_EXPAND);
#define glNamedFramebufferTextureLayerEXT_INDEX 1439
#define glNamedFramebufferTextureLayerEXT_RETURN void
#define glNamedFramebufferTextureLayerEXT_ARG_NAMES framebuffer, attachment, texture, level, layer
#define glNamedFramebufferTextureLayerEXT_ARG_EXPAND GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLint layer
#define glNamedFramebufferTextureLayerEXT_PACKED PACKED_glNamedFramebufferTextureLayerEXT
#define glNamedFramebufferTextureLayerEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glNamedFramebufferTextureLayerEXT_NOT_VOID_WRAP(...) {}
#define pack_glNamedFramebufferTextureLayerEXT(_framebuffer, _attachment, _texture, _level, _layer) ({ \
    glNamedFramebufferTextureLayerEXT_PACKED *packed_data = malloc(sizeof(glNamedFramebufferTextureLayerEXT_PACKED)); \
    packed_data->index = glNamedFramebufferTextureLayerEXT_INDEX; \
    packed_data->args.framebuffer = (GLuint)_framebuffer; \
    packed_data->args.attachment = (GLenum)_attachment; \
    packed_data->args.texture = (GLuint)_texture; \
    packed_data->args.level = (GLint)_level; \
    packed_data->args.layer = (GLint)_layer; \
    (packed_call_t *)packed_data; \
})
#define call_glNamedFramebufferTextureLayerEXT(packed, ret_v) do { \
    PACKED_glNamedFramebufferTextureLayerEXT *unpacked = (PACKED_glNamedFramebufferTextureLayerEXT *)packed; \
    ARGS_glNamedFramebufferTextureLayerEXT *args = (ARGS_glNamedFramebufferTextureLayerEXT *)&unpacked->args; \
    glNamedFramebufferTextureLayerEXT(args->framebuffer, args->attachment, args->texture, args->level, args->layer);; \
} while(0)
void glNamedFramebufferTextureLayerEXT(glNamedFramebufferTextureLayerEXT_ARG_EXPAND);
typedef void (*glNamedFramebufferTextureLayerEXT_PTR)(glNamedFramebufferTextureLayerEXT_ARG_EXPAND);
#define glNamedProgramLocalParameter4dEXT_INDEX 1440
#define glNamedProgramLocalParameter4dEXT_RETURN void
#define glNamedProgramLocalParameter4dEXT_ARG_NAMES program, target, index, x, y, z, w
#define glNamedProgramLocalParameter4dEXT_ARG_EXPAND GLuint program, GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w
#define glNamedProgramLocalParameter4dEXT_PACKED PACKED_glNamedProgramLocalParameter4dEXT
#define glNamedProgramLocalParameter4dEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glNamedProgramLocalParameter4dEXT_NOT_VOID_WRAP(...) {}
#define pack_glNamedProgramLocalParameter4dEXT(_program, _target, _index, _x, _y, _z, _w) ({ \
    glNamedProgramLocalParameter4dEXT_PACKED *packed_data = malloc(sizeof(glNamedProgramLocalParameter4dEXT_PACKED)); \
    packed_data->index = glNamedProgramLocalParameter4dEXT_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.x = (GLdouble)_x; \
    packed_data->args.y = (GLdouble)_y; \
    packed_data->args.z = (GLdouble)_z; \
    packed_data->args.w = (GLdouble)_w; \
    (packed_call_t *)packed_data; \
})
#define call_glNamedProgramLocalParameter4dEXT(packed, ret_v) do { \
    PACKED_glNamedProgramLocalParameter4dEXT *unpacked = (PACKED_glNamedProgramLocalParameter4dEXT *)packed; \
    ARGS_glNamedProgramLocalParameter4dEXT *args = (ARGS_glNamedProgramLocalParameter4dEXT *)&unpacked->args; \
    glNamedProgramLocalParameter4dEXT(args->program, args->target, args->index, args->x, args->y, args->z, args->w);; \
} while(0)
void glNamedProgramLocalParameter4dEXT(glNamedProgramLocalParameter4dEXT_ARG_EXPAND);
typedef void (*glNamedProgramLocalParameter4dEXT_PTR)(glNamedProgramLocalParameter4dEXT_ARG_EXPAND);
#define glNamedProgramLocalParameter4dvEXT_INDEX 1441
#define glNamedProgramLocalParameter4dvEXT_RETURN void
#define glNamedProgramLocalParameter4dvEXT_ARG_NAMES program, target, index, params
#define glNamedProgramLocalParameter4dvEXT_ARG_EXPAND GLuint program, GLenum target, GLuint index, const GLdouble * params
#define glNamedProgramLocalParameter4dvEXT_PACKED PACKED_glNamedProgramLocalParameter4dvEXT
#define glNamedProgramLocalParameter4dvEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glNamedProgramLocalParameter4dvEXT_NOT_VOID_WRAP(...) {}
#define pack_glNamedProgramLocalParameter4dvEXT(_program, _target, _index, _params) ({ \
    glNamedProgramLocalParameter4dvEXT_PACKED *packed_data = malloc(sizeof(glNamedProgramLocalParameter4dvEXT_PACKED)); \
    packed_data->index = glNamedProgramLocalParameter4dvEXT_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.params = (GLdouble *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glNamedProgramLocalParameter4dvEXT(packed, ret_v) do { \
    PACKED_glNamedProgramLocalParameter4dvEXT *unpacked = (PACKED_glNamedProgramLocalParameter4dvEXT *)packed; \
    ARGS_glNamedProgramLocalParameter4dvEXT *args = (ARGS_glNamedProgramLocalParameter4dvEXT *)&unpacked->args; \
    glNamedProgramLocalParameter4dvEXT(args->program, args->target, args->index, args->params);; \
} while(0)
void glNamedProgramLocalParameter4dvEXT(glNamedProgramLocalParameter4dvEXT_ARG_EXPAND);
typedef void (*glNamedProgramLocalParameter4dvEXT_PTR)(glNamedProgramLocalParameter4dvEXT_ARG_EXPAND);
#define glNamedProgramLocalParameter4fEXT_INDEX 1442
#define glNamedProgramLocalParameter4fEXT_RETURN void
#define glNamedProgramLocalParameter4fEXT_ARG_NAMES program, target, index, x, y, z, w
#define glNamedProgramLocalParameter4fEXT_ARG_EXPAND GLuint program, GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w
#define glNamedProgramLocalParameter4fEXT_PACKED PACKED_glNamedProgramLocalParameter4fEXT
#define glNamedProgramLocalParameter4fEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glNamedProgramLocalParameter4fEXT_NOT_VOID_WRAP(...) {}
#define pack_glNamedProgramLocalParameter4fEXT(_program, _target, _index, _x, _y, _z, _w) ({ \
    glNamedProgramLocalParameter4fEXT_PACKED *packed_data = malloc(sizeof(glNamedProgramLocalParameter4fEXT_PACKED)); \
    packed_data->index = glNamedProgramLocalParameter4fEXT_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.x = (GLfloat)_x; \
    packed_data->args.y = (GLfloat)_y; \
    packed_data->args.z = (GLfloat)_z; \
    packed_data->args.w = (GLfloat)_w; \
    (packed_call_t *)packed_data; \
})
#define call_glNamedProgramLocalParameter4fEXT(packed, ret_v) do { \
    PACKED_glNamedProgramLocalParameter4fEXT *unpacked = (PACKED_glNamedProgramLocalParameter4fEXT *)packed; \
    ARGS_glNamedProgramLocalParameter4fEXT *args = (ARGS_glNamedProgramLocalParameter4fEXT *)&unpacked->args; \
    glNamedProgramLocalParameter4fEXT(args->program, args->target, args->index, args->x, args->y, args->z, args->w);; \
} while(0)
void glNamedProgramLocalParameter4fEXT(glNamedProgramLocalParameter4fEXT_ARG_EXPAND);
typedef void (*glNamedProgramLocalParameter4fEXT_PTR)(glNamedProgramLocalParameter4fEXT_ARG_EXPAND);
#define glNamedProgramLocalParameter4fvEXT_INDEX 1443
#define glNamedProgramLocalParameter4fvEXT_RETURN void
#define glNamedProgramLocalParameter4fvEXT_ARG_NAMES program, target, index, params
#define glNamedProgramLocalParameter4fvEXT_ARG_EXPAND GLuint program, GLenum target, GLuint index, const GLfloat * params
#define glNamedProgramLocalParameter4fvEXT_PACKED PACKED_glNamedProgramLocalParameter4fvEXT
#define glNamedProgramLocalParameter4fvEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glNamedProgramLocalParameter4fvEXT_NOT_VOID_WRAP(...) {}
#define pack_glNamedProgramLocalParameter4fvEXT(_program, _target, _index, _params) ({ \
    glNamedProgramLocalParameter4fvEXT_PACKED *packed_data = malloc(sizeof(glNamedProgramLocalParameter4fvEXT_PACKED)); \
    packed_data->index = glNamedProgramLocalParameter4fvEXT_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.params = (GLfloat *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glNamedProgramLocalParameter4fvEXT(packed, ret_v) do { \
    PACKED_glNamedProgramLocalParameter4fvEXT *unpacked = (PACKED_glNamedProgramLocalParameter4fvEXT *)packed; \
    ARGS_glNamedProgramLocalParameter4fvEXT *args = (ARGS_glNamedProgramLocalParameter4fvEXT *)&unpacked->args; \
    glNamedProgramLocalParameter4fvEXT(args->program, args->target, args->index, args->params);; \
} while(0)
void glNamedProgramLocalParameter4fvEXT(glNamedProgramLocalParameter4fvEXT_ARG_EXPAND);
typedef void (*glNamedProgramLocalParameter4fvEXT_PTR)(glNamedProgramLocalParameter4fvEXT_ARG_EXPAND);
#define glNamedProgramLocalParameterI4iEXT_INDEX 1444
#define glNamedProgramLocalParameterI4iEXT_RETURN void
#define glNamedProgramLocalParameterI4iEXT_ARG_NAMES program, target, index, x, y, z, w
#define glNamedProgramLocalParameterI4iEXT_ARG_EXPAND GLuint program, GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w
#define glNamedProgramLocalParameterI4iEXT_PACKED PACKED_glNamedProgramLocalParameterI4iEXT
#define glNamedProgramLocalParameterI4iEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glNamedProgramLocalParameterI4iEXT_NOT_VOID_WRAP(...) {}
#define pack_glNamedProgramLocalParameterI4iEXT(_program, _target, _index, _x, _y, _z, _w) ({ \
    glNamedProgramLocalParameterI4iEXT_PACKED *packed_data = malloc(sizeof(glNamedProgramLocalParameterI4iEXT_PACKED)); \
    packed_data->index = glNamedProgramLocalParameterI4iEXT_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.x = (GLint)_x; \
    packed_data->args.y = (GLint)_y; \
    packed_data->args.z = (GLint)_z; \
    packed_data->args.w = (GLint)_w; \
    (packed_call_t *)packed_data; \
})
#define call_glNamedProgramLocalParameterI4iEXT(packed, ret_v) do { \
    PACKED_glNamedProgramLocalParameterI4iEXT *unpacked = (PACKED_glNamedProgramLocalParameterI4iEXT *)packed; \
    ARGS_glNamedProgramLocalParameterI4iEXT *args = (ARGS_glNamedProgramLocalParameterI4iEXT *)&unpacked->args; \
    glNamedProgramLocalParameterI4iEXT(args->program, args->target, args->index, args->x, args->y, args->z, args->w);; \
} while(0)
void glNamedProgramLocalParameterI4iEXT(glNamedProgramLocalParameterI4iEXT_ARG_EXPAND);
typedef void (*glNamedProgramLocalParameterI4iEXT_PTR)(glNamedProgramLocalParameterI4iEXT_ARG_EXPAND);
#define glNamedProgramLocalParameterI4ivEXT_INDEX 1445
#define glNamedProgramLocalParameterI4ivEXT_RETURN void
#define glNamedProgramLocalParameterI4ivEXT_ARG_NAMES program, target, index, params
#define glNamedProgramLocalParameterI4ivEXT_ARG_EXPAND GLuint program, GLenum target, GLuint index, const GLint * params
#define glNamedProgramLocalParameterI4ivEXT_PACKED PACKED_glNamedProgramLocalParameterI4ivEXT
#define glNamedProgramLocalParameterI4ivEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glNamedProgramLocalParameterI4ivEXT_NOT_VOID_WRAP(...) {}
#define pack_glNamedProgramLocalParameterI4ivEXT(_program, _target, _index, _params) ({ \
    glNamedProgramLocalParameterI4ivEXT_PACKED *packed_data = malloc(sizeof(glNamedProgramLocalParameterI4ivEXT_PACKED)); \
    packed_data->index = glNamedProgramLocalParameterI4ivEXT_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.params = (GLint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glNamedProgramLocalParameterI4ivEXT(packed, ret_v) do { \
    PACKED_glNamedProgramLocalParameterI4ivEXT *unpacked = (PACKED_glNamedProgramLocalParameterI4ivEXT *)packed; \
    ARGS_glNamedProgramLocalParameterI4ivEXT *args = (ARGS_glNamedProgramLocalParameterI4ivEXT *)&unpacked->args; \
    glNamedProgramLocalParameterI4ivEXT(args->program, args->target, args->index, args->params);; \
} while(0)
void glNamedProgramLocalParameterI4ivEXT(glNamedProgramLocalParameterI4ivEXT_ARG_EXPAND);
typedef void (*glNamedProgramLocalParameterI4ivEXT_PTR)(glNamedProgramLocalParameterI4ivEXT_ARG_EXPAND);
#define glNamedProgramLocalParameterI4uiEXT_INDEX 1446
#define glNamedProgramLocalParameterI4uiEXT_RETURN void
#define glNamedProgramLocalParameterI4uiEXT_ARG_NAMES program, target, index, x, y, z, w
#define glNamedProgramLocalParameterI4uiEXT_ARG_EXPAND GLuint program, GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w
#define glNamedProgramLocalParameterI4uiEXT_PACKED PACKED_glNamedProgramLocalParameterI4uiEXT
#define glNamedProgramLocalParameterI4uiEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glNamedProgramLocalParameterI4uiEXT_NOT_VOID_WRAP(...) {}
#define pack_glNamedProgramLocalParameterI4uiEXT(_program, _target, _index, _x, _y, _z, _w) ({ \
    glNamedProgramLocalParameterI4uiEXT_PACKED *packed_data = malloc(sizeof(glNamedProgramLocalParameterI4uiEXT_PACKED)); \
    packed_data->index = glNamedProgramLocalParameterI4uiEXT_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.x = (GLuint)_x; \
    packed_data->args.y = (GLuint)_y; \
    packed_data->args.z = (GLuint)_z; \
    packed_data->args.w = (GLuint)_w; \
    (packed_call_t *)packed_data; \
})
#define call_glNamedProgramLocalParameterI4uiEXT(packed, ret_v) do { \
    PACKED_glNamedProgramLocalParameterI4uiEXT *unpacked = (PACKED_glNamedProgramLocalParameterI4uiEXT *)packed; \
    ARGS_glNamedProgramLocalParameterI4uiEXT *args = (ARGS_glNamedProgramLocalParameterI4uiEXT *)&unpacked->args; \
    glNamedProgramLocalParameterI4uiEXT(args->program, args->target, args->index, args->x, args->y, args->z, args->w);; \
} while(0)
void glNamedProgramLocalParameterI4uiEXT(glNamedProgramLocalParameterI4uiEXT_ARG_EXPAND);
typedef void (*glNamedProgramLocalParameterI4uiEXT_PTR)(glNamedProgramLocalParameterI4uiEXT_ARG_EXPAND);
#define glNamedProgramLocalParameterI4uivEXT_INDEX 1447
#define glNamedProgramLocalParameterI4uivEXT_RETURN void
#define glNamedProgramLocalParameterI4uivEXT_ARG_NAMES program, target, index, params
#define glNamedProgramLocalParameterI4uivEXT_ARG_EXPAND GLuint program, GLenum target, GLuint index, const GLuint * params
#define glNamedProgramLocalParameterI4uivEXT_PACKED PACKED_glNamedProgramLocalParameterI4uivEXT
#define glNamedProgramLocalParameterI4uivEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glNamedProgramLocalParameterI4uivEXT_NOT_VOID_WRAP(...) {}
#define pack_glNamedProgramLocalParameterI4uivEXT(_program, _target, _index, _params) ({ \
    glNamedProgramLocalParameterI4uivEXT_PACKED *packed_data = malloc(sizeof(glNamedProgramLocalParameterI4uivEXT_PACKED)); \
    packed_data->index = glNamedProgramLocalParameterI4uivEXT_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.params = (GLuint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glNamedProgramLocalParameterI4uivEXT(packed, ret_v) do { \
    PACKED_glNamedProgramLocalParameterI4uivEXT *unpacked = (PACKED_glNamedProgramLocalParameterI4uivEXT *)packed; \
    ARGS_glNamedProgramLocalParameterI4uivEXT *args = (ARGS_glNamedProgramLocalParameterI4uivEXT *)&unpacked->args; \
    glNamedProgramLocalParameterI4uivEXT(args->program, args->target, args->index, args->params);; \
} while(0)
void glNamedProgramLocalParameterI4uivEXT(glNamedProgramLocalParameterI4uivEXT_ARG_EXPAND);
typedef void (*glNamedProgramLocalParameterI4uivEXT_PTR)(glNamedProgramLocalParameterI4uivEXT_ARG_EXPAND);
#define glNamedProgramLocalParameters4fvEXT_INDEX 1448
#define glNamedProgramLocalParameters4fvEXT_RETURN void
#define glNamedProgramLocalParameters4fvEXT_ARG_NAMES program, target, index, count, params
#define glNamedProgramLocalParameters4fvEXT_ARG_EXPAND GLuint program, GLenum target, GLuint index, GLsizei count, const GLfloat * params
#define glNamedProgramLocalParameters4fvEXT_PACKED PACKED_glNamedProgramLocalParameters4fvEXT
#define glNamedProgramLocalParameters4fvEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glNamedProgramLocalParameters4fvEXT_NOT_VOID_WRAP(...) {}
#define pack_glNamedProgramLocalParameters4fvEXT(_program, _target, _index, _count, _params) ({ \
    glNamedProgramLocalParameters4fvEXT_PACKED *packed_data = malloc(sizeof(glNamedProgramLocalParameters4fvEXT_PACKED)); \
    packed_data->index = glNamedProgramLocalParameters4fvEXT_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.params = (GLfloat *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glNamedProgramLocalParameters4fvEXT(packed, ret_v) do { \
    PACKED_glNamedProgramLocalParameters4fvEXT *unpacked = (PACKED_glNamedProgramLocalParameters4fvEXT *)packed; \
    ARGS_glNamedProgramLocalParameters4fvEXT *args = (ARGS_glNamedProgramLocalParameters4fvEXT *)&unpacked->args; \
    glNamedProgramLocalParameters4fvEXT(args->program, args->target, args->index, args->count, args->params);; \
} while(0)
void glNamedProgramLocalParameters4fvEXT(glNamedProgramLocalParameters4fvEXT_ARG_EXPAND);
typedef void (*glNamedProgramLocalParameters4fvEXT_PTR)(glNamedProgramLocalParameters4fvEXT_ARG_EXPAND);
#define glNamedProgramLocalParametersI4ivEXT_INDEX 1449
#define glNamedProgramLocalParametersI4ivEXT_RETURN void
#define glNamedProgramLocalParametersI4ivEXT_ARG_NAMES program, target, index, count, params
#define glNamedProgramLocalParametersI4ivEXT_ARG_EXPAND GLuint program, GLenum target, GLuint index, GLsizei count, const GLint * params
#define glNamedProgramLocalParametersI4ivEXT_PACKED PACKED_glNamedProgramLocalParametersI4ivEXT
#define glNamedProgramLocalParametersI4ivEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glNamedProgramLocalParametersI4ivEXT_NOT_VOID_WRAP(...) {}
#define pack_glNamedProgramLocalParametersI4ivEXT(_program, _target, _index, _count, _params) ({ \
    glNamedProgramLocalParametersI4ivEXT_PACKED *packed_data = malloc(sizeof(glNamedProgramLocalParametersI4ivEXT_PACKED)); \
    packed_data->index = glNamedProgramLocalParametersI4ivEXT_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.params = (GLint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glNamedProgramLocalParametersI4ivEXT(packed, ret_v) do { \
    PACKED_glNamedProgramLocalParametersI4ivEXT *unpacked = (PACKED_glNamedProgramLocalParametersI4ivEXT *)packed; \
    ARGS_glNamedProgramLocalParametersI4ivEXT *args = (ARGS_glNamedProgramLocalParametersI4ivEXT *)&unpacked->args; \
    glNamedProgramLocalParametersI4ivEXT(args->program, args->target, args->index, args->count, args->params);; \
} while(0)
void glNamedProgramLocalParametersI4ivEXT(glNamedProgramLocalParametersI4ivEXT_ARG_EXPAND);
typedef void (*glNamedProgramLocalParametersI4ivEXT_PTR)(glNamedProgramLocalParametersI4ivEXT_ARG_EXPAND);
#define glNamedProgramLocalParametersI4uivEXT_INDEX 1450
#define glNamedProgramLocalParametersI4uivEXT_RETURN void
#define glNamedProgramLocalParametersI4uivEXT_ARG_NAMES program, target, index, count, params
#define glNamedProgramLocalParametersI4uivEXT_ARG_EXPAND GLuint program, GLenum target, GLuint index, GLsizei count, const GLuint * params
#define glNamedProgramLocalParametersI4uivEXT_PACKED PACKED_glNamedProgramLocalParametersI4uivEXT
#define glNamedProgramLocalParametersI4uivEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glNamedProgramLocalParametersI4uivEXT_NOT_VOID_WRAP(...) {}
#define pack_glNamedProgramLocalParametersI4uivEXT(_program, _target, _index, _count, _params) ({ \
    glNamedProgramLocalParametersI4uivEXT_PACKED *packed_data = malloc(sizeof(glNamedProgramLocalParametersI4uivEXT_PACKED)); \
    packed_data->index = glNamedProgramLocalParametersI4uivEXT_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.params = (GLuint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glNamedProgramLocalParametersI4uivEXT(packed, ret_v) do { \
    PACKED_glNamedProgramLocalParametersI4uivEXT *unpacked = (PACKED_glNamedProgramLocalParametersI4uivEXT *)packed; \
    ARGS_glNamedProgramLocalParametersI4uivEXT *args = (ARGS_glNamedProgramLocalParametersI4uivEXT *)&unpacked->args; \
    glNamedProgramLocalParametersI4uivEXT(args->program, args->target, args->index, args->count, args->params);; \
} while(0)
void glNamedProgramLocalParametersI4uivEXT(glNamedProgramLocalParametersI4uivEXT_ARG_EXPAND);
typedef void (*glNamedProgramLocalParametersI4uivEXT_PTR)(glNamedProgramLocalParametersI4uivEXT_ARG_EXPAND);
#define glNamedProgramStringEXT_INDEX 1451
#define glNamedProgramStringEXT_RETURN void
#define glNamedProgramStringEXT_ARG_NAMES program, target, format, len, string
#define glNamedProgramStringEXT_ARG_EXPAND GLuint program, GLenum target, GLenum format, GLsizei len, const GLvoid * string
#define glNamedProgramStringEXT_PACKED PACKED_glNamedProgramStringEXT
#define glNamedProgramStringEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glNamedProgramStringEXT_NOT_VOID_WRAP(...) {}
#define pack_glNamedProgramStringEXT(_program, _target, _format, _len, _string) ({ \
    glNamedProgramStringEXT_PACKED *packed_data = malloc(sizeof(glNamedProgramStringEXT_PACKED)); \
    packed_data->index = glNamedProgramStringEXT_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.format = (GLenum)_format; \
    packed_data->args.len = (GLsizei)_len; \
    packed_data->args.string = (GLvoid *)_string; \
    (packed_call_t *)packed_data; \
})
#define call_glNamedProgramStringEXT(packed, ret_v) do { \
    PACKED_glNamedProgramStringEXT *unpacked = (PACKED_glNamedProgramStringEXT *)packed; \
    ARGS_glNamedProgramStringEXT *args = (ARGS_glNamedProgramStringEXT *)&unpacked->args; \
    glNamedProgramStringEXT(args->program, args->target, args->format, args->len, args->string);; \
} while(0)
void glNamedProgramStringEXT(glNamedProgramStringEXT_ARG_EXPAND);
typedef void (*glNamedProgramStringEXT_PTR)(glNamedProgramStringEXT_ARG_EXPAND);
#define glNamedRenderbufferStorageEXT_INDEX 1452
#define glNamedRenderbufferStorageEXT_RETURN void
#define glNamedRenderbufferStorageEXT_ARG_NAMES renderbuffer, internalformat, width, height
#define glNamedRenderbufferStorageEXT_ARG_EXPAND GLuint renderbuffer, GLenum internalformat, GLsizei width, GLsizei height
#define glNamedRenderbufferStorageEXT_PACKED PACKED_glNamedRenderbufferStorageEXT
#define glNamedRenderbufferStorageEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glNamedRenderbufferStorageEXT_NOT_VOID_WRAP(...) {}
#define pack_glNamedRenderbufferStorageEXT(_renderbuffer, _internalformat, _width, _height) ({ \
    glNamedRenderbufferStorageEXT_PACKED *packed_data = malloc(sizeof(glNamedRenderbufferStorageEXT_PACKED)); \
    packed_data->index = glNamedRenderbufferStorageEXT_INDEX; \
    packed_data->args.renderbuffer = (GLuint)_renderbuffer; \
    packed_data->args.internalformat = (GLenum)_internalformat; \
    packed_data->args.width = (GLsizei)_width; \
    packed_data->args.height = (GLsizei)_height; \
    (packed_call_t *)packed_data; \
})
#define call_glNamedRenderbufferStorageEXT(packed, ret_v) do { \
    PACKED_glNamedRenderbufferStorageEXT *unpacked = (PACKED_glNamedRenderbufferStorageEXT *)packed; \
    ARGS_glNamedRenderbufferStorageEXT *args = (ARGS_glNamedRenderbufferStorageEXT *)&unpacked->args; \
    glNamedRenderbufferStorageEXT(args->renderbuffer, args->internalformat, args->width, args->height);; \
} while(0)
void glNamedRenderbufferStorageEXT(glNamedRenderbufferStorageEXT_ARG_EXPAND);
typedef void (*glNamedRenderbufferStorageEXT_PTR)(glNamedRenderbufferStorageEXT_ARG_EXPAND);
#define glNamedRenderbufferStorageMultisampleCoverageEXT_INDEX 1453
#define glNamedRenderbufferStorageMultisampleCoverageEXT_RETURN void
#define glNamedRenderbufferStorageMultisampleCoverageEXT_ARG_NAMES renderbuffer, coverageSamples, colorSamples, internalformat, width, height
#define glNamedRenderbufferStorageMultisampleCoverageEXT_ARG_EXPAND GLuint renderbuffer, GLsizei coverageSamples, GLsizei colorSamples, GLenum internalformat, GLsizei width, GLsizei height
#define glNamedRenderbufferStorageMultisampleCoverageEXT_PACKED PACKED_glNamedRenderbufferStorageMultisampleCoverageEXT
#define glNamedRenderbufferStorageMultisampleCoverageEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glNamedRenderbufferStorageMultisampleCoverageEXT_NOT_VOID_WRAP(...) {}
#define pack_glNamedRenderbufferStorageMultisampleCoverageEXT(_renderbuffer, _coverageSamples, _colorSamples, _internalformat, _width, _height) ({ \
    glNamedRenderbufferStorageMultisampleCoverageEXT_PACKED *packed_data = malloc(sizeof(glNamedRenderbufferStorageMultisampleCoverageEXT_PACKED)); \
    packed_data->index = glNamedRenderbufferStorageMultisampleCoverageEXT_INDEX; \
    packed_data->args.renderbuffer = (GLuint)_renderbuffer; \
    packed_data->args.coverageSamples = (GLsizei)_coverageSamples; \
    packed_data->args.colorSamples = (GLsizei)_colorSamples; \
    packed_data->args.internalformat = (GLenum)_internalformat; \
    packed_data->args.width = (GLsizei)_width; \
    packed_data->args.height = (GLsizei)_height; \
    (packed_call_t *)packed_data; \
})
#define call_glNamedRenderbufferStorageMultisampleCoverageEXT(packed, ret_v) do { \
    PACKED_glNamedRenderbufferStorageMultisampleCoverageEXT *unpacked = (PACKED_glNamedRenderbufferStorageMultisampleCoverageEXT *)packed; \
    ARGS_glNamedRenderbufferStorageMultisampleCoverageEXT *args = (ARGS_glNamedRenderbufferStorageMultisampleCoverageEXT *)&unpacked->args; \
    glNamedRenderbufferStorageMultisampleCoverageEXT(args->renderbuffer, args->coverageSamples, args->colorSamples, args->internalformat, args->width, args->height);; \
} while(0)
void glNamedRenderbufferStorageMultisampleCoverageEXT(glNamedRenderbufferStorageMultisampleCoverageEXT_ARG_EXPAND);
typedef void (*glNamedRenderbufferStorageMultisampleCoverageEXT_PTR)(glNamedRenderbufferStorageMultisampleCoverageEXT_ARG_EXPAND);
#define glNamedRenderbufferStorageMultisampleEXT_INDEX 1454
#define glNamedRenderbufferStorageMultisampleEXT_RETURN void
#define glNamedRenderbufferStorageMultisampleEXT_ARG_NAMES renderbuffer, samples, internalformat, width, height
#define glNamedRenderbufferStorageMultisampleEXT_ARG_EXPAND GLuint renderbuffer, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height
#define glNamedRenderbufferStorageMultisampleEXT_PACKED PACKED_glNamedRenderbufferStorageMultisampleEXT
#define glNamedRenderbufferStorageMultisampleEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glNamedRenderbufferStorageMultisampleEXT_NOT_VOID_WRAP(...) {}
#define pack_glNamedRenderbufferStorageMultisampleEXT(_renderbuffer, _samples, _internalformat, _width, _height) ({ \
    glNamedRenderbufferStorageMultisampleEXT_PACKED *packed_data = malloc(sizeof(glNamedRenderbufferStorageMultisampleEXT_PACKED)); \
    packed_data->index = glNamedRenderbufferStorageMultisampleEXT_INDEX; \
    packed_data->args.renderbuffer = (GLuint)_renderbuffer; \
    packed_data->args.samples = (GLsizei)_samples; \
    packed_data->args.internalformat = (GLenum)_internalformat; \
    packed_data->args.width = (GLsizei)_width; \
    packed_data->args.height = (GLsizei)_height; \
    (packed_call_t *)packed_data; \
})
#define call_glNamedRenderbufferStorageMultisampleEXT(packed, ret_v) do { \
    PACKED_glNamedRenderbufferStorageMultisampleEXT *unpacked = (PACKED_glNamedRenderbufferStorageMultisampleEXT *)packed; \
    ARGS_glNamedRenderbufferStorageMultisampleEXT *args = (ARGS_glNamedRenderbufferStorageMultisampleEXT *)&unpacked->args; \
    glNamedRenderbufferStorageMultisampleEXT(args->renderbuffer, args->samples, args->internalformat, args->width, args->height);; \
} while(0)
void glNamedRenderbufferStorageMultisampleEXT(glNamedRenderbufferStorageMultisampleEXT_ARG_EXPAND);
typedef void (*glNamedRenderbufferStorageMultisampleEXT_PTR)(glNamedRenderbufferStorageMultisampleEXT_ARG_EXPAND);
#define glNamedStringARB_INDEX 1455
#define glNamedStringARB_RETURN void
#define glNamedStringARB_ARG_NAMES type, namelen, name, stringlen, string
#define glNamedStringARB_ARG_EXPAND GLenum type, GLint namelen, const GLchar * name, GLint stringlen, const GLchar * string
#define glNamedStringARB_PACKED PACKED_glNamedStringARB
#define glNamedStringARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glNamedStringARB_NOT_VOID_WRAP(...) {}
#define pack_glNamedStringARB(_type, _namelen, _name, _stringlen, _string) ({ \
    glNamedStringARB_PACKED *packed_data = malloc(sizeof(glNamedStringARB_PACKED)); \
    packed_data->index = glNamedStringARB_INDEX; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.namelen = (GLint)_namelen; \
    packed_data->args.name = (GLchar *)_name; \
    packed_data->args.stringlen = (GLint)_stringlen; \
    packed_data->args.string = (GLchar *)_string; \
    (packed_call_t *)packed_data; \
})
#define call_glNamedStringARB(packed, ret_v) do { \
    PACKED_glNamedStringARB *unpacked = (PACKED_glNamedStringARB *)packed; \
    ARGS_glNamedStringARB *args = (ARGS_glNamedStringARB *)&unpacked->args; \
    glNamedStringARB(args->type, args->namelen, args->name, args->stringlen, args->string);; \
} while(0)
void glNamedStringARB(glNamedStringARB_ARG_EXPAND);
typedef void (*glNamedStringARB_PTR)(glNamedStringARB_ARG_EXPAND);
#define glNewList_INDEX 1456
#define glNewList_RETURN void
#define glNewList_ARG_NAMES list, mode
#define glNewList_ARG_EXPAND GLuint list, GLenum mode
#define glNewList_PACKED PACKED_glNewList
#define glNewList_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glNewList_NOT_VOID_WRAP(...) {}
#define pack_glNewList(_list, _mode) ({ \
    glNewList_PACKED *packed_data = malloc(sizeof(glNewList_PACKED)); \
    packed_data->index = glNewList_INDEX; \
    packed_data->args.list = (GLuint)_list; \
    packed_data->args.mode = (GLenum)_mode; \
    (packed_call_t *)packed_data; \
})
#define call_glNewList(packed, ret_v) do { \
    PACKED_glNewList *unpacked = (PACKED_glNewList *)packed; \
    ARGS_glNewList *args = (ARGS_glNewList *)&unpacked->args; \
    glNewList(args->list, args->mode);; \
} while(0)
void glNewList(glNewList_ARG_EXPAND);
typedef void (*glNewList_PTR)(glNewList_ARG_EXPAND);
#define glNewObjectBufferATI_INDEX 1457
#define glNewObjectBufferATI_RETURN GLuint
#define glNewObjectBufferATI_ARG_NAMES size, pointer, usage
#define glNewObjectBufferATI_ARG_EXPAND GLsizei size, const GLvoid * pointer, GLenum usage
#define glNewObjectBufferATI_PACKED PACKED_glNewObjectBufferATI
#define glNewObjectBufferATI_VOID_ONLY_WRAP(...) {}
#define glNewObjectBufferATI_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glNewObjectBufferATI(_size, _pointer, _usage) ({ \
    glNewObjectBufferATI_PACKED *packed_data = malloc(sizeof(glNewObjectBufferATI_PACKED)); \
    packed_data->index = glNewObjectBufferATI_INDEX; \
    packed_data->args.size = (GLsizei)_size; \
    packed_data->args.pointer = (GLvoid *)_pointer; \
    packed_data->args.usage = (GLenum)_usage; \
    (packed_call_t *)packed_data; \
})
#define call_glNewObjectBufferATI(packed, ret_v) do { \
    PACKED_glNewObjectBufferATI *unpacked = (PACKED_glNewObjectBufferATI *)packed; \
    ARGS_glNewObjectBufferATI *args = (ARGS_glNewObjectBufferATI *)&unpacked->args; \
    GLuint *ret = (GLuint *)ret_v; \
    if (ret != NULL) { \
        *ret = glNewObjectBufferATI(args->size, args->pointer, args->usage);; \
    } else { \
        glNewObjectBufferATI(args->size, args->pointer, args->usage);; \
    } \
} while(0)
GLuint glNewObjectBufferATI(glNewObjectBufferATI_ARG_EXPAND);
typedef GLuint (*glNewObjectBufferATI_PTR)(glNewObjectBufferATI_ARG_EXPAND);
#define glNormal3b_INDEX 1458
#define glNormal3b_RETURN void
#define glNormal3b_ARG_NAMES nx, ny, nz
#define glNormal3b_ARG_EXPAND GLbyte nx, GLbyte ny, GLbyte nz
#define glNormal3b_PACKED PACKED_glNormal3b
#define glNormal3b_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glNormal3b_NOT_VOID_WRAP(...) {}
#define pack_glNormal3b(_nx, _ny, _nz) ({ \
    glNormal3b_PACKED *packed_data = malloc(sizeof(glNormal3b_PACKED)); \
    packed_data->index = glNormal3b_INDEX; \
    packed_data->args.nx = (GLbyte)_nx; \
    packed_data->args.ny = (GLbyte)_ny; \
    packed_data->args.nz = (GLbyte)_nz; \
    (packed_call_t *)packed_data; \
})
#define call_glNormal3b(packed, ret_v) do { \
    PACKED_glNormal3b *unpacked = (PACKED_glNormal3b *)packed; \
    ARGS_glNormal3b *args = (ARGS_glNormal3b *)&unpacked->args; \
    glNormal3b(args->nx, args->ny, args->nz);; \
} while(0)
void glNormal3b(glNormal3b_ARG_EXPAND);
typedef void (*glNormal3b_PTR)(glNormal3b_ARG_EXPAND);
#define glNormal3bv_INDEX 1459
#define glNormal3bv_RETURN void
#define glNormal3bv_ARG_NAMES v
#define glNormal3bv_ARG_EXPAND const GLbyte * v
#define glNormal3bv_PACKED PACKED_glNormal3bv
#define glNormal3bv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glNormal3bv_NOT_VOID_WRAP(...) {}
#define pack_glNormal3bv(_v) ({ \
    glNormal3bv_PACKED *packed_data = malloc(sizeof(glNormal3bv_PACKED)); \
    packed_data->index = glNormal3bv_INDEX; \
    packed_data->args.v = (GLbyte *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glNormal3bv(packed, ret_v) do { \
    PACKED_glNormal3bv *unpacked = (PACKED_glNormal3bv *)packed; \
    ARGS_glNormal3bv *args = (ARGS_glNormal3bv *)&unpacked->args; \
    glNormal3bv(args->v);; \
} while(0)
void glNormal3bv(glNormal3bv_ARG_EXPAND);
typedef void (*glNormal3bv_PTR)(glNormal3bv_ARG_EXPAND);
#define glNormal3d_INDEX 1460
#define glNormal3d_RETURN void
#define glNormal3d_ARG_NAMES nx, ny, nz
#define glNormal3d_ARG_EXPAND GLdouble nx, GLdouble ny, GLdouble nz
#define glNormal3d_PACKED PACKED_glNormal3d
#define glNormal3d_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glNormal3d_NOT_VOID_WRAP(...) {}
#define pack_glNormal3d(_nx, _ny, _nz) ({ \
    glNormal3d_PACKED *packed_data = malloc(sizeof(glNormal3d_PACKED)); \
    packed_data->index = glNormal3d_INDEX; \
    packed_data->args.nx = (GLdouble)_nx; \
    packed_data->args.ny = (GLdouble)_ny; \
    packed_data->args.nz = (GLdouble)_nz; \
    (packed_call_t *)packed_data; \
})
#define call_glNormal3d(packed, ret_v) do { \
    PACKED_glNormal3d *unpacked = (PACKED_glNormal3d *)packed; \
    ARGS_glNormal3d *args = (ARGS_glNormal3d *)&unpacked->args; \
    glNormal3d(args->nx, args->ny, args->nz);; \
} while(0)
void glNormal3d(glNormal3d_ARG_EXPAND);
typedef void (*glNormal3d_PTR)(glNormal3d_ARG_EXPAND);
#define glNormal3dv_INDEX 1461
#define glNormal3dv_RETURN void
#define glNormal3dv_ARG_NAMES v
#define glNormal3dv_ARG_EXPAND const GLdouble * v
#define glNormal3dv_PACKED PACKED_glNormal3dv
#define glNormal3dv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glNormal3dv_NOT_VOID_WRAP(...) {}
#define pack_glNormal3dv(_v) ({ \
    glNormal3dv_PACKED *packed_data = malloc(sizeof(glNormal3dv_PACKED)); \
    packed_data->index = glNormal3dv_INDEX; \
    packed_data->args.v = (GLdouble *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glNormal3dv(packed, ret_v) do { \
    PACKED_glNormal3dv *unpacked = (PACKED_glNormal3dv *)packed; \
    ARGS_glNormal3dv *args = (ARGS_glNormal3dv *)&unpacked->args; \
    glNormal3dv(args->v);; \
} while(0)
void glNormal3dv(glNormal3dv_ARG_EXPAND);
typedef void (*glNormal3dv_PTR)(glNormal3dv_ARG_EXPAND);
#define glNormal3f_INDEX 1462
#define glNormal3f_RETURN void
#define glNormal3f_ARG_NAMES nx, ny, nz
#define glNormal3f_ARG_EXPAND GLfloat nx, GLfloat ny, GLfloat nz
#define glNormal3f_PACKED PACKED_glNormal3f
#define glNormal3f_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glNormal3f_NOT_VOID_WRAP(...) {}
#define pack_glNormal3f(_nx, _ny, _nz) ({ \
    glNormal3f_PACKED *packed_data = malloc(sizeof(glNormal3f_PACKED)); \
    packed_data->index = glNormal3f_INDEX; \
    packed_data->args.nx = (GLfloat)_nx; \
    packed_data->args.ny = (GLfloat)_ny; \
    packed_data->args.nz = (GLfloat)_nz; \
    (packed_call_t *)packed_data; \
})
#define call_glNormal3f(packed, ret_v) do { \
    PACKED_glNormal3f *unpacked = (PACKED_glNormal3f *)packed; \
    ARGS_glNormal3f *args = (ARGS_glNormal3f *)&unpacked->args; \
    glNormal3f(args->nx, args->ny, args->nz);; \
} while(0)
void glNormal3f(glNormal3f_ARG_EXPAND);
typedef void (*glNormal3f_PTR)(glNormal3f_ARG_EXPAND);
#define glNormal3fVertex3fSUN_INDEX 1463
#define glNormal3fVertex3fSUN_RETURN void
#define glNormal3fVertex3fSUN_ARG_NAMES nx, ny, nz, x, y, z
#define glNormal3fVertex3fSUN_ARG_EXPAND GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z
#define glNormal3fVertex3fSUN_PACKED PACKED_glNormal3fVertex3fSUN
#define glNormal3fVertex3fSUN_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glNormal3fVertex3fSUN_NOT_VOID_WRAP(...) {}
#define pack_glNormal3fVertex3fSUN(_nx, _ny, _nz, _x, _y, _z) ({ \
    glNormal3fVertex3fSUN_PACKED *packed_data = malloc(sizeof(glNormal3fVertex3fSUN_PACKED)); \
    packed_data->index = glNormal3fVertex3fSUN_INDEX; \
    packed_data->args.nx = (GLfloat)_nx; \
    packed_data->args.ny = (GLfloat)_ny; \
    packed_data->args.nz = (GLfloat)_nz; \
    packed_data->args.x = (GLfloat)_x; \
    packed_data->args.y = (GLfloat)_y; \
    packed_data->args.z = (GLfloat)_z; \
    (packed_call_t *)packed_data; \
})
#define call_glNormal3fVertex3fSUN(packed, ret_v) do { \
    PACKED_glNormal3fVertex3fSUN *unpacked = (PACKED_glNormal3fVertex3fSUN *)packed; \
    ARGS_glNormal3fVertex3fSUN *args = (ARGS_glNormal3fVertex3fSUN *)&unpacked->args; \
    glNormal3fVertex3fSUN(args->nx, args->ny, args->nz, args->x, args->y, args->z);; \
} while(0)
void glNormal3fVertex3fSUN(glNormal3fVertex3fSUN_ARG_EXPAND);
typedef void (*glNormal3fVertex3fSUN_PTR)(glNormal3fVertex3fSUN_ARG_EXPAND);
#define glNormal3fVertex3fvSUN_INDEX 1464
#define glNormal3fVertex3fvSUN_RETURN void
#define glNormal3fVertex3fvSUN_ARG_NAMES n, v
#define glNormal3fVertex3fvSUN_ARG_EXPAND const GLfloat * n, const GLfloat * v
#define glNormal3fVertex3fvSUN_PACKED PACKED_glNormal3fVertex3fvSUN
#define glNormal3fVertex3fvSUN_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glNormal3fVertex3fvSUN_NOT_VOID_WRAP(...) {}
#define pack_glNormal3fVertex3fvSUN(_n, _v) ({ \
    glNormal3fVertex3fvSUN_PACKED *packed_data = malloc(sizeof(glNormal3fVertex3fvSUN_PACKED)); \
    packed_data->index = glNormal3fVertex3fvSUN_INDEX; \
    packed_data->args.n = (GLfloat *)_n; \
    packed_data->args.v = (GLfloat *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glNormal3fVertex3fvSUN(packed, ret_v) do { \
    PACKED_glNormal3fVertex3fvSUN *unpacked = (PACKED_glNormal3fVertex3fvSUN *)packed; \
    ARGS_glNormal3fVertex3fvSUN *args = (ARGS_glNormal3fVertex3fvSUN *)&unpacked->args; \
    glNormal3fVertex3fvSUN(args->n, args->v);; \
} while(0)
void glNormal3fVertex3fvSUN(glNormal3fVertex3fvSUN_ARG_EXPAND);
typedef void (*glNormal3fVertex3fvSUN_PTR)(glNormal3fVertex3fvSUN_ARG_EXPAND);
#define glNormal3fv_INDEX 1465
#define glNormal3fv_RETURN void
#define glNormal3fv_ARG_NAMES v
#define glNormal3fv_ARG_EXPAND const GLfloat * v
#define glNormal3fv_PACKED PACKED_glNormal3fv
#define glNormal3fv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glNormal3fv_NOT_VOID_WRAP(...) {}
#define pack_glNormal3fv(_v) ({ \
    glNormal3fv_PACKED *packed_data = malloc(sizeof(glNormal3fv_PACKED)); \
    packed_data->index = glNormal3fv_INDEX; \
    packed_data->args.v = (GLfloat *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glNormal3fv(packed, ret_v) do { \
    PACKED_glNormal3fv *unpacked = (PACKED_glNormal3fv *)packed; \
    ARGS_glNormal3fv *args = (ARGS_glNormal3fv *)&unpacked->args; \
    glNormal3fv(args->v);; \
} while(0)
void glNormal3fv(glNormal3fv_ARG_EXPAND);
typedef void (*glNormal3fv_PTR)(glNormal3fv_ARG_EXPAND);
#define glNormal3hNV_INDEX 1466
#define glNormal3hNV_RETURN void
#define glNormal3hNV_ARG_NAMES nx, ny, nz
#define glNormal3hNV_ARG_EXPAND GLhalfNV nx, GLhalfNV ny, GLhalfNV nz
#define glNormal3hNV_PACKED PACKED_glNormal3hNV
#define glNormal3hNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glNormal3hNV_NOT_VOID_WRAP(...) {}
#define pack_glNormal3hNV(_nx, _ny, _nz) ({ \
    glNormal3hNV_PACKED *packed_data = malloc(sizeof(glNormal3hNV_PACKED)); \
    packed_data->index = glNormal3hNV_INDEX; \
    packed_data->args.nx = (GLhalfNV)_nx; \
    packed_data->args.ny = (GLhalfNV)_ny; \
    packed_data->args.nz = (GLhalfNV)_nz; \
    (packed_call_t *)packed_data; \
})
#define call_glNormal3hNV(packed, ret_v) do { \
    PACKED_glNormal3hNV *unpacked = (PACKED_glNormal3hNV *)packed; \
    ARGS_glNormal3hNV *args = (ARGS_glNormal3hNV *)&unpacked->args; \
    glNormal3hNV(args->nx, args->ny, args->nz);; \
} while(0)
void glNormal3hNV(glNormal3hNV_ARG_EXPAND);
typedef void (*glNormal3hNV_PTR)(glNormal3hNV_ARG_EXPAND);
#define glNormal3hvNV_INDEX 1467
#define glNormal3hvNV_RETURN void
#define glNormal3hvNV_ARG_NAMES v
#define glNormal3hvNV_ARG_EXPAND const GLhalfNV * v
#define glNormal3hvNV_PACKED PACKED_glNormal3hvNV
#define glNormal3hvNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glNormal3hvNV_NOT_VOID_WRAP(...) {}
#define pack_glNormal3hvNV(_v) ({ \
    glNormal3hvNV_PACKED *packed_data = malloc(sizeof(glNormal3hvNV_PACKED)); \
    packed_data->index = glNormal3hvNV_INDEX; \
    packed_data->args.v = (GLhalfNV *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glNormal3hvNV(packed, ret_v) do { \
    PACKED_glNormal3hvNV *unpacked = (PACKED_glNormal3hvNV *)packed; \
    ARGS_glNormal3hvNV *args = (ARGS_glNormal3hvNV *)&unpacked->args; \
    glNormal3hvNV(args->v);; \
} while(0)
void glNormal3hvNV(glNormal3hvNV_ARG_EXPAND);
typedef void (*glNormal3hvNV_PTR)(glNormal3hvNV_ARG_EXPAND);
#define glNormal3i_INDEX 1468
#define glNormal3i_RETURN void
#define glNormal3i_ARG_NAMES nx, ny, nz
#define glNormal3i_ARG_EXPAND GLint nx, GLint ny, GLint nz
#define glNormal3i_PACKED PACKED_glNormal3i
#define glNormal3i_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glNormal3i_NOT_VOID_WRAP(...) {}
#define pack_glNormal3i(_nx, _ny, _nz) ({ \
    glNormal3i_PACKED *packed_data = malloc(sizeof(glNormal3i_PACKED)); \
    packed_data->index = glNormal3i_INDEX; \
    packed_data->args.nx = (GLint)_nx; \
    packed_data->args.ny = (GLint)_ny; \
    packed_data->args.nz = (GLint)_nz; \
    (packed_call_t *)packed_data; \
})
#define call_glNormal3i(packed, ret_v) do { \
    PACKED_glNormal3i *unpacked = (PACKED_glNormal3i *)packed; \
    ARGS_glNormal3i *args = (ARGS_glNormal3i *)&unpacked->args; \
    glNormal3i(args->nx, args->ny, args->nz);; \
} while(0)
void glNormal3i(glNormal3i_ARG_EXPAND);
typedef void (*glNormal3i_PTR)(glNormal3i_ARG_EXPAND);
#define glNormal3iv_INDEX 1469
#define glNormal3iv_RETURN void
#define glNormal3iv_ARG_NAMES v
#define glNormal3iv_ARG_EXPAND const GLint * v
#define glNormal3iv_PACKED PACKED_glNormal3iv
#define glNormal3iv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glNormal3iv_NOT_VOID_WRAP(...) {}
#define pack_glNormal3iv(_v) ({ \
    glNormal3iv_PACKED *packed_data = malloc(sizeof(glNormal3iv_PACKED)); \
    packed_data->index = glNormal3iv_INDEX; \
    packed_data->args.v = (GLint *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glNormal3iv(packed, ret_v) do { \
    PACKED_glNormal3iv *unpacked = (PACKED_glNormal3iv *)packed; \
    ARGS_glNormal3iv *args = (ARGS_glNormal3iv *)&unpacked->args; \
    glNormal3iv(args->v);; \
} while(0)
void glNormal3iv(glNormal3iv_ARG_EXPAND);
typedef void (*glNormal3iv_PTR)(glNormal3iv_ARG_EXPAND);
#define glNormal3s_INDEX 1470
#define glNormal3s_RETURN void
#define glNormal3s_ARG_NAMES nx, ny, nz
#define glNormal3s_ARG_EXPAND GLshort nx, GLshort ny, GLshort nz
#define glNormal3s_PACKED PACKED_glNormal3s
#define glNormal3s_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glNormal3s_NOT_VOID_WRAP(...) {}
#define pack_glNormal3s(_nx, _ny, _nz) ({ \
    glNormal3s_PACKED *packed_data = malloc(sizeof(glNormal3s_PACKED)); \
    packed_data->index = glNormal3s_INDEX; \
    packed_data->args.nx = (GLshort)_nx; \
    packed_data->args.ny = (GLshort)_ny; \
    packed_data->args.nz = (GLshort)_nz; \
    (packed_call_t *)packed_data; \
})
#define call_glNormal3s(packed, ret_v) do { \
    PACKED_glNormal3s *unpacked = (PACKED_glNormal3s *)packed; \
    ARGS_glNormal3s *args = (ARGS_glNormal3s *)&unpacked->args; \
    glNormal3s(args->nx, args->ny, args->nz);; \
} while(0)
void glNormal3s(glNormal3s_ARG_EXPAND);
typedef void (*glNormal3s_PTR)(glNormal3s_ARG_EXPAND);
#define glNormal3sv_INDEX 1471
#define glNormal3sv_RETURN void
#define glNormal3sv_ARG_NAMES v
#define glNormal3sv_ARG_EXPAND const GLshort * v
#define glNormal3sv_PACKED PACKED_glNormal3sv
#define glNormal3sv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glNormal3sv_NOT_VOID_WRAP(...) {}
#define pack_glNormal3sv(_v) ({ \
    glNormal3sv_PACKED *packed_data = malloc(sizeof(glNormal3sv_PACKED)); \
    packed_data->index = glNormal3sv_INDEX; \
    packed_data->args.v = (GLshort *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glNormal3sv(packed, ret_v) do { \
    PACKED_glNormal3sv *unpacked = (PACKED_glNormal3sv *)packed; \
    ARGS_glNormal3sv *args = (ARGS_glNormal3sv *)&unpacked->args; \
    glNormal3sv(args->v);; \
} while(0)
void glNormal3sv(glNormal3sv_ARG_EXPAND);
typedef void (*glNormal3sv_PTR)(glNormal3sv_ARG_EXPAND);
#define glNormal3x_INDEX 1472
#define glNormal3x_RETURN void
#define glNormal3x_ARG_NAMES nx, ny, nz
#define glNormal3x_ARG_EXPAND GLfixed nx, GLfixed ny, GLfixed nz
#define glNormal3x_PACKED PACKED_glNormal3x
#define glNormal3x_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glNormal3x_NOT_VOID_WRAP(...) {}
#define pack_glNormal3x(_nx, _ny, _nz) ({ \
    glNormal3x_PACKED *packed_data = malloc(sizeof(glNormal3x_PACKED)); \
    packed_data->index = glNormal3x_INDEX; \
    packed_data->args.nx = (GLfixed)_nx; \
    packed_data->args.ny = (GLfixed)_ny; \
    packed_data->args.nz = (GLfixed)_nz; \
    (packed_call_t *)packed_data; \
})
#define call_glNormal3x(packed, ret_v) do { \
    PACKED_glNormal3x *unpacked = (PACKED_glNormal3x *)packed; \
    ARGS_glNormal3x *args = (ARGS_glNormal3x *)&unpacked->args; \
    glNormal3x(args->nx, args->ny, args->nz);; \
} while(0)
void glNormal3x(glNormal3x_ARG_EXPAND);
typedef void (*glNormal3x_PTR)(glNormal3x_ARG_EXPAND);
#define glNormal3xOES_INDEX 1473
#define glNormal3xOES_RETURN void
#define glNormal3xOES_ARG_NAMES nx, ny, nz
#define glNormal3xOES_ARG_EXPAND GLfixed nx, GLfixed ny, GLfixed nz
#define glNormal3xOES_PACKED PACKED_glNormal3xOES
#define glNormal3xOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glNormal3xOES_NOT_VOID_WRAP(...) {}
#define pack_glNormal3xOES(_nx, _ny, _nz) ({ \
    glNormal3xOES_PACKED *packed_data = malloc(sizeof(glNormal3xOES_PACKED)); \
    packed_data->index = glNormal3xOES_INDEX; \
    packed_data->args.nx = (GLfixed)_nx; \
    packed_data->args.ny = (GLfixed)_ny; \
    packed_data->args.nz = (GLfixed)_nz; \
    (packed_call_t *)packed_data; \
})
#define call_glNormal3xOES(packed, ret_v) do { \
    PACKED_glNormal3xOES *unpacked = (PACKED_glNormal3xOES *)packed; \
    ARGS_glNormal3xOES *args = (ARGS_glNormal3xOES *)&unpacked->args; \
    glNormal3xOES(args->nx, args->ny, args->nz);; \
} while(0)
void glNormal3xOES(glNormal3xOES_ARG_EXPAND);
typedef void (*glNormal3xOES_PTR)(glNormal3xOES_ARG_EXPAND);
#define glNormal3xvOES_INDEX 1474
#define glNormal3xvOES_RETURN void
#define glNormal3xvOES_ARG_NAMES coords
#define glNormal3xvOES_ARG_EXPAND const GLfixed * coords
#define glNormal3xvOES_PACKED PACKED_glNormal3xvOES
#define glNormal3xvOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glNormal3xvOES_NOT_VOID_WRAP(...) {}
#define pack_glNormal3xvOES(_coords) ({ \
    glNormal3xvOES_PACKED *packed_data = malloc(sizeof(glNormal3xvOES_PACKED)); \
    packed_data->index = glNormal3xvOES_INDEX; \
    packed_data->args.coords = (GLfixed *)_coords; \
    (packed_call_t *)packed_data; \
})
#define call_glNormal3xvOES(packed, ret_v) do { \
    PACKED_glNormal3xvOES *unpacked = (PACKED_glNormal3xvOES *)packed; \
    ARGS_glNormal3xvOES *args = (ARGS_glNormal3xvOES *)&unpacked->args; \
    glNormal3xvOES(args->coords);; \
} while(0)
void glNormal3xvOES(glNormal3xvOES_ARG_EXPAND);
typedef void (*glNormal3xvOES_PTR)(glNormal3xvOES_ARG_EXPAND);
#define glNormalFormatNV_INDEX 1475
#define glNormalFormatNV_RETURN void
#define glNormalFormatNV_ARG_NAMES type, stride
#define glNormalFormatNV_ARG_EXPAND GLenum type, GLsizei stride
#define glNormalFormatNV_PACKED PACKED_glNormalFormatNV
#define glNormalFormatNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glNormalFormatNV_NOT_VOID_WRAP(...) {}
#define pack_glNormalFormatNV(_type, _stride) ({ \
    glNormalFormatNV_PACKED *packed_data = malloc(sizeof(glNormalFormatNV_PACKED)); \
    packed_data->index = glNormalFormatNV_INDEX; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.stride = (GLsizei)_stride; \
    (packed_call_t *)packed_data; \
})
#define call_glNormalFormatNV(packed, ret_v) do { \
    PACKED_glNormalFormatNV *unpacked = (PACKED_glNormalFormatNV *)packed; \
    ARGS_glNormalFormatNV *args = (ARGS_glNormalFormatNV *)&unpacked->args; \
    glNormalFormatNV(args->type, args->stride);; \
} while(0)
void glNormalFormatNV(glNormalFormatNV_ARG_EXPAND);
typedef void (*glNormalFormatNV_PTR)(glNormalFormatNV_ARG_EXPAND);
#define glNormalP3ui_INDEX 1476
#define glNormalP3ui_RETURN void
#define glNormalP3ui_ARG_NAMES type, coords
#define glNormalP3ui_ARG_EXPAND GLenum type, GLuint coords
#define glNormalP3ui_PACKED PACKED_glNormalP3ui
#define glNormalP3ui_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glNormalP3ui_NOT_VOID_WRAP(...) {}
#define pack_glNormalP3ui(_type, _coords) ({ \
    glNormalP3ui_PACKED *packed_data = malloc(sizeof(glNormalP3ui_PACKED)); \
    packed_data->index = glNormalP3ui_INDEX; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.coords = (GLuint)_coords; \
    (packed_call_t *)packed_data; \
})
#define call_glNormalP3ui(packed, ret_v) do { \
    PACKED_glNormalP3ui *unpacked = (PACKED_glNormalP3ui *)packed; \
    ARGS_glNormalP3ui *args = (ARGS_glNormalP3ui *)&unpacked->args; \
    glNormalP3ui(args->type, args->coords);; \
} while(0)
void glNormalP3ui(glNormalP3ui_ARG_EXPAND);
typedef void (*glNormalP3ui_PTR)(glNormalP3ui_ARG_EXPAND);
#define glNormalP3uiv_INDEX 1477
#define glNormalP3uiv_RETURN void
#define glNormalP3uiv_ARG_NAMES type, coords
#define glNormalP3uiv_ARG_EXPAND GLenum type, const GLuint * coords
#define glNormalP3uiv_PACKED PACKED_glNormalP3uiv
#define glNormalP3uiv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glNormalP3uiv_NOT_VOID_WRAP(...) {}
#define pack_glNormalP3uiv(_type, _coords) ({ \
    glNormalP3uiv_PACKED *packed_data = malloc(sizeof(glNormalP3uiv_PACKED)); \
    packed_data->index = glNormalP3uiv_INDEX; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.coords = (GLuint *)_coords; \
    (packed_call_t *)packed_data; \
})
#define call_glNormalP3uiv(packed, ret_v) do { \
    PACKED_glNormalP3uiv *unpacked = (PACKED_glNormalP3uiv *)packed; \
    ARGS_glNormalP3uiv *args = (ARGS_glNormalP3uiv *)&unpacked->args; \
    glNormalP3uiv(args->type, args->coords);; \
} while(0)
void glNormalP3uiv(glNormalP3uiv_ARG_EXPAND);
typedef void (*glNormalP3uiv_PTR)(glNormalP3uiv_ARG_EXPAND);
#define glNormalPointer_INDEX 1478
#define glNormalPointer_RETURN void
#define glNormalPointer_ARG_NAMES type, stride, pointer
#define glNormalPointer_ARG_EXPAND GLenum type, GLsizei stride, const GLvoid * pointer
#define glNormalPointer_PACKED PACKED_glNormalPointer
#define glNormalPointer_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glNormalPointer_NOT_VOID_WRAP(...) {}
#define pack_glNormalPointer(_type, _stride, _pointer) ({ \
    glNormalPointer_PACKED *packed_data = malloc(sizeof(glNormalPointer_PACKED)); \
    packed_data->index = glNormalPointer_INDEX; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.stride = (GLsizei)_stride; \
    packed_data->args.pointer = (GLvoid *)_pointer; \
    (packed_call_t *)packed_data; \
})
#define call_glNormalPointer(packed, ret_v) do { \
    PACKED_glNormalPointer *unpacked = (PACKED_glNormalPointer *)packed; \
    ARGS_glNormalPointer *args = (ARGS_glNormalPointer *)&unpacked->args; \
    glNormalPointer(args->type, args->stride, args->pointer);; \
} while(0)
void glNormalPointer(glNormalPointer_ARG_EXPAND);
typedef void (*glNormalPointer_PTR)(glNormalPointer_ARG_EXPAND);
#define glNormalPointerEXT_INDEX 1479
#define glNormalPointerEXT_RETURN void
#define glNormalPointerEXT_ARG_NAMES type, stride, count, pointer
#define glNormalPointerEXT_ARG_EXPAND GLenum type, GLsizei stride, GLsizei count, const GLvoid * pointer
#define glNormalPointerEXT_PACKED PACKED_glNormalPointerEXT
#define glNormalPointerEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glNormalPointerEXT_NOT_VOID_WRAP(...) {}
#define pack_glNormalPointerEXT(_type, _stride, _count, _pointer) ({ \
    glNormalPointerEXT_PACKED *packed_data = malloc(sizeof(glNormalPointerEXT_PACKED)); \
    packed_data->index = glNormalPointerEXT_INDEX; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.stride = (GLsizei)_stride; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.pointer = (GLvoid *)_pointer; \
    (packed_call_t *)packed_data; \
})
#define call_glNormalPointerEXT(packed, ret_v) do { \
    PACKED_glNormalPointerEXT *unpacked = (PACKED_glNormalPointerEXT *)packed; \
    ARGS_glNormalPointerEXT *args = (ARGS_glNormalPointerEXT *)&unpacked->args; \
    glNormalPointerEXT(args->type, args->stride, args->count, args->pointer);; \
} while(0)
void glNormalPointerEXT(glNormalPointerEXT_ARG_EXPAND);
typedef void (*glNormalPointerEXT_PTR)(glNormalPointerEXT_ARG_EXPAND);
#define glNormalPointerListIBM_INDEX 1480
#define glNormalPointerListIBM_RETURN void
#define glNormalPointerListIBM_ARG_NAMES type, stride, pointer, ptrstride
#define glNormalPointerListIBM_ARG_EXPAND GLenum type, GLint stride, const GLvoid * pointer, GLint ptrstride
#define glNormalPointerListIBM_PACKED PACKED_glNormalPointerListIBM
#define glNormalPointerListIBM_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glNormalPointerListIBM_NOT_VOID_WRAP(...) {}
#define pack_glNormalPointerListIBM(_type, _stride, _pointer, _ptrstride) ({ \
    glNormalPointerListIBM_PACKED *packed_data = malloc(sizeof(glNormalPointerListIBM_PACKED)); \
    packed_data->index = glNormalPointerListIBM_INDEX; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.stride = (GLint)_stride; \
    packed_data->args.pointer = (GLvoid *)_pointer; \
    packed_data->args.ptrstride = (GLint)_ptrstride; \
    (packed_call_t *)packed_data; \
})
#define call_glNormalPointerListIBM(packed, ret_v) do { \
    PACKED_glNormalPointerListIBM *unpacked = (PACKED_glNormalPointerListIBM *)packed; \
    ARGS_glNormalPointerListIBM *args = (ARGS_glNormalPointerListIBM *)&unpacked->args; \
    glNormalPointerListIBM(args->type, args->stride, args->pointer, args->ptrstride);; \
} while(0)
void glNormalPointerListIBM(glNormalPointerListIBM_ARG_EXPAND);
typedef void (*glNormalPointerListIBM_PTR)(glNormalPointerListIBM_ARG_EXPAND);
#define glNormalPointervINTEL_INDEX 1481
#define glNormalPointervINTEL_RETURN void
#define glNormalPointervINTEL_ARG_NAMES type, pointer
#define glNormalPointervINTEL_ARG_EXPAND GLenum type, const GLvoid * pointer
#define glNormalPointervINTEL_PACKED PACKED_glNormalPointervINTEL
#define glNormalPointervINTEL_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glNormalPointervINTEL_NOT_VOID_WRAP(...) {}
#define pack_glNormalPointervINTEL(_type, _pointer) ({ \
    glNormalPointervINTEL_PACKED *packed_data = malloc(sizeof(glNormalPointervINTEL_PACKED)); \
    packed_data->index = glNormalPointervINTEL_INDEX; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.pointer = (GLvoid *)_pointer; \
    (packed_call_t *)packed_data; \
})
#define call_glNormalPointervINTEL(packed, ret_v) do { \
    PACKED_glNormalPointervINTEL *unpacked = (PACKED_glNormalPointervINTEL *)packed; \
    ARGS_glNormalPointervINTEL *args = (ARGS_glNormalPointervINTEL *)&unpacked->args; \
    glNormalPointervINTEL(args->type, args->pointer);; \
} while(0)
void glNormalPointervINTEL(glNormalPointervINTEL_ARG_EXPAND);
typedef void (*glNormalPointervINTEL_PTR)(glNormalPointervINTEL_ARG_EXPAND);
#define glNormalStream3bATI_INDEX 1482
#define glNormalStream3bATI_RETURN void
#define glNormalStream3bATI_ARG_NAMES stream, nx, ny, nz
#define glNormalStream3bATI_ARG_EXPAND GLenum stream, GLbyte nx, GLbyte ny, GLbyte nz
#define glNormalStream3bATI_PACKED PACKED_glNormalStream3bATI
#define glNormalStream3bATI_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glNormalStream3bATI_NOT_VOID_WRAP(...) {}
#define pack_glNormalStream3bATI(_stream, _nx, _ny, _nz) ({ \
    glNormalStream3bATI_PACKED *packed_data = malloc(sizeof(glNormalStream3bATI_PACKED)); \
    packed_data->index = glNormalStream3bATI_INDEX; \
    packed_data->args.stream = (GLenum)_stream; \
    packed_data->args.nx = (GLbyte)_nx; \
    packed_data->args.ny = (GLbyte)_ny; \
    packed_data->args.nz = (GLbyte)_nz; \
    (packed_call_t *)packed_data; \
})
#define call_glNormalStream3bATI(packed, ret_v) do { \
    PACKED_glNormalStream3bATI *unpacked = (PACKED_glNormalStream3bATI *)packed; \
    ARGS_glNormalStream3bATI *args = (ARGS_glNormalStream3bATI *)&unpacked->args; \
    glNormalStream3bATI(args->stream, args->nx, args->ny, args->nz);; \
} while(0)
void glNormalStream3bATI(glNormalStream3bATI_ARG_EXPAND);
typedef void (*glNormalStream3bATI_PTR)(glNormalStream3bATI_ARG_EXPAND);
#define glNormalStream3bvATI_INDEX 1483
#define glNormalStream3bvATI_RETURN void
#define glNormalStream3bvATI_ARG_NAMES stream, coords
#define glNormalStream3bvATI_ARG_EXPAND GLenum stream, const GLbyte * coords
#define glNormalStream3bvATI_PACKED PACKED_glNormalStream3bvATI
#define glNormalStream3bvATI_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glNormalStream3bvATI_NOT_VOID_WRAP(...) {}
#define pack_glNormalStream3bvATI(_stream, _coords) ({ \
    glNormalStream3bvATI_PACKED *packed_data = malloc(sizeof(glNormalStream3bvATI_PACKED)); \
    packed_data->index = glNormalStream3bvATI_INDEX; \
    packed_data->args.stream = (GLenum)_stream; \
    packed_data->args.coords = (GLbyte *)_coords; \
    (packed_call_t *)packed_data; \
})
#define call_glNormalStream3bvATI(packed, ret_v) do { \
    PACKED_glNormalStream3bvATI *unpacked = (PACKED_glNormalStream3bvATI *)packed; \
    ARGS_glNormalStream3bvATI *args = (ARGS_glNormalStream3bvATI *)&unpacked->args; \
    glNormalStream3bvATI(args->stream, args->coords);; \
} while(0)
void glNormalStream3bvATI(glNormalStream3bvATI_ARG_EXPAND);
typedef void (*glNormalStream3bvATI_PTR)(glNormalStream3bvATI_ARG_EXPAND);
#define glNormalStream3dATI_INDEX 1484
#define glNormalStream3dATI_RETURN void
#define glNormalStream3dATI_ARG_NAMES stream, nx, ny, nz
#define glNormalStream3dATI_ARG_EXPAND GLenum stream, GLdouble nx, GLdouble ny, GLdouble nz
#define glNormalStream3dATI_PACKED PACKED_glNormalStream3dATI
#define glNormalStream3dATI_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glNormalStream3dATI_NOT_VOID_WRAP(...) {}
#define pack_glNormalStream3dATI(_stream, _nx, _ny, _nz) ({ \
    glNormalStream3dATI_PACKED *packed_data = malloc(sizeof(glNormalStream3dATI_PACKED)); \
    packed_data->index = glNormalStream3dATI_INDEX; \
    packed_data->args.stream = (GLenum)_stream; \
    packed_data->args.nx = (GLdouble)_nx; \
    packed_data->args.ny = (GLdouble)_ny; \
    packed_data->args.nz = (GLdouble)_nz; \
    (packed_call_t *)packed_data; \
})
#define call_glNormalStream3dATI(packed, ret_v) do { \
    PACKED_glNormalStream3dATI *unpacked = (PACKED_glNormalStream3dATI *)packed; \
    ARGS_glNormalStream3dATI *args = (ARGS_glNormalStream3dATI *)&unpacked->args; \
    glNormalStream3dATI(args->stream, args->nx, args->ny, args->nz);; \
} while(0)
void glNormalStream3dATI(glNormalStream3dATI_ARG_EXPAND);
typedef void (*glNormalStream3dATI_PTR)(glNormalStream3dATI_ARG_EXPAND);
#define glNormalStream3dvATI_INDEX 1485
#define glNormalStream3dvATI_RETURN void
#define glNormalStream3dvATI_ARG_NAMES stream, coords
#define glNormalStream3dvATI_ARG_EXPAND GLenum stream, const GLdouble * coords
#define glNormalStream3dvATI_PACKED PACKED_glNormalStream3dvATI
#define glNormalStream3dvATI_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glNormalStream3dvATI_NOT_VOID_WRAP(...) {}
#define pack_glNormalStream3dvATI(_stream, _coords) ({ \
    glNormalStream3dvATI_PACKED *packed_data = malloc(sizeof(glNormalStream3dvATI_PACKED)); \
    packed_data->index = glNormalStream3dvATI_INDEX; \
    packed_data->args.stream = (GLenum)_stream; \
    packed_data->args.coords = (GLdouble *)_coords; \
    (packed_call_t *)packed_data; \
})
#define call_glNormalStream3dvATI(packed, ret_v) do { \
    PACKED_glNormalStream3dvATI *unpacked = (PACKED_glNormalStream3dvATI *)packed; \
    ARGS_glNormalStream3dvATI *args = (ARGS_glNormalStream3dvATI *)&unpacked->args; \
    glNormalStream3dvATI(args->stream, args->coords);; \
} while(0)
void glNormalStream3dvATI(glNormalStream3dvATI_ARG_EXPAND);
typedef void (*glNormalStream3dvATI_PTR)(glNormalStream3dvATI_ARG_EXPAND);
#define glNormalStream3fATI_INDEX 1486
#define glNormalStream3fATI_RETURN void
#define glNormalStream3fATI_ARG_NAMES stream, nx, ny, nz
#define glNormalStream3fATI_ARG_EXPAND GLenum stream, GLfloat nx, GLfloat ny, GLfloat nz
#define glNormalStream3fATI_PACKED PACKED_glNormalStream3fATI
#define glNormalStream3fATI_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glNormalStream3fATI_NOT_VOID_WRAP(...) {}
#define pack_glNormalStream3fATI(_stream, _nx, _ny, _nz) ({ \
    glNormalStream3fATI_PACKED *packed_data = malloc(sizeof(glNormalStream3fATI_PACKED)); \
    packed_data->index = glNormalStream3fATI_INDEX; \
    packed_data->args.stream = (GLenum)_stream; \
    packed_data->args.nx = (GLfloat)_nx; \
    packed_data->args.ny = (GLfloat)_ny; \
    packed_data->args.nz = (GLfloat)_nz; \
    (packed_call_t *)packed_data; \
})
#define call_glNormalStream3fATI(packed, ret_v) do { \
    PACKED_glNormalStream3fATI *unpacked = (PACKED_glNormalStream3fATI *)packed; \
    ARGS_glNormalStream3fATI *args = (ARGS_glNormalStream3fATI *)&unpacked->args; \
    glNormalStream3fATI(args->stream, args->nx, args->ny, args->nz);; \
} while(0)
void glNormalStream3fATI(glNormalStream3fATI_ARG_EXPAND);
typedef void (*glNormalStream3fATI_PTR)(glNormalStream3fATI_ARG_EXPAND);
#define glNormalStream3fvATI_INDEX 1487
#define glNormalStream3fvATI_RETURN void
#define glNormalStream3fvATI_ARG_NAMES stream, coords
#define glNormalStream3fvATI_ARG_EXPAND GLenum stream, const GLfloat * coords
#define glNormalStream3fvATI_PACKED PACKED_glNormalStream3fvATI
#define glNormalStream3fvATI_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glNormalStream3fvATI_NOT_VOID_WRAP(...) {}
#define pack_glNormalStream3fvATI(_stream, _coords) ({ \
    glNormalStream3fvATI_PACKED *packed_data = malloc(sizeof(glNormalStream3fvATI_PACKED)); \
    packed_data->index = glNormalStream3fvATI_INDEX; \
    packed_data->args.stream = (GLenum)_stream; \
    packed_data->args.coords = (GLfloat *)_coords; \
    (packed_call_t *)packed_data; \
})
#define call_glNormalStream3fvATI(packed, ret_v) do { \
    PACKED_glNormalStream3fvATI *unpacked = (PACKED_glNormalStream3fvATI *)packed; \
    ARGS_glNormalStream3fvATI *args = (ARGS_glNormalStream3fvATI *)&unpacked->args; \
    glNormalStream3fvATI(args->stream, args->coords);; \
} while(0)
void glNormalStream3fvATI(glNormalStream3fvATI_ARG_EXPAND);
typedef void (*glNormalStream3fvATI_PTR)(glNormalStream3fvATI_ARG_EXPAND);
#define glNormalStream3iATI_INDEX 1488
#define glNormalStream3iATI_RETURN void
#define glNormalStream3iATI_ARG_NAMES stream, nx, ny, nz
#define glNormalStream3iATI_ARG_EXPAND GLenum stream, GLint nx, GLint ny, GLint nz
#define glNormalStream3iATI_PACKED PACKED_glNormalStream3iATI
#define glNormalStream3iATI_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glNormalStream3iATI_NOT_VOID_WRAP(...) {}
#define pack_glNormalStream3iATI(_stream, _nx, _ny, _nz) ({ \
    glNormalStream3iATI_PACKED *packed_data = malloc(sizeof(glNormalStream3iATI_PACKED)); \
    packed_data->index = glNormalStream3iATI_INDEX; \
    packed_data->args.stream = (GLenum)_stream; \
    packed_data->args.nx = (GLint)_nx; \
    packed_data->args.ny = (GLint)_ny; \
    packed_data->args.nz = (GLint)_nz; \
    (packed_call_t *)packed_data; \
})
#define call_glNormalStream3iATI(packed, ret_v) do { \
    PACKED_glNormalStream3iATI *unpacked = (PACKED_glNormalStream3iATI *)packed; \
    ARGS_glNormalStream3iATI *args = (ARGS_glNormalStream3iATI *)&unpacked->args; \
    glNormalStream3iATI(args->stream, args->nx, args->ny, args->nz);; \
} while(0)
void glNormalStream3iATI(glNormalStream3iATI_ARG_EXPAND);
typedef void (*glNormalStream3iATI_PTR)(glNormalStream3iATI_ARG_EXPAND);
#define glNormalStream3ivATI_INDEX 1489
#define glNormalStream3ivATI_RETURN void
#define glNormalStream3ivATI_ARG_NAMES stream, coords
#define glNormalStream3ivATI_ARG_EXPAND GLenum stream, const GLint * coords
#define glNormalStream3ivATI_PACKED PACKED_glNormalStream3ivATI
#define glNormalStream3ivATI_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glNormalStream3ivATI_NOT_VOID_WRAP(...) {}
#define pack_glNormalStream3ivATI(_stream, _coords) ({ \
    glNormalStream3ivATI_PACKED *packed_data = malloc(sizeof(glNormalStream3ivATI_PACKED)); \
    packed_data->index = glNormalStream3ivATI_INDEX; \
    packed_data->args.stream = (GLenum)_stream; \
    packed_data->args.coords = (GLint *)_coords; \
    (packed_call_t *)packed_data; \
})
#define call_glNormalStream3ivATI(packed, ret_v) do { \
    PACKED_glNormalStream3ivATI *unpacked = (PACKED_glNormalStream3ivATI *)packed; \
    ARGS_glNormalStream3ivATI *args = (ARGS_glNormalStream3ivATI *)&unpacked->args; \
    glNormalStream3ivATI(args->stream, args->coords);; \
} while(0)
void glNormalStream3ivATI(glNormalStream3ivATI_ARG_EXPAND);
typedef void (*glNormalStream3ivATI_PTR)(glNormalStream3ivATI_ARG_EXPAND);
#define glNormalStream3sATI_INDEX 1490
#define glNormalStream3sATI_RETURN void
#define glNormalStream3sATI_ARG_NAMES stream, nx, ny, nz
#define glNormalStream3sATI_ARG_EXPAND GLenum stream, GLshort nx, GLshort ny, GLshort nz
#define glNormalStream3sATI_PACKED PACKED_glNormalStream3sATI
#define glNormalStream3sATI_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glNormalStream3sATI_NOT_VOID_WRAP(...) {}
#define pack_glNormalStream3sATI(_stream, _nx, _ny, _nz) ({ \
    glNormalStream3sATI_PACKED *packed_data = malloc(sizeof(glNormalStream3sATI_PACKED)); \
    packed_data->index = glNormalStream3sATI_INDEX; \
    packed_data->args.stream = (GLenum)_stream; \
    packed_data->args.nx = (GLshort)_nx; \
    packed_data->args.ny = (GLshort)_ny; \
    packed_data->args.nz = (GLshort)_nz; \
    (packed_call_t *)packed_data; \
})
#define call_glNormalStream3sATI(packed, ret_v) do { \
    PACKED_glNormalStream3sATI *unpacked = (PACKED_glNormalStream3sATI *)packed; \
    ARGS_glNormalStream3sATI *args = (ARGS_glNormalStream3sATI *)&unpacked->args; \
    glNormalStream3sATI(args->stream, args->nx, args->ny, args->nz);; \
} while(0)
void glNormalStream3sATI(glNormalStream3sATI_ARG_EXPAND);
typedef void (*glNormalStream3sATI_PTR)(glNormalStream3sATI_ARG_EXPAND);
#define glNormalStream3svATI_INDEX 1491
#define glNormalStream3svATI_RETURN void
#define glNormalStream3svATI_ARG_NAMES stream, coords
#define glNormalStream3svATI_ARG_EXPAND GLenum stream, const GLshort * coords
#define glNormalStream3svATI_PACKED PACKED_glNormalStream3svATI
#define glNormalStream3svATI_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glNormalStream3svATI_NOT_VOID_WRAP(...) {}
#define pack_glNormalStream3svATI(_stream, _coords) ({ \
    glNormalStream3svATI_PACKED *packed_data = malloc(sizeof(glNormalStream3svATI_PACKED)); \
    packed_data->index = glNormalStream3svATI_INDEX; \
    packed_data->args.stream = (GLenum)_stream; \
    packed_data->args.coords = (GLshort *)_coords; \
    (packed_call_t *)packed_data; \
})
#define call_glNormalStream3svATI(packed, ret_v) do { \
    PACKED_glNormalStream3svATI *unpacked = (PACKED_glNormalStream3svATI *)packed; \
    ARGS_glNormalStream3svATI *args = (ARGS_glNormalStream3svATI *)&unpacked->args; \
    glNormalStream3svATI(args->stream, args->coords);; \
} while(0)
void glNormalStream3svATI(glNormalStream3svATI_ARG_EXPAND);
typedef void (*glNormalStream3svATI_PTR)(glNormalStream3svATI_ARG_EXPAND);
#define glObjectLabel_INDEX 1492
#define glObjectLabel_RETURN void
#define glObjectLabel_ARG_NAMES identifier, name, length, label
#define glObjectLabel_ARG_EXPAND GLenum identifier, GLuint name, GLsizei length, const GLchar * label
#define glObjectLabel_PACKED PACKED_glObjectLabel
#define glObjectLabel_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glObjectLabel_NOT_VOID_WRAP(...) {}
#define pack_glObjectLabel(_identifier, _name, _length, _label) ({ \
    glObjectLabel_PACKED *packed_data = malloc(sizeof(glObjectLabel_PACKED)); \
    packed_data->index = glObjectLabel_INDEX; \
    packed_data->args.identifier = (GLenum)_identifier; \
    packed_data->args.name = (GLuint)_name; \
    packed_data->args.length = (GLsizei)_length; \
    packed_data->args.label = (GLchar *)_label; \
    (packed_call_t *)packed_data; \
})
#define call_glObjectLabel(packed, ret_v) do { \
    PACKED_glObjectLabel *unpacked = (PACKED_glObjectLabel *)packed; \
    ARGS_glObjectLabel *args = (ARGS_glObjectLabel *)&unpacked->args; \
    glObjectLabel(args->identifier, args->name, args->length, args->label);; \
} while(0)
void glObjectLabel(glObjectLabel_ARG_EXPAND);
typedef void (*glObjectLabel_PTR)(glObjectLabel_ARG_EXPAND);
#define glObjectPtrLabel_INDEX 1493
#define glObjectPtrLabel_RETURN void
#define glObjectPtrLabel_ARG_NAMES ptr, length, label
#define glObjectPtrLabel_ARG_EXPAND const void * ptr, GLsizei length, const GLchar * label
#define glObjectPtrLabel_PACKED PACKED_glObjectPtrLabel
#define glObjectPtrLabel_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glObjectPtrLabel_NOT_VOID_WRAP(...) {}
#define pack_glObjectPtrLabel(_ptr, _length, _label) ({ \
    glObjectPtrLabel_PACKED *packed_data = malloc(sizeof(glObjectPtrLabel_PACKED)); \
    packed_data->index = glObjectPtrLabel_INDEX; \
    packed_data->args.ptr = (void *)_ptr; \
    packed_data->args.length = (GLsizei)_length; \
    packed_data->args.label = (GLchar *)_label; \
    (packed_call_t *)packed_data; \
})
#define call_glObjectPtrLabel(packed, ret_v) do { \
    PACKED_glObjectPtrLabel *unpacked = (PACKED_glObjectPtrLabel *)packed; \
    ARGS_glObjectPtrLabel *args = (ARGS_glObjectPtrLabel *)&unpacked->args; \
    glObjectPtrLabel(args->ptr, args->length, args->label);; \
} while(0)
void glObjectPtrLabel(glObjectPtrLabel_ARG_EXPAND);
typedef void (*glObjectPtrLabel_PTR)(glObjectPtrLabel_ARG_EXPAND);
#define glObjectPurgeableAPPLE_INDEX 1494
#define glObjectPurgeableAPPLE_RETURN GLenum
#define glObjectPurgeableAPPLE_ARG_NAMES objectType, name, option
#define glObjectPurgeableAPPLE_ARG_EXPAND GLenum objectType, GLuint name, GLenum option
#define glObjectPurgeableAPPLE_PACKED PACKED_glObjectPurgeableAPPLE
#define glObjectPurgeableAPPLE_VOID_ONLY_WRAP(...) {}
#define glObjectPurgeableAPPLE_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glObjectPurgeableAPPLE(_objectType, _name, _option) ({ \
    glObjectPurgeableAPPLE_PACKED *packed_data = malloc(sizeof(glObjectPurgeableAPPLE_PACKED)); \
    packed_data->index = glObjectPurgeableAPPLE_INDEX; \
    packed_data->args.objectType = (GLenum)_objectType; \
    packed_data->args.name = (GLuint)_name; \
    packed_data->args.option = (GLenum)_option; \
    (packed_call_t *)packed_data; \
})
#define call_glObjectPurgeableAPPLE(packed, ret_v) do { \
    PACKED_glObjectPurgeableAPPLE *unpacked = (PACKED_glObjectPurgeableAPPLE *)packed; \
    ARGS_glObjectPurgeableAPPLE *args = (ARGS_glObjectPurgeableAPPLE *)&unpacked->args; \
    GLenum *ret = (GLenum *)ret_v; \
    if (ret != NULL) { \
        *ret = glObjectPurgeableAPPLE(args->objectType, args->name, args->option);; \
    } else { \
        glObjectPurgeableAPPLE(args->objectType, args->name, args->option);; \
    } \
} while(0)
GLenum glObjectPurgeableAPPLE(glObjectPurgeableAPPLE_ARG_EXPAND);
typedef GLenum (*glObjectPurgeableAPPLE_PTR)(glObjectPurgeableAPPLE_ARG_EXPAND);
#define glObjectUnpurgeableAPPLE_INDEX 1495
#define glObjectUnpurgeableAPPLE_RETURN GLenum
#define glObjectUnpurgeableAPPLE_ARG_NAMES objectType, name, option
#define glObjectUnpurgeableAPPLE_ARG_EXPAND GLenum objectType, GLuint name, GLenum option
#define glObjectUnpurgeableAPPLE_PACKED PACKED_glObjectUnpurgeableAPPLE
#define glObjectUnpurgeableAPPLE_VOID_ONLY_WRAP(...) {}
#define glObjectUnpurgeableAPPLE_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glObjectUnpurgeableAPPLE(_objectType, _name, _option) ({ \
    glObjectUnpurgeableAPPLE_PACKED *packed_data = malloc(sizeof(glObjectUnpurgeableAPPLE_PACKED)); \
    packed_data->index = glObjectUnpurgeableAPPLE_INDEX; \
    packed_data->args.objectType = (GLenum)_objectType; \
    packed_data->args.name = (GLuint)_name; \
    packed_data->args.option = (GLenum)_option; \
    (packed_call_t *)packed_data; \
})
#define call_glObjectUnpurgeableAPPLE(packed, ret_v) do { \
    PACKED_glObjectUnpurgeableAPPLE *unpacked = (PACKED_glObjectUnpurgeableAPPLE *)packed; \
    ARGS_glObjectUnpurgeableAPPLE *args = (ARGS_glObjectUnpurgeableAPPLE *)&unpacked->args; \
    GLenum *ret = (GLenum *)ret_v; \
    if (ret != NULL) { \
        *ret = glObjectUnpurgeableAPPLE(args->objectType, args->name, args->option);; \
    } else { \
        glObjectUnpurgeableAPPLE(args->objectType, args->name, args->option);; \
    } \
} while(0)
GLenum glObjectUnpurgeableAPPLE(glObjectUnpurgeableAPPLE_ARG_EXPAND);
typedef GLenum (*glObjectUnpurgeableAPPLE_PTR)(glObjectUnpurgeableAPPLE_ARG_EXPAND);
#define glOrtho_INDEX 1496
#define glOrtho_RETURN void
#define glOrtho_ARG_NAMES left, right, bottom, top, zNear, zFar
#define glOrtho_ARG_EXPAND GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar
#define glOrtho_PACKED PACKED_glOrtho
#define glOrtho_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glOrtho_NOT_VOID_WRAP(...) {}
#define pack_glOrtho(_left, _right, _bottom, _top, _zNear, _zFar) ({ \
    glOrtho_PACKED *packed_data = malloc(sizeof(glOrtho_PACKED)); \
    packed_data->index = glOrtho_INDEX; \
    packed_data->args.left = (GLdouble)_left; \
    packed_data->args.right = (GLdouble)_right; \
    packed_data->args.bottom = (GLdouble)_bottom; \
    packed_data->args.top = (GLdouble)_top; \
    packed_data->args.zNear = (GLdouble)_zNear; \
    packed_data->args.zFar = (GLdouble)_zFar; \
    (packed_call_t *)packed_data; \
})
#define call_glOrtho(packed, ret_v) do { \
    PACKED_glOrtho *unpacked = (PACKED_glOrtho *)packed; \
    ARGS_glOrtho *args = (ARGS_glOrtho *)&unpacked->args; \
    glOrtho(args->left, args->right, args->bottom, args->top, args->zNear, args->zFar);; \
} while(0)
void glOrtho(glOrtho_ARG_EXPAND);
typedef void (*glOrtho_PTR)(glOrtho_ARG_EXPAND);
#define glOrthof_INDEX 1497
#define glOrthof_RETURN void
#define glOrthof_ARG_NAMES left, right, bottom, top, near, far
#define glOrthof_ARG_EXPAND GLfloat left, GLfloat right, GLfloat bottom, GLfloat top, GLfloat near, GLfloat far
#define glOrthof_PACKED PACKED_glOrthof
#define glOrthof_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glOrthof_NOT_VOID_WRAP(...) {}
#define pack_glOrthof(_left, _right, _bottom, _top, _near, _far) ({ \
    glOrthof_PACKED *packed_data = malloc(sizeof(glOrthof_PACKED)); \
    packed_data->index = glOrthof_INDEX; \
    packed_data->args.left = (GLfloat)_left; \
    packed_data->args.right = (GLfloat)_right; \
    packed_data->args.bottom = (GLfloat)_bottom; \
    packed_data->args.top = (GLfloat)_top; \
    packed_data->args.near = (GLfloat)_near; \
    packed_data->args.far = (GLfloat)_far; \
    (packed_call_t *)packed_data; \
})
#define call_glOrthof(packed, ret_v) do { \
    PACKED_glOrthof *unpacked = (PACKED_glOrthof *)packed; \
    ARGS_glOrthof *args = (ARGS_glOrthof *)&unpacked->args; \
    glOrthof(args->left, args->right, args->bottom, args->top, args->near, args->far);; \
} while(0)
void glOrthof(glOrthof_ARG_EXPAND);
typedef void (*glOrthof_PTR)(glOrthof_ARG_EXPAND);
#define glOrthofOES_INDEX 1498
#define glOrthofOES_RETURN void
#define glOrthofOES_ARG_NAMES l, r, b, t, n, f
#define glOrthofOES_ARG_EXPAND GLfloat l, GLfloat r, GLfloat b, GLfloat t, GLfloat n, GLfloat f
#define glOrthofOES_PACKED PACKED_glOrthofOES
#define glOrthofOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glOrthofOES_NOT_VOID_WRAP(...) {}
#define pack_glOrthofOES(_l, _r, _b, _t, _n, _f) ({ \
    glOrthofOES_PACKED *packed_data = malloc(sizeof(glOrthofOES_PACKED)); \
    packed_data->index = glOrthofOES_INDEX; \
    packed_data->args.l = (GLfloat)_l; \
    packed_data->args.r = (GLfloat)_r; \
    packed_data->args.b = (GLfloat)_b; \
    packed_data->args.t = (GLfloat)_t; \
    packed_data->args.n = (GLfloat)_n; \
    packed_data->args.f = (GLfloat)_f; \
    (packed_call_t *)packed_data; \
})
#define call_glOrthofOES(packed, ret_v) do { \
    PACKED_glOrthofOES *unpacked = (PACKED_glOrthofOES *)packed; \
    ARGS_glOrthofOES *args = (ARGS_glOrthofOES *)&unpacked->args; \
    glOrthofOES(args->l, args->r, args->b, args->t, args->n, args->f);; \
} while(0)
void glOrthofOES(glOrthofOES_ARG_EXPAND);
typedef void (*glOrthofOES_PTR)(glOrthofOES_ARG_EXPAND);
#define glOrthox_INDEX 1499
#define glOrthox_RETURN void
#define glOrthox_ARG_NAMES left, right, bottom, top, near, far
#define glOrthox_ARG_EXPAND GLfixed left, GLfixed right, GLfixed bottom, GLfixed top, GLfixed near, GLfixed far
#define glOrthox_PACKED PACKED_glOrthox
#define glOrthox_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glOrthox_NOT_VOID_WRAP(...) {}
#define pack_glOrthox(_left, _right, _bottom, _top, _near, _far) ({ \
    glOrthox_PACKED *packed_data = malloc(sizeof(glOrthox_PACKED)); \
    packed_data->index = glOrthox_INDEX; \
    packed_data->args.left = (GLfixed)_left; \
    packed_data->args.right = (GLfixed)_right; \
    packed_data->args.bottom = (GLfixed)_bottom; \
    packed_data->args.top = (GLfixed)_top; \
    packed_data->args.near = (GLfixed)_near; \
    packed_data->args.far = (GLfixed)_far; \
    (packed_call_t *)packed_data; \
})
#define call_glOrthox(packed, ret_v) do { \
    PACKED_glOrthox *unpacked = (PACKED_glOrthox *)packed; \
    ARGS_glOrthox *args = (ARGS_glOrthox *)&unpacked->args; \
    glOrthox(args->left, args->right, args->bottom, args->top, args->near, args->far);; \
} while(0)
void glOrthox(glOrthox_ARG_EXPAND);
typedef void (*glOrthox_PTR)(glOrthox_ARG_EXPAND);
#define glOrthoxOES_INDEX 1500
#define glOrthoxOES_RETURN void
#define glOrthoxOES_ARG_NAMES l, r, b, t, n, f
#define glOrthoxOES_ARG_EXPAND GLfixed l, GLfixed r, GLfixed b, GLfixed t, GLfixed n, GLfixed f
#define glOrthoxOES_PACKED PACKED_glOrthoxOES
#define glOrthoxOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glOrthoxOES_NOT_VOID_WRAP(...) {}
#define pack_glOrthoxOES(_l, _r, _b, _t, _n, _f) ({ \
    glOrthoxOES_PACKED *packed_data = malloc(sizeof(glOrthoxOES_PACKED)); \
    packed_data->index = glOrthoxOES_INDEX; \
    packed_data->args.l = (GLfixed)_l; \
    packed_data->args.r = (GLfixed)_r; \
    packed_data->args.b = (GLfixed)_b; \
    packed_data->args.t = (GLfixed)_t; \
    packed_data->args.n = (GLfixed)_n; \
    packed_data->args.f = (GLfixed)_f; \
    (packed_call_t *)packed_data; \
})
#define call_glOrthoxOES(packed, ret_v) do { \
    PACKED_glOrthoxOES *unpacked = (PACKED_glOrthoxOES *)packed; \
    ARGS_glOrthoxOES *args = (ARGS_glOrthoxOES *)&unpacked->args; \
    glOrthoxOES(args->l, args->r, args->b, args->t, args->n, args->f);; \
} while(0)
void glOrthoxOES(glOrthoxOES_ARG_EXPAND);
typedef void (*glOrthoxOES_PTR)(glOrthoxOES_ARG_EXPAND);
#define glPNTrianglesfATI_INDEX 1501
#define glPNTrianglesfATI_RETURN void
#define glPNTrianglesfATI_ARG_NAMES pname, param
#define glPNTrianglesfATI_ARG_EXPAND GLenum pname, GLfloat param
#define glPNTrianglesfATI_PACKED PACKED_glPNTrianglesfATI
#define glPNTrianglesfATI_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glPNTrianglesfATI_NOT_VOID_WRAP(...) {}
#define pack_glPNTrianglesfATI(_pname, _param) ({ \
    glPNTrianglesfATI_PACKED *packed_data = malloc(sizeof(glPNTrianglesfATI_PACKED)); \
    packed_data->index = glPNTrianglesfATI_INDEX; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.param = (GLfloat)_param; \
    (packed_call_t *)packed_data; \
})
#define call_glPNTrianglesfATI(packed, ret_v) do { \
    PACKED_glPNTrianglesfATI *unpacked = (PACKED_glPNTrianglesfATI *)packed; \
    ARGS_glPNTrianglesfATI *args = (ARGS_glPNTrianglesfATI *)&unpacked->args; \
    glPNTrianglesfATI(args->pname, args->param);; \
} while(0)
void glPNTrianglesfATI(glPNTrianglesfATI_ARG_EXPAND);
typedef void (*glPNTrianglesfATI_PTR)(glPNTrianglesfATI_ARG_EXPAND);
#define glPNTrianglesiATI_INDEX 1502
#define glPNTrianglesiATI_RETURN void
#define glPNTrianglesiATI_ARG_NAMES pname, param
#define glPNTrianglesiATI_ARG_EXPAND GLenum pname, GLint param
#define glPNTrianglesiATI_PACKED PACKED_glPNTrianglesiATI
#define glPNTrianglesiATI_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glPNTrianglesiATI_NOT_VOID_WRAP(...) {}
#define pack_glPNTrianglesiATI(_pname, _param) ({ \
    glPNTrianglesiATI_PACKED *packed_data = malloc(sizeof(glPNTrianglesiATI_PACKED)); \
    packed_data->index = glPNTrianglesiATI_INDEX; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.param = (GLint)_param; \
    (packed_call_t *)packed_data; \
})
#define call_glPNTrianglesiATI(packed, ret_v) do { \
    PACKED_glPNTrianglesiATI *unpacked = (PACKED_glPNTrianglesiATI *)packed; \
    ARGS_glPNTrianglesiATI *args = (ARGS_glPNTrianglesiATI *)&unpacked->args; \
    glPNTrianglesiATI(args->pname, args->param);; \
} while(0)
void glPNTrianglesiATI(glPNTrianglesiATI_ARG_EXPAND);
typedef void (*glPNTrianglesiATI_PTR)(glPNTrianglesiATI_ARG_EXPAND);
#define glPassTexCoordATI_INDEX 1503
#define glPassTexCoordATI_RETURN void
#define glPassTexCoordATI_ARG_NAMES dst, coord, swizzle
#define glPassTexCoordATI_ARG_EXPAND GLuint dst, GLuint coord, GLenum swizzle
#define glPassTexCoordATI_PACKED PACKED_glPassTexCoordATI
#define glPassTexCoordATI_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glPassTexCoordATI_NOT_VOID_WRAP(...) {}
#define pack_glPassTexCoordATI(_dst, _coord, _swizzle) ({ \
    glPassTexCoordATI_PACKED *packed_data = malloc(sizeof(glPassTexCoordATI_PACKED)); \
    packed_data->index = glPassTexCoordATI_INDEX; \
    packed_data->args.dst = (GLuint)_dst; \
    packed_data->args.coord = (GLuint)_coord; \
    packed_data->args.swizzle = (GLenum)_swizzle; \
    (packed_call_t *)packed_data; \
})
#define call_glPassTexCoordATI(packed, ret_v) do { \
    PACKED_glPassTexCoordATI *unpacked = (PACKED_glPassTexCoordATI *)packed; \
    ARGS_glPassTexCoordATI *args = (ARGS_glPassTexCoordATI *)&unpacked->args; \
    glPassTexCoordATI(args->dst, args->coord, args->swizzle);; \
} while(0)
void glPassTexCoordATI(glPassTexCoordATI_ARG_EXPAND);
typedef void (*glPassTexCoordATI_PTR)(glPassTexCoordATI_ARG_EXPAND);
#define glPassThrough_INDEX 1504
#define glPassThrough_RETURN void
#define glPassThrough_ARG_NAMES token
#define glPassThrough_ARG_EXPAND GLfloat token
#define glPassThrough_PACKED PACKED_glPassThrough
#define glPassThrough_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glPassThrough_NOT_VOID_WRAP(...) {}
#define pack_glPassThrough(_token) ({ \
    glPassThrough_PACKED *packed_data = malloc(sizeof(glPassThrough_PACKED)); \
    packed_data->index = glPassThrough_INDEX; \
    packed_data->args.token = (GLfloat)_token; \
    (packed_call_t *)packed_data; \
})
#define call_glPassThrough(packed, ret_v) do { \
    PACKED_glPassThrough *unpacked = (PACKED_glPassThrough *)packed; \
    ARGS_glPassThrough *args = (ARGS_glPassThrough *)&unpacked->args; \
    glPassThrough(args->token);; \
} while(0)
void glPassThrough(glPassThrough_ARG_EXPAND);
typedef void (*glPassThrough_PTR)(glPassThrough_ARG_EXPAND);
#define glPassThroughxOES_INDEX 1505
#define glPassThroughxOES_RETURN void
#define glPassThroughxOES_ARG_NAMES token
#define glPassThroughxOES_ARG_EXPAND GLfixed token
#define glPassThroughxOES_PACKED PACKED_glPassThroughxOES
#define glPassThroughxOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glPassThroughxOES_NOT_VOID_WRAP(...) {}
#define pack_glPassThroughxOES(_token) ({ \
    glPassThroughxOES_PACKED *packed_data = malloc(sizeof(glPassThroughxOES_PACKED)); \
    packed_data->index = glPassThroughxOES_INDEX; \
    packed_data->args.token = (GLfixed)_token; \
    (packed_call_t *)packed_data; \
})
#define call_glPassThroughxOES(packed, ret_v) do { \
    PACKED_glPassThroughxOES *unpacked = (PACKED_glPassThroughxOES *)packed; \
    ARGS_glPassThroughxOES *args = (ARGS_glPassThroughxOES *)&unpacked->args; \
    glPassThroughxOES(args->token);; \
} while(0)
void glPassThroughxOES(glPassThroughxOES_ARG_EXPAND);
typedef void (*glPassThroughxOES_PTR)(glPassThroughxOES_ARG_EXPAND);
#define glPatchParameterfv_INDEX 1506
#define glPatchParameterfv_RETURN void
#define glPatchParameterfv_ARG_NAMES pname, values
#define glPatchParameterfv_ARG_EXPAND GLenum pname, const GLfloat * values
#define glPatchParameterfv_PACKED PACKED_glPatchParameterfv
#define glPatchParameterfv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glPatchParameterfv_NOT_VOID_WRAP(...) {}
#define pack_glPatchParameterfv(_pname, _values) ({ \
    glPatchParameterfv_PACKED *packed_data = malloc(sizeof(glPatchParameterfv_PACKED)); \
    packed_data->index = glPatchParameterfv_INDEX; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.values = (GLfloat *)_values; \
    (packed_call_t *)packed_data; \
})
#define call_glPatchParameterfv(packed, ret_v) do { \
    PACKED_glPatchParameterfv *unpacked = (PACKED_glPatchParameterfv *)packed; \
    ARGS_glPatchParameterfv *args = (ARGS_glPatchParameterfv *)&unpacked->args; \
    glPatchParameterfv(args->pname, args->values);; \
} while(0)
void glPatchParameterfv(glPatchParameterfv_ARG_EXPAND);
typedef void (*glPatchParameterfv_PTR)(glPatchParameterfv_ARG_EXPAND);
#define glPatchParameteri_INDEX 1507
#define glPatchParameteri_RETURN void
#define glPatchParameteri_ARG_NAMES pname, value
#define glPatchParameteri_ARG_EXPAND GLenum pname, GLint value
#define glPatchParameteri_PACKED PACKED_glPatchParameteri
#define glPatchParameteri_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glPatchParameteri_NOT_VOID_WRAP(...) {}
#define pack_glPatchParameteri(_pname, _value) ({ \
    glPatchParameteri_PACKED *packed_data = malloc(sizeof(glPatchParameteri_PACKED)); \
    packed_data->index = glPatchParameteri_INDEX; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.value = (GLint)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glPatchParameteri(packed, ret_v) do { \
    PACKED_glPatchParameteri *unpacked = (PACKED_glPatchParameteri *)packed; \
    ARGS_glPatchParameteri *args = (ARGS_glPatchParameteri *)&unpacked->args; \
    glPatchParameteri(args->pname, args->value);; \
} while(0)
void glPatchParameteri(glPatchParameteri_ARG_EXPAND);
typedef void (*glPatchParameteri_PTR)(glPatchParameteri_ARG_EXPAND);
#define glPathColorGenNV_INDEX 1508
#define glPathColorGenNV_RETURN void
#define glPathColorGenNV_ARG_NAMES color, genMode, colorFormat, coeffs
#define glPathColorGenNV_ARG_EXPAND GLenum color, GLenum genMode, GLenum colorFormat, const GLfloat * coeffs
#define glPathColorGenNV_PACKED PACKED_glPathColorGenNV
#define glPathColorGenNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glPathColorGenNV_NOT_VOID_WRAP(...) {}
#define pack_glPathColorGenNV(_color, _genMode, _colorFormat, _coeffs) ({ \
    glPathColorGenNV_PACKED *packed_data = malloc(sizeof(glPathColorGenNV_PACKED)); \
    packed_data->index = glPathColorGenNV_INDEX; \
    packed_data->args.color = (GLenum)_color; \
    packed_data->args.genMode = (GLenum)_genMode; \
    packed_data->args.colorFormat = (GLenum)_colorFormat; \
    packed_data->args.coeffs = (GLfloat *)_coeffs; \
    (packed_call_t *)packed_data; \
})
#define call_glPathColorGenNV(packed, ret_v) do { \
    PACKED_glPathColorGenNV *unpacked = (PACKED_glPathColorGenNV *)packed; \
    ARGS_glPathColorGenNV *args = (ARGS_glPathColorGenNV *)&unpacked->args; \
    glPathColorGenNV(args->color, args->genMode, args->colorFormat, args->coeffs);; \
} while(0)
void glPathColorGenNV(glPathColorGenNV_ARG_EXPAND);
typedef void (*glPathColorGenNV_PTR)(glPathColorGenNV_ARG_EXPAND);
#define glPathCommandsNV_INDEX 1509
#define glPathCommandsNV_RETURN void
#define glPathCommandsNV_ARG_NAMES path, numCommands, commands, numCoords, coordType, coords
#define glPathCommandsNV_ARG_EXPAND GLuint path, GLsizei numCommands, const GLubyte * commands, GLsizei numCoords, GLenum coordType, const GLvoid * coords
#define glPathCommandsNV_PACKED PACKED_glPathCommandsNV
#define glPathCommandsNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glPathCommandsNV_NOT_VOID_WRAP(...) {}
#define pack_glPathCommandsNV(_path, _numCommands, _commands, _numCoords, _coordType, _coords) ({ \
    glPathCommandsNV_PACKED *packed_data = malloc(sizeof(glPathCommandsNV_PACKED)); \
    packed_data->index = glPathCommandsNV_INDEX; \
    packed_data->args.path = (GLuint)_path; \
    packed_data->args.numCommands = (GLsizei)_numCommands; \
    packed_data->args.commands = (GLubyte *)_commands; \
    packed_data->args.numCoords = (GLsizei)_numCoords; \
    packed_data->args.coordType = (GLenum)_coordType; \
    packed_data->args.coords = (GLvoid *)_coords; \
    (packed_call_t *)packed_data; \
})
#define call_glPathCommandsNV(packed, ret_v) do { \
    PACKED_glPathCommandsNV *unpacked = (PACKED_glPathCommandsNV *)packed; \
    ARGS_glPathCommandsNV *args = (ARGS_glPathCommandsNV *)&unpacked->args; \
    glPathCommandsNV(args->path, args->numCommands, args->commands, args->numCoords, args->coordType, args->coords);; \
} while(0)
void glPathCommandsNV(glPathCommandsNV_ARG_EXPAND);
typedef void (*glPathCommandsNV_PTR)(glPathCommandsNV_ARG_EXPAND);
#define glPathCoordsNV_INDEX 1510
#define glPathCoordsNV_RETURN void
#define glPathCoordsNV_ARG_NAMES path, numCoords, coordType, coords
#define glPathCoordsNV_ARG_EXPAND GLuint path, GLsizei numCoords, GLenum coordType, const GLvoid * coords
#define glPathCoordsNV_PACKED PACKED_glPathCoordsNV
#define glPathCoordsNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glPathCoordsNV_NOT_VOID_WRAP(...) {}
#define pack_glPathCoordsNV(_path, _numCoords, _coordType, _coords) ({ \
    glPathCoordsNV_PACKED *packed_data = malloc(sizeof(glPathCoordsNV_PACKED)); \
    packed_data->index = glPathCoordsNV_INDEX; \
    packed_data->args.path = (GLuint)_path; \
    packed_data->args.numCoords = (GLsizei)_numCoords; \
    packed_data->args.coordType = (GLenum)_coordType; \
    packed_data->args.coords = (GLvoid *)_coords; \
    (packed_call_t *)packed_data; \
})
#define call_glPathCoordsNV(packed, ret_v) do { \
    PACKED_glPathCoordsNV *unpacked = (PACKED_glPathCoordsNV *)packed; \
    ARGS_glPathCoordsNV *args = (ARGS_glPathCoordsNV *)&unpacked->args; \
    glPathCoordsNV(args->path, args->numCoords, args->coordType, args->coords);; \
} while(0)
void glPathCoordsNV(glPathCoordsNV_ARG_EXPAND);
typedef void (*glPathCoordsNV_PTR)(glPathCoordsNV_ARG_EXPAND);
#define glPathCoverDepthFuncNV_INDEX 1511
#define glPathCoverDepthFuncNV_RETURN void
#define glPathCoverDepthFuncNV_ARG_NAMES func
#define glPathCoverDepthFuncNV_ARG_EXPAND GLenum func
#define glPathCoverDepthFuncNV_PACKED PACKED_glPathCoverDepthFuncNV
#define glPathCoverDepthFuncNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glPathCoverDepthFuncNV_NOT_VOID_WRAP(...) {}
#define pack_glPathCoverDepthFuncNV(_func) ({ \
    glPathCoverDepthFuncNV_PACKED *packed_data = malloc(sizeof(glPathCoverDepthFuncNV_PACKED)); \
    packed_data->index = glPathCoverDepthFuncNV_INDEX; \
    packed_data->args.func = (GLenum)_func; \
    (packed_call_t *)packed_data; \
})
#define call_glPathCoverDepthFuncNV(packed, ret_v) do { \
    PACKED_glPathCoverDepthFuncNV *unpacked = (PACKED_glPathCoverDepthFuncNV *)packed; \
    ARGS_glPathCoverDepthFuncNV *args = (ARGS_glPathCoverDepthFuncNV *)&unpacked->args; \
    glPathCoverDepthFuncNV(args->func);; \
} while(0)
void glPathCoverDepthFuncNV(glPathCoverDepthFuncNV_ARG_EXPAND);
typedef void (*glPathCoverDepthFuncNV_PTR)(glPathCoverDepthFuncNV_ARG_EXPAND);
#define glPathDashArrayNV_INDEX 1512
#define glPathDashArrayNV_RETURN void
#define glPathDashArrayNV_ARG_NAMES path, dashCount, dashArray
#define glPathDashArrayNV_ARG_EXPAND GLuint path, GLsizei dashCount, const GLfloat * dashArray
#define glPathDashArrayNV_PACKED PACKED_glPathDashArrayNV
#define glPathDashArrayNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glPathDashArrayNV_NOT_VOID_WRAP(...) {}
#define pack_glPathDashArrayNV(_path, _dashCount, _dashArray) ({ \
    glPathDashArrayNV_PACKED *packed_data = malloc(sizeof(glPathDashArrayNV_PACKED)); \
    packed_data->index = glPathDashArrayNV_INDEX; \
    packed_data->args.path = (GLuint)_path; \
    packed_data->args.dashCount = (GLsizei)_dashCount; \
    packed_data->args.dashArray = (GLfloat *)_dashArray; \
    (packed_call_t *)packed_data; \
})
#define call_glPathDashArrayNV(packed, ret_v) do { \
    PACKED_glPathDashArrayNV *unpacked = (PACKED_glPathDashArrayNV *)packed; \
    ARGS_glPathDashArrayNV *args = (ARGS_glPathDashArrayNV *)&unpacked->args; \
    glPathDashArrayNV(args->path, args->dashCount, args->dashArray);; \
} while(0)
void glPathDashArrayNV(glPathDashArrayNV_ARG_EXPAND);
typedef void (*glPathDashArrayNV_PTR)(glPathDashArrayNV_ARG_EXPAND);
#define glPathFogGenNV_INDEX 1513
#define glPathFogGenNV_RETURN void
#define glPathFogGenNV_ARG_NAMES genMode
#define glPathFogGenNV_ARG_EXPAND GLenum genMode
#define glPathFogGenNV_PACKED PACKED_glPathFogGenNV
#define glPathFogGenNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glPathFogGenNV_NOT_VOID_WRAP(...) {}
#define pack_glPathFogGenNV(_genMode) ({ \
    glPathFogGenNV_PACKED *packed_data = malloc(sizeof(glPathFogGenNV_PACKED)); \
    packed_data->index = glPathFogGenNV_INDEX; \
    packed_data->args.genMode = (GLenum)_genMode; \
    (packed_call_t *)packed_data; \
})
#define call_glPathFogGenNV(packed, ret_v) do { \
    PACKED_glPathFogGenNV *unpacked = (PACKED_glPathFogGenNV *)packed; \
    ARGS_glPathFogGenNV *args = (ARGS_glPathFogGenNV *)&unpacked->args; \
    glPathFogGenNV(args->genMode);; \
} while(0)
void glPathFogGenNV(glPathFogGenNV_ARG_EXPAND);
typedef void (*glPathFogGenNV_PTR)(glPathFogGenNV_ARG_EXPAND);
#define glPathGlyphRangeNV_INDEX 1514
#define glPathGlyphRangeNV_RETURN void
#define glPathGlyphRangeNV_ARG_NAMES firstPathName, fontTarget, fontName, fontStyle, firstGlyph, numGlyphs, handleMissingGlyphs, pathParameterTemplate, emScale
#define glPathGlyphRangeNV_ARG_EXPAND GLuint firstPathName, GLenum fontTarget, const GLvoid * fontName, GLbitfield fontStyle, GLuint firstGlyph, GLsizei numGlyphs, GLenum handleMissingGlyphs, GLuint pathParameterTemplate, GLfloat emScale
#define glPathGlyphRangeNV_PACKED PACKED_glPathGlyphRangeNV
#define glPathGlyphRangeNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glPathGlyphRangeNV_NOT_VOID_WRAP(...) {}
#define pack_glPathGlyphRangeNV(_firstPathName, _fontTarget, _fontName, _fontStyle, _firstGlyph, _numGlyphs, _handleMissingGlyphs, _pathParameterTemplate, _emScale) ({ \
    glPathGlyphRangeNV_PACKED *packed_data = malloc(sizeof(glPathGlyphRangeNV_PACKED)); \
    packed_data->index = glPathGlyphRangeNV_INDEX; \
    packed_data->args.firstPathName = (GLuint)_firstPathName; \
    packed_data->args.fontTarget = (GLenum)_fontTarget; \
    packed_data->args.fontName = (GLvoid *)_fontName; \
    packed_data->args.fontStyle = (GLbitfield)_fontStyle; \
    packed_data->args.firstGlyph = (GLuint)_firstGlyph; \
    packed_data->args.numGlyphs = (GLsizei)_numGlyphs; \
    packed_data->args.handleMissingGlyphs = (GLenum)_handleMissingGlyphs; \
    packed_data->args.pathParameterTemplate = (GLuint)_pathParameterTemplate; \
    packed_data->args.emScale = (GLfloat)_emScale; \
    (packed_call_t *)packed_data; \
})
#define call_glPathGlyphRangeNV(packed, ret_v) do { \
    PACKED_glPathGlyphRangeNV *unpacked = (PACKED_glPathGlyphRangeNV *)packed; \
    ARGS_glPathGlyphRangeNV *args = (ARGS_glPathGlyphRangeNV *)&unpacked->args; \
    glPathGlyphRangeNV(args->firstPathName, args->fontTarget, args->fontName, args->fontStyle, args->firstGlyph, args->numGlyphs, args->handleMissingGlyphs, args->pathParameterTemplate, args->emScale);; \
} while(0)
void glPathGlyphRangeNV(glPathGlyphRangeNV_ARG_EXPAND);
typedef void (*glPathGlyphRangeNV_PTR)(glPathGlyphRangeNV_ARG_EXPAND);
#define glPathGlyphsNV_INDEX 1515
#define glPathGlyphsNV_RETURN void
#define glPathGlyphsNV_ARG_NAMES firstPathName, fontTarget, fontName, fontStyle, numGlyphs, type, charcodes, handleMissingGlyphs, pathParameterTemplate, emScale
#define glPathGlyphsNV_ARG_EXPAND GLuint firstPathName, GLenum fontTarget, const GLvoid * fontName, GLbitfield fontStyle, GLsizei numGlyphs, GLenum type, const GLvoid * charcodes, GLenum handleMissingGlyphs, GLuint pathParameterTemplate, GLfloat emScale
#define glPathGlyphsNV_PACKED PACKED_glPathGlyphsNV
#define glPathGlyphsNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glPathGlyphsNV_NOT_VOID_WRAP(...) {}
#define pack_glPathGlyphsNV(_firstPathName, _fontTarget, _fontName, _fontStyle, _numGlyphs, _type, _charcodes, _handleMissingGlyphs, _pathParameterTemplate, _emScale) ({ \
    glPathGlyphsNV_PACKED *packed_data = malloc(sizeof(glPathGlyphsNV_PACKED)); \
    packed_data->index = glPathGlyphsNV_INDEX; \
    packed_data->args.firstPathName = (GLuint)_firstPathName; \
    packed_data->args.fontTarget = (GLenum)_fontTarget; \
    packed_data->args.fontName = (GLvoid *)_fontName; \
    packed_data->args.fontStyle = (GLbitfield)_fontStyle; \
    packed_data->args.numGlyphs = (GLsizei)_numGlyphs; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.charcodes = (GLvoid *)_charcodes; \
    packed_data->args.handleMissingGlyphs = (GLenum)_handleMissingGlyphs; \
    packed_data->args.pathParameterTemplate = (GLuint)_pathParameterTemplate; \
    packed_data->args.emScale = (GLfloat)_emScale; \
    (packed_call_t *)packed_data; \
})
#define call_glPathGlyphsNV(packed, ret_v) do { \
    PACKED_glPathGlyphsNV *unpacked = (PACKED_glPathGlyphsNV *)packed; \
    ARGS_glPathGlyphsNV *args = (ARGS_glPathGlyphsNV *)&unpacked->args; \
    glPathGlyphsNV(args->firstPathName, args->fontTarget, args->fontName, args->fontStyle, args->numGlyphs, args->type, args->charcodes, args->handleMissingGlyphs, args->pathParameterTemplate, args->emScale);; \
} while(0)
void glPathGlyphsNV(glPathGlyphsNV_ARG_EXPAND);
typedef void (*glPathGlyphsNV_PTR)(glPathGlyphsNV_ARG_EXPAND);
#define glPathParameterfNV_INDEX 1516
#define glPathParameterfNV_RETURN void
#define glPathParameterfNV_ARG_NAMES path, pname, value
#define glPathParameterfNV_ARG_EXPAND GLuint path, GLenum pname, GLfloat value
#define glPathParameterfNV_PACKED PACKED_glPathParameterfNV
#define glPathParameterfNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glPathParameterfNV_NOT_VOID_WRAP(...) {}
#define pack_glPathParameterfNV(_path, _pname, _value) ({ \
    glPathParameterfNV_PACKED *packed_data = malloc(sizeof(glPathParameterfNV_PACKED)); \
    packed_data->index = glPathParameterfNV_INDEX; \
    packed_data->args.path = (GLuint)_path; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.value = (GLfloat)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glPathParameterfNV(packed, ret_v) do { \
    PACKED_glPathParameterfNV *unpacked = (PACKED_glPathParameterfNV *)packed; \
    ARGS_glPathParameterfNV *args = (ARGS_glPathParameterfNV *)&unpacked->args; \
    glPathParameterfNV(args->path, args->pname, args->value);; \
} while(0)
void glPathParameterfNV(glPathParameterfNV_ARG_EXPAND);
typedef void (*glPathParameterfNV_PTR)(glPathParameterfNV_ARG_EXPAND);
#define glPathParameterfvNV_INDEX 1517
#define glPathParameterfvNV_RETURN void
#define glPathParameterfvNV_ARG_NAMES path, pname, value
#define glPathParameterfvNV_ARG_EXPAND GLuint path, GLenum pname, const GLfloat * value
#define glPathParameterfvNV_PACKED PACKED_glPathParameterfvNV
#define glPathParameterfvNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glPathParameterfvNV_NOT_VOID_WRAP(...) {}
#define pack_glPathParameterfvNV(_path, _pname, _value) ({ \
    glPathParameterfvNV_PACKED *packed_data = malloc(sizeof(glPathParameterfvNV_PACKED)); \
    packed_data->index = glPathParameterfvNV_INDEX; \
    packed_data->args.path = (GLuint)_path; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.value = (GLfloat *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glPathParameterfvNV(packed, ret_v) do { \
    PACKED_glPathParameterfvNV *unpacked = (PACKED_glPathParameterfvNV *)packed; \
    ARGS_glPathParameterfvNV *args = (ARGS_glPathParameterfvNV *)&unpacked->args; \
    glPathParameterfvNV(args->path, args->pname, args->value);; \
} while(0)
void glPathParameterfvNV(glPathParameterfvNV_ARG_EXPAND);
typedef void (*glPathParameterfvNV_PTR)(glPathParameterfvNV_ARG_EXPAND);
#define glPathParameteriNV_INDEX 1518
#define glPathParameteriNV_RETURN void
#define glPathParameteriNV_ARG_NAMES path, pname, value
#define glPathParameteriNV_ARG_EXPAND GLuint path, GLenum pname, GLint value
#define glPathParameteriNV_PACKED PACKED_glPathParameteriNV
#define glPathParameteriNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glPathParameteriNV_NOT_VOID_WRAP(...) {}
#define pack_glPathParameteriNV(_path, _pname, _value) ({ \
    glPathParameteriNV_PACKED *packed_data = malloc(sizeof(glPathParameteriNV_PACKED)); \
    packed_data->index = glPathParameteriNV_INDEX; \
    packed_data->args.path = (GLuint)_path; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.value = (GLint)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glPathParameteriNV(packed, ret_v) do { \
    PACKED_glPathParameteriNV *unpacked = (PACKED_glPathParameteriNV *)packed; \
    ARGS_glPathParameteriNV *args = (ARGS_glPathParameteriNV *)&unpacked->args; \
    glPathParameteriNV(args->path, args->pname, args->value);; \
} while(0)
void glPathParameteriNV(glPathParameteriNV_ARG_EXPAND);
typedef void (*glPathParameteriNV_PTR)(glPathParameteriNV_ARG_EXPAND);
#define glPathParameterivNV_INDEX 1519
#define glPathParameterivNV_RETURN void
#define glPathParameterivNV_ARG_NAMES path, pname, value
#define glPathParameterivNV_ARG_EXPAND GLuint path, GLenum pname, const GLint * value
#define glPathParameterivNV_PACKED PACKED_glPathParameterivNV
#define glPathParameterivNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glPathParameterivNV_NOT_VOID_WRAP(...) {}
#define pack_glPathParameterivNV(_path, _pname, _value) ({ \
    glPathParameterivNV_PACKED *packed_data = malloc(sizeof(glPathParameterivNV_PACKED)); \
    packed_data->index = glPathParameterivNV_INDEX; \
    packed_data->args.path = (GLuint)_path; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.value = (GLint *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glPathParameterivNV(packed, ret_v) do { \
    PACKED_glPathParameterivNV *unpacked = (PACKED_glPathParameterivNV *)packed; \
    ARGS_glPathParameterivNV *args = (ARGS_glPathParameterivNV *)&unpacked->args; \
    glPathParameterivNV(args->path, args->pname, args->value);; \
} while(0)
void glPathParameterivNV(glPathParameterivNV_ARG_EXPAND);
typedef void (*glPathParameterivNV_PTR)(glPathParameterivNV_ARG_EXPAND);
#define glPathStencilDepthOffsetNV_INDEX 1520
#define glPathStencilDepthOffsetNV_RETURN void
#define glPathStencilDepthOffsetNV_ARG_NAMES factor, units
#define glPathStencilDepthOffsetNV_ARG_EXPAND GLfloat factor, GLfloat units
#define glPathStencilDepthOffsetNV_PACKED PACKED_glPathStencilDepthOffsetNV
#define glPathStencilDepthOffsetNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glPathStencilDepthOffsetNV_NOT_VOID_WRAP(...) {}
#define pack_glPathStencilDepthOffsetNV(_factor, _units) ({ \
    glPathStencilDepthOffsetNV_PACKED *packed_data = malloc(sizeof(glPathStencilDepthOffsetNV_PACKED)); \
    packed_data->index = glPathStencilDepthOffsetNV_INDEX; \
    packed_data->args.factor = (GLfloat)_factor; \
    packed_data->args.units = (GLfloat)_units; \
    (packed_call_t *)packed_data; \
})
#define call_glPathStencilDepthOffsetNV(packed, ret_v) do { \
    PACKED_glPathStencilDepthOffsetNV *unpacked = (PACKED_glPathStencilDepthOffsetNV *)packed; \
    ARGS_glPathStencilDepthOffsetNV *args = (ARGS_glPathStencilDepthOffsetNV *)&unpacked->args; \
    glPathStencilDepthOffsetNV(args->factor, args->units);; \
} while(0)
void glPathStencilDepthOffsetNV(glPathStencilDepthOffsetNV_ARG_EXPAND);
typedef void (*glPathStencilDepthOffsetNV_PTR)(glPathStencilDepthOffsetNV_ARG_EXPAND);
#define glPathStencilFuncNV_INDEX 1521
#define glPathStencilFuncNV_RETURN void
#define glPathStencilFuncNV_ARG_NAMES func, ref, mask
#define glPathStencilFuncNV_ARG_EXPAND GLenum func, GLint ref, GLuint mask
#define glPathStencilFuncNV_PACKED PACKED_glPathStencilFuncNV
#define glPathStencilFuncNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glPathStencilFuncNV_NOT_VOID_WRAP(...) {}
#define pack_glPathStencilFuncNV(_func, _ref, _mask) ({ \
    glPathStencilFuncNV_PACKED *packed_data = malloc(sizeof(glPathStencilFuncNV_PACKED)); \
    packed_data->index = glPathStencilFuncNV_INDEX; \
    packed_data->args.func = (GLenum)_func; \
    packed_data->args.ref = (GLint)_ref; \
    packed_data->args.mask = (GLuint)_mask; \
    (packed_call_t *)packed_data; \
})
#define call_glPathStencilFuncNV(packed, ret_v) do { \
    PACKED_glPathStencilFuncNV *unpacked = (PACKED_glPathStencilFuncNV *)packed; \
    ARGS_glPathStencilFuncNV *args = (ARGS_glPathStencilFuncNV *)&unpacked->args; \
    glPathStencilFuncNV(args->func, args->ref, args->mask);; \
} while(0)
void glPathStencilFuncNV(glPathStencilFuncNV_ARG_EXPAND);
typedef void (*glPathStencilFuncNV_PTR)(glPathStencilFuncNV_ARG_EXPAND);
#define glPathStringNV_INDEX 1522
#define glPathStringNV_RETURN void
#define glPathStringNV_ARG_NAMES path, format, length, pathString
#define glPathStringNV_ARG_EXPAND GLuint path, GLenum format, GLsizei length, const GLvoid * pathString
#define glPathStringNV_PACKED PACKED_glPathStringNV
#define glPathStringNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glPathStringNV_NOT_VOID_WRAP(...) {}
#define pack_glPathStringNV(_path, _format, _length, _pathString) ({ \
    glPathStringNV_PACKED *packed_data = malloc(sizeof(glPathStringNV_PACKED)); \
    packed_data->index = glPathStringNV_INDEX; \
    packed_data->args.path = (GLuint)_path; \
    packed_data->args.format = (GLenum)_format; \
    packed_data->args.length = (GLsizei)_length; \
    packed_data->args.pathString = (GLvoid *)_pathString; \
    (packed_call_t *)packed_data; \
})
#define call_glPathStringNV(packed, ret_v) do { \
    PACKED_glPathStringNV *unpacked = (PACKED_glPathStringNV *)packed; \
    ARGS_glPathStringNV *args = (ARGS_glPathStringNV *)&unpacked->args; \
    glPathStringNV(args->path, args->format, args->length, args->pathString);; \
} while(0)
void glPathStringNV(glPathStringNV_ARG_EXPAND);
typedef void (*glPathStringNV_PTR)(glPathStringNV_ARG_EXPAND);
#define glPathSubCommandsNV_INDEX 1523
#define glPathSubCommandsNV_RETURN void
#define glPathSubCommandsNV_ARG_NAMES path, commandStart, commandsToDelete, numCommands, commands, numCoords, coordType, coords
#define glPathSubCommandsNV_ARG_EXPAND GLuint path, GLsizei commandStart, GLsizei commandsToDelete, GLsizei numCommands, const GLubyte * commands, GLsizei numCoords, GLenum coordType, const GLvoid * coords
#define glPathSubCommandsNV_PACKED PACKED_glPathSubCommandsNV
#define glPathSubCommandsNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glPathSubCommandsNV_NOT_VOID_WRAP(...) {}
#define pack_glPathSubCommandsNV(_path, _commandStart, _commandsToDelete, _numCommands, _commands, _numCoords, _coordType, _coords) ({ \
    glPathSubCommandsNV_PACKED *packed_data = malloc(sizeof(glPathSubCommandsNV_PACKED)); \
    packed_data->index = glPathSubCommandsNV_INDEX; \
    packed_data->args.path = (GLuint)_path; \
    packed_data->args.commandStart = (GLsizei)_commandStart; \
    packed_data->args.commandsToDelete = (GLsizei)_commandsToDelete; \
    packed_data->args.numCommands = (GLsizei)_numCommands; \
    packed_data->args.commands = (GLubyte *)_commands; \
    packed_data->args.numCoords = (GLsizei)_numCoords; \
    packed_data->args.coordType = (GLenum)_coordType; \
    packed_data->args.coords = (GLvoid *)_coords; \
    (packed_call_t *)packed_data; \
})
#define call_glPathSubCommandsNV(packed, ret_v) do { \
    PACKED_glPathSubCommandsNV *unpacked = (PACKED_glPathSubCommandsNV *)packed; \
    ARGS_glPathSubCommandsNV *args = (ARGS_glPathSubCommandsNV *)&unpacked->args; \
    glPathSubCommandsNV(args->path, args->commandStart, args->commandsToDelete, args->numCommands, args->commands, args->numCoords, args->coordType, args->coords);; \
} while(0)
void glPathSubCommandsNV(glPathSubCommandsNV_ARG_EXPAND);
typedef void (*glPathSubCommandsNV_PTR)(glPathSubCommandsNV_ARG_EXPAND);
#define glPathSubCoordsNV_INDEX 1524
#define glPathSubCoordsNV_RETURN void
#define glPathSubCoordsNV_ARG_NAMES path, coordStart, numCoords, coordType, coords
#define glPathSubCoordsNV_ARG_EXPAND GLuint path, GLsizei coordStart, GLsizei numCoords, GLenum coordType, const GLvoid * coords
#define glPathSubCoordsNV_PACKED PACKED_glPathSubCoordsNV
#define glPathSubCoordsNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glPathSubCoordsNV_NOT_VOID_WRAP(...) {}
#define pack_glPathSubCoordsNV(_path, _coordStart, _numCoords, _coordType, _coords) ({ \
    glPathSubCoordsNV_PACKED *packed_data = malloc(sizeof(glPathSubCoordsNV_PACKED)); \
    packed_data->index = glPathSubCoordsNV_INDEX; \
    packed_data->args.path = (GLuint)_path; \
    packed_data->args.coordStart = (GLsizei)_coordStart; \
    packed_data->args.numCoords = (GLsizei)_numCoords; \
    packed_data->args.coordType = (GLenum)_coordType; \
    packed_data->args.coords = (GLvoid *)_coords; \
    (packed_call_t *)packed_data; \
})
#define call_glPathSubCoordsNV(packed, ret_v) do { \
    PACKED_glPathSubCoordsNV *unpacked = (PACKED_glPathSubCoordsNV *)packed; \
    ARGS_glPathSubCoordsNV *args = (ARGS_glPathSubCoordsNV *)&unpacked->args; \
    glPathSubCoordsNV(args->path, args->coordStart, args->numCoords, args->coordType, args->coords);; \
} while(0)
void glPathSubCoordsNV(glPathSubCoordsNV_ARG_EXPAND);
typedef void (*glPathSubCoordsNV_PTR)(glPathSubCoordsNV_ARG_EXPAND);
#define glPathTexGenNV_INDEX 1525
#define glPathTexGenNV_RETURN void
#define glPathTexGenNV_ARG_NAMES texCoordSet, genMode, components, coeffs
#define glPathTexGenNV_ARG_EXPAND GLenum texCoordSet, GLenum genMode, GLint components, const GLfloat * coeffs
#define glPathTexGenNV_PACKED PACKED_glPathTexGenNV
#define glPathTexGenNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glPathTexGenNV_NOT_VOID_WRAP(...) {}
#define pack_glPathTexGenNV(_texCoordSet, _genMode, _components, _coeffs) ({ \
    glPathTexGenNV_PACKED *packed_data = malloc(sizeof(glPathTexGenNV_PACKED)); \
    packed_data->index = glPathTexGenNV_INDEX; \
    packed_data->args.texCoordSet = (GLenum)_texCoordSet; \
    packed_data->args.genMode = (GLenum)_genMode; \
    packed_data->args.components = (GLint)_components; \
    packed_data->args.coeffs = (GLfloat *)_coeffs; \
    (packed_call_t *)packed_data; \
})
#define call_glPathTexGenNV(packed, ret_v) do { \
    PACKED_glPathTexGenNV *unpacked = (PACKED_glPathTexGenNV *)packed; \
    ARGS_glPathTexGenNV *args = (ARGS_glPathTexGenNV *)&unpacked->args; \
    glPathTexGenNV(args->texCoordSet, args->genMode, args->components, args->coeffs);; \
} while(0)
void glPathTexGenNV(glPathTexGenNV_ARG_EXPAND);
typedef void (*glPathTexGenNV_PTR)(glPathTexGenNV_ARG_EXPAND);
#define glPauseTransformFeedback_INDEX 1526
#define glPauseTransformFeedback_RETURN void
#define glPauseTransformFeedback_ARG_NAMES 
#define glPauseTransformFeedback_ARG_EXPAND 
#define glPauseTransformFeedback_PACKED PACKED_glPauseTransformFeedback
#define glPauseTransformFeedback_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glPauseTransformFeedback_NOT_VOID_WRAP(...) {}
#define pack_glPauseTransformFeedback() ({ \
    glPauseTransformFeedback_PACKED *packed_data = malloc(sizeof(glPauseTransformFeedback_PACKED)); \
    packed_data->index = glPauseTransformFeedback_INDEX; \
    (packed_call_t *)packed_data; \
})
#define call_glPauseTransformFeedback(packed, ret_v) do { \
    glPauseTransformFeedback();; \
} while(0)
void glPauseTransformFeedback(glPauseTransformFeedback_ARG_EXPAND);
typedef void (*glPauseTransformFeedback_PTR)(glPauseTransformFeedback_ARG_EXPAND);
#define glPauseTransformFeedbackNV_INDEX 1527
#define glPauseTransformFeedbackNV_RETURN void
#define glPauseTransformFeedbackNV_ARG_NAMES 
#define glPauseTransformFeedbackNV_ARG_EXPAND 
#define glPauseTransformFeedbackNV_PACKED PACKED_glPauseTransformFeedbackNV
#define glPauseTransformFeedbackNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glPauseTransformFeedbackNV_NOT_VOID_WRAP(...) {}
#define pack_glPauseTransformFeedbackNV() ({ \
    glPauseTransformFeedbackNV_PACKED *packed_data = malloc(sizeof(glPauseTransformFeedbackNV_PACKED)); \
    packed_data->index = glPauseTransformFeedbackNV_INDEX; \
    (packed_call_t *)packed_data; \
})
#define call_glPauseTransformFeedbackNV(packed, ret_v) do { \
    glPauseTransformFeedbackNV();; \
} while(0)
void glPauseTransformFeedbackNV(glPauseTransformFeedbackNV_ARG_EXPAND);
typedef void (*glPauseTransformFeedbackNV_PTR)(glPauseTransformFeedbackNV_ARG_EXPAND);
#define glPixelDataRangeNV_INDEX 1528
#define glPixelDataRangeNV_RETURN void
#define glPixelDataRangeNV_ARG_NAMES target, length, pointer
#define glPixelDataRangeNV_ARG_EXPAND GLenum target, GLsizei length, const GLvoid * pointer
#define glPixelDataRangeNV_PACKED PACKED_glPixelDataRangeNV
#define glPixelDataRangeNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glPixelDataRangeNV_NOT_VOID_WRAP(...) {}
#define pack_glPixelDataRangeNV(_target, _length, _pointer) ({ \
    glPixelDataRangeNV_PACKED *packed_data = malloc(sizeof(glPixelDataRangeNV_PACKED)); \
    packed_data->index = glPixelDataRangeNV_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.length = (GLsizei)_length; \
    packed_data->args.pointer = (GLvoid *)_pointer; \
    (packed_call_t *)packed_data; \
})
#define call_glPixelDataRangeNV(packed, ret_v) do { \
    PACKED_glPixelDataRangeNV *unpacked = (PACKED_glPixelDataRangeNV *)packed; \
    ARGS_glPixelDataRangeNV *args = (ARGS_glPixelDataRangeNV *)&unpacked->args; \
    glPixelDataRangeNV(args->target, args->length, args->pointer);; \
} while(0)
void glPixelDataRangeNV(glPixelDataRangeNV_ARG_EXPAND);
typedef void (*glPixelDataRangeNV_PTR)(glPixelDataRangeNV_ARG_EXPAND);
#define glPixelMapfv_INDEX 1529
#define glPixelMapfv_RETURN void
#define glPixelMapfv_ARG_NAMES map, mapsize, values
#define glPixelMapfv_ARG_EXPAND GLenum map, GLsizei mapsize, const GLfloat * values
#define glPixelMapfv_PACKED PACKED_glPixelMapfv
#define glPixelMapfv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glPixelMapfv_NOT_VOID_WRAP(...) {}
#define pack_glPixelMapfv(_map, _mapsize, _values) ({ \
    glPixelMapfv_PACKED *packed_data = malloc(sizeof(glPixelMapfv_PACKED)); \
    packed_data->index = glPixelMapfv_INDEX; \
    packed_data->args.map = (GLenum)_map; \
    packed_data->args.mapsize = (GLsizei)_mapsize; \
    packed_data->args.values = (GLfloat *)_values; \
    (packed_call_t *)packed_data; \
})
#define call_glPixelMapfv(packed, ret_v) do { \
    PACKED_glPixelMapfv *unpacked = (PACKED_glPixelMapfv *)packed; \
    ARGS_glPixelMapfv *args = (ARGS_glPixelMapfv *)&unpacked->args; \
    glPixelMapfv(args->map, args->mapsize, args->values);; \
} while(0)
void glPixelMapfv(glPixelMapfv_ARG_EXPAND);
typedef void (*glPixelMapfv_PTR)(glPixelMapfv_ARG_EXPAND);
#define glPixelMapuiv_INDEX 1530
#define glPixelMapuiv_RETURN void
#define glPixelMapuiv_ARG_NAMES map, mapsize, values
#define glPixelMapuiv_ARG_EXPAND GLenum map, GLsizei mapsize, const GLuint * values
#define glPixelMapuiv_PACKED PACKED_glPixelMapuiv
#define glPixelMapuiv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glPixelMapuiv_NOT_VOID_WRAP(...) {}
#define pack_glPixelMapuiv(_map, _mapsize, _values) ({ \
    glPixelMapuiv_PACKED *packed_data = malloc(sizeof(glPixelMapuiv_PACKED)); \
    packed_data->index = glPixelMapuiv_INDEX; \
    packed_data->args.map = (GLenum)_map; \
    packed_data->args.mapsize = (GLsizei)_mapsize; \
    packed_data->args.values = (GLuint *)_values; \
    (packed_call_t *)packed_data; \
})
#define call_glPixelMapuiv(packed, ret_v) do { \
    PACKED_glPixelMapuiv *unpacked = (PACKED_glPixelMapuiv *)packed; \
    ARGS_glPixelMapuiv *args = (ARGS_glPixelMapuiv *)&unpacked->args; \
    glPixelMapuiv(args->map, args->mapsize, args->values);; \
} while(0)
void glPixelMapuiv(glPixelMapuiv_ARG_EXPAND);
typedef void (*glPixelMapuiv_PTR)(glPixelMapuiv_ARG_EXPAND);
#define glPixelMapusv_INDEX 1531
#define glPixelMapusv_RETURN void
#define glPixelMapusv_ARG_NAMES map, mapsize, values
#define glPixelMapusv_ARG_EXPAND GLenum map, GLsizei mapsize, const GLushort * values
#define glPixelMapusv_PACKED PACKED_glPixelMapusv
#define glPixelMapusv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glPixelMapusv_NOT_VOID_WRAP(...) {}
#define pack_glPixelMapusv(_map, _mapsize, _values) ({ \
    glPixelMapusv_PACKED *packed_data = malloc(sizeof(glPixelMapusv_PACKED)); \
    packed_data->index = glPixelMapusv_INDEX; \
    packed_data->args.map = (GLenum)_map; \
    packed_data->args.mapsize = (GLsizei)_mapsize; \
    packed_data->args.values = (GLushort *)_values; \
    (packed_call_t *)packed_data; \
})
#define call_glPixelMapusv(packed, ret_v) do { \
    PACKED_glPixelMapusv *unpacked = (PACKED_glPixelMapusv *)packed; \
    ARGS_glPixelMapusv *args = (ARGS_glPixelMapusv *)&unpacked->args; \
    glPixelMapusv(args->map, args->mapsize, args->values);; \
} while(0)
void glPixelMapusv(glPixelMapusv_ARG_EXPAND);
typedef void (*glPixelMapusv_PTR)(glPixelMapusv_ARG_EXPAND);
#define glPixelMapx_INDEX 1532
#define glPixelMapx_RETURN void
#define glPixelMapx_ARG_NAMES map, size, values
#define glPixelMapx_ARG_EXPAND GLenum map, GLint size, const GLfixed * values
#define glPixelMapx_PACKED PACKED_glPixelMapx
#define glPixelMapx_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glPixelMapx_NOT_VOID_WRAP(...) {}
#define pack_glPixelMapx(_map, _size, _values) ({ \
    glPixelMapx_PACKED *packed_data = malloc(sizeof(glPixelMapx_PACKED)); \
    packed_data->index = glPixelMapx_INDEX; \
    packed_data->args.map = (GLenum)_map; \
    packed_data->args.size = (GLint)_size; \
    packed_data->args.values = (GLfixed *)_values; \
    (packed_call_t *)packed_data; \
})
#define call_glPixelMapx(packed, ret_v) do { \
    PACKED_glPixelMapx *unpacked = (PACKED_glPixelMapx *)packed; \
    ARGS_glPixelMapx *args = (ARGS_glPixelMapx *)&unpacked->args; \
    glPixelMapx(args->map, args->size, args->values);; \
} while(0)
void glPixelMapx(glPixelMapx_ARG_EXPAND);
typedef void (*glPixelMapx_PTR)(glPixelMapx_ARG_EXPAND);
#define glPixelStoref_INDEX 1533
#define glPixelStoref_RETURN void
#define glPixelStoref_ARG_NAMES pname, param
#define glPixelStoref_ARG_EXPAND GLenum pname, GLfloat param
#define glPixelStoref_PACKED PACKED_glPixelStoref
#define glPixelStoref_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glPixelStoref_NOT_VOID_WRAP(...) {}
#define pack_glPixelStoref(_pname, _param) ({ \
    glPixelStoref_PACKED *packed_data = malloc(sizeof(glPixelStoref_PACKED)); \
    packed_data->index = glPixelStoref_INDEX; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.param = (GLfloat)_param; \
    (packed_call_t *)packed_data; \
})
#define call_glPixelStoref(packed, ret_v) do { \
    PACKED_glPixelStoref *unpacked = (PACKED_glPixelStoref *)packed; \
    ARGS_glPixelStoref *args = (ARGS_glPixelStoref *)&unpacked->args; \
    glPixelStoref(args->pname, args->param);; \
} while(0)
void glPixelStoref(glPixelStoref_ARG_EXPAND);
typedef void (*glPixelStoref_PTR)(glPixelStoref_ARG_EXPAND);
#define glPixelStorei_INDEX 1534
#define glPixelStorei_RETURN void
#define glPixelStorei_ARG_NAMES pname, param
#define glPixelStorei_ARG_EXPAND GLenum pname, GLint param
#define glPixelStorei_PACKED PACKED_glPixelStorei
#define glPixelStorei_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glPixelStorei_NOT_VOID_WRAP(...) {}
#define pack_glPixelStorei(_pname, _param) ({ \
    glPixelStorei_PACKED *packed_data = malloc(sizeof(glPixelStorei_PACKED)); \
    packed_data->index = glPixelStorei_INDEX; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.param = (GLint)_param; \
    (packed_call_t *)packed_data; \
})
#define call_glPixelStorei(packed, ret_v) do { \
    PACKED_glPixelStorei *unpacked = (PACKED_glPixelStorei *)packed; \
    ARGS_glPixelStorei *args = (ARGS_glPixelStorei *)&unpacked->args; \
    glPixelStorei(args->pname, args->param);; \
} while(0)
void glPixelStorei(glPixelStorei_ARG_EXPAND);
typedef void (*glPixelStorei_PTR)(glPixelStorei_ARG_EXPAND);
#define glPixelStorex_INDEX 1535
#define glPixelStorex_RETURN void
#define glPixelStorex_ARG_NAMES pname, param
#define glPixelStorex_ARG_EXPAND GLenum pname, GLfixed param
#define glPixelStorex_PACKED PACKED_glPixelStorex
#define glPixelStorex_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glPixelStorex_NOT_VOID_WRAP(...) {}
#define pack_glPixelStorex(_pname, _param) ({ \
    glPixelStorex_PACKED *packed_data = malloc(sizeof(glPixelStorex_PACKED)); \
    packed_data->index = glPixelStorex_INDEX; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.param = (GLfixed)_param; \
    (packed_call_t *)packed_data; \
})
#define call_glPixelStorex(packed, ret_v) do { \
    PACKED_glPixelStorex *unpacked = (PACKED_glPixelStorex *)packed; \
    ARGS_glPixelStorex *args = (ARGS_glPixelStorex *)&unpacked->args; \
    glPixelStorex(args->pname, args->param);; \
} while(0)
void glPixelStorex(glPixelStorex_ARG_EXPAND);
typedef void (*glPixelStorex_PTR)(glPixelStorex_ARG_EXPAND);
#define glPixelTexGenParameterfSGIS_INDEX 1536
#define glPixelTexGenParameterfSGIS_RETURN void
#define glPixelTexGenParameterfSGIS_ARG_NAMES pname, param
#define glPixelTexGenParameterfSGIS_ARG_EXPAND GLenum pname, GLfloat param
#define glPixelTexGenParameterfSGIS_PACKED PACKED_glPixelTexGenParameterfSGIS
#define glPixelTexGenParameterfSGIS_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glPixelTexGenParameterfSGIS_NOT_VOID_WRAP(...) {}
#define pack_glPixelTexGenParameterfSGIS(_pname, _param) ({ \
    glPixelTexGenParameterfSGIS_PACKED *packed_data = malloc(sizeof(glPixelTexGenParameterfSGIS_PACKED)); \
    packed_data->index = glPixelTexGenParameterfSGIS_INDEX; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.param = (GLfloat)_param; \
    (packed_call_t *)packed_data; \
})
#define call_glPixelTexGenParameterfSGIS(packed, ret_v) do { \
    PACKED_glPixelTexGenParameterfSGIS *unpacked = (PACKED_glPixelTexGenParameterfSGIS *)packed; \
    ARGS_glPixelTexGenParameterfSGIS *args = (ARGS_glPixelTexGenParameterfSGIS *)&unpacked->args; \
    glPixelTexGenParameterfSGIS(args->pname, args->param);; \
} while(0)
void glPixelTexGenParameterfSGIS(glPixelTexGenParameterfSGIS_ARG_EXPAND);
typedef void (*glPixelTexGenParameterfSGIS_PTR)(glPixelTexGenParameterfSGIS_ARG_EXPAND);
#define glPixelTexGenParameterfvSGIS_INDEX 1537
#define glPixelTexGenParameterfvSGIS_RETURN void
#define glPixelTexGenParameterfvSGIS_ARG_NAMES pname, params
#define glPixelTexGenParameterfvSGIS_ARG_EXPAND GLenum pname, const GLfloat * params
#define glPixelTexGenParameterfvSGIS_PACKED PACKED_glPixelTexGenParameterfvSGIS
#define glPixelTexGenParameterfvSGIS_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glPixelTexGenParameterfvSGIS_NOT_VOID_WRAP(...) {}
#define pack_glPixelTexGenParameterfvSGIS(_pname, _params) ({ \
    glPixelTexGenParameterfvSGIS_PACKED *packed_data = malloc(sizeof(glPixelTexGenParameterfvSGIS_PACKED)); \
    packed_data->index = glPixelTexGenParameterfvSGIS_INDEX; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLfloat *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glPixelTexGenParameterfvSGIS(packed, ret_v) do { \
    PACKED_glPixelTexGenParameterfvSGIS *unpacked = (PACKED_glPixelTexGenParameterfvSGIS *)packed; \
    ARGS_glPixelTexGenParameterfvSGIS *args = (ARGS_glPixelTexGenParameterfvSGIS *)&unpacked->args; \
    glPixelTexGenParameterfvSGIS(args->pname, args->params);; \
} while(0)
void glPixelTexGenParameterfvSGIS(glPixelTexGenParameterfvSGIS_ARG_EXPAND);
typedef void (*glPixelTexGenParameterfvSGIS_PTR)(glPixelTexGenParameterfvSGIS_ARG_EXPAND);
#define glPixelTexGenParameteriSGIS_INDEX 1538
#define glPixelTexGenParameteriSGIS_RETURN void
#define glPixelTexGenParameteriSGIS_ARG_NAMES pname, param
#define glPixelTexGenParameteriSGIS_ARG_EXPAND GLenum pname, GLint param
#define glPixelTexGenParameteriSGIS_PACKED PACKED_glPixelTexGenParameteriSGIS
#define glPixelTexGenParameteriSGIS_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glPixelTexGenParameteriSGIS_NOT_VOID_WRAP(...) {}
#define pack_glPixelTexGenParameteriSGIS(_pname, _param) ({ \
    glPixelTexGenParameteriSGIS_PACKED *packed_data = malloc(sizeof(glPixelTexGenParameteriSGIS_PACKED)); \
    packed_data->index = glPixelTexGenParameteriSGIS_INDEX; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.param = (GLint)_param; \
    (packed_call_t *)packed_data; \
})
#define call_glPixelTexGenParameteriSGIS(packed, ret_v) do { \
    PACKED_glPixelTexGenParameteriSGIS *unpacked = (PACKED_glPixelTexGenParameteriSGIS *)packed; \
    ARGS_glPixelTexGenParameteriSGIS *args = (ARGS_glPixelTexGenParameteriSGIS *)&unpacked->args; \
    glPixelTexGenParameteriSGIS(args->pname, args->param);; \
} while(0)
void glPixelTexGenParameteriSGIS(glPixelTexGenParameteriSGIS_ARG_EXPAND);
typedef void (*glPixelTexGenParameteriSGIS_PTR)(glPixelTexGenParameteriSGIS_ARG_EXPAND);
#define glPixelTexGenParameterivSGIS_INDEX 1539
#define glPixelTexGenParameterivSGIS_RETURN void
#define glPixelTexGenParameterivSGIS_ARG_NAMES pname, params
#define glPixelTexGenParameterivSGIS_ARG_EXPAND GLenum pname, const GLint * params
#define glPixelTexGenParameterivSGIS_PACKED PACKED_glPixelTexGenParameterivSGIS
#define glPixelTexGenParameterivSGIS_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glPixelTexGenParameterivSGIS_NOT_VOID_WRAP(...) {}
#define pack_glPixelTexGenParameterivSGIS(_pname, _params) ({ \
    glPixelTexGenParameterivSGIS_PACKED *packed_data = malloc(sizeof(glPixelTexGenParameterivSGIS_PACKED)); \
    packed_data->index = glPixelTexGenParameterivSGIS_INDEX; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glPixelTexGenParameterivSGIS(packed, ret_v) do { \
    PACKED_glPixelTexGenParameterivSGIS *unpacked = (PACKED_glPixelTexGenParameterivSGIS *)packed; \
    ARGS_glPixelTexGenParameterivSGIS *args = (ARGS_glPixelTexGenParameterivSGIS *)&unpacked->args; \
    glPixelTexGenParameterivSGIS(args->pname, args->params);; \
} while(0)
void glPixelTexGenParameterivSGIS(glPixelTexGenParameterivSGIS_ARG_EXPAND);
typedef void (*glPixelTexGenParameterivSGIS_PTR)(glPixelTexGenParameterivSGIS_ARG_EXPAND);
#define glPixelTexGenSGIX_INDEX 1540
#define glPixelTexGenSGIX_RETURN void
#define glPixelTexGenSGIX_ARG_NAMES mode
#define glPixelTexGenSGIX_ARG_EXPAND GLenum mode
#define glPixelTexGenSGIX_PACKED PACKED_glPixelTexGenSGIX
#define glPixelTexGenSGIX_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glPixelTexGenSGIX_NOT_VOID_WRAP(...) {}
#define pack_glPixelTexGenSGIX(_mode) ({ \
    glPixelTexGenSGIX_PACKED *packed_data = malloc(sizeof(glPixelTexGenSGIX_PACKED)); \
    packed_data->index = glPixelTexGenSGIX_INDEX; \
    packed_data->args.mode = (GLenum)_mode; \
    (packed_call_t *)packed_data; \
})
#define call_glPixelTexGenSGIX(packed, ret_v) do { \
    PACKED_glPixelTexGenSGIX *unpacked = (PACKED_glPixelTexGenSGIX *)packed; \
    ARGS_glPixelTexGenSGIX *args = (ARGS_glPixelTexGenSGIX *)&unpacked->args; \
    glPixelTexGenSGIX(args->mode);; \
} while(0)
void glPixelTexGenSGIX(glPixelTexGenSGIX_ARG_EXPAND);
typedef void (*glPixelTexGenSGIX_PTR)(glPixelTexGenSGIX_ARG_EXPAND);
#define glPixelTransferf_INDEX 1541
#define glPixelTransferf_RETURN void
#define glPixelTransferf_ARG_NAMES pname, param
#define glPixelTransferf_ARG_EXPAND GLenum pname, GLfloat param
#define glPixelTransferf_PACKED PACKED_glPixelTransferf
#define glPixelTransferf_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glPixelTransferf_NOT_VOID_WRAP(...) {}
#define pack_glPixelTransferf(_pname, _param) ({ \
    glPixelTransferf_PACKED *packed_data = malloc(sizeof(glPixelTransferf_PACKED)); \
    packed_data->index = glPixelTransferf_INDEX; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.param = (GLfloat)_param; \
    (packed_call_t *)packed_data; \
})
#define call_glPixelTransferf(packed, ret_v) do { \
    PACKED_glPixelTransferf *unpacked = (PACKED_glPixelTransferf *)packed; \
    ARGS_glPixelTransferf *args = (ARGS_glPixelTransferf *)&unpacked->args; \
    glPixelTransferf(args->pname, args->param);; \
} while(0)
void glPixelTransferf(glPixelTransferf_ARG_EXPAND);
typedef void (*glPixelTransferf_PTR)(glPixelTransferf_ARG_EXPAND);
#define glPixelTransferi_INDEX 1542
#define glPixelTransferi_RETURN void
#define glPixelTransferi_ARG_NAMES pname, param
#define glPixelTransferi_ARG_EXPAND GLenum pname, GLint param
#define glPixelTransferi_PACKED PACKED_glPixelTransferi
#define glPixelTransferi_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glPixelTransferi_NOT_VOID_WRAP(...) {}
#define pack_glPixelTransferi(_pname, _param) ({ \
    glPixelTransferi_PACKED *packed_data = malloc(sizeof(glPixelTransferi_PACKED)); \
    packed_data->index = glPixelTransferi_INDEX; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.param = (GLint)_param; \
    (packed_call_t *)packed_data; \
})
#define call_glPixelTransferi(packed, ret_v) do { \
    PACKED_glPixelTransferi *unpacked = (PACKED_glPixelTransferi *)packed; \
    ARGS_glPixelTransferi *args = (ARGS_glPixelTransferi *)&unpacked->args; \
    glPixelTransferi(args->pname, args->param);; \
} while(0)
void glPixelTransferi(glPixelTransferi_ARG_EXPAND);
typedef void (*glPixelTransferi_PTR)(glPixelTransferi_ARG_EXPAND);
#define glPixelTransferxOES_INDEX 1543
#define glPixelTransferxOES_RETURN void
#define glPixelTransferxOES_ARG_NAMES pname, param
#define glPixelTransferxOES_ARG_EXPAND GLenum pname, GLfixed param
#define glPixelTransferxOES_PACKED PACKED_glPixelTransferxOES
#define glPixelTransferxOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glPixelTransferxOES_NOT_VOID_WRAP(...) {}
#define pack_glPixelTransferxOES(_pname, _param) ({ \
    glPixelTransferxOES_PACKED *packed_data = malloc(sizeof(glPixelTransferxOES_PACKED)); \
    packed_data->index = glPixelTransferxOES_INDEX; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.param = (GLfixed)_param; \
    (packed_call_t *)packed_data; \
})
#define call_glPixelTransferxOES(packed, ret_v) do { \
    PACKED_glPixelTransferxOES *unpacked = (PACKED_glPixelTransferxOES *)packed; \
    ARGS_glPixelTransferxOES *args = (ARGS_glPixelTransferxOES *)&unpacked->args; \
    glPixelTransferxOES(args->pname, args->param);; \
} while(0)
void glPixelTransferxOES(glPixelTransferxOES_ARG_EXPAND);
typedef void (*glPixelTransferxOES_PTR)(glPixelTransferxOES_ARG_EXPAND);
#define glPixelTransformParameterfEXT_INDEX 1544
#define glPixelTransformParameterfEXT_RETURN void
#define glPixelTransformParameterfEXT_ARG_NAMES target, pname, param
#define glPixelTransformParameterfEXT_ARG_EXPAND GLenum target, GLenum pname, GLfloat param
#define glPixelTransformParameterfEXT_PACKED PACKED_glPixelTransformParameterfEXT
#define glPixelTransformParameterfEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glPixelTransformParameterfEXT_NOT_VOID_WRAP(...) {}
#define pack_glPixelTransformParameterfEXT(_target, _pname, _param) ({ \
    glPixelTransformParameterfEXT_PACKED *packed_data = malloc(sizeof(glPixelTransformParameterfEXT_PACKED)); \
    packed_data->index = glPixelTransformParameterfEXT_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.param = (GLfloat)_param; \
    (packed_call_t *)packed_data; \
})
#define call_glPixelTransformParameterfEXT(packed, ret_v) do { \
    PACKED_glPixelTransformParameterfEXT *unpacked = (PACKED_glPixelTransformParameterfEXT *)packed; \
    ARGS_glPixelTransformParameterfEXT *args = (ARGS_glPixelTransformParameterfEXT *)&unpacked->args; \
    glPixelTransformParameterfEXT(args->target, args->pname, args->param);; \
} while(0)
void glPixelTransformParameterfEXT(glPixelTransformParameterfEXT_ARG_EXPAND);
typedef void (*glPixelTransformParameterfEXT_PTR)(glPixelTransformParameterfEXT_ARG_EXPAND);
#define glPixelTransformParameterfvEXT_INDEX 1545
#define glPixelTransformParameterfvEXT_RETURN void
#define glPixelTransformParameterfvEXT_ARG_NAMES target, pname, params
#define glPixelTransformParameterfvEXT_ARG_EXPAND GLenum target, GLenum pname, const GLfloat * params
#define glPixelTransformParameterfvEXT_PACKED PACKED_glPixelTransformParameterfvEXT
#define glPixelTransformParameterfvEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glPixelTransformParameterfvEXT_NOT_VOID_WRAP(...) {}
#define pack_glPixelTransformParameterfvEXT(_target, _pname, _params) ({ \
    glPixelTransformParameterfvEXT_PACKED *packed_data = malloc(sizeof(glPixelTransformParameterfvEXT_PACKED)); \
    packed_data->index = glPixelTransformParameterfvEXT_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLfloat *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glPixelTransformParameterfvEXT(packed, ret_v) do { \
    PACKED_glPixelTransformParameterfvEXT *unpacked = (PACKED_glPixelTransformParameterfvEXT *)packed; \
    ARGS_glPixelTransformParameterfvEXT *args = (ARGS_glPixelTransformParameterfvEXT *)&unpacked->args; \
    glPixelTransformParameterfvEXT(args->target, args->pname, args->params);; \
} while(0)
void glPixelTransformParameterfvEXT(glPixelTransformParameterfvEXT_ARG_EXPAND);
typedef void (*glPixelTransformParameterfvEXT_PTR)(glPixelTransformParameterfvEXT_ARG_EXPAND);
#define glPixelTransformParameteriEXT_INDEX 1546
#define glPixelTransformParameteriEXT_RETURN void
#define glPixelTransformParameteriEXT_ARG_NAMES target, pname, param
#define glPixelTransformParameteriEXT_ARG_EXPAND GLenum target, GLenum pname, GLint param
#define glPixelTransformParameteriEXT_PACKED PACKED_glPixelTransformParameteriEXT
#define glPixelTransformParameteriEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glPixelTransformParameteriEXT_NOT_VOID_WRAP(...) {}
#define pack_glPixelTransformParameteriEXT(_target, _pname, _param) ({ \
    glPixelTransformParameteriEXT_PACKED *packed_data = malloc(sizeof(glPixelTransformParameteriEXT_PACKED)); \
    packed_data->index = glPixelTransformParameteriEXT_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.param = (GLint)_param; \
    (packed_call_t *)packed_data; \
})
#define call_glPixelTransformParameteriEXT(packed, ret_v) do { \
    PACKED_glPixelTransformParameteriEXT *unpacked = (PACKED_glPixelTransformParameteriEXT *)packed; \
    ARGS_glPixelTransformParameteriEXT *args = (ARGS_glPixelTransformParameteriEXT *)&unpacked->args; \
    glPixelTransformParameteriEXT(args->target, args->pname, args->param);; \
} while(0)
void glPixelTransformParameteriEXT(glPixelTransformParameteriEXT_ARG_EXPAND);
typedef void (*glPixelTransformParameteriEXT_PTR)(glPixelTransformParameteriEXT_ARG_EXPAND);
#define glPixelTransformParameterivEXT_INDEX 1547
#define glPixelTransformParameterivEXT_RETURN void
#define glPixelTransformParameterivEXT_ARG_NAMES target, pname, params
#define glPixelTransformParameterivEXT_ARG_EXPAND GLenum target, GLenum pname, const GLint * params
#define glPixelTransformParameterivEXT_PACKED PACKED_glPixelTransformParameterivEXT
#define glPixelTransformParameterivEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glPixelTransformParameterivEXT_NOT_VOID_WRAP(...) {}
#define pack_glPixelTransformParameterivEXT(_target, _pname, _params) ({ \
    glPixelTransformParameterivEXT_PACKED *packed_data = malloc(sizeof(glPixelTransformParameterivEXT_PACKED)); \
    packed_data->index = glPixelTransformParameterivEXT_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glPixelTransformParameterivEXT(packed, ret_v) do { \
    PACKED_glPixelTransformParameterivEXT *unpacked = (PACKED_glPixelTransformParameterivEXT *)packed; \
    ARGS_glPixelTransformParameterivEXT *args = (ARGS_glPixelTransformParameterivEXT *)&unpacked->args; \
    glPixelTransformParameterivEXT(args->target, args->pname, args->params);; \
} while(0)
void glPixelTransformParameterivEXT(glPixelTransformParameterivEXT_ARG_EXPAND);
typedef void (*glPixelTransformParameterivEXT_PTR)(glPixelTransformParameterivEXT_ARG_EXPAND);
#define glPixelZoom_INDEX 1548
#define glPixelZoom_RETURN void
#define glPixelZoom_ARG_NAMES xfactor, yfactor
#define glPixelZoom_ARG_EXPAND GLfloat xfactor, GLfloat yfactor
#define glPixelZoom_PACKED PACKED_glPixelZoom
#define glPixelZoom_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glPixelZoom_NOT_VOID_WRAP(...) {}
#define pack_glPixelZoom(_xfactor, _yfactor) ({ \
    glPixelZoom_PACKED *packed_data = malloc(sizeof(glPixelZoom_PACKED)); \
    packed_data->index = glPixelZoom_INDEX; \
    packed_data->args.xfactor = (GLfloat)_xfactor; \
    packed_data->args.yfactor = (GLfloat)_yfactor; \
    (packed_call_t *)packed_data; \
})
#define call_glPixelZoom(packed, ret_v) do { \
    PACKED_glPixelZoom *unpacked = (PACKED_glPixelZoom *)packed; \
    ARGS_glPixelZoom *args = (ARGS_glPixelZoom *)&unpacked->args; \
    glPixelZoom(args->xfactor, args->yfactor);; \
} while(0)
void glPixelZoom(glPixelZoom_ARG_EXPAND);
typedef void (*glPixelZoom_PTR)(glPixelZoom_ARG_EXPAND);
#define glPixelZoomxOES_INDEX 1549
#define glPixelZoomxOES_RETURN void
#define glPixelZoomxOES_ARG_NAMES xfactor, yfactor
#define glPixelZoomxOES_ARG_EXPAND GLfixed xfactor, GLfixed yfactor
#define glPixelZoomxOES_PACKED PACKED_glPixelZoomxOES
#define glPixelZoomxOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glPixelZoomxOES_NOT_VOID_WRAP(...) {}
#define pack_glPixelZoomxOES(_xfactor, _yfactor) ({ \
    glPixelZoomxOES_PACKED *packed_data = malloc(sizeof(glPixelZoomxOES_PACKED)); \
    packed_data->index = glPixelZoomxOES_INDEX; \
    packed_data->args.xfactor = (GLfixed)_xfactor; \
    packed_data->args.yfactor = (GLfixed)_yfactor; \
    (packed_call_t *)packed_data; \
})
#define call_glPixelZoomxOES(packed, ret_v) do { \
    PACKED_glPixelZoomxOES *unpacked = (PACKED_glPixelZoomxOES *)packed; \
    ARGS_glPixelZoomxOES *args = (ARGS_glPixelZoomxOES *)&unpacked->args; \
    glPixelZoomxOES(args->xfactor, args->yfactor);; \
} while(0)
void glPixelZoomxOES(glPixelZoomxOES_ARG_EXPAND);
typedef void (*glPixelZoomxOES_PTR)(glPixelZoomxOES_ARG_EXPAND);
#define glPointAlongPathNV_INDEX 1550
#define glPointAlongPathNV_RETURN GLboolean
#define glPointAlongPathNV_ARG_NAMES path, startSegment, numSegments, distance, x, y, tangentX, tangentY
#define glPointAlongPathNV_ARG_EXPAND GLuint path, GLsizei startSegment, GLsizei numSegments, GLfloat distance, GLfloat * x, GLfloat * y, GLfloat * tangentX, GLfloat * tangentY
#define glPointAlongPathNV_PACKED PACKED_glPointAlongPathNV
#define glPointAlongPathNV_VOID_ONLY_WRAP(...) {}
#define glPointAlongPathNV_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glPointAlongPathNV(_path, _startSegment, _numSegments, _distance, _x, _y, _tangentX, _tangentY) ({ \
    glPointAlongPathNV_PACKED *packed_data = malloc(sizeof(glPointAlongPathNV_PACKED)); \
    packed_data->index = glPointAlongPathNV_INDEX; \
    packed_data->args.path = (GLuint)_path; \
    packed_data->args.startSegment = (GLsizei)_startSegment; \
    packed_data->args.numSegments = (GLsizei)_numSegments; \
    packed_data->args.distance = (GLfloat)_distance; \
    packed_data->args.x = (GLfloat *)_x; \
    packed_data->args.y = (GLfloat *)_y; \
    packed_data->args.tangentX = (GLfloat *)_tangentX; \
    packed_data->args.tangentY = (GLfloat *)_tangentY; \
    (packed_call_t *)packed_data; \
})
#define call_glPointAlongPathNV(packed, ret_v) do { \
    PACKED_glPointAlongPathNV *unpacked = (PACKED_glPointAlongPathNV *)packed; \
    ARGS_glPointAlongPathNV *args = (ARGS_glPointAlongPathNV *)&unpacked->args; \
    GLboolean *ret = (GLboolean *)ret_v; \
    if (ret != NULL) { \
        *ret = glPointAlongPathNV(args->path, args->startSegment, args->numSegments, args->distance, args->x, args->y, args->tangentX, args->tangentY);; \
    } else { \
        glPointAlongPathNV(args->path, args->startSegment, args->numSegments, args->distance, args->x, args->y, args->tangentX, args->tangentY);; \
    } \
} while(0)
GLboolean glPointAlongPathNV(glPointAlongPathNV_ARG_EXPAND);
typedef GLboolean (*glPointAlongPathNV_PTR)(glPointAlongPathNV_ARG_EXPAND);
#define glPointParameterf_INDEX 1551
#define glPointParameterf_RETURN void
#define glPointParameterf_ARG_NAMES pname, param
#define glPointParameterf_ARG_EXPAND GLenum pname, GLfloat param
#define glPointParameterf_PACKED PACKED_glPointParameterf
#define glPointParameterf_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glPointParameterf_NOT_VOID_WRAP(...) {}
#define pack_glPointParameterf(_pname, _param) ({ \
    glPointParameterf_PACKED *packed_data = malloc(sizeof(glPointParameterf_PACKED)); \
    packed_data->index = glPointParameterf_INDEX; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.param = (GLfloat)_param; \
    (packed_call_t *)packed_data; \
})
#define call_glPointParameterf(packed, ret_v) do { \
    PACKED_glPointParameterf *unpacked = (PACKED_glPointParameterf *)packed; \
    ARGS_glPointParameterf *args = (ARGS_glPointParameterf *)&unpacked->args; \
    glPointParameterf(args->pname, args->param);; \
} while(0)
void glPointParameterf(glPointParameterf_ARG_EXPAND);
typedef void (*glPointParameterf_PTR)(glPointParameterf_ARG_EXPAND);
#define glPointParameterfARB_INDEX 1552
#define glPointParameterfARB_RETURN void
#define glPointParameterfARB_ARG_NAMES pname, param
#define glPointParameterfARB_ARG_EXPAND GLenum pname, GLfloat param
#define glPointParameterfARB_PACKED PACKED_glPointParameterfARB
#define glPointParameterfARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glPointParameterfARB_NOT_VOID_WRAP(...) {}
#define pack_glPointParameterfARB(_pname, _param) ({ \
    glPointParameterfARB_PACKED *packed_data = malloc(sizeof(glPointParameterfARB_PACKED)); \
    packed_data->index = glPointParameterfARB_INDEX; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.param = (GLfloat)_param; \
    (packed_call_t *)packed_data; \
})
#define call_glPointParameterfARB(packed, ret_v) do { \
    PACKED_glPointParameterfARB *unpacked = (PACKED_glPointParameterfARB *)packed; \
    ARGS_glPointParameterfARB *args = (ARGS_glPointParameterfARB *)&unpacked->args; \
    glPointParameterfARB(args->pname, args->param);; \
} while(0)
void glPointParameterfARB(glPointParameterfARB_ARG_EXPAND);
typedef void (*glPointParameterfARB_PTR)(glPointParameterfARB_ARG_EXPAND);
#define glPointParameterfEXT_INDEX 1553
#define glPointParameterfEXT_RETURN void
#define glPointParameterfEXT_ARG_NAMES pname, param
#define glPointParameterfEXT_ARG_EXPAND GLenum pname, GLfloat param
#define glPointParameterfEXT_PACKED PACKED_glPointParameterfEXT
#define glPointParameterfEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glPointParameterfEXT_NOT_VOID_WRAP(...) {}
#define pack_glPointParameterfEXT(_pname, _param) ({ \
    glPointParameterfEXT_PACKED *packed_data = malloc(sizeof(glPointParameterfEXT_PACKED)); \
    packed_data->index = glPointParameterfEXT_INDEX; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.param = (GLfloat)_param; \
    (packed_call_t *)packed_data; \
})
#define call_glPointParameterfEXT(packed, ret_v) do { \
    PACKED_glPointParameterfEXT *unpacked = (PACKED_glPointParameterfEXT *)packed; \
    ARGS_glPointParameterfEXT *args = (ARGS_glPointParameterfEXT *)&unpacked->args; \
    glPointParameterfEXT(args->pname, args->param);; \
} while(0)
void glPointParameterfEXT(glPointParameterfEXT_ARG_EXPAND);
typedef void (*glPointParameterfEXT_PTR)(glPointParameterfEXT_ARG_EXPAND);
#define glPointParameterfSGIS_INDEX 1554
#define glPointParameterfSGIS_RETURN void
#define glPointParameterfSGIS_ARG_NAMES pname, param
#define glPointParameterfSGIS_ARG_EXPAND GLenum pname, GLfloat param
#define glPointParameterfSGIS_PACKED PACKED_glPointParameterfSGIS
#define glPointParameterfSGIS_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glPointParameterfSGIS_NOT_VOID_WRAP(...) {}
#define pack_glPointParameterfSGIS(_pname, _param) ({ \
    glPointParameterfSGIS_PACKED *packed_data = malloc(sizeof(glPointParameterfSGIS_PACKED)); \
    packed_data->index = glPointParameterfSGIS_INDEX; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.param = (GLfloat)_param; \
    (packed_call_t *)packed_data; \
})
#define call_glPointParameterfSGIS(packed, ret_v) do { \
    PACKED_glPointParameterfSGIS *unpacked = (PACKED_glPointParameterfSGIS *)packed; \
    ARGS_glPointParameterfSGIS *args = (ARGS_glPointParameterfSGIS *)&unpacked->args; \
    glPointParameterfSGIS(args->pname, args->param);; \
} while(0)
void glPointParameterfSGIS(glPointParameterfSGIS_ARG_EXPAND);
typedef void (*glPointParameterfSGIS_PTR)(glPointParameterfSGIS_ARG_EXPAND);
#define glPointParameterfv_INDEX 1555
#define glPointParameterfv_RETURN void
#define glPointParameterfv_ARG_NAMES pname, params
#define glPointParameterfv_ARG_EXPAND GLenum pname, const GLfloat * params
#define glPointParameterfv_PACKED PACKED_glPointParameterfv
#define glPointParameterfv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glPointParameterfv_NOT_VOID_WRAP(...) {}
#define pack_glPointParameterfv(_pname, _params) ({ \
    glPointParameterfv_PACKED *packed_data = malloc(sizeof(glPointParameterfv_PACKED)); \
    packed_data->index = glPointParameterfv_INDEX; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLfloat *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glPointParameterfv(packed, ret_v) do { \
    PACKED_glPointParameterfv *unpacked = (PACKED_glPointParameterfv *)packed; \
    ARGS_glPointParameterfv *args = (ARGS_glPointParameterfv *)&unpacked->args; \
    glPointParameterfv(args->pname, args->params);; \
} while(0)
void glPointParameterfv(glPointParameterfv_ARG_EXPAND);
typedef void (*glPointParameterfv_PTR)(glPointParameterfv_ARG_EXPAND);
#define glPointParameterfvARB_INDEX 1556
#define glPointParameterfvARB_RETURN void
#define glPointParameterfvARB_ARG_NAMES pname, params
#define glPointParameterfvARB_ARG_EXPAND GLenum pname, const GLfloat * params
#define glPointParameterfvARB_PACKED PACKED_glPointParameterfvARB
#define glPointParameterfvARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glPointParameterfvARB_NOT_VOID_WRAP(...) {}
#define pack_glPointParameterfvARB(_pname, _params) ({ \
    glPointParameterfvARB_PACKED *packed_data = malloc(sizeof(glPointParameterfvARB_PACKED)); \
    packed_data->index = glPointParameterfvARB_INDEX; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLfloat *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glPointParameterfvARB(packed, ret_v) do { \
    PACKED_glPointParameterfvARB *unpacked = (PACKED_glPointParameterfvARB *)packed; \
    ARGS_glPointParameterfvARB *args = (ARGS_glPointParameterfvARB *)&unpacked->args; \
    glPointParameterfvARB(args->pname, args->params);; \
} while(0)
void glPointParameterfvARB(glPointParameterfvARB_ARG_EXPAND);
typedef void (*glPointParameterfvARB_PTR)(glPointParameterfvARB_ARG_EXPAND);
#define glPointParameterfvEXT_INDEX 1557
#define glPointParameterfvEXT_RETURN void
#define glPointParameterfvEXT_ARG_NAMES pname, params
#define glPointParameterfvEXT_ARG_EXPAND GLenum pname, const GLfloat * params
#define glPointParameterfvEXT_PACKED PACKED_glPointParameterfvEXT
#define glPointParameterfvEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glPointParameterfvEXT_NOT_VOID_WRAP(...) {}
#define pack_glPointParameterfvEXT(_pname, _params) ({ \
    glPointParameterfvEXT_PACKED *packed_data = malloc(sizeof(glPointParameterfvEXT_PACKED)); \
    packed_data->index = glPointParameterfvEXT_INDEX; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLfloat *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glPointParameterfvEXT(packed, ret_v) do { \
    PACKED_glPointParameterfvEXT *unpacked = (PACKED_glPointParameterfvEXT *)packed; \
    ARGS_glPointParameterfvEXT *args = (ARGS_glPointParameterfvEXT *)&unpacked->args; \
    glPointParameterfvEXT(args->pname, args->params);; \
} while(0)
void glPointParameterfvEXT(glPointParameterfvEXT_ARG_EXPAND);
typedef void (*glPointParameterfvEXT_PTR)(glPointParameterfvEXT_ARG_EXPAND);
#define glPointParameterfvSGIS_INDEX 1558
#define glPointParameterfvSGIS_RETURN void
#define glPointParameterfvSGIS_ARG_NAMES pname, params
#define glPointParameterfvSGIS_ARG_EXPAND GLenum pname, const GLfloat * params
#define glPointParameterfvSGIS_PACKED PACKED_glPointParameterfvSGIS
#define glPointParameterfvSGIS_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glPointParameterfvSGIS_NOT_VOID_WRAP(...) {}
#define pack_glPointParameterfvSGIS(_pname, _params) ({ \
    glPointParameterfvSGIS_PACKED *packed_data = malloc(sizeof(glPointParameterfvSGIS_PACKED)); \
    packed_data->index = glPointParameterfvSGIS_INDEX; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLfloat *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glPointParameterfvSGIS(packed, ret_v) do { \
    PACKED_glPointParameterfvSGIS *unpacked = (PACKED_glPointParameterfvSGIS *)packed; \
    ARGS_glPointParameterfvSGIS *args = (ARGS_glPointParameterfvSGIS *)&unpacked->args; \
    glPointParameterfvSGIS(args->pname, args->params);; \
} while(0)
void glPointParameterfvSGIS(glPointParameterfvSGIS_ARG_EXPAND);
typedef void (*glPointParameterfvSGIS_PTR)(glPointParameterfvSGIS_ARG_EXPAND);
#define glPointParameteri_INDEX 1559
#define glPointParameteri_RETURN void
#define glPointParameteri_ARG_NAMES pname, param
#define glPointParameteri_ARG_EXPAND GLenum pname, GLint param
#define glPointParameteri_PACKED PACKED_glPointParameteri
#define glPointParameteri_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glPointParameteri_NOT_VOID_WRAP(...) {}
#define pack_glPointParameteri(_pname, _param) ({ \
    glPointParameteri_PACKED *packed_data = malloc(sizeof(glPointParameteri_PACKED)); \
    packed_data->index = glPointParameteri_INDEX; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.param = (GLint)_param; \
    (packed_call_t *)packed_data; \
})
#define call_glPointParameteri(packed, ret_v) do { \
    PACKED_glPointParameteri *unpacked = (PACKED_glPointParameteri *)packed; \
    ARGS_glPointParameteri *args = (ARGS_glPointParameteri *)&unpacked->args; \
    glPointParameteri(args->pname, args->param);; \
} while(0)
void glPointParameteri(glPointParameteri_ARG_EXPAND);
typedef void (*glPointParameteri_PTR)(glPointParameteri_ARG_EXPAND);
#define glPointParameteriNV_INDEX 1560
#define glPointParameteriNV_RETURN void
#define glPointParameteriNV_ARG_NAMES pname, param
#define glPointParameteriNV_ARG_EXPAND GLenum pname, GLint param
#define glPointParameteriNV_PACKED PACKED_glPointParameteriNV
#define glPointParameteriNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glPointParameteriNV_NOT_VOID_WRAP(...) {}
#define pack_glPointParameteriNV(_pname, _param) ({ \
    glPointParameteriNV_PACKED *packed_data = malloc(sizeof(glPointParameteriNV_PACKED)); \
    packed_data->index = glPointParameteriNV_INDEX; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.param = (GLint)_param; \
    (packed_call_t *)packed_data; \
})
#define call_glPointParameteriNV(packed, ret_v) do { \
    PACKED_glPointParameteriNV *unpacked = (PACKED_glPointParameteriNV *)packed; \
    ARGS_glPointParameteriNV *args = (ARGS_glPointParameteriNV *)&unpacked->args; \
    glPointParameteriNV(args->pname, args->param);; \
} while(0)
void glPointParameteriNV(glPointParameteriNV_ARG_EXPAND);
typedef void (*glPointParameteriNV_PTR)(glPointParameteriNV_ARG_EXPAND);
#define glPointParameteriv_INDEX 1561
#define glPointParameteriv_RETURN void
#define glPointParameteriv_ARG_NAMES pname, params
#define glPointParameteriv_ARG_EXPAND GLenum pname, const GLint * params
#define glPointParameteriv_PACKED PACKED_glPointParameteriv
#define glPointParameteriv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glPointParameteriv_NOT_VOID_WRAP(...) {}
#define pack_glPointParameteriv(_pname, _params) ({ \
    glPointParameteriv_PACKED *packed_data = malloc(sizeof(glPointParameteriv_PACKED)); \
    packed_data->index = glPointParameteriv_INDEX; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glPointParameteriv(packed, ret_v) do { \
    PACKED_glPointParameteriv *unpacked = (PACKED_glPointParameteriv *)packed; \
    ARGS_glPointParameteriv *args = (ARGS_glPointParameteriv *)&unpacked->args; \
    glPointParameteriv(args->pname, args->params);; \
} while(0)
void glPointParameteriv(glPointParameteriv_ARG_EXPAND);
typedef void (*glPointParameteriv_PTR)(glPointParameteriv_ARG_EXPAND);
#define glPointParameterivNV_INDEX 1562
#define glPointParameterivNV_RETURN void
#define glPointParameterivNV_ARG_NAMES pname, params
#define glPointParameterivNV_ARG_EXPAND GLenum pname, const GLint * params
#define glPointParameterivNV_PACKED PACKED_glPointParameterivNV
#define glPointParameterivNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glPointParameterivNV_NOT_VOID_WRAP(...) {}
#define pack_glPointParameterivNV(_pname, _params) ({ \
    glPointParameterivNV_PACKED *packed_data = malloc(sizeof(glPointParameterivNV_PACKED)); \
    packed_data->index = glPointParameterivNV_INDEX; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glPointParameterivNV(packed, ret_v) do { \
    PACKED_glPointParameterivNV *unpacked = (PACKED_glPointParameterivNV *)packed; \
    ARGS_glPointParameterivNV *args = (ARGS_glPointParameterivNV *)&unpacked->args; \
    glPointParameterivNV(args->pname, args->params);; \
} while(0)
void glPointParameterivNV(glPointParameterivNV_ARG_EXPAND);
typedef void (*glPointParameterivNV_PTR)(glPointParameterivNV_ARG_EXPAND);
#define glPointParameterx_INDEX 1563
#define glPointParameterx_RETURN void
#define glPointParameterx_ARG_NAMES pname, param
#define glPointParameterx_ARG_EXPAND GLenum pname, GLfixed param
#define glPointParameterx_PACKED PACKED_glPointParameterx
#define glPointParameterx_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glPointParameterx_NOT_VOID_WRAP(...) {}
#define pack_glPointParameterx(_pname, _param) ({ \
    glPointParameterx_PACKED *packed_data = malloc(sizeof(glPointParameterx_PACKED)); \
    packed_data->index = glPointParameterx_INDEX; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.param = (GLfixed)_param; \
    (packed_call_t *)packed_data; \
})
#define call_glPointParameterx(packed, ret_v) do { \
    PACKED_glPointParameterx *unpacked = (PACKED_glPointParameterx *)packed; \
    ARGS_glPointParameterx *args = (ARGS_glPointParameterx *)&unpacked->args; \
    glPointParameterx(args->pname, args->param);; \
} while(0)
void glPointParameterx(glPointParameterx_ARG_EXPAND);
typedef void (*glPointParameterx_PTR)(glPointParameterx_ARG_EXPAND);
#define glPointParameterxv_INDEX 1564
#define glPointParameterxv_RETURN void
#define glPointParameterxv_ARG_NAMES pname, params
#define glPointParameterxv_ARG_EXPAND GLenum pname, const GLfixed * params
#define glPointParameterxv_PACKED PACKED_glPointParameterxv
#define glPointParameterxv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glPointParameterxv_NOT_VOID_WRAP(...) {}
#define pack_glPointParameterxv(_pname, _params) ({ \
    glPointParameterxv_PACKED *packed_data = malloc(sizeof(glPointParameterxv_PACKED)); \
    packed_data->index = glPointParameterxv_INDEX; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLfixed *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glPointParameterxv(packed, ret_v) do { \
    PACKED_glPointParameterxv *unpacked = (PACKED_glPointParameterxv *)packed; \
    ARGS_glPointParameterxv *args = (ARGS_glPointParameterxv *)&unpacked->args; \
    glPointParameterxv(args->pname, args->params);; \
} while(0)
void glPointParameterxv(glPointParameterxv_ARG_EXPAND);
typedef void (*glPointParameterxv_PTR)(glPointParameterxv_ARG_EXPAND);
#define glPointParameterxvOES_INDEX 1565
#define glPointParameterxvOES_RETURN void
#define glPointParameterxvOES_ARG_NAMES pname, params
#define glPointParameterxvOES_ARG_EXPAND GLenum pname, const GLfixed * params
#define glPointParameterxvOES_PACKED PACKED_glPointParameterxvOES
#define glPointParameterxvOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glPointParameterxvOES_NOT_VOID_WRAP(...) {}
#define pack_glPointParameterxvOES(_pname, _params) ({ \
    glPointParameterxvOES_PACKED *packed_data = malloc(sizeof(glPointParameterxvOES_PACKED)); \
    packed_data->index = glPointParameterxvOES_INDEX; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLfixed *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glPointParameterxvOES(packed, ret_v) do { \
    PACKED_glPointParameterxvOES *unpacked = (PACKED_glPointParameterxvOES *)packed; \
    ARGS_glPointParameterxvOES *args = (ARGS_glPointParameterxvOES *)&unpacked->args; \
    glPointParameterxvOES(args->pname, args->params);; \
} while(0)
void glPointParameterxvOES(glPointParameterxvOES_ARG_EXPAND);
typedef void (*glPointParameterxvOES_PTR)(glPointParameterxvOES_ARG_EXPAND);
#define glPointSize_INDEX 1566
#define glPointSize_RETURN void
#define glPointSize_ARG_NAMES size
#define glPointSize_ARG_EXPAND GLfloat size
#define glPointSize_PACKED PACKED_glPointSize
#define glPointSize_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glPointSize_NOT_VOID_WRAP(...) {}
#define pack_glPointSize(_size) ({ \
    glPointSize_PACKED *packed_data = malloc(sizeof(glPointSize_PACKED)); \
    packed_data->index = glPointSize_INDEX; \
    packed_data->args.size = (GLfloat)_size; \
    (packed_call_t *)packed_data; \
})
#define call_glPointSize(packed, ret_v) do { \
    PACKED_glPointSize *unpacked = (PACKED_glPointSize *)packed; \
    ARGS_glPointSize *args = (ARGS_glPointSize *)&unpacked->args; \
    glPointSize(args->size);; \
} while(0)
void glPointSize(glPointSize_ARG_EXPAND);
typedef void (*glPointSize_PTR)(glPointSize_ARG_EXPAND);
#define glPointSizePointerOES_INDEX 1567
#define glPointSizePointerOES_RETURN void
#define glPointSizePointerOES_ARG_NAMES type, stride, pointer
#define glPointSizePointerOES_ARG_EXPAND GLenum type, GLsizei stride, const GLvoid * pointer
#define glPointSizePointerOES_PACKED PACKED_glPointSizePointerOES
#define glPointSizePointerOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glPointSizePointerOES_NOT_VOID_WRAP(...) {}
#define pack_glPointSizePointerOES(_type, _stride, _pointer) ({ \
    glPointSizePointerOES_PACKED *packed_data = malloc(sizeof(glPointSizePointerOES_PACKED)); \
    packed_data->index = glPointSizePointerOES_INDEX; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.stride = (GLsizei)_stride; \
    packed_data->args.pointer = (GLvoid *)_pointer; \
    (packed_call_t *)packed_data; \
})
#define call_glPointSizePointerOES(packed, ret_v) do { \
    PACKED_glPointSizePointerOES *unpacked = (PACKED_glPointSizePointerOES *)packed; \
    ARGS_glPointSizePointerOES *args = (ARGS_glPointSizePointerOES *)&unpacked->args; \
    glPointSizePointerOES(args->type, args->stride, args->pointer);; \
} while(0)
void glPointSizePointerOES(glPointSizePointerOES_ARG_EXPAND);
typedef void (*glPointSizePointerOES_PTR)(glPointSizePointerOES_ARG_EXPAND);
#define glPointSizex_INDEX 1568
#define glPointSizex_RETURN void
#define glPointSizex_ARG_NAMES size
#define glPointSizex_ARG_EXPAND GLfixed size
#define glPointSizex_PACKED PACKED_glPointSizex
#define glPointSizex_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glPointSizex_NOT_VOID_WRAP(...) {}
#define pack_glPointSizex(_size) ({ \
    glPointSizex_PACKED *packed_data = malloc(sizeof(glPointSizex_PACKED)); \
    packed_data->index = glPointSizex_INDEX; \
    packed_data->args.size = (GLfixed)_size; \
    (packed_call_t *)packed_data; \
})
#define call_glPointSizex(packed, ret_v) do { \
    PACKED_glPointSizex *unpacked = (PACKED_glPointSizex *)packed; \
    ARGS_glPointSizex *args = (ARGS_glPointSizex *)&unpacked->args; \
    glPointSizex(args->size);; \
} while(0)
void glPointSizex(glPointSizex_ARG_EXPAND);
typedef void (*glPointSizex_PTR)(glPointSizex_ARG_EXPAND);
#define glPointSizexOES_INDEX 1569
#define glPointSizexOES_RETURN void
#define glPointSizexOES_ARG_NAMES size
#define glPointSizexOES_ARG_EXPAND GLfixed size
#define glPointSizexOES_PACKED PACKED_glPointSizexOES
#define glPointSizexOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glPointSizexOES_NOT_VOID_WRAP(...) {}
#define pack_glPointSizexOES(_size) ({ \
    glPointSizexOES_PACKED *packed_data = malloc(sizeof(glPointSizexOES_PACKED)); \
    packed_data->index = glPointSizexOES_INDEX; \
    packed_data->args.size = (GLfixed)_size; \
    (packed_call_t *)packed_data; \
})
#define call_glPointSizexOES(packed, ret_v) do { \
    PACKED_glPointSizexOES *unpacked = (PACKED_glPointSizexOES *)packed; \
    ARGS_glPointSizexOES *args = (ARGS_glPointSizexOES *)&unpacked->args; \
    glPointSizexOES(args->size);; \
} while(0)
void glPointSizexOES(glPointSizexOES_ARG_EXPAND);
typedef void (*glPointSizexOES_PTR)(glPointSizexOES_ARG_EXPAND);
#define glPollAsyncSGIX_INDEX 1570
#define glPollAsyncSGIX_RETURN GLint
#define glPollAsyncSGIX_ARG_NAMES markerp
#define glPollAsyncSGIX_ARG_EXPAND GLuint * markerp
#define glPollAsyncSGIX_PACKED PACKED_glPollAsyncSGIX
#define glPollAsyncSGIX_VOID_ONLY_WRAP(...) {}
#define glPollAsyncSGIX_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glPollAsyncSGIX(_markerp) ({ \
    glPollAsyncSGIX_PACKED *packed_data = malloc(sizeof(glPollAsyncSGIX_PACKED)); \
    packed_data->index = glPollAsyncSGIX_INDEX; \
    packed_data->args.markerp = (GLuint *)_markerp; \
    (packed_call_t *)packed_data; \
})
#define call_glPollAsyncSGIX(packed, ret_v) do { \
    PACKED_glPollAsyncSGIX *unpacked = (PACKED_glPollAsyncSGIX *)packed; \
    ARGS_glPollAsyncSGIX *args = (ARGS_glPollAsyncSGIX *)&unpacked->args; \
    GLint *ret = (GLint *)ret_v; \
    if (ret != NULL) { \
        *ret = glPollAsyncSGIX(args->markerp);; \
    } else { \
        glPollAsyncSGIX(args->markerp);; \
    } \
} while(0)
GLint glPollAsyncSGIX(glPollAsyncSGIX_ARG_EXPAND);
typedef GLint (*glPollAsyncSGIX_PTR)(glPollAsyncSGIX_ARG_EXPAND);
#define glPollInstrumentsSGIX_INDEX 1571
#define glPollInstrumentsSGIX_RETURN GLint
#define glPollInstrumentsSGIX_ARG_NAMES marker_p
#define glPollInstrumentsSGIX_ARG_EXPAND GLint * marker_p
#define glPollInstrumentsSGIX_PACKED PACKED_glPollInstrumentsSGIX
#define glPollInstrumentsSGIX_VOID_ONLY_WRAP(...) {}
#define glPollInstrumentsSGIX_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glPollInstrumentsSGIX(_marker_p) ({ \
    glPollInstrumentsSGIX_PACKED *packed_data = malloc(sizeof(glPollInstrumentsSGIX_PACKED)); \
    packed_data->index = glPollInstrumentsSGIX_INDEX; \
    packed_data->args.marker_p = (GLint *)_marker_p; \
    (packed_call_t *)packed_data; \
})
#define call_glPollInstrumentsSGIX(packed, ret_v) do { \
    PACKED_glPollInstrumentsSGIX *unpacked = (PACKED_glPollInstrumentsSGIX *)packed; \
    ARGS_glPollInstrumentsSGIX *args = (ARGS_glPollInstrumentsSGIX *)&unpacked->args; \
    GLint *ret = (GLint *)ret_v; \
    if (ret != NULL) { \
        *ret = glPollInstrumentsSGIX(args->marker_p);; \
    } else { \
        glPollInstrumentsSGIX(args->marker_p);; \
    } \
} while(0)
GLint glPollInstrumentsSGIX(glPollInstrumentsSGIX_ARG_EXPAND);
typedef GLint (*glPollInstrumentsSGIX_PTR)(glPollInstrumentsSGIX_ARG_EXPAND);
#define glPolygonMode_INDEX 1572
#define glPolygonMode_RETURN void
#define glPolygonMode_ARG_NAMES face, mode
#define glPolygonMode_ARG_EXPAND GLenum face, GLenum mode
#define glPolygonMode_PACKED PACKED_glPolygonMode
#define glPolygonMode_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glPolygonMode_NOT_VOID_WRAP(...) {}
#define pack_glPolygonMode(_face, _mode) ({ \
    glPolygonMode_PACKED *packed_data = malloc(sizeof(glPolygonMode_PACKED)); \
    packed_data->index = glPolygonMode_INDEX; \
    packed_data->args.face = (GLenum)_face; \
    packed_data->args.mode = (GLenum)_mode; \
    (packed_call_t *)packed_data; \
})
#define call_glPolygonMode(packed, ret_v) do { \
    PACKED_glPolygonMode *unpacked = (PACKED_glPolygonMode *)packed; \
    ARGS_glPolygonMode *args = (ARGS_glPolygonMode *)&unpacked->args; \
    glPolygonMode(args->face, args->mode);; \
} while(0)
void glPolygonMode(glPolygonMode_ARG_EXPAND);
typedef void (*glPolygonMode_PTR)(glPolygonMode_ARG_EXPAND);
#define glPolygonOffset_INDEX 1573
#define glPolygonOffset_RETURN void
#define glPolygonOffset_ARG_NAMES factor, units
#define glPolygonOffset_ARG_EXPAND GLfloat factor, GLfloat units
#define glPolygonOffset_PACKED PACKED_glPolygonOffset
#define glPolygonOffset_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glPolygonOffset_NOT_VOID_WRAP(...) {}
#define pack_glPolygonOffset(_factor, _units) ({ \
    glPolygonOffset_PACKED *packed_data = malloc(sizeof(glPolygonOffset_PACKED)); \
    packed_data->index = glPolygonOffset_INDEX; \
    packed_data->args.factor = (GLfloat)_factor; \
    packed_data->args.units = (GLfloat)_units; \
    (packed_call_t *)packed_data; \
})
#define call_glPolygonOffset(packed, ret_v) do { \
    PACKED_glPolygonOffset *unpacked = (PACKED_glPolygonOffset *)packed; \
    ARGS_glPolygonOffset *args = (ARGS_glPolygonOffset *)&unpacked->args; \
    glPolygonOffset(args->factor, args->units);; \
} while(0)
void glPolygonOffset(glPolygonOffset_ARG_EXPAND);
typedef void (*glPolygonOffset_PTR)(glPolygonOffset_ARG_EXPAND);
#define glPolygonOffsetEXT_INDEX 1574
#define glPolygonOffsetEXT_RETURN void
#define glPolygonOffsetEXT_ARG_NAMES factor, bias
#define glPolygonOffsetEXT_ARG_EXPAND GLfloat factor, GLfloat bias
#define glPolygonOffsetEXT_PACKED PACKED_glPolygonOffsetEXT
#define glPolygonOffsetEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glPolygonOffsetEXT_NOT_VOID_WRAP(...) {}
#define pack_glPolygonOffsetEXT(_factor, _bias) ({ \
    glPolygonOffsetEXT_PACKED *packed_data = malloc(sizeof(glPolygonOffsetEXT_PACKED)); \
    packed_data->index = glPolygonOffsetEXT_INDEX; \
    packed_data->args.factor = (GLfloat)_factor; \
    packed_data->args.bias = (GLfloat)_bias; \
    (packed_call_t *)packed_data; \
})
#define call_glPolygonOffsetEXT(packed, ret_v) do { \
    PACKED_glPolygonOffsetEXT *unpacked = (PACKED_glPolygonOffsetEXT *)packed; \
    ARGS_glPolygonOffsetEXT *args = (ARGS_glPolygonOffsetEXT *)&unpacked->args; \
    glPolygonOffsetEXT(args->factor, args->bias);; \
} while(0)
void glPolygonOffsetEXT(glPolygonOffsetEXT_ARG_EXPAND);
typedef void (*glPolygonOffsetEXT_PTR)(glPolygonOffsetEXT_ARG_EXPAND);
#define glPolygonOffsetx_INDEX 1575
#define glPolygonOffsetx_RETURN void
#define glPolygonOffsetx_ARG_NAMES factor, units
#define glPolygonOffsetx_ARG_EXPAND GLfixed factor, GLfixed units
#define glPolygonOffsetx_PACKED PACKED_glPolygonOffsetx
#define glPolygonOffsetx_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glPolygonOffsetx_NOT_VOID_WRAP(...) {}
#define pack_glPolygonOffsetx(_factor, _units) ({ \
    glPolygonOffsetx_PACKED *packed_data = malloc(sizeof(glPolygonOffsetx_PACKED)); \
    packed_data->index = glPolygonOffsetx_INDEX; \
    packed_data->args.factor = (GLfixed)_factor; \
    packed_data->args.units = (GLfixed)_units; \
    (packed_call_t *)packed_data; \
})
#define call_glPolygonOffsetx(packed, ret_v) do { \
    PACKED_glPolygonOffsetx *unpacked = (PACKED_glPolygonOffsetx *)packed; \
    ARGS_glPolygonOffsetx *args = (ARGS_glPolygonOffsetx *)&unpacked->args; \
    glPolygonOffsetx(args->factor, args->units);; \
} while(0)
void glPolygonOffsetx(glPolygonOffsetx_ARG_EXPAND);
typedef void (*glPolygonOffsetx_PTR)(glPolygonOffsetx_ARG_EXPAND);
#define glPolygonOffsetxOES_INDEX 1576
#define glPolygonOffsetxOES_RETURN void
#define glPolygonOffsetxOES_ARG_NAMES factor, units
#define glPolygonOffsetxOES_ARG_EXPAND GLfixed factor, GLfixed units
#define glPolygonOffsetxOES_PACKED PACKED_glPolygonOffsetxOES
#define glPolygonOffsetxOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glPolygonOffsetxOES_NOT_VOID_WRAP(...) {}
#define pack_glPolygonOffsetxOES(_factor, _units) ({ \
    glPolygonOffsetxOES_PACKED *packed_data = malloc(sizeof(glPolygonOffsetxOES_PACKED)); \
    packed_data->index = glPolygonOffsetxOES_INDEX; \
    packed_data->args.factor = (GLfixed)_factor; \
    packed_data->args.units = (GLfixed)_units; \
    (packed_call_t *)packed_data; \
})
#define call_glPolygonOffsetxOES(packed, ret_v) do { \
    PACKED_glPolygonOffsetxOES *unpacked = (PACKED_glPolygonOffsetxOES *)packed; \
    ARGS_glPolygonOffsetxOES *args = (ARGS_glPolygonOffsetxOES *)&unpacked->args; \
    glPolygonOffsetxOES(args->factor, args->units);; \
} while(0)
void glPolygonOffsetxOES(glPolygonOffsetxOES_ARG_EXPAND);
typedef void (*glPolygonOffsetxOES_PTR)(glPolygonOffsetxOES_ARG_EXPAND);
#define glPolygonStipple_INDEX 1577
#define glPolygonStipple_RETURN void
#define glPolygonStipple_ARG_NAMES mask
#define glPolygonStipple_ARG_EXPAND const GLubyte * mask
#define glPolygonStipple_PACKED PACKED_glPolygonStipple
#define glPolygonStipple_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glPolygonStipple_NOT_VOID_WRAP(...) {}
#define pack_glPolygonStipple(_mask) ({ \
    glPolygonStipple_PACKED *packed_data = malloc(sizeof(glPolygonStipple_PACKED)); \
    packed_data->index = glPolygonStipple_INDEX; \
    packed_data->args.mask = (GLubyte *)_mask; \
    (packed_call_t *)packed_data; \
})
#define call_glPolygonStipple(packed, ret_v) do { \
    PACKED_glPolygonStipple *unpacked = (PACKED_glPolygonStipple *)packed; \
    ARGS_glPolygonStipple *args = (ARGS_glPolygonStipple *)&unpacked->args; \
    glPolygonStipple(args->mask);; \
} while(0)
void glPolygonStipple(glPolygonStipple_ARG_EXPAND);
typedef void (*glPolygonStipple_PTR)(glPolygonStipple_ARG_EXPAND);
#define glPopAttrib_INDEX 1578
#define glPopAttrib_RETURN void
#define glPopAttrib_ARG_NAMES 
#define glPopAttrib_ARG_EXPAND 
#define glPopAttrib_PACKED PACKED_glPopAttrib
#define glPopAttrib_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glPopAttrib_NOT_VOID_WRAP(...) {}
#define pack_glPopAttrib() ({ \
    glPopAttrib_PACKED *packed_data = malloc(sizeof(glPopAttrib_PACKED)); \
    packed_data->index = glPopAttrib_INDEX; \
    (packed_call_t *)packed_data; \
})
#define call_glPopAttrib(packed, ret_v) do { \
    glPopAttrib();; \
} while(0)
void glPopAttrib(glPopAttrib_ARG_EXPAND);
typedef void (*glPopAttrib_PTR)(glPopAttrib_ARG_EXPAND);
#define glPopClientAttrib_INDEX 1579
#define glPopClientAttrib_RETURN void
#define glPopClientAttrib_ARG_NAMES 
#define glPopClientAttrib_ARG_EXPAND 
#define glPopClientAttrib_PACKED PACKED_glPopClientAttrib
#define glPopClientAttrib_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glPopClientAttrib_NOT_VOID_WRAP(...) {}
#define pack_glPopClientAttrib() ({ \
    glPopClientAttrib_PACKED *packed_data = malloc(sizeof(glPopClientAttrib_PACKED)); \
    packed_data->index = glPopClientAttrib_INDEX; \
    (packed_call_t *)packed_data; \
})
#define call_glPopClientAttrib(packed, ret_v) do { \
    glPopClientAttrib();; \
} while(0)
void glPopClientAttrib(glPopClientAttrib_ARG_EXPAND);
typedef void (*glPopClientAttrib_PTR)(glPopClientAttrib_ARG_EXPAND);
#define glPopDebugGroup_INDEX 1580
#define glPopDebugGroup_RETURN void
#define glPopDebugGroup_ARG_NAMES 
#define glPopDebugGroup_ARG_EXPAND 
#define glPopDebugGroup_PACKED PACKED_glPopDebugGroup
#define glPopDebugGroup_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glPopDebugGroup_NOT_VOID_WRAP(...) {}
#define pack_glPopDebugGroup() ({ \
    glPopDebugGroup_PACKED *packed_data = malloc(sizeof(glPopDebugGroup_PACKED)); \
    packed_data->index = glPopDebugGroup_INDEX; \
    (packed_call_t *)packed_data; \
})
#define call_glPopDebugGroup(packed, ret_v) do { \
    glPopDebugGroup();; \
} while(0)
void glPopDebugGroup(glPopDebugGroup_ARG_EXPAND);
typedef void (*glPopDebugGroup_PTR)(glPopDebugGroup_ARG_EXPAND);
#define glPopMatrix_INDEX 1581
#define glPopMatrix_RETURN void
#define glPopMatrix_ARG_NAMES 
#define glPopMatrix_ARG_EXPAND 
#define glPopMatrix_PACKED PACKED_glPopMatrix
#define glPopMatrix_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glPopMatrix_NOT_VOID_WRAP(...) {}
#define pack_glPopMatrix() ({ \
    glPopMatrix_PACKED *packed_data = malloc(sizeof(glPopMatrix_PACKED)); \
    packed_data->index = glPopMatrix_INDEX; \
    (packed_call_t *)packed_data; \
})
#define call_glPopMatrix(packed, ret_v) do { \
    glPopMatrix();; \
} while(0)
void glPopMatrix(glPopMatrix_ARG_EXPAND);
typedef void (*glPopMatrix_PTR)(glPopMatrix_ARG_EXPAND);
#define glPopName_INDEX 1582
#define glPopName_RETURN void
#define glPopName_ARG_NAMES 
#define glPopName_ARG_EXPAND 
#define glPopName_PACKED PACKED_glPopName
#define glPopName_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glPopName_NOT_VOID_WRAP(...) {}
#define pack_glPopName() ({ \
    glPopName_PACKED *packed_data = malloc(sizeof(glPopName_PACKED)); \
    packed_data->index = glPopName_INDEX; \
    (packed_call_t *)packed_data; \
})
#define call_glPopName(packed, ret_v) do { \
    glPopName();; \
} while(0)
void glPopName(glPopName_ARG_EXPAND);
typedef void (*glPopName_PTR)(glPopName_ARG_EXPAND);
#define glPresentFrameDualFillNV_INDEX 1583
#define glPresentFrameDualFillNV_RETURN void
#define glPresentFrameDualFillNV_ARG_NAMES video_slot, minPresentTime, beginPresentTimeId, presentDurationId, type, target0, fill0, target1, fill1, target2, fill2, target3, fill3
#define glPresentFrameDualFillNV_ARG_EXPAND GLuint video_slot, GLuint64EXT minPresentTime, GLuint beginPresentTimeId, GLuint presentDurationId, GLenum type, GLenum target0, GLuint fill0, GLenum target1, GLuint fill1, GLenum target2, GLuint fill2, GLenum target3, GLuint fill3
#define glPresentFrameDualFillNV_PACKED PACKED_glPresentFrameDualFillNV
#define glPresentFrameDualFillNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glPresentFrameDualFillNV_NOT_VOID_WRAP(...) {}
#define pack_glPresentFrameDualFillNV(_video_slot, _minPresentTime, _beginPresentTimeId, _presentDurationId, _type, _target0, _fill0, _target1, _fill1, _target2, _fill2, _target3, _fill3) ({ \
    glPresentFrameDualFillNV_PACKED *packed_data = malloc(sizeof(glPresentFrameDualFillNV_PACKED)); \
    packed_data->index = glPresentFrameDualFillNV_INDEX; \
    packed_data->args.video_slot = (GLuint)_video_slot; \
    packed_data->args.minPresentTime = (GLuint64EXT)_minPresentTime; \
    packed_data->args.beginPresentTimeId = (GLuint)_beginPresentTimeId; \
    packed_data->args.presentDurationId = (GLuint)_presentDurationId; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.target0 = (GLenum)_target0; \
    packed_data->args.fill0 = (GLuint)_fill0; \
    packed_data->args.target1 = (GLenum)_target1; \
    packed_data->args.fill1 = (GLuint)_fill1; \
    packed_data->args.target2 = (GLenum)_target2; \
    packed_data->args.fill2 = (GLuint)_fill2; \
    packed_data->args.target3 = (GLenum)_target3; \
    packed_data->args.fill3 = (GLuint)_fill3; \
    (packed_call_t *)packed_data; \
})
#define call_glPresentFrameDualFillNV(packed, ret_v) do { \
    PACKED_glPresentFrameDualFillNV *unpacked = (PACKED_glPresentFrameDualFillNV *)packed; \
    ARGS_glPresentFrameDualFillNV *args = (ARGS_glPresentFrameDualFillNV *)&unpacked->args; \
    glPresentFrameDualFillNV(args->video_slot, args->minPresentTime, args->beginPresentTimeId, args->presentDurationId, args->type, args->target0, args->fill0, args->target1, args->fill1, args->target2, args->fill2, args->target3, args->fill3);; \
} while(0)
void glPresentFrameDualFillNV(glPresentFrameDualFillNV_ARG_EXPAND);
typedef void (*glPresentFrameDualFillNV_PTR)(glPresentFrameDualFillNV_ARG_EXPAND);
#define glPresentFrameKeyedNV_INDEX 1584
#define glPresentFrameKeyedNV_RETURN void
#define glPresentFrameKeyedNV_ARG_NAMES video_slot, minPresentTime, beginPresentTimeId, presentDurationId, type, target0, fill0, key0, target1, fill1, key1
#define glPresentFrameKeyedNV_ARG_EXPAND GLuint video_slot, GLuint64EXT minPresentTime, GLuint beginPresentTimeId, GLuint presentDurationId, GLenum type, GLenum target0, GLuint fill0, GLuint key0, GLenum target1, GLuint fill1, GLuint key1
#define glPresentFrameKeyedNV_PACKED PACKED_glPresentFrameKeyedNV
#define glPresentFrameKeyedNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glPresentFrameKeyedNV_NOT_VOID_WRAP(...) {}
#define pack_glPresentFrameKeyedNV(_video_slot, _minPresentTime, _beginPresentTimeId, _presentDurationId, _type, _target0, _fill0, _key0, _target1, _fill1, _key1) ({ \
    glPresentFrameKeyedNV_PACKED *packed_data = malloc(sizeof(glPresentFrameKeyedNV_PACKED)); \
    packed_data->index = glPresentFrameKeyedNV_INDEX; \
    packed_data->args.video_slot = (GLuint)_video_slot; \
    packed_data->args.minPresentTime = (GLuint64EXT)_minPresentTime; \
    packed_data->args.beginPresentTimeId = (GLuint)_beginPresentTimeId; \
    packed_data->args.presentDurationId = (GLuint)_presentDurationId; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.target0 = (GLenum)_target0; \
    packed_data->args.fill0 = (GLuint)_fill0; \
    packed_data->args.key0 = (GLuint)_key0; \
    packed_data->args.target1 = (GLenum)_target1; \
    packed_data->args.fill1 = (GLuint)_fill1; \
    packed_data->args.key1 = (GLuint)_key1; \
    (packed_call_t *)packed_data; \
})
#define call_glPresentFrameKeyedNV(packed, ret_v) do { \
    PACKED_glPresentFrameKeyedNV *unpacked = (PACKED_glPresentFrameKeyedNV *)packed; \
    ARGS_glPresentFrameKeyedNV *args = (ARGS_glPresentFrameKeyedNV *)&unpacked->args; \
    glPresentFrameKeyedNV(args->video_slot, args->minPresentTime, args->beginPresentTimeId, args->presentDurationId, args->type, args->target0, args->fill0, args->key0, args->target1, args->fill1, args->key1);; \
} while(0)
void glPresentFrameKeyedNV(glPresentFrameKeyedNV_ARG_EXPAND);
typedef void (*glPresentFrameKeyedNV_PTR)(glPresentFrameKeyedNV_ARG_EXPAND);
#define glPrimitiveRestartIndex_INDEX 1585
#define glPrimitiveRestartIndex_RETURN void
#define glPrimitiveRestartIndex_ARG_NAMES index
#define glPrimitiveRestartIndex_ARG_EXPAND GLuint index
#define glPrimitiveRestartIndex_PACKED PACKED_glPrimitiveRestartIndex
#define glPrimitiveRestartIndex_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glPrimitiveRestartIndex_NOT_VOID_WRAP(...) {}
#define pack_glPrimitiveRestartIndex(_index) ({ \
    glPrimitiveRestartIndex_PACKED *packed_data = malloc(sizeof(glPrimitiveRestartIndex_PACKED)); \
    packed_data->index = glPrimitiveRestartIndex_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    (packed_call_t *)packed_data; \
})
#define call_glPrimitiveRestartIndex(packed, ret_v) do { \
    PACKED_glPrimitiveRestartIndex *unpacked = (PACKED_glPrimitiveRestartIndex *)packed; \
    ARGS_glPrimitiveRestartIndex *args = (ARGS_glPrimitiveRestartIndex *)&unpacked->args; \
    glPrimitiveRestartIndex(args->index);; \
} while(0)
void glPrimitiveRestartIndex(glPrimitiveRestartIndex_ARG_EXPAND);
typedef void (*glPrimitiveRestartIndex_PTR)(glPrimitiveRestartIndex_ARG_EXPAND);
#define glPrimitiveRestartIndexNV_INDEX 1586
#define glPrimitiveRestartIndexNV_RETURN void
#define glPrimitiveRestartIndexNV_ARG_NAMES index
#define glPrimitiveRestartIndexNV_ARG_EXPAND GLuint index
#define glPrimitiveRestartIndexNV_PACKED PACKED_glPrimitiveRestartIndexNV
#define glPrimitiveRestartIndexNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glPrimitiveRestartIndexNV_NOT_VOID_WRAP(...) {}
#define pack_glPrimitiveRestartIndexNV(_index) ({ \
    glPrimitiveRestartIndexNV_PACKED *packed_data = malloc(sizeof(glPrimitiveRestartIndexNV_PACKED)); \
    packed_data->index = glPrimitiveRestartIndexNV_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    (packed_call_t *)packed_data; \
})
#define call_glPrimitiveRestartIndexNV(packed, ret_v) do { \
    PACKED_glPrimitiveRestartIndexNV *unpacked = (PACKED_glPrimitiveRestartIndexNV *)packed; \
    ARGS_glPrimitiveRestartIndexNV *args = (ARGS_glPrimitiveRestartIndexNV *)&unpacked->args; \
    glPrimitiveRestartIndexNV(args->index);; \
} while(0)
void glPrimitiveRestartIndexNV(glPrimitiveRestartIndexNV_ARG_EXPAND);
typedef void (*glPrimitiveRestartIndexNV_PTR)(glPrimitiveRestartIndexNV_ARG_EXPAND);
#define glPrimitiveRestartNV_INDEX 1587
#define glPrimitiveRestartNV_RETURN void
#define glPrimitiveRestartNV_ARG_NAMES 
#define glPrimitiveRestartNV_ARG_EXPAND 
#define glPrimitiveRestartNV_PACKED PACKED_glPrimitiveRestartNV
#define glPrimitiveRestartNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glPrimitiveRestartNV_NOT_VOID_WRAP(...) {}
#define pack_glPrimitiveRestartNV() ({ \
    glPrimitiveRestartNV_PACKED *packed_data = malloc(sizeof(glPrimitiveRestartNV_PACKED)); \
    packed_data->index = glPrimitiveRestartNV_INDEX; \
    (packed_call_t *)packed_data; \
})
#define call_glPrimitiveRestartNV(packed, ret_v) do { \
    glPrimitiveRestartNV();; \
} while(0)
void glPrimitiveRestartNV(glPrimitiveRestartNV_ARG_EXPAND);
typedef void (*glPrimitiveRestartNV_PTR)(glPrimitiveRestartNV_ARG_EXPAND);
#define glPrioritizeTextures_INDEX 1588
#define glPrioritizeTextures_RETURN void
#define glPrioritizeTextures_ARG_NAMES n, textures, priorities
#define glPrioritizeTextures_ARG_EXPAND GLsizei n, const GLuint * textures, const GLfloat * priorities
#define glPrioritizeTextures_PACKED PACKED_glPrioritizeTextures
#define glPrioritizeTextures_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glPrioritizeTextures_NOT_VOID_WRAP(...) {}
#define pack_glPrioritizeTextures(_n, _textures, _priorities) ({ \
    glPrioritizeTextures_PACKED *packed_data = malloc(sizeof(glPrioritizeTextures_PACKED)); \
    packed_data->index = glPrioritizeTextures_INDEX; \
    packed_data->args.n = (GLsizei)_n; \
    packed_data->args.textures = (GLuint *)_textures; \
    packed_data->args.priorities = (GLfloat *)_priorities; \
    (packed_call_t *)packed_data; \
})
#define call_glPrioritizeTextures(packed, ret_v) do { \
    PACKED_glPrioritizeTextures *unpacked = (PACKED_glPrioritizeTextures *)packed; \
    ARGS_glPrioritizeTextures *args = (ARGS_glPrioritizeTextures *)&unpacked->args; \
    glPrioritizeTextures(args->n, args->textures, args->priorities);; \
} while(0)
void glPrioritizeTextures(glPrioritizeTextures_ARG_EXPAND);
typedef void (*glPrioritizeTextures_PTR)(glPrioritizeTextures_ARG_EXPAND);
#define glPrioritizeTexturesEXT_INDEX 1589
#define glPrioritizeTexturesEXT_RETURN void
#define glPrioritizeTexturesEXT_ARG_NAMES n, textures, priorities
#define glPrioritizeTexturesEXT_ARG_EXPAND GLsizei n, const GLuint * textures, const GLclampf * priorities
#define glPrioritizeTexturesEXT_PACKED PACKED_glPrioritizeTexturesEXT
#define glPrioritizeTexturesEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glPrioritizeTexturesEXT_NOT_VOID_WRAP(...) {}
#define pack_glPrioritizeTexturesEXT(_n, _textures, _priorities) ({ \
    glPrioritizeTexturesEXT_PACKED *packed_data = malloc(sizeof(glPrioritizeTexturesEXT_PACKED)); \
    packed_data->index = glPrioritizeTexturesEXT_INDEX; \
    packed_data->args.n = (GLsizei)_n; \
    packed_data->args.textures = (GLuint *)_textures; \
    packed_data->args.priorities = (GLclampf *)_priorities; \
    (packed_call_t *)packed_data; \
})
#define call_glPrioritizeTexturesEXT(packed, ret_v) do { \
    PACKED_glPrioritizeTexturesEXT *unpacked = (PACKED_glPrioritizeTexturesEXT *)packed; \
    ARGS_glPrioritizeTexturesEXT *args = (ARGS_glPrioritizeTexturesEXT *)&unpacked->args; \
    glPrioritizeTexturesEXT(args->n, args->textures, args->priorities);; \
} while(0)
void glPrioritizeTexturesEXT(glPrioritizeTexturesEXT_ARG_EXPAND);
typedef void (*glPrioritizeTexturesEXT_PTR)(glPrioritizeTexturesEXT_ARG_EXPAND);
#define glPrioritizeTexturesxOES_INDEX 1590
#define glPrioritizeTexturesxOES_RETURN void
#define glPrioritizeTexturesxOES_ARG_NAMES n, textures, priorities
#define glPrioritizeTexturesxOES_ARG_EXPAND GLsizei n, const GLuint * textures, const GLfixed * priorities
#define glPrioritizeTexturesxOES_PACKED PACKED_glPrioritizeTexturesxOES
#define glPrioritizeTexturesxOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glPrioritizeTexturesxOES_NOT_VOID_WRAP(...) {}
#define pack_glPrioritizeTexturesxOES(_n, _textures, _priorities) ({ \
    glPrioritizeTexturesxOES_PACKED *packed_data = malloc(sizeof(glPrioritizeTexturesxOES_PACKED)); \
    packed_data->index = glPrioritizeTexturesxOES_INDEX; \
    packed_data->args.n = (GLsizei)_n; \
    packed_data->args.textures = (GLuint *)_textures; \
    packed_data->args.priorities = (GLfixed *)_priorities; \
    (packed_call_t *)packed_data; \
})
#define call_glPrioritizeTexturesxOES(packed, ret_v) do { \
    PACKED_glPrioritizeTexturesxOES *unpacked = (PACKED_glPrioritizeTexturesxOES *)packed; \
    ARGS_glPrioritizeTexturesxOES *args = (ARGS_glPrioritizeTexturesxOES *)&unpacked->args; \
    glPrioritizeTexturesxOES(args->n, args->textures, args->priorities);; \
} while(0)
void glPrioritizeTexturesxOES(glPrioritizeTexturesxOES_ARG_EXPAND);
typedef void (*glPrioritizeTexturesxOES_PTR)(glPrioritizeTexturesxOES_ARG_EXPAND);
#define glProgramBinary_INDEX 1591
#define glProgramBinary_RETURN void
#define glProgramBinary_ARG_NAMES program, binaryFormat, binary, length
#define glProgramBinary_ARG_EXPAND GLuint program, GLenum binaryFormat, const GLvoid * binary, GLsizei length
#define glProgramBinary_PACKED PACKED_glProgramBinary
#define glProgramBinary_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramBinary_NOT_VOID_WRAP(...) {}
#define pack_glProgramBinary(_program, _binaryFormat, _binary, _length) ({ \
    glProgramBinary_PACKED *packed_data = malloc(sizeof(glProgramBinary_PACKED)); \
    packed_data->index = glProgramBinary_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.binaryFormat = (GLenum)_binaryFormat; \
    packed_data->args.binary = (GLvoid *)_binary; \
    packed_data->args.length = (GLsizei)_length; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramBinary(packed, ret_v) do { \
    PACKED_glProgramBinary *unpacked = (PACKED_glProgramBinary *)packed; \
    ARGS_glProgramBinary *args = (ARGS_glProgramBinary *)&unpacked->args; \
    glProgramBinary(args->program, args->binaryFormat, args->binary, args->length);; \
} while(0)
void glProgramBinary(glProgramBinary_ARG_EXPAND);
typedef void (*glProgramBinary_PTR)(glProgramBinary_ARG_EXPAND);
#define glProgramBufferParametersIivNV_INDEX 1592
#define glProgramBufferParametersIivNV_RETURN void
#define glProgramBufferParametersIivNV_ARG_NAMES target, bindingIndex, wordIndex, count, params
#define glProgramBufferParametersIivNV_ARG_EXPAND GLenum target, GLuint bindingIndex, GLuint wordIndex, GLsizei count, const GLint * params
#define glProgramBufferParametersIivNV_PACKED PACKED_glProgramBufferParametersIivNV
#define glProgramBufferParametersIivNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramBufferParametersIivNV_NOT_VOID_WRAP(...) {}
#define pack_glProgramBufferParametersIivNV(_target, _bindingIndex, _wordIndex, _count, _params) ({ \
    glProgramBufferParametersIivNV_PACKED *packed_data = malloc(sizeof(glProgramBufferParametersIivNV_PACKED)); \
    packed_data->index = glProgramBufferParametersIivNV_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.bindingIndex = (GLuint)_bindingIndex; \
    packed_data->args.wordIndex = (GLuint)_wordIndex; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.params = (GLint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramBufferParametersIivNV(packed, ret_v) do { \
    PACKED_glProgramBufferParametersIivNV *unpacked = (PACKED_glProgramBufferParametersIivNV *)packed; \
    ARGS_glProgramBufferParametersIivNV *args = (ARGS_glProgramBufferParametersIivNV *)&unpacked->args; \
    glProgramBufferParametersIivNV(args->target, args->bindingIndex, args->wordIndex, args->count, args->params);; \
} while(0)
void glProgramBufferParametersIivNV(glProgramBufferParametersIivNV_ARG_EXPAND);
typedef void (*glProgramBufferParametersIivNV_PTR)(glProgramBufferParametersIivNV_ARG_EXPAND);
#define glProgramBufferParametersIuivNV_INDEX 1593
#define glProgramBufferParametersIuivNV_RETURN void
#define glProgramBufferParametersIuivNV_ARG_NAMES target, bindingIndex, wordIndex, count, params
#define glProgramBufferParametersIuivNV_ARG_EXPAND GLenum target, GLuint bindingIndex, GLuint wordIndex, GLsizei count, const GLuint * params
#define glProgramBufferParametersIuivNV_PACKED PACKED_glProgramBufferParametersIuivNV
#define glProgramBufferParametersIuivNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramBufferParametersIuivNV_NOT_VOID_WRAP(...) {}
#define pack_glProgramBufferParametersIuivNV(_target, _bindingIndex, _wordIndex, _count, _params) ({ \
    glProgramBufferParametersIuivNV_PACKED *packed_data = malloc(sizeof(glProgramBufferParametersIuivNV_PACKED)); \
    packed_data->index = glProgramBufferParametersIuivNV_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.bindingIndex = (GLuint)_bindingIndex; \
    packed_data->args.wordIndex = (GLuint)_wordIndex; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.params = (GLuint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramBufferParametersIuivNV(packed, ret_v) do { \
    PACKED_glProgramBufferParametersIuivNV *unpacked = (PACKED_glProgramBufferParametersIuivNV *)packed; \
    ARGS_glProgramBufferParametersIuivNV *args = (ARGS_glProgramBufferParametersIuivNV *)&unpacked->args; \
    glProgramBufferParametersIuivNV(args->target, args->bindingIndex, args->wordIndex, args->count, args->params);; \
} while(0)
void glProgramBufferParametersIuivNV(glProgramBufferParametersIuivNV_ARG_EXPAND);
typedef void (*glProgramBufferParametersIuivNV_PTR)(glProgramBufferParametersIuivNV_ARG_EXPAND);
#define glProgramBufferParametersfvNV_INDEX 1594
#define glProgramBufferParametersfvNV_RETURN void
#define glProgramBufferParametersfvNV_ARG_NAMES target, bindingIndex, wordIndex, count, params
#define glProgramBufferParametersfvNV_ARG_EXPAND GLenum target, GLuint bindingIndex, GLuint wordIndex, GLsizei count, const GLfloat * params
#define glProgramBufferParametersfvNV_PACKED PACKED_glProgramBufferParametersfvNV
#define glProgramBufferParametersfvNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramBufferParametersfvNV_NOT_VOID_WRAP(...) {}
#define pack_glProgramBufferParametersfvNV(_target, _bindingIndex, _wordIndex, _count, _params) ({ \
    glProgramBufferParametersfvNV_PACKED *packed_data = malloc(sizeof(glProgramBufferParametersfvNV_PACKED)); \
    packed_data->index = glProgramBufferParametersfvNV_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.bindingIndex = (GLuint)_bindingIndex; \
    packed_data->args.wordIndex = (GLuint)_wordIndex; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.params = (GLfloat *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramBufferParametersfvNV(packed, ret_v) do { \
    PACKED_glProgramBufferParametersfvNV *unpacked = (PACKED_glProgramBufferParametersfvNV *)packed; \
    ARGS_glProgramBufferParametersfvNV *args = (ARGS_glProgramBufferParametersfvNV *)&unpacked->args; \
    glProgramBufferParametersfvNV(args->target, args->bindingIndex, args->wordIndex, args->count, args->params);; \
} while(0)
void glProgramBufferParametersfvNV(glProgramBufferParametersfvNV_ARG_EXPAND);
typedef void (*glProgramBufferParametersfvNV_PTR)(glProgramBufferParametersfvNV_ARG_EXPAND);
#define glProgramEnvParameter4dARB_INDEX 1595
#define glProgramEnvParameter4dARB_RETURN void
#define glProgramEnvParameter4dARB_ARG_NAMES target, index, x, y, z, w
#define glProgramEnvParameter4dARB_ARG_EXPAND GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w
#define glProgramEnvParameter4dARB_PACKED PACKED_glProgramEnvParameter4dARB
#define glProgramEnvParameter4dARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramEnvParameter4dARB_NOT_VOID_WRAP(...) {}
#define pack_glProgramEnvParameter4dARB(_target, _index, _x, _y, _z, _w) ({ \
    glProgramEnvParameter4dARB_PACKED *packed_data = malloc(sizeof(glProgramEnvParameter4dARB_PACKED)); \
    packed_data->index = glProgramEnvParameter4dARB_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.x = (GLdouble)_x; \
    packed_data->args.y = (GLdouble)_y; \
    packed_data->args.z = (GLdouble)_z; \
    packed_data->args.w = (GLdouble)_w; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramEnvParameter4dARB(packed, ret_v) do { \
    PACKED_glProgramEnvParameter4dARB *unpacked = (PACKED_glProgramEnvParameter4dARB *)packed; \
    ARGS_glProgramEnvParameter4dARB *args = (ARGS_glProgramEnvParameter4dARB *)&unpacked->args; \
    glProgramEnvParameter4dARB(args->target, args->index, args->x, args->y, args->z, args->w);; \
} while(0)
void glProgramEnvParameter4dARB(glProgramEnvParameter4dARB_ARG_EXPAND);
typedef void (*glProgramEnvParameter4dARB_PTR)(glProgramEnvParameter4dARB_ARG_EXPAND);
#define glProgramEnvParameter4dvARB_INDEX 1596
#define glProgramEnvParameter4dvARB_RETURN void
#define glProgramEnvParameter4dvARB_ARG_NAMES target, index, params
#define glProgramEnvParameter4dvARB_ARG_EXPAND GLenum target, GLuint index, const GLdouble * params
#define glProgramEnvParameter4dvARB_PACKED PACKED_glProgramEnvParameter4dvARB
#define glProgramEnvParameter4dvARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramEnvParameter4dvARB_NOT_VOID_WRAP(...) {}
#define pack_glProgramEnvParameter4dvARB(_target, _index, _params) ({ \
    glProgramEnvParameter4dvARB_PACKED *packed_data = malloc(sizeof(glProgramEnvParameter4dvARB_PACKED)); \
    packed_data->index = glProgramEnvParameter4dvARB_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.params = (GLdouble *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramEnvParameter4dvARB(packed, ret_v) do { \
    PACKED_glProgramEnvParameter4dvARB *unpacked = (PACKED_glProgramEnvParameter4dvARB *)packed; \
    ARGS_glProgramEnvParameter4dvARB *args = (ARGS_glProgramEnvParameter4dvARB *)&unpacked->args; \
    glProgramEnvParameter4dvARB(args->target, args->index, args->params);; \
} while(0)
void glProgramEnvParameter4dvARB(glProgramEnvParameter4dvARB_ARG_EXPAND);
typedef void (*glProgramEnvParameter4dvARB_PTR)(glProgramEnvParameter4dvARB_ARG_EXPAND);
#define glProgramEnvParameter4fARB_INDEX 1597
#define glProgramEnvParameter4fARB_RETURN void
#define glProgramEnvParameter4fARB_ARG_NAMES target, index, x, y, z, w
#define glProgramEnvParameter4fARB_ARG_EXPAND GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w
#define glProgramEnvParameter4fARB_PACKED PACKED_glProgramEnvParameter4fARB
#define glProgramEnvParameter4fARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramEnvParameter4fARB_NOT_VOID_WRAP(...) {}
#define pack_glProgramEnvParameter4fARB(_target, _index, _x, _y, _z, _w) ({ \
    glProgramEnvParameter4fARB_PACKED *packed_data = malloc(sizeof(glProgramEnvParameter4fARB_PACKED)); \
    packed_data->index = glProgramEnvParameter4fARB_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.x = (GLfloat)_x; \
    packed_data->args.y = (GLfloat)_y; \
    packed_data->args.z = (GLfloat)_z; \
    packed_data->args.w = (GLfloat)_w; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramEnvParameter4fARB(packed, ret_v) do { \
    PACKED_glProgramEnvParameter4fARB *unpacked = (PACKED_glProgramEnvParameter4fARB *)packed; \
    ARGS_glProgramEnvParameter4fARB *args = (ARGS_glProgramEnvParameter4fARB *)&unpacked->args; \
    glProgramEnvParameter4fARB(args->target, args->index, args->x, args->y, args->z, args->w);; \
} while(0)
void glProgramEnvParameter4fARB(glProgramEnvParameter4fARB_ARG_EXPAND);
typedef void (*glProgramEnvParameter4fARB_PTR)(glProgramEnvParameter4fARB_ARG_EXPAND);
#define glProgramEnvParameter4fvARB_INDEX 1598
#define glProgramEnvParameter4fvARB_RETURN void
#define glProgramEnvParameter4fvARB_ARG_NAMES target, index, params
#define glProgramEnvParameter4fvARB_ARG_EXPAND GLenum target, GLuint index, const GLfloat * params
#define glProgramEnvParameter4fvARB_PACKED PACKED_glProgramEnvParameter4fvARB
#define glProgramEnvParameter4fvARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramEnvParameter4fvARB_NOT_VOID_WRAP(...) {}
#define pack_glProgramEnvParameter4fvARB(_target, _index, _params) ({ \
    glProgramEnvParameter4fvARB_PACKED *packed_data = malloc(sizeof(glProgramEnvParameter4fvARB_PACKED)); \
    packed_data->index = glProgramEnvParameter4fvARB_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.params = (GLfloat *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramEnvParameter4fvARB(packed, ret_v) do { \
    PACKED_glProgramEnvParameter4fvARB *unpacked = (PACKED_glProgramEnvParameter4fvARB *)packed; \
    ARGS_glProgramEnvParameter4fvARB *args = (ARGS_glProgramEnvParameter4fvARB *)&unpacked->args; \
    glProgramEnvParameter4fvARB(args->target, args->index, args->params);; \
} while(0)
void glProgramEnvParameter4fvARB(glProgramEnvParameter4fvARB_ARG_EXPAND);
typedef void (*glProgramEnvParameter4fvARB_PTR)(glProgramEnvParameter4fvARB_ARG_EXPAND);
#define glProgramEnvParameterI4iNV_INDEX 1599
#define glProgramEnvParameterI4iNV_RETURN void
#define glProgramEnvParameterI4iNV_ARG_NAMES target, index, x, y, z, w
#define glProgramEnvParameterI4iNV_ARG_EXPAND GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w
#define glProgramEnvParameterI4iNV_PACKED PACKED_glProgramEnvParameterI4iNV
#define glProgramEnvParameterI4iNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramEnvParameterI4iNV_NOT_VOID_WRAP(...) {}
#define pack_glProgramEnvParameterI4iNV(_target, _index, _x, _y, _z, _w) ({ \
    glProgramEnvParameterI4iNV_PACKED *packed_data = malloc(sizeof(glProgramEnvParameterI4iNV_PACKED)); \
    packed_data->index = glProgramEnvParameterI4iNV_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.x = (GLint)_x; \
    packed_data->args.y = (GLint)_y; \
    packed_data->args.z = (GLint)_z; \
    packed_data->args.w = (GLint)_w; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramEnvParameterI4iNV(packed, ret_v) do { \
    PACKED_glProgramEnvParameterI4iNV *unpacked = (PACKED_glProgramEnvParameterI4iNV *)packed; \
    ARGS_glProgramEnvParameterI4iNV *args = (ARGS_glProgramEnvParameterI4iNV *)&unpacked->args; \
    glProgramEnvParameterI4iNV(args->target, args->index, args->x, args->y, args->z, args->w);; \
} while(0)
void glProgramEnvParameterI4iNV(glProgramEnvParameterI4iNV_ARG_EXPAND);
typedef void (*glProgramEnvParameterI4iNV_PTR)(glProgramEnvParameterI4iNV_ARG_EXPAND);
#define glProgramEnvParameterI4ivNV_INDEX 1600
#define glProgramEnvParameterI4ivNV_RETURN void
#define glProgramEnvParameterI4ivNV_ARG_NAMES target, index, params
#define glProgramEnvParameterI4ivNV_ARG_EXPAND GLenum target, GLuint index, const GLint * params
#define glProgramEnvParameterI4ivNV_PACKED PACKED_glProgramEnvParameterI4ivNV
#define glProgramEnvParameterI4ivNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramEnvParameterI4ivNV_NOT_VOID_WRAP(...) {}
#define pack_glProgramEnvParameterI4ivNV(_target, _index, _params) ({ \
    glProgramEnvParameterI4ivNV_PACKED *packed_data = malloc(sizeof(glProgramEnvParameterI4ivNV_PACKED)); \
    packed_data->index = glProgramEnvParameterI4ivNV_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.params = (GLint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramEnvParameterI4ivNV(packed, ret_v) do { \
    PACKED_glProgramEnvParameterI4ivNV *unpacked = (PACKED_glProgramEnvParameterI4ivNV *)packed; \
    ARGS_glProgramEnvParameterI4ivNV *args = (ARGS_glProgramEnvParameterI4ivNV *)&unpacked->args; \
    glProgramEnvParameterI4ivNV(args->target, args->index, args->params);; \
} while(0)
void glProgramEnvParameterI4ivNV(glProgramEnvParameterI4ivNV_ARG_EXPAND);
typedef void (*glProgramEnvParameterI4ivNV_PTR)(glProgramEnvParameterI4ivNV_ARG_EXPAND);
#define glProgramEnvParameterI4uiNV_INDEX 1601
#define glProgramEnvParameterI4uiNV_RETURN void
#define glProgramEnvParameterI4uiNV_ARG_NAMES target, index, x, y, z, w
#define glProgramEnvParameterI4uiNV_ARG_EXPAND GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w
#define glProgramEnvParameterI4uiNV_PACKED PACKED_glProgramEnvParameterI4uiNV
#define glProgramEnvParameterI4uiNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramEnvParameterI4uiNV_NOT_VOID_WRAP(...) {}
#define pack_glProgramEnvParameterI4uiNV(_target, _index, _x, _y, _z, _w) ({ \
    glProgramEnvParameterI4uiNV_PACKED *packed_data = malloc(sizeof(glProgramEnvParameterI4uiNV_PACKED)); \
    packed_data->index = glProgramEnvParameterI4uiNV_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.x = (GLuint)_x; \
    packed_data->args.y = (GLuint)_y; \
    packed_data->args.z = (GLuint)_z; \
    packed_data->args.w = (GLuint)_w; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramEnvParameterI4uiNV(packed, ret_v) do { \
    PACKED_glProgramEnvParameterI4uiNV *unpacked = (PACKED_glProgramEnvParameterI4uiNV *)packed; \
    ARGS_glProgramEnvParameterI4uiNV *args = (ARGS_glProgramEnvParameterI4uiNV *)&unpacked->args; \
    glProgramEnvParameterI4uiNV(args->target, args->index, args->x, args->y, args->z, args->w);; \
} while(0)
void glProgramEnvParameterI4uiNV(glProgramEnvParameterI4uiNV_ARG_EXPAND);
typedef void (*glProgramEnvParameterI4uiNV_PTR)(glProgramEnvParameterI4uiNV_ARG_EXPAND);
#define glProgramEnvParameterI4uivNV_INDEX 1602
#define glProgramEnvParameterI4uivNV_RETURN void
#define glProgramEnvParameterI4uivNV_ARG_NAMES target, index, params
#define glProgramEnvParameterI4uivNV_ARG_EXPAND GLenum target, GLuint index, const GLuint * params
#define glProgramEnvParameterI4uivNV_PACKED PACKED_glProgramEnvParameterI4uivNV
#define glProgramEnvParameterI4uivNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramEnvParameterI4uivNV_NOT_VOID_WRAP(...) {}
#define pack_glProgramEnvParameterI4uivNV(_target, _index, _params) ({ \
    glProgramEnvParameterI4uivNV_PACKED *packed_data = malloc(sizeof(glProgramEnvParameterI4uivNV_PACKED)); \
    packed_data->index = glProgramEnvParameterI4uivNV_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.params = (GLuint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramEnvParameterI4uivNV(packed, ret_v) do { \
    PACKED_glProgramEnvParameterI4uivNV *unpacked = (PACKED_glProgramEnvParameterI4uivNV *)packed; \
    ARGS_glProgramEnvParameterI4uivNV *args = (ARGS_glProgramEnvParameterI4uivNV *)&unpacked->args; \
    glProgramEnvParameterI4uivNV(args->target, args->index, args->params);; \
} while(0)
void glProgramEnvParameterI4uivNV(glProgramEnvParameterI4uivNV_ARG_EXPAND);
typedef void (*glProgramEnvParameterI4uivNV_PTR)(glProgramEnvParameterI4uivNV_ARG_EXPAND);
#define glProgramEnvParameters4fvEXT_INDEX 1603
#define glProgramEnvParameters4fvEXT_RETURN void
#define glProgramEnvParameters4fvEXT_ARG_NAMES target, index, count, params
#define glProgramEnvParameters4fvEXT_ARG_EXPAND GLenum target, GLuint index, GLsizei count, const GLfloat * params
#define glProgramEnvParameters4fvEXT_PACKED PACKED_glProgramEnvParameters4fvEXT
#define glProgramEnvParameters4fvEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramEnvParameters4fvEXT_NOT_VOID_WRAP(...) {}
#define pack_glProgramEnvParameters4fvEXT(_target, _index, _count, _params) ({ \
    glProgramEnvParameters4fvEXT_PACKED *packed_data = malloc(sizeof(glProgramEnvParameters4fvEXT_PACKED)); \
    packed_data->index = glProgramEnvParameters4fvEXT_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.params = (GLfloat *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramEnvParameters4fvEXT(packed, ret_v) do { \
    PACKED_glProgramEnvParameters4fvEXT *unpacked = (PACKED_glProgramEnvParameters4fvEXT *)packed; \
    ARGS_glProgramEnvParameters4fvEXT *args = (ARGS_glProgramEnvParameters4fvEXT *)&unpacked->args; \
    glProgramEnvParameters4fvEXT(args->target, args->index, args->count, args->params);; \
} while(0)
void glProgramEnvParameters4fvEXT(glProgramEnvParameters4fvEXT_ARG_EXPAND);
typedef void (*glProgramEnvParameters4fvEXT_PTR)(glProgramEnvParameters4fvEXT_ARG_EXPAND);
#define glProgramEnvParametersI4ivNV_INDEX 1604
#define glProgramEnvParametersI4ivNV_RETURN void
#define glProgramEnvParametersI4ivNV_ARG_NAMES target, index, count, params
#define glProgramEnvParametersI4ivNV_ARG_EXPAND GLenum target, GLuint index, GLsizei count, const GLint * params
#define glProgramEnvParametersI4ivNV_PACKED PACKED_glProgramEnvParametersI4ivNV
#define glProgramEnvParametersI4ivNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramEnvParametersI4ivNV_NOT_VOID_WRAP(...) {}
#define pack_glProgramEnvParametersI4ivNV(_target, _index, _count, _params) ({ \
    glProgramEnvParametersI4ivNV_PACKED *packed_data = malloc(sizeof(glProgramEnvParametersI4ivNV_PACKED)); \
    packed_data->index = glProgramEnvParametersI4ivNV_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.params = (GLint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramEnvParametersI4ivNV(packed, ret_v) do { \
    PACKED_glProgramEnvParametersI4ivNV *unpacked = (PACKED_glProgramEnvParametersI4ivNV *)packed; \
    ARGS_glProgramEnvParametersI4ivNV *args = (ARGS_glProgramEnvParametersI4ivNV *)&unpacked->args; \
    glProgramEnvParametersI4ivNV(args->target, args->index, args->count, args->params);; \
} while(0)
void glProgramEnvParametersI4ivNV(glProgramEnvParametersI4ivNV_ARG_EXPAND);
typedef void (*glProgramEnvParametersI4ivNV_PTR)(glProgramEnvParametersI4ivNV_ARG_EXPAND);
#define glProgramEnvParametersI4uivNV_INDEX 1605
#define glProgramEnvParametersI4uivNV_RETURN void
#define glProgramEnvParametersI4uivNV_ARG_NAMES target, index, count, params
#define glProgramEnvParametersI4uivNV_ARG_EXPAND GLenum target, GLuint index, GLsizei count, const GLuint * params
#define glProgramEnvParametersI4uivNV_PACKED PACKED_glProgramEnvParametersI4uivNV
#define glProgramEnvParametersI4uivNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramEnvParametersI4uivNV_NOT_VOID_WRAP(...) {}
#define pack_glProgramEnvParametersI4uivNV(_target, _index, _count, _params) ({ \
    glProgramEnvParametersI4uivNV_PACKED *packed_data = malloc(sizeof(glProgramEnvParametersI4uivNV_PACKED)); \
    packed_data->index = glProgramEnvParametersI4uivNV_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.params = (GLuint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramEnvParametersI4uivNV(packed, ret_v) do { \
    PACKED_glProgramEnvParametersI4uivNV *unpacked = (PACKED_glProgramEnvParametersI4uivNV *)packed; \
    ARGS_glProgramEnvParametersI4uivNV *args = (ARGS_glProgramEnvParametersI4uivNV *)&unpacked->args; \
    glProgramEnvParametersI4uivNV(args->target, args->index, args->count, args->params);; \
} while(0)
void glProgramEnvParametersI4uivNV(glProgramEnvParametersI4uivNV_ARG_EXPAND);
typedef void (*glProgramEnvParametersI4uivNV_PTR)(glProgramEnvParametersI4uivNV_ARG_EXPAND);
#define glProgramLocalParameter4dARB_INDEX 1606
#define glProgramLocalParameter4dARB_RETURN void
#define glProgramLocalParameter4dARB_ARG_NAMES target, index, x, y, z, w
#define glProgramLocalParameter4dARB_ARG_EXPAND GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w
#define glProgramLocalParameter4dARB_PACKED PACKED_glProgramLocalParameter4dARB
#define glProgramLocalParameter4dARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramLocalParameter4dARB_NOT_VOID_WRAP(...) {}
#define pack_glProgramLocalParameter4dARB(_target, _index, _x, _y, _z, _w) ({ \
    glProgramLocalParameter4dARB_PACKED *packed_data = malloc(sizeof(glProgramLocalParameter4dARB_PACKED)); \
    packed_data->index = glProgramLocalParameter4dARB_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.x = (GLdouble)_x; \
    packed_data->args.y = (GLdouble)_y; \
    packed_data->args.z = (GLdouble)_z; \
    packed_data->args.w = (GLdouble)_w; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramLocalParameter4dARB(packed, ret_v) do { \
    PACKED_glProgramLocalParameter4dARB *unpacked = (PACKED_glProgramLocalParameter4dARB *)packed; \
    ARGS_glProgramLocalParameter4dARB *args = (ARGS_glProgramLocalParameter4dARB *)&unpacked->args; \
    glProgramLocalParameter4dARB(args->target, args->index, args->x, args->y, args->z, args->w);; \
} while(0)
void glProgramLocalParameter4dARB(glProgramLocalParameter4dARB_ARG_EXPAND);
typedef void (*glProgramLocalParameter4dARB_PTR)(glProgramLocalParameter4dARB_ARG_EXPAND);
#define glProgramLocalParameter4dvARB_INDEX 1607
#define glProgramLocalParameter4dvARB_RETURN void
#define glProgramLocalParameter4dvARB_ARG_NAMES target, index, params
#define glProgramLocalParameter4dvARB_ARG_EXPAND GLenum target, GLuint index, const GLdouble * params
#define glProgramLocalParameter4dvARB_PACKED PACKED_glProgramLocalParameter4dvARB
#define glProgramLocalParameter4dvARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramLocalParameter4dvARB_NOT_VOID_WRAP(...) {}
#define pack_glProgramLocalParameter4dvARB(_target, _index, _params) ({ \
    glProgramLocalParameter4dvARB_PACKED *packed_data = malloc(sizeof(glProgramLocalParameter4dvARB_PACKED)); \
    packed_data->index = glProgramLocalParameter4dvARB_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.params = (GLdouble *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramLocalParameter4dvARB(packed, ret_v) do { \
    PACKED_glProgramLocalParameter4dvARB *unpacked = (PACKED_glProgramLocalParameter4dvARB *)packed; \
    ARGS_glProgramLocalParameter4dvARB *args = (ARGS_glProgramLocalParameter4dvARB *)&unpacked->args; \
    glProgramLocalParameter4dvARB(args->target, args->index, args->params);; \
} while(0)
void glProgramLocalParameter4dvARB(glProgramLocalParameter4dvARB_ARG_EXPAND);
typedef void (*glProgramLocalParameter4dvARB_PTR)(glProgramLocalParameter4dvARB_ARG_EXPAND);
#define glProgramLocalParameter4fARB_INDEX 1608
#define glProgramLocalParameter4fARB_RETURN void
#define glProgramLocalParameter4fARB_ARG_NAMES target, index, x, y, z, w
#define glProgramLocalParameter4fARB_ARG_EXPAND GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w
#define glProgramLocalParameter4fARB_PACKED PACKED_glProgramLocalParameter4fARB
#define glProgramLocalParameter4fARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramLocalParameter4fARB_NOT_VOID_WRAP(...) {}
#define pack_glProgramLocalParameter4fARB(_target, _index, _x, _y, _z, _w) ({ \
    glProgramLocalParameter4fARB_PACKED *packed_data = malloc(sizeof(glProgramLocalParameter4fARB_PACKED)); \
    packed_data->index = glProgramLocalParameter4fARB_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.x = (GLfloat)_x; \
    packed_data->args.y = (GLfloat)_y; \
    packed_data->args.z = (GLfloat)_z; \
    packed_data->args.w = (GLfloat)_w; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramLocalParameter4fARB(packed, ret_v) do { \
    PACKED_glProgramLocalParameter4fARB *unpacked = (PACKED_glProgramLocalParameter4fARB *)packed; \
    ARGS_glProgramLocalParameter4fARB *args = (ARGS_glProgramLocalParameter4fARB *)&unpacked->args; \
    glProgramLocalParameter4fARB(args->target, args->index, args->x, args->y, args->z, args->w);; \
} while(0)
void glProgramLocalParameter4fARB(glProgramLocalParameter4fARB_ARG_EXPAND);
typedef void (*glProgramLocalParameter4fARB_PTR)(glProgramLocalParameter4fARB_ARG_EXPAND);
#define glProgramLocalParameter4fvARB_INDEX 1609
#define glProgramLocalParameter4fvARB_RETURN void
#define glProgramLocalParameter4fvARB_ARG_NAMES target, index, params
#define glProgramLocalParameter4fvARB_ARG_EXPAND GLenum target, GLuint index, const GLfloat * params
#define glProgramLocalParameter4fvARB_PACKED PACKED_glProgramLocalParameter4fvARB
#define glProgramLocalParameter4fvARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramLocalParameter4fvARB_NOT_VOID_WRAP(...) {}
#define pack_glProgramLocalParameter4fvARB(_target, _index, _params) ({ \
    glProgramLocalParameter4fvARB_PACKED *packed_data = malloc(sizeof(glProgramLocalParameter4fvARB_PACKED)); \
    packed_data->index = glProgramLocalParameter4fvARB_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.params = (GLfloat *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramLocalParameter4fvARB(packed, ret_v) do { \
    PACKED_glProgramLocalParameter4fvARB *unpacked = (PACKED_glProgramLocalParameter4fvARB *)packed; \
    ARGS_glProgramLocalParameter4fvARB *args = (ARGS_glProgramLocalParameter4fvARB *)&unpacked->args; \
    glProgramLocalParameter4fvARB(args->target, args->index, args->params);; \
} while(0)
void glProgramLocalParameter4fvARB(glProgramLocalParameter4fvARB_ARG_EXPAND);
typedef void (*glProgramLocalParameter4fvARB_PTR)(glProgramLocalParameter4fvARB_ARG_EXPAND);
#define glProgramLocalParameterI4iNV_INDEX 1610
#define glProgramLocalParameterI4iNV_RETURN void
#define glProgramLocalParameterI4iNV_ARG_NAMES target, index, x, y, z, w
#define glProgramLocalParameterI4iNV_ARG_EXPAND GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w
#define glProgramLocalParameterI4iNV_PACKED PACKED_glProgramLocalParameterI4iNV
#define glProgramLocalParameterI4iNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramLocalParameterI4iNV_NOT_VOID_WRAP(...) {}
#define pack_glProgramLocalParameterI4iNV(_target, _index, _x, _y, _z, _w) ({ \
    glProgramLocalParameterI4iNV_PACKED *packed_data = malloc(sizeof(glProgramLocalParameterI4iNV_PACKED)); \
    packed_data->index = glProgramLocalParameterI4iNV_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.x = (GLint)_x; \
    packed_data->args.y = (GLint)_y; \
    packed_data->args.z = (GLint)_z; \
    packed_data->args.w = (GLint)_w; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramLocalParameterI4iNV(packed, ret_v) do { \
    PACKED_glProgramLocalParameterI4iNV *unpacked = (PACKED_glProgramLocalParameterI4iNV *)packed; \
    ARGS_glProgramLocalParameterI4iNV *args = (ARGS_glProgramLocalParameterI4iNV *)&unpacked->args; \
    glProgramLocalParameterI4iNV(args->target, args->index, args->x, args->y, args->z, args->w);; \
} while(0)
void glProgramLocalParameterI4iNV(glProgramLocalParameterI4iNV_ARG_EXPAND);
typedef void (*glProgramLocalParameterI4iNV_PTR)(glProgramLocalParameterI4iNV_ARG_EXPAND);
#define glProgramLocalParameterI4ivNV_INDEX 1611
#define glProgramLocalParameterI4ivNV_RETURN void
#define glProgramLocalParameterI4ivNV_ARG_NAMES target, index, params
#define glProgramLocalParameterI4ivNV_ARG_EXPAND GLenum target, GLuint index, const GLint * params
#define glProgramLocalParameterI4ivNV_PACKED PACKED_glProgramLocalParameterI4ivNV
#define glProgramLocalParameterI4ivNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramLocalParameterI4ivNV_NOT_VOID_WRAP(...) {}
#define pack_glProgramLocalParameterI4ivNV(_target, _index, _params) ({ \
    glProgramLocalParameterI4ivNV_PACKED *packed_data = malloc(sizeof(glProgramLocalParameterI4ivNV_PACKED)); \
    packed_data->index = glProgramLocalParameterI4ivNV_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.params = (GLint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramLocalParameterI4ivNV(packed, ret_v) do { \
    PACKED_glProgramLocalParameterI4ivNV *unpacked = (PACKED_glProgramLocalParameterI4ivNV *)packed; \
    ARGS_glProgramLocalParameterI4ivNV *args = (ARGS_glProgramLocalParameterI4ivNV *)&unpacked->args; \
    glProgramLocalParameterI4ivNV(args->target, args->index, args->params);; \
} while(0)
void glProgramLocalParameterI4ivNV(glProgramLocalParameterI4ivNV_ARG_EXPAND);
typedef void (*glProgramLocalParameterI4ivNV_PTR)(glProgramLocalParameterI4ivNV_ARG_EXPAND);
#define glProgramLocalParameterI4uiNV_INDEX 1612
#define glProgramLocalParameterI4uiNV_RETURN void
#define glProgramLocalParameterI4uiNV_ARG_NAMES target, index, x, y, z, w
#define glProgramLocalParameterI4uiNV_ARG_EXPAND GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w
#define glProgramLocalParameterI4uiNV_PACKED PACKED_glProgramLocalParameterI4uiNV
#define glProgramLocalParameterI4uiNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramLocalParameterI4uiNV_NOT_VOID_WRAP(...) {}
#define pack_glProgramLocalParameterI4uiNV(_target, _index, _x, _y, _z, _w) ({ \
    glProgramLocalParameterI4uiNV_PACKED *packed_data = malloc(sizeof(glProgramLocalParameterI4uiNV_PACKED)); \
    packed_data->index = glProgramLocalParameterI4uiNV_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.x = (GLuint)_x; \
    packed_data->args.y = (GLuint)_y; \
    packed_data->args.z = (GLuint)_z; \
    packed_data->args.w = (GLuint)_w; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramLocalParameterI4uiNV(packed, ret_v) do { \
    PACKED_glProgramLocalParameterI4uiNV *unpacked = (PACKED_glProgramLocalParameterI4uiNV *)packed; \
    ARGS_glProgramLocalParameterI4uiNV *args = (ARGS_glProgramLocalParameterI4uiNV *)&unpacked->args; \
    glProgramLocalParameterI4uiNV(args->target, args->index, args->x, args->y, args->z, args->w);; \
} while(0)
void glProgramLocalParameterI4uiNV(glProgramLocalParameterI4uiNV_ARG_EXPAND);
typedef void (*glProgramLocalParameterI4uiNV_PTR)(glProgramLocalParameterI4uiNV_ARG_EXPAND);
#define glProgramLocalParameterI4uivNV_INDEX 1613
#define glProgramLocalParameterI4uivNV_RETURN void
#define glProgramLocalParameterI4uivNV_ARG_NAMES target, index, params
#define glProgramLocalParameterI4uivNV_ARG_EXPAND GLenum target, GLuint index, const GLuint * params
#define glProgramLocalParameterI4uivNV_PACKED PACKED_glProgramLocalParameterI4uivNV
#define glProgramLocalParameterI4uivNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramLocalParameterI4uivNV_NOT_VOID_WRAP(...) {}
#define pack_glProgramLocalParameterI4uivNV(_target, _index, _params) ({ \
    glProgramLocalParameterI4uivNV_PACKED *packed_data = malloc(sizeof(glProgramLocalParameterI4uivNV_PACKED)); \
    packed_data->index = glProgramLocalParameterI4uivNV_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.params = (GLuint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramLocalParameterI4uivNV(packed, ret_v) do { \
    PACKED_glProgramLocalParameterI4uivNV *unpacked = (PACKED_glProgramLocalParameterI4uivNV *)packed; \
    ARGS_glProgramLocalParameterI4uivNV *args = (ARGS_glProgramLocalParameterI4uivNV *)&unpacked->args; \
    glProgramLocalParameterI4uivNV(args->target, args->index, args->params);; \
} while(0)
void glProgramLocalParameterI4uivNV(glProgramLocalParameterI4uivNV_ARG_EXPAND);
typedef void (*glProgramLocalParameterI4uivNV_PTR)(glProgramLocalParameterI4uivNV_ARG_EXPAND);
#define glProgramLocalParameters4fvEXT_INDEX 1614
#define glProgramLocalParameters4fvEXT_RETURN void
#define glProgramLocalParameters4fvEXT_ARG_NAMES target, index, count, params
#define glProgramLocalParameters4fvEXT_ARG_EXPAND GLenum target, GLuint index, GLsizei count, const GLfloat * params
#define glProgramLocalParameters4fvEXT_PACKED PACKED_glProgramLocalParameters4fvEXT
#define glProgramLocalParameters4fvEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramLocalParameters4fvEXT_NOT_VOID_WRAP(...) {}
#define pack_glProgramLocalParameters4fvEXT(_target, _index, _count, _params) ({ \
    glProgramLocalParameters4fvEXT_PACKED *packed_data = malloc(sizeof(glProgramLocalParameters4fvEXT_PACKED)); \
    packed_data->index = glProgramLocalParameters4fvEXT_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.params = (GLfloat *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramLocalParameters4fvEXT(packed, ret_v) do { \
    PACKED_glProgramLocalParameters4fvEXT *unpacked = (PACKED_glProgramLocalParameters4fvEXT *)packed; \
    ARGS_glProgramLocalParameters4fvEXT *args = (ARGS_glProgramLocalParameters4fvEXT *)&unpacked->args; \
    glProgramLocalParameters4fvEXT(args->target, args->index, args->count, args->params);; \
} while(0)
void glProgramLocalParameters4fvEXT(glProgramLocalParameters4fvEXT_ARG_EXPAND);
typedef void (*glProgramLocalParameters4fvEXT_PTR)(glProgramLocalParameters4fvEXT_ARG_EXPAND);
#define glProgramLocalParametersI4ivNV_INDEX 1615
#define glProgramLocalParametersI4ivNV_RETURN void
#define glProgramLocalParametersI4ivNV_ARG_NAMES target, index, count, params
#define glProgramLocalParametersI4ivNV_ARG_EXPAND GLenum target, GLuint index, GLsizei count, const GLint * params
#define glProgramLocalParametersI4ivNV_PACKED PACKED_glProgramLocalParametersI4ivNV
#define glProgramLocalParametersI4ivNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramLocalParametersI4ivNV_NOT_VOID_WRAP(...) {}
#define pack_glProgramLocalParametersI4ivNV(_target, _index, _count, _params) ({ \
    glProgramLocalParametersI4ivNV_PACKED *packed_data = malloc(sizeof(glProgramLocalParametersI4ivNV_PACKED)); \
    packed_data->index = glProgramLocalParametersI4ivNV_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.params = (GLint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramLocalParametersI4ivNV(packed, ret_v) do { \
    PACKED_glProgramLocalParametersI4ivNV *unpacked = (PACKED_glProgramLocalParametersI4ivNV *)packed; \
    ARGS_glProgramLocalParametersI4ivNV *args = (ARGS_glProgramLocalParametersI4ivNV *)&unpacked->args; \
    glProgramLocalParametersI4ivNV(args->target, args->index, args->count, args->params);; \
} while(0)
void glProgramLocalParametersI4ivNV(glProgramLocalParametersI4ivNV_ARG_EXPAND);
typedef void (*glProgramLocalParametersI4ivNV_PTR)(glProgramLocalParametersI4ivNV_ARG_EXPAND);
#define glProgramLocalParametersI4uivNV_INDEX 1616
#define glProgramLocalParametersI4uivNV_RETURN void
#define glProgramLocalParametersI4uivNV_ARG_NAMES target, index, count, params
#define glProgramLocalParametersI4uivNV_ARG_EXPAND GLenum target, GLuint index, GLsizei count, const GLuint * params
#define glProgramLocalParametersI4uivNV_PACKED PACKED_glProgramLocalParametersI4uivNV
#define glProgramLocalParametersI4uivNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramLocalParametersI4uivNV_NOT_VOID_WRAP(...) {}
#define pack_glProgramLocalParametersI4uivNV(_target, _index, _count, _params) ({ \
    glProgramLocalParametersI4uivNV_PACKED *packed_data = malloc(sizeof(glProgramLocalParametersI4uivNV_PACKED)); \
    packed_data->index = glProgramLocalParametersI4uivNV_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.params = (GLuint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramLocalParametersI4uivNV(packed, ret_v) do { \
    PACKED_glProgramLocalParametersI4uivNV *unpacked = (PACKED_glProgramLocalParametersI4uivNV *)packed; \
    ARGS_glProgramLocalParametersI4uivNV *args = (ARGS_glProgramLocalParametersI4uivNV *)&unpacked->args; \
    glProgramLocalParametersI4uivNV(args->target, args->index, args->count, args->params);; \
} while(0)
void glProgramLocalParametersI4uivNV(glProgramLocalParametersI4uivNV_ARG_EXPAND);
typedef void (*glProgramLocalParametersI4uivNV_PTR)(glProgramLocalParametersI4uivNV_ARG_EXPAND);
#define glProgramNamedParameter4dNV_INDEX 1617
#define glProgramNamedParameter4dNV_RETURN void
#define glProgramNamedParameter4dNV_ARG_NAMES id, len, name, x, y, z, w
#define glProgramNamedParameter4dNV_ARG_EXPAND GLuint id, GLsizei len, const GLubyte * name, GLdouble x, GLdouble y, GLdouble z, GLdouble w
#define glProgramNamedParameter4dNV_PACKED PACKED_glProgramNamedParameter4dNV
#define glProgramNamedParameter4dNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramNamedParameter4dNV_NOT_VOID_WRAP(...) {}
#define pack_glProgramNamedParameter4dNV(_id, _len, _name, _x, _y, _z, _w) ({ \
    glProgramNamedParameter4dNV_PACKED *packed_data = malloc(sizeof(glProgramNamedParameter4dNV_PACKED)); \
    packed_data->index = glProgramNamedParameter4dNV_INDEX; \
    packed_data->args.id = (GLuint)_id; \
    packed_data->args.len = (GLsizei)_len; \
    packed_data->args.name = (GLubyte *)_name; \
    packed_data->args.x = (GLdouble)_x; \
    packed_data->args.y = (GLdouble)_y; \
    packed_data->args.z = (GLdouble)_z; \
    packed_data->args.w = (GLdouble)_w; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramNamedParameter4dNV(packed, ret_v) do { \
    PACKED_glProgramNamedParameter4dNV *unpacked = (PACKED_glProgramNamedParameter4dNV *)packed; \
    ARGS_glProgramNamedParameter4dNV *args = (ARGS_glProgramNamedParameter4dNV *)&unpacked->args; \
    glProgramNamedParameter4dNV(args->id, args->len, args->name, args->x, args->y, args->z, args->w);; \
} while(0)
void glProgramNamedParameter4dNV(glProgramNamedParameter4dNV_ARG_EXPAND);
typedef void (*glProgramNamedParameter4dNV_PTR)(glProgramNamedParameter4dNV_ARG_EXPAND);
#define glProgramNamedParameter4dvNV_INDEX 1618
#define glProgramNamedParameter4dvNV_RETURN void
#define glProgramNamedParameter4dvNV_ARG_NAMES id, len, name, v
#define glProgramNamedParameter4dvNV_ARG_EXPAND GLuint id, GLsizei len, const GLubyte * name, const GLdouble * v
#define glProgramNamedParameter4dvNV_PACKED PACKED_glProgramNamedParameter4dvNV
#define glProgramNamedParameter4dvNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramNamedParameter4dvNV_NOT_VOID_WRAP(...) {}
#define pack_glProgramNamedParameter4dvNV(_id, _len, _name, _v) ({ \
    glProgramNamedParameter4dvNV_PACKED *packed_data = malloc(sizeof(glProgramNamedParameter4dvNV_PACKED)); \
    packed_data->index = glProgramNamedParameter4dvNV_INDEX; \
    packed_data->args.id = (GLuint)_id; \
    packed_data->args.len = (GLsizei)_len; \
    packed_data->args.name = (GLubyte *)_name; \
    packed_data->args.v = (GLdouble *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramNamedParameter4dvNV(packed, ret_v) do { \
    PACKED_glProgramNamedParameter4dvNV *unpacked = (PACKED_glProgramNamedParameter4dvNV *)packed; \
    ARGS_glProgramNamedParameter4dvNV *args = (ARGS_glProgramNamedParameter4dvNV *)&unpacked->args; \
    glProgramNamedParameter4dvNV(args->id, args->len, args->name, args->v);; \
} while(0)
void glProgramNamedParameter4dvNV(glProgramNamedParameter4dvNV_ARG_EXPAND);
typedef void (*glProgramNamedParameter4dvNV_PTR)(glProgramNamedParameter4dvNV_ARG_EXPAND);
#define glProgramNamedParameter4fNV_INDEX 1619
#define glProgramNamedParameter4fNV_RETURN void
#define glProgramNamedParameter4fNV_ARG_NAMES id, len, name, x, y, z, w
#define glProgramNamedParameter4fNV_ARG_EXPAND GLuint id, GLsizei len, const GLubyte * name, GLfloat x, GLfloat y, GLfloat z, GLfloat w
#define glProgramNamedParameter4fNV_PACKED PACKED_glProgramNamedParameter4fNV
#define glProgramNamedParameter4fNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramNamedParameter4fNV_NOT_VOID_WRAP(...) {}
#define pack_glProgramNamedParameter4fNV(_id, _len, _name, _x, _y, _z, _w) ({ \
    glProgramNamedParameter4fNV_PACKED *packed_data = malloc(sizeof(glProgramNamedParameter4fNV_PACKED)); \
    packed_data->index = glProgramNamedParameter4fNV_INDEX; \
    packed_data->args.id = (GLuint)_id; \
    packed_data->args.len = (GLsizei)_len; \
    packed_data->args.name = (GLubyte *)_name; \
    packed_data->args.x = (GLfloat)_x; \
    packed_data->args.y = (GLfloat)_y; \
    packed_data->args.z = (GLfloat)_z; \
    packed_data->args.w = (GLfloat)_w; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramNamedParameter4fNV(packed, ret_v) do { \
    PACKED_glProgramNamedParameter4fNV *unpacked = (PACKED_glProgramNamedParameter4fNV *)packed; \
    ARGS_glProgramNamedParameter4fNV *args = (ARGS_glProgramNamedParameter4fNV *)&unpacked->args; \
    glProgramNamedParameter4fNV(args->id, args->len, args->name, args->x, args->y, args->z, args->w);; \
} while(0)
void glProgramNamedParameter4fNV(glProgramNamedParameter4fNV_ARG_EXPAND);
typedef void (*glProgramNamedParameter4fNV_PTR)(glProgramNamedParameter4fNV_ARG_EXPAND);
#define glProgramNamedParameter4fvNV_INDEX 1620
#define glProgramNamedParameter4fvNV_RETURN void
#define glProgramNamedParameter4fvNV_ARG_NAMES id, len, name, v
#define glProgramNamedParameter4fvNV_ARG_EXPAND GLuint id, GLsizei len, const GLubyte * name, const GLfloat * v
#define glProgramNamedParameter4fvNV_PACKED PACKED_glProgramNamedParameter4fvNV
#define glProgramNamedParameter4fvNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramNamedParameter4fvNV_NOT_VOID_WRAP(...) {}
#define pack_glProgramNamedParameter4fvNV(_id, _len, _name, _v) ({ \
    glProgramNamedParameter4fvNV_PACKED *packed_data = malloc(sizeof(glProgramNamedParameter4fvNV_PACKED)); \
    packed_data->index = glProgramNamedParameter4fvNV_INDEX; \
    packed_data->args.id = (GLuint)_id; \
    packed_data->args.len = (GLsizei)_len; \
    packed_data->args.name = (GLubyte *)_name; \
    packed_data->args.v = (GLfloat *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramNamedParameter4fvNV(packed, ret_v) do { \
    PACKED_glProgramNamedParameter4fvNV *unpacked = (PACKED_glProgramNamedParameter4fvNV *)packed; \
    ARGS_glProgramNamedParameter4fvNV *args = (ARGS_glProgramNamedParameter4fvNV *)&unpacked->args; \
    glProgramNamedParameter4fvNV(args->id, args->len, args->name, args->v);; \
} while(0)
void glProgramNamedParameter4fvNV(glProgramNamedParameter4fvNV_ARG_EXPAND);
typedef void (*glProgramNamedParameter4fvNV_PTR)(glProgramNamedParameter4fvNV_ARG_EXPAND);
#define glProgramParameter4dNV_INDEX 1621
#define glProgramParameter4dNV_RETURN void
#define glProgramParameter4dNV_ARG_NAMES target, index, x, y, z, w
#define glProgramParameter4dNV_ARG_EXPAND GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w
#define glProgramParameter4dNV_PACKED PACKED_glProgramParameter4dNV
#define glProgramParameter4dNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramParameter4dNV_NOT_VOID_WRAP(...) {}
#define pack_glProgramParameter4dNV(_target, _index, _x, _y, _z, _w) ({ \
    glProgramParameter4dNV_PACKED *packed_data = malloc(sizeof(glProgramParameter4dNV_PACKED)); \
    packed_data->index = glProgramParameter4dNV_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.x = (GLdouble)_x; \
    packed_data->args.y = (GLdouble)_y; \
    packed_data->args.z = (GLdouble)_z; \
    packed_data->args.w = (GLdouble)_w; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramParameter4dNV(packed, ret_v) do { \
    PACKED_glProgramParameter4dNV *unpacked = (PACKED_glProgramParameter4dNV *)packed; \
    ARGS_glProgramParameter4dNV *args = (ARGS_glProgramParameter4dNV *)&unpacked->args; \
    glProgramParameter4dNV(args->target, args->index, args->x, args->y, args->z, args->w);; \
} while(0)
void glProgramParameter4dNV(glProgramParameter4dNV_ARG_EXPAND);
typedef void (*glProgramParameter4dNV_PTR)(glProgramParameter4dNV_ARG_EXPAND);
#define glProgramParameter4dvNV_INDEX 1622
#define glProgramParameter4dvNV_RETURN void
#define glProgramParameter4dvNV_ARG_NAMES target, index, v
#define glProgramParameter4dvNV_ARG_EXPAND GLenum target, GLuint index, const GLdouble * v
#define glProgramParameter4dvNV_PACKED PACKED_glProgramParameter4dvNV
#define glProgramParameter4dvNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramParameter4dvNV_NOT_VOID_WRAP(...) {}
#define pack_glProgramParameter4dvNV(_target, _index, _v) ({ \
    glProgramParameter4dvNV_PACKED *packed_data = malloc(sizeof(glProgramParameter4dvNV_PACKED)); \
    packed_data->index = glProgramParameter4dvNV_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.v = (GLdouble *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramParameter4dvNV(packed, ret_v) do { \
    PACKED_glProgramParameter4dvNV *unpacked = (PACKED_glProgramParameter4dvNV *)packed; \
    ARGS_glProgramParameter4dvNV *args = (ARGS_glProgramParameter4dvNV *)&unpacked->args; \
    glProgramParameter4dvNV(args->target, args->index, args->v);; \
} while(0)
void glProgramParameter4dvNV(glProgramParameter4dvNV_ARG_EXPAND);
typedef void (*glProgramParameter4dvNV_PTR)(glProgramParameter4dvNV_ARG_EXPAND);
#define glProgramParameter4fNV_INDEX 1623
#define glProgramParameter4fNV_RETURN void
#define glProgramParameter4fNV_ARG_NAMES target, index, x, y, z, w
#define glProgramParameter4fNV_ARG_EXPAND GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w
#define glProgramParameter4fNV_PACKED PACKED_glProgramParameter4fNV
#define glProgramParameter4fNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramParameter4fNV_NOT_VOID_WRAP(...) {}
#define pack_glProgramParameter4fNV(_target, _index, _x, _y, _z, _w) ({ \
    glProgramParameter4fNV_PACKED *packed_data = malloc(sizeof(glProgramParameter4fNV_PACKED)); \
    packed_data->index = glProgramParameter4fNV_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.x = (GLfloat)_x; \
    packed_data->args.y = (GLfloat)_y; \
    packed_data->args.z = (GLfloat)_z; \
    packed_data->args.w = (GLfloat)_w; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramParameter4fNV(packed, ret_v) do { \
    PACKED_glProgramParameter4fNV *unpacked = (PACKED_glProgramParameter4fNV *)packed; \
    ARGS_glProgramParameter4fNV *args = (ARGS_glProgramParameter4fNV *)&unpacked->args; \
    glProgramParameter4fNV(args->target, args->index, args->x, args->y, args->z, args->w);; \
} while(0)
void glProgramParameter4fNV(glProgramParameter4fNV_ARG_EXPAND);
typedef void (*glProgramParameter4fNV_PTR)(glProgramParameter4fNV_ARG_EXPAND);
#define glProgramParameter4fvNV_INDEX 1624
#define glProgramParameter4fvNV_RETURN void
#define glProgramParameter4fvNV_ARG_NAMES target, index, v
#define glProgramParameter4fvNV_ARG_EXPAND GLenum target, GLuint index, const GLfloat * v
#define glProgramParameter4fvNV_PACKED PACKED_glProgramParameter4fvNV
#define glProgramParameter4fvNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramParameter4fvNV_NOT_VOID_WRAP(...) {}
#define pack_glProgramParameter4fvNV(_target, _index, _v) ({ \
    glProgramParameter4fvNV_PACKED *packed_data = malloc(sizeof(glProgramParameter4fvNV_PACKED)); \
    packed_data->index = glProgramParameter4fvNV_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.v = (GLfloat *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramParameter4fvNV(packed, ret_v) do { \
    PACKED_glProgramParameter4fvNV *unpacked = (PACKED_glProgramParameter4fvNV *)packed; \
    ARGS_glProgramParameter4fvNV *args = (ARGS_glProgramParameter4fvNV *)&unpacked->args; \
    glProgramParameter4fvNV(args->target, args->index, args->v);; \
} while(0)
void glProgramParameter4fvNV(glProgramParameter4fvNV_ARG_EXPAND);
typedef void (*glProgramParameter4fvNV_PTR)(glProgramParameter4fvNV_ARG_EXPAND);
#define glProgramParameteri_INDEX 1625
#define glProgramParameteri_RETURN void
#define glProgramParameteri_ARG_NAMES program, pname, value
#define glProgramParameteri_ARG_EXPAND GLuint program, GLenum pname, GLint value
#define glProgramParameteri_PACKED PACKED_glProgramParameteri
#define glProgramParameteri_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramParameteri_NOT_VOID_WRAP(...) {}
#define pack_glProgramParameteri(_program, _pname, _value) ({ \
    glProgramParameteri_PACKED *packed_data = malloc(sizeof(glProgramParameteri_PACKED)); \
    packed_data->index = glProgramParameteri_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.value = (GLint)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramParameteri(packed, ret_v) do { \
    PACKED_glProgramParameteri *unpacked = (PACKED_glProgramParameteri *)packed; \
    ARGS_glProgramParameteri *args = (ARGS_glProgramParameteri *)&unpacked->args; \
    glProgramParameteri(args->program, args->pname, args->value);; \
} while(0)
void glProgramParameteri(glProgramParameteri_ARG_EXPAND);
typedef void (*glProgramParameteri_PTR)(glProgramParameteri_ARG_EXPAND);
#define glProgramParameteriARB_INDEX 1626
#define glProgramParameteriARB_RETURN void
#define glProgramParameteriARB_ARG_NAMES program, pname, value
#define glProgramParameteriARB_ARG_EXPAND GLuint program, GLenum pname, GLint value
#define glProgramParameteriARB_PACKED PACKED_glProgramParameteriARB
#define glProgramParameteriARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramParameteriARB_NOT_VOID_WRAP(...) {}
#define pack_glProgramParameteriARB(_program, _pname, _value) ({ \
    glProgramParameteriARB_PACKED *packed_data = malloc(sizeof(glProgramParameteriARB_PACKED)); \
    packed_data->index = glProgramParameteriARB_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.value = (GLint)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramParameteriARB(packed, ret_v) do { \
    PACKED_glProgramParameteriARB *unpacked = (PACKED_glProgramParameteriARB *)packed; \
    ARGS_glProgramParameteriARB *args = (ARGS_glProgramParameteriARB *)&unpacked->args; \
    glProgramParameteriARB(args->program, args->pname, args->value);; \
} while(0)
void glProgramParameteriARB(glProgramParameteriARB_ARG_EXPAND);
typedef void (*glProgramParameteriARB_PTR)(glProgramParameteriARB_ARG_EXPAND);
#define glProgramParameteriEXT_INDEX 1627
#define glProgramParameteriEXT_RETURN void
#define glProgramParameteriEXT_ARG_NAMES program, pname, value
#define glProgramParameteriEXT_ARG_EXPAND GLuint program, GLenum pname, GLint value
#define glProgramParameteriEXT_PACKED PACKED_glProgramParameteriEXT
#define glProgramParameteriEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramParameteriEXT_NOT_VOID_WRAP(...) {}
#define pack_glProgramParameteriEXT(_program, _pname, _value) ({ \
    glProgramParameteriEXT_PACKED *packed_data = malloc(sizeof(glProgramParameteriEXT_PACKED)); \
    packed_data->index = glProgramParameteriEXT_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.value = (GLint)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramParameteriEXT(packed, ret_v) do { \
    PACKED_glProgramParameteriEXT *unpacked = (PACKED_glProgramParameteriEXT *)packed; \
    ARGS_glProgramParameteriEXT *args = (ARGS_glProgramParameteriEXT *)&unpacked->args; \
    glProgramParameteriEXT(args->program, args->pname, args->value);; \
} while(0)
void glProgramParameteriEXT(glProgramParameteriEXT_ARG_EXPAND);
typedef void (*glProgramParameteriEXT_PTR)(glProgramParameteriEXT_ARG_EXPAND);
#define glProgramParameters4dvNV_INDEX 1628
#define glProgramParameters4dvNV_RETURN void
#define glProgramParameters4dvNV_ARG_NAMES target, index, count, v
#define glProgramParameters4dvNV_ARG_EXPAND GLenum target, GLuint index, GLsizei count, const GLdouble * v
#define glProgramParameters4dvNV_PACKED PACKED_glProgramParameters4dvNV
#define glProgramParameters4dvNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramParameters4dvNV_NOT_VOID_WRAP(...) {}
#define pack_glProgramParameters4dvNV(_target, _index, _count, _v) ({ \
    glProgramParameters4dvNV_PACKED *packed_data = malloc(sizeof(glProgramParameters4dvNV_PACKED)); \
    packed_data->index = glProgramParameters4dvNV_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.v = (GLdouble *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramParameters4dvNV(packed, ret_v) do { \
    PACKED_glProgramParameters4dvNV *unpacked = (PACKED_glProgramParameters4dvNV *)packed; \
    ARGS_glProgramParameters4dvNV *args = (ARGS_glProgramParameters4dvNV *)&unpacked->args; \
    glProgramParameters4dvNV(args->target, args->index, args->count, args->v);; \
} while(0)
void glProgramParameters4dvNV(glProgramParameters4dvNV_ARG_EXPAND);
typedef void (*glProgramParameters4dvNV_PTR)(glProgramParameters4dvNV_ARG_EXPAND);
#define glProgramParameters4fvNV_INDEX 1629
#define glProgramParameters4fvNV_RETURN void
#define glProgramParameters4fvNV_ARG_NAMES target, index, count, v
#define glProgramParameters4fvNV_ARG_EXPAND GLenum target, GLuint index, GLsizei count, const GLfloat * v
#define glProgramParameters4fvNV_PACKED PACKED_glProgramParameters4fvNV
#define glProgramParameters4fvNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramParameters4fvNV_NOT_VOID_WRAP(...) {}
#define pack_glProgramParameters4fvNV(_target, _index, _count, _v) ({ \
    glProgramParameters4fvNV_PACKED *packed_data = malloc(sizeof(glProgramParameters4fvNV_PACKED)); \
    packed_data->index = glProgramParameters4fvNV_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.v = (GLfloat *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramParameters4fvNV(packed, ret_v) do { \
    PACKED_glProgramParameters4fvNV *unpacked = (PACKED_glProgramParameters4fvNV *)packed; \
    ARGS_glProgramParameters4fvNV *args = (ARGS_glProgramParameters4fvNV *)&unpacked->args; \
    glProgramParameters4fvNV(args->target, args->index, args->count, args->v);; \
} while(0)
void glProgramParameters4fvNV(glProgramParameters4fvNV_ARG_EXPAND);
typedef void (*glProgramParameters4fvNV_PTR)(glProgramParameters4fvNV_ARG_EXPAND);
#define glProgramStringARB_INDEX 1630
#define glProgramStringARB_RETURN void
#define glProgramStringARB_ARG_NAMES target, format, len, string
#define glProgramStringARB_ARG_EXPAND GLenum target, GLenum format, GLsizei len, const GLvoid * string
#define glProgramStringARB_PACKED PACKED_glProgramStringARB
#define glProgramStringARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramStringARB_NOT_VOID_WRAP(...) {}
#define pack_glProgramStringARB(_target, _format, _len, _string) ({ \
    glProgramStringARB_PACKED *packed_data = malloc(sizeof(glProgramStringARB_PACKED)); \
    packed_data->index = glProgramStringARB_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.format = (GLenum)_format; \
    packed_data->args.len = (GLsizei)_len; \
    packed_data->args.string = (GLvoid *)_string; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramStringARB(packed, ret_v) do { \
    PACKED_glProgramStringARB *unpacked = (PACKED_glProgramStringARB *)packed; \
    ARGS_glProgramStringARB *args = (ARGS_glProgramStringARB *)&unpacked->args; \
    glProgramStringARB(args->target, args->format, args->len, args->string);; \
} while(0)
void glProgramStringARB(glProgramStringARB_ARG_EXPAND);
typedef void (*glProgramStringARB_PTR)(glProgramStringARB_ARG_EXPAND);
#define glProgramSubroutineParametersuivNV_INDEX 1631
#define glProgramSubroutineParametersuivNV_RETURN void
#define glProgramSubroutineParametersuivNV_ARG_NAMES target, count, params
#define glProgramSubroutineParametersuivNV_ARG_EXPAND GLenum target, GLsizei count, const GLuint * params
#define glProgramSubroutineParametersuivNV_PACKED PACKED_glProgramSubroutineParametersuivNV
#define glProgramSubroutineParametersuivNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramSubroutineParametersuivNV_NOT_VOID_WRAP(...) {}
#define pack_glProgramSubroutineParametersuivNV(_target, _count, _params) ({ \
    glProgramSubroutineParametersuivNV_PACKED *packed_data = malloc(sizeof(glProgramSubroutineParametersuivNV_PACKED)); \
    packed_data->index = glProgramSubroutineParametersuivNV_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.params = (GLuint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramSubroutineParametersuivNV(packed, ret_v) do { \
    PACKED_glProgramSubroutineParametersuivNV *unpacked = (PACKED_glProgramSubroutineParametersuivNV *)packed; \
    ARGS_glProgramSubroutineParametersuivNV *args = (ARGS_glProgramSubroutineParametersuivNV *)&unpacked->args; \
    glProgramSubroutineParametersuivNV(args->target, args->count, args->params);; \
} while(0)
void glProgramSubroutineParametersuivNV(glProgramSubroutineParametersuivNV_ARG_EXPAND);
typedef void (*glProgramSubroutineParametersuivNV_PTR)(glProgramSubroutineParametersuivNV_ARG_EXPAND);
#define glProgramUniform1d_INDEX 1632
#define glProgramUniform1d_RETURN void
#define glProgramUniform1d_ARG_NAMES program, location, v0
#define glProgramUniform1d_ARG_EXPAND GLuint program, GLint location, GLdouble v0
#define glProgramUniform1d_PACKED PACKED_glProgramUniform1d
#define glProgramUniform1d_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramUniform1d_NOT_VOID_WRAP(...) {}
#define pack_glProgramUniform1d(_program, _location, _v0) ({ \
    glProgramUniform1d_PACKED *packed_data = malloc(sizeof(glProgramUniform1d_PACKED)); \
    packed_data->index = glProgramUniform1d_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.v0 = (GLdouble)_v0; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramUniform1d(packed, ret_v) do { \
    PACKED_glProgramUniform1d *unpacked = (PACKED_glProgramUniform1d *)packed; \
    ARGS_glProgramUniform1d *args = (ARGS_glProgramUniform1d *)&unpacked->args; \
    glProgramUniform1d(args->program, args->location, args->v0);; \
} while(0)
void glProgramUniform1d(glProgramUniform1d_ARG_EXPAND);
typedef void (*glProgramUniform1d_PTR)(glProgramUniform1d_ARG_EXPAND);
#define glProgramUniform1dEXT_INDEX 1633
#define glProgramUniform1dEXT_RETURN void
#define glProgramUniform1dEXT_ARG_NAMES program, location, x
#define glProgramUniform1dEXT_ARG_EXPAND GLuint program, GLint location, GLdouble x
#define glProgramUniform1dEXT_PACKED PACKED_glProgramUniform1dEXT
#define glProgramUniform1dEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramUniform1dEXT_NOT_VOID_WRAP(...) {}
#define pack_glProgramUniform1dEXT(_program, _location, _x) ({ \
    glProgramUniform1dEXT_PACKED *packed_data = malloc(sizeof(glProgramUniform1dEXT_PACKED)); \
    packed_data->index = glProgramUniform1dEXT_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.x = (GLdouble)_x; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramUniform1dEXT(packed, ret_v) do { \
    PACKED_glProgramUniform1dEXT *unpacked = (PACKED_glProgramUniform1dEXT *)packed; \
    ARGS_glProgramUniform1dEXT *args = (ARGS_glProgramUniform1dEXT *)&unpacked->args; \
    glProgramUniform1dEXT(args->program, args->location, args->x);; \
} while(0)
void glProgramUniform1dEXT(glProgramUniform1dEXT_ARG_EXPAND);
typedef void (*glProgramUniform1dEXT_PTR)(glProgramUniform1dEXT_ARG_EXPAND);
#define glProgramUniform1dv_INDEX 1634
#define glProgramUniform1dv_RETURN void
#define glProgramUniform1dv_ARG_NAMES program, location, count, value
#define glProgramUniform1dv_ARG_EXPAND GLuint program, GLint location, GLsizei count, const GLdouble * value
#define glProgramUniform1dv_PACKED PACKED_glProgramUniform1dv
#define glProgramUniform1dv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramUniform1dv_NOT_VOID_WRAP(...) {}
#define pack_glProgramUniform1dv(_program, _location, _count, _value) ({ \
    glProgramUniform1dv_PACKED *packed_data = malloc(sizeof(glProgramUniform1dv_PACKED)); \
    packed_data->index = glProgramUniform1dv_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.value = (GLdouble *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramUniform1dv(packed, ret_v) do { \
    PACKED_glProgramUniform1dv *unpacked = (PACKED_glProgramUniform1dv *)packed; \
    ARGS_glProgramUniform1dv *args = (ARGS_glProgramUniform1dv *)&unpacked->args; \
    glProgramUniform1dv(args->program, args->location, args->count, args->value);; \
} while(0)
void glProgramUniform1dv(glProgramUniform1dv_ARG_EXPAND);
typedef void (*glProgramUniform1dv_PTR)(glProgramUniform1dv_ARG_EXPAND);
#define glProgramUniform1dvEXT_INDEX 1635
#define glProgramUniform1dvEXT_RETURN void
#define glProgramUniform1dvEXT_ARG_NAMES program, location, count, value
#define glProgramUniform1dvEXT_ARG_EXPAND GLuint program, GLint location, GLsizei count, const GLdouble * value
#define glProgramUniform1dvEXT_PACKED PACKED_glProgramUniform1dvEXT
#define glProgramUniform1dvEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramUniform1dvEXT_NOT_VOID_WRAP(...) {}
#define pack_glProgramUniform1dvEXT(_program, _location, _count, _value) ({ \
    glProgramUniform1dvEXT_PACKED *packed_data = malloc(sizeof(glProgramUniform1dvEXT_PACKED)); \
    packed_data->index = glProgramUniform1dvEXT_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.value = (GLdouble *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramUniform1dvEXT(packed, ret_v) do { \
    PACKED_glProgramUniform1dvEXT *unpacked = (PACKED_glProgramUniform1dvEXT *)packed; \
    ARGS_glProgramUniform1dvEXT *args = (ARGS_glProgramUniform1dvEXT *)&unpacked->args; \
    glProgramUniform1dvEXT(args->program, args->location, args->count, args->value);; \
} while(0)
void glProgramUniform1dvEXT(glProgramUniform1dvEXT_ARG_EXPAND);
typedef void (*glProgramUniform1dvEXT_PTR)(glProgramUniform1dvEXT_ARG_EXPAND);
#define glProgramUniform1f_INDEX 1636
#define glProgramUniform1f_RETURN void
#define glProgramUniform1f_ARG_NAMES program, location, v0
#define glProgramUniform1f_ARG_EXPAND GLuint program, GLint location, GLfloat v0
#define glProgramUniform1f_PACKED PACKED_glProgramUniform1f
#define glProgramUniform1f_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramUniform1f_NOT_VOID_WRAP(...) {}
#define pack_glProgramUniform1f(_program, _location, _v0) ({ \
    glProgramUniform1f_PACKED *packed_data = malloc(sizeof(glProgramUniform1f_PACKED)); \
    packed_data->index = glProgramUniform1f_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.v0 = (GLfloat)_v0; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramUniform1f(packed, ret_v) do { \
    PACKED_glProgramUniform1f *unpacked = (PACKED_glProgramUniform1f *)packed; \
    ARGS_glProgramUniform1f *args = (ARGS_glProgramUniform1f *)&unpacked->args; \
    glProgramUniform1f(args->program, args->location, args->v0);; \
} while(0)
void glProgramUniform1f(glProgramUniform1f_ARG_EXPAND);
typedef void (*glProgramUniform1f_PTR)(glProgramUniform1f_ARG_EXPAND);
#define glProgramUniform1fEXT_INDEX 1637
#define glProgramUniform1fEXT_RETURN void
#define glProgramUniform1fEXT_ARG_NAMES program, location, v0
#define glProgramUniform1fEXT_ARG_EXPAND GLuint program, GLint location, GLfloat v0
#define glProgramUniform1fEXT_PACKED PACKED_glProgramUniform1fEXT
#define glProgramUniform1fEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramUniform1fEXT_NOT_VOID_WRAP(...) {}
#define pack_glProgramUniform1fEXT(_program, _location, _v0) ({ \
    glProgramUniform1fEXT_PACKED *packed_data = malloc(sizeof(glProgramUniform1fEXT_PACKED)); \
    packed_data->index = glProgramUniform1fEXT_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.v0 = (GLfloat)_v0; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramUniform1fEXT(packed, ret_v) do { \
    PACKED_glProgramUniform1fEXT *unpacked = (PACKED_glProgramUniform1fEXT *)packed; \
    ARGS_glProgramUniform1fEXT *args = (ARGS_glProgramUniform1fEXT *)&unpacked->args; \
    glProgramUniform1fEXT(args->program, args->location, args->v0);; \
} while(0)
void glProgramUniform1fEXT(glProgramUniform1fEXT_ARG_EXPAND);
typedef void (*glProgramUniform1fEXT_PTR)(glProgramUniform1fEXT_ARG_EXPAND);
#define glProgramUniform1fv_INDEX 1638
#define glProgramUniform1fv_RETURN void
#define glProgramUniform1fv_ARG_NAMES program, location, count, value
#define glProgramUniform1fv_ARG_EXPAND GLuint program, GLint location, GLsizei count, const GLfloat * value
#define glProgramUniform1fv_PACKED PACKED_glProgramUniform1fv
#define glProgramUniform1fv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramUniform1fv_NOT_VOID_WRAP(...) {}
#define pack_glProgramUniform1fv(_program, _location, _count, _value) ({ \
    glProgramUniform1fv_PACKED *packed_data = malloc(sizeof(glProgramUniform1fv_PACKED)); \
    packed_data->index = glProgramUniform1fv_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.value = (GLfloat *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramUniform1fv(packed, ret_v) do { \
    PACKED_glProgramUniform1fv *unpacked = (PACKED_glProgramUniform1fv *)packed; \
    ARGS_glProgramUniform1fv *args = (ARGS_glProgramUniform1fv *)&unpacked->args; \
    glProgramUniform1fv(args->program, args->location, args->count, args->value);; \
} while(0)
void glProgramUniform1fv(glProgramUniform1fv_ARG_EXPAND);
typedef void (*glProgramUniform1fv_PTR)(glProgramUniform1fv_ARG_EXPAND);
#define glProgramUniform1fvEXT_INDEX 1639
#define glProgramUniform1fvEXT_RETURN void
#define glProgramUniform1fvEXT_ARG_NAMES program, location, count, value
#define glProgramUniform1fvEXT_ARG_EXPAND GLuint program, GLint location, GLsizei count, const GLfloat * value
#define glProgramUniform1fvEXT_PACKED PACKED_glProgramUniform1fvEXT
#define glProgramUniform1fvEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramUniform1fvEXT_NOT_VOID_WRAP(...) {}
#define pack_glProgramUniform1fvEXT(_program, _location, _count, _value) ({ \
    glProgramUniform1fvEXT_PACKED *packed_data = malloc(sizeof(glProgramUniform1fvEXT_PACKED)); \
    packed_data->index = glProgramUniform1fvEXT_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.value = (GLfloat *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramUniform1fvEXT(packed, ret_v) do { \
    PACKED_glProgramUniform1fvEXT *unpacked = (PACKED_glProgramUniform1fvEXT *)packed; \
    ARGS_glProgramUniform1fvEXT *args = (ARGS_glProgramUniform1fvEXT *)&unpacked->args; \
    glProgramUniform1fvEXT(args->program, args->location, args->count, args->value);; \
} while(0)
void glProgramUniform1fvEXT(glProgramUniform1fvEXT_ARG_EXPAND);
typedef void (*glProgramUniform1fvEXT_PTR)(glProgramUniform1fvEXT_ARG_EXPAND);
#define glProgramUniform1i_INDEX 1640
#define glProgramUniform1i_RETURN void
#define glProgramUniform1i_ARG_NAMES program, location, v0
#define glProgramUniform1i_ARG_EXPAND GLuint program, GLint location, GLint v0
#define glProgramUniform1i_PACKED PACKED_glProgramUniform1i
#define glProgramUniform1i_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramUniform1i_NOT_VOID_WRAP(...) {}
#define pack_glProgramUniform1i(_program, _location, _v0) ({ \
    glProgramUniform1i_PACKED *packed_data = malloc(sizeof(glProgramUniform1i_PACKED)); \
    packed_data->index = glProgramUniform1i_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.v0 = (GLint)_v0; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramUniform1i(packed, ret_v) do { \
    PACKED_glProgramUniform1i *unpacked = (PACKED_glProgramUniform1i *)packed; \
    ARGS_glProgramUniform1i *args = (ARGS_glProgramUniform1i *)&unpacked->args; \
    glProgramUniform1i(args->program, args->location, args->v0);; \
} while(0)
void glProgramUniform1i(glProgramUniform1i_ARG_EXPAND);
typedef void (*glProgramUniform1i_PTR)(glProgramUniform1i_ARG_EXPAND);
#define glProgramUniform1i64NV_INDEX 1641
#define glProgramUniform1i64NV_RETURN void
#define glProgramUniform1i64NV_ARG_NAMES program, location, x
#define glProgramUniform1i64NV_ARG_EXPAND GLuint program, GLint location, GLint64EXT x
#define glProgramUniform1i64NV_PACKED PACKED_glProgramUniform1i64NV
#define glProgramUniform1i64NV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramUniform1i64NV_NOT_VOID_WRAP(...) {}
#define pack_glProgramUniform1i64NV(_program, _location, _x) ({ \
    glProgramUniform1i64NV_PACKED *packed_data = malloc(sizeof(glProgramUniform1i64NV_PACKED)); \
    packed_data->index = glProgramUniform1i64NV_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.x = (GLint64EXT)_x; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramUniform1i64NV(packed, ret_v) do { \
    PACKED_glProgramUniform1i64NV *unpacked = (PACKED_glProgramUniform1i64NV *)packed; \
    ARGS_glProgramUniform1i64NV *args = (ARGS_glProgramUniform1i64NV *)&unpacked->args; \
    glProgramUniform1i64NV(args->program, args->location, args->x);; \
} while(0)
void glProgramUniform1i64NV(glProgramUniform1i64NV_ARG_EXPAND);
typedef void (*glProgramUniform1i64NV_PTR)(glProgramUniform1i64NV_ARG_EXPAND);
#define glProgramUniform1i64vNV_INDEX 1642
#define glProgramUniform1i64vNV_RETURN void
#define glProgramUniform1i64vNV_ARG_NAMES program, location, count, value
#define glProgramUniform1i64vNV_ARG_EXPAND GLuint program, GLint location, GLsizei count, const GLint64EXT * value
#define glProgramUniform1i64vNV_PACKED PACKED_glProgramUniform1i64vNV
#define glProgramUniform1i64vNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramUniform1i64vNV_NOT_VOID_WRAP(...) {}
#define pack_glProgramUniform1i64vNV(_program, _location, _count, _value) ({ \
    glProgramUniform1i64vNV_PACKED *packed_data = malloc(sizeof(glProgramUniform1i64vNV_PACKED)); \
    packed_data->index = glProgramUniform1i64vNV_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.value = (GLint64EXT *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramUniform1i64vNV(packed, ret_v) do { \
    PACKED_glProgramUniform1i64vNV *unpacked = (PACKED_glProgramUniform1i64vNV *)packed; \
    ARGS_glProgramUniform1i64vNV *args = (ARGS_glProgramUniform1i64vNV *)&unpacked->args; \
    glProgramUniform1i64vNV(args->program, args->location, args->count, args->value);; \
} while(0)
void glProgramUniform1i64vNV(glProgramUniform1i64vNV_ARG_EXPAND);
typedef void (*glProgramUniform1i64vNV_PTR)(glProgramUniform1i64vNV_ARG_EXPAND);
#define glProgramUniform1iEXT_INDEX 1643
#define glProgramUniform1iEXT_RETURN void
#define glProgramUniform1iEXT_ARG_NAMES program, location, v0
#define glProgramUniform1iEXT_ARG_EXPAND GLuint program, GLint location, GLint v0
#define glProgramUniform1iEXT_PACKED PACKED_glProgramUniform1iEXT
#define glProgramUniform1iEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramUniform1iEXT_NOT_VOID_WRAP(...) {}
#define pack_glProgramUniform1iEXT(_program, _location, _v0) ({ \
    glProgramUniform1iEXT_PACKED *packed_data = malloc(sizeof(glProgramUniform1iEXT_PACKED)); \
    packed_data->index = glProgramUniform1iEXT_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.v0 = (GLint)_v0; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramUniform1iEXT(packed, ret_v) do { \
    PACKED_glProgramUniform1iEXT *unpacked = (PACKED_glProgramUniform1iEXT *)packed; \
    ARGS_glProgramUniform1iEXT *args = (ARGS_glProgramUniform1iEXT *)&unpacked->args; \
    glProgramUniform1iEXT(args->program, args->location, args->v0);; \
} while(0)
void glProgramUniform1iEXT(glProgramUniform1iEXT_ARG_EXPAND);
typedef void (*glProgramUniform1iEXT_PTR)(glProgramUniform1iEXT_ARG_EXPAND);
#define glProgramUniform1iv_INDEX 1644
#define glProgramUniform1iv_RETURN void
#define glProgramUniform1iv_ARG_NAMES program, location, count, value
#define glProgramUniform1iv_ARG_EXPAND GLuint program, GLint location, GLsizei count, const GLint * value
#define glProgramUniform1iv_PACKED PACKED_glProgramUniform1iv
#define glProgramUniform1iv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramUniform1iv_NOT_VOID_WRAP(...) {}
#define pack_glProgramUniform1iv(_program, _location, _count, _value) ({ \
    glProgramUniform1iv_PACKED *packed_data = malloc(sizeof(glProgramUniform1iv_PACKED)); \
    packed_data->index = glProgramUniform1iv_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.value = (GLint *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramUniform1iv(packed, ret_v) do { \
    PACKED_glProgramUniform1iv *unpacked = (PACKED_glProgramUniform1iv *)packed; \
    ARGS_glProgramUniform1iv *args = (ARGS_glProgramUniform1iv *)&unpacked->args; \
    glProgramUniform1iv(args->program, args->location, args->count, args->value);; \
} while(0)
void glProgramUniform1iv(glProgramUniform1iv_ARG_EXPAND);
typedef void (*glProgramUniform1iv_PTR)(glProgramUniform1iv_ARG_EXPAND);
#define glProgramUniform1ivEXT_INDEX 1645
#define glProgramUniform1ivEXT_RETURN void
#define glProgramUniform1ivEXT_ARG_NAMES program, location, count, value
#define glProgramUniform1ivEXT_ARG_EXPAND GLuint program, GLint location, GLsizei count, const GLint * value
#define glProgramUniform1ivEXT_PACKED PACKED_glProgramUniform1ivEXT
#define glProgramUniform1ivEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramUniform1ivEXT_NOT_VOID_WRAP(...) {}
#define pack_glProgramUniform1ivEXT(_program, _location, _count, _value) ({ \
    glProgramUniform1ivEXT_PACKED *packed_data = malloc(sizeof(glProgramUniform1ivEXT_PACKED)); \
    packed_data->index = glProgramUniform1ivEXT_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.value = (GLint *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramUniform1ivEXT(packed, ret_v) do { \
    PACKED_glProgramUniform1ivEXT *unpacked = (PACKED_glProgramUniform1ivEXT *)packed; \
    ARGS_glProgramUniform1ivEXT *args = (ARGS_glProgramUniform1ivEXT *)&unpacked->args; \
    glProgramUniform1ivEXT(args->program, args->location, args->count, args->value);; \
} while(0)
void glProgramUniform1ivEXT(glProgramUniform1ivEXT_ARG_EXPAND);
typedef void (*glProgramUniform1ivEXT_PTR)(glProgramUniform1ivEXT_ARG_EXPAND);
#define glProgramUniform1ui_INDEX 1646
#define glProgramUniform1ui_RETURN void
#define glProgramUniform1ui_ARG_NAMES program, location, v0
#define glProgramUniform1ui_ARG_EXPAND GLuint program, GLint location, GLuint v0
#define glProgramUniform1ui_PACKED PACKED_glProgramUniform1ui
#define glProgramUniform1ui_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramUniform1ui_NOT_VOID_WRAP(...) {}
#define pack_glProgramUniform1ui(_program, _location, _v0) ({ \
    glProgramUniform1ui_PACKED *packed_data = malloc(sizeof(glProgramUniform1ui_PACKED)); \
    packed_data->index = glProgramUniform1ui_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.v0 = (GLuint)_v0; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramUniform1ui(packed, ret_v) do { \
    PACKED_glProgramUniform1ui *unpacked = (PACKED_glProgramUniform1ui *)packed; \
    ARGS_glProgramUniform1ui *args = (ARGS_glProgramUniform1ui *)&unpacked->args; \
    glProgramUniform1ui(args->program, args->location, args->v0);; \
} while(0)
void glProgramUniform1ui(glProgramUniform1ui_ARG_EXPAND);
typedef void (*glProgramUniform1ui_PTR)(glProgramUniform1ui_ARG_EXPAND);
#define glProgramUniform1ui64NV_INDEX 1647
#define glProgramUniform1ui64NV_RETURN void
#define glProgramUniform1ui64NV_ARG_NAMES program, location, x
#define glProgramUniform1ui64NV_ARG_EXPAND GLuint program, GLint location, GLuint64EXT x
#define glProgramUniform1ui64NV_PACKED PACKED_glProgramUniform1ui64NV
#define glProgramUniform1ui64NV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramUniform1ui64NV_NOT_VOID_WRAP(...) {}
#define pack_glProgramUniform1ui64NV(_program, _location, _x) ({ \
    glProgramUniform1ui64NV_PACKED *packed_data = malloc(sizeof(glProgramUniform1ui64NV_PACKED)); \
    packed_data->index = glProgramUniform1ui64NV_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.x = (GLuint64EXT)_x; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramUniform1ui64NV(packed, ret_v) do { \
    PACKED_glProgramUniform1ui64NV *unpacked = (PACKED_glProgramUniform1ui64NV *)packed; \
    ARGS_glProgramUniform1ui64NV *args = (ARGS_glProgramUniform1ui64NV *)&unpacked->args; \
    glProgramUniform1ui64NV(args->program, args->location, args->x);; \
} while(0)
void glProgramUniform1ui64NV(glProgramUniform1ui64NV_ARG_EXPAND);
typedef void (*glProgramUniform1ui64NV_PTR)(glProgramUniform1ui64NV_ARG_EXPAND);
#define glProgramUniform1ui64vNV_INDEX 1648
#define glProgramUniform1ui64vNV_RETURN void
#define glProgramUniform1ui64vNV_ARG_NAMES program, location, count, value
#define glProgramUniform1ui64vNV_ARG_EXPAND GLuint program, GLint location, GLsizei count, const GLuint64EXT * value
#define glProgramUniform1ui64vNV_PACKED PACKED_glProgramUniform1ui64vNV
#define glProgramUniform1ui64vNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramUniform1ui64vNV_NOT_VOID_WRAP(...) {}
#define pack_glProgramUniform1ui64vNV(_program, _location, _count, _value) ({ \
    glProgramUniform1ui64vNV_PACKED *packed_data = malloc(sizeof(glProgramUniform1ui64vNV_PACKED)); \
    packed_data->index = glProgramUniform1ui64vNV_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.value = (GLuint64EXT *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramUniform1ui64vNV(packed, ret_v) do { \
    PACKED_glProgramUniform1ui64vNV *unpacked = (PACKED_glProgramUniform1ui64vNV *)packed; \
    ARGS_glProgramUniform1ui64vNV *args = (ARGS_glProgramUniform1ui64vNV *)&unpacked->args; \
    glProgramUniform1ui64vNV(args->program, args->location, args->count, args->value);; \
} while(0)
void glProgramUniform1ui64vNV(glProgramUniform1ui64vNV_ARG_EXPAND);
typedef void (*glProgramUniform1ui64vNV_PTR)(glProgramUniform1ui64vNV_ARG_EXPAND);
#define glProgramUniform1uiEXT_INDEX 1649
#define glProgramUniform1uiEXT_RETURN void
#define glProgramUniform1uiEXT_ARG_NAMES program, location, v0
#define glProgramUniform1uiEXT_ARG_EXPAND GLuint program, GLint location, GLuint v0
#define glProgramUniform1uiEXT_PACKED PACKED_glProgramUniform1uiEXT
#define glProgramUniform1uiEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramUniform1uiEXT_NOT_VOID_WRAP(...) {}
#define pack_glProgramUniform1uiEXT(_program, _location, _v0) ({ \
    glProgramUniform1uiEXT_PACKED *packed_data = malloc(sizeof(glProgramUniform1uiEXT_PACKED)); \
    packed_data->index = glProgramUniform1uiEXT_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.v0 = (GLuint)_v0; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramUniform1uiEXT(packed, ret_v) do { \
    PACKED_glProgramUniform1uiEXT *unpacked = (PACKED_glProgramUniform1uiEXT *)packed; \
    ARGS_glProgramUniform1uiEXT *args = (ARGS_glProgramUniform1uiEXT *)&unpacked->args; \
    glProgramUniform1uiEXT(args->program, args->location, args->v0);; \
} while(0)
void glProgramUniform1uiEXT(glProgramUniform1uiEXT_ARG_EXPAND);
typedef void (*glProgramUniform1uiEXT_PTR)(glProgramUniform1uiEXT_ARG_EXPAND);
#define glProgramUniform1uiv_INDEX 1650
#define glProgramUniform1uiv_RETURN void
#define glProgramUniform1uiv_ARG_NAMES program, location, count, value
#define glProgramUniform1uiv_ARG_EXPAND GLuint program, GLint location, GLsizei count, const GLuint * value
#define glProgramUniform1uiv_PACKED PACKED_glProgramUniform1uiv
#define glProgramUniform1uiv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramUniform1uiv_NOT_VOID_WRAP(...) {}
#define pack_glProgramUniform1uiv(_program, _location, _count, _value) ({ \
    glProgramUniform1uiv_PACKED *packed_data = malloc(sizeof(glProgramUniform1uiv_PACKED)); \
    packed_data->index = glProgramUniform1uiv_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.value = (GLuint *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramUniform1uiv(packed, ret_v) do { \
    PACKED_glProgramUniform1uiv *unpacked = (PACKED_glProgramUniform1uiv *)packed; \
    ARGS_glProgramUniform1uiv *args = (ARGS_glProgramUniform1uiv *)&unpacked->args; \
    glProgramUniform1uiv(args->program, args->location, args->count, args->value);; \
} while(0)
void glProgramUniform1uiv(glProgramUniform1uiv_ARG_EXPAND);
typedef void (*glProgramUniform1uiv_PTR)(glProgramUniform1uiv_ARG_EXPAND);
#define glProgramUniform1uivEXT_INDEX 1651
#define glProgramUniform1uivEXT_RETURN void
#define glProgramUniform1uivEXT_ARG_NAMES program, location, count, value
#define glProgramUniform1uivEXT_ARG_EXPAND GLuint program, GLint location, GLsizei count, const GLuint * value
#define glProgramUniform1uivEXT_PACKED PACKED_glProgramUniform1uivEXT
#define glProgramUniform1uivEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramUniform1uivEXT_NOT_VOID_WRAP(...) {}
#define pack_glProgramUniform1uivEXT(_program, _location, _count, _value) ({ \
    glProgramUniform1uivEXT_PACKED *packed_data = malloc(sizeof(glProgramUniform1uivEXT_PACKED)); \
    packed_data->index = glProgramUniform1uivEXT_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.value = (GLuint *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramUniform1uivEXT(packed, ret_v) do { \
    PACKED_glProgramUniform1uivEXT *unpacked = (PACKED_glProgramUniform1uivEXT *)packed; \
    ARGS_glProgramUniform1uivEXT *args = (ARGS_glProgramUniform1uivEXT *)&unpacked->args; \
    glProgramUniform1uivEXT(args->program, args->location, args->count, args->value);; \
} while(0)
void glProgramUniform1uivEXT(glProgramUniform1uivEXT_ARG_EXPAND);
typedef void (*glProgramUniform1uivEXT_PTR)(glProgramUniform1uivEXT_ARG_EXPAND);
#define glProgramUniform2d_INDEX 1652
#define glProgramUniform2d_RETURN void
#define glProgramUniform2d_ARG_NAMES program, location, v0, v1
#define glProgramUniform2d_ARG_EXPAND GLuint program, GLint location, GLdouble v0, GLdouble v1
#define glProgramUniform2d_PACKED PACKED_glProgramUniform2d
#define glProgramUniform2d_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramUniform2d_NOT_VOID_WRAP(...) {}
#define pack_glProgramUniform2d(_program, _location, _v0, _v1) ({ \
    glProgramUniform2d_PACKED *packed_data = malloc(sizeof(glProgramUniform2d_PACKED)); \
    packed_data->index = glProgramUniform2d_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.v0 = (GLdouble)_v0; \
    packed_data->args.v1 = (GLdouble)_v1; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramUniform2d(packed, ret_v) do { \
    PACKED_glProgramUniform2d *unpacked = (PACKED_glProgramUniform2d *)packed; \
    ARGS_glProgramUniform2d *args = (ARGS_glProgramUniform2d *)&unpacked->args; \
    glProgramUniform2d(args->program, args->location, args->v0, args->v1);; \
} while(0)
void glProgramUniform2d(glProgramUniform2d_ARG_EXPAND);
typedef void (*glProgramUniform2d_PTR)(glProgramUniform2d_ARG_EXPAND);
#define glProgramUniform2dEXT_INDEX 1653
#define glProgramUniform2dEXT_RETURN void
#define glProgramUniform2dEXT_ARG_NAMES program, location, x, y
#define glProgramUniform2dEXT_ARG_EXPAND GLuint program, GLint location, GLdouble x, GLdouble y
#define glProgramUniform2dEXT_PACKED PACKED_glProgramUniform2dEXT
#define glProgramUniform2dEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramUniform2dEXT_NOT_VOID_WRAP(...) {}
#define pack_glProgramUniform2dEXT(_program, _location, _x, _y) ({ \
    glProgramUniform2dEXT_PACKED *packed_data = malloc(sizeof(glProgramUniform2dEXT_PACKED)); \
    packed_data->index = glProgramUniform2dEXT_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.x = (GLdouble)_x; \
    packed_data->args.y = (GLdouble)_y; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramUniform2dEXT(packed, ret_v) do { \
    PACKED_glProgramUniform2dEXT *unpacked = (PACKED_glProgramUniform2dEXT *)packed; \
    ARGS_glProgramUniform2dEXT *args = (ARGS_glProgramUniform2dEXT *)&unpacked->args; \
    glProgramUniform2dEXT(args->program, args->location, args->x, args->y);; \
} while(0)
void glProgramUniform2dEXT(glProgramUniform2dEXT_ARG_EXPAND);
typedef void (*glProgramUniform2dEXT_PTR)(glProgramUniform2dEXT_ARG_EXPAND);
#define glProgramUniform2dv_INDEX 1654
#define glProgramUniform2dv_RETURN void
#define glProgramUniform2dv_ARG_NAMES program, location, count, value
#define glProgramUniform2dv_ARG_EXPAND GLuint program, GLint location, GLsizei count, const GLdouble * value
#define glProgramUniform2dv_PACKED PACKED_glProgramUniform2dv
#define glProgramUniform2dv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramUniform2dv_NOT_VOID_WRAP(...) {}
#define pack_glProgramUniform2dv(_program, _location, _count, _value) ({ \
    glProgramUniform2dv_PACKED *packed_data = malloc(sizeof(glProgramUniform2dv_PACKED)); \
    packed_data->index = glProgramUniform2dv_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.value = (GLdouble *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramUniform2dv(packed, ret_v) do { \
    PACKED_glProgramUniform2dv *unpacked = (PACKED_glProgramUniform2dv *)packed; \
    ARGS_glProgramUniform2dv *args = (ARGS_glProgramUniform2dv *)&unpacked->args; \
    glProgramUniform2dv(args->program, args->location, args->count, args->value);; \
} while(0)
void glProgramUniform2dv(glProgramUniform2dv_ARG_EXPAND);
typedef void (*glProgramUniform2dv_PTR)(glProgramUniform2dv_ARG_EXPAND);
#define glProgramUniform2dvEXT_INDEX 1655
#define glProgramUniform2dvEXT_RETURN void
#define glProgramUniform2dvEXT_ARG_NAMES program, location, count, value
#define glProgramUniform2dvEXT_ARG_EXPAND GLuint program, GLint location, GLsizei count, const GLdouble * value
#define glProgramUniform2dvEXT_PACKED PACKED_glProgramUniform2dvEXT
#define glProgramUniform2dvEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramUniform2dvEXT_NOT_VOID_WRAP(...) {}
#define pack_glProgramUniform2dvEXT(_program, _location, _count, _value) ({ \
    glProgramUniform2dvEXT_PACKED *packed_data = malloc(sizeof(glProgramUniform2dvEXT_PACKED)); \
    packed_data->index = glProgramUniform2dvEXT_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.value = (GLdouble *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramUniform2dvEXT(packed, ret_v) do { \
    PACKED_glProgramUniform2dvEXT *unpacked = (PACKED_glProgramUniform2dvEXT *)packed; \
    ARGS_glProgramUniform2dvEXT *args = (ARGS_glProgramUniform2dvEXT *)&unpacked->args; \
    glProgramUniform2dvEXT(args->program, args->location, args->count, args->value);; \
} while(0)
void glProgramUniform2dvEXT(glProgramUniform2dvEXT_ARG_EXPAND);
typedef void (*glProgramUniform2dvEXT_PTR)(glProgramUniform2dvEXT_ARG_EXPAND);
#define glProgramUniform2f_INDEX 1656
#define glProgramUniform2f_RETURN void
#define glProgramUniform2f_ARG_NAMES program, location, v0, v1
#define glProgramUniform2f_ARG_EXPAND GLuint program, GLint location, GLfloat v0, GLfloat v1
#define glProgramUniform2f_PACKED PACKED_glProgramUniform2f
#define glProgramUniform2f_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramUniform2f_NOT_VOID_WRAP(...) {}
#define pack_glProgramUniform2f(_program, _location, _v0, _v1) ({ \
    glProgramUniform2f_PACKED *packed_data = malloc(sizeof(glProgramUniform2f_PACKED)); \
    packed_data->index = glProgramUniform2f_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.v0 = (GLfloat)_v0; \
    packed_data->args.v1 = (GLfloat)_v1; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramUniform2f(packed, ret_v) do { \
    PACKED_glProgramUniform2f *unpacked = (PACKED_glProgramUniform2f *)packed; \
    ARGS_glProgramUniform2f *args = (ARGS_glProgramUniform2f *)&unpacked->args; \
    glProgramUniform2f(args->program, args->location, args->v0, args->v1);; \
} while(0)
void glProgramUniform2f(glProgramUniform2f_ARG_EXPAND);
typedef void (*glProgramUniform2f_PTR)(glProgramUniform2f_ARG_EXPAND);
#define glProgramUniform2fEXT_INDEX 1657
#define glProgramUniform2fEXT_RETURN void
#define glProgramUniform2fEXT_ARG_NAMES program, location, v0, v1
#define glProgramUniform2fEXT_ARG_EXPAND GLuint program, GLint location, GLfloat v0, GLfloat v1
#define glProgramUniform2fEXT_PACKED PACKED_glProgramUniform2fEXT
#define glProgramUniform2fEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramUniform2fEXT_NOT_VOID_WRAP(...) {}
#define pack_glProgramUniform2fEXT(_program, _location, _v0, _v1) ({ \
    glProgramUniform2fEXT_PACKED *packed_data = malloc(sizeof(glProgramUniform2fEXT_PACKED)); \
    packed_data->index = glProgramUniform2fEXT_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.v0 = (GLfloat)_v0; \
    packed_data->args.v1 = (GLfloat)_v1; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramUniform2fEXT(packed, ret_v) do { \
    PACKED_glProgramUniform2fEXT *unpacked = (PACKED_glProgramUniform2fEXT *)packed; \
    ARGS_glProgramUniform2fEXT *args = (ARGS_glProgramUniform2fEXT *)&unpacked->args; \
    glProgramUniform2fEXT(args->program, args->location, args->v0, args->v1);; \
} while(0)
void glProgramUniform2fEXT(glProgramUniform2fEXT_ARG_EXPAND);
typedef void (*glProgramUniform2fEXT_PTR)(glProgramUniform2fEXT_ARG_EXPAND);
#define glProgramUniform2fv_INDEX 1658
#define glProgramUniform2fv_RETURN void
#define glProgramUniform2fv_ARG_NAMES program, location, count, value
#define glProgramUniform2fv_ARG_EXPAND GLuint program, GLint location, GLsizei count, const GLfloat * value
#define glProgramUniform2fv_PACKED PACKED_glProgramUniform2fv
#define glProgramUniform2fv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramUniform2fv_NOT_VOID_WRAP(...) {}
#define pack_glProgramUniform2fv(_program, _location, _count, _value) ({ \
    glProgramUniform2fv_PACKED *packed_data = malloc(sizeof(glProgramUniform2fv_PACKED)); \
    packed_data->index = glProgramUniform2fv_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.value = (GLfloat *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramUniform2fv(packed, ret_v) do { \
    PACKED_glProgramUniform2fv *unpacked = (PACKED_glProgramUniform2fv *)packed; \
    ARGS_glProgramUniform2fv *args = (ARGS_glProgramUniform2fv *)&unpacked->args; \
    glProgramUniform2fv(args->program, args->location, args->count, args->value);; \
} while(0)
void glProgramUniform2fv(glProgramUniform2fv_ARG_EXPAND);
typedef void (*glProgramUniform2fv_PTR)(glProgramUniform2fv_ARG_EXPAND);
#define glProgramUniform2fvEXT_INDEX 1659
#define glProgramUniform2fvEXT_RETURN void
#define glProgramUniform2fvEXT_ARG_NAMES program, location, count, value
#define glProgramUniform2fvEXT_ARG_EXPAND GLuint program, GLint location, GLsizei count, const GLfloat * value
#define glProgramUniform2fvEXT_PACKED PACKED_glProgramUniform2fvEXT
#define glProgramUniform2fvEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramUniform2fvEXT_NOT_VOID_WRAP(...) {}
#define pack_glProgramUniform2fvEXT(_program, _location, _count, _value) ({ \
    glProgramUniform2fvEXT_PACKED *packed_data = malloc(sizeof(glProgramUniform2fvEXT_PACKED)); \
    packed_data->index = glProgramUniform2fvEXT_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.value = (GLfloat *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramUniform2fvEXT(packed, ret_v) do { \
    PACKED_glProgramUniform2fvEXT *unpacked = (PACKED_glProgramUniform2fvEXT *)packed; \
    ARGS_glProgramUniform2fvEXT *args = (ARGS_glProgramUniform2fvEXT *)&unpacked->args; \
    glProgramUniform2fvEXT(args->program, args->location, args->count, args->value);; \
} while(0)
void glProgramUniform2fvEXT(glProgramUniform2fvEXT_ARG_EXPAND);
typedef void (*glProgramUniform2fvEXT_PTR)(glProgramUniform2fvEXT_ARG_EXPAND);
#define glProgramUniform2i_INDEX 1660
#define glProgramUniform2i_RETURN void
#define glProgramUniform2i_ARG_NAMES program, location, v0, v1
#define glProgramUniform2i_ARG_EXPAND GLuint program, GLint location, GLint v0, GLint v1
#define glProgramUniform2i_PACKED PACKED_glProgramUniform2i
#define glProgramUniform2i_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramUniform2i_NOT_VOID_WRAP(...) {}
#define pack_glProgramUniform2i(_program, _location, _v0, _v1) ({ \
    glProgramUniform2i_PACKED *packed_data = malloc(sizeof(glProgramUniform2i_PACKED)); \
    packed_data->index = glProgramUniform2i_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.v0 = (GLint)_v0; \
    packed_data->args.v1 = (GLint)_v1; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramUniform2i(packed, ret_v) do { \
    PACKED_glProgramUniform2i *unpacked = (PACKED_glProgramUniform2i *)packed; \
    ARGS_glProgramUniform2i *args = (ARGS_glProgramUniform2i *)&unpacked->args; \
    glProgramUniform2i(args->program, args->location, args->v0, args->v1);; \
} while(0)
void glProgramUniform2i(glProgramUniform2i_ARG_EXPAND);
typedef void (*glProgramUniform2i_PTR)(glProgramUniform2i_ARG_EXPAND);
#define glProgramUniform2i64NV_INDEX 1661
#define glProgramUniform2i64NV_RETURN void
#define glProgramUniform2i64NV_ARG_NAMES program, location, x, y
#define glProgramUniform2i64NV_ARG_EXPAND GLuint program, GLint location, GLint64EXT x, GLint64EXT y
#define glProgramUniform2i64NV_PACKED PACKED_glProgramUniform2i64NV
#define glProgramUniform2i64NV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramUniform2i64NV_NOT_VOID_WRAP(...) {}
#define pack_glProgramUniform2i64NV(_program, _location, _x, _y) ({ \
    glProgramUniform2i64NV_PACKED *packed_data = malloc(sizeof(glProgramUniform2i64NV_PACKED)); \
    packed_data->index = glProgramUniform2i64NV_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.x = (GLint64EXT)_x; \
    packed_data->args.y = (GLint64EXT)_y; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramUniform2i64NV(packed, ret_v) do { \
    PACKED_glProgramUniform2i64NV *unpacked = (PACKED_glProgramUniform2i64NV *)packed; \
    ARGS_glProgramUniform2i64NV *args = (ARGS_glProgramUniform2i64NV *)&unpacked->args; \
    glProgramUniform2i64NV(args->program, args->location, args->x, args->y);; \
} while(0)
void glProgramUniform2i64NV(glProgramUniform2i64NV_ARG_EXPAND);
typedef void (*glProgramUniform2i64NV_PTR)(glProgramUniform2i64NV_ARG_EXPAND);
#define glProgramUniform2i64vNV_INDEX 1662
#define glProgramUniform2i64vNV_RETURN void
#define glProgramUniform2i64vNV_ARG_NAMES program, location, count, value
#define glProgramUniform2i64vNV_ARG_EXPAND GLuint program, GLint location, GLsizei count, const GLint64EXT * value
#define glProgramUniform2i64vNV_PACKED PACKED_glProgramUniform2i64vNV
#define glProgramUniform2i64vNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramUniform2i64vNV_NOT_VOID_WRAP(...) {}
#define pack_glProgramUniform2i64vNV(_program, _location, _count, _value) ({ \
    glProgramUniform2i64vNV_PACKED *packed_data = malloc(sizeof(glProgramUniform2i64vNV_PACKED)); \
    packed_data->index = glProgramUniform2i64vNV_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.value = (GLint64EXT *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramUniform2i64vNV(packed, ret_v) do { \
    PACKED_glProgramUniform2i64vNV *unpacked = (PACKED_glProgramUniform2i64vNV *)packed; \
    ARGS_glProgramUniform2i64vNV *args = (ARGS_glProgramUniform2i64vNV *)&unpacked->args; \
    glProgramUniform2i64vNV(args->program, args->location, args->count, args->value);; \
} while(0)
void glProgramUniform2i64vNV(glProgramUniform2i64vNV_ARG_EXPAND);
typedef void (*glProgramUniform2i64vNV_PTR)(glProgramUniform2i64vNV_ARG_EXPAND);
#define glProgramUniform2iEXT_INDEX 1663
#define glProgramUniform2iEXT_RETURN void
#define glProgramUniform2iEXT_ARG_NAMES program, location, v0, v1
#define glProgramUniform2iEXT_ARG_EXPAND GLuint program, GLint location, GLint v0, GLint v1
#define glProgramUniform2iEXT_PACKED PACKED_glProgramUniform2iEXT
#define glProgramUniform2iEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramUniform2iEXT_NOT_VOID_WRAP(...) {}
#define pack_glProgramUniform2iEXT(_program, _location, _v0, _v1) ({ \
    glProgramUniform2iEXT_PACKED *packed_data = malloc(sizeof(glProgramUniform2iEXT_PACKED)); \
    packed_data->index = glProgramUniform2iEXT_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.v0 = (GLint)_v0; \
    packed_data->args.v1 = (GLint)_v1; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramUniform2iEXT(packed, ret_v) do { \
    PACKED_glProgramUniform2iEXT *unpacked = (PACKED_glProgramUniform2iEXT *)packed; \
    ARGS_glProgramUniform2iEXT *args = (ARGS_glProgramUniform2iEXT *)&unpacked->args; \
    glProgramUniform2iEXT(args->program, args->location, args->v0, args->v1);; \
} while(0)
void glProgramUniform2iEXT(glProgramUniform2iEXT_ARG_EXPAND);
typedef void (*glProgramUniform2iEXT_PTR)(glProgramUniform2iEXT_ARG_EXPAND);
#define glProgramUniform2iv_INDEX 1664
#define glProgramUniform2iv_RETURN void
#define glProgramUniform2iv_ARG_NAMES program, location, count, value
#define glProgramUniform2iv_ARG_EXPAND GLuint program, GLint location, GLsizei count, const GLint * value
#define glProgramUniform2iv_PACKED PACKED_glProgramUniform2iv
#define glProgramUniform2iv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramUniform2iv_NOT_VOID_WRAP(...) {}
#define pack_glProgramUniform2iv(_program, _location, _count, _value) ({ \
    glProgramUniform2iv_PACKED *packed_data = malloc(sizeof(glProgramUniform2iv_PACKED)); \
    packed_data->index = glProgramUniform2iv_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.value = (GLint *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramUniform2iv(packed, ret_v) do { \
    PACKED_glProgramUniform2iv *unpacked = (PACKED_glProgramUniform2iv *)packed; \
    ARGS_glProgramUniform2iv *args = (ARGS_glProgramUniform2iv *)&unpacked->args; \
    glProgramUniform2iv(args->program, args->location, args->count, args->value);; \
} while(0)
void glProgramUniform2iv(glProgramUniform2iv_ARG_EXPAND);
typedef void (*glProgramUniform2iv_PTR)(glProgramUniform2iv_ARG_EXPAND);
#define glProgramUniform2ivEXT_INDEX 1665
#define glProgramUniform2ivEXT_RETURN void
#define glProgramUniform2ivEXT_ARG_NAMES program, location, count, value
#define glProgramUniform2ivEXT_ARG_EXPAND GLuint program, GLint location, GLsizei count, const GLint * value
#define glProgramUniform2ivEXT_PACKED PACKED_glProgramUniform2ivEXT
#define glProgramUniform2ivEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramUniform2ivEXT_NOT_VOID_WRAP(...) {}
#define pack_glProgramUniform2ivEXT(_program, _location, _count, _value) ({ \
    glProgramUniform2ivEXT_PACKED *packed_data = malloc(sizeof(glProgramUniform2ivEXT_PACKED)); \
    packed_data->index = glProgramUniform2ivEXT_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.value = (GLint *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramUniform2ivEXT(packed, ret_v) do { \
    PACKED_glProgramUniform2ivEXT *unpacked = (PACKED_glProgramUniform2ivEXT *)packed; \
    ARGS_glProgramUniform2ivEXT *args = (ARGS_glProgramUniform2ivEXT *)&unpacked->args; \
    glProgramUniform2ivEXT(args->program, args->location, args->count, args->value);; \
} while(0)
void glProgramUniform2ivEXT(glProgramUniform2ivEXT_ARG_EXPAND);
typedef void (*glProgramUniform2ivEXT_PTR)(glProgramUniform2ivEXT_ARG_EXPAND);
#define glProgramUniform2ui_INDEX 1666
#define glProgramUniform2ui_RETURN void
#define glProgramUniform2ui_ARG_NAMES program, location, v0, v1
#define glProgramUniform2ui_ARG_EXPAND GLuint program, GLint location, GLuint v0, GLuint v1
#define glProgramUniform2ui_PACKED PACKED_glProgramUniform2ui
#define glProgramUniform2ui_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramUniform2ui_NOT_VOID_WRAP(...) {}
#define pack_glProgramUniform2ui(_program, _location, _v0, _v1) ({ \
    glProgramUniform2ui_PACKED *packed_data = malloc(sizeof(glProgramUniform2ui_PACKED)); \
    packed_data->index = glProgramUniform2ui_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.v0 = (GLuint)_v0; \
    packed_data->args.v1 = (GLuint)_v1; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramUniform2ui(packed, ret_v) do { \
    PACKED_glProgramUniform2ui *unpacked = (PACKED_glProgramUniform2ui *)packed; \
    ARGS_glProgramUniform2ui *args = (ARGS_glProgramUniform2ui *)&unpacked->args; \
    glProgramUniform2ui(args->program, args->location, args->v0, args->v1);; \
} while(0)
void glProgramUniform2ui(glProgramUniform2ui_ARG_EXPAND);
typedef void (*glProgramUniform2ui_PTR)(glProgramUniform2ui_ARG_EXPAND);
#define glProgramUniform2ui64NV_INDEX 1667
#define glProgramUniform2ui64NV_RETURN void
#define glProgramUniform2ui64NV_ARG_NAMES program, location, x, y
#define glProgramUniform2ui64NV_ARG_EXPAND GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y
#define glProgramUniform2ui64NV_PACKED PACKED_glProgramUniform2ui64NV
#define glProgramUniform2ui64NV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramUniform2ui64NV_NOT_VOID_WRAP(...) {}
#define pack_glProgramUniform2ui64NV(_program, _location, _x, _y) ({ \
    glProgramUniform2ui64NV_PACKED *packed_data = malloc(sizeof(glProgramUniform2ui64NV_PACKED)); \
    packed_data->index = glProgramUniform2ui64NV_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.x = (GLuint64EXT)_x; \
    packed_data->args.y = (GLuint64EXT)_y; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramUniform2ui64NV(packed, ret_v) do { \
    PACKED_glProgramUniform2ui64NV *unpacked = (PACKED_glProgramUniform2ui64NV *)packed; \
    ARGS_glProgramUniform2ui64NV *args = (ARGS_glProgramUniform2ui64NV *)&unpacked->args; \
    glProgramUniform2ui64NV(args->program, args->location, args->x, args->y);; \
} while(0)
void glProgramUniform2ui64NV(glProgramUniform2ui64NV_ARG_EXPAND);
typedef void (*glProgramUniform2ui64NV_PTR)(glProgramUniform2ui64NV_ARG_EXPAND);
#define glProgramUniform2ui64vNV_INDEX 1668
#define glProgramUniform2ui64vNV_RETURN void
#define glProgramUniform2ui64vNV_ARG_NAMES program, location, count, value
#define glProgramUniform2ui64vNV_ARG_EXPAND GLuint program, GLint location, GLsizei count, const GLuint64EXT * value
#define glProgramUniform2ui64vNV_PACKED PACKED_glProgramUniform2ui64vNV
#define glProgramUniform2ui64vNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramUniform2ui64vNV_NOT_VOID_WRAP(...) {}
#define pack_glProgramUniform2ui64vNV(_program, _location, _count, _value) ({ \
    glProgramUniform2ui64vNV_PACKED *packed_data = malloc(sizeof(glProgramUniform2ui64vNV_PACKED)); \
    packed_data->index = glProgramUniform2ui64vNV_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.value = (GLuint64EXT *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramUniform2ui64vNV(packed, ret_v) do { \
    PACKED_glProgramUniform2ui64vNV *unpacked = (PACKED_glProgramUniform2ui64vNV *)packed; \
    ARGS_glProgramUniform2ui64vNV *args = (ARGS_glProgramUniform2ui64vNV *)&unpacked->args; \
    glProgramUniform2ui64vNV(args->program, args->location, args->count, args->value);; \
} while(0)
void glProgramUniform2ui64vNV(glProgramUniform2ui64vNV_ARG_EXPAND);
typedef void (*glProgramUniform2ui64vNV_PTR)(glProgramUniform2ui64vNV_ARG_EXPAND);
#define glProgramUniform2uiEXT_INDEX 1669
#define glProgramUniform2uiEXT_RETURN void
#define glProgramUniform2uiEXT_ARG_NAMES program, location, v0, v1
#define glProgramUniform2uiEXT_ARG_EXPAND GLuint program, GLint location, GLuint v0, GLuint v1
#define glProgramUniform2uiEXT_PACKED PACKED_glProgramUniform2uiEXT
#define glProgramUniform2uiEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramUniform2uiEXT_NOT_VOID_WRAP(...) {}
#define pack_glProgramUniform2uiEXT(_program, _location, _v0, _v1) ({ \
    glProgramUniform2uiEXT_PACKED *packed_data = malloc(sizeof(glProgramUniform2uiEXT_PACKED)); \
    packed_data->index = glProgramUniform2uiEXT_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.v0 = (GLuint)_v0; \
    packed_data->args.v1 = (GLuint)_v1; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramUniform2uiEXT(packed, ret_v) do { \
    PACKED_glProgramUniform2uiEXT *unpacked = (PACKED_glProgramUniform2uiEXT *)packed; \
    ARGS_glProgramUniform2uiEXT *args = (ARGS_glProgramUniform2uiEXT *)&unpacked->args; \
    glProgramUniform2uiEXT(args->program, args->location, args->v0, args->v1);; \
} while(0)
void glProgramUniform2uiEXT(glProgramUniform2uiEXT_ARG_EXPAND);
typedef void (*glProgramUniform2uiEXT_PTR)(glProgramUniform2uiEXT_ARG_EXPAND);
#define glProgramUniform2uiv_INDEX 1670
#define glProgramUniform2uiv_RETURN void
#define glProgramUniform2uiv_ARG_NAMES program, location, count, value
#define glProgramUniform2uiv_ARG_EXPAND GLuint program, GLint location, GLsizei count, const GLuint * value
#define glProgramUniform2uiv_PACKED PACKED_glProgramUniform2uiv
#define glProgramUniform2uiv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramUniform2uiv_NOT_VOID_WRAP(...) {}
#define pack_glProgramUniform2uiv(_program, _location, _count, _value) ({ \
    glProgramUniform2uiv_PACKED *packed_data = malloc(sizeof(glProgramUniform2uiv_PACKED)); \
    packed_data->index = glProgramUniform2uiv_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.value = (GLuint *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramUniform2uiv(packed, ret_v) do { \
    PACKED_glProgramUniform2uiv *unpacked = (PACKED_glProgramUniform2uiv *)packed; \
    ARGS_glProgramUniform2uiv *args = (ARGS_glProgramUniform2uiv *)&unpacked->args; \
    glProgramUniform2uiv(args->program, args->location, args->count, args->value);; \
} while(0)
void glProgramUniform2uiv(glProgramUniform2uiv_ARG_EXPAND);
typedef void (*glProgramUniform2uiv_PTR)(glProgramUniform2uiv_ARG_EXPAND);
#define glProgramUniform2uivEXT_INDEX 1671
#define glProgramUniform2uivEXT_RETURN void
#define glProgramUniform2uivEXT_ARG_NAMES program, location, count, value
#define glProgramUniform2uivEXT_ARG_EXPAND GLuint program, GLint location, GLsizei count, const GLuint * value
#define glProgramUniform2uivEXT_PACKED PACKED_glProgramUniform2uivEXT
#define glProgramUniform2uivEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramUniform2uivEXT_NOT_VOID_WRAP(...) {}
#define pack_glProgramUniform2uivEXT(_program, _location, _count, _value) ({ \
    glProgramUniform2uivEXT_PACKED *packed_data = malloc(sizeof(glProgramUniform2uivEXT_PACKED)); \
    packed_data->index = glProgramUniform2uivEXT_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.value = (GLuint *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramUniform2uivEXT(packed, ret_v) do { \
    PACKED_glProgramUniform2uivEXT *unpacked = (PACKED_glProgramUniform2uivEXT *)packed; \
    ARGS_glProgramUniform2uivEXT *args = (ARGS_glProgramUniform2uivEXT *)&unpacked->args; \
    glProgramUniform2uivEXT(args->program, args->location, args->count, args->value);; \
} while(0)
void glProgramUniform2uivEXT(glProgramUniform2uivEXT_ARG_EXPAND);
typedef void (*glProgramUniform2uivEXT_PTR)(glProgramUniform2uivEXT_ARG_EXPAND);
#define glProgramUniform3d_INDEX 1672
#define glProgramUniform3d_RETURN void
#define glProgramUniform3d_ARG_NAMES program, location, v0, v1, v2
#define glProgramUniform3d_ARG_EXPAND GLuint program, GLint location, GLdouble v0, GLdouble v1, GLdouble v2
#define glProgramUniform3d_PACKED PACKED_glProgramUniform3d
#define glProgramUniform3d_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramUniform3d_NOT_VOID_WRAP(...) {}
#define pack_glProgramUniform3d(_program, _location, _v0, _v1, _v2) ({ \
    glProgramUniform3d_PACKED *packed_data = malloc(sizeof(glProgramUniform3d_PACKED)); \
    packed_data->index = glProgramUniform3d_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.v0 = (GLdouble)_v0; \
    packed_data->args.v1 = (GLdouble)_v1; \
    packed_data->args.v2 = (GLdouble)_v2; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramUniform3d(packed, ret_v) do { \
    PACKED_glProgramUniform3d *unpacked = (PACKED_glProgramUniform3d *)packed; \
    ARGS_glProgramUniform3d *args = (ARGS_glProgramUniform3d *)&unpacked->args; \
    glProgramUniform3d(args->program, args->location, args->v0, args->v1, args->v2);; \
} while(0)
void glProgramUniform3d(glProgramUniform3d_ARG_EXPAND);
typedef void (*glProgramUniform3d_PTR)(glProgramUniform3d_ARG_EXPAND);
#define glProgramUniform3dEXT_INDEX 1673
#define glProgramUniform3dEXT_RETURN void
#define glProgramUniform3dEXT_ARG_NAMES program, location, x, y, z
#define glProgramUniform3dEXT_ARG_EXPAND GLuint program, GLint location, GLdouble x, GLdouble y, GLdouble z
#define glProgramUniform3dEXT_PACKED PACKED_glProgramUniform3dEXT
#define glProgramUniform3dEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramUniform3dEXT_NOT_VOID_WRAP(...) {}
#define pack_glProgramUniform3dEXT(_program, _location, _x, _y, _z) ({ \
    glProgramUniform3dEXT_PACKED *packed_data = malloc(sizeof(glProgramUniform3dEXT_PACKED)); \
    packed_data->index = glProgramUniform3dEXT_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.x = (GLdouble)_x; \
    packed_data->args.y = (GLdouble)_y; \
    packed_data->args.z = (GLdouble)_z; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramUniform3dEXT(packed, ret_v) do { \
    PACKED_glProgramUniform3dEXT *unpacked = (PACKED_glProgramUniform3dEXT *)packed; \
    ARGS_glProgramUniform3dEXT *args = (ARGS_glProgramUniform3dEXT *)&unpacked->args; \
    glProgramUniform3dEXT(args->program, args->location, args->x, args->y, args->z);; \
} while(0)
void glProgramUniform3dEXT(glProgramUniform3dEXT_ARG_EXPAND);
typedef void (*glProgramUniform3dEXT_PTR)(glProgramUniform3dEXT_ARG_EXPAND);
#define glProgramUniform3dv_INDEX 1674
#define glProgramUniform3dv_RETURN void
#define glProgramUniform3dv_ARG_NAMES program, location, count, value
#define glProgramUniform3dv_ARG_EXPAND GLuint program, GLint location, GLsizei count, const GLdouble * value
#define glProgramUniform3dv_PACKED PACKED_glProgramUniform3dv
#define glProgramUniform3dv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramUniform3dv_NOT_VOID_WRAP(...) {}
#define pack_glProgramUniform3dv(_program, _location, _count, _value) ({ \
    glProgramUniform3dv_PACKED *packed_data = malloc(sizeof(glProgramUniform3dv_PACKED)); \
    packed_data->index = glProgramUniform3dv_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.value = (GLdouble *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramUniform3dv(packed, ret_v) do { \
    PACKED_glProgramUniform3dv *unpacked = (PACKED_glProgramUniform3dv *)packed; \
    ARGS_glProgramUniform3dv *args = (ARGS_glProgramUniform3dv *)&unpacked->args; \
    glProgramUniform3dv(args->program, args->location, args->count, args->value);; \
} while(0)
void glProgramUniform3dv(glProgramUniform3dv_ARG_EXPAND);
typedef void (*glProgramUniform3dv_PTR)(glProgramUniform3dv_ARG_EXPAND);
#define glProgramUniform3dvEXT_INDEX 1675
#define glProgramUniform3dvEXT_RETURN void
#define glProgramUniform3dvEXT_ARG_NAMES program, location, count, value
#define glProgramUniform3dvEXT_ARG_EXPAND GLuint program, GLint location, GLsizei count, const GLdouble * value
#define glProgramUniform3dvEXT_PACKED PACKED_glProgramUniform3dvEXT
#define glProgramUniform3dvEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramUniform3dvEXT_NOT_VOID_WRAP(...) {}
#define pack_glProgramUniform3dvEXT(_program, _location, _count, _value) ({ \
    glProgramUniform3dvEXT_PACKED *packed_data = malloc(sizeof(glProgramUniform3dvEXT_PACKED)); \
    packed_data->index = glProgramUniform3dvEXT_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.value = (GLdouble *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramUniform3dvEXT(packed, ret_v) do { \
    PACKED_glProgramUniform3dvEXT *unpacked = (PACKED_glProgramUniform3dvEXT *)packed; \
    ARGS_glProgramUniform3dvEXT *args = (ARGS_glProgramUniform3dvEXT *)&unpacked->args; \
    glProgramUniform3dvEXT(args->program, args->location, args->count, args->value);; \
} while(0)
void glProgramUniform3dvEXT(glProgramUniform3dvEXT_ARG_EXPAND);
typedef void (*glProgramUniform3dvEXT_PTR)(glProgramUniform3dvEXT_ARG_EXPAND);
#define glProgramUniform3f_INDEX 1676
#define glProgramUniform3f_RETURN void
#define glProgramUniform3f_ARG_NAMES program, location, v0, v1, v2
#define glProgramUniform3f_ARG_EXPAND GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2
#define glProgramUniform3f_PACKED PACKED_glProgramUniform3f
#define glProgramUniform3f_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramUniform3f_NOT_VOID_WRAP(...) {}
#define pack_glProgramUniform3f(_program, _location, _v0, _v1, _v2) ({ \
    glProgramUniform3f_PACKED *packed_data = malloc(sizeof(glProgramUniform3f_PACKED)); \
    packed_data->index = glProgramUniform3f_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.v0 = (GLfloat)_v0; \
    packed_data->args.v1 = (GLfloat)_v1; \
    packed_data->args.v2 = (GLfloat)_v2; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramUniform3f(packed, ret_v) do { \
    PACKED_glProgramUniform3f *unpacked = (PACKED_glProgramUniform3f *)packed; \
    ARGS_glProgramUniform3f *args = (ARGS_glProgramUniform3f *)&unpacked->args; \
    glProgramUniform3f(args->program, args->location, args->v0, args->v1, args->v2);; \
} while(0)
void glProgramUniform3f(glProgramUniform3f_ARG_EXPAND);
typedef void (*glProgramUniform3f_PTR)(glProgramUniform3f_ARG_EXPAND);
#define glProgramUniform3fEXT_INDEX 1677
#define glProgramUniform3fEXT_RETURN void
#define glProgramUniform3fEXT_ARG_NAMES program, location, v0, v1, v2
#define glProgramUniform3fEXT_ARG_EXPAND GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2
#define glProgramUniform3fEXT_PACKED PACKED_glProgramUniform3fEXT
#define glProgramUniform3fEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramUniform3fEXT_NOT_VOID_WRAP(...) {}
#define pack_glProgramUniform3fEXT(_program, _location, _v0, _v1, _v2) ({ \
    glProgramUniform3fEXT_PACKED *packed_data = malloc(sizeof(glProgramUniform3fEXT_PACKED)); \
    packed_data->index = glProgramUniform3fEXT_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.v0 = (GLfloat)_v0; \
    packed_data->args.v1 = (GLfloat)_v1; \
    packed_data->args.v2 = (GLfloat)_v2; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramUniform3fEXT(packed, ret_v) do { \
    PACKED_glProgramUniform3fEXT *unpacked = (PACKED_glProgramUniform3fEXT *)packed; \
    ARGS_glProgramUniform3fEXT *args = (ARGS_glProgramUniform3fEXT *)&unpacked->args; \
    glProgramUniform3fEXT(args->program, args->location, args->v0, args->v1, args->v2);; \
} while(0)
void glProgramUniform3fEXT(glProgramUniform3fEXT_ARG_EXPAND);
typedef void (*glProgramUniform3fEXT_PTR)(glProgramUniform3fEXT_ARG_EXPAND);
#define glProgramUniform3fv_INDEX 1678
#define glProgramUniform3fv_RETURN void
#define glProgramUniform3fv_ARG_NAMES program, location, count, value
#define glProgramUniform3fv_ARG_EXPAND GLuint program, GLint location, GLsizei count, const GLfloat * value
#define glProgramUniform3fv_PACKED PACKED_glProgramUniform3fv
#define glProgramUniform3fv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramUniform3fv_NOT_VOID_WRAP(...) {}
#define pack_glProgramUniform3fv(_program, _location, _count, _value) ({ \
    glProgramUniform3fv_PACKED *packed_data = malloc(sizeof(glProgramUniform3fv_PACKED)); \
    packed_data->index = glProgramUniform3fv_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.value = (GLfloat *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramUniform3fv(packed, ret_v) do { \
    PACKED_glProgramUniform3fv *unpacked = (PACKED_glProgramUniform3fv *)packed; \
    ARGS_glProgramUniform3fv *args = (ARGS_glProgramUniform3fv *)&unpacked->args; \
    glProgramUniform3fv(args->program, args->location, args->count, args->value);; \
} while(0)
void glProgramUniform3fv(glProgramUniform3fv_ARG_EXPAND);
typedef void (*glProgramUniform3fv_PTR)(glProgramUniform3fv_ARG_EXPAND);
#define glProgramUniform3fvEXT_INDEX 1679
#define glProgramUniform3fvEXT_RETURN void
#define glProgramUniform3fvEXT_ARG_NAMES program, location, count, value
#define glProgramUniform3fvEXT_ARG_EXPAND GLuint program, GLint location, GLsizei count, const GLfloat * value
#define glProgramUniform3fvEXT_PACKED PACKED_glProgramUniform3fvEXT
#define glProgramUniform3fvEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramUniform3fvEXT_NOT_VOID_WRAP(...) {}
#define pack_glProgramUniform3fvEXT(_program, _location, _count, _value) ({ \
    glProgramUniform3fvEXT_PACKED *packed_data = malloc(sizeof(glProgramUniform3fvEXT_PACKED)); \
    packed_data->index = glProgramUniform3fvEXT_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.value = (GLfloat *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramUniform3fvEXT(packed, ret_v) do { \
    PACKED_glProgramUniform3fvEXT *unpacked = (PACKED_glProgramUniform3fvEXT *)packed; \
    ARGS_glProgramUniform3fvEXT *args = (ARGS_glProgramUniform3fvEXT *)&unpacked->args; \
    glProgramUniform3fvEXT(args->program, args->location, args->count, args->value);; \
} while(0)
void glProgramUniform3fvEXT(glProgramUniform3fvEXT_ARG_EXPAND);
typedef void (*glProgramUniform3fvEXT_PTR)(glProgramUniform3fvEXT_ARG_EXPAND);
#define glProgramUniform3i_INDEX 1680
#define glProgramUniform3i_RETURN void
#define glProgramUniform3i_ARG_NAMES program, location, v0, v1, v2
#define glProgramUniform3i_ARG_EXPAND GLuint program, GLint location, GLint v0, GLint v1, GLint v2
#define glProgramUniform3i_PACKED PACKED_glProgramUniform3i
#define glProgramUniform3i_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramUniform3i_NOT_VOID_WRAP(...) {}
#define pack_glProgramUniform3i(_program, _location, _v0, _v1, _v2) ({ \
    glProgramUniform3i_PACKED *packed_data = malloc(sizeof(glProgramUniform3i_PACKED)); \
    packed_data->index = glProgramUniform3i_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.v0 = (GLint)_v0; \
    packed_data->args.v1 = (GLint)_v1; \
    packed_data->args.v2 = (GLint)_v2; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramUniform3i(packed, ret_v) do { \
    PACKED_glProgramUniform3i *unpacked = (PACKED_glProgramUniform3i *)packed; \
    ARGS_glProgramUniform3i *args = (ARGS_glProgramUniform3i *)&unpacked->args; \
    glProgramUniform3i(args->program, args->location, args->v0, args->v1, args->v2);; \
} while(0)
void glProgramUniform3i(glProgramUniform3i_ARG_EXPAND);
typedef void (*glProgramUniform3i_PTR)(glProgramUniform3i_ARG_EXPAND);
#define glProgramUniform3i64NV_INDEX 1681
#define glProgramUniform3i64NV_RETURN void
#define glProgramUniform3i64NV_ARG_NAMES program, location, x, y, z
#define glProgramUniform3i64NV_ARG_EXPAND GLuint program, GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z
#define glProgramUniform3i64NV_PACKED PACKED_glProgramUniform3i64NV
#define glProgramUniform3i64NV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramUniform3i64NV_NOT_VOID_WRAP(...) {}
#define pack_glProgramUniform3i64NV(_program, _location, _x, _y, _z) ({ \
    glProgramUniform3i64NV_PACKED *packed_data = malloc(sizeof(glProgramUniform3i64NV_PACKED)); \
    packed_data->index = glProgramUniform3i64NV_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.x = (GLint64EXT)_x; \
    packed_data->args.y = (GLint64EXT)_y; \
    packed_data->args.z = (GLint64EXT)_z; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramUniform3i64NV(packed, ret_v) do { \
    PACKED_glProgramUniform3i64NV *unpacked = (PACKED_glProgramUniform3i64NV *)packed; \
    ARGS_glProgramUniform3i64NV *args = (ARGS_glProgramUniform3i64NV *)&unpacked->args; \
    glProgramUniform3i64NV(args->program, args->location, args->x, args->y, args->z);; \
} while(0)
void glProgramUniform3i64NV(glProgramUniform3i64NV_ARG_EXPAND);
typedef void (*glProgramUniform3i64NV_PTR)(glProgramUniform3i64NV_ARG_EXPAND);
#define glProgramUniform3i64vNV_INDEX 1682
#define glProgramUniform3i64vNV_RETURN void
#define glProgramUniform3i64vNV_ARG_NAMES program, location, count, value
#define glProgramUniform3i64vNV_ARG_EXPAND GLuint program, GLint location, GLsizei count, const GLint64EXT * value
#define glProgramUniform3i64vNV_PACKED PACKED_glProgramUniform3i64vNV
#define glProgramUniform3i64vNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramUniform3i64vNV_NOT_VOID_WRAP(...) {}
#define pack_glProgramUniform3i64vNV(_program, _location, _count, _value) ({ \
    glProgramUniform3i64vNV_PACKED *packed_data = malloc(sizeof(glProgramUniform3i64vNV_PACKED)); \
    packed_data->index = glProgramUniform3i64vNV_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.value = (GLint64EXT *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramUniform3i64vNV(packed, ret_v) do { \
    PACKED_glProgramUniform3i64vNV *unpacked = (PACKED_glProgramUniform3i64vNV *)packed; \
    ARGS_glProgramUniform3i64vNV *args = (ARGS_glProgramUniform3i64vNV *)&unpacked->args; \
    glProgramUniform3i64vNV(args->program, args->location, args->count, args->value);; \
} while(0)
void glProgramUniform3i64vNV(glProgramUniform3i64vNV_ARG_EXPAND);
typedef void (*glProgramUniform3i64vNV_PTR)(glProgramUniform3i64vNV_ARG_EXPAND);
#define glProgramUniform3iEXT_INDEX 1683
#define glProgramUniform3iEXT_RETURN void
#define glProgramUniform3iEXT_ARG_NAMES program, location, v0, v1, v2
#define glProgramUniform3iEXT_ARG_EXPAND GLuint program, GLint location, GLint v0, GLint v1, GLint v2
#define glProgramUniform3iEXT_PACKED PACKED_glProgramUniform3iEXT
#define glProgramUniform3iEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramUniform3iEXT_NOT_VOID_WRAP(...) {}
#define pack_glProgramUniform3iEXT(_program, _location, _v0, _v1, _v2) ({ \
    glProgramUniform3iEXT_PACKED *packed_data = malloc(sizeof(glProgramUniform3iEXT_PACKED)); \
    packed_data->index = glProgramUniform3iEXT_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.v0 = (GLint)_v0; \
    packed_data->args.v1 = (GLint)_v1; \
    packed_data->args.v2 = (GLint)_v2; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramUniform3iEXT(packed, ret_v) do { \
    PACKED_glProgramUniform3iEXT *unpacked = (PACKED_glProgramUniform3iEXT *)packed; \
    ARGS_glProgramUniform3iEXT *args = (ARGS_glProgramUniform3iEXT *)&unpacked->args; \
    glProgramUniform3iEXT(args->program, args->location, args->v0, args->v1, args->v2);; \
} while(0)
void glProgramUniform3iEXT(glProgramUniform3iEXT_ARG_EXPAND);
typedef void (*glProgramUniform3iEXT_PTR)(glProgramUniform3iEXT_ARG_EXPAND);
#define glProgramUniform3iv_INDEX 1684
#define glProgramUniform3iv_RETURN void
#define glProgramUniform3iv_ARG_NAMES program, location, count, value
#define glProgramUniform3iv_ARG_EXPAND GLuint program, GLint location, GLsizei count, const GLint * value
#define glProgramUniform3iv_PACKED PACKED_glProgramUniform3iv
#define glProgramUniform3iv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramUniform3iv_NOT_VOID_WRAP(...) {}
#define pack_glProgramUniform3iv(_program, _location, _count, _value) ({ \
    glProgramUniform3iv_PACKED *packed_data = malloc(sizeof(glProgramUniform3iv_PACKED)); \
    packed_data->index = glProgramUniform3iv_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.value = (GLint *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramUniform3iv(packed, ret_v) do { \
    PACKED_glProgramUniform3iv *unpacked = (PACKED_glProgramUniform3iv *)packed; \
    ARGS_glProgramUniform3iv *args = (ARGS_glProgramUniform3iv *)&unpacked->args; \
    glProgramUniform3iv(args->program, args->location, args->count, args->value);; \
} while(0)
void glProgramUniform3iv(glProgramUniform3iv_ARG_EXPAND);
typedef void (*glProgramUniform3iv_PTR)(glProgramUniform3iv_ARG_EXPAND);
#define glProgramUniform3ivEXT_INDEX 1685
#define glProgramUniform3ivEXT_RETURN void
#define glProgramUniform3ivEXT_ARG_NAMES program, location, count, value
#define glProgramUniform3ivEXT_ARG_EXPAND GLuint program, GLint location, GLsizei count, const GLint * value
#define glProgramUniform3ivEXT_PACKED PACKED_glProgramUniform3ivEXT
#define glProgramUniform3ivEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramUniform3ivEXT_NOT_VOID_WRAP(...) {}
#define pack_glProgramUniform3ivEXT(_program, _location, _count, _value) ({ \
    glProgramUniform3ivEXT_PACKED *packed_data = malloc(sizeof(glProgramUniform3ivEXT_PACKED)); \
    packed_data->index = glProgramUniform3ivEXT_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.value = (GLint *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramUniform3ivEXT(packed, ret_v) do { \
    PACKED_glProgramUniform3ivEXT *unpacked = (PACKED_glProgramUniform3ivEXT *)packed; \
    ARGS_glProgramUniform3ivEXT *args = (ARGS_glProgramUniform3ivEXT *)&unpacked->args; \
    glProgramUniform3ivEXT(args->program, args->location, args->count, args->value);; \
} while(0)
void glProgramUniform3ivEXT(glProgramUniform3ivEXT_ARG_EXPAND);
typedef void (*glProgramUniform3ivEXT_PTR)(glProgramUniform3ivEXT_ARG_EXPAND);
#define glProgramUniform3ui_INDEX 1686
#define glProgramUniform3ui_RETURN void
#define glProgramUniform3ui_ARG_NAMES program, location, v0, v1, v2
#define glProgramUniform3ui_ARG_EXPAND GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2
#define glProgramUniform3ui_PACKED PACKED_glProgramUniform3ui
#define glProgramUniform3ui_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramUniform3ui_NOT_VOID_WRAP(...) {}
#define pack_glProgramUniform3ui(_program, _location, _v0, _v1, _v2) ({ \
    glProgramUniform3ui_PACKED *packed_data = malloc(sizeof(glProgramUniform3ui_PACKED)); \
    packed_data->index = glProgramUniform3ui_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.v0 = (GLuint)_v0; \
    packed_data->args.v1 = (GLuint)_v1; \
    packed_data->args.v2 = (GLuint)_v2; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramUniform3ui(packed, ret_v) do { \
    PACKED_glProgramUniform3ui *unpacked = (PACKED_glProgramUniform3ui *)packed; \
    ARGS_glProgramUniform3ui *args = (ARGS_glProgramUniform3ui *)&unpacked->args; \
    glProgramUniform3ui(args->program, args->location, args->v0, args->v1, args->v2);; \
} while(0)
void glProgramUniform3ui(glProgramUniform3ui_ARG_EXPAND);
typedef void (*glProgramUniform3ui_PTR)(glProgramUniform3ui_ARG_EXPAND);
#define glProgramUniform3ui64NV_INDEX 1687
#define glProgramUniform3ui64NV_RETURN void
#define glProgramUniform3ui64NV_ARG_NAMES program, location, x, y, z
#define glProgramUniform3ui64NV_ARG_EXPAND GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z
#define glProgramUniform3ui64NV_PACKED PACKED_glProgramUniform3ui64NV
#define glProgramUniform3ui64NV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramUniform3ui64NV_NOT_VOID_WRAP(...) {}
#define pack_glProgramUniform3ui64NV(_program, _location, _x, _y, _z) ({ \
    glProgramUniform3ui64NV_PACKED *packed_data = malloc(sizeof(glProgramUniform3ui64NV_PACKED)); \
    packed_data->index = glProgramUniform3ui64NV_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.x = (GLuint64EXT)_x; \
    packed_data->args.y = (GLuint64EXT)_y; \
    packed_data->args.z = (GLuint64EXT)_z; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramUniform3ui64NV(packed, ret_v) do { \
    PACKED_glProgramUniform3ui64NV *unpacked = (PACKED_glProgramUniform3ui64NV *)packed; \
    ARGS_glProgramUniform3ui64NV *args = (ARGS_glProgramUniform3ui64NV *)&unpacked->args; \
    glProgramUniform3ui64NV(args->program, args->location, args->x, args->y, args->z);; \
} while(0)
void glProgramUniform3ui64NV(glProgramUniform3ui64NV_ARG_EXPAND);
typedef void (*glProgramUniform3ui64NV_PTR)(glProgramUniform3ui64NV_ARG_EXPAND);
#define glProgramUniform3ui64vNV_INDEX 1688
#define glProgramUniform3ui64vNV_RETURN void
#define glProgramUniform3ui64vNV_ARG_NAMES program, location, count, value
#define glProgramUniform3ui64vNV_ARG_EXPAND GLuint program, GLint location, GLsizei count, const GLuint64EXT * value
#define glProgramUniform3ui64vNV_PACKED PACKED_glProgramUniform3ui64vNV
#define glProgramUniform3ui64vNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramUniform3ui64vNV_NOT_VOID_WRAP(...) {}
#define pack_glProgramUniform3ui64vNV(_program, _location, _count, _value) ({ \
    glProgramUniform3ui64vNV_PACKED *packed_data = malloc(sizeof(glProgramUniform3ui64vNV_PACKED)); \
    packed_data->index = glProgramUniform3ui64vNV_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.value = (GLuint64EXT *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramUniform3ui64vNV(packed, ret_v) do { \
    PACKED_glProgramUniform3ui64vNV *unpacked = (PACKED_glProgramUniform3ui64vNV *)packed; \
    ARGS_glProgramUniform3ui64vNV *args = (ARGS_glProgramUniform3ui64vNV *)&unpacked->args; \
    glProgramUniform3ui64vNV(args->program, args->location, args->count, args->value);; \
} while(0)
void glProgramUniform3ui64vNV(glProgramUniform3ui64vNV_ARG_EXPAND);
typedef void (*glProgramUniform3ui64vNV_PTR)(glProgramUniform3ui64vNV_ARG_EXPAND);
#define glProgramUniform3uiEXT_INDEX 1689
#define glProgramUniform3uiEXT_RETURN void
#define glProgramUniform3uiEXT_ARG_NAMES program, location, v0, v1, v2
#define glProgramUniform3uiEXT_ARG_EXPAND GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2
#define glProgramUniform3uiEXT_PACKED PACKED_glProgramUniform3uiEXT
#define glProgramUniform3uiEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramUniform3uiEXT_NOT_VOID_WRAP(...) {}
#define pack_glProgramUniform3uiEXT(_program, _location, _v0, _v1, _v2) ({ \
    glProgramUniform3uiEXT_PACKED *packed_data = malloc(sizeof(glProgramUniform3uiEXT_PACKED)); \
    packed_data->index = glProgramUniform3uiEXT_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.v0 = (GLuint)_v0; \
    packed_data->args.v1 = (GLuint)_v1; \
    packed_data->args.v2 = (GLuint)_v2; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramUniform3uiEXT(packed, ret_v) do { \
    PACKED_glProgramUniform3uiEXT *unpacked = (PACKED_glProgramUniform3uiEXT *)packed; \
    ARGS_glProgramUniform3uiEXT *args = (ARGS_glProgramUniform3uiEXT *)&unpacked->args; \
    glProgramUniform3uiEXT(args->program, args->location, args->v0, args->v1, args->v2);; \
} while(0)
void glProgramUniform3uiEXT(glProgramUniform3uiEXT_ARG_EXPAND);
typedef void (*glProgramUniform3uiEXT_PTR)(glProgramUniform3uiEXT_ARG_EXPAND);
#define glProgramUniform3uiv_INDEX 1690
#define glProgramUniform3uiv_RETURN void
#define glProgramUniform3uiv_ARG_NAMES program, location, count, value
#define glProgramUniform3uiv_ARG_EXPAND GLuint program, GLint location, GLsizei count, const GLuint * value
#define glProgramUniform3uiv_PACKED PACKED_glProgramUniform3uiv
#define glProgramUniform3uiv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramUniform3uiv_NOT_VOID_WRAP(...) {}
#define pack_glProgramUniform3uiv(_program, _location, _count, _value) ({ \
    glProgramUniform3uiv_PACKED *packed_data = malloc(sizeof(glProgramUniform3uiv_PACKED)); \
    packed_data->index = glProgramUniform3uiv_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.value = (GLuint *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramUniform3uiv(packed, ret_v) do { \
    PACKED_glProgramUniform3uiv *unpacked = (PACKED_glProgramUniform3uiv *)packed; \
    ARGS_glProgramUniform3uiv *args = (ARGS_glProgramUniform3uiv *)&unpacked->args; \
    glProgramUniform3uiv(args->program, args->location, args->count, args->value);; \
} while(0)
void glProgramUniform3uiv(glProgramUniform3uiv_ARG_EXPAND);
typedef void (*glProgramUniform3uiv_PTR)(glProgramUniform3uiv_ARG_EXPAND);
#define glProgramUniform3uivEXT_INDEX 1691
#define glProgramUniform3uivEXT_RETURN void
#define glProgramUniform3uivEXT_ARG_NAMES program, location, count, value
#define glProgramUniform3uivEXT_ARG_EXPAND GLuint program, GLint location, GLsizei count, const GLuint * value
#define glProgramUniform3uivEXT_PACKED PACKED_glProgramUniform3uivEXT
#define glProgramUniform3uivEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramUniform3uivEXT_NOT_VOID_WRAP(...) {}
#define pack_glProgramUniform3uivEXT(_program, _location, _count, _value) ({ \
    glProgramUniform3uivEXT_PACKED *packed_data = malloc(sizeof(glProgramUniform3uivEXT_PACKED)); \
    packed_data->index = glProgramUniform3uivEXT_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.value = (GLuint *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramUniform3uivEXT(packed, ret_v) do { \
    PACKED_glProgramUniform3uivEXT *unpacked = (PACKED_glProgramUniform3uivEXT *)packed; \
    ARGS_glProgramUniform3uivEXT *args = (ARGS_glProgramUniform3uivEXT *)&unpacked->args; \
    glProgramUniform3uivEXT(args->program, args->location, args->count, args->value);; \
} while(0)
void glProgramUniform3uivEXT(glProgramUniform3uivEXT_ARG_EXPAND);
typedef void (*glProgramUniform3uivEXT_PTR)(glProgramUniform3uivEXT_ARG_EXPAND);
#define glProgramUniform4d_INDEX 1692
#define glProgramUniform4d_RETURN void
#define glProgramUniform4d_ARG_NAMES program, location, v0, v1, v2, v3
#define glProgramUniform4d_ARG_EXPAND GLuint program, GLint location, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3
#define glProgramUniform4d_PACKED PACKED_glProgramUniform4d
#define glProgramUniform4d_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramUniform4d_NOT_VOID_WRAP(...) {}
#define pack_glProgramUniform4d(_program, _location, _v0, _v1, _v2, _v3) ({ \
    glProgramUniform4d_PACKED *packed_data = malloc(sizeof(glProgramUniform4d_PACKED)); \
    packed_data->index = glProgramUniform4d_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.v0 = (GLdouble)_v0; \
    packed_data->args.v1 = (GLdouble)_v1; \
    packed_data->args.v2 = (GLdouble)_v2; \
    packed_data->args.v3 = (GLdouble)_v3; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramUniform4d(packed, ret_v) do { \
    PACKED_glProgramUniform4d *unpacked = (PACKED_glProgramUniform4d *)packed; \
    ARGS_glProgramUniform4d *args = (ARGS_glProgramUniform4d *)&unpacked->args; \
    glProgramUniform4d(args->program, args->location, args->v0, args->v1, args->v2, args->v3);; \
} while(0)
void glProgramUniform4d(glProgramUniform4d_ARG_EXPAND);
typedef void (*glProgramUniform4d_PTR)(glProgramUniform4d_ARG_EXPAND);
#define glProgramUniform4dEXT_INDEX 1693
#define glProgramUniform4dEXT_RETURN void
#define glProgramUniform4dEXT_ARG_NAMES program, location, x, y, z, w
#define glProgramUniform4dEXT_ARG_EXPAND GLuint program, GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w
#define glProgramUniform4dEXT_PACKED PACKED_glProgramUniform4dEXT
#define glProgramUniform4dEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramUniform4dEXT_NOT_VOID_WRAP(...) {}
#define pack_glProgramUniform4dEXT(_program, _location, _x, _y, _z, _w) ({ \
    glProgramUniform4dEXT_PACKED *packed_data = malloc(sizeof(glProgramUniform4dEXT_PACKED)); \
    packed_data->index = glProgramUniform4dEXT_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.x = (GLdouble)_x; \
    packed_data->args.y = (GLdouble)_y; \
    packed_data->args.z = (GLdouble)_z; \
    packed_data->args.w = (GLdouble)_w; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramUniform4dEXT(packed, ret_v) do { \
    PACKED_glProgramUniform4dEXT *unpacked = (PACKED_glProgramUniform4dEXT *)packed; \
    ARGS_glProgramUniform4dEXT *args = (ARGS_glProgramUniform4dEXT *)&unpacked->args; \
    glProgramUniform4dEXT(args->program, args->location, args->x, args->y, args->z, args->w);; \
} while(0)
void glProgramUniform4dEXT(glProgramUniform4dEXT_ARG_EXPAND);
typedef void (*glProgramUniform4dEXT_PTR)(glProgramUniform4dEXT_ARG_EXPAND);
#define glProgramUniform4dv_INDEX 1694
#define glProgramUniform4dv_RETURN void
#define glProgramUniform4dv_ARG_NAMES program, location, count, value
#define glProgramUniform4dv_ARG_EXPAND GLuint program, GLint location, GLsizei count, const GLdouble * value
#define glProgramUniform4dv_PACKED PACKED_glProgramUniform4dv
#define glProgramUniform4dv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramUniform4dv_NOT_VOID_WRAP(...) {}
#define pack_glProgramUniform4dv(_program, _location, _count, _value) ({ \
    glProgramUniform4dv_PACKED *packed_data = malloc(sizeof(glProgramUniform4dv_PACKED)); \
    packed_data->index = glProgramUniform4dv_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.value = (GLdouble *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramUniform4dv(packed, ret_v) do { \
    PACKED_glProgramUniform4dv *unpacked = (PACKED_glProgramUniform4dv *)packed; \
    ARGS_glProgramUniform4dv *args = (ARGS_glProgramUniform4dv *)&unpacked->args; \
    glProgramUniform4dv(args->program, args->location, args->count, args->value);; \
} while(0)
void glProgramUniform4dv(glProgramUniform4dv_ARG_EXPAND);
typedef void (*glProgramUniform4dv_PTR)(glProgramUniform4dv_ARG_EXPAND);
#define glProgramUniform4dvEXT_INDEX 1695
#define glProgramUniform4dvEXT_RETURN void
#define glProgramUniform4dvEXT_ARG_NAMES program, location, count, value
#define glProgramUniform4dvEXT_ARG_EXPAND GLuint program, GLint location, GLsizei count, const GLdouble * value
#define glProgramUniform4dvEXT_PACKED PACKED_glProgramUniform4dvEXT
#define glProgramUniform4dvEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramUniform4dvEXT_NOT_VOID_WRAP(...) {}
#define pack_glProgramUniform4dvEXT(_program, _location, _count, _value) ({ \
    glProgramUniform4dvEXT_PACKED *packed_data = malloc(sizeof(glProgramUniform4dvEXT_PACKED)); \
    packed_data->index = glProgramUniform4dvEXT_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.value = (GLdouble *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramUniform4dvEXT(packed, ret_v) do { \
    PACKED_glProgramUniform4dvEXT *unpacked = (PACKED_glProgramUniform4dvEXT *)packed; \
    ARGS_glProgramUniform4dvEXT *args = (ARGS_glProgramUniform4dvEXT *)&unpacked->args; \
    glProgramUniform4dvEXT(args->program, args->location, args->count, args->value);; \
} while(0)
void glProgramUniform4dvEXT(glProgramUniform4dvEXT_ARG_EXPAND);
typedef void (*glProgramUniform4dvEXT_PTR)(glProgramUniform4dvEXT_ARG_EXPAND);
#define glProgramUniform4f_INDEX 1696
#define glProgramUniform4f_RETURN void
#define glProgramUniform4f_ARG_NAMES program, location, v0, v1, v2, v3
#define glProgramUniform4f_ARG_EXPAND GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3
#define glProgramUniform4f_PACKED PACKED_glProgramUniform4f
#define glProgramUniform4f_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramUniform4f_NOT_VOID_WRAP(...) {}
#define pack_glProgramUniform4f(_program, _location, _v0, _v1, _v2, _v3) ({ \
    glProgramUniform4f_PACKED *packed_data = malloc(sizeof(glProgramUniform4f_PACKED)); \
    packed_data->index = glProgramUniform4f_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.v0 = (GLfloat)_v0; \
    packed_data->args.v1 = (GLfloat)_v1; \
    packed_data->args.v2 = (GLfloat)_v2; \
    packed_data->args.v3 = (GLfloat)_v3; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramUniform4f(packed, ret_v) do { \
    PACKED_glProgramUniform4f *unpacked = (PACKED_glProgramUniform4f *)packed; \
    ARGS_glProgramUniform4f *args = (ARGS_glProgramUniform4f *)&unpacked->args; \
    glProgramUniform4f(args->program, args->location, args->v0, args->v1, args->v2, args->v3);; \
} while(0)
void glProgramUniform4f(glProgramUniform4f_ARG_EXPAND);
typedef void (*glProgramUniform4f_PTR)(glProgramUniform4f_ARG_EXPAND);
#define glProgramUniform4fEXT_INDEX 1697
#define glProgramUniform4fEXT_RETURN void
#define glProgramUniform4fEXT_ARG_NAMES program, location, v0, v1, v2, v3
#define glProgramUniform4fEXT_ARG_EXPAND GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3
#define glProgramUniform4fEXT_PACKED PACKED_glProgramUniform4fEXT
#define glProgramUniform4fEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramUniform4fEXT_NOT_VOID_WRAP(...) {}
#define pack_glProgramUniform4fEXT(_program, _location, _v0, _v1, _v2, _v3) ({ \
    glProgramUniform4fEXT_PACKED *packed_data = malloc(sizeof(glProgramUniform4fEXT_PACKED)); \
    packed_data->index = glProgramUniform4fEXT_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.v0 = (GLfloat)_v0; \
    packed_data->args.v1 = (GLfloat)_v1; \
    packed_data->args.v2 = (GLfloat)_v2; \
    packed_data->args.v3 = (GLfloat)_v3; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramUniform4fEXT(packed, ret_v) do { \
    PACKED_glProgramUniform4fEXT *unpacked = (PACKED_glProgramUniform4fEXT *)packed; \
    ARGS_glProgramUniform4fEXT *args = (ARGS_glProgramUniform4fEXT *)&unpacked->args; \
    glProgramUniform4fEXT(args->program, args->location, args->v0, args->v1, args->v2, args->v3);; \
} while(0)
void glProgramUniform4fEXT(glProgramUniform4fEXT_ARG_EXPAND);
typedef void (*glProgramUniform4fEXT_PTR)(glProgramUniform4fEXT_ARG_EXPAND);
#define glProgramUniform4fv_INDEX 1698
#define glProgramUniform4fv_RETURN void
#define glProgramUniform4fv_ARG_NAMES program, location, count, value
#define glProgramUniform4fv_ARG_EXPAND GLuint program, GLint location, GLsizei count, const GLfloat * value
#define glProgramUniform4fv_PACKED PACKED_glProgramUniform4fv
#define glProgramUniform4fv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramUniform4fv_NOT_VOID_WRAP(...) {}
#define pack_glProgramUniform4fv(_program, _location, _count, _value) ({ \
    glProgramUniform4fv_PACKED *packed_data = malloc(sizeof(glProgramUniform4fv_PACKED)); \
    packed_data->index = glProgramUniform4fv_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.value = (GLfloat *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramUniform4fv(packed, ret_v) do { \
    PACKED_glProgramUniform4fv *unpacked = (PACKED_glProgramUniform4fv *)packed; \
    ARGS_glProgramUniform4fv *args = (ARGS_glProgramUniform4fv *)&unpacked->args; \
    glProgramUniform4fv(args->program, args->location, args->count, args->value);; \
} while(0)
void glProgramUniform4fv(glProgramUniform4fv_ARG_EXPAND);
typedef void (*glProgramUniform4fv_PTR)(glProgramUniform4fv_ARG_EXPAND);
#define glProgramUniform4fvEXT_INDEX 1699
#define glProgramUniform4fvEXT_RETURN void
#define glProgramUniform4fvEXT_ARG_NAMES program, location, count, value
#define glProgramUniform4fvEXT_ARG_EXPAND GLuint program, GLint location, GLsizei count, const GLfloat * value
#define glProgramUniform4fvEXT_PACKED PACKED_glProgramUniform4fvEXT
#define glProgramUniform4fvEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramUniform4fvEXT_NOT_VOID_WRAP(...) {}
#define pack_glProgramUniform4fvEXT(_program, _location, _count, _value) ({ \
    glProgramUniform4fvEXT_PACKED *packed_data = malloc(sizeof(glProgramUniform4fvEXT_PACKED)); \
    packed_data->index = glProgramUniform4fvEXT_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.value = (GLfloat *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramUniform4fvEXT(packed, ret_v) do { \
    PACKED_glProgramUniform4fvEXT *unpacked = (PACKED_glProgramUniform4fvEXT *)packed; \
    ARGS_glProgramUniform4fvEXT *args = (ARGS_glProgramUniform4fvEXT *)&unpacked->args; \
    glProgramUniform4fvEXT(args->program, args->location, args->count, args->value);; \
} while(0)
void glProgramUniform4fvEXT(glProgramUniform4fvEXT_ARG_EXPAND);
typedef void (*glProgramUniform4fvEXT_PTR)(glProgramUniform4fvEXT_ARG_EXPAND);
#define glProgramUniform4i_INDEX 1700
#define glProgramUniform4i_RETURN void
#define glProgramUniform4i_ARG_NAMES program, location, v0, v1, v2, v3
#define glProgramUniform4i_ARG_EXPAND GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3
#define glProgramUniform4i_PACKED PACKED_glProgramUniform4i
#define glProgramUniform4i_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramUniform4i_NOT_VOID_WRAP(...) {}
#define pack_glProgramUniform4i(_program, _location, _v0, _v1, _v2, _v3) ({ \
    glProgramUniform4i_PACKED *packed_data = malloc(sizeof(glProgramUniform4i_PACKED)); \
    packed_data->index = glProgramUniform4i_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.v0 = (GLint)_v0; \
    packed_data->args.v1 = (GLint)_v1; \
    packed_data->args.v2 = (GLint)_v2; \
    packed_data->args.v3 = (GLint)_v3; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramUniform4i(packed, ret_v) do { \
    PACKED_glProgramUniform4i *unpacked = (PACKED_glProgramUniform4i *)packed; \
    ARGS_glProgramUniform4i *args = (ARGS_glProgramUniform4i *)&unpacked->args; \
    glProgramUniform4i(args->program, args->location, args->v0, args->v1, args->v2, args->v3);; \
} while(0)
void glProgramUniform4i(glProgramUniform4i_ARG_EXPAND);
typedef void (*glProgramUniform4i_PTR)(glProgramUniform4i_ARG_EXPAND);
#define glProgramUniform4i64NV_INDEX 1701
#define glProgramUniform4i64NV_RETURN void
#define glProgramUniform4i64NV_ARG_NAMES program, location, x, y, z, w
#define glProgramUniform4i64NV_ARG_EXPAND GLuint program, GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w
#define glProgramUniform4i64NV_PACKED PACKED_glProgramUniform4i64NV
#define glProgramUniform4i64NV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramUniform4i64NV_NOT_VOID_WRAP(...) {}
#define pack_glProgramUniform4i64NV(_program, _location, _x, _y, _z, _w) ({ \
    glProgramUniform4i64NV_PACKED *packed_data = malloc(sizeof(glProgramUniform4i64NV_PACKED)); \
    packed_data->index = glProgramUniform4i64NV_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.x = (GLint64EXT)_x; \
    packed_data->args.y = (GLint64EXT)_y; \
    packed_data->args.z = (GLint64EXT)_z; \
    packed_data->args.w = (GLint64EXT)_w; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramUniform4i64NV(packed, ret_v) do { \
    PACKED_glProgramUniform4i64NV *unpacked = (PACKED_glProgramUniform4i64NV *)packed; \
    ARGS_glProgramUniform4i64NV *args = (ARGS_glProgramUniform4i64NV *)&unpacked->args; \
    glProgramUniform4i64NV(args->program, args->location, args->x, args->y, args->z, args->w);; \
} while(0)
void glProgramUniform4i64NV(glProgramUniform4i64NV_ARG_EXPAND);
typedef void (*glProgramUniform4i64NV_PTR)(glProgramUniform4i64NV_ARG_EXPAND);
#define glProgramUniform4i64vNV_INDEX 1702
#define glProgramUniform4i64vNV_RETURN void
#define glProgramUniform4i64vNV_ARG_NAMES program, location, count, value
#define glProgramUniform4i64vNV_ARG_EXPAND GLuint program, GLint location, GLsizei count, const GLint64EXT * value
#define glProgramUniform4i64vNV_PACKED PACKED_glProgramUniform4i64vNV
#define glProgramUniform4i64vNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramUniform4i64vNV_NOT_VOID_WRAP(...) {}
#define pack_glProgramUniform4i64vNV(_program, _location, _count, _value) ({ \
    glProgramUniform4i64vNV_PACKED *packed_data = malloc(sizeof(glProgramUniform4i64vNV_PACKED)); \
    packed_data->index = glProgramUniform4i64vNV_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.value = (GLint64EXT *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramUniform4i64vNV(packed, ret_v) do { \
    PACKED_glProgramUniform4i64vNV *unpacked = (PACKED_glProgramUniform4i64vNV *)packed; \
    ARGS_glProgramUniform4i64vNV *args = (ARGS_glProgramUniform4i64vNV *)&unpacked->args; \
    glProgramUniform4i64vNV(args->program, args->location, args->count, args->value);; \
} while(0)
void glProgramUniform4i64vNV(glProgramUniform4i64vNV_ARG_EXPAND);
typedef void (*glProgramUniform4i64vNV_PTR)(glProgramUniform4i64vNV_ARG_EXPAND);
#define glProgramUniform4iEXT_INDEX 1703
#define glProgramUniform4iEXT_RETURN void
#define glProgramUniform4iEXT_ARG_NAMES program, location, v0, v1, v2, v3
#define glProgramUniform4iEXT_ARG_EXPAND GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3
#define glProgramUniform4iEXT_PACKED PACKED_glProgramUniform4iEXT
#define glProgramUniform4iEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramUniform4iEXT_NOT_VOID_WRAP(...) {}
#define pack_glProgramUniform4iEXT(_program, _location, _v0, _v1, _v2, _v3) ({ \
    glProgramUniform4iEXT_PACKED *packed_data = malloc(sizeof(glProgramUniform4iEXT_PACKED)); \
    packed_data->index = glProgramUniform4iEXT_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.v0 = (GLint)_v0; \
    packed_data->args.v1 = (GLint)_v1; \
    packed_data->args.v2 = (GLint)_v2; \
    packed_data->args.v3 = (GLint)_v3; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramUniform4iEXT(packed, ret_v) do { \
    PACKED_glProgramUniform4iEXT *unpacked = (PACKED_glProgramUniform4iEXT *)packed; \
    ARGS_glProgramUniform4iEXT *args = (ARGS_glProgramUniform4iEXT *)&unpacked->args; \
    glProgramUniform4iEXT(args->program, args->location, args->v0, args->v1, args->v2, args->v3);; \
} while(0)
void glProgramUniform4iEXT(glProgramUniform4iEXT_ARG_EXPAND);
typedef void (*glProgramUniform4iEXT_PTR)(glProgramUniform4iEXT_ARG_EXPAND);
#define glProgramUniform4iv_INDEX 1704
#define glProgramUniform4iv_RETURN void
#define glProgramUniform4iv_ARG_NAMES program, location, count, value
#define glProgramUniform4iv_ARG_EXPAND GLuint program, GLint location, GLsizei count, const GLint * value
#define glProgramUniform4iv_PACKED PACKED_glProgramUniform4iv
#define glProgramUniform4iv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramUniform4iv_NOT_VOID_WRAP(...) {}
#define pack_glProgramUniform4iv(_program, _location, _count, _value) ({ \
    glProgramUniform4iv_PACKED *packed_data = malloc(sizeof(glProgramUniform4iv_PACKED)); \
    packed_data->index = glProgramUniform4iv_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.value = (GLint *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramUniform4iv(packed, ret_v) do { \
    PACKED_glProgramUniform4iv *unpacked = (PACKED_glProgramUniform4iv *)packed; \
    ARGS_glProgramUniform4iv *args = (ARGS_glProgramUniform4iv *)&unpacked->args; \
    glProgramUniform4iv(args->program, args->location, args->count, args->value);; \
} while(0)
void glProgramUniform4iv(glProgramUniform4iv_ARG_EXPAND);
typedef void (*glProgramUniform4iv_PTR)(glProgramUniform4iv_ARG_EXPAND);
#define glProgramUniform4ivEXT_INDEX 1705
#define glProgramUniform4ivEXT_RETURN void
#define glProgramUniform4ivEXT_ARG_NAMES program, location, count, value
#define glProgramUniform4ivEXT_ARG_EXPAND GLuint program, GLint location, GLsizei count, const GLint * value
#define glProgramUniform4ivEXT_PACKED PACKED_glProgramUniform4ivEXT
#define glProgramUniform4ivEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramUniform4ivEXT_NOT_VOID_WRAP(...) {}
#define pack_glProgramUniform4ivEXT(_program, _location, _count, _value) ({ \
    glProgramUniform4ivEXT_PACKED *packed_data = malloc(sizeof(glProgramUniform4ivEXT_PACKED)); \
    packed_data->index = glProgramUniform4ivEXT_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.value = (GLint *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramUniform4ivEXT(packed, ret_v) do { \
    PACKED_glProgramUniform4ivEXT *unpacked = (PACKED_glProgramUniform4ivEXT *)packed; \
    ARGS_glProgramUniform4ivEXT *args = (ARGS_glProgramUniform4ivEXT *)&unpacked->args; \
    glProgramUniform4ivEXT(args->program, args->location, args->count, args->value);; \
} while(0)
void glProgramUniform4ivEXT(glProgramUniform4ivEXT_ARG_EXPAND);
typedef void (*glProgramUniform4ivEXT_PTR)(glProgramUniform4ivEXT_ARG_EXPAND);
#define glProgramUniform4ui_INDEX 1706
#define glProgramUniform4ui_RETURN void
#define glProgramUniform4ui_ARG_NAMES program, location, v0, v1, v2, v3
#define glProgramUniform4ui_ARG_EXPAND GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3
#define glProgramUniform4ui_PACKED PACKED_glProgramUniform4ui
#define glProgramUniform4ui_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramUniform4ui_NOT_VOID_WRAP(...) {}
#define pack_glProgramUniform4ui(_program, _location, _v0, _v1, _v2, _v3) ({ \
    glProgramUniform4ui_PACKED *packed_data = malloc(sizeof(glProgramUniform4ui_PACKED)); \
    packed_data->index = glProgramUniform4ui_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.v0 = (GLuint)_v0; \
    packed_data->args.v1 = (GLuint)_v1; \
    packed_data->args.v2 = (GLuint)_v2; \
    packed_data->args.v3 = (GLuint)_v3; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramUniform4ui(packed, ret_v) do { \
    PACKED_glProgramUniform4ui *unpacked = (PACKED_glProgramUniform4ui *)packed; \
    ARGS_glProgramUniform4ui *args = (ARGS_glProgramUniform4ui *)&unpacked->args; \
    glProgramUniform4ui(args->program, args->location, args->v0, args->v1, args->v2, args->v3);; \
} while(0)
void glProgramUniform4ui(glProgramUniform4ui_ARG_EXPAND);
typedef void (*glProgramUniform4ui_PTR)(glProgramUniform4ui_ARG_EXPAND);
#define glProgramUniform4ui64NV_INDEX 1707
#define glProgramUniform4ui64NV_RETURN void
#define glProgramUniform4ui64NV_ARG_NAMES program, location, x, y, z, w
#define glProgramUniform4ui64NV_ARG_EXPAND GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w
#define glProgramUniform4ui64NV_PACKED PACKED_glProgramUniform4ui64NV
#define glProgramUniform4ui64NV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramUniform4ui64NV_NOT_VOID_WRAP(...) {}
#define pack_glProgramUniform4ui64NV(_program, _location, _x, _y, _z, _w) ({ \
    glProgramUniform4ui64NV_PACKED *packed_data = malloc(sizeof(glProgramUniform4ui64NV_PACKED)); \
    packed_data->index = glProgramUniform4ui64NV_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.x = (GLuint64EXT)_x; \
    packed_data->args.y = (GLuint64EXT)_y; \
    packed_data->args.z = (GLuint64EXT)_z; \
    packed_data->args.w = (GLuint64EXT)_w; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramUniform4ui64NV(packed, ret_v) do { \
    PACKED_glProgramUniform4ui64NV *unpacked = (PACKED_glProgramUniform4ui64NV *)packed; \
    ARGS_glProgramUniform4ui64NV *args = (ARGS_glProgramUniform4ui64NV *)&unpacked->args; \
    glProgramUniform4ui64NV(args->program, args->location, args->x, args->y, args->z, args->w);; \
} while(0)
void glProgramUniform4ui64NV(glProgramUniform4ui64NV_ARG_EXPAND);
typedef void (*glProgramUniform4ui64NV_PTR)(glProgramUniform4ui64NV_ARG_EXPAND);
#define glProgramUniform4ui64vNV_INDEX 1708
#define glProgramUniform4ui64vNV_RETURN void
#define glProgramUniform4ui64vNV_ARG_NAMES program, location, count, value
#define glProgramUniform4ui64vNV_ARG_EXPAND GLuint program, GLint location, GLsizei count, const GLuint64EXT * value
#define glProgramUniform4ui64vNV_PACKED PACKED_glProgramUniform4ui64vNV
#define glProgramUniform4ui64vNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramUniform4ui64vNV_NOT_VOID_WRAP(...) {}
#define pack_glProgramUniform4ui64vNV(_program, _location, _count, _value) ({ \
    glProgramUniform4ui64vNV_PACKED *packed_data = malloc(sizeof(glProgramUniform4ui64vNV_PACKED)); \
    packed_data->index = glProgramUniform4ui64vNV_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.value = (GLuint64EXT *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramUniform4ui64vNV(packed, ret_v) do { \
    PACKED_glProgramUniform4ui64vNV *unpacked = (PACKED_glProgramUniform4ui64vNV *)packed; \
    ARGS_glProgramUniform4ui64vNV *args = (ARGS_glProgramUniform4ui64vNV *)&unpacked->args; \
    glProgramUniform4ui64vNV(args->program, args->location, args->count, args->value);; \
} while(0)
void glProgramUniform4ui64vNV(glProgramUniform4ui64vNV_ARG_EXPAND);
typedef void (*glProgramUniform4ui64vNV_PTR)(glProgramUniform4ui64vNV_ARG_EXPAND);
#define glProgramUniform4uiEXT_INDEX 1709
#define glProgramUniform4uiEXT_RETURN void
#define glProgramUniform4uiEXT_ARG_NAMES program, location, v0, v1, v2, v3
#define glProgramUniform4uiEXT_ARG_EXPAND GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3
#define glProgramUniform4uiEXT_PACKED PACKED_glProgramUniform4uiEXT
#define glProgramUniform4uiEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramUniform4uiEXT_NOT_VOID_WRAP(...) {}
#define pack_glProgramUniform4uiEXT(_program, _location, _v0, _v1, _v2, _v3) ({ \
    glProgramUniform4uiEXT_PACKED *packed_data = malloc(sizeof(glProgramUniform4uiEXT_PACKED)); \
    packed_data->index = glProgramUniform4uiEXT_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.v0 = (GLuint)_v0; \
    packed_data->args.v1 = (GLuint)_v1; \
    packed_data->args.v2 = (GLuint)_v2; \
    packed_data->args.v3 = (GLuint)_v3; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramUniform4uiEXT(packed, ret_v) do { \
    PACKED_glProgramUniform4uiEXT *unpacked = (PACKED_glProgramUniform4uiEXT *)packed; \
    ARGS_glProgramUniform4uiEXT *args = (ARGS_glProgramUniform4uiEXT *)&unpacked->args; \
    glProgramUniform4uiEXT(args->program, args->location, args->v0, args->v1, args->v2, args->v3);; \
} while(0)
void glProgramUniform4uiEXT(glProgramUniform4uiEXT_ARG_EXPAND);
typedef void (*glProgramUniform4uiEXT_PTR)(glProgramUniform4uiEXT_ARG_EXPAND);
#define glProgramUniform4uiv_INDEX 1710
#define glProgramUniform4uiv_RETURN void
#define glProgramUniform4uiv_ARG_NAMES program, location, count, value
#define glProgramUniform4uiv_ARG_EXPAND GLuint program, GLint location, GLsizei count, const GLuint * value
#define glProgramUniform4uiv_PACKED PACKED_glProgramUniform4uiv
#define glProgramUniform4uiv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramUniform4uiv_NOT_VOID_WRAP(...) {}
#define pack_glProgramUniform4uiv(_program, _location, _count, _value) ({ \
    glProgramUniform4uiv_PACKED *packed_data = malloc(sizeof(glProgramUniform4uiv_PACKED)); \
    packed_data->index = glProgramUniform4uiv_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.value = (GLuint *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramUniform4uiv(packed, ret_v) do { \
    PACKED_glProgramUniform4uiv *unpacked = (PACKED_glProgramUniform4uiv *)packed; \
    ARGS_glProgramUniform4uiv *args = (ARGS_glProgramUniform4uiv *)&unpacked->args; \
    glProgramUniform4uiv(args->program, args->location, args->count, args->value);; \
} while(0)
void glProgramUniform4uiv(glProgramUniform4uiv_ARG_EXPAND);
typedef void (*glProgramUniform4uiv_PTR)(glProgramUniform4uiv_ARG_EXPAND);
#define glProgramUniform4uivEXT_INDEX 1711
#define glProgramUniform4uivEXT_RETURN void
#define glProgramUniform4uivEXT_ARG_NAMES program, location, count, value
#define glProgramUniform4uivEXT_ARG_EXPAND GLuint program, GLint location, GLsizei count, const GLuint * value
#define glProgramUniform4uivEXT_PACKED PACKED_glProgramUniform4uivEXT
#define glProgramUniform4uivEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramUniform4uivEXT_NOT_VOID_WRAP(...) {}
#define pack_glProgramUniform4uivEXT(_program, _location, _count, _value) ({ \
    glProgramUniform4uivEXT_PACKED *packed_data = malloc(sizeof(glProgramUniform4uivEXT_PACKED)); \
    packed_data->index = glProgramUniform4uivEXT_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.value = (GLuint *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramUniform4uivEXT(packed, ret_v) do { \
    PACKED_glProgramUniform4uivEXT *unpacked = (PACKED_glProgramUniform4uivEXT *)packed; \
    ARGS_glProgramUniform4uivEXT *args = (ARGS_glProgramUniform4uivEXT *)&unpacked->args; \
    glProgramUniform4uivEXT(args->program, args->location, args->count, args->value);; \
} while(0)
void glProgramUniform4uivEXT(glProgramUniform4uivEXT_ARG_EXPAND);
typedef void (*glProgramUniform4uivEXT_PTR)(glProgramUniform4uivEXT_ARG_EXPAND);
#define glProgramUniformHandleui64NV_INDEX 1712
#define glProgramUniformHandleui64NV_RETURN void
#define glProgramUniformHandleui64NV_ARG_NAMES program, location, value
#define glProgramUniformHandleui64NV_ARG_EXPAND GLuint program, GLint location, GLuint64 value
#define glProgramUniformHandleui64NV_PACKED PACKED_glProgramUniformHandleui64NV
#define glProgramUniformHandleui64NV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramUniformHandleui64NV_NOT_VOID_WRAP(...) {}
#define pack_glProgramUniformHandleui64NV(_program, _location, _value) ({ \
    glProgramUniformHandleui64NV_PACKED *packed_data = malloc(sizeof(glProgramUniformHandleui64NV_PACKED)); \
    packed_data->index = glProgramUniformHandleui64NV_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.value = (GLuint64)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramUniformHandleui64NV(packed, ret_v) do { \
    PACKED_glProgramUniformHandleui64NV *unpacked = (PACKED_glProgramUniformHandleui64NV *)packed; \
    ARGS_glProgramUniformHandleui64NV *args = (ARGS_glProgramUniformHandleui64NV *)&unpacked->args; \
    glProgramUniformHandleui64NV(args->program, args->location, args->value);; \
} while(0)
void glProgramUniformHandleui64NV(glProgramUniformHandleui64NV_ARG_EXPAND);
typedef void (*glProgramUniformHandleui64NV_PTR)(glProgramUniformHandleui64NV_ARG_EXPAND);
#define glProgramUniformHandleui64vNV_INDEX 1713
#define glProgramUniformHandleui64vNV_RETURN void
#define glProgramUniformHandleui64vNV_ARG_NAMES program, location, count, values
#define glProgramUniformHandleui64vNV_ARG_EXPAND GLuint program, GLint location, GLsizei count, const GLuint64 * values
#define glProgramUniformHandleui64vNV_PACKED PACKED_glProgramUniformHandleui64vNV
#define glProgramUniformHandleui64vNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramUniformHandleui64vNV_NOT_VOID_WRAP(...) {}
#define pack_glProgramUniformHandleui64vNV(_program, _location, _count, _values) ({ \
    glProgramUniformHandleui64vNV_PACKED *packed_data = malloc(sizeof(glProgramUniformHandleui64vNV_PACKED)); \
    packed_data->index = glProgramUniformHandleui64vNV_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.values = (GLuint64 *)_values; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramUniformHandleui64vNV(packed, ret_v) do { \
    PACKED_glProgramUniformHandleui64vNV *unpacked = (PACKED_glProgramUniformHandleui64vNV *)packed; \
    ARGS_glProgramUniformHandleui64vNV *args = (ARGS_glProgramUniformHandleui64vNV *)&unpacked->args; \
    glProgramUniformHandleui64vNV(args->program, args->location, args->count, args->values);; \
} while(0)
void glProgramUniformHandleui64vNV(glProgramUniformHandleui64vNV_ARG_EXPAND);
typedef void (*glProgramUniformHandleui64vNV_PTR)(glProgramUniformHandleui64vNV_ARG_EXPAND);
#define glProgramUniformMatrix2dv_INDEX 1714
#define glProgramUniformMatrix2dv_RETURN void
#define glProgramUniformMatrix2dv_ARG_NAMES program, location, count, transpose, value
#define glProgramUniformMatrix2dv_ARG_EXPAND GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value
#define glProgramUniformMatrix2dv_PACKED PACKED_glProgramUniformMatrix2dv
#define glProgramUniformMatrix2dv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramUniformMatrix2dv_NOT_VOID_WRAP(...) {}
#define pack_glProgramUniformMatrix2dv(_program, _location, _count, _transpose, _value) ({ \
    glProgramUniformMatrix2dv_PACKED *packed_data = malloc(sizeof(glProgramUniformMatrix2dv_PACKED)); \
    packed_data->index = glProgramUniformMatrix2dv_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.transpose = (GLboolean)_transpose; \
    packed_data->args.value = (GLdouble *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramUniformMatrix2dv(packed, ret_v) do { \
    PACKED_glProgramUniformMatrix2dv *unpacked = (PACKED_glProgramUniformMatrix2dv *)packed; \
    ARGS_glProgramUniformMatrix2dv *args = (ARGS_glProgramUniformMatrix2dv *)&unpacked->args; \
    glProgramUniformMatrix2dv(args->program, args->location, args->count, args->transpose, args->value);; \
} while(0)
void glProgramUniformMatrix2dv(glProgramUniformMatrix2dv_ARG_EXPAND);
typedef void (*glProgramUniformMatrix2dv_PTR)(glProgramUniformMatrix2dv_ARG_EXPAND);
#define glProgramUniformMatrix2dvEXT_INDEX 1715
#define glProgramUniformMatrix2dvEXT_RETURN void
#define glProgramUniformMatrix2dvEXT_ARG_NAMES program, location, count, transpose, value
#define glProgramUniformMatrix2dvEXT_ARG_EXPAND GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value
#define glProgramUniformMatrix2dvEXT_PACKED PACKED_glProgramUniformMatrix2dvEXT
#define glProgramUniformMatrix2dvEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramUniformMatrix2dvEXT_NOT_VOID_WRAP(...) {}
#define pack_glProgramUniformMatrix2dvEXT(_program, _location, _count, _transpose, _value) ({ \
    glProgramUniformMatrix2dvEXT_PACKED *packed_data = malloc(sizeof(glProgramUniformMatrix2dvEXT_PACKED)); \
    packed_data->index = glProgramUniformMatrix2dvEXT_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.transpose = (GLboolean)_transpose; \
    packed_data->args.value = (GLdouble *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramUniformMatrix2dvEXT(packed, ret_v) do { \
    PACKED_glProgramUniformMatrix2dvEXT *unpacked = (PACKED_glProgramUniformMatrix2dvEXT *)packed; \
    ARGS_glProgramUniformMatrix2dvEXT *args = (ARGS_glProgramUniformMatrix2dvEXT *)&unpacked->args; \
    glProgramUniformMatrix2dvEXT(args->program, args->location, args->count, args->transpose, args->value);; \
} while(0)
void glProgramUniformMatrix2dvEXT(glProgramUniformMatrix2dvEXT_ARG_EXPAND);
typedef void (*glProgramUniformMatrix2dvEXT_PTR)(glProgramUniformMatrix2dvEXT_ARG_EXPAND);
#define glProgramUniformMatrix2fv_INDEX 1716
#define glProgramUniformMatrix2fv_RETURN void
#define glProgramUniformMatrix2fv_ARG_NAMES program, location, count, transpose, value
#define glProgramUniformMatrix2fv_ARG_EXPAND GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value
#define glProgramUniformMatrix2fv_PACKED PACKED_glProgramUniformMatrix2fv
#define glProgramUniformMatrix2fv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramUniformMatrix2fv_NOT_VOID_WRAP(...) {}
#define pack_glProgramUniformMatrix2fv(_program, _location, _count, _transpose, _value) ({ \
    glProgramUniformMatrix2fv_PACKED *packed_data = malloc(sizeof(glProgramUniformMatrix2fv_PACKED)); \
    packed_data->index = glProgramUniformMatrix2fv_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.transpose = (GLboolean)_transpose; \
    packed_data->args.value = (GLfloat *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramUniformMatrix2fv(packed, ret_v) do { \
    PACKED_glProgramUniformMatrix2fv *unpacked = (PACKED_glProgramUniformMatrix2fv *)packed; \
    ARGS_glProgramUniformMatrix2fv *args = (ARGS_glProgramUniformMatrix2fv *)&unpacked->args; \
    glProgramUniformMatrix2fv(args->program, args->location, args->count, args->transpose, args->value);; \
} while(0)
void glProgramUniformMatrix2fv(glProgramUniformMatrix2fv_ARG_EXPAND);
typedef void (*glProgramUniformMatrix2fv_PTR)(glProgramUniformMatrix2fv_ARG_EXPAND);
#define glProgramUniformMatrix2fvEXT_INDEX 1717
#define glProgramUniformMatrix2fvEXT_RETURN void
#define glProgramUniformMatrix2fvEXT_ARG_NAMES program, location, count, transpose, value
#define glProgramUniformMatrix2fvEXT_ARG_EXPAND GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value
#define glProgramUniformMatrix2fvEXT_PACKED PACKED_glProgramUniformMatrix2fvEXT
#define glProgramUniformMatrix2fvEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramUniformMatrix2fvEXT_NOT_VOID_WRAP(...) {}
#define pack_glProgramUniformMatrix2fvEXT(_program, _location, _count, _transpose, _value) ({ \
    glProgramUniformMatrix2fvEXT_PACKED *packed_data = malloc(sizeof(glProgramUniformMatrix2fvEXT_PACKED)); \
    packed_data->index = glProgramUniformMatrix2fvEXT_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.transpose = (GLboolean)_transpose; \
    packed_data->args.value = (GLfloat *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramUniformMatrix2fvEXT(packed, ret_v) do { \
    PACKED_glProgramUniformMatrix2fvEXT *unpacked = (PACKED_glProgramUniformMatrix2fvEXT *)packed; \
    ARGS_glProgramUniformMatrix2fvEXT *args = (ARGS_glProgramUniformMatrix2fvEXT *)&unpacked->args; \
    glProgramUniformMatrix2fvEXT(args->program, args->location, args->count, args->transpose, args->value);; \
} while(0)
void glProgramUniformMatrix2fvEXT(glProgramUniformMatrix2fvEXT_ARG_EXPAND);
typedef void (*glProgramUniformMatrix2fvEXT_PTR)(glProgramUniformMatrix2fvEXT_ARG_EXPAND);
#define glProgramUniformMatrix2x3dv_INDEX 1718
#define glProgramUniformMatrix2x3dv_RETURN void
#define glProgramUniformMatrix2x3dv_ARG_NAMES program, location, count, transpose, value
#define glProgramUniformMatrix2x3dv_ARG_EXPAND GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value
#define glProgramUniformMatrix2x3dv_PACKED PACKED_glProgramUniformMatrix2x3dv
#define glProgramUniformMatrix2x3dv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramUniformMatrix2x3dv_NOT_VOID_WRAP(...) {}
#define pack_glProgramUniformMatrix2x3dv(_program, _location, _count, _transpose, _value) ({ \
    glProgramUniformMatrix2x3dv_PACKED *packed_data = malloc(sizeof(glProgramUniformMatrix2x3dv_PACKED)); \
    packed_data->index = glProgramUniformMatrix2x3dv_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.transpose = (GLboolean)_transpose; \
    packed_data->args.value = (GLdouble *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramUniformMatrix2x3dv(packed, ret_v) do { \
    PACKED_glProgramUniformMatrix2x3dv *unpacked = (PACKED_glProgramUniformMatrix2x3dv *)packed; \
    ARGS_glProgramUniformMatrix2x3dv *args = (ARGS_glProgramUniformMatrix2x3dv *)&unpacked->args; \
    glProgramUniformMatrix2x3dv(args->program, args->location, args->count, args->transpose, args->value);; \
} while(0)
void glProgramUniformMatrix2x3dv(glProgramUniformMatrix2x3dv_ARG_EXPAND);
typedef void (*glProgramUniformMatrix2x3dv_PTR)(glProgramUniformMatrix2x3dv_ARG_EXPAND);
#define glProgramUniformMatrix2x3dvEXT_INDEX 1719
#define glProgramUniformMatrix2x3dvEXT_RETURN void
#define glProgramUniformMatrix2x3dvEXT_ARG_NAMES program, location, count, transpose, value
#define glProgramUniformMatrix2x3dvEXT_ARG_EXPAND GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value
#define glProgramUniformMatrix2x3dvEXT_PACKED PACKED_glProgramUniformMatrix2x3dvEXT
#define glProgramUniformMatrix2x3dvEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramUniformMatrix2x3dvEXT_NOT_VOID_WRAP(...) {}
#define pack_glProgramUniformMatrix2x3dvEXT(_program, _location, _count, _transpose, _value) ({ \
    glProgramUniformMatrix2x3dvEXT_PACKED *packed_data = malloc(sizeof(glProgramUniformMatrix2x3dvEXT_PACKED)); \
    packed_data->index = glProgramUniformMatrix2x3dvEXT_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.transpose = (GLboolean)_transpose; \
    packed_data->args.value = (GLdouble *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramUniformMatrix2x3dvEXT(packed, ret_v) do { \
    PACKED_glProgramUniformMatrix2x3dvEXT *unpacked = (PACKED_glProgramUniformMatrix2x3dvEXT *)packed; \
    ARGS_glProgramUniformMatrix2x3dvEXT *args = (ARGS_glProgramUniformMatrix2x3dvEXT *)&unpacked->args; \
    glProgramUniformMatrix2x3dvEXT(args->program, args->location, args->count, args->transpose, args->value);; \
} while(0)
void glProgramUniformMatrix2x3dvEXT(glProgramUniformMatrix2x3dvEXT_ARG_EXPAND);
typedef void (*glProgramUniformMatrix2x3dvEXT_PTR)(glProgramUniformMatrix2x3dvEXT_ARG_EXPAND);
#define glProgramUniformMatrix2x3fv_INDEX 1720
#define glProgramUniformMatrix2x3fv_RETURN void
#define glProgramUniformMatrix2x3fv_ARG_NAMES program, location, count, transpose, value
#define glProgramUniformMatrix2x3fv_ARG_EXPAND GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value
#define glProgramUniformMatrix2x3fv_PACKED PACKED_glProgramUniformMatrix2x3fv
#define glProgramUniformMatrix2x3fv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramUniformMatrix2x3fv_NOT_VOID_WRAP(...) {}
#define pack_glProgramUniformMatrix2x3fv(_program, _location, _count, _transpose, _value) ({ \
    glProgramUniformMatrix2x3fv_PACKED *packed_data = malloc(sizeof(glProgramUniformMatrix2x3fv_PACKED)); \
    packed_data->index = glProgramUniformMatrix2x3fv_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.transpose = (GLboolean)_transpose; \
    packed_data->args.value = (GLfloat *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramUniformMatrix2x3fv(packed, ret_v) do { \
    PACKED_glProgramUniformMatrix2x3fv *unpacked = (PACKED_glProgramUniformMatrix2x3fv *)packed; \
    ARGS_glProgramUniformMatrix2x3fv *args = (ARGS_glProgramUniformMatrix2x3fv *)&unpacked->args; \
    glProgramUniformMatrix2x3fv(args->program, args->location, args->count, args->transpose, args->value);; \
} while(0)
void glProgramUniformMatrix2x3fv(glProgramUniformMatrix2x3fv_ARG_EXPAND);
typedef void (*glProgramUniformMatrix2x3fv_PTR)(glProgramUniformMatrix2x3fv_ARG_EXPAND);
#define glProgramUniformMatrix2x3fvEXT_INDEX 1721
#define glProgramUniformMatrix2x3fvEXT_RETURN void
#define glProgramUniformMatrix2x3fvEXT_ARG_NAMES program, location, count, transpose, value
#define glProgramUniformMatrix2x3fvEXT_ARG_EXPAND GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value
#define glProgramUniformMatrix2x3fvEXT_PACKED PACKED_glProgramUniformMatrix2x3fvEXT
#define glProgramUniformMatrix2x3fvEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramUniformMatrix2x3fvEXT_NOT_VOID_WRAP(...) {}
#define pack_glProgramUniformMatrix2x3fvEXT(_program, _location, _count, _transpose, _value) ({ \
    glProgramUniformMatrix2x3fvEXT_PACKED *packed_data = malloc(sizeof(glProgramUniformMatrix2x3fvEXT_PACKED)); \
    packed_data->index = glProgramUniformMatrix2x3fvEXT_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.transpose = (GLboolean)_transpose; \
    packed_data->args.value = (GLfloat *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramUniformMatrix2x3fvEXT(packed, ret_v) do { \
    PACKED_glProgramUniformMatrix2x3fvEXT *unpacked = (PACKED_glProgramUniformMatrix2x3fvEXT *)packed; \
    ARGS_glProgramUniformMatrix2x3fvEXT *args = (ARGS_glProgramUniformMatrix2x3fvEXT *)&unpacked->args; \
    glProgramUniformMatrix2x3fvEXT(args->program, args->location, args->count, args->transpose, args->value);; \
} while(0)
void glProgramUniformMatrix2x3fvEXT(glProgramUniformMatrix2x3fvEXT_ARG_EXPAND);
typedef void (*glProgramUniformMatrix2x3fvEXT_PTR)(glProgramUniformMatrix2x3fvEXT_ARG_EXPAND);
#define glProgramUniformMatrix2x4dv_INDEX 1722
#define glProgramUniformMatrix2x4dv_RETURN void
#define glProgramUniformMatrix2x4dv_ARG_NAMES program, location, count, transpose, value
#define glProgramUniformMatrix2x4dv_ARG_EXPAND GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value
#define glProgramUniformMatrix2x4dv_PACKED PACKED_glProgramUniformMatrix2x4dv
#define glProgramUniformMatrix2x4dv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramUniformMatrix2x4dv_NOT_VOID_WRAP(...) {}
#define pack_glProgramUniformMatrix2x4dv(_program, _location, _count, _transpose, _value) ({ \
    glProgramUniformMatrix2x4dv_PACKED *packed_data = malloc(sizeof(glProgramUniformMatrix2x4dv_PACKED)); \
    packed_data->index = glProgramUniformMatrix2x4dv_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.transpose = (GLboolean)_transpose; \
    packed_data->args.value = (GLdouble *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramUniformMatrix2x4dv(packed, ret_v) do { \
    PACKED_glProgramUniformMatrix2x4dv *unpacked = (PACKED_glProgramUniformMatrix2x4dv *)packed; \
    ARGS_glProgramUniformMatrix2x4dv *args = (ARGS_glProgramUniformMatrix2x4dv *)&unpacked->args; \
    glProgramUniformMatrix2x4dv(args->program, args->location, args->count, args->transpose, args->value);; \
} while(0)
void glProgramUniformMatrix2x4dv(glProgramUniformMatrix2x4dv_ARG_EXPAND);
typedef void (*glProgramUniformMatrix2x4dv_PTR)(glProgramUniformMatrix2x4dv_ARG_EXPAND);
#define glProgramUniformMatrix2x4dvEXT_INDEX 1723
#define glProgramUniformMatrix2x4dvEXT_RETURN void
#define glProgramUniformMatrix2x4dvEXT_ARG_NAMES program, location, count, transpose, value
#define glProgramUniformMatrix2x4dvEXT_ARG_EXPAND GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value
#define glProgramUniformMatrix2x4dvEXT_PACKED PACKED_glProgramUniformMatrix2x4dvEXT
#define glProgramUniformMatrix2x4dvEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramUniformMatrix2x4dvEXT_NOT_VOID_WRAP(...) {}
#define pack_glProgramUniformMatrix2x4dvEXT(_program, _location, _count, _transpose, _value) ({ \
    glProgramUniformMatrix2x4dvEXT_PACKED *packed_data = malloc(sizeof(glProgramUniformMatrix2x4dvEXT_PACKED)); \
    packed_data->index = glProgramUniformMatrix2x4dvEXT_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.transpose = (GLboolean)_transpose; \
    packed_data->args.value = (GLdouble *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramUniformMatrix2x4dvEXT(packed, ret_v) do { \
    PACKED_glProgramUniformMatrix2x4dvEXT *unpacked = (PACKED_glProgramUniformMatrix2x4dvEXT *)packed; \
    ARGS_glProgramUniformMatrix2x4dvEXT *args = (ARGS_glProgramUniformMatrix2x4dvEXT *)&unpacked->args; \
    glProgramUniformMatrix2x4dvEXT(args->program, args->location, args->count, args->transpose, args->value);; \
} while(0)
void glProgramUniformMatrix2x4dvEXT(glProgramUniformMatrix2x4dvEXT_ARG_EXPAND);
typedef void (*glProgramUniformMatrix2x4dvEXT_PTR)(glProgramUniformMatrix2x4dvEXT_ARG_EXPAND);
#define glProgramUniformMatrix2x4fv_INDEX 1724
#define glProgramUniformMatrix2x4fv_RETURN void
#define glProgramUniformMatrix2x4fv_ARG_NAMES program, location, count, transpose, value
#define glProgramUniformMatrix2x4fv_ARG_EXPAND GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value
#define glProgramUniformMatrix2x4fv_PACKED PACKED_glProgramUniformMatrix2x4fv
#define glProgramUniformMatrix2x4fv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramUniformMatrix2x4fv_NOT_VOID_WRAP(...) {}
#define pack_glProgramUniformMatrix2x4fv(_program, _location, _count, _transpose, _value) ({ \
    glProgramUniformMatrix2x4fv_PACKED *packed_data = malloc(sizeof(glProgramUniformMatrix2x4fv_PACKED)); \
    packed_data->index = glProgramUniformMatrix2x4fv_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.transpose = (GLboolean)_transpose; \
    packed_data->args.value = (GLfloat *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramUniformMatrix2x4fv(packed, ret_v) do { \
    PACKED_glProgramUniformMatrix2x4fv *unpacked = (PACKED_glProgramUniformMatrix2x4fv *)packed; \
    ARGS_glProgramUniformMatrix2x4fv *args = (ARGS_glProgramUniformMatrix2x4fv *)&unpacked->args; \
    glProgramUniformMatrix2x4fv(args->program, args->location, args->count, args->transpose, args->value);; \
} while(0)
void glProgramUniformMatrix2x4fv(glProgramUniformMatrix2x4fv_ARG_EXPAND);
typedef void (*glProgramUniformMatrix2x4fv_PTR)(glProgramUniformMatrix2x4fv_ARG_EXPAND);
#define glProgramUniformMatrix2x4fvEXT_INDEX 1725
#define glProgramUniformMatrix2x4fvEXT_RETURN void
#define glProgramUniformMatrix2x4fvEXT_ARG_NAMES program, location, count, transpose, value
#define glProgramUniformMatrix2x4fvEXT_ARG_EXPAND GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value
#define glProgramUniformMatrix2x4fvEXT_PACKED PACKED_glProgramUniformMatrix2x4fvEXT
#define glProgramUniformMatrix2x4fvEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramUniformMatrix2x4fvEXT_NOT_VOID_WRAP(...) {}
#define pack_glProgramUniformMatrix2x4fvEXT(_program, _location, _count, _transpose, _value) ({ \
    glProgramUniformMatrix2x4fvEXT_PACKED *packed_data = malloc(sizeof(glProgramUniformMatrix2x4fvEXT_PACKED)); \
    packed_data->index = glProgramUniformMatrix2x4fvEXT_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.transpose = (GLboolean)_transpose; \
    packed_data->args.value = (GLfloat *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramUniformMatrix2x4fvEXT(packed, ret_v) do { \
    PACKED_glProgramUniformMatrix2x4fvEXT *unpacked = (PACKED_glProgramUniformMatrix2x4fvEXT *)packed; \
    ARGS_glProgramUniformMatrix2x4fvEXT *args = (ARGS_glProgramUniformMatrix2x4fvEXT *)&unpacked->args; \
    glProgramUniformMatrix2x4fvEXT(args->program, args->location, args->count, args->transpose, args->value);; \
} while(0)
void glProgramUniformMatrix2x4fvEXT(glProgramUniformMatrix2x4fvEXT_ARG_EXPAND);
typedef void (*glProgramUniformMatrix2x4fvEXT_PTR)(glProgramUniformMatrix2x4fvEXT_ARG_EXPAND);
#define glProgramUniformMatrix3dv_INDEX 1726
#define glProgramUniformMatrix3dv_RETURN void
#define glProgramUniformMatrix3dv_ARG_NAMES program, location, count, transpose, value
#define glProgramUniformMatrix3dv_ARG_EXPAND GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value
#define glProgramUniformMatrix3dv_PACKED PACKED_glProgramUniformMatrix3dv
#define glProgramUniformMatrix3dv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramUniformMatrix3dv_NOT_VOID_WRAP(...) {}
#define pack_glProgramUniformMatrix3dv(_program, _location, _count, _transpose, _value) ({ \
    glProgramUniformMatrix3dv_PACKED *packed_data = malloc(sizeof(glProgramUniformMatrix3dv_PACKED)); \
    packed_data->index = glProgramUniformMatrix3dv_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.transpose = (GLboolean)_transpose; \
    packed_data->args.value = (GLdouble *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramUniformMatrix3dv(packed, ret_v) do { \
    PACKED_glProgramUniformMatrix3dv *unpacked = (PACKED_glProgramUniformMatrix3dv *)packed; \
    ARGS_glProgramUniformMatrix3dv *args = (ARGS_glProgramUniformMatrix3dv *)&unpacked->args; \
    glProgramUniformMatrix3dv(args->program, args->location, args->count, args->transpose, args->value);; \
} while(0)
void glProgramUniformMatrix3dv(glProgramUniformMatrix3dv_ARG_EXPAND);
typedef void (*glProgramUniformMatrix3dv_PTR)(glProgramUniformMatrix3dv_ARG_EXPAND);
#define glProgramUniformMatrix3dvEXT_INDEX 1727
#define glProgramUniformMatrix3dvEXT_RETURN void
#define glProgramUniformMatrix3dvEXT_ARG_NAMES program, location, count, transpose, value
#define glProgramUniformMatrix3dvEXT_ARG_EXPAND GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value
#define glProgramUniformMatrix3dvEXT_PACKED PACKED_glProgramUniformMatrix3dvEXT
#define glProgramUniformMatrix3dvEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramUniformMatrix3dvEXT_NOT_VOID_WRAP(...) {}
#define pack_glProgramUniformMatrix3dvEXT(_program, _location, _count, _transpose, _value) ({ \
    glProgramUniformMatrix3dvEXT_PACKED *packed_data = malloc(sizeof(glProgramUniformMatrix3dvEXT_PACKED)); \
    packed_data->index = glProgramUniformMatrix3dvEXT_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.transpose = (GLboolean)_transpose; \
    packed_data->args.value = (GLdouble *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramUniformMatrix3dvEXT(packed, ret_v) do { \
    PACKED_glProgramUniformMatrix3dvEXT *unpacked = (PACKED_glProgramUniformMatrix3dvEXT *)packed; \
    ARGS_glProgramUniformMatrix3dvEXT *args = (ARGS_glProgramUniformMatrix3dvEXT *)&unpacked->args; \
    glProgramUniformMatrix3dvEXT(args->program, args->location, args->count, args->transpose, args->value);; \
} while(0)
void glProgramUniformMatrix3dvEXT(glProgramUniformMatrix3dvEXT_ARG_EXPAND);
typedef void (*glProgramUniformMatrix3dvEXT_PTR)(glProgramUniformMatrix3dvEXT_ARG_EXPAND);
#define glProgramUniformMatrix3fv_INDEX 1728
#define glProgramUniformMatrix3fv_RETURN void
#define glProgramUniformMatrix3fv_ARG_NAMES program, location, count, transpose, value
#define glProgramUniformMatrix3fv_ARG_EXPAND GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value
#define glProgramUniformMatrix3fv_PACKED PACKED_glProgramUniformMatrix3fv
#define glProgramUniformMatrix3fv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramUniformMatrix3fv_NOT_VOID_WRAP(...) {}
#define pack_glProgramUniformMatrix3fv(_program, _location, _count, _transpose, _value) ({ \
    glProgramUniformMatrix3fv_PACKED *packed_data = malloc(sizeof(glProgramUniformMatrix3fv_PACKED)); \
    packed_data->index = glProgramUniformMatrix3fv_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.transpose = (GLboolean)_transpose; \
    packed_data->args.value = (GLfloat *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramUniformMatrix3fv(packed, ret_v) do { \
    PACKED_glProgramUniformMatrix3fv *unpacked = (PACKED_glProgramUniformMatrix3fv *)packed; \
    ARGS_glProgramUniformMatrix3fv *args = (ARGS_glProgramUniformMatrix3fv *)&unpacked->args; \
    glProgramUniformMatrix3fv(args->program, args->location, args->count, args->transpose, args->value);; \
} while(0)
void glProgramUniformMatrix3fv(glProgramUniformMatrix3fv_ARG_EXPAND);
typedef void (*glProgramUniformMatrix3fv_PTR)(glProgramUniformMatrix3fv_ARG_EXPAND);
#define glProgramUniformMatrix3fvEXT_INDEX 1729
#define glProgramUniformMatrix3fvEXT_RETURN void
#define glProgramUniformMatrix3fvEXT_ARG_NAMES program, location, count, transpose, value
#define glProgramUniformMatrix3fvEXT_ARG_EXPAND GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value
#define glProgramUniformMatrix3fvEXT_PACKED PACKED_glProgramUniformMatrix3fvEXT
#define glProgramUniformMatrix3fvEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramUniformMatrix3fvEXT_NOT_VOID_WRAP(...) {}
#define pack_glProgramUniformMatrix3fvEXT(_program, _location, _count, _transpose, _value) ({ \
    glProgramUniformMatrix3fvEXT_PACKED *packed_data = malloc(sizeof(glProgramUniformMatrix3fvEXT_PACKED)); \
    packed_data->index = glProgramUniformMatrix3fvEXT_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.transpose = (GLboolean)_transpose; \
    packed_data->args.value = (GLfloat *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramUniformMatrix3fvEXT(packed, ret_v) do { \
    PACKED_glProgramUniformMatrix3fvEXT *unpacked = (PACKED_glProgramUniformMatrix3fvEXT *)packed; \
    ARGS_glProgramUniformMatrix3fvEXT *args = (ARGS_glProgramUniformMatrix3fvEXT *)&unpacked->args; \
    glProgramUniformMatrix3fvEXT(args->program, args->location, args->count, args->transpose, args->value);; \
} while(0)
void glProgramUniformMatrix3fvEXT(glProgramUniformMatrix3fvEXT_ARG_EXPAND);
typedef void (*glProgramUniformMatrix3fvEXT_PTR)(glProgramUniformMatrix3fvEXT_ARG_EXPAND);
#define glProgramUniformMatrix3x2dv_INDEX 1730
#define glProgramUniformMatrix3x2dv_RETURN void
#define glProgramUniformMatrix3x2dv_ARG_NAMES program, location, count, transpose, value
#define glProgramUniformMatrix3x2dv_ARG_EXPAND GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value
#define glProgramUniformMatrix3x2dv_PACKED PACKED_glProgramUniformMatrix3x2dv
#define glProgramUniformMatrix3x2dv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramUniformMatrix3x2dv_NOT_VOID_WRAP(...) {}
#define pack_glProgramUniformMatrix3x2dv(_program, _location, _count, _transpose, _value) ({ \
    glProgramUniformMatrix3x2dv_PACKED *packed_data = malloc(sizeof(glProgramUniformMatrix3x2dv_PACKED)); \
    packed_data->index = glProgramUniformMatrix3x2dv_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.transpose = (GLboolean)_transpose; \
    packed_data->args.value = (GLdouble *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramUniformMatrix3x2dv(packed, ret_v) do { \
    PACKED_glProgramUniformMatrix3x2dv *unpacked = (PACKED_glProgramUniformMatrix3x2dv *)packed; \
    ARGS_glProgramUniformMatrix3x2dv *args = (ARGS_glProgramUniformMatrix3x2dv *)&unpacked->args; \
    glProgramUniformMatrix3x2dv(args->program, args->location, args->count, args->transpose, args->value);; \
} while(0)
void glProgramUniformMatrix3x2dv(glProgramUniformMatrix3x2dv_ARG_EXPAND);
typedef void (*glProgramUniformMatrix3x2dv_PTR)(glProgramUniformMatrix3x2dv_ARG_EXPAND);
#define glProgramUniformMatrix3x2dvEXT_INDEX 1731
#define glProgramUniformMatrix3x2dvEXT_RETURN void
#define glProgramUniformMatrix3x2dvEXT_ARG_NAMES program, location, count, transpose, value
#define glProgramUniformMatrix3x2dvEXT_ARG_EXPAND GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value
#define glProgramUniformMatrix3x2dvEXT_PACKED PACKED_glProgramUniformMatrix3x2dvEXT
#define glProgramUniformMatrix3x2dvEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramUniformMatrix3x2dvEXT_NOT_VOID_WRAP(...) {}
#define pack_glProgramUniformMatrix3x2dvEXT(_program, _location, _count, _transpose, _value) ({ \
    glProgramUniformMatrix3x2dvEXT_PACKED *packed_data = malloc(sizeof(glProgramUniformMatrix3x2dvEXT_PACKED)); \
    packed_data->index = glProgramUniformMatrix3x2dvEXT_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.transpose = (GLboolean)_transpose; \
    packed_data->args.value = (GLdouble *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramUniformMatrix3x2dvEXT(packed, ret_v) do { \
    PACKED_glProgramUniformMatrix3x2dvEXT *unpacked = (PACKED_glProgramUniformMatrix3x2dvEXT *)packed; \
    ARGS_glProgramUniformMatrix3x2dvEXT *args = (ARGS_glProgramUniformMatrix3x2dvEXT *)&unpacked->args; \
    glProgramUniformMatrix3x2dvEXT(args->program, args->location, args->count, args->transpose, args->value);; \
} while(0)
void glProgramUniformMatrix3x2dvEXT(glProgramUniformMatrix3x2dvEXT_ARG_EXPAND);
typedef void (*glProgramUniformMatrix3x2dvEXT_PTR)(glProgramUniformMatrix3x2dvEXT_ARG_EXPAND);
#define glProgramUniformMatrix3x2fv_INDEX 1732
#define glProgramUniformMatrix3x2fv_RETURN void
#define glProgramUniformMatrix3x2fv_ARG_NAMES program, location, count, transpose, value
#define glProgramUniformMatrix3x2fv_ARG_EXPAND GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value
#define glProgramUniformMatrix3x2fv_PACKED PACKED_glProgramUniformMatrix3x2fv
#define glProgramUniformMatrix3x2fv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramUniformMatrix3x2fv_NOT_VOID_WRAP(...) {}
#define pack_glProgramUniformMatrix3x2fv(_program, _location, _count, _transpose, _value) ({ \
    glProgramUniformMatrix3x2fv_PACKED *packed_data = malloc(sizeof(glProgramUniformMatrix3x2fv_PACKED)); \
    packed_data->index = glProgramUniformMatrix3x2fv_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.transpose = (GLboolean)_transpose; \
    packed_data->args.value = (GLfloat *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramUniformMatrix3x2fv(packed, ret_v) do { \
    PACKED_glProgramUniformMatrix3x2fv *unpacked = (PACKED_glProgramUniformMatrix3x2fv *)packed; \
    ARGS_glProgramUniformMatrix3x2fv *args = (ARGS_glProgramUniformMatrix3x2fv *)&unpacked->args; \
    glProgramUniformMatrix3x2fv(args->program, args->location, args->count, args->transpose, args->value);; \
} while(0)
void glProgramUniformMatrix3x2fv(glProgramUniformMatrix3x2fv_ARG_EXPAND);
typedef void (*glProgramUniformMatrix3x2fv_PTR)(glProgramUniformMatrix3x2fv_ARG_EXPAND);
#define glProgramUniformMatrix3x2fvEXT_INDEX 1733
#define glProgramUniformMatrix3x2fvEXT_RETURN void
#define glProgramUniformMatrix3x2fvEXT_ARG_NAMES program, location, count, transpose, value
#define glProgramUniformMatrix3x2fvEXT_ARG_EXPAND GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value
#define glProgramUniformMatrix3x2fvEXT_PACKED PACKED_glProgramUniformMatrix3x2fvEXT
#define glProgramUniformMatrix3x2fvEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramUniformMatrix3x2fvEXT_NOT_VOID_WRAP(...) {}
#define pack_glProgramUniformMatrix3x2fvEXT(_program, _location, _count, _transpose, _value) ({ \
    glProgramUniformMatrix3x2fvEXT_PACKED *packed_data = malloc(sizeof(glProgramUniformMatrix3x2fvEXT_PACKED)); \
    packed_data->index = glProgramUniformMatrix3x2fvEXT_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.transpose = (GLboolean)_transpose; \
    packed_data->args.value = (GLfloat *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramUniformMatrix3x2fvEXT(packed, ret_v) do { \
    PACKED_glProgramUniformMatrix3x2fvEXT *unpacked = (PACKED_glProgramUniformMatrix3x2fvEXT *)packed; \
    ARGS_glProgramUniformMatrix3x2fvEXT *args = (ARGS_glProgramUniformMatrix3x2fvEXT *)&unpacked->args; \
    glProgramUniformMatrix3x2fvEXT(args->program, args->location, args->count, args->transpose, args->value);; \
} while(0)
void glProgramUniformMatrix3x2fvEXT(glProgramUniformMatrix3x2fvEXT_ARG_EXPAND);
typedef void (*glProgramUniformMatrix3x2fvEXT_PTR)(glProgramUniformMatrix3x2fvEXT_ARG_EXPAND);
#define glProgramUniformMatrix3x4dv_INDEX 1734
#define glProgramUniformMatrix3x4dv_RETURN void
#define glProgramUniformMatrix3x4dv_ARG_NAMES program, location, count, transpose, value
#define glProgramUniformMatrix3x4dv_ARG_EXPAND GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value
#define glProgramUniformMatrix3x4dv_PACKED PACKED_glProgramUniformMatrix3x4dv
#define glProgramUniformMatrix3x4dv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramUniformMatrix3x4dv_NOT_VOID_WRAP(...) {}
#define pack_glProgramUniformMatrix3x4dv(_program, _location, _count, _transpose, _value) ({ \
    glProgramUniformMatrix3x4dv_PACKED *packed_data = malloc(sizeof(glProgramUniformMatrix3x4dv_PACKED)); \
    packed_data->index = glProgramUniformMatrix3x4dv_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.transpose = (GLboolean)_transpose; \
    packed_data->args.value = (GLdouble *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramUniformMatrix3x4dv(packed, ret_v) do { \
    PACKED_glProgramUniformMatrix3x4dv *unpacked = (PACKED_glProgramUniformMatrix3x4dv *)packed; \
    ARGS_glProgramUniformMatrix3x4dv *args = (ARGS_glProgramUniformMatrix3x4dv *)&unpacked->args; \
    glProgramUniformMatrix3x4dv(args->program, args->location, args->count, args->transpose, args->value);; \
} while(0)
void glProgramUniformMatrix3x4dv(glProgramUniformMatrix3x4dv_ARG_EXPAND);
typedef void (*glProgramUniformMatrix3x4dv_PTR)(glProgramUniformMatrix3x4dv_ARG_EXPAND);
#define glProgramUniformMatrix3x4dvEXT_INDEX 1735
#define glProgramUniformMatrix3x4dvEXT_RETURN void
#define glProgramUniformMatrix3x4dvEXT_ARG_NAMES program, location, count, transpose, value
#define glProgramUniformMatrix3x4dvEXT_ARG_EXPAND GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value
#define glProgramUniformMatrix3x4dvEXT_PACKED PACKED_glProgramUniformMatrix3x4dvEXT
#define glProgramUniformMatrix3x4dvEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramUniformMatrix3x4dvEXT_NOT_VOID_WRAP(...) {}
#define pack_glProgramUniformMatrix3x4dvEXT(_program, _location, _count, _transpose, _value) ({ \
    glProgramUniformMatrix3x4dvEXT_PACKED *packed_data = malloc(sizeof(glProgramUniformMatrix3x4dvEXT_PACKED)); \
    packed_data->index = glProgramUniformMatrix3x4dvEXT_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.transpose = (GLboolean)_transpose; \
    packed_data->args.value = (GLdouble *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramUniformMatrix3x4dvEXT(packed, ret_v) do { \
    PACKED_glProgramUniformMatrix3x4dvEXT *unpacked = (PACKED_glProgramUniformMatrix3x4dvEXT *)packed; \
    ARGS_glProgramUniformMatrix3x4dvEXT *args = (ARGS_glProgramUniformMatrix3x4dvEXT *)&unpacked->args; \
    glProgramUniformMatrix3x4dvEXT(args->program, args->location, args->count, args->transpose, args->value);; \
} while(0)
void glProgramUniformMatrix3x4dvEXT(glProgramUniformMatrix3x4dvEXT_ARG_EXPAND);
typedef void (*glProgramUniformMatrix3x4dvEXT_PTR)(glProgramUniformMatrix3x4dvEXT_ARG_EXPAND);
#define glProgramUniformMatrix3x4fv_INDEX 1736
#define glProgramUniformMatrix3x4fv_RETURN void
#define glProgramUniformMatrix3x4fv_ARG_NAMES program, location, count, transpose, value
#define glProgramUniformMatrix3x4fv_ARG_EXPAND GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value
#define glProgramUniformMatrix3x4fv_PACKED PACKED_glProgramUniformMatrix3x4fv
#define glProgramUniformMatrix3x4fv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramUniformMatrix3x4fv_NOT_VOID_WRAP(...) {}
#define pack_glProgramUniformMatrix3x4fv(_program, _location, _count, _transpose, _value) ({ \
    glProgramUniformMatrix3x4fv_PACKED *packed_data = malloc(sizeof(glProgramUniformMatrix3x4fv_PACKED)); \
    packed_data->index = glProgramUniformMatrix3x4fv_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.transpose = (GLboolean)_transpose; \
    packed_data->args.value = (GLfloat *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramUniformMatrix3x4fv(packed, ret_v) do { \
    PACKED_glProgramUniformMatrix3x4fv *unpacked = (PACKED_glProgramUniformMatrix3x4fv *)packed; \
    ARGS_glProgramUniformMatrix3x4fv *args = (ARGS_glProgramUniformMatrix3x4fv *)&unpacked->args; \
    glProgramUniformMatrix3x4fv(args->program, args->location, args->count, args->transpose, args->value);; \
} while(0)
void glProgramUniformMatrix3x4fv(glProgramUniformMatrix3x4fv_ARG_EXPAND);
typedef void (*glProgramUniformMatrix3x4fv_PTR)(glProgramUniformMatrix3x4fv_ARG_EXPAND);
#define glProgramUniformMatrix3x4fvEXT_INDEX 1737
#define glProgramUniformMatrix3x4fvEXT_RETURN void
#define glProgramUniformMatrix3x4fvEXT_ARG_NAMES program, location, count, transpose, value
#define glProgramUniformMatrix3x4fvEXT_ARG_EXPAND GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value
#define glProgramUniformMatrix3x4fvEXT_PACKED PACKED_glProgramUniformMatrix3x4fvEXT
#define glProgramUniformMatrix3x4fvEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramUniformMatrix3x4fvEXT_NOT_VOID_WRAP(...) {}
#define pack_glProgramUniformMatrix3x4fvEXT(_program, _location, _count, _transpose, _value) ({ \
    glProgramUniformMatrix3x4fvEXT_PACKED *packed_data = malloc(sizeof(glProgramUniformMatrix3x4fvEXT_PACKED)); \
    packed_data->index = glProgramUniformMatrix3x4fvEXT_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.transpose = (GLboolean)_transpose; \
    packed_data->args.value = (GLfloat *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramUniformMatrix3x4fvEXT(packed, ret_v) do { \
    PACKED_glProgramUniformMatrix3x4fvEXT *unpacked = (PACKED_glProgramUniformMatrix3x4fvEXT *)packed; \
    ARGS_glProgramUniformMatrix3x4fvEXT *args = (ARGS_glProgramUniformMatrix3x4fvEXT *)&unpacked->args; \
    glProgramUniformMatrix3x4fvEXT(args->program, args->location, args->count, args->transpose, args->value);; \
} while(0)
void glProgramUniformMatrix3x4fvEXT(glProgramUniformMatrix3x4fvEXT_ARG_EXPAND);
typedef void (*glProgramUniformMatrix3x4fvEXT_PTR)(glProgramUniformMatrix3x4fvEXT_ARG_EXPAND);
#define glProgramUniformMatrix4dv_INDEX 1738
#define glProgramUniformMatrix4dv_RETURN void
#define glProgramUniformMatrix4dv_ARG_NAMES program, location, count, transpose, value
#define glProgramUniformMatrix4dv_ARG_EXPAND GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value
#define glProgramUniformMatrix4dv_PACKED PACKED_glProgramUniformMatrix4dv
#define glProgramUniformMatrix4dv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramUniformMatrix4dv_NOT_VOID_WRAP(...) {}
#define pack_glProgramUniformMatrix4dv(_program, _location, _count, _transpose, _value) ({ \
    glProgramUniformMatrix4dv_PACKED *packed_data = malloc(sizeof(glProgramUniformMatrix4dv_PACKED)); \
    packed_data->index = glProgramUniformMatrix4dv_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.transpose = (GLboolean)_transpose; \
    packed_data->args.value = (GLdouble *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramUniformMatrix4dv(packed, ret_v) do { \
    PACKED_glProgramUniformMatrix4dv *unpacked = (PACKED_glProgramUniformMatrix4dv *)packed; \
    ARGS_glProgramUniformMatrix4dv *args = (ARGS_glProgramUniformMatrix4dv *)&unpacked->args; \
    glProgramUniformMatrix4dv(args->program, args->location, args->count, args->transpose, args->value);; \
} while(0)
void glProgramUniformMatrix4dv(glProgramUniformMatrix4dv_ARG_EXPAND);
typedef void (*glProgramUniformMatrix4dv_PTR)(glProgramUniformMatrix4dv_ARG_EXPAND);
#define glProgramUniformMatrix4dvEXT_INDEX 1739
#define glProgramUniformMatrix4dvEXT_RETURN void
#define glProgramUniformMatrix4dvEXT_ARG_NAMES program, location, count, transpose, value
#define glProgramUniformMatrix4dvEXT_ARG_EXPAND GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value
#define glProgramUniformMatrix4dvEXT_PACKED PACKED_glProgramUniformMatrix4dvEXT
#define glProgramUniformMatrix4dvEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramUniformMatrix4dvEXT_NOT_VOID_WRAP(...) {}
#define pack_glProgramUniformMatrix4dvEXT(_program, _location, _count, _transpose, _value) ({ \
    glProgramUniformMatrix4dvEXT_PACKED *packed_data = malloc(sizeof(glProgramUniformMatrix4dvEXT_PACKED)); \
    packed_data->index = glProgramUniformMatrix4dvEXT_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.transpose = (GLboolean)_transpose; \
    packed_data->args.value = (GLdouble *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramUniformMatrix4dvEXT(packed, ret_v) do { \
    PACKED_glProgramUniformMatrix4dvEXT *unpacked = (PACKED_glProgramUniformMatrix4dvEXT *)packed; \
    ARGS_glProgramUniformMatrix4dvEXT *args = (ARGS_glProgramUniformMatrix4dvEXT *)&unpacked->args; \
    glProgramUniformMatrix4dvEXT(args->program, args->location, args->count, args->transpose, args->value);; \
} while(0)
void glProgramUniformMatrix4dvEXT(glProgramUniformMatrix4dvEXT_ARG_EXPAND);
typedef void (*glProgramUniformMatrix4dvEXT_PTR)(glProgramUniformMatrix4dvEXT_ARG_EXPAND);
#define glProgramUniformMatrix4fv_INDEX 1740
#define glProgramUniformMatrix4fv_RETURN void
#define glProgramUniformMatrix4fv_ARG_NAMES program, location, count, transpose, value
#define glProgramUniformMatrix4fv_ARG_EXPAND GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value
#define glProgramUniformMatrix4fv_PACKED PACKED_glProgramUniformMatrix4fv
#define glProgramUniformMatrix4fv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramUniformMatrix4fv_NOT_VOID_WRAP(...) {}
#define pack_glProgramUniformMatrix4fv(_program, _location, _count, _transpose, _value) ({ \
    glProgramUniformMatrix4fv_PACKED *packed_data = malloc(sizeof(glProgramUniformMatrix4fv_PACKED)); \
    packed_data->index = glProgramUniformMatrix4fv_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.transpose = (GLboolean)_transpose; \
    packed_data->args.value = (GLfloat *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramUniformMatrix4fv(packed, ret_v) do { \
    PACKED_glProgramUniformMatrix4fv *unpacked = (PACKED_glProgramUniformMatrix4fv *)packed; \
    ARGS_glProgramUniformMatrix4fv *args = (ARGS_glProgramUniformMatrix4fv *)&unpacked->args; \
    glProgramUniformMatrix4fv(args->program, args->location, args->count, args->transpose, args->value);; \
} while(0)
void glProgramUniformMatrix4fv(glProgramUniformMatrix4fv_ARG_EXPAND);
typedef void (*glProgramUniformMatrix4fv_PTR)(glProgramUniformMatrix4fv_ARG_EXPAND);
#define glProgramUniformMatrix4fvEXT_INDEX 1741
#define glProgramUniformMatrix4fvEXT_RETURN void
#define glProgramUniformMatrix4fvEXT_ARG_NAMES program, location, count, transpose, value
#define glProgramUniformMatrix4fvEXT_ARG_EXPAND GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value
#define glProgramUniformMatrix4fvEXT_PACKED PACKED_glProgramUniformMatrix4fvEXT
#define glProgramUniformMatrix4fvEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramUniformMatrix4fvEXT_NOT_VOID_WRAP(...) {}
#define pack_glProgramUniformMatrix4fvEXT(_program, _location, _count, _transpose, _value) ({ \
    glProgramUniformMatrix4fvEXT_PACKED *packed_data = malloc(sizeof(glProgramUniformMatrix4fvEXT_PACKED)); \
    packed_data->index = glProgramUniformMatrix4fvEXT_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.transpose = (GLboolean)_transpose; \
    packed_data->args.value = (GLfloat *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramUniformMatrix4fvEXT(packed, ret_v) do { \
    PACKED_glProgramUniformMatrix4fvEXT *unpacked = (PACKED_glProgramUniformMatrix4fvEXT *)packed; \
    ARGS_glProgramUniformMatrix4fvEXT *args = (ARGS_glProgramUniformMatrix4fvEXT *)&unpacked->args; \
    glProgramUniformMatrix4fvEXT(args->program, args->location, args->count, args->transpose, args->value);; \
} while(0)
void glProgramUniformMatrix4fvEXT(glProgramUniformMatrix4fvEXT_ARG_EXPAND);
typedef void (*glProgramUniformMatrix4fvEXT_PTR)(glProgramUniformMatrix4fvEXT_ARG_EXPAND);
#define glProgramUniformMatrix4x2dv_INDEX 1742
#define glProgramUniformMatrix4x2dv_RETURN void
#define glProgramUniformMatrix4x2dv_ARG_NAMES program, location, count, transpose, value
#define glProgramUniformMatrix4x2dv_ARG_EXPAND GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value
#define glProgramUniformMatrix4x2dv_PACKED PACKED_glProgramUniformMatrix4x2dv
#define glProgramUniformMatrix4x2dv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramUniformMatrix4x2dv_NOT_VOID_WRAP(...) {}
#define pack_glProgramUniformMatrix4x2dv(_program, _location, _count, _transpose, _value) ({ \
    glProgramUniformMatrix4x2dv_PACKED *packed_data = malloc(sizeof(glProgramUniformMatrix4x2dv_PACKED)); \
    packed_data->index = glProgramUniformMatrix4x2dv_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.transpose = (GLboolean)_transpose; \
    packed_data->args.value = (GLdouble *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramUniformMatrix4x2dv(packed, ret_v) do { \
    PACKED_glProgramUniformMatrix4x2dv *unpacked = (PACKED_glProgramUniformMatrix4x2dv *)packed; \
    ARGS_glProgramUniformMatrix4x2dv *args = (ARGS_glProgramUniformMatrix4x2dv *)&unpacked->args; \
    glProgramUniformMatrix4x2dv(args->program, args->location, args->count, args->transpose, args->value);; \
} while(0)
void glProgramUniformMatrix4x2dv(glProgramUniformMatrix4x2dv_ARG_EXPAND);
typedef void (*glProgramUniformMatrix4x2dv_PTR)(glProgramUniformMatrix4x2dv_ARG_EXPAND);
#define glProgramUniformMatrix4x2dvEXT_INDEX 1743
#define glProgramUniformMatrix4x2dvEXT_RETURN void
#define glProgramUniformMatrix4x2dvEXT_ARG_NAMES program, location, count, transpose, value
#define glProgramUniformMatrix4x2dvEXT_ARG_EXPAND GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value
#define glProgramUniformMatrix4x2dvEXT_PACKED PACKED_glProgramUniformMatrix4x2dvEXT
#define glProgramUniformMatrix4x2dvEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramUniformMatrix4x2dvEXT_NOT_VOID_WRAP(...) {}
#define pack_glProgramUniformMatrix4x2dvEXT(_program, _location, _count, _transpose, _value) ({ \
    glProgramUniformMatrix4x2dvEXT_PACKED *packed_data = malloc(sizeof(glProgramUniformMatrix4x2dvEXT_PACKED)); \
    packed_data->index = glProgramUniformMatrix4x2dvEXT_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.transpose = (GLboolean)_transpose; \
    packed_data->args.value = (GLdouble *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramUniformMatrix4x2dvEXT(packed, ret_v) do { \
    PACKED_glProgramUniformMatrix4x2dvEXT *unpacked = (PACKED_glProgramUniformMatrix4x2dvEXT *)packed; \
    ARGS_glProgramUniformMatrix4x2dvEXT *args = (ARGS_glProgramUniformMatrix4x2dvEXT *)&unpacked->args; \
    glProgramUniformMatrix4x2dvEXT(args->program, args->location, args->count, args->transpose, args->value);; \
} while(0)
void glProgramUniformMatrix4x2dvEXT(glProgramUniformMatrix4x2dvEXT_ARG_EXPAND);
typedef void (*glProgramUniformMatrix4x2dvEXT_PTR)(glProgramUniformMatrix4x2dvEXT_ARG_EXPAND);
#define glProgramUniformMatrix4x2fv_INDEX 1744
#define glProgramUniformMatrix4x2fv_RETURN void
#define glProgramUniformMatrix4x2fv_ARG_NAMES program, location, count, transpose, value
#define glProgramUniformMatrix4x2fv_ARG_EXPAND GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value
#define glProgramUniformMatrix4x2fv_PACKED PACKED_glProgramUniformMatrix4x2fv
#define glProgramUniformMatrix4x2fv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramUniformMatrix4x2fv_NOT_VOID_WRAP(...) {}
#define pack_glProgramUniformMatrix4x2fv(_program, _location, _count, _transpose, _value) ({ \
    glProgramUniformMatrix4x2fv_PACKED *packed_data = malloc(sizeof(glProgramUniformMatrix4x2fv_PACKED)); \
    packed_data->index = glProgramUniformMatrix4x2fv_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.transpose = (GLboolean)_transpose; \
    packed_data->args.value = (GLfloat *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramUniformMatrix4x2fv(packed, ret_v) do { \
    PACKED_glProgramUniformMatrix4x2fv *unpacked = (PACKED_glProgramUniformMatrix4x2fv *)packed; \
    ARGS_glProgramUniformMatrix4x2fv *args = (ARGS_glProgramUniformMatrix4x2fv *)&unpacked->args; \
    glProgramUniformMatrix4x2fv(args->program, args->location, args->count, args->transpose, args->value);; \
} while(0)
void glProgramUniformMatrix4x2fv(glProgramUniformMatrix4x2fv_ARG_EXPAND);
typedef void (*glProgramUniformMatrix4x2fv_PTR)(glProgramUniformMatrix4x2fv_ARG_EXPAND);
#define glProgramUniformMatrix4x2fvEXT_INDEX 1745
#define glProgramUniformMatrix4x2fvEXT_RETURN void
#define glProgramUniformMatrix4x2fvEXT_ARG_NAMES program, location, count, transpose, value
#define glProgramUniformMatrix4x2fvEXT_ARG_EXPAND GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value
#define glProgramUniformMatrix4x2fvEXT_PACKED PACKED_glProgramUniformMatrix4x2fvEXT
#define glProgramUniformMatrix4x2fvEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramUniformMatrix4x2fvEXT_NOT_VOID_WRAP(...) {}
#define pack_glProgramUniformMatrix4x2fvEXT(_program, _location, _count, _transpose, _value) ({ \
    glProgramUniformMatrix4x2fvEXT_PACKED *packed_data = malloc(sizeof(glProgramUniformMatrix4x2fvEXT_PACKED)); \
    packed_data->index = glProgramUniformMatrix4x2fvEXT_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.transpose = (GLboolean)_transpose; \
    packed_data->args.value = (GLfloat *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramUniformMatrix4x2fvEXT(packed, ret_v) do { \
    PACKED_glProgramUniformMatrix4x2fvEXT *unpacked = (PACKED_glProgramUniformMatrix4x2fvEXT *)packed; \
    ARGS_glProgramUniformMatrix4x2fvEXT *args = (ARGS_glProgramUniformMatrix4x2fvEXT *)&unpacked->args; \
    glProgramUniformMatrix4x2fvEXT(args->program, args->location, args->count, args->transpose, args->value);; \
} while(0)
void glProgramUniformMatrix4x2fvEXT(glProgramUniformMatrix4x2fvEXT_ARG_EXPAND);
typedef void (*glProgramUniformMatrix4x2fvEXT_PTR)(glProgramUniformMatrix4x2fvEXT_ARG_EXPAND);
#define glProgramUniformMatrix4x3dv_INDEX 1746
#define glProgramUniformMatrix4x3dv_RETURN void
#define glProgramUniformMatrix4x3dv_ARG_NAMES program, location, count, transpose, value
#define glProgramUniformMatrix4x3dv_ARG_EXPAND GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value
#define glProgramUniformMatrix4x3dv_PACKED PACKED_glProgramUniformMatrix4x3dv
#define glProgramUniformMatrix4x3dv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramUniformMatrix4x3dv_NOT_VOID_WRAP(...) {}
#define pack_glProgramUniformMatrix4x3dv(_program, _location, _count, _transpose, _value) ({ \
    glProgramUniformMatrix4x3dv_PACKED *packed_data = malloc(sizeof(glProgramUniformMatrix4x3dv_PACKED)); \
    packed_data->index = glProgramUniformMatrix4x3dv_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.transpose = (GLboolean)_transpose; \
    packed_data->args.value = (GLdouble *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramUniformMatrix4x3dv(packed, ret_v) do { \
    PACKED_glProgramUniformMatrix4x3dv *unpacked = (PACKED_glProgramUniformMatrix4x3dv *)packed; \
    ARGS_glProgramUniformMatrix4x3dv *args = (ARGS_glProgramUniformMatrix4x3dv *)&unpacked->args; \
    glProgramUniformMatrix4x3dv(args->program, args->location, args->count, args->transpose, args->value);; \
} while(0)
void glProgramUniformMatrix4x3dv(glProgramUniformMatrix4x3dv_ARG_EXPAND);
typedef void (*glProgramUniformMatrix4x3dv_PTR)(glProgramUniformMatrix4x3dv_ARG_EXPAND);
#define glProgramUniformMatrix4x3dvEXT_INDEX 1747
#define glProgramUniformMatrix4x3dvEXT_RETURN void
#define glProgramUniformMatrix4x3dvEXT_ARG_NAMES program, location, count, transpose, value
#define glProgramUniformMatrix4x3dvEXT_ARG_EXPAND GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble * value
#define glProgramUniformMatrix4x3dvEXT_PACKED PACKED_glProgramUniformMatrix4x3dvEXT
#define glProgramUniformMatrix4x3dvEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramUniformMatrix4x3dvEXT_NOT_VOID_WRAP(...) {}
#define pack_glProgramUniformMatrix4x3dvEXT(_program, _location, _count, _transpose, _value) ({ \
    glProgramUniformMatrix4x3dvEXT_PACKED *packed_data = malloc(sizeof(glProgramUniformMatrix4x3dvEXT_PACKED)); \
    packed_data->index = glProgramUniformMatrix4x3dvEXT_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.transpose = (GLboolean)_transpose; \
    packed_data->args.value = (GLdouble *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramUniformMatrix4x3dvEXT(packed, ret_v) do { \
    PACKED_glProgramUniformMatrix4x3dvEXT *unpacked = (PACKED_glProgramUniformMatrix4x3dvEXT *)packed; \
    ARGS_glProgramUniformMatrix4x3dvEXT *args = (ARGS_glProgramUniformMatrix4x3dvEXT *)&unpacked->args; \
    glProgramUniformMatrix4x3dvEXT(args->program, args->location, args->count, args->transpose, args->value);; \
} while(0)
void glProgramUniformMatrix4x3dvEXT(glProgramUniformMatrix4x3dvEXT_ARG_EXPAND);
typedef void (*glProgramUniformMatrix4x3dvEXT_PTR)(glProgramUniformMatrix4x3dvEXT_ARG_EXPAND);
#define glProgramUniformMatrix4x3fv_INDEX 1748
#define glProgramUniformMatrix4x3fv_RETURN void
#define glProgramUniformMatrix4x3fv_ARG_NAMES program, location, count, transpose, value
#define glProgramUniformMatrix4x3fv_ARG_EXPAND GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value
#define glProgramUniformMatrix4x3fv_PACKED PACKED_glProgramUniformMatrix4x3fv
#define glProgramUniformMatrix4x3fv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramUniformMatrix4x3fv_NOT_VOID_WRAP(...) {}
#define pack_glProgramUniformMatrix4x3fv(_program, _location, _count, _transpose, _value) ({ \
    glProgramUniformMatrix4x3fv_PACKED *packed_data = malloc(sizeof(glProgramUniformMatrix4x3fv_PACKED)); \
    packed_data->index = glProgramUniformMatrix4x3fv_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.transpose = (GLboolean)_transpose; \
    packed_data->args.value = (GLfloat *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramUniformMatrix4x3fv(packed, ret_v) do { \
    PACKED_glProgramUniformMatrix4x3fv *unpacked = (PACKED_glProgramUniformMatrix4x3fv *)packed; \
    ARGS_glProgramUniformMatrix4x3fv *args = (ARGS_glProgramUniformMatrix4x3fv *)&unpacked->args; \
    glProgramUniformMatrix4x3fv(args->program, args->location, args->count, args->transpose, args->value);; \
} while(0)
void glProgramUniformMatrix4x3fv(glProgramUniformMatrix4x3fv_ARG_EXPAND);
typedef void (*glProgramUniformMatrix4x3fv_PTR)(glProgramUniformMatrix4x3fv_ARG_EXPAND);
#define glProgramUniformMatrix4x3fvEXT_INDEX 1749
#define glProgramUniformMatrix4x3fvEXT_RETURN void
#define glProgramUniformMatrix4x3fvEXT_ARG_NAMES program, location, count, transpose, value
#define glProgramUniformMatrix4x3fvEXT_ARG_EXPAND GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat * value
#define glProgramUniformMatrix4x3fvEXT_PACKED PACKED_glProgramUniformMatrix4x3fvEXT
#define glProgramUniformMatrix4x3fvEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramUniformMatrix4x3fvEXT_NOT_VOID_WRAP(...) {}
#define pack_glProgramUniformMatrix4x3fvEXT(_program, _location, _count, _transpose, _value) ({ \
    glProgramUniformMatrix4x3fvEXT_PACKED *packed_data = malloc(sizeof(glProgramUniformMatrix4x3fvEXT_PACKED)); \
    packed_data->index = glProgramUniformMatrix4x3fvEXT_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.transpose = (GLboolean)_transpose; \
    packed_data->args.value = (GLfloat *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramUniformMatrix4x3fvEXT(packed, ret_v) do { \
    PACKED_glProgramUniformMatrix4x3fvEXT *unpacked = (PACKED_glProgramUniformMatrix4x3fvEXT *)packed; \
    ARGS_glProgramUniformMatrix4x3fvEXT *args = (ARGS_glProgramUniformMatrix4x3fvEXT *)&unpacked->args; \
    glProgramUniformMatrix4x3fvEXT(args->program, args->location, args->count, args->transpose, args->value);; \
} while(0)
void glProgramUniformMatrix4x3fvEXT(glProgramUniformMatrix4x3fvEXT_ARG_EXPAND);
typedef void (*glProgramUniformMatrix4x3fvEXT_PTR)(glProgramUniformMatrix4x3fvEXT_ARG_EXPAND);
#define glProgramUniformui64NV_INDEX 1750
#define glProgramUniformui64NV_RETURN void
#define glProgramUniformui64NV_ARG_NAMES program, location, value
#define glProgramUniformui64NV_ARG_EXPAND GLuint program, GLint location, GLuint64EXT value
#define glProgramUniformui64NV_PACKED PACKED_glProgramUniformui64NV
#define glProgramUniformui64NV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramUniformui64NV_NOT_VOID_WRAP(...) {}
#define pack_glProgramUniformui64NV(_program, _location, _value) ({ \
    glProgramUniformui64NV_PACKED *packed_data = malloc(sizeof(glProgramUniformui64NV_PACKED)); \
    packed_data->index = glProgramUniformui64NV_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.value = (GLuint64EXT)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramUniformui64NV(packed, ret_v) do { \
    PACKED_glProgramUniformui64NV *unpacked = (PACKED_glProgramUniformui64NV *)packed; \
    ARGS_glProgramUniformui64NV *args = (ARGS_glProgramUniformui64NV *)&unpacked->args; \
    glProgramUniformui64NV(args->program, args->location, args->value);; \
} while(0)
void glProgramUniformui64NV(glProgramUniformui64NV_ARG_EXPAND);
typedef void (*glProgramUniformui64NV_PTR)(glProgramUniformui64NV_ARG_EXPAND);
#define glProgramUniformui64vNV_INDEX 1751
#define glProgramUniformui64vNV_RETURN void
#define glProgramUniformui64vNV_ARG_NAMES program, location, count, value
#define glProgramUniformui64vNV_ARG_EXPAND GLuint program, GLint location, GLsizei count, const GLuint64EXT * value
#define glProgramUniformui64vNV_PACKED PACKED_glProgramUniformui64vNV
#define glProgramUniformui64vNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramUniformui64vNV_NOT_VOID_WRAP(...) {}
#define pack_glProgramUniformui64vNV(_program, _location, _count, _value) ({ \
    glProgramUniformui64vNV_PACKED *packed_data = malloc(sizeof(glProgramUniformui64vNV_PACKED)); \
    packed_data->index = glProgramUniformui64vNV_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.value = (GLuint64EXT *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramUniformui64vNV(packed, ret_v) do { \
    PACKED_glProgramUniformui64vNV *unpacked = (PACKED_glProgramUniformui64vNV *)packed; \
    ARGS_glProgramUniformui64vNV *args = (ARGS_glProgramUniformui64vNV *)&unpacked->args; \
    glProgramUniformui64vNV(args->program, args->location, args->count, args->value);; \
} while(0)
void glProgramUniformui64vNV(glProgramUniformui64vNV_ARG_EXPAND);
typedef void (*glProgramUniformui64vNV_PTR)(glProgramUniformui64vNV_ARG_EXPAND);
#define glProgramVertexLimitNV_INDEX 1752
#define glProgramVertexLimitNV_RETURN void
#define glProgramVertexLimitNV_ARG_NAMES target, limit
#define glProgramVertexLimitNV_ARG_EXPAND GLenum target, GLint limit
#define glProgramVertexLimitNV_PACKED PACKED_glProgramVertexLimitNV
#define glProgramVertexLimitNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProgramVertexLimitNV_NOT_VOID_WRAP(...) {}
#define pack_glProgramVertexLimitNV(_target, _limit) ({ \
    glProgramVertexLimitNV_PACKED *packed_data = malloc(sizeof(glProgramVertexLimitNV_PACKED)); \
    packed_data->index = glProgramVertexLimitNV_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.limit = (GLint)_limit; \
    (packed_call_t *)packed_data; \
})
#define call_glProgramVertexLimitNV(packed, ret_v) do { \
    PACKED_glProgramVertexLimitNV *unpacked = (PACKED_glProgramVertexLimitNV *)packed; \
    ARGS_glProgramVertexLimitNV *args = (ARGS_glProgramVertexLimitNV *)&unpacked->args; \
    glProgramVertexLimitNV(args->target, args->limit);; \
} while(0)
void glProgramVertexLimitNV(glProgramVertexLimitNV_ARG_EXPAND);
typedef void (*glProgramVertexLimitNV_PTR)(glProgramVertexLimitNV_ARG_EXPAND);
#define glProvokingVertex_INDEX 1753
#define glProvokingVertex_RETURN void
#define glProvokingVertex_ARG_NAMES mode
#define glProvokingVertex_ARG_EXPAND GLenum mode
#define glProvokingVertex_PACKED PACKED_glProvokingVertex
#define glProvokingVertex_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProvokingVertex_NOT_VOID_WRAP(...) {}
#define pack_glProvokingVertex(_mode) ({ \
    glProvokingVertex_PACKED *packed_data = malloc(sizeof(glProvokingVertex_PACKED)); \
    packed_data->index = glProvokingVertex_INDEX; \
    packed_data->args.mode = (GLenum)_mode; \
    (packed_call_t *)packed_data; \
})
#define call_glProvokingVertex(packed, ret_v) do { \
    PACKED_glProvokingVertex *unpacked = (PACKED_glProvokingVertex *)packed; \
    ARGS_glProvokingVertex *args = (ARGS_glProvokingVertex *)&unpacked->args; \
    glProvokingVertex(args->mode);; \
} while(0)
void glProvokingVertex(glProvokingVertex_ARG_EXPAND);
typedef void (*glProvokingVertex_PTR)(glProvokingVertex_ARG_EXPAND);
#define glProvokingVertexEXT_INDEX 1754
#define glProvokingVertexEXT_RETURN void
#define glProvokingVertexEXT_ARG_NAMES mode
#define glProvokingVertexEXT_ARG_EXPAND GLenum mode
#define glProvokingVertexEXT_PACKED PACKED_glProvokingVertexEXT
#define glProvokingVertexEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glProvokingVertexEXT_NOT_VOID_WRAP(...) {}
#define pack_glProvokingVertexEXT(_mode) ({ \
    glProvokingVertexEXT_PACKED *packed_data = malloc(sizeof(glProvokingVertexEXT_PACKED)); \
    packed_data->index = glProvokingVertexEXT_INDEX; \
    packed_data->args.mode = (GLenum)_mode; \
    (packed_call_t *)packed_data; \
})
#define call_glProvokingVertexEXT(packed, ret_v) do { \
    PACKED_glProvokingVertexEXT *unpacked = (PACKED_glProvokingVertexEXT *)packed; \
    ARGS_glProvokingVertexEXT *args = (ARGS_glProvokingVertexEXT *)&unpacked->args; \
    glProvokingVertexEXT(args->mode);; \
} while(0)
void glProvokingVertexEXT(glProvokingVertexEXT_ARG_EXPAND);
typedef void (*glProvokingVertexEXT_PTR)(glProvokingVertexEXT_ARG_EXPAND);
#define glPushAttrib_INDEX 1755
#define glPushAttrib_RETURN void
#define glPushAttrib_ARG_NAMES mask
#define glPushAttrib_ARG_EXPAND GLbitfield mask
#define glPushAttrib_PACKED PACKED_glPushAttrib
#define glPushAttrib_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glPushAttrib_NOT_VOID_WRAP(...) {}
#define pack_glPushAttrib(_mask) ({ \
    glPushAttrib_PACKED *packed_data = malloc(sizeof(glPushAttrib_PACKED)); \
    packed_data->index = glPushAttrib_INDEX; \
    packed_data->args.mask = (GLbitfield)_mask; \
    (packed_call_t *)packed_data; \
})
#define call_glPushAttrib(packed, ret_v) do { \
    PACKED_glPushAttrib *unpacked = (PACKED_glPushAttrib *)packed; \
    ARGS_glPushAttrib *args = (ARGS_glPushAttrib *)&unpacked->args; \
    glPushAttrib(args->mask);; \
} while(0)
void glPushAttrib(glPushAttrib_ARG_EXPAND);
typedef void (*glPushAttrib_PTR)(glPushAttrib_ARG_EXPAND);
#define glPushClientAttrib_INDEX 1756
#define glPushClientAttrib_RETURN void
#define glPushClientAttrib_ARG_NAMES mask
#define glPushClientAttrib_ARG_EXPAND GLbitfield mask
#define glPushClientAttrib_PACKED PACKED_glPushClientAttrib
#define glPushClientAttrib_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glPushClientAttrib_NOT_VOID_WRAP(...) {}
#define pack_glPushClientAttrib(_mask) ({ \
    glPushClientAttrib_PACKED *packed_data = malloc(sizeof(glPushClientAttrib_PACKED)); \
    packed_data->index = glPushClientAttrib_INDEX; \
    packed_data->args.mask = (GLbitfield)_mask; \
    (packed_call_t *)packed_data; \
})
#define call_glPushClientAttrib(packed, ret_v) do { \
    PACKED_glPushClientAttrib *unpacked = (PACKED_glPushClientAttrib *)packed; \
    ARGS_glPushClientAttrib *args = (ARGS_glPushClientAttrib *)&unpacked->args; \
    glPushClientAttrib(args->mask);; \
} while(0)
void glPushClientAttrib(glPushClientAttrib_ARG_EXPAND);
typedef void (*glPushClientAttrib_PTR)(glPushClientAttrib_ARG_EXPAND);
#define glPushClientAttribDefaultEXT_INDEX 1757
#define glPushClientAttribDefaultEXT_RETURN void
#define glPushClientAttribDefaultEXT_ARG_NAMES mask
#define glPushClientAttribDefaultEXT_ARG_EXPAND GLbitfield mask
#define glPushClientAttribDefaultEXT_PACKED PACKED_glPushClientAttribDefaultEXT
#define glPushClientAttribDefaultEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glPushClientAttribDefaultEXT_NOT_VOID_WRAP(...) {}
#define pack_glPushClientAttribDefaultEXT(_mask) ({ \
    glPushClientAttribDefaultEXT_PACKED *packed_data = malloc(sizeof(glPushClientAttribDefaultEXT_PACKED)); \
    packed_data->index = glPushClientAttribDefaultEXT_INDEX; \
    packed_data->args.mask = (GLbitfield)_mask; \
    (packed_call_t *)packed_data; \
})
#define call_glPushClientAttribDefaultEXT(packed, ret_v) do { \
    PACKED_glPushClientAttribDefaultEXT *unpacked = (PACKED_glPushClientAttribDefaultEXT *)packed; \
    ARGS_glPushClientAttribDefaultEXT *args = (ARGS_glPushClientAttribDefaultEXT *)&unpacked->args; \
    glPushClientAttribDefaultEXT(args->mask);; \
} while(0)
void glPushClientAttribDefaultEXT(glPushClientAttribDefaultEXT_ARG_EXPAND);
typedef void (*glPushClientAttribDefaultEXT_PTR)(glPushClientAttribDefaultEXT_ARG_EXPAND);
#define glPushDebugGroup_INDEX 1758
#define glPushDebugGroup_RETURN void
#define glPushDebugGroup_ARG_NAMES source, id, length, message
#define glPushDebugGroup_ARG_EXPAND GLenum source, GLuint id, GLsizei length, const GLchar * message
#define glPushDebugGroup_PACKED PACKED_glPushDebugGroup
#define glPushDebugGroup_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glPushDebugGroup_NOT_VOID_WRAP(...) {}
#define pack_glPushDebugGroup(_source, _id, _length, _message) ({ \
    glPushDebugGroup_PACKED *packed_data = malloc(sizeof(glPushDebugGroup_PACKED)); \
    packed_data->index = glPushDebugGroup_INDEX; \
    packed_data->args.source = (GLenum)_source; \
    packed_data->args.id = (GLuint)_id; \
    packed_data->args.length = (GLsizei)_length; \
    packed_data->args.message = (GLchar *)_message; \
    (packed_call_t *)packed_data; \
})
#define call_glPushDebugGroup(packed, ret_v) do { \
    PACKED_glPushDebugGroup *unpacked = (PACKED_glPushDebugGroup *)packed; \
    ARGS_glPushDebugGroup *args = (ARGS_glPushDebugGroup *)&unpacked->args; \
    glPushDebugGroup(args->source, args->id, args->length, args->message);; \
} while(0)
void glPushDebugGroup(glPushDebugGroup_ARG_EXPAND);
typedef void (*glPushDebugGroup_PTR)(glPushDebugGroup_ARG_EXPAND);
#define glPushMatrix_INDEX 1759
#define glPushMatrix_RETURN void
#define glPushMatrix_ARG_NAMES 
#define glPushMatrix_ARG_EXPAND 
#define glPushMatrix_PACKED PACKED_glPushMatrix
#define glPushMatrix_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glPushMatrix_NOT_VOID_WRAP(...) {}
#define pack_glPushMatrix() ({ \
    glPushMatrix_PACKED *packed_data = malloc(sizeof(glPushMatrix_PACKED)); \
    packed_data->index = glPushMatrix_INDEX; \
    (packed_call_t *)packed_data; \
})
#define call_glPushMatrix(packed, ret_v) do { \
    glPushMatrix();; \
} while(0)
void glPushMatrix(glPushMatrix_ARG_EXPAND);
typedef void (*glPushMatrix_PTR)(glPushMatrix_ARG_EXPAND);
#define glPushName_INDEX 1760
#define glPushName_RETURN void
#define glPushName_ARG_NAMES name
#define glPushName_ARG_EXPAND GLuint name
#define glPushName_PACKED PACKED_glPushName
#define glPushName_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glPushName_NOT_VOID_WRAP(...) {}
#define pack_glPushName(_name) ({ \
    glPushName_PACKED *packed_data = malloc(sizeof(glPushName_PACKED)); \
    packed_data->index = glPushName_INDEX; \
    packed_data->args.name = (GLuint)_name; \
    (packed_call_t *)packed_data; \
})
#define call_glPushName(packed, ret_v) do { \
    PACKED_glPushName *unpacked = (PACKED_glPushName *)packed; \
    ARGS_glPushName *args = (ARGS_glPushName *)&unpacked->args; \
    glPushName(args->name);; \
} while(0)
void glPushName(glPushName_ARG_EXPAND);
typedef void (*glPushName_PTR)(glPushName_ARG_EXPAND);
#define glQueryCounter_INDEX 1761
#define glQueryCounter_RETURN void
#define glQueryCounter_ARG_NAMES id, target
#define glQueryCounter_ARG_EXPAND GLuint id, GLenum target
#define glQueryCounter_PACKED PACKED_glQueryCounter
#define glQueryCounter_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glQueryCounter_NOT_VOID_WRAP(...) {}
#define pack_glQueryCounter(_id, _target) ({ \
    glQueryCounter_PACKED *packed_data = malloc(sizeof(glQueryCounter_PACKED)); \
    packed_data->index = glQueryCounter_INDEX; \
    packed_data->args.id = (GLuint)_id; \
    packed_data->args.target = (GLenum)_target; \
    (packed_call_t *)packed_data; \
})
#define call_glQueryCounter(packed, ret_v) do { \
    PACKED_glQueryCounter *unpacked = (PACKED_glQueryCounter *)packed; \
    ARGS_glQueryCounter *args = (ARGS_glQueryCounter *)&unpacked->args; \
    glQueryCounter(args->id, args->target);; \
} while(0)
void glQueryCounter(glQueryCounter_ARG_EXPAND);
typedef void (*glQueryCounter_PTR)(glQueryCounter_ARG_EXPAND);
#define glQueryMatrixxOES_INDEX 1762
#define glQueryMatrixxOES_RETURN GLbitfield
#define glQueryMatrixxOES_ARG_NAMES mantissa, exponent
#define glQueryMatrixxOES_ARG_EXPAND GLfixed * mantissa, GLint * exponent
#define glQueryMatrixxOES_PACKED PACKED_glQueryMatrixxOES
#define glQueryMatrixxOES_VOID_ONLY_WRAP(...) {}
#define glQueryMatrixxOES_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glQueryMatrixxOES(_mantissa, _exponent) ({ \
    glQueryMatrixxOES_PACKED *packed_data = malloc(sizeof(glQueryMatrixxOES_PACKED)); \
    packed_data->index = glQueryMatrixxOES_INDEX; \
    packed_data->args.mantissa = (GLfixed *)_mantissa; \
    packed_data->args.exponent = (GLint *)_exponent; \
    (packed_call_t *)packed_data; \
})
#define call_glQueryMatrixxOES(packed, ret_v) do { \
    PACKED_glQueryMatrixxOES *unpacked = (PACKED_glQueryMatrixxOES *)packed; \
    ARGS_glQueryMatrixxOES *args = (ARGS_glQueryMatrixxOES *)&unpacked->args; \
    GLbitfield *ret = (GLbitfield *)ret_v; \
    if (ret != NULL) { \
        *ret = glQueryMatrixxOES(args->mantissa, args->exponent);; \
    } else { \
        glQueryMatrixxOES(args->mantissa, args->exponent);; \
    } \
} while(0)
GLbitfield glQueryMatrixxOES(glQueryMatrixxOES_ARG_EXPAND);
typedef GLbitfield (*glQueryMatrixxOES_PTR)(glQueryMatrixxOES_ARG_EXPAND);
#define glRasterPos2d_INDEX 1763
#define glRasterPos2d_RETURN void
#define glRasterPos2d_ARG_NAMES x, y
#define glRasterPos2d_ARG_EXPAND GLdouble x, GLdouble y
#define glRasterPos2d_PACKED PACKED_glRasterPos2d
#define glRasterPos2d_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glRasterPos2d_NOT_VOID_WRAP(...) {}
#define pack_glRasterPos2d(_x, _y) ({ \
    glRasterPos2d_PACKED *packed_data = malloc(sizeof(glRasterPos2d_PACKED)); \
    packed_data->index = glRasterPos2d_INDEX; \
    packed_data->args.x = (GLdouble)_x; \
    packed_data->args.y = (GLdouble)_y; \
    (packed_call_t *)packed_data; \
})
#define call_glRasterPos2d(packed, ret_v) do { \
    PACKED_glRasterPos2d *unpacked = (PACKED_glRasterPos2d *)packed; \
    ARGS_glRasterPos2d *args = (ARGS_glRasterPos2d *)&unpacked->args; \
    glRasterPos2d(args->x, args->y);; \
} while(0)
void glRasterPos2d(glRasterPos2d_ARG_EXPAND);
typedef void (*glRasterPos2d_PTR)(glRasterPos2d_ARG_EXPAND);
#define glRasterPos2dv_INDEX 1764
#define glRasterPos2dv_RETURN void
#define glRasterPos2dv_ARG_NAMES v
#define glRasterPos2dv_ARG_EXPAND const GLdouble * v
#define glRasterPos2dv_PACKED PACKED_glRasterPos2dv
#define glRasterPos2dv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glRasterPos2dv_NOT_VOID_WRAP(...) {}
#define pack_glRasterPos2dv(_v) ({ \
    glRasterPos2dv_PACKED *packed_data = malloc(sizeof(glRasterPos2dv_PACKED)); \
    packed_data->index = glRasterPos2dv_INDEX; \
    packed_data->args.v = (GLdouble *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glRasterPos2dv(packed, ret_v) do { \
    PACKED_glRasterPos2dv *unpacked = (PACKED_glRasterPos2dv *)packed; \
    ARGS_glRasterPos2dv *args = (ARGS_glRasterPos2dv *)&unpacked->args; \
    glRasterPos2dv(args->v);; \
} while(0)
void glRasterPos2dv(glRasterPos2dv_ARG_EXPAND);
typedef void (*glRasterPos2dv_PTR)(glRasterPos2dv_ARG_EXPAND);
#define glRasterPos2f_INDEX 1765
#define glRasterPos2f_RETURN void
#define glRasterPos2f_ARG_NAMES x, y
#define glRasterPos2f_ARG_EXPAND GLfloat x, GLfloat y
#define glRasterPos2f_PACKED PACKED_glRasterPos2f
#define glRasterPos2f_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glRasterPos2f_NOT_VOID_WRAP(...) {}
#define pack_glRasterPos2f(_x, _y) ({ \
    glRasterPos2f_PACKED *packed_data = malloc(sizeof(glRasterPos2f_PACKED)); \
    packed_data->index = glRasterPos2f_INDEX; \
    packed_data->args.x = (GLfloat)_x; \
    packed_data->args.y = (GLfloat)_y; \
    (packed_call_t *)packed_data; \
})
#define call_glRasterPos2f(packed, ret_v) do { \
    PACKED_glRasterPos2f *unpacked = (PACKED_glRasterPos2f *)packed; \
    ARGS_glRasterPos2f *args = (ARGS_glRasterPos2f *)&unpacked->args; \
    glRasterPos2f(args->x, args->y);; \
} while(0)
void glRasterPos2f(glRasterPos2f_ARG_EXPAND);
typedef void (*glRasterPos2f_PTR)(glRasterPos2f_ARG_EXPAND);
#define glRasterPos2fv_INDEX 1766
#define glRasterPos2fv_RETURN void
#define glRasterPos2fv_ARG_NAMES v
#define glRasterPos2fv_ARG_EXPAND const GLfloat * v
#define glRasterPos2fv_PACKED PACKED_glRasterPos2fv
#define glRasterPos2fv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glRasterPos2fv_NOT_VOID_WRAP(...) {}
#define pack_glRasterPos2fv(_v) ({ \
    glRasterPos2fv_PACKED *packed_data = malloc(sizeof(glRasterPos2fv_PACKED)); \
    packed_data->index = glRasterPos2fv_INDEX; \
    packed_data->args.v = (GLfloat *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glRasterPos2fv(packed, ret_v) do { \
    PACKED_glRasterPos2fv *unpacked = (PACKED_glRasterPos2fv *)packed; \
    ARGS_glRasterPos2fv *args = (ARGS_glRasterPos2fv *)&unpacked->args; \
    glRasterPos2fv(args->v);; \
} while(0)
void glRasterPos2fv(glRasterPos2fv_ARG_EXPAND);
typedef void (*glRasterPos2fv_PTR)(glRasterPos2fv_ARG_EXPAND);
#define glRasterPos2i_INDEX 1767
#define glRasterPos2i_RETURN void
#define glRasterPos2i_ARG_NAMES x, y
#define glRasterPos2i_ARG_EXPAND GLint x, GLint y
#define glRasterPos2i_PACKED PACKED_glRasterPos2i
#define glRasterPos2i_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glRasterPos2i_NOT_VOID_WRAP(...) {}
#define pack_glRasterPos2i(_x, _y) ({ \
    glRasterPos2i_PACKED *packed_data = malloc(sizeof(glRasterPos2i_PACKED)); \
    packed_data->index = glRasterPos2i_INDEX; \
    packed_data->args.x = (GLint)_x; \
    packed_data->args.y = (GLint)_y; \
    (packed_call_t *)packed_data; \
})
#define call_glRasterPos2i(packed, ret_v) do { \
    PACKED_glRasterPos2i *unpacked = (PACKED_glRasterPos2i *)packed; \
    ARGS_glRasterPos2i *args = (ARGS_glRasterPos2i *)&unpacked->args; \
    glRasterPos2i(args->x, args->y);; \
} while(0)
void glRasterPos2i(glRasterPos2i_ARG_EXPAND);
typedef void (*glRasterPos2i_PTR)(glRasterPos2i_ARG_EXPAND);
#define glRasterPos2iv_INDEX 1768
#define glRasterPos2iv_RETURN void
#define glRasterPos2iv_ARG_NAMES v
#define glRasterPos2iv_ARG_EXPAND const GLint * v
#define glRasterPos2iv_PACKED PACKED_glRasterPos2iv
#define glRasterPos2iv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glRasterPos2iv_NOT_VOID_WRAP(...) {}
#define pack_glRasterPos2iv(_v) ({ \
    glRasterPos2iv_PACKED *packed_data = malloc(sizeof(glRasterPos2iv_PACKED)); \
    packed_data->index = glRasterPos2iv_INDEX; \
    packed_data->args.v = (GLint *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glRasterPos2iv(packed, ret_v) do { \
    PACKED_glRasterPos2iv *unpacked = (PACKED_glRasterPos2iv *)packed; \
    ARGS_glRasterPos2iv *args = (ARGS_glRasterPos2iv *)&unpacked->args; \
    glRasterPos2iv(args->v);; \
} while(0)
void glRasterPos2iv(glRasterPos2iv_ARG_EXPAND);
typedef void (*glRasterPos2iv_PTR)(glRasterPos2iv_ARG_EXPAND);
#define glRasterPos2s_INDEX 1769
#define glRasterPos2s_RETURN void
#define glRasterPos2s_ARG_NAMES x, y
#define glRasterPos2s_ARG_EXPAND GLshort x, GLshort y
#define glRasterPos2s_PACKED PACKED_glRasterPos2s
#define glRasterPos2s_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glRasterPos2s_NOT_VOID_WRAP(...) {}
#define pack_glRasterPos2s(_x, _y) ({ \
    glRasterPos2s_PACKED *packed_data = malloc(sizeof(glRasterPos2s_PACKED)); \
    packed_data->index = glRasterPos2s_INDEX; \
    packed_data->args.x = (GLshort)_x; \
    packed_data->args.y = (GLshort)_y; \
    (packed_call_t *)packed_data; \
})
#define call_glRasterPos2s(packed, ret_v) do { \
    PACKED_glRasterPos2s *unpacked = (PACKED_glRasterPos2s *)packed; \
    ARGS_glRasterPos2s *args = (ARGS_glRasterPos2s *)&unpacked->args; \
    glRasterPos2s(args->x, args->y);; \
} while(0)
void glRasterPos2s(glRasterPos2s_ARG_EXPAND);
typedef void (*glRasterPos2s_PTR)(glRasterPos2s_ARG_EXPAND);
#define glRasterPos2sv_INDEX 1770
#define glRasterPos2sv_RETURN void
#define glRasterPos2sv_ARG_NAMES v
#define glRasterPos2sv_ARG_EXPAND const GLshort * v
#define glRasterPos2sv_PACKED PACKED_glRasterPos2sv
#define glRasterPos2sv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glRasterPos2sv_NOT_VOID_WRAP(...) {}
#define pack_glRasterPos2sv(_v) ({ \
    glRasterPos2sv_PACKED *packed_data = malloc(sizeof(glRasterPos2sv_PACKED)); \
    packed_data->index = glRasterPos2sv_INDEX; \
    packed_data->args.v = (GLshort *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glRasterPos2sv(packed, ret_v) do { \
    PACKED_glRasterPos2sv *unpacked = (PACKED_glRasterPos2sv *)packed; \
    ARGS_glRasterPos2sv *args = (ARGS_glRasterPos2sv *)&unpacked->args; \
    glRasterPos2sv(args->v);; \
} while(0)
void glRasterPos2sv(glRasterPos2sv_ARG_EXPAND);
typedef void (*glRasterPos2sv_PTR)(glRasterPos2sv_ARG_EXPAND);
#define glRasterPos2xOES_INDEX 1771
#define glRasterPos2xOES_RETURN void
#define glRasterPos2xOES_ARG_NAMES x, y
#define glRasterPos2xOES_ARG_EXPAND GLfixed x, GLfixed y
#define glRasterPos2xOES_PACKED PACKED_glRasterPos2xOES
#define glRasterPos2xOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glRasterPos2xOES_NOT_VOID_WRAP(...) {}
#define pack_glRasterPos2xOES(_x, _y) ({ \
    glRasterPos2xOES_PACKED *packed_data = malloc(sizeof(glRasterPos2xOES_PACKED)); \
    packed_data->index = glRasterPos2xOES_INDEX; \
    packed_data->args.x = (GLfixed)_x; \
    packed_data->args.y = (GLfixed)_y; \
    (packed_call_t *)packed_data; \
})
#define call_glRasterPos2xOES(packed, ret_v) do { \
    PACKED_glRasterPos2xOES *unpacked = (PACKED_glRasterPos2xOES *)packed; \
    ARGS_glRasterPos2xOES *args = (ARGS_glRasterPos2xOES *)&unpacked->args; \
    glRasterPos2xOES(args->x, args->y);; \
} while(0)
void glRasterPos2xOES(glRasterPos2xOES_ARG_EXPAND);
typedef void (*glRasterPos2xOES_PTR)(glRasterPos2xOES_ARG_EXPAND);
#define glRasterPos2xvOES_INDEX 1772
#define glRasterPos2xvOES_RETURN void
#define glRasterPos2xvOES_ARG_NAMES coords
#define glRasterPos2xvOES_ARG_EXPAND const GLfixed * coords
#define glRasterPos2xvOES_PACKED PACKED_glRasterPos2xvOES
#define glRasterPos2xvOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glRasterPos2xvOES_NOT_VOID_WRAP(...) {}
#define pack_glRasterPos2xvOES(_coords) ({ \
    glRasterPos2xvOES_PACKED *packed_data = malloc(sizeof(glRasterPos2xvOES_PACKED)); \
    packed_data->index = glRasterPos2xvOES_INDEX; \
    packed_data->args.coords = (GLfixed *)_coords; \
    (packed_call_t *)packed_data; \
})
#define call_glRasterPos2xvOES(packed, ret_v) do { \
    PACKED_glRasterPos2xvOES *unpacked = (PACKED_glRasterPos2xvOES *)packed; \
    ARGS_glRasterPos2xvOES *args = (ARGS_glRasterPos2xvOES *)&unpacked->args; \
    glRasterPos2xvOES(args->coords);; \
} while(0)
void glRasterPos2xvOES(glRasterPos2xvOES_ARG_EXPAND);
typedef void (*glRasterPos2xvOES_PTR)(glRasterPos2xvOES_ARG_EXPAND);
#define glRasterPos3d_INDEX 1773
#define glRasterPos3d_RETURN void
#define glRasterPos3d_ARG_NAMES x, y, z
#define glRasterPos3d_ARG_EXPAND GLdouble x, GLdouble y, GLdouble z
#define glRasterPos3d_PACKED PACKED_glRasterPos3d
#define glRasterPos3d_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glRasterPos3d_NOT_VOID_WRAP(...) {}
#define pack_glRasterPos3d(_x, _y, _z) ({ \
    glRasterPos3d_PACKED *packed_data = malloc(sizeof(glRasterPos3d_PACKED)); \
    packed_data->index = glRasterPos3d_INDEX; \
    packed_data->args.x = (GLdouble)_x; \
    packed_data->args.y = (GLdouble)_y; \
    packed_data->args.z = (GLdouble)_z; \
    (packed_call_t *)packed_data; \
})
#define call_glRasterPos3d(packed, ret_v) do { \
    PACKED_glRasterPos3d *unpacked = (PACKED_glRasterPos3d *)packed; \
    ARGS_glRasterPos3d *args = (ARGS_glRasterPos3d *)&unpacked->args; \
    glRasterPos3d(args->x, args->y, args->z);; \
} while(0)
void glRasterPos3d(glRasterPos3d_ARG_EXPAND);
typedef void (*glRasterPos3d_PTR)(glRasterPos3d_ARG_EXPAND);
#define glRasterPos3dv_INDEX 1774
#define glRasterPos3dv_RETURN void
#define glRasterPos3dv_ARG_NAMES v
#define glRasterPos3dv_ARG_EXPAND const GLdouble * v
#define glRasterPos3dv_PACKED PACKED_glRasterPos3dv
#define glRasterPos3dv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glRasterPos3dv_NOT_VOID_WRAP(...) {}
#define pack_glRasterPos3dv(_v) ({ \
    glRasterPos3dv_PACKED *packed_data = malloc(sizeof(glRasterPos3dv_PACKED)); \
    packed_data->index = glRasterPos3dv_INDEX; \
    packed_data->args.v = (GLdouble *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glRasterPos3dv(packed, ret_v) do { \
    PACKED_glRasterPos3dv *unpacked = (PACKED_glRasterPos3dv *)packed; \
    ARGS_glRasterPos3dv *args = (ARGS_glRasterPos3dv *)&unpacked->args; \
    glRasterPos3dv(args->v);; \
} while(0)
void glRasterPos3dv(glRasterPos3dv_ARG_EXPAND);
typedef void (*glRasterPos3dv_PTR)(glRasterPos3dv_ARG_EXPAND);
#define glRasterPos3f_INDEX 1775
#define glRasterPos3f_RETURN void
#define glRasterPos3f_ARG_NAMES x, y, z
#define glRasterPos3f_ARG_EXPAND GLfloat x, GLfloat y, GLfloat z
#define glRasterPos3f_PACKED PACKED_glRasterPos3f
#define glRasterPos3f_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glRasterPos3f_NOT_VOID_WRAP(...) {}
#define pack_glRasterPos3f(_x, _y, _z) ({ \
    glRasterPos3f_PACKED *packed_data = malloc(sizeof(glRasterPos3f_PACKED)); \
    packed_data->index = glRasterPos3f_INDEX; \
    packed_data->args.x = (GLfloat)_x; \
    packed_data->args.y = (GLfloat)_y; \
    packed_data->args.z = (GLfloat)_z; \
    (packed_call_t *)packed_data; \
})
#define call_glRasterPos3f(packed, ret_v) do { \
    PACKED_glRasterPos3f *unpacked = (PACKED_glRasterPos3f *)packed; \
    ARGS_glRasterPos3f *args = (ARGS_glRasterPos3f *)&unpacked->args; \
    glRasterPos3f(args->x, args->y, args->z);; \
} while(0)
void glRasterPos3f(glRasterPos3f_ARG_EXPAND);
typedef void (*glRasterPos3f_PTR)(glRasterPos3f_ARG_EXPAND);
#define glRasterPos3fv_INDEX 1776
#define glRasterPos3fv_RETURN void
#define glRasterPos3fv_ARG_NAMES v
#define glRasterPos3fv_ARG_EXPAND const GLfloat * v
#define glRasterPos3fv_PACKED PACKED_glRasterPos3fv
#define glRasterPos3fv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glRasterPos3fv_NOT_VOID_WRAP(...) {}
#define pack_glRasterPos3fv(_v) ({ \
    glRasterPos3fv_PACKED *packed_data = malloc(sizeof(glRasterPos3fv_PACKED)); \
    packed_data->index = glRasterPos3fv_INDEX; \
    packed_data->args.v = (GLfloat *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glRasterPos3fv(packed, ret_v) do { \
    PACKED_glRasterPos3fv *unpacked = (PACKED_glRasterPos3fv *)packed; \
    ARGS_glRasterPos3fv *args = (ARGS_glRasterPos3fv *)&unpacked->args; \
    glRasterPos3fv(args->v);; \
} while(0)
void glRasterPos3fv(glRasterPos3fv_ARG_EXPAND);
typedef void (*glRasterPos3fv_PTR)(glRasterPos3fv_ARG_EXPAND);
#define glRasterPos3i_INDEX 1777
#define glRasterPos3i_RETURN void
#define glRasterPos3i_ARG_NAMES x, y, z
#define glRasterPos3i_ARG_EXPAND GLint x, GLint y, GLint z
#define glRasterPos3i_PACKED PACKED_glRasterPos3i
#define glRasterPos3i_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glRasterPos3i_NOT_VOID_WRAP(...) {}
#define pack_glRasterPos3i(_x, _y, _z) ({ \
    glRasterPos3i_PACKED *packed_data = malloc(sizeof(glRasterPos3i_PACKED)); \
    packed_data->index = glRasterPos3i_INDEX; \
    packed_data->args.x = (GLint)_x; \
    packed_data->args.y = (GLint)_y; \
    packed_data->args.z = (GLint)_z; \
    (packed_call_t *)packed_data; \
})
#define call_glRasterPos3i(packed, ret_v) do { \
    PACKED_glRasterPos3i *unpacked = (PACKED_glRasterPos3i *)packed; \
    ARGS_glRasterPos3i *args = (ARGS_glRasterPos3i *)&unpacked->args; \
    glRasterPos3i(args->x, args->y, args->z);; \
} while(0)
void glRasterPos3i(glRasterPos3i_ARG_EXPAND);
typedef void (*glRasterPos3i_PTR)(glRasterPos3i_ARG_EXPAND);
#define glRasterPos3iv_INDEX 1778
#define glRasterPos3iv_RETURN void
#define glRasterPos3iv_ARG_NAMES v
#define glRasterPos3iv_ARG_EXPAND const GLint * v
#define glRasterPos3iv_PACKED PACKED_glRasterPos3iv
#define glRasterPos3iv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glRasterPos3iv_NOT_VOID_WRAP(...) {}
#define pack_glRasterPos3iv(_v) ({ \
    glRasterPos3iv_PACKED *packed_data = malloc(sizeof(glRasterPos3iv_PACKED)); \
    packed_data->index = glRasterPos3iv_INDEX; \
    packed_data->args.v = (GLint *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glRasterPos3iv(packed, ret_v) do { \
    PACKED_glRasterPos3iv *unpacked = (PACKED_glRasterPos3iv *)packed; \
    ARGS_glRasterPos3iv *args = (ARGS_glRasterPos3iv *)&unpacked->args; \
    glRasterPos3iv(args->v);; \
} while(0)
void glRasterPos3iv(glRasterPos3iv_ARG_EXPAND);
typedef void (*glRasterPos3iv_PTR)(glRasterPos3iv_ARG_EXPAND);
#define glRasterPos3s_INDEX 1779
#define glRasterPos3s_RETURN void
#define glRasterPos3s_ARG_NAMES x, y, z
#define glRasterPos3s_ARG_EXPAND GLshort x, GLshort y, GLshort z
#define glRasterPos3s_PACKED PACKED_glRasterPos3s
#define glRasterPos3s_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glRasterPos3s_NOT_VOID_WRAP(...) {}
#define pack_glRasterPos3s(_x, _y, _z) ({ \
    glRasterPos3s_PACKED *packed_data = malloc(sizeof(glRasterPos3s_PACKED)); \
    packed_data->index = glRasterPos3s_INDEX; \
    packed_data->args.x = (GLshort)_x; \
    packed_data->args.y = (GLshort)_y; \
    packed_data->args.z = (GLshort)_z; \
    (packed_call_t *)packed_data; \
})
#define call_glRasterPos3s(packed, ret_v) do { \
    PACKED_glRasterPos3s *unpacked = (PACKED_glRasterPos3s *)packed; \
    ARGS_glRasterPos3s *args = (ARGS_glRasterPos3s *)&unpacked->args; \
    glRasterPos3s(args->x, args->y, args->z);; \
} while(0)
void glRasterPos3s(glRasterPos3s_ARG_EXPAND);
typedef void (*glRasterPos3s_PTR)(glRasterPos3s_ARG_EXPAND);
#define glRasterPos3sv_INDEX 1780
#define glRasterPos3sv_RETURN void
#define glRasterPos3sv_ARG_NAMES v
#define glRasterPos3sv_ARG_EXPAND const GLshort * v
#define glRasterPos3sv_PACKED PACKED_glRasterPos3sv
#define glRasterPos3sv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glRasterPos3sv_NOT_VOID_WRAP(...) {}
#define pack_glRasterPos3sv(_v) ({ \
    glRasterPos3sv_PACKED *packed_data = malloc(sizeof(glRasterPos3sv_PACKED)); \
    packed_data->index = glRasterPos3sv_INDEX; \
    packed_data->args.v = (GLshort *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glRasterPos3sv(packed, ret_v) do { \
    PACKED_glRasterPos3sv *unpacked = (PACKED_glRasterPos3sv *)packed; \
    ARGS_glRasterPos3sv *args = (ARGS_glRasterPos3sv *)&unpacked->args; \
    glRasterPos3sv(args->v);; \
} while(0)
void glRasterPos3sv(glRasterPos3sv_ARG_EXPAND);
typedef void (*glRasterPos3sv_PTR)(glRasterPos3sv_ARG_EXPAND);
#define glRasterPos3xOES_INDEX 1781
#define glRasterPos3xOES_RETURN void
#define glRasterPos3xOES_ARG_NAMES x, y, z
#define glRasterPos3xOES_ARG_EXPAND GLfixed x, GLfixed y, GLfixed z
#define glRasterPos3xOES_PACKED PACKED_glRasterPos3xOES
#define glRasterPos3xOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glRasterPos3xOES_NOT_VOID_WRAP(...) {}
#define pack_glRasterPos3xOES(_x, _y, _z) ({ \
    glRasterPos3xOES_PACKED *packed_data = malloc(sizeof(glRasterPos3xOES_PACKED)); \
    packed_data->index = glRasterPos3xOES_INDEX; \
    packed_data->args.x = (GLfixed)_x; \
    packed_data->args.y = (GLfixed)_y; \
    packed_data->args.z = (GLfixed)_z; \
    (packed_call_t *)packed_data; \
})
#define call_glRasterPos3xOES(packed, ret_v) do { \
    PACKED_glRasterPos3xOES *unpacked = (PACKED_glRasterPos3xOES *)packed; \
    ARGS_glRasterPos3xOES *args = (ARGS_glRasterPos3xOES *)&unpacked->args; \
    glRasterPos3xOES(args->x, args->y, args->z);; \
} while(0)
void glRasterPos3xOES(glRasterPos3xOES_ARG_EXPAND);
typedef void (*glRasterPos3xOES_PTR)(glRasterPos3xOES_ARG_EXPAND);
#define glRasterPos3xvOES_INDEX 1782
#define glRasterPos3xvOES_RETURN void
#define glRasterPos3xvOES_ARG_NAMES coords
#define glRasterPos3xvOES_ARG_EXPAND const GLfixed * coords
#define glRasterPos3xvOES_PACKED PACKED_glRasterPos3xvOES
#define glRasterPos3xvOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glRasterPos3xvOES_NOT_VOID_WRAP(...) {}
#define pack_glRasterPos3xvOES(_coords) ({ \
    glRasterPos3xvOES_PACKED *packed_data = malloc(sizeof(glRasterPos3xvOES_PACKED)); \
    packed_data->index = glRasterPos3xvOES_INDEX; \
    packed_data->args.coords = (GLfixed *)_coords; \
    (packed_call_t *)packed_data; \
})
#define call_glRasterPos3xvOES(packed, ret_v) do { \
    PACKED_glRasterPos3xvOES *unpacked = (PACKED_glRasterPos3xvOES *)packed; \
    ARGS_glRasterPos3xvOES *args = (ARGS_glRasterPos3xvOES *)&unpacked->args; \
    glRasterPos3xvOES(args->coords);; \
} while(0)
void glRasterPos3xvOES(glRasterPos3xvOES_ARG_EXPAND);
typedef void (*glRasterPos3xvOES_PTR)(glRasterPos3xvOES_ARG_EXPAND);
#define glRasterPos4d_INDEX 1783
#define glRasterPos4d_RETURN void
#define glRasterPos4d_ARG_NAMES x, y, z, w
#define glRasterPos4d_ARG_EXPAND GLdouble x, GLdouble y, GLdouble z, GLdouble w
#define glRasterPos4d_PACKED PACKED_glRasterPos4d
#define glRasterPos4d_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glRasterPos4d_NOT_VOID_WRAP(...) {}
#define pack_glRasterPos4d(_x, _y, _z, _w) ({ \
    glRasterPos4d_PACKED *packed_data = malloc(sizeof(glRasterPos4d_PACKED)); \
    packed_data->index = glRasterPos4d_INDEX; \
    packed_data->args.x = (GLdouble)_x; \
    packed_data->args.y = (GLdouble)_y; \
    packed_data->args.z = (GLdouble)_z; \
    packed_data->args.w = (GLdouble)_w; \
    (packed_call_t *)packed_data; \
})
#define call_glRasterPos4d(packed, ret_v) do { \
    PACKED_glRasterPos4d *unpacked = (PACKED_glRasterPos4d *)packed; \
    ARGS_glRasterPos4d *args = (ARGS_glRasterPos4d *)&unpacked->args; \
    glRasterPos4d(args->x, args->y, args->z, args->w);; \
} while(0)
void glRasterPos4d(glRasterPos4d_ARG_EXPAND);
typedef void (*glRasterPos4d_PTR)(glRasterPos4d_ARG_EXPAND);
#define glRasterPos4dv_INDEX 1784
#define glRasterPos4dv_RETURN void
#define glRasterPos4dv_ARG_NAMES v
#define glRasterPos4dv_ARG_EXPAND const GLdouble * v
#define glRasterPos4dv_PACKED PACKED_glRasterPos4dv
#define glRasterPos4dv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glRasterPos4dv_NOT_VOID_WRAP(...) {}
#define pack_glRasterPos4dv(_v) ({ \
    glRasterPos4dv_PACKED *packed_data = malloc(sizeof(glRasterPos4dv_PACKED)); \
    packed_data->index = glRasterPos4dv_INDEX; \
    packed_data->args.v = (GLdouble *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glRasterPos4dv(packed, ret_v) do { \
    PACKED_glRasterPos4dv *unpacked = (PACKED_glRasterPos4dv *)packed; \
    ARGS_glRasterPos4dv *args = (ARGS_glRasterPos4dv *)&unpacked->args; \
    glRasterPos4dv(args->v);; \
} while(0)
void glRasterPos4dv(glRasterPos4dv_ARG_EXPAND);
typedef void (*glRasterPos4dv_PTR)(glRasterPos4dv_ARG_EXPAND);
#define glRasterPos4f_INDEX 1785
#define glRasterPos4f_RETURN void
#define glRasterPos4f_ARG_NAMES x, y, z, w
#define glRasterPos4f_ARG_EXPAND GLfloat x, GLfloat y, GLfloat z, GLfloat w
#define glRasterPos4f_PACKED PACKED_glRasterPos4f
#define glRasterPos4f_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glRasterPos4f_NOT_VOID_WRAP(...) {}
#define pack_glRasterPos4f(_x, _y, _z, _w) ({ \
    glRasterPos4f_PACKED *packed_data = malloc(sizeof(glRasterPos4f_PACKED)); \
    packed_data->index = glRasterPos4f_INDEX; \
    packed_data->args.x = (GLfloat)_x; \
    packed_data->args.y = (GLfloat)_y; \
    packed_data->args.z = (GLfloat)_z; \
    packed_data->args.w = (GLfloat)_w; \
    (packed_call_t *)packed_data; \
})
#define call_glRasterPos4f(packed, ret_v) do { \
    PACKED_glRasterPos4f *unpacked = (PACKED_glRasterPos4f *)packed; \
    ARGS_glRasterPos4f *args = (ARGS_glRasterPos4f *)&unpacked->args; \
    glRasterPos4f(args->x, args->y, args->z, args->w);; \
} while(0)
void glRasterPos4f(glRasterPos4f_ARG_EXPAND);
typedef void (*glRasterPos4f_PTR)(glRasterPos4f_ARG_EXPAND);
#define glRasterPos4fv_INDEX 1786
#define glRasterPos4fv_RETURN void
#define glRasterPos4fv_ARG_NAMES v
#define glRasterPos4fv_ARG_EXPAND const GLfloat * v
#define glRasterPos4fv_PACKED PACKED_glRasterPos4fv
#define glRasterPos4fv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glRasterPos4fv_NOT_VOID_WRAP(...) {}
#define pack_glRasterPos4fv(_v) ({ \
    glRasterPos4fv_PACKED *packed_data = malloc(sizeof(glRasterPos4fv_PACKED)); \
    packed_data->index = glRasterPos4fv_INDEX; \
    packed_data->args.v = (GLfloat *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glRasterPos4fv(packed, ret_v) do { \
    PACKED_glRasterPos4fv *unpacked = (PACKED_glRasterPos4fv *)packed; \
    ARGS_glRasterPos4fv *args = (ARGS_glRasterPos4fv *)&unpacked->args; \
    glRasterPos4fv(args->v);; \
} while(0)
void glRasterPos4fv(glRasterPos4fv_ARG_EXPAND);
typedef void (*glRasterPos4fv_PTR)(glRasterPos4fv_ARG_EXPAND);
#define glRasterPos4i_INDEX 1787
#define glRasterPos4i_RETURN void
#define glRasterPos4i_ARG_NAMES x, y, z, w
#define glRasterPos4i_ARG_EXPAND GLint x, GLint y, GLint z, GLint w
#define glRasterPos4i_PACKED PACKED_glRasterPos4i
#define glRasterPos4i_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glRasterPos4i_NOT_VOID_WRAP(...) {}
#define pack_glRasterPos4i(_x, _y, _z, _w) ({ \
    glRasterPos4i_PACKED *packed_data = malloc(sizeof(glRasterPos4i_PACKED)); \
    packed_data->index = glRasterPos4i_INDEX; \
    packed_data->args.x = (GLint)_x; \
    packed_data->args.y = (GLint)_y; \
    packed_data->args.z = (GLint)_z; \
    packed_data->args.w = (GLint)_w; \
    (packed_call_t *)packed_data; \
})
#define call_glRasterPos4i(packed, ret_v) do { \
    PACKED_glRasterPos4i *unpacked = (PACKED_glRasterPos4i *)packed; \
    ARGS_glRasterPos4i *args = (ARGS_glRasterPos4i *)&unpacked->args; \
    glRasterPos4i(args->x, args->y, args->z, args->w);; \
} while(0)
void glRasterPos4i(glRasterPos4i_ARG_EXPAND);
typedef void (*glRasterPos4i_PTR)(glRasterPos4i_ARG_EXPAND);
#define glRasterPos4iv_INDEX 1788
#define glRasterPos4iv_RETURN void
#define glRasterPos4iv_ARG_NAMES v
#define glRasterPos4iv_ARG_EXPAND const GLint * v
#define glRasterPos4iv_PACKED PACKED_glRasterPos4iv
#define glRasterPos4iv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glRasterPos4iv_NOT_VOID_WRAP(...) {}
#define pack_glRasterPos4iv(_v) ({ \
    glRasterPos4iv_PACKED *packed_data = malloc(sizeof(glRasterPos4iv_PACKED)); \
    packed_data->index = glRasterPos4iv_INDEX; \
    packed_data->args.v = (GLint *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glRasterPos4iv(packed, ret_v) do { \
    PACKED_glRasterPos4iv *unpacked = (PACKED_glRasterPos4iv *)packed; \
    ARGS_glRasterPos4iv *args = (ARGS_glRasterPos4iv *)&unpacked->args; \
    glRasterPos4iv(args->v);; \
} while(0)
void glRasterPos4iv(glRasterPos4iv_ARG_EXPAND);
typedef void (*glRasterPos4iv_PTR)(glRasterPos4iv_ARG_EXPAND);
#define glRasterPos4s_INDEX 1789
#define glRasterPos4s_RETURN void
#define glRasterPos4s_ARG_NAMES x, y, z, w
#define glRasterPos4s_ARG_EXPAND GLshort x, GLshort y, GLshort z, GLshort w
#define glRasterPos4s_PACKED PACKED_glRasterPos4s
#define glRasterPos4s_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glRasterPos4s_NOT_VOID_WRAP(...) {}
#define pack_glRasterPos4s(_x, _y, _z, _w) ({ \
    glRasterPos4s_PACKED *packed_data = malloc(sizeof(glRasterPos4s_PACKED)); \
    packed_data->index = glRasterPos4s_INDEX; \
    packed_data->args.x = (GLshort)_x; \
    packed_data->args.y = (GLshort)_y; \
    packed_data->args.z = (GLshort)_z; \
    packed_data->args.w = (GLshort)_w; \
    (packed_call_t *)packed_data; \
})
#define call_glRasterPos4s(packed, ret_v) do { \
    PACKED_glRasterPos4s *unpacked = (PACKED_glRasterPos4s *)packed; \
    ARGS_glRasterPos4s *args = (ARGS_glRasterPos4s *)&unpacked->args; \
    glRasterPos4s(args->x, args->y, args->z, args->w);; \
} while(0)
void glRasterPos4s(glRasterPos4s_ARG_EXPAND);
typedef void (*glRasterPos4s_PTR)(glRasterPos4s_ARG_EXPAND);
#define glRasterPos4sv_INDEX 1790
#define glRasterPos4sv_RETURN void
#define glRasterPos4sv_ARG_NAMES v
#define glRasterPos4sv_ARG_EXPAND const GLshort * v
#define glRasterPos4sv_PACKED PACKED_glRasterPos4sv
#define glRasterPos4sv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glRasterPos4sv_NOT_VOID_WRAP(...) {}
#define pack_glRasterPos4sv(_v) ({ \
    glRasterPos4sv_PACKED *packed_data = malloc(sizeof(glRasterPos4sv_PACKED)); \
    packed_data->index = glRasterPos4sv_INDEX; \
    packed_data->args.v = (GLshort *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glRasterPos4sv(packed, ret_v) do { \
    PACKED_glRasterPos4sv *unpacked = (PACKED_glRasterPos4sv *)packed; \
    ARGS_glRasterPos4sv *args = (ARGS_glRasterPos4sv *)&unpacked->args; \
    glRasterPos4sv(args->v);; \
} while(0)
void glRasterPos4sv(glRasterPos4sv_ARG_EXPAND);
typedef void (*glRasterPos4sv_PTR)(glRasterPos4sv_ARG_EXPAND);
#define glRasterPos4xOES_INDEX 1791
#define glRasterPos4xOES_RETURN void
#define glRasterPos4xOES_ARG_NAMES x, y, z, w
#define glRasterPos4xOES_ARG_EXPAND GLfixed x, GLfixed y, GLfixed z, GLfixed w
#define glRasterPos4xOES_PACKED PACKED_glRasterPos4xOES
#define glRasterPos4xOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glRasterPos4xOES_NOT_VOID_WRAP(...) {}
#define pack_glRasterPos4xOES(_x, _y, _z, _w) ({ \
    glRasterPos4xOES_PACKED *packed_data = malloc(sizeof(glRasterPos4xOES_PACKED)); \
    packed_data->index = glRasterPos4xOES_INDEX; \
    packed_data->args.x = (GLfixed)_x; \
    packed_data->args.y = (GLfixed)_y; \
    packed_data->args.z = (GLfixed)_z; \
    packed_data->args.w = (GLfixed)_w; \
    (packed_call_t *)packed_data; \
})
#define call_glRasterPos4xOES(packed, ret_v) do { \
    PACKED_glRasterPos4xOES *unpacked = (PACKED_glRasterPos4xOES *)packed; \
    ARGS_glRasterPos4xOES *args = (ARGS_glRasterPos4xOES *)&unpacked->args; \
    glRasterPos4xOES(args->x, args->y, args->z, args->w);; \
} while(0)
void glRasterPos4xOES(glRasterPos4xOES_ARG_EXPAND);
typedef void (*glRasterPos4xOES_PTR)(glRasterPos4xOES_ARG_EXPAND);
#define glRasterPos4xvOES_INDEX 1792
#define glRasterPos4xvOES_RETURN void
#define glRasterPos4xvOES_ARG_NAMES coords
#define glRasterPos4xvOES_ARG_EXPAND const GLfixed * coords
#define glRasterPos4xvOES_PACKED PACKED_glRasterPos4xvOES
#define glRasterPos4xvOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glRasterPos4xvOES_NOT_VOID_WRAP(...) {}
#define pack_glRasterPos4xvOES(_coords) ({ \
    glRasterPos4xvOES_PACKED *packed_data = malloc(sizeof(glRasterPos4xvOES_PACKED)); \
    packed_data->index = glRasterPos4xvOES_INDEX; \
    packed_data->args.coords = (GLfixed *)_coords; \
    (packed_call_t *)packed_data; \
})
#define call_glRasterPos4xvOES(packed, ret_v) do { \
    PACKED_glRasterPos4xvOES *unpacked = (PACKED_glRasterPos4xvOES *)packed; \
    ARGS_glRasterPos4xvOES *args = (ARGS_glRasterPos4xvOES *)&unpacked->args; \
    glRasterPos4xvOES(args->coords);; \
} while(0)
void glRasterPos4xvOES(glRasterPos4xvOES_ARG_EXPAND);
typedef void (*glRasterPos4xvOES_PTR)(glRasterPos4xvOES_ARG_EXPAND);
#define glReadBuffer_INDEX 1793
#define glReadBuffer_RETURN void
#define glReadBuffer_ARG_NAMES mode
#define glReadBuffer_ARG_EXPAND GLenum mode
#define glReadBuffer_PACKED PACKED_glReadBuffer
#define glReadBuffer_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glReadBuffer_NOT_VOID_WRAP(...) {}
#define pack_glReadBuffer(_mode) ({ \
    glReadBuffer_PACKED *packed_data = malloc(sizeof(glReadBuffer_PACKED)); \
    packed_data->index = glReadBuffer_INDEX; \
    packed_data->args.mode = (GLenum)_mode; \
    (packed_call_t *)packed_data; \
})
#define call_glReadBuffer(packed, ret_v) do { \
    PACKED_glReadBuffer *unpacked = (PACKED_glReadBuffer *)packed; \
    ARGS_glReadBuffer *args = (ARGS_glReadBuffer *)&unpacked->args; \
    glReadBuffer(args->mode);; \
} while(0)
void glReadBuffer(glReadBuffer_ARG_EXPAND);
typedef void (*glReadBuffer_PTR)(glReadBuffer_ARG_EXPAND);
#define glReadInstrumentsSGIX_INDEX 1794
#define glReadInstrumentsSGIX_RETURN void
#define glReadInstrumentsSGIX_ARG_NAMES marker
#define glReadInstrumentsSGIX_ARG_EXPAND GLint marker
#define glReadInstrumentsSGIX_PACKED PACKED_glReadInstrumentsSGIX
#define glReadInstrumentsSGIX_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glReadInstrumentsSGIX_NOT_VOID_WRAP(...) {}
#define pack_glReadInstrumentsSGIX(_marker) ({ \
    glReadInstrumentsSGIX_PACKED *packed_data = malloc(sizeof(glReadInstrumentsSGIX_PACKED)); \
    packed_data->index = glReadInstrumentsSGIX_INDEX; \
    packed_data->args.marker = (GLint)_marker; \
    (packed_call_t *)packed_data; \
})
#define call_glReadInstrumentsSGIX(packed, ret_v) do { \
    PACKED_glReadInstrumentsSGIX *unpacked = (PACKED_glReadInstrumentsSGIX *)packed; \
    ARGS_glReadInstrumentsSGIX *args = (ARGS_glReadInstrumentsSGIX *)&unpacked->args; \
    glReadInstrumentsSGIX(args->marker);; \
} while(0)
void glReadInstrumentsSGIX(glReadInstrumentsSGIX_ARG_EXPAND);
typedef void (*glReadInstrumentsSGIX_PTR)(glReadInstrumentsSGIX_ARG_EXPAND);
#define glReadPixels_INDEX 1795
#define glReadPixels_RETURN void
#define glReadPixels_ARG_NAMES x, y, width, height, format, type, pixels
#define glReadPixels_ARG_EXPAND GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid * pixels
#define glReadPixels_PACKED PACKED_glReadPixels
#define glReadPixels_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glReadPixels_NOT_VOID_WRAP(...) {}
#define pack_glReadPixels(_x, _y, _width, _height, _format, _type, _pixels) ({ \
    glReadPixels_PACKED *packed_data = malloc(sizeof(glReadPixels_PACKED)); \
    packed_data->index = glReadPixels_INDEX; \
    packed_data->args.x = (GLint)_x; \
    packed_data->args.y = (GLint)_y; \
    packed_data->args.width = (GLsizei)_width; \
    packed_data->args.height = (GLsizei)_height; \
    packed_data->args.format = (GLenum)_format; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.pixels = (GLvoid *)_pixels; \
    (packed_call_t *)packed_data; \
})
#define call_glReadPixels(packed, ret_v) do { \
    PACKED_glReadPixels *unpacked = (PACKED_glReadPixels *)packed; \
    ARGS_glReadPixels *args = (ARGS_glReadPixels *)&unpacked->args; \
    glReadPixels(args->x, args->y, args->width, args->height, args->format, args->type, args->pixels);; \
} while(0)
void glReadPixels(glReadPixels_ARG_EXPAND);
typedef void (*glReadPixels_PTR)(glReadPixels_ARG_EXPAND);
#define glReadnPixelsARB_INDEX 1796
#define glReadnPixelsARB_RETURN void
#define glReadnPixelsARB_ARG_NAMES x, y, width, height, format, type, bufSize, data
#define glReadnPixelsARB_ARG_EXPAND GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, GLvoid * data
#define glReadnPixelsARB_PACKED PACKED_glReadnPixelsARB
#define glReadnPixelsARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glReadnPixelsARB_NOT_VOID_WRAP(...) {}
#define pack_glReadnPixelsARB(_x, _y, _width, _height, _format, _type, _bufSize, _data) ({ \
    glReadnPixelsARB_PACKED *packed_data = malloc(sizeof(glReadnPixelsARB_PACKED)); \
    packed_data->index = glReadnPixelsARB_INDEX; \
    packed_data->args.x = (GLint)_x; \
    packed_data->args.y = (GLint)_y; \
    packed_data->args.width = (GLsizei)_width; \
    packed_data->args.height = (GLsizei)_height; \
    packed_data->args.format = (GLenum)_format; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.bufSize = (GLsizei)_bufSize; \
    packed_data->args.data = (GLvoid *)_data; \
    (packed_call_t *)packed_data; \
})
#define call_glReadnPixelsARB(packed, ret_v) do { \
    PACKED_glReadnPixelsARB *unpacked = (PACKED_glReadnPixelsARB *)packed; \
    ARGS_glReadnPixelsARB *args = (ARGS_glReadnPixelsARB *)&unpacked->args; \
    glReadnPixelsARB(args->x, args->y, args->width, args->height, args->format, args->type, args->bufSize, args->data);; \
} while(0)
void glReadnPixelsARB(glReadnPixelsARB_ARG_EXPAND);
typedef void (*glReadnPixelsARB_PTR)(glReadnPixelsARB_ARG_EXPAND);
#define glRectd_INDEX 1797
#define glRectd_RETURN void
#define glRectd_ARG_NAMES x1, y1, x2, y2
#define glRectd_ARG_EXPAND GLdouble x1, GLdouble y1, GLdouble x2, GLdouble y2
#define glRectd_PACKED PACKED_glRectd
#define glRectd_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glRectd_NOT_VOID_WRAP(...) {}
#define pack_glRectd(_x1, _y1, _x2, _y2) ({ \
    glRectd_PACKED *packed_data = malloc(sizeof(glRectd_PACKED)); \
    packed_data->index = glRectd_INDEX; \
    packed_data->args.x1 = (GLdouble)_x1; \
    packed_data->args.y1 = (GLdouble)_y1; \
    packed_data->args.x2 = (GLdouble)_x2; \
    packed_data->args.y2 = (GLdouble)_y2; \
    (packed_call_t *)packed_data; \
})
#define call_glRectd(packed, ret_v) do { \
    PACKED_glRectd *unpacked = (PACKED_glRectd *)packed; \
    ARGS_glRectd *args = (ARGS_glRectd *)&unpacked->args; \
    glRectd(args->x1, args->y1, args->x2, args->y2);; \
} while(0)
void glRectd(glRectd_ARG_EXPAND);
typedef void (*glRectd_PTR)(glRectd_ARG_EXPAND);
#define glRectdv_INDEX 1798
#define glRectdv_RETURN void
#define glRectdv_ARG_NAMES v1, v2
#define glRectdv_ARG_EXPAND const GLdouble * v1, const GLdouble * v2
#define glRectdv_PACKED PACKED_glRectdv
#define glRectdv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glRectdv_NOT_VOID_WRAP(...) {}
#define pack_glRectdv(_v1, _v2) ({ \
    glRectdv_PACKED *packed_data = malloc(sizeof(glRectdv_PACKED)); \
    packed_data->index = glRectdv_INDEX; \
    packed_data->args.v1 = (GLdouble *)_v1; \
    packed_data->args.v2 = (GLdouble *)_v2; \
    (packed_call_t *)packed_data; \
})
#define call_glRectdv(packed, ret_v) do { \
    PACKED_glRectdv *unpacked = (PACKED_glRectdv *)packed; \
    ARGS_glRectdv *args = (ARGS_glRectdv *)&unpacked->args; \
    glRectdv(args->v1, args->v2);; \
} while(0)
void glRectdv(glRectdv_ARG_EXPAND);
typedef void (*glRectdv_PTR)(glRectdv_ARG_EXPAND);
#define glRectf_INDEX 1799
#define glRectf_RETURN void
#define glRectf_ARG_NAMES x1, y1, x2, y2
#define glRectf_ARG_EXPAND GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2
#define glRectf_PACKED PACKED_glRectf
#define glRectf_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glRectf_NOT_VOID_WRAP(...) {}
#define pack_glRectf(_x1, _y1, _x2, _y2) ({ \
    glRectf_PACKED *packed_data = malloc(sizeof(glRectf_PACKED)); \
    packed_data->index = glRectf_INDEX; \
    packed_data->args.x1 = (GLfloat)_x1; \
    packed_data->args.y1 = (GLfloat)_y1; \
    packed_data->args.x2 = (GLfloat)_x2; \
    packed_data->args.y2 = (GLfloat)_y2; \
    (packed_call_t *)packed_data; \
})
#define call_glRectf(packed, ret_v) do { \
    PACKED_glRectf *unpacked = (PACKED_glRectf *)packed; \
    ARGS_glRectf *args = (ARGS_glRectf *)&unpacked->args; \
    glRectf(args->x1, args->y1, args->x2, args->y2);; \
} while(0)
void glRectf(glRectf_ARG_EXPAND);
typedef void (*glRectf_PTR)(glRectf_ARG_EXPAND);
#define glRectfv_INDEX 1800
#define glRectfv_RETURN void
#define glRectfv_ARG_NAMES v1, v2
#define glRectfv_ARG_EXPAND const GLfloat * v1, const GLfloat * v2
#define glRectfv_PACKED PACKED_glRectfv
#define glRectfv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glRectfv_NOT_VOID_WRAP(...) {}
#define pack_glRectfv(_v1, _v2) ({ \
    glRectfv_PACKED *packed_data = malloc(sizeof(glRectfv_PACKED)); \
    packed_data->index = glRectfv_INDEX; \
    packed_data->args.v1 = (GLfloat *)_v1; \
    packed_data->args.v2 = (GLfloat *)_v2; \
    (packed_call_t *)packed_data; \
})
#define call_glRectfv(packed, ret_v) do { \
    PACKED_glRectfv *unpacked = (PACKED_glRectfv *)packed; \
    ARGS_glRectfv *args = (ARGS_glRectfv *)&unpacked->args; \
    glRectfv(args->v1, args->v2);; \
} while(0)
void glRectfv(glRectfv_ARG_EXPAND);
typedef void (*glRectfv_PTR)(glRectfv_ARG_EXPAND);
#define glRecti_INDEX 1801
#define glRecti_RETURN void
#define glRecti_ARG_NAMES x1, y1, x2, y2
#define glRecti_ARG_EXPAND GLint x1, GLint y1, GLint x2, GLint y2
#define glRecti_PACKED PACKED_glRecti
#define glRecti_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glRecti_NOT_VOID_WRAP(...) {}
#define pack_glRecti(_x1, _y1, _x2, _y2) ({ \
    glRecti_PACKED *packed_data = malloc(sizeof(glRecti_PACKED)); \
    packed_data->index = glRecti_INDEX; \
    packed_data->args.x1 = (GLint)_x1; \
    packed_data->args.y1 = (GLint)_y1; \
    packed_data->args.x2 = (GLint)_x2; \
    packed_data->args.y2 = (GLint)_y2; \
    (packed_call_t *)packed_data; \
})
#define call_glRecti(packed, ret_v) do { \
    PACKED_glRecti *unpacked = (PACKED_glRecti *)packed; \
    ARGS_glRecti *args = (ARGS_glRecti *)&unpacked->args; \
    glRecti(args->x1, args->y1, args->x2, args->y2);; \
} while(0)
void glRecti(glRecti_ARG_EXPAND);
typedef void (*glRecti_PTR)(glRecti_ARG_EXPAND);
#define glRectiv_INDEX 1802
#define glRectiv_RETURN void
#define glRectiv_ARG_NAMES v1, v2
#define glRectiv_ARG_EXPAND const GLint * v1, const GLint * v2
#define glRectiv_PACKED PACKED_glRectiv
#define glRectiv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glRectiv_NOT_VOID_WRAP(...) {}
#define pack_glRectiv(_v1, _v2) ({ \
    glRectiv_PACKED *packed_data = malloc(sizeof(glRectiv_PACKED)); \
    packed_data->index = glRectiv_INDEX; \
    packed_data->args.v1 = (GLint *)_v1; \
    packed_data->args.v2 = (GLint *)_v2; \
    (packed_call_t *)packed_data; \
})
#define call_glRectiv(packed, ret_v) do { \
    PACKED_glRectiv *unpacked = (PACKED_glRectiv *)packed; \
    ARGS_glRectiv *args = (ARGS_glRectiv *)&unpacked->args; \
    glRectiv(args->v1, args->v2);; \
} while(0)
void glRectiv(glRectiv_ARG_EXPAND);
typedef void (*glRectiv_PTR)(glRectiv_ARG_EXPAND);
#define glRects_INDEX 1803
#define glRects_RETURN void
#define glRects_ARG_NAMES x1, y1, x2, y2
#define glRects_ARG_EXPAND GLshort x1, GLshort y1, GLshort x2, GLshort y2
#define glRects_PACKED PACKED_glRects
#define glRects_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glRects_NOT_VOID_WRAP(...) {}
#define pack_glRects(_x1, _y1, _x2, _y2) ({ \
    glRects_PACKED *packed_data = malloc(sizeof(glRects_PACKED)); \
    packed_data->index = glRects_INDEX; \
    packed_data->args.x1 = (GLshort)_x1; \
    packed_data->args.y1 = (GLshort)_y1; \
    packed_data->args.x2 = (GLshort)_x2; \
    packed_data->args.y2 = (GLshort)_y2; \
    (packed_call_t *)packed_data; \
})
#define call_glRects(packed, ret_v) do { \
    PACKED_glRects *unpacked = (PACKED_glRects *)packed; \
    ARGS_glRects *args = (ARGS_glRects *)&unpacked->args; \
    glRects(args->x1, args->y1, args->x2, args->y2);; \
} while(0)
void glRects(glRects_ARG_EXPAND);
typedef void (*glRects_PTR)(glRects_ARG_EXPAND);
#define glRectsv_INDEX 1804
#define glRectsv_RETURN void
#define glRectsv_ARG_NAMES v1, v2
#define glRectsv_ARG_EXPAND const GLshort * v1, const GLshort * v2
#define glRectsv_PACKED PACKED_glRectsv
#define glRectsv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glRectsv_NOT_VOID_WRAP(...) {}
#define pack_glRectsv(_v1, _v2) ({ \
    glRectsv_PACKED *packed_data = malloc(sizeof(glRectsv_PACKED)); \
    packed_data->index = glRectsv_INDEX; \
    packed_data->args.v1 = (GLshort *)_v1; \
    packed_data->args.v2 = (GLshort *)_v2; \
    (packed_call_t *)packed_data; \
})
#define call_glRectsv(packed, ret_v) do { \
    PACKED_glRectsv *unpacked = (PACKED_glRectsv *)packed; \
    ARGS_glRectsv *args = (ARGS_glRectsv *)&unpacked->args; \
    glRectsv(args->v1, args->v2);; \
} while(0)
void glRectsv(glRectsv_ARG_EXPAND);
typedef void (*glRectsv_PTR)(glRectsv_ARG_EXPAND);
#define glRectxOES_INDEX 1805
#define glRectxOES_RETURN void
#define glRectxOES_ARG_NAMES x1, y1, x2, y2
#define glRectxOES_ARG_EXPAND GLfixed x1, GLfixed y1, GLfixed x2, GLfixed y2
#define glRectxOES_PACKED PACKED_glRectxOES
#define glRectxOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glRectxOES_NOT_VOID_WRAP(...) {}
#define pack_glRectxOES(_x1, _y1, _x2, _y2) ({ \
    glRectxOES_PACKED *packed_data = malloc(sizeof(glRectxOES_PACKED)); \
    packed_data->index = glRectxOES_INDEX; \
    packed_data->args.x1 = (GLfixed)_x1; \
    packed_data->args.y1 = (GLfixed)_y1; \
    packed_data->args.x2 = (GLfixed)_x2; \
    packed_data->args.y2 = (GLfixed)_y2; \
    (packed_call_t *)packed_data; \
})
#define call_glRectxOES(packed, ret_v) do { \
    PACKED_glRectxOES *unpacked = (PACKED_glRectxOES *)packed; \
    ARGS_glRectxOES *args = (ARGS_glRectxOES *)&unpacked->args; \
    glRectxOES(args->x1, args->y1, args->x2, args->y2);; \
} while(0)
void glRectxOES(glRectxOES_ARG_EXPAND);
typedef void (*glRectxOES_PTR)(glRectxOES_ARG_EXPAND);
#define glRectxvOES_INDEX 1806
#define glRectxvOES_RETURN void
#define glRectxvOES_ARG_NAMES v1, v2
#define glRectxvOES_ARG_EXPAND const GLfixed * v1, const GLfixed * v2
#define glRectxvOES_PACKED PACKED_glRectxvOES
#define glRectxvOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glRectxvOES_NOT_VOID_WRAP(...) {}
#define pack_glRectxvOES(_v1, _v2) ({ \
    glRectxvOES_PACKED *packed_data = malloc(sizeof(glRectxvOES_PACKED)); \
    packed_data->index = glRectxvOES_INDEX; \
    packed_data->args.v1 = (GLfixed *)_v1; \
    packed_data->args.v2 = (GLfixed *)_v2; \
    (packed_call_t *)packed_data; \
})
#define call_glRectxvOES(packed, ret_v) do { \
    PACKED_glRectxvOES *unpacked = (PACKED_glRectxvOES *)packed; \
    ARGS_glRectxvOES *args = (ARGS_glRectxvOES *)&unpacked->args; \
    glRectxvOES(args->v1, args->v2);; \
} while(0)
void glRectxvOES(glRectxvOES_ARG_EXPAND);
typedef void (*glRectxvOES_PTR)(glRectxvOES_ARG_EXPAND);
#define glReferencePlaneSGIX_INDEX 1807
#define glReferencePlaneSGIX_RETURN void
#define glReferencePlaneSGIX_ARG_NAMES equation
#define glReferencePlaneSGIX_ARG_EXPAND const GLdouble * equation
#define glReferencePlaneSGIX_PACKED PACKED_glReferencePlaneSGIX
#define glReferencePlaneSGIX_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glReferencePlaneSGIX_NOT_VOID_WRAP(...) {}
#define pack_glReferencePlaneSGIX(_equation) ({ \
    glReferencePlaneSGIX_PACKED *packed_data = malloc(sizeof(glReferencePlaneSGIX_PACKED)); \
    packed_data->index = glReferencePlaneSGIX_INDEX; \
    packed_data->args.equation = (GLdouble *)_equation; \
    (packed_call_t *)packed_data; \
})
#define call_glReferencePlaneSGIX(packed, ret_v) do { \
    PACKED_glReferencePlaneSGIX *unpacked = (PACKED_glReferencePlaneSGIX *)packed; \
    ARGS_glReferencePlaneSGIX *args = (ARGS_glReferencePlaneSGIX *)&unpacked->args; \
    glReferencePlaneSGIX(args->equation);; \
} while(0)
void glReferencePlaneSGIX(glReferencePlaneSGIX_ARG_EXPAND);
typedef void (*glReferencePlaneSGIX_PTR)(glReferencePlaneSGIX_ARG_EXPAND);
#define glReleaseShaderCompiler_INDEX 1808
#define glReleaseShaderCompiler_RETURN void
#define glReleaseShaderCompiler_ARG_NAMES 
#define glReleaseShaderCompiler_ARG_EXPAND 
#define glReleaseShaderCompiler_PACKED PACKED_glReleaseShaderCompiler
#define glReleaseShaderCompiler_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glReleaseShaderCompiler_NOT_VOID_WRAP(...) {}
#define pack_glReleaseShaderCompiler() ({ \
    glReleaseShaderCompiler_PACKED *packed_data = malloc(sizeof(glReleaseShaderCompiler_PACKED)); \
    packed_data->index = glReleaseShaderCompiler_INDEX; \
    (packed_call_t *)packed_data; \
})
#define call_glReleaseShaderCompiler(packed, ret_v) do { \
    glReleaseShaderCompiler();; \
} while(0)
void glReleaseShaderCompiler(glReleaseShaderCompiler_ARG_EXPAND);
typedef void (*glReleaseShaderCompiler_PTR)(glReleaseShaderCompiler_ARG_EXPAND);
#define glRenderMode_INDEX 1809
#define glRenderMode_RETURN GLint
#define glRenderMode_ARG_NAMES mode
#define glRenderMode_ARG_EXPAND GLenum mode
#define glRenderMode_PACKED PACKED_glRenderMode
#define glRenderMode_VOID_ONLY_WRAP(...) {}
#define glRenderMode_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glRenderMode(_mode) ({ \
    glRenderMode_PACKED *packed_data = malloc(sizeof(glRenderMode_PACKED)); \
    packed_data->index = glRenderMode_INDEX; \
    packed_data->args.mode = (GLenum)_mode; \
    (packed_call_t *)packed_data; \
})
#define call_glRenderMode(packed, ret_v) do { \
    PACKED_glRenderMode *unpacked = (PACKED_glRenderMode *)packed; \
    ARGS_glRenderMode *args = (ARGS_glRenderMode *)&unpacked->args; \
    GLint *ret = (GLint *)ret_v; \
    if (ret != NULL) { \
        *ret = glRenderMode(args->mode);; \
    } else { \
        glRenderMode(args->mode);; \
    } \
} while(0)
GLint glRenderMode(glRenderMode_ARG_EXPAND);
typedef GLint (*glRenderMode_PTR)(glRenderMode_ARG_EXPAND);
#define glRenderbufferStorage_INDEX 1810
#define glRenderbufferStorage_RETURN void
#define glRenderbufferStorage_ARG_NAMES target, internalformat, width, height
#define glRenderbufferStorage_ARG_EXPAND GLenum target, GLenum internalformat, GLsizei width, GLsizei height
#define glRenderbufferStorage_PACKED PACKED_glRenderbufferStorage
#define glRenderbufferStorage_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glRenderbufferStorage_NOT_VOID_WRAP(...) {}
#define pack_glRenderbufferStorage(_target, _internalformat, _width, _height) ({ \
    glRenderbufferStorage_PACKED *packed_data = malloc(sizeof(glRenderbufferStorage_PACKED)); \
    packed_data->index = glRenderbufferStorage_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.internalformat = (GLenum)_internalformat; \
    packed_data->args.width = (GLsizei)_width; \
    packed_data->args.height = (GLsizei)_height; \
    (packed_call_t *)packed_data; \
})
#define call_glRenderbufferStorage(packed, ret_v) do { \
    PACKED_glRenderbufferStorage *unpacked = (PACKED_glRenderbufferStorage *)packed; \
    ARGS_glRenderbufferStorage *args = (ARGS_glRenderbufferStorage *)&unpacked->args; \
    glRenderbufferStorage(args->target, args->internalformat, args->width, args->height);; \
} while(0)
void glRenderbufferStorage(glRenderbufferStorage_ARG_EXPAND);
typedef void (*glRenderbufferStorage_PTR)(glRenderbufferStorage_ARG_EXPAND);
#define glRenderbufferStorageEXT_INDEX 1811
#define glRenderbufferStorageEXT_RETURN void
#define glRenderbufferStorageEXT_ARG_NAMES target, internalformat, width, height
#define glRenderbufferStorageEXT_ARG_EXPAND GLenum target, GLenum internalformat, GLsizei width, GLsizei height
#define glRenderbufferStorageEXT_PACKED PACKED_glRenderbufferStorageEXT
#define glRenderbufferStorageEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glRenderbufferStorageEXT_NOT_VOID_WRAP(...) {}
#define pack_glRenderbufferStorageEXT(_target, _internalformat, _width, _height) ({ \
    glRenderbufferStorageEXT_PACKED *packed_data = malloc(sizeof(glRenderbufferStorageEXT_PACKED)); \
    packed_data->index = glRenderbufferStorageEXT_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.internalformat = (GLenum)_internalformat; \
    packed_data->args.width = (GLsizei)_width; \
    packed_data->args.height = (GLsizei)_height; \
    (packed_call_t *)packed_data; \
})
#define call_glRenderbufferStorageEXT(packed, ret_v) do { \
    PACKED_glRenderbufferStorageEXT *unpacked = (PACKED_glRenderbufferStorageEXT *)packed; \
    ARGS_glRenderbufferStorageEXT *args = (ARGS_glRenderbufferStorageEXT *)&unpacked->args; \
    glRenderbufferStorageEXT(args->target, args->internalformat, args->width, args->height);; \
} while(0)
void glRenderbufferStorageEXT(glRenderbufferStorageEXT_ARG_EXPAND);
typedef void (*glRenderbufferStorageEXT_PTR)(glRenderbufferStorageEXT_ARG_EXPAND);
#define glRenderbufferStorageMultisample_INDEX 1812
#define glRenderbufferStorageMultisample_RETURN void
#define glRenderbufferStorageMultisample_ARG_NAMES target, samples, internalformat, width, height
#define glRenderbufferStorageMultisample_ARG_EXPAND GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height
#define glRenderbufferStorageMultisample_PACKED PACKED_glRenderbufferStorageMultisample
#define glRenderbufferStorageMultisample_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glRenderbufferStorageMultisample_NOT_VOID_WRAP(...) {}
#define pack_glRenderbufferStorageMultisample(_target, _samples, _internalformat, _width, _height) ({ \
    glRenderbufferStorageMultisample_PACKED *packed_data = malloc(sizeof(glRenderbufferStorageMultisample_PACKED)); \
    packed_data->index = glRenderbufferStorageMultisample_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.samples = (GLsizei)_samples; \
    packed_data->args.internalformat = (GLenum)_internalformat; \
    packed_data->args.width = (GLsizei)_width; \
    packed_data->args.height = (GLsizei)_height; \
    (packed_call_t *)packed_data; \
})
#define call_glRenderbufferStorageMultisample(packed, ret_v) do { \
    PACKED_glRenderbufferStorageMultisample *unpacked = (PACKED_glRenderbufferStorageMultisample *)packed; \
    ARGS_glRenderbufferStorageMultisample *args = (ARGS_glRenderbufferStorageMultisample *)&unpacked->args; \
    glRenderbufferStorageMultisample(args->target, args->samples, args->internalformat, args->width, args->height);; \
} while(0)
void glRenderbufferStorageMultisample(glRenderbufferStorageMultisample_ARG_EXPAND);
typedef void (*glRenderbufferStorageMultisample_PTR)(glRenderbufferStorageMultisample_ARG_EXPAND);
#define glRenderbufferStorageMultisampleCoverageNV_INDEX 1813
#define glRenderbufferStorageMultisampleCoverageNV_RETURN void
#define glRenderbufferStorageMultisampleCoverageNV_ARG_NAMES target, coverageSamples, colorSamples, internalformat, width, height
#define glRenderbufferStorageMultisampleCoverageNV_ARG_EXPAND GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLenum internalformat, GLsizei width, GLsizei height
#define glRenderbufferStorageMultisampleCoverageNV_PACKED PACKED_glRenderbufferStorageMultisampleCoverageNV
#define glRenderbufferStorageMultisampleCoverageNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glRenderbufferStorageMultisampleCoverageNV_NOT_VOID_WRAP(...) {}
#define pack_glRenderbufferStorageMultisampleCoverageNV(_target, _coverageSamples, _colorSamples, _internalformat, _width, _height) ({ \
    glRenderbufferStorageMultisampleCoverageNV_PACKED *packed_data = malloc(sizeof(glRenderbufferStorageMultisampleCoverageNV_PACKED)); \
    packed_data->index = glRenderbufferStorageMultisampleCoverageNV_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.coverageSamples = (GLsizei)_coverageSamples; \
    packed_data->args.colorSamples = (GLsizei)_colorSamples; \
    packed_data->args.internalformat = (GLenum)_internalformat; \
    packed_data->args.width = (GLsizei)_width; \
    packed_data->args.height = (GLsizei)_height; \
    (packed_call_t *)packed_data; \
})
#define call_glRenderbufferStorageMultisampleCoverageNV(packed, ret_v) do { \
    PACKED_glRenderbufferStorageMultisampleCoverageNV *unpacked = (PACKED_glRenderbufferStorageMultisampleCoverageNV *)packed; \
    ARGS_glRenderbufferStorageMultisampleCoverageNV *args = (ARGS_glRenderbufferStorageMultisampleCoverageNV *)&unpacked->args; \
    glRenderbufferStorageMultisampleCoverageNV(args->target, args->coverageSamples, args->colorSamples, args->internalformat, args->width, args->height);; \
} while(0)
void glRenderbufferStorageMultisampleCoverageNV(glRenderbufferStorageMultisampleCoverageNV_ARG_EXPAND);
typedef void (*glRenderbufferStorageMultisampleCoverageNV_PTR)(glRenderbufferStorageMultisampleCoverageNV_ARG_EXPAND);
#define glRenderbufferStorageMultisampleEXT_INDEX 1814
#define glRenderbufferStorageMultisampleEXT_RETURN void
#define glRenderbufferStorageMultisampleEXT_ARG_NAMES target, samples, internalformat, width, height
#define glRenderbufferStorageMultisampleEXT_ARG_EXPAND GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height
#define glRenderbufferStorageMultisampleEXT_PACKED PACKED_glRenderbufferStorageMultisampleEXT
#define glRenderbufferStorageMultisampleEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glRenderbufferStorageMultisampleEXT_NOT_VOID_WRAP(...) {}
#define pack_glRenderbufferStorageMultisampleEXT(_target, _samples, _internalformat, _width, _height) ({ \
    glRenderbufferStorageMultisampleEXT_PACKED *packed_data = malloc(sizeof(glRenderbufferStorageMultisampleEXT_PACKED)); \
    packed_data->index = glRenderbufferStorageMultisampleEXT_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.samples = (GLsizei)_samples; \
    packed_data->args.internalformat = (GLenum)_internalformat; \
    packed_data->args.width = (GLsizei)_width; \
    packed_data->args.height = (GLsizei)_height; \
    (packed_call_t *)packed_data; \
})
#define call_glRenderbufferStorageMultisampleEXT(packed, ret_v) do { \
    PACKED_glRenderbufferStorageMultisampleEXT *unpacked = (PACKED_glRenderbufferStorageMultisampleEXT *)packed; \
    ARGS_glRenderbufferStorageMultisampleEXT *args = (ARGS_glRenderbufferStorageMultisampleEXT *)&unpacked->args; \
    glRenderbufferStorageMultisampleEXT(args->target, args->samples, args->internalformat, args->width, args->height);; \
} while(0)
void glRenderbufferStorageMultisampleEXT(glRenderbufferStorageMultisampleEXT_ARG_EXPAND);
typedef void (*glRenderbufferStorageMultisampleEXT_PTR)(glRenderbufferStorageMultisampleEXT_ARG_EXPAND);
#define glReplacementCodePointerSUN_INDEX 1815
#define glReplacementCodePointerSUN_RETURN void
#define glReplacementCodePointerSUN_ARG_NAMES type, stride, pointer
#define glReplacementCodePointerSUN_ARG_EXPAND GLenum type, GLsizei stride, const GLvoid * pointer
#define glReplacementCodePointerSUN_PACKED PACKED_glReplacementCodePointerSUN
#define glReplacementCodePointerSUN_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glReplacementCodePointerSUN_NOT_VOID_WRAP(...) {}
#define pack_glReplacementCodePointerSUN(_type, _stride, _pointer) ({ \
    glReplacementCodePointerSUN_PACKED *packed_data = malloc(sizeof(glReplacementCodePointerSUN_PACKED)); \
    packed_data->index = glReplacementCodePointerSUN_INDEX; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.stride = (GLsizei)_stride; \
    packed_data->args.pointer = (GLvoid *)_pointer; \
    (packed_call_t *)packed_data; \
})
#define call_glReplacementCodePointerSUN(packed, ret_v) do { \
    PACKED_glReplacementCodePointerSUN *unpacked = (PACKED_glReplacementCodePointerSUN *)packed; \
    ARGS_glReplacementCodePointerSUN *args = (ARGS_glReplacementCodePointerSUN *)&unpacked->args; \
    glReplacementCodePointerSUN(args->type, args->stride, args->pointer);; \
} while(0)
void glReplacementCodePointerSUN(glReplacementCodePointerSUN_ARG_EXPAND);
typedef void (*glReplacementCodePointerSUN_PTR)(glReplacementCodePointerSUN_ARG_EXPAND);
#define glReplacementCodeubSUN_INDEX 1816
#define glReplacementCodeubSUN_RETURN void
#define glReplacementCodeubSUN_ARG_NAMES code
#define glReplacementCodeubSUN_ARG_EXPAND GLubyte code
#define glReplacementCodeubSUN_PACKED PACKED_glReplacementCodeubSUN
#define glReplacementCodeubSUN_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glReplacementCodeubSUN_NOT_VOID_WRAP(...) {}
#define pack_glReplacementCodeubSUN(_code) ({ \
    glReplacementCodeubSUN_PACKED *packed_data = malloc(sizeof(glReplacementCodeubSUN_PACKED)); \
    packed_data->index = glReplacementCodeubSUN_INDEX; \
    packed_data->args.code = (GLubyte)_code; \
    (packed_call_t *)packed_data; \
})
#define call_glReplacementCodeubSUN(packed, ret_v) do { \
    PACKED_glReplacementCodeubSUN *unpacked = (PACKED_glReplacementCodeubSUN *)packed; \
    ARGS_glReplacementCodeubSUN *args = (ARGS_glReplacementCodeubSUN *)&unpacked->args; \
    glReplacementCodeubSUN(args->code);; \
} while(0)
void glReplacementCodeubSUN(glReplacementCodeubSUN_ARG_EXPAND);
typedef void (*glReplacementCodeubSUN_PTR)(glReplacementCodeubSUN_ARG_EXPAND);
#define glReplacementCodeubvSUN_INDEX 1817
#define glReplacementCodeubvSUN_RETURN void
#define glReplacementCodeubvSUN_ARG_NAMES code
#define glReplacementCodeubvSUN_ARG_EXPAND const GLubyte * code
#define glReplacementCodeubvSUN_PACKED PACKED_glReplacementCodeubvSUN
#define glReplacementCodeubvSUN_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glReplacementCodeubvSUN_NOT_VOID_WRAP(...) {}
#define pack_glReplacementCodeubvSUN(_code) ({ \
    glReplacementCodeubvSUN_PACKED *packed_data = malloc(sizeof(glReplacementCodeubvSUN_PACKED)); \
    packed_data->index = glReplacementCodeubvSUN_INDEX; \
    packed_data->args.code = (GLubyte *)_code; \
    (packed_call_t *)packed_data; \
})
#define call_glReplacementCodeubvSUN(packed, ret_v) do { \
    PACKED_glReplacementCodeubvSUN *unpacked = (PACKED_glReplacementCodeubvSUN *)packed; \
    ARGS_glReplacementCodeubvSUN *args = (ARGS_glReplacementCodeubvSUN *)&unpacked->args; \
    glReplacementCodeubvSUN(args->code);; \
} while(0)
void glReplacementCodeubvSUN(glReplacementCodeubvSUN_ARG_EXPAND);
typedef void (*glReplacementCodeubvSUN_PTR)(glReplacementCodeubvSUN_ARG_EXPAND);
#define glReplacementCodeuiColor3fVertex3fSUN_INDEX 1818
#define glReplacementCodeuiColor3fVertex3fSUN_RETURN void
#define glReplacementCodeuiColor3fVertex3fSUN_ARG_NAMES rc, r, g, b, x, y, z
#define glReplacementCodeuiColor3fVertex3fSUN_ARG_EXPAND GLuint rc, GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z
#define glReplacementCodeuiColor3fVertex3fSUN_PACKED PACKED_glReplacementCodeuiColor3fVertex3fSUN
#define glReplacementCodeuiColor3fVertex3fSUN_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glReplacementCodeuiColor3fVertex3fSUN_NOT_VOID_WRAP(...) {}
#define pack_glReplacementCodeuiColor3fVertex3fSUN(_rc, _r, _g, _b, _x, _y, _z) ({ \
    glReplacementCodeuiColor3fVertex3fSUN_PACKED *packed_data = malloc(sizeof(glReplacementCodeuiColor3fVertex3fSUN_PACKED)); \
    packed_data->index = glReplacementCodeuiColor3fVertex3fSUN_INDEX; \
    packed_data->args.rc = (GLuint)_rc; \
    packed_data->args.r = (GLfloat)_r; \
    packed_data->args.g = (GLfloat)_g; \
    packed_data->args.b = (GLfloat)_b; \
    packed_data->args.x = (GLfloat)_x; \
    packed_data->args.y = (GLfloat)_y; \
    packed_data->args.z = (GLfloat)_z; \
    (packed_call_t *)packed_data; \
})
#define call_glReplacementCodeuiColor3fVertex3fSUN(packed, ret_v) do { \
    PACKED_glReplacementCodeuiColor3fVertex3fSUN *unpacked = (PACKED_glReplacementCodeuiColor3fVertex3fSUN *)packed; \
    ARGS_glReplacementCodeuiColor3fVertex3fSUN *args = (ARGS_glReplacementCodeuiColor3fVertex3fSUN *)&unpacked->args; \
    glReplacementCodeuiColor3fVertex3fSUN(args->rc, args->r, args->g, args->b, args->x, args->y, args->z);; \
} while(0)
void glReplacementCodeuiColor3fVertex3fSUN(glReplacementCodeuiColor3fVertex3fSUN_ARG_EXPAND);
typedef void (*glReplacementCodeuiColor3fVertex3fSUN_PTR)(glReplacementCodeuiColor3fVertex3fSUN_ARG_EXPAND);
#define glReplacementCodeuiColor3fVertex3fvSUN_INDEX 1819
#define glReplacementCodeuiColor3fVertex3fvSUN_RETURN void
#define glReplacementCodeuiColor3fVertex3fvSUN_ARG_NAMES rc, c, v
#define glReplacementCodeuiColor3fVertex3fvSUN_ARG_EXPAND const GLuint * rc, const GLfloat * c, const GLfloat * v
#define glReplacementCodeuiColor3fVertex3fvSUN_PACKED PACKED_glReplacementCodeuiColor3fVertex3fvSUN
#define glReplacementCodeuiColor3fVertex3fvSUN_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glReplacementCodeuiColor3fVertex3fvSUN_NOT_VOID_WRAP(...) {}
#define pack_glReplacementCodeuiColor3fVertex3fvSUN(_rc, _c, _v) ({ \
    glReplacementCodeuiColor3fVertex3fvSUN_PACKED *packed_data = malloc(sizeof(glReplacementCodeuiColor3fVertex3fvSUN_PACKED)); \
    packed_data->index = glReplacementCodeuiColor3fVertex3fvSUN_INDEX; \
    packed_data->args.rc = (GLuint *)_rc; \
    packed_data->args.c = (GLfloat *)_c; \
    packed_data->args.v = (GLfloat *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glReplacementCodeuiColor3fVertex3fvSUN(packed, ret_v) do { \
    PACKED_glReplacementCodeuiColor3fVertex3fvSUN *unpacked = (PACKED_glReplacementCodeuiColor3fVertex3fvSUN *)packed; \
    ARGS_glReplacementCodeuiColor3fVertex3fvSUN *args = (ARGS_glReplacementCodeuiColor3fVertex3fvSUN *)&unpacked->args; \
    glReplacementCodeuiColor3fVertex3fvSUN(args->rc, args->c, args->v);; \
} while(0)
void glReplacementCodeuiColor3fVertex3fvSUN(glReplacementCodeuiColor3fVertex3fvSUN_ARG_EXPAND);
typedef void (*glReplacementCodeuiColor3fVertex3fvSUN_PTR)(glReplacementCodeuiColor3fVertex3fvSUN_ARG_EXPAND);
#define glReplacementCodeuiColor4fNormal3fVertex3fSUN_INDEX 1820
#define glReplacementCodeuiColor4fNormal3fVertex3fSUN_RETURN void
#define glReplacementCodeuiColor4fNormal3fVertex3fSUN_ARG_NAMES rc, r, g, b, a, nx, ny, nz, x, y, z
#define glReplacementCodeuiColor4fNormal3fVertex3fSUN_ARG_EXPAND GLuint rc, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z
#define glReplacementCodeuiColor4fNormal3fVertex3fSUN_PACKED PACKED_glReplacementCodeuiColor4fNormal3fVertex3fSUN
#define glReplacementCodeuiColor4fNormal3fVertex3fSUN_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glReplacementCodeuiColor4fNormal3fVertex3fSUN_NOT_VOID_WRAP(...) {}
#define pack_glReplacementCodeuiColor4fNormal3fVertex3fSUN(_rc, _r, _g, _b, _a, _nx, _ny, _nz, _x, _y, _z) ({ \
    glReplacementCodeuiColor4fNormal3fVertex3fSUN_PACKED *packed_data = malloc(sizeof(glReplacementCodeuiColor4fNormal3fVertex3fSUN_PACKED)); \
    packed_data->index = glReplacementCodeuiColor4fNormal3fVertex3fSUN_INDEX; \
    packed_data->args.rc = (GLuint)_rc; \
    packed_data->args.r = (GLfloat)_r; \
    packed_data->args.g = (GLfloat)_g; \
    packed_data->args.b = (GLfloat)_b; \
    packed_data->args.a = (GLfloat)_a; \
    packed_data->args.nx = (GLfloat)_nx; \
    packed_data->args.ny = (GLfloat)_ny; \
    packed_data->args.nz = (GLfloat)_nz; \
    packed_data->args.x = (GLfloat)_x; \
    packed_data->args.y = (GLfloat)_y; \
    packed_data->args.z = (GLfloat)_z; \
    (packed_call_t *)packed_data; \
})
#define call_glReplacementCodeuiColor4fNormal3fVertex3fSUN(packed, ret_v) do { \
    PACKED_glReplacementCodeuiColor4fNormal3fVertex3fSUN *unpacked = (PACKED_glReplacementCodeuiColor4fNormal3fVertex3fSUN *)packed; \
    ARGS_glReplacementCodeuiColor4fNormal3fVertex3fSUN *args = (ARGS_glReplacementCodeuiColor4fNormal3fVertex3fSUN *)&unpacked->args; \
    glReplacementCodeuiColor4fNormal3fVertex3fSUN(args->rc, args->r, args->g, args->b, args->a, args->nx, args->ny, args->nz, args->x, args->y, args->z);; \
} while(0)
void glReplacementCodeuiColor4fNormal3fVertex3fSUN(glReplacementCodeuiColor4fNormal3fVertex3fSUN_ARG_EXPAND);
typedef void (*glReplacementCodeuiColor4fNormal3fVertex3fSUN_PTR)(glReplacementCodeuiColor4fNormal3fVertex3fSUN_ARG_EXPAND);
#define glReplacementCodeuiColor4fNormal3fVertex3fvSUN_INDEX 1821
#define glReplacementCodeuiColor4fNormal3fVertex3fvSUN_RETURN void
#define glReplacementCodeuiColor4fNormal3fVertex3fvSUN_ARG_NAMES rc, c, n, v
#define glReplacementCodeuiColor4fNormal3fVertex3fvSUN_ARG_EXPAND const GLuint * rc, const GLfloat * c, const GLfloat * n, const GLfloat * v
#define glReplacementCodeuiColor4fNormal3fVertex3fvSUN_PACKED PACKED_glReplacementCodeuiColor4fNormal3fVertex3fvSUN
#define glReplacementCodeuiColor4fNormal3fVertex3fvSUN_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glReplacementCodeuiColor4fNormal3fVertex3fvSUN_NOT_VOID_WRAP(...) {}
#define pack_glReplacementCodeuiColor4fNormal3fVertex3fvSUN(_rc, _c, _n, _v) ({ \
    glReplacementCodeuiColor4fNormal3fVertex3fvSUN_PACKED *packed_data = malloc(sizeof(glReplacementCodeuiColor4fNormal3fVertex3fvSUN_PACKED)); \
    packed_data->index = glReplacementCodeuiColor4fNormal3fVertex3fvSUN_INDEX; \
    packed_data->args.rc = (GLuint *)_rc; \
    packed_data->args.c = (GLfloat *)_c; \
    packed_data->args.n = (GLfloat *)_n; \
    packed_data->args.v = (GLfloat *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glReplacementCodeuiColor4fNormal3fVertex3fvSUN(packed, ret_v) do { \
    PACKED_glReplacementCodeuiColor4fNormal3fVertex3fvSUN *unpacked = (PACKED_glReplacementCodeuiColor4fNormal3fVertex3fvSUN *)packed; \
    ARGS_glReplacementCodeuiColor4fNormal3fVertex3fvSUN *args = (ARGS_glReplacementCodeuiColor4fNormal3fVertex3fvSUN *)&unpacked->args; \
    glReplacementCodeuiColor4fNormal3fVertex3fvSUN(args->rc, args->c, args->n, args->v);; \
} while(0)
void glReplacementCodeuiColor4fNormal3fVertex3fvSUN(glReplacementCodeuiColor4fNormal3fVertex3fvSUN_ARG_EXPAND);
typedef void (*glReplacementCodeuiColor4fNormal3fVertex3fvSUN_PTR)(glReplacementCodeuiColor4fNormal3fVertex3fvSUN_ARG_EXPAND);
#define glReplacementCodeuiColor4ubVertex3fSUN_INDEX 1822
#define glReplacementCodeuiColor4ubVertex3fSUN_RETURN void
#define glReplacementCodeuiColor4ubVertex3fSUN_ARG_NAMES rc, r, g, b, a, x, y, z
#define glReplacementCodeuiColor4ubVertex3fSUN_ARG_EXPAND GLuint rc, GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z
#define glReplacementCodeuiColor4ubVertex3fSUN_PACKED PACKED_glReplacementCodeuiColor4ubVertex3fSUN
#define glReplacementCodeuiColor4ubVertex3fSUN_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glReplacementCodeuiColor4ubVertex3fSUN_NOT_VOID_WRAP(...) {}
#define pack_glReplacementCodeuiColor4ubVertex3fSUN(_rc, _r, _g, _b, _a, _x, _y, _z) ({ \
    glReplacementCodeuiColor4ubVertex3fSUN_PACKED *packed_data = malloc(sizeof(glReplacementCodeuiColor4ubVertex3fSUN_PACKED)); \
    packed_data->index = glReplacementCodeuiColor4ubVertex3fSUN_INDEX; \
    packed_data->args.rc = (GLuint)_rc; \
    packed_data->args.r = (GLubyte)_r; \
    packed_data->args.g = (GLubyte)_g; \
    packed_data->args.b = (GLubyte)_b; \
    packed_data->args.a = (GLubyte)_a; \
    packed_data->args.x = (GLfloat)_x; \
    packed_data->args.y = (GLfloat)_y; \
    packed_data->args.z = (GLfloat)_z; \
    (packed_call_t *)packed_data; \
})
#define call_glReplacementCodeuiColor4ubVertex3fSUN(packed, ret_v) do { \
    PACKED_glReplacementCodeuiColor4ubVertex3fSUN *unpacked = (PACKED_glReplacementCodeuiColor4ubVertex3fSUN *)packed; \
    ARGS_glReplacementCodeuiColor4ubVertex3fSUN *args = (ARGS_glReplacementCodeuiColor4ubVertex3fSUN *)&unpacked->args; \
    glReplacementCodeuiColor4ubVertex3fSUN(args->rc, args->r, args->g, args->b, args->a, args->x, args->y, args->z);; \
} while(0)
void glReplacementCodeuiColor4ubVertex3fSUN(glReplacementCodeuiColor4ubVertex3fSUN_ARG_EXPAND);
typedef void (*glReplacementCodeuiColor4ubVertex3fSUN_PTR)(glReplacementCodeuiColor4ubVertex3fSUN_ARG_EXPAND);
#define glReplacementCodeuiColor4ubVertex3fvSUN_INDEX 1823
#define glReplacementCodeuiColor4ubVertex3fvSUN_RETURN void
#define glReplacementCodeuiColor4ubVertex3fvSUN_ARG_NAMES rc, c, v
#define glReplacementCodeuiColor4ubVertex3fvSUN_ARG_EXPAND const GLuint * rc, const GLubyte * c, const GLfloat * v
#define glReplacementCodeuiColor4ubVertex3fvSUN_PACKED PACKED_glReplacementCodeuiColor4ubVertex3fvSUN
#define glReplacementCodeuiColor4ubVertex3fvSUN_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glReplacementCodeuiColor4ubVertex3fvSUN_NOT_VOID_WRAP(...) {}
#define pack_glReplacementCodeuiColor4ubVertex3fvSUN(_rc, _c, _v) ({ \
    glReplacementCodeuiColor4ubVertex3fvSUN_PACKED *packed_data = malloc(sizeof(glReplacementCodeuiColor4ubVertex3fvSUN_PACKED)); \
    packed_data->index = glReplacementCodeuiColor4ubVertex3fvSUN_INDEX; \
    packed_data->args.rc = (GLuint *)_rc; \
    packed_data->args.c = (GLubyte *)_c; \
    packed_data->args.v = (GLfloat *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glReplacementCodeuiColor4ubVertex3fvSUN(packed, ret_v) do { \
    PACKED_glReplacementCodeuiColor4ubVertex3fvSUN *unpacked = (PACKED_glReplacementCodeuiColor4ubVertex3fvSUN *)packed; \
    ARGS_glReplacementCodeuiColor4ubVertex3fvSUN *args = (ARGS_glReplacementCodeuiColor4ubVertex3fvSUN *)&unpacked->args; \
    glReplacementCodeuiColor4ubVertex3fvSUN(args->rc, args->c, args->v);; \
} while(0)
void glReplacementCodeuiColor4ubVertex3fvSUN(glReplacementCodeuiColor4ubVertex3fvSUN_ARG_EXPAND);
typedef void (*glReplacementCodeuiColor4ubVertex3fvSUN_PTR)(glReplacementCodeuiColor4ubVertex3fvSUN_ARG_EXPAND);
#define glReplacementCodeuiNormal3fVertex3fSUN_INDEX 1824
#define glReplacementCodeuiNormal3fVertex3fSUN_RETURN void
#define glReplacementCodeuiNormal3fVertex3fSUN_ARG_NAMES rc, nx, ny, nz, x, y, z
#define glReplacementCodeuiNormal3fVertex3fSUN_ARG_EXPAND GLuint rc, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z
#define glReplacementCodeuiNormal3fVertex3fSUN_PACKED PACKED_glReplacementCodeuiNormal3fVertex3fSUN
#define glReplacementCodeuiNormal3fVertex3fSUN_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glReplacementCodeuiNormal3fVertex3fSUN_NOT_VOID_WRAP(...) {}
#define pack_glReplacementCodeuiNormal3fVertex3fSUN(_rc, _nx, _ny, _nz, _x, _y, _z) ({ \
    glReplacementCodeuiNormal3fVertex3fSUN_PACKED *packed_data = malloc(sizeof(glReplacementCodeuiNormal3fVertex3fSUN_PACKED)); \
    packed_data->index = glReplacementCodeuiNormal3fVertex3fSUN_INDEX; \
    packed_data->args.rc = (GLuint)_rc; \
    packed_data->args.nx = (GLfloat)_nx; \
    packed_data->args.ny = (GLfloat)_ny; \
    packed_data->args.nz = (GLfloat)_nz; \
    packed_data->args.x = (GLfloat)_x; \
    packed_data->args.y = (GLfloat)_y; \
    packed_data->args.z = (GLfloat)_z; \
    (packed_call_t *)packed_data; \
})
#define call_glReplacementCodeuiNormal3fVertex3fSUN(packed, ret_v) do { \
    PACKED_glReplacementCodeuiNormal3fVertex3fSUN *unpacked = (PACKED_glReplacementCodeuiNormal3fVertex3fSUN *)packed; \
    ARGS_glReplacementCodeuiNormal3fVertex3fSUN *args = (ARGS_glReplacementCodeuiNormal3fVertex3fSUN *)&unpacked->args; \
    glReplacementCodeuiNormal3fVertex3fSUN(args->rc, args->nx, args->ny, args->nz, args->x, args->y, args->z);; \
} while(0)
void glReplacementCodeuiNormal3fVertex3fSUN(glReplacementCodeuiNormal3fVertex3fSUN_ARG_EXPAND);
typedef void (*glReplacementCodeuiNormal3fVertex3fSUN_PTR)(glReplacementCodeuiNormal3fVertex3fSUN_ARG_EXPAND);
#define glReplacementCodeuiNormal3fVertex3fvSUN_INDEX 1825
#define glReplacementCodeuiNormal3fVertex3fvSUN_RETURN void
#define glReplacementCodeuiNormal3fVertex3fvSUN_ARG_NAMES rc, n, v
#define glReplacementCodeuiNormal3fVertex3fvSUN_ARG_EXPAND const GLuint * rc, const GLfloat * n, const GLfloat * v
#define glReplacementCodeuiNormal3fVertex3fvSUN_PACKED PACKED_glReplacementCodeuiNormal3fVertex3fvSUN
#define glReplacementCodeuiNormal3fVertex3fvSUN_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glReplacementCodeuiNormal3fVertex3fvSUN_NOT_VOID_WRAP(...) {}
#define pack_glReplacementCodeuiNormal3fVertex3fvSUN(_rc, _n, _v) ({ \
    glReplacementCodeuiNormal3fVertex3fvSUN_PACKED *packed_data = malloc(sizeof(glReplacementCodeuiNormal3fVertex3fvSUN_PACKED)); \
    packed_data->index = glReplacementCodeuiNormal3fVertex3fvSUN_INDEX; \
    packed_data->args.rc = (GLuint *)_rc; \
    packed_data->args.n = (GLfloat *)_n; \
    packed_data->args.v = (GLfloat *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glReplacementCodeuiNormal3fVertex3fvSUN(packed, ret_v) do { \
    PACKED_glReplacementCodeuiNormal3fVertex3fvSUN *unpacked = (PACKED_glReplacementCodeuiNormal3fVertex3fvSUN *)packed; \
    ARGS_glReplacementCodeuiNormal3fVertex3fvSUN *args = (ARGS_glReplacementCodeuiNormal3fVertex3fvSUN *)&unpacked->args; \
    glReplacementCodeuiNormal3fVertex3fvSUN(args->rc, args->n, args->v);; \
} while(0)
void glReplacementCodeuiNormal3fVertex3fvSUN(glReplacementCodeuiNormal3fVertex3fvSUN_ARG_EXPAND);
typedef void (*glReplacementCodeuiNormal3fVertex3fvSUN_PTR)(glReplacementCodeuiNormal3fVertex3fvSUN_ARG_EXPAND);
#define glReplacementCodeuiSUN_INDEX 1826
#define glReplacementCodeuiSUN_RETURN void
#define glReplacementCodeuiSUN_ARG_NAMES code
#define glReplacementCodeuiSUN_ARG_EXPAND GLuint code
#define glReplacementCodeuiSUN_PACKED PACKED_glReplacementCodeuiSUN
#define glReplacementCodeuiSUN_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glReplacementCodeuiSUN_NOT_VOID_WRAP(...) {}
#define pack_glReplacementCodeuiSUN(_code) ({ \
    glReplacementCodeuiSUN_PACKED *packed_data = malloc(sizeof(glReplacementCodeuiSUN_PACKED)); \
    packed_data->index = glReplacementCodeuiSUN_INDEX; \
    packed_data->args.code = (GLuint)_code; \
    (packed_call_t *)packed_data; \
})
#define call_glReplacementCodeuiSUN(packed, ret_v) do { \
    PACKED_glReplacementCodeuiSUN *unpacked = (PACKED_glReplacementCodeuiSUN *)packed; \
    ARGS_glReplacementCodeuiSUN *args = (ARGS_glReplacementCodeuiSUN *)&unpacked->args; \
    glReplacementCodeuiSUN(args->code);; \
} while(0)
void glReplacementCodeuiSUN(glReplacementCodeuiSUN_ARG_EXPAND);
typedef void (*glReplacementCodeuiSUN_PTR)(glReplacementCodeuiSUN_ARG_EXPAND);
#define glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN_INDEX 1827
#define glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN_RETURN void
#define glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN_ARG_NAMES rc, s, t, r, g, b, a, nx, ny, nz, x, y, z
#define glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN_ARG_EXPAND GLuint rc, GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z
#define glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN_PACKED PACKED_glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN
#define glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN_NOT_VOID_WRAP(...) {}
#define pack_glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN(_rc, _s, _t, _r, _g, _b, _a, _nx, _ny, _nz, _x, _y, _z) ({ \
    glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN_PACKED *packed_data = malloc(sizeof(glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN_PACKED)); \
    packed_data->index = glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN_INDEX; \
    packed_data->args.rc = (GLuint)_rc; \
    packed_data->args.s = (GLfloat)_s; \
    packed_data->args.t = (GLfloat)_t; \
    packed_data->args.r = (GLfloat)_r; \
    packed_data->args.g = (GLfloat)_g; \
    packed_data->args.b = (GLfloat)_b; \
    packed_data->args.a = (GLfloat)_a; \
    packed_data->args.nx = (GLfloat)_nx; \
    packed_data->args.ny = (GLfloat)_ny; \
    packed_data->args.nz = (GLfloat)_nz; \
    packed_data->args.x = (GLfloat)_x; \
    packed_data->args.y = (GLfloat)_y; \
    packed_data->args.z = (GLfloat)_z; \
    (packed_call_t *)packed_data; \
})
#define call_glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN(packed, ret_v) do { \
    PACKED_glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN *unpacked = (PACKED_glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN *)packed; \
    ARGS_glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN *args = (ARGS_glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN *)&unpacked->args; \
    glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN(args->rc, args->s, args->t, args->r, args->g, args->b, args->a, args->nx, args->ny, args->nz, args->x, args->y, args->z);; \
} while(0)
void glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN(glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN_ARG_EXPAND);
typedef void (*glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN_PTR)(glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN_ARG_EXPAND);
#define glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN_INDEX 1828
#define glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN_RETURN void
#define glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN_ARG_NAMES rc, tc, c, n, v
#define glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN_ARG_EXPAND const GLuint * rc, const GLfloat * tc, const GLfloat * c, const GLfloat * n, const GLfloat * v
#define glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN_PACKED PACKED_glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN
#define glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN_NOT_VOID_WRAP(...) {}
#define pack_glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(_rc, _tc, _c, _n, _v) ({ \
    glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN_PACKED *packed_data = malloc(sizeof(glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN_PACKED)); \
    packed_data->index = glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN_INDEX; \
    packed_data->args.rc = (GLuint *)_rc; \
    packed_data->args.tc = (GLfloat *)_tc; \
    packed_data->args.c = (GLfloat *)_c; \
    packed_data->args.n = (GLfloat *)_n; \
    packed_data->args.v = (GLfloat *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(packed, ret_v) do { \
    PACKED_glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN *unpacked = (PACKED_glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN *)packed; \
    ARGS_glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN *args = (ARGS_glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN *)&unpacked->args; \
    glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(args->rc, args->tc, args->c, args->n, args->v);; \
} while(0)
void glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN(glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN_ARG_EXPAND);
typedef void (*glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN_PTR)(glReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN_ARG_EXPAND);
#define glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN_INDEX 1829
#define glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN_RETURN void
#define glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN_ARG_NAMES rc, s, t, nx, ny, nz, x, y, z
#define glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN_ARG_EXPAND GLuint rc, GLfloat s, GLfloat t, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z
#define glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN_PACKED PACKED_glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN
#define glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN_NOT_VOID_WRAP(...) {}
#define pack_glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN(_rc, _s, _t, _nx, _ny, _nz, _x, _y, _z) ({ \
    glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN_PACKED *packed_data = malloc(sizeof(glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN_PACKED)); \
    packed_data->index = glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN_INDEX; \
    packed_data->args.rc = (GLuint)_rc; \
    packed_data->args.s = (GLfloat)_s; \
    packed_data->args.t = (GLfloat)_t; \
    packed_data->args.nx = (GLfloat)_nx; \
    packed_data->args.ny = (GLfloat)_ny; \
    packed_data->args.nz = (GLfloat)_nz; \
    packed_data->args.x = (GLfloat)_x; \
    packed_data->args.y = (GLfloat)_y; \
    packed_data->args.z = (GLfloat)_z; \
    (packed_call_t *)packed_data; \
})
#define call_glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN(packed, ret_v) do { \
    PACKED_glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN *unpacked = (PACKED_glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN *)packed; \
    ARGS_glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN *args = (ARGS_glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN *)&unpacked->args; \
    glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN(args->rc, args->s, args->t, args->nx, args->ny, args->nz, args->x, args->y, args->z);; \
} while(0)
void glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN(glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN_ARG_EXPAND);
typedef void (*glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN_PTR)(glReplacementCodeuiTexCoord2fNormal3fVertex3fSUN_ARG_EXPAND);
#define glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN_INDEX 1830
#define glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN_RETURN void
#define glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN_ARG_NAMES rc, tc, n, v
#define glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN_ARG_EXPAND const GLuint * rc, const GLfloat * tc, const GLfloat * n, const GLfloat * v
#define glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN_PACKED PACKED_glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN
#define glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN_NOT_VOID_WRAP(...) {}
#define pack_glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(_rc, _tc, _n, _v) ({ \
    glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN_PACKED *packed_data = malloc(sizeof(glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN_PACKED)); \
    packed_data->index = glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN_INDEX; \
    packed_data->args.rc = (GLuint *)_rc; \
    packed_data->args.tc = (GLfloat *)_tc; \
    packed_data->args.n = (GLfloat *)_n; \
    packed_data->args.v = (GLfloat *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(packed, ret_v) do { \
    PACKED_glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN *unpacked = (PACKED_glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN *)packed; \
    ARGS_glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN *args = (ARGS_glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN *)&unpacked->args; \
    glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(args->rc, args->tc, args->n, args->v);; \
} while(0)
void glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN(glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN_ARG_EXPAND);
typedef void (*glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN_PTR)(glReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN_ARG_EXPAND);
#define glReplacementCodeuiTexCoord2fVertex3fSUN_INDEX 1831
#define glReplacementCodeuiTexCoord2fVertex3fSUN_RETURN void
#define glReplacementCodeuiTexCoord2fVertex3fSUN_ARG_NAMES rc, s, t, x, y, z
#define glReplacementCodeuiTexCoord2fVertex3fSUN_ARG_EXPAND GLuint rc, GLfloat s, GLfloat t, GLfloat x, GLfloat y, GLfloat z
#define glReplacementCodeuiTexCoord2fVertex3fSUN_PACKED PACKED_glReplacementCodeuiTexCoord2fVertex3fSUN
#define glReplacementCodeuiTexCoord2fVertex3fSUN_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glReplacementCodeuiTexCoord2fVertex3fSUN_NOT_VOID_WRAP(...) {}
#define pack_glReplacementCodeuiTexCoord2fVertex3fSUN(_rc, _s, _t, _x, _y, _z) ({ \
    glReplacementCodeuiTexCoord2fVertex3fSUN_PACKED *packed_data = malloc(sizeof(glReplacementCodeuiTexCoord2fVertex3fSUN_PACKED)); \
    packed_data->index = glReplacementCodeuiTexCoord2fVertex3fSUN_INDEX; \
    packed_data->args.rc = (GLuint)_rc; \
    packed_data->args.s = (GLfloat)_s; \
    packed_data->args.t = (GLfloat)_t; \
    packed_data->args.x = (GLfloat)_x; \
    packed_data->args.y = (GLfloat)_y; \
    packed_data->args.z = (GLfloat)_z; \
    (packed_call_t *)packed_data; \
})
#define call_glReplacementCodeuiTexCoord2fVertex3fSUN(packed, ret_v) do { \
    PACKED_glReplacementCodeuiTexCoord2fVertex3fSUN *unpacked = (PACKED_glReplacementCodeuiTexCoord2fVertex3fSUN *)packed; \
    ARGS_glReplacementCodeuiTexCoord2fVertex3fSUN *args = (ARGS_glReplacementCodeuiTexCoord2fVertex3fSUN *)&unpacked->args; \
    glReplacementCodeuiTexCoord2fVertex3fSUN(args->rc, args->s, args->t, args->x, args->y, args->z);; \
} while(0)
void glReplacementCodeuiTexCoord2fVertex3fSUN(glReplacementCodeuiTexCoord2fVertex3fSUN_ARG_EXPAND);
typedef void (*glReplacementCodeuiTexCoord2fVertex3fSUN_PTR)(glReplacementCodeuiTexCoord2fVertex3fSUN_ARG_EXPAND);
#define glReplacementCodeuiTexCoord2fVertex3fvSUN_INDEX 1832
#define glReplacementCodeuiTexCoord2fVertex3fvSUN_RETURN void
#define glReplacementCodeuiTexCoord2fVertex3fvSUN_ARG_NAMES rc, tc, v
#define glReplacementCodeuiTexCoord2fVertex3fvSUN_ARG_EXPAND const GLuint * rc, const GLfloat * tc, const GLfloat * v
#define glReplacementCodeuiTexCoord2fVertex3fvSUN_PACKED PACKED_glReplacementCodeuiTexCoord2fVertex3fvSUN
#define glReplacementCodeuiTexCoord2fVertex3fvSUN_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glReplacementCodeuiTexCoord2fVertex3fvSUN_NOT_VOID_WRAP(...) {}
#define pack_glReplacementCodeuiTexCoord2fVertex3fvSUN(_rc, _tc, _v) ({ \
    glReplacementCodeuiTexCoord2fVertex3fvSUN_PACKED *packed_data = malloc(sizeof(glReplacementCodeuiTexCoord2fVertex3fvSUN_PACKED)); \
    packed_data->index = glReplacementCodeuiTexCoord2fVertex3fvSUN_INDEX; \
    packed_data->args.rc = (GLuint *)_rc; \
    packed_data->args.tc = (GLfloat *)_tc; \
    packed_data->args.v = (GLfloat *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glReplacementCodeuiTexCoord2fVertex3fvSUN(packed, ret_v) do { \
    PACKED_glReplacementCodeuiTexCoord2fVertex3fvSUN *unpacked = (PACKED_glReplacementCodeuiTexCoord2fVertex3fvSUN *)packed; \
    ARGS_glReplacementCodeuiTexCoord2fVertex3fvSUN *args = (ARGS_glReplacementCodeuiTexCoord2fVertex3fvSUN *)&unpacked->args; \
    glReplacementCodeuiTexCoord2fVertex3fvSUN(args->rc, args->tc, args->v);; \
} while(0)
void glReplacementCodeuiTexCoord2fVertex3fvSUN(glReplacementCodeuiTexCoord2fVertex3fvSUN_ARG_EXPAND);
typedef void (*glReplacementCodeuiTexCoord2fVertex3fvSUN_PTR)(glReplacementCodeuiTexCoord2fVertex3fvSUN_ARG_EXPAND);
#define glReplacementCodeuiVertex3fSUN_INDEX 1833
#define glReplacementCodeuiVertex3fSUN_RETURN void
#define glReplacementCodeuiVertex3fSUN_ARG_NAMES rc, x, y, z
#define glReplacementCodeuiVertex3fSUN_ARG_EXPAND GLuint rc, GLfloat x, GLfloat y, GLfloat z
#define glReplacementCodeuiVertex3fSUN_PACKED PACKED_glReplacementCodeuiVertex3fSUN
#define glReplacementCodeuiVertex3fSUN_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glReplacementCodeuiVertex3fSUN_NOT_VOID_WRAP(...) {}
#define pack_glReplacementCodeuiVertex3fSUN(_rc, _x, _y, _z) ({ \
    glReplacementCodeuiVertex3fSUN_PACKED *packed_data = malloc(sizeof(glReplacementCodeuiVertex3fSUN_PACKED)); \
    packed_data->index = glReplacementCodeuiVertex3fSUN_INDEX; \
    packed_data->args.rc = (GLuint)_rc; \
    packed_data->args.x = (GLfloat)_x; \
    packed_data->args.y = (GLfloat)_y; \
    packed_data->args.z = (GLfloat)_z; \
    (packed_call_t *)packed_data; \
})
#define call_glReplacementCodeuiVertex3fSUN(packed, ret_v) do { \
    PACKED_glReplacementCodeuiVertex3fSUN *unpacked = (PACKED_glReplacementCodeuiVertex3fSUN *)packed; \
    ARGS_glReplacementCodeuiVertex3fSUN *args = (ARGS_glReplacementCodeuiVertex3fSUN *)&unpacked->args; \
    glReplacementCodeuiVertex3fSUN(args->rc, args->x, args->y, args->z);; \
} while(0)
void glReplacementCodeuiVertex3fSUN(glReplacementCodeuiVertex3fSUN_ARG_EXPAND);
typedef void (*glReplacementCodeuiVertex3fSUN_PTR)(glReplacementCodeuiVertex3fSUN_ARG_EXPAND);
#define glReplacementCodeuiVertex3fvSUN_INDEX 1834
#define glReplacementCodeuiVertex3fvSUN_RETURN void
#define glReplacementCodeuiVertex3fvSUN_ARG_NAMES rc, v
#define glReplacementCodeuiVertex3fvSUN_ARG_EXPAND const GLuint * rc, const GLfloat * v
#define glReplacementCodeuiVertex3fvSUN_PACKED PACKED_glReplacementCodeuiVertex3fvSUN
#define glReplacementCodeuiVertex3fvSUN_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glReplacementCodeuiVertex3fvSUN_NOT_VOID_WRAP(...) {}
#define pack_glReplacementCodeuiVertex3fvSUN(_rc, _v) ({ \
    glReplacementCodeuiVertex3fvSUN_PACKED *packed_data = malloc(sizeof(glReplacementCodeuiVertex3fvSUN_PACKED)); \
    packed_data->index = glReplacementCodeuiVertex3fvSUN_INDEX; \
    packed_data->args.rc = (GLuint *)_rc; \
    packed_data->args.v = (GLfloat *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glReplacementCodeuiVertex3fvSUN(packed, ret_v) do { \
    PACKED_glReplacementCodeuiVertex3fvSUN *unpacked = (PACKED_glReplacementCodeuiVertex3fvSUN *)packed; \
    ARGS_glReplacementCodeuiVertex3fvSUN *args = (ARGS_glReplacementCodeuiVertex3fvSUN *)&unpacked->args; \
    glReplacementCodeuiVertex3fvSUN(args->rc, args->v);; \
} while(0)
void glReplacementCodeuiVertex3fvSUN(glReplacementCodeuiVertex3fvSUN_ARG_EXPAND);
typedef void (*glReplacementCodeuiVertex3fvSUN_PTR)(glReplacementCodeuiVertex3fvSUN_ARG_EXPAND);
#define glReplacementCodeuivSUN_INDEX 1835
#define glReplacementCodeuivSUN_RETURN void
#define glReplacementCodeuivSUN_ARG_NAMES code
#define glReplacementCodeuivSUN_ARG_EXPAND const GLuint * code
#define glReplacementCodeuivSUN_PACKED PACKED_glReplacementCodeuivSUN
#define glReplacementCodeuivSUN_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glReplacementCodeuivSUN_NOT_VOID_WRAP(...) {}
#define pack_glReplacementCodeuivSUN(_code) ({ \
    glReplacementCodeuivSUN_PACKED *packed_data = malloc(sizeof(glReplacementCodeuivSUN_PACKED)); \
    packed_data->index = glReplacementCodeuivSUN_INDEX; \
    packed_data->args.code = (GLuint *)_code; \
    (packed_call_t *)packed_data; \
})
#define call_glReplacementCodeuivSUN(packed, ret_v) do { \
    PACKED_glReplacementCodeuivSUN *unpacked = (PACKED_glReplacementCodeuivSUN *)packed; \
    ARGS_glReplacementCodeuivSUN *args = (ARGS_glReplacementCodeuivSUN *)&unpacked->args; \
    glReplacementCodeuivSUN(args->code);; \
} while(0)
void glReplacementCodeuivSUN(glReplacementCodeuivSUN_ARG_EXPAND);
typedef void (*glReplacementCodeuivSUN_PTR)(glReplacementCodeuivSUN_ARG_EXPAND);
#define glReplacementCodeusSUN_INDEX 1836
#define glReplacementCodeusSUN_RETURN void
#define glReplacementCodeusSUN_ARG_NAMES code
#define glReplacementCodeusSUN_ARG_EXPAND GLushort code
#define glReplacementCodeusSUN_PACKED PACKED_glReplacementCodeusSUN
#define glReplacementCodeusSUN_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glReplacementCodeusSUN_NOT_VOID_WRAP(...) {}
#define pack_glReplacementCodeusSUN(_code) ({ \
    glReplacementCodeusSUN_PACKED *packed_data = malloc(sizeof(glReplacementCodeusSUN_PACKED)); \
    packed_data->index = glReplacementCodeusSUN_INDEX; \
    packed_data->args.code = (GLushort)_code; \
    (packed_call_t *)packed_data; \
})
#define call_glReplacementCodeusSUN(packed, ret_v) do { \
    PACKED_glReplacementCodeusSUN *unpacked = (PACKED_glReplacementCodeusSUN *)packed; \
    ARGS_glReplacementCodeusSUN *args = (ARGS_glReplacementCodeusSUN *)&unpacked->args; \
    glReplacementCodeusSUN(args->code);; \
} while(0)
void glReplacementCodeusSUN(glReplacementCodeusSUN_ARG_EXPAND);
typedef void (*glReplacementCodeusSUN_PTR)(glReplacementCodeusSUN_ARG_EXPAND);
#define glReplacementCodeusvSUN_INDEX 1837
#define glReplacementCodeusvSUN_RETURN void
#define glReplacementCodeusvSUN_ARG_NAMES code
#define glReplacementCodeusvSUN_ARG_EXPAND const GLushort * code
#define glReplacementCodeusvSUN_PACKED PACKED_glReplacementCodeusvSUN
#define glReplacementCodeusvSUN_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glReplacementCodeusvSUN_NOT_VOID_WRAP(...) {}
#define pack_glReplacementCodeusvSUN(_code) ({ \
    glReplacementCodeusvSUN_PACKED *packed_data = malloc(sizeof(glReplacementCodeusvSUN_PACKED)); \
    packed_data->index = glReplacementCodeusvSUN_INDEX; \
    packed_data->args.code = (GLushort *)_code; \
    (packed_call_t *)packed_data; \
})
#define call_glReplacementCodeusvSUN(packed, ret_v) do { \
    PACKED_glReplacementCodeusvSUN *unpacked = (PACKED_glReplacementCodeusvSUN *)packed; \
    ARGS_glReplacementCodeusvSUN *args = (ARGS_glReplacementCodeusvSUN *)&unpacked->args; \
    glReplacementCodeusvSUN(args->code);; \
} while(0)
void glReplacementCodeusvSUN(glReplacementCodeusvSUN_ARG_EXPAND);
typedef void (*glReplacementCodeusvSUN_PTR)(glReplacementCodeusvSUN_ARG_EXPAND);
#define glRequestResidentProgramsNV_INDEX 1838
#define glRequestResidentProgramsNV_RETURN void
#define glRequestResidentProgramsNV_ARG_NAMES n, programs
#define glRequestResidentProgramsNV_ARG_EXPAND GLsizei n, const GLuint * programs
#define glRequestResidentProgramsNV_PACKED PACKED_glRequestResidentProgramsNV
#define glRequestResidentProgramsNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glRequestResidentProgramsNV_NOT_VOID_WRAP(...) {}
#define pack_glRequestResidentProgramsNV(_n, _programs) ({ \
    glRequestResidentProgramsNV_PACKED *packed_data = malloc(sizeof(glRequestResidentProgramsNV_PACKED)); \
    packed_data->index = glRequestResidentProgramsNV_INDEX; \
    packed_data->args.n = (GLsizei)_n; \
    packed_data->args.programs = (GLuint *)_programs; \
    (packed_call_t *)packed_data; \
})
#define call_glRequestResidentProgramsNV(packed, ret_v) do { \
    PACKED_glRequestResidentProgramsNV *unpacked = (PACKED_glRequestResidentProgramsNV *)packed; \
    ARGS_glRequestResidentProgramsNV *args = (ARGS_glRequestResidentProgramsNV *)&unpacked->args; \
    glRequestResidentProgramsNV(args->n, args->programs);; \
} while(0)
void glRequestResidentProgramsNV(glRequestResidentProgramsNV_ARG_EXPAND);
typedef void (*glRequestResidentProgramsNV_PTR)(glRequestResidentProgramsNV_ARG_EXPAND);
#define glResetHistogram_INDEX 1839
#define glResetHistogram_RETURN void
#define glResetHistogram_ARG_NAMES target
#define glResetHistogram_ARG_EXPAND GLenum target
#define glResetHistogram_PACKED PACKED_glResetHistogram
#define glResetHistogram_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glResetHistogram_NOT_VOID_WRAP(...) {}
#define pack_glResetHistogram(_target) ({ \
    glResetHistogram_PACKED *packed_data = malloc(sizeof(glResetHistogram_PACKED)); \
    packed_data->index = glResetHistogram_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    (packed_call_t *)packed_data; \
})
#define call_glResetHistogram(packed, ret_v) do { \
    PACKED_glResetHistogram *unpacked = (PACKED_glResetHistogram *)packed; \
    ARGS_glResetHistogram *args = (ARGS_glResetHistogram *)&unpacked->args; \
    glResetHistogram(args->target);; \
} while(0)
void glResetHistogram(glResetHistogram_ARG_EXPAND);
typedef void (*glResetHistogram_PTR)(glResetHistogram_ARG_EXPAND);
#define glResetHistogramEXT_INDEX 1840
#define glResetHistogramEXT_RETURN void
#define glResetHistogramEXT_ARG_NAMES target
#define glResetHistogramEXT_ARG_EXPAND GLenum target
#define glResetHistogramEXT_PACKED PACKED_glResetHistogramEXT
#define glResetHistogramEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glResetHistogramEXT_NOT_VOID_WRAP(...) {}
#define pack_glResetHistogramEXT(_target) ({ \
    glResetHistogramEXT_PACKED *packed_data = malloc(sizeof(glResetHistogramEXT_PACKED)); \
    packed_data->index = glResetHistogramEXT_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    (packed_call_t *)packed_data; \
})
#define call_glResetHistogramEXT(packed, ret_v) do { \
    PACKED_glResetHistogramEXT *unpacked = (PACKED_glResetHistogramEXT *)packed; \
    ARGS_glResetHistogramEXT *args = (ARGS_glResetHistogramEXT *)&unpacked->args; \
    glResetHistogramEXT(args->target);; \
} while(0)
void glResetHistogramEXT(glResetHistogramEXT_ARG_EXPAND);
typedef void (*glResetHistogramEXT_PTR)(glResetHistogramEXT_ARG_EXPAND);
#define glResetMinmax_INDEX 1841
#define glResetMinmax_RETURN void
#define glResetMinmax_ARG_NAMES target
#define glResetMinmax_ARG_EXPAND GLenum target
#define glResetMinmax_PACKED PACKED_glResetMinmax
#define glResetMinmax_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glResetMinmax_NOT_VOID_WRAP(...) {}
#define pack_glResetMinmax(_target) ({ \
    glResetMinmax_PACKED *packed_data = malloc(sizeof(glResetMinmax_PACKED)); \
    packed_data->index = glResetMinmax_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    (packed_call_t *)packed_data; \
})
#define call_glResetMinmax(packed, ret_v) do { \
    PACKED_glResetMinmax *unpacked = (PACKED_glResetMinmax *)packed; \
    ARGS_glResetMinmax *args = (ARGS_glResetMinmax *)&unpacked->args; \
    glResetMinmax(args->target);; \
} while(0)
void glResetMinmax(glResetMinmax_ARG_EXPAND);
typedef void (*glResetMinmax_PTR)(glResetMinmax_ARG_EXPAND);
#define glResetMinmaxEXT_INDEX 1842
#define glResetMinmaxEXT_RETURN void
#define glResetMinmaxEXT_ARG_NAMES target
#define glResetMinmaxEXT_ARG_EXPAND GLenum target
#define glResetMinmaxEXT_PACKED PACKED_glResetMinmaxEXT
#define glResetMinmaxEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glResetMinmaxEXT_NOT_VOID_WRAP(...) {}
#define pack_glResetMinmaxEXT(_target) ({ \
    glResetMinmaxEXT_PACKED *packed_data = malloc(sizeof(glResetMinmaxEXT_PACKED)); \
    packed_data->index = glResetMinmaxEXT_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    (packed_call_t *)packed_data; \
})
#define call_glResetMinmaxEXT(packed, ret_v) do { \
    PACKED_glResetMinmaxEXT *unpacked = (PACKED_glResetMinmaxEXT *)packed; \
    ARGS_glResetMinmaxEXT *args = (ARGS_glResetMinmaxEXT *)&unpacked->args; \
    glResetMinmaxEXT(args->target);; \
} while(0)
void glResetMinmaxEXT(glResetMinmaxEXT_ARG_EXPAND);
typedef void (*glResetMinmaxEXT_PTR)(glResetMinmaxEXT_ARG_EXPAND);
#define glResizeBuffersMESA_INDEX 1843
#define glResizeBuffersMESA_RETURN void
#define glResizeBuffersMESA_ARG_NAMES 
#define glResizeBuffersMESA_ARG_EXPAND 
#define glResizeBuffersMESA_PACKED PACKED_glResizeBuffersMESA
#define glResizeBuffersMESA_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glResizeBuffersMESA_NOT_VOID_WRAP(...) {}
#define pack_glResizeBuffersMESA() ({ \
    glResizeBuffersMESA_PACKED *packed_data = malloc(sizeof(glResizeBuffersMESA_PACKED)); \
    packed_data->index = glResizeBuffersMESA_INDEX; \
    (packed_call_t *)packed_data; \
})
#define call_glResizeBuffersMESA(packed, ret_v) do { \
    glResizeBuffersMESA();; \
} while(0)
void glResizeBuffersMESA(glResizeBuffersMESA_ARG_EXPAND);
typedef void (*glResizeBuffersMESA_PTR)(glResizeBuffersMESA_ARG_EXPAND);
#define glResumeTransformFeedback_INDEX 1844
#define glResumeTransformFeedback_RETURN void
#define glResumeTransformFeedback_ARG_NAMES 
#define glResumeTransformFeedback_ARG_EXPAND 
#define glResumeTransformFeedback_PACKED PACKED_glResumeTransformFeedback
#define glResumeTransformFeedback_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glResumeTransformFeedback_NOT_VOID_WRAP(...) {}
#define pack_glResumeTransformFeedback() ({ \
    glResumeTransformFeedback_PACKED *packed_data = malloc(sizeof(glResumeTransformFeedback_PACKED)); \
    packed_data->index = glResumeTransformFeedback_INDEX; \
    (packed_call_t *)packed_data; \
})
#define call_glResumeTransformFeedback(packed, ret_v) do { \
    glResumeTransformFeedback();; \
} while(0)
void glResumeTransformFeedback(glResumeTransformFeedback_ARG_EXPAND);
typedef void (*glResumeTransformFeedback_PTR)(glResumeTransformFeedback_ARG_EXPAND);
#define glResumeTransformFeedbackNV_INDEX 1845
#define glResumeTransformFeedbackNV_RETURN void
#define glResumeTransformFeedbackNV_ARG_NAMES 
#define glResumeTransformFeedbackNV_ARG_EXPAND 
#define glResumeTransformFeedbackNV_PACKED PACKED_glResumeTransformFeedbackNV
#define glResumeTransformFeedbackNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glResumeTransformFeedbackNV_NOT_VOID_WRAP(...) {}
#define pack_glResumeTransformFeedbackNV() ({ \
    glResumeTransformFeedbackNV_PACKED *packed_data = malloc(sizeof(glResumeTransformFeedbackNV_PACKED)); \
    packed_data->index = glResumeTransformFeedbackNV_INDEX; \
    (packed_call_t *)packed_data; \
})
#define call_glResumeTransformFeedbackNV(packed, ret_v) do { \
    glResumeTransformFeedbackNV();; \
} while(0)
void glResumeTransformFeedbackNV(glResumeTransformFeedbackNV_ARG_EXPAND);
typedef void (*glResumeTransformFeedbackNV_PTR)(glResumeTransformFeedbackNV_ARG_EXPAND);
#define glRotated_INDEX 1846
#define glRotated_RETURN void
#define glRotated_ARG_NAMES angle, x, y, z
#define glRotated_ARG_EXPAND GLdouble angle, GLdouble x, GLdouble y, GLdouble z
#define glRotated_PACKED PACKED_glRotated
#define glRotated_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glRotated_NOT_VOID_WRAP(...) {}
#define pack_glRotated(_angle, _x, _y, _z) ({ \
    glRotated_PACKED *packed_data = malloc(sizeof(glRotated_PACKED)); \
    packed_data->index = glRotated_INDEX; \
    packed_data->args.angle = (GLdouble)_angle; \
    packed_data->args.x = (GLdouble)_x; \
    packed_data->args.y = (GLdouble)_y; \
    packed_data->args.z = (GLdouble)_z; \
    (packed_call_t *)packed_data; \
})
#define call_glRotated(packed, ret_v) do { \
    PACKED_glRotated *unpacked = (PACKED_glRotated *)packed; \
    ARGS_glRotated *args = (ARGS_glRotated *)&unpacked->args; \
    glRotated(args->angle, args->x, args->y, args->z);; \
} while(0)
void glRotated(glRotated_ARG_EXPAND);
typedef void (*glRotated_PTR)(glRotated_ARG_EXPAND);
#define glRotatef_INDEX 1847
#define glRotatef_RETURN void
#define glRotatef_ARG_NAMES angle, x, y, z
#define glRotatef_ARG_EXPAND GLfloat angle, GLfloat x, GLfloat y, GLfloat z
#define glRotatef_PACKED PACKED_glRotatef
#define glRotatef_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glRotatef_NOT_VOID_WRAP(...) {}
#define pack_glRotatef(_angle, _x, _y, _z) ({ \
    glRotatef_PACKED *packed_data = malloc(sizeof(glRotatef_PACKED)); \
    packed_data->index = glRotatef_INDEX; \
    packed_data->args.angle = (GLfloat)_angle; \
    packed_data->args.x = (GLfloat)_x; \
    packed_data->args.y = (GLfloat)_y; \
    packed_data->args.z = (GLfloat)_z; \
    (packed_call_t *)packed_data; \
})
#define call_glRotatef(packed, ret_v) do { \
    PACKED_glRotatef *unpacked = (PACKED_glRotatef *)packed; \
    ARGS_glRotatef *args = (ARGS_glRotatef *)&unpacked->args; \
    glRotatef(args->angle, args->x, args->y, args->z);; \
} while(0)
void glRotatef(glRotatef_ARG_EXPAND);
typedef void (*glRotatef_PTR)(glRotatef_ARG_EXPAND);
#define glRotatex_INDEX 1848
#define glRotatex_RETURN void
#define glRotatex_ARG_NAMES angle, x, y, z
#define glRotatex_ARG_EXPAND GLfixed angle, GLfixed x, GLfixed y, GLfixed z
#define glRotatex_PACKED PACKED_glRotatex
#define glRotatex_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glRotatex_NOT_VOID_WRAP(...) {}
#define pack_glRotatex(_angle, _x, _y, _z) ({ \
    glRotatex_PACKED *packed_data = malloc(sizeof(glRotatex_PACKED)); \
    packed_data->index = glRotatex_INDEX; \
    packed_data->args.angle = (GLfixed)_angle; \
    packed_data->args.x = (GLfixed)_x; \
    packed_data->args.y = (GLfixed)_y; \
    packed_data->args.z = (GLfixed)_z; \
    (packed_call_t *)packed_data; \
})
#define call_glRotatex(packed, ret_v) do { \
    PACKED_glRotatex *unpacked = (PACKED_glRotatex *)packed; \
    ARGS_glRotatex *args = (ARGS_glRotatex *)&unpacked->args; \
    glRotatex(args->angle, args->x, args->y, args->z);; \
} while(0)
void glRotatex(glRotatex_ARG_EXPAND);
typedef void (*glRotatex_PTR)(glRotatex_ARG_EXPAND);
#define glRotatexOES_INDEX 1849
#define glRotatexOES_RETURN void
#define glRotatexOES_ARG_NAMES angle, x, y, z
#define glRotatexOES_ARG_EXPAND GLfixed angle, GLfixed x, GLfixed y, GLfixed z
#define glRotatexOES_PACKED PACKED_glRotatexOES
#define glRotatexOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glRotatexOES_NOT_VOID_WRAP(...) {}
#define pack_glRotatexOES(_angle, _x, _y, _z) ({ \
    glRotatexOES_PACKED *packed_data = malloc(sizeof(glRotatexOES_PACKED)); \
    packed_data->index = glRotatexOES_INDEX; \
    packed_data->args.angle = (GLfixed)_angle; \
    packed_data->args.x = (GLfixed)_x; \
    packed_data->args.y = (GLfixed)_y; \
    packed_data->args.z = (GLfixed)_z; \
    (packed_call_t *)packed_data; \
})
#define call_glRotatexOES(packed, ret_v) do { \
    PACKED_glRotatexOES *unpacked = (PACKED_glRotatexOES *)packed; \
    ARGS_glRotatexOES *args = (ARGS_glRotatexOES *)&unpacked->args; \
    glRotatexOES(args->angle, args->x, args->y, args->z);; \
} while(0)
void glRotatexOES(glRotatexOES_ARG_EXPAND);
typedef void (*glRotatexOES_PTR)(glRotatexOES_ARG_EXPAND);
#define glSampleCoverage_INDEX 1850
#define glSampleCoverage_RETURN void
#define glSampleCoverage_ARG_NAMES value, invert
#define glSampleCoverage_ARG_EXPAND GLclampf value, GLboolean invert
#define glSampleCoverage_PACKED PACKED_glSampleCoverage
#define glSampleCoverage_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glSampleCoverage_NOT_VOID_WRAP(...) {}
#define pack_glSampleCoverage(_value, _invert) ({ \
    glSampleCoverage_PACKED *packed_data = malloc(sizeof(glSampleCoverage_PACKED)); \
    packed_data->index = glSampleCoverage_INDEX; \
    packed_data->args.value = (GLclampf)_value; \
    packed_data->args.invert = (GLboolean)_invert; \
    (packed_call_t *)packed_data; \
})
#define call_glSampleCoverage(packed, ret_v) do { \
    PACKED_glSampleCoverage *unpacked = (PACKED_glSampleCoverage *)packed; \
    ARGS_glSampleCoverage *args = (ARGS_glSampleCoverage *)&unpacked->args; \
    glSampleCoverage(args->value, args->invert);; \
} while(0)
void glSampleCoverage(glSampleCoverage_ARG_EXPAND);
typedef void (*glSampleCoverage_PTR)(glSampleCoverage_ARG_EXPAND);
#define glSampleCoverageARB_INDEX 1851
#define glSampleCoverageARB_RETURN void
#define glSampleCoverageARB_ARG_NAMES value, invert
#define glSampleCoverageARB_ARG_EXPAND GLfloat value, GLboolean invert
#define glSampleCoverageARB_PACKED PACKED_glSampleCoverageARB
#define glSampleCoverageARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glSampleCoverageARB_NOT_VOID_WRAP(...) {}
#define pack_glSampleCoverageARB(_value, _invert) ({ \
    glSampleCoverageARB_PACKED *packed_data = malloc(sizeof(glSampleCoverageARB_PACKED)); \
    packed_data->index = glSampleCoverageARB_INDEX; \
    packed_data->args.value = (GLfloat)_value; \
    packed_data->args.invert = (GLboolean)_invert; \
    (packed_call_t *)packed_data; \
})
#define call_glSampleCoverageARB(packed, ret_v) do { \
    PACKED_glSampleCoverageARB *unpacked = (PACKED_glSampleCoverageARB *)packed; \
    ARGS_glSampleCoverageARB *args = (ARGS_glSampleCoverageARB *)&unpacked->args; \
    glSampleCoverageARB(args->value, args->invert);; \
} while(0)
void glSampleCoverageARB(glSampleCoverageARB_ARG_EXPAND);
typedef void (*glSampleCoverageARB_PTR)(glSampleCoverageARB_ARG_EXPAND);
#define glSampleCoverageOES_INDEX 1852
#define glSampleCoverageOES_RETURN void
#define glSampleCoverageOES_ARG_NAMES value, invert
#define glSampleCoverageOES_ARG_EXPAND GLfixed value, GLboolean invert
#define glSampleCoverageOES_PACKED PACKED_glSampleCoverageOES
#define glSampleCoverageOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glSampleCoverageOES_NOT_VOID_WRAP(...) {}
#define pack_glSampleCoverageOES(_value, _invert) ({ \
    glSampleCoverageOES_PACKED *packed_data = malloc(sizeof(glSampleCoverageOES_PACKED)); \
    packed_data->index = glSampleCoverageOES_INDEX; \
    packed_data->args.value = (GLfixed)_value; \
    packed_data->args.invert = (GLboolean)_invert; \
    (packed_call_t *)packed_data; \
})
#define call_glSampleCoverageOES(packed, ret_v) do { \
    PACKED_glSampleCoverageOES *unpacked = (PACKED_glSampleCoverageOES *)packed; \
    ARGS_glSampleCoverageOES *args = (ARGS_glSampleCoverageOES *)&unpacked->args; \
    glSampleCoverageOES(args->value, args->invert);; \
} while(0)
void glSampleCoverageOES(glSampleCoverageOES_ARG_EXPAND);
typedef void (*glSampleCoverageOES_PTR)(glSampleCoverageOES_ARG_EXPAND);
#define glSampleCoveragex_INDEX 1853
#define glSampleCoveragex_RETURN void
#define glSampleCoveragex_ARG_NAMES value, invert
#define glSampleCoveragex_ARG_EXPAND GLclampx value, GLboolean invert
#define glSampleCoveragex_PACKED PACKED_glSampleCoveragex
#define glSampleCoveragex_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glSampleCoveragex_NOT_VOID_WRAP(...) {}
#define pack_glSampleCoveragex(_value, _invert) ({ \
    glSampleCoveragex_PACKED *packed_data = malloc(sizeof(glSampleCoveragex_PACKED)); \
    packed_data->index = glSampleCoveragex_INDEX; \
    packed_data->args.value = (GLclampx)_value; \
    packed_data->args.invert = (GLboolean)_invert; \
    (packed_call_t *)packed_data; \
})
#define call_glSampleCoveragex(packed, ret_v) do { \
    PACKED_glSampleCoveragex *unpacked = (PACKED_glSampleCoveragex *)packed; \
    ARGS_glSampleCoveragex *args = (ARGS_glSampleCoveragex *)&unpacked->args; \
    glSampleCoveragex(args->value, args->invert);; \
} while(0)
void glSampleCoveragex(glSampleCoveragex_ARG_EXPAND);
typedef void (*glSampleCoveragex_PTR)(glSampleCoveragex_ARG_EXPAND);
#define glSampleMapATI_INDEX 1854
#define glSampleMapATI_RETURN void
#define glSampleMapATI_ARG_NAMES dst, interp, swizzle
#define glSampleMapATI_ARG_EXPAND GLuint dst, GLuint interp, GLenum swizzle
#define glSampleMapATI_PACKED PACKED_glSampleMapATI
#define glSampleMapATI_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glSampleMapATI_NOT_VOID_WRAP(...) {}
#define pack_glSampleMapATI(_dst, _interp, _swizzle) ({ \
    glSampleMapATI_PACKED *packed_data = malloc(sizeof(glSampleMapATI_PACKED)); \
    packed_data->index = glSampleMapATI_INDEX; \
    packed_data->args.dst = (GLuint)_dst; \
    packed_data->args.interp = (GLuint)_interp; \
    packed_data->args.swizzle = (GLenum)_swizzle; \
    (packed_call_t *)packed_data; \
})
#define call_glSampleMapATI(packed, ret_v) do { \
    PACKED_glSampleMapATI *unpacked = (PACKED_glSampleMapATI *)packed; \
    ARGS_glSampleMapATI *args = (ARGS_glSampleMapATI *)&unpacked->args; \
    glSampleMapATI(args->dst, args->interp, args->swizzle);; \
} while(0)
void glSampleMapATI(glSampleMapATI_ARG_EXPAND);
typedef void (*glSampleMapATI_PTR)(glSampleMapATI_ARG_EXPAND);
#define glSampleMaskEXT_INDEX 1855
#define glSampleMaskEXT_RETURN void
#define glSampleMaskEXT_ARG_NAMES value, invert
#define glSampleMaskEXT_ARG_EXPAND GLclampf value, GLboolean invert
#define glSampleMaskEXT_PACKED PACKED_glSampleMaskEXT
#define glSampleMaskEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glSampleMaskEXT_NOT_VOID_WRAP(...) {}
#define pack_glSampleMaskEXT(_value, _invert) ({ \
    glSampleMaskEXT_PACKED *packed_data = malloc(sizeof(glSampleMaskEXT_PACKED)); \
    packed_data->index = glSampleMaskEXT_INDEX; \
    packed_data->args.value = (GLclampf)_value; \
    packed_data->args.invert = (GLboolean)_invert; \
    (packed_call_t *)packed_data; \
})
#define call_glSampleMaskEXT(packed, ret_v) do { \
    PACKED_glSampleMaskEXT *unpacked = (PACKED_glSampleMaskEXT *)packed; \
    ARGS_glSampleMaskEXT *args = (ARGS_glSampleMaskEXT *)&unpacked->args; \
    glSampleMaskEXT(args->value, args->invert);; \
} while(0)
void glSampleMaskEXT(glSampleMaskEXT_ARG_EXPAND);
typedef void (*glSampleMaskEXT_PTR)(glSampleMaskEXT_ARG_EXPAND);
#define glSampleMaskIndexedNV_INDEX 1856
#define glSampleMaskIndexedNV_RETURN void
#define glSampleMaskIndexedNV_ARG_NAMES index, mask
#define glSampleMaskIndexedNV_ARG_EXPAND GLuint index, GLbitfield mask
#define glSampleMaskIndexedNV_PACKED PACKED_glSampleMaskIndexedNV
#define glSampleMaskIndexedNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glSampleMaskIndexedNV_NOT_VOID_WRAP(...) {}
#define pack_glSampleMaskIndexedNV(_index, _mask) ({ \
    glSampleMaskIndexedNV_PACKED *packed_data = malloc(sizeof(glSampleMaskIndexedNV_PACKED)); \
    packed_data->index = glSampleMaskIndexedNV_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.mask = (GLbitfield)_mask; \
    (packed_call_t *)packed_data; \
})
#define call_glSampleMaskIndexedNV(packed, ret_v) do { \
    PACKED_glSampleMaskIndexedNV *unpacked = (PACKED_glSampleMaskIndexedNV *)packed; \
    ARGS_glSampleMaskIndexedNV *args = (ARGS_glSampleMaskIndexedNV *)&unpacked->args; \
    glSampleMaskIndexedNV(args->index, args->mask);; \
} while(0)
void glSampleMaskIndexedNV(glSampleMaskIndexedNV_ARG_EXPAND);
typedef void (*glSampleMaskIndexedNV_PTR)(glSampleMaskIndexedNV_ARG_EXPAND);
#define glSampleMaskSGIS_INDEX 1857
#define glSampleMaskSGIS_RETURN void
#define glSampleMaskSGIS_ARG_NAMES value, invert
#define glSampleMaskSGIS_ARG_EXPAND GLclampf value, GLboolean invert
#define glSampleMaskSGIS_PACKED PACKED_glSampleMaskSGIS
#define glSampleMaskSGIS_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glSampleMaskSGIS_NOT_VOID_WRAP(...) {}
#define pack_glSampleMaskSGIS(_value, _invert) ({ \
    glSampleMaskSGIS_PACKED *packed_data = malloc(sizeof(glSampleMaskSGIS_PACKED)); \
    packed_data->index = glSampleMaskSGIS_INDEX; \
    packed_data->args.value = (GLclampf)_value; \
    packed_data->args.invert = (GLboolean)_invert; \
    (packed_call_t *)packed_data; \
})
#define call_glSampleMaskSGIS(packed, ret_v) do { \
    PACKED_glSampleMaskSGIS *unpacked = (PACKED_glSampleMaskSGIS *)packed; \
    ARGS_glSampleMaskSGIS *args = (ARGS_glSampleMaskSGIS *)&unpacked->args; \
    glSampleMaskSGIS(args->value, args->invert);; \
} while(0)
void glSampleMaskSGIS(glSampleMaskSGIS_ARG_EXPAND);
typedef void (*glSampleMaskSGIS_PTR)(glSampleMaskSGIS_ARG_EXPAND);
#define glSampleMaski_INDEX 1858
#define glSampleMaski_RETURN void
#define glSampleMaski_ARG_NAMES index, mask
#define glSampleMaski_ARG_EXPAND GLuint index, GLbitfield mask
#define glSampleMaski_PACKED PACKED_glSampleMaski
#define glSampleMaski_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glSampleMaski_NOT_VOID_WRAP(...) {}
#define pack_glSampleMaski(_index, _mask) ({ \
    glSampleMaski_PACKED *packed_data = malloc(sizeof(glSampleMaski_PACKED)); \
    packed_data->index = glSampleMaski_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.mask = (GLbitfield)_mask; \
    (packed_call_t *)packed_data; \
})
#define call_glSampleMaski(packed, ret_v) do { \
    PACKED_glSampleMaski *unpacked = (PACKED_glSampleMaski *)packed; \
    ARGS_glSampleMaski *args = (ARGS_glSampleMaski *)&unpacked->args; \
    glSampleMaski(args->index, args->mask);; \
} while(0)
void glSampleMaski(glSampleMaski_ARG_EXPAND);
typedef void (*glSampleMaski_PTR)(glSampleMaski_ARG_EXPAND);
#define glSamplePatternEXT_INDEX 1859
#define glSamplePatternEXT_RETURN void
#define glSamplePatternEXT_ARG_NAMES pattern
#define glSamplePatternEXT_ARG_EXPAND GLenum pattern
#define glSamplePatternEXT_PACKED PACKED_glSamplePatternEXT
#define glSamplePatternEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glSamplePatternEXT_NOT_VOID_WRAP(...) {}
#define pack_glSamplePatternEXT(_pattern) ({ \
    glSamplePatternEXT_PACKED *packed_data = malloc(sizeof(glSamplePatternEXT_PACKED)); \
    packed_data->index = glSamplePatternEXT_INDEX; \
    packed_data->args.pattern = (GLenum)_pattern; \
    (packed_call_t *)packed_data; \
})
#define call_glSamplePatternEXT(packed, ret_v) do { \
    PACKED_glSamplePatternEXT *unpacked = (PACKED_glSamplePatternEXT *)packed; \
    ARGS_glSamplePatternEXT *args = (ARGS_glSamplePatternEXT *)&unpacked->args; \
    glSamplePatternEXT(args->pattern);; \
} while(0)
void glSamplePatternEXT(glSamplePatternEXT_ARG_EXPAND);
typedef void (*glSamplePatternEXT_PTR)(glSamplePatternEXT_ARG_EXPAND);
#define glSamplePatternSGIS_INDEX 1860
#define glSamplePatternSGIS_RETURN void
#define glSamplePatternSGIS_ARG_NAMES pattern
#define glSamplePatternSGIS_ARG_EXPAND GLenum pattern
#define glSamplePatternSGIS_PACKED PACKED_glSamplePatternSGIS
#define glSamplePatternSGIS_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glSamplePatternSGIS_NOT_VOID_WRAP(...) {}
#define pack_glSamplePatternSGIS(_pattern) ({ \
    glSamplePatternSGIS_PACKED *packed_data = malloc(sizeof(glSamplePatternSGIS_PACKED)); \
    packed_data->index = glSamplePatternSGIS_INDEX; \
    packed_data->args.pattern = (GLenum)_pattern; \
    (packed_call_t *)packed_data; \
})
#define call_glSamplePatternSGIS(packed, ret_v) do { \
    PACKED_glSamplePatternSGIS *unpacked = (PACKED_glSamplePatternSGIS *)packed; \
    ARGS_glSamplePatternSGIS *args = (ARGS_glSamplePatternSGIS *)&unpacked->args; \
    glSamplePatternSGIS(args->pattern);; \
} while(0)
void glSamplePatternSGIS(glSamplePatternSGIS_ARG_EXPAND);
typedef void (*glSamplePatternSGIS_PTR)(glSamplePatternSGIS_ARG_EXPAND);
#define glSamplerParameterIiv_INDEX 1861
#define glSamplerParameterIiv_RETURN void
#define glSamplerParameterIiv_ARG_NAMES sampler, pname, param
#define glSamplerParameterIiv_ARG_EXPAND GLuint sampler, GLenum pname, const GLint * param
#define glSamplerParameterIiv_PACKED PACKED_glSamplerParameterIiv
#define glSamplerParameterIiv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glSamplerParameterIiv_NOT_VOID_WRAP(...) {}
#define pack_glSamplerParameterIiv(_sampler, _pname, _param) ({ \
    glSamplerParameterIiv_PACKED *packed_data = malloc(sizeof(glSamplerParameterIiv_PACKED)); \
    packed_data->index = glSamplerParameterIiv_INDEX; \
    packed_data->args.sampler = (GLuint)_sampler; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.param = (GLint *)_param; \
    (packed_call_t *)packed_data; \
})
#define call_glSamplerParameterIiv(packed, ret_v) do { \
    PACKED_glSamplerParameterIiv *unpacked = (PACKED_glSamplerParameterIiv *)packed; \
    ARGS_glSamplerParameterIiv *args = (ARGS_glSamplerParameterIiv *)&unpacked->args; \
    glSamplerParameterIiv(args->sampler, args->pname, args->param);; \
} while(0)
void glSamplerParameterIiv(glSamplerParameterIiv_ARG_EXPAND);
typedef void (*glSamplerParameterIiv_PTR)(glSamplerParameterIiv_ARG_EXPAND);
#define glSamplerParameterIuiv_INDEX 1862
#define glSamplerParameterIuiv_RETURN void
#define glSamplerParameterIuiv_ARG_NAMES sampler, pname, param
#define glSamplerParameterIuiv_ARG_EXPAND GLuint sampler, GLenum pname, const GLuint * param
#define glSamplerParameterIuiv_PACKED PACKED_glSamplerParameterIuiv
#define glSamplerParameterIuiv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glSamplerParameterIuiv_NOT_VOID_WRAP(...) {}
#define pack_glSamplerParameterIuiv(_sampler, _pname, _param) ({ \
    glSamplerParameterIuiv_PACKED *packed_data = malloc(sizeof(glSamplerParameterIuiv_PACKED)); \
    packed_data->index = glSamplerParameterIuiv_INDEX; \
    packed_data->args.sampler = (GLuint)_sampler; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.param = (GLuint *)_param; \
    (packed_call_t *)packed_data; \
})
#define call_glSamplerParameterIuiv(packed, ret_v) do { \
    PACKED_glSamplerParameterIuiv *unpacked = (PACKED_glSamplerParameterIuiv *)packed; \
    ARGS_glSamplerParameterIuiv *args = (ARGS_glSamplerParameterIuiv *)&unpacked->args; \
    glSamplerParameterIuiv(args->sampler, args->pname, args->param);; \
} while(0)
void glSamplerParameterIuiv(glSamplerParameterIuiv_ARG_EXPAND);
typedef void (*glSamplerParameterIuiv_PTR)(glSamplerParameterIuiv_ARG_EXPAND);
#define glSamplerParameterf_INDEX 1863
#define glSamplerParameterf_RETURN void
#define glSamplerParameterf_ARG_NAMES sampler, pname, param
#define glSamplerParameterf_ARG_EXPAND GLuint sampler, GLenum pname, GLfloat param
#define glSamplerParameterf_PACKED PACKED_glSamplerParameterf
#define glSamplerParameterf_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glSamplerParameterf_NOT_VOID_WRAP(...) {}
#define pack_glSamplerParameterf(_sampler, _pname, _param) ({ \
    glSamplerParameterf_PACKED *packed_data = malloc(sizeof(glSamplerParameterf_PACKED)); \
    packed_data->index = glSamplerParameterf_INDEX; \
    packed_data->args.sampler = (GLuint)_sampler; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.param = (GLfloat)_param; \
    (packed_call_t *)packed_data; \
})
#define call_glSamplerParameterf(packed, ret_v) do { \
    PACKED_glSamplerParameterf *unpacked = (PACKED_glSamplerParameterf *)packed; \
    ARGS_glSamplerParameterf *args = (ARGS_glSamplerParameterf *)&unpacked->args; \
    glSamplerParameterf(args->sampler, args->pname, args->param);; \
} while(0)
void glSamplerParameterf(glSamplerParameterf_ARG_EXPAND);
typedef void (*glSamplerParameterf_PTR)(glSamplerParameterf_ARG_EXPAND);
#define glSamplerParameterfv_INDEX 1864
#define glSamplerParameterfv_RETURN void
#define glSamplerParameterfv_ARG_NAMES sampler, pname, param
#define glSamplerParameterfv_ARG_EXPAND GLuint sampler, GLenum pname, const GLfloat * param
#define glSamplerParameterfv_PACKED PACKED_glSamplerParameterfv
#define glSamplerParameterfv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glSamplerParameterfv_NOT_VOID_WRAP(...) {}
#define pack_glSamplerParameterfv(_sampler, _pname, _param) ({ \
    glSamplerParameterfv_PACKED *packed_data = malloc(sizeof(glSamplerParameterfv_PACKED)); \
    packed_data->index = glSamplerParameterfv_INDEX; \
    packed_data->args.sampler = (GLuint)_sampler; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.param = (GLfloat *)_param; \
    (packed_call_t *)packed_data; \
})
#define call_glSamplerParameterfv(packed, ret_v) do { \
    PACKED_glSamplerParameterfv *unpacked = (PACKED_glSamplerParameterfv *)packed; \
    ARGS_glSamplerParameterfv *args = (ARGS_glSamplerParameterfv *)&unpacked->args; \
    glSamplerParameterfv(args->sampler, args->pname, args->param);; \
} while(0)
void glSamplerParameterfv(glSamplerParameterfv_ARG_EXPAND);
typedef void (*glSamplerParameterfv_PTR)(glSamplerParameterfv_ARG_EXPAND);
#define glSamplerParameteri_INDEX 1865
#define glSamplerParameteri_RETURN void
#define glSamplerParameteri_ARG_NAMES sampler, pname, param
#define glSamplerParameteri_ARG_EXPAND GLuint sampler, GLenum pname, GLint param
#define glSamplerParameteri_PACKED PACKED_glSamplerParameteri
#define glSamplerParameteri_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glSamplerParameteri_NOT_VOID_WRAP(...) {}
#define pack_glSamplerParameteri(_sampler, _pname, _param) ({ \
    glSamplerParameteri_PACKED *packed_data = malloc(sizeof(glSamplerParameteri_PACKED)); \
    packed_data->index = glSamplerParameteri_INDEX; \
    packed_data->args.sampler = (GLuint)_sampler; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.param = (GLint)_param; \
    (packed_call_t *)packed_data; \
})
#define call_glSamplerParameteri(packed, ret_v) do { \
    PACKED_glSamplerParameteri *unpacked = (PACKED_glSamplerParameteri *)packed; \
    ARGS_glSamplerParameteri *args = (ARGS_glSamplerParameteri *)&unpacked->args; \
    glSamplerParameteri(args->sampler, args->pname, args->param);; \
} while(0)
void glSamplerParameteri(glSamplerParameteri_ARG_EXPAND);
typedef void (*glSamplerParameteri_PTR)(glSamplerParameteri_ARG_EXPAND);
#define glSamplerParameteriv_INDEX 1866
#define glSamplerParameteriv_RETURN void
#define glSamplerParameteriv_ARG_NAMES sampler, pname, param
#define glSamplerParameteriv_ARG_EXPAND GLuint sampler, GLenum pname, const GLint * param
#define glSamplerParameteriv_PACKED PACKED_glSamplerParameteriv
#define glSamplerParameteriv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glSamplerParameteriv_NOT_VOID_WRAP(...) {}
#define pack_glSamplerParameteriv(_sampler, _pname, _param) ({ \
    glSamplerParameteriv_PACKED *packed_data = malloc(sizeof(glSamplerParameteriv_PACKED)); \
    packed_data->index = glSamplerParameteriv_INDEX; \
    packed_data->args.sampler = (GLuint)_sampler; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.param = (GLint *)_param; \
    (packed_call_t *)packed_data; \
})
#define call_glSamplerParameteriv(packed, ret_v) do { \
    PACKED_glSamplerParameteriv *unpacked = (PACKED_glSamplerParameteriv *)packed; \
    ARGS_glSamplerParameteriv *args = (ARGS_glSamplerParameteriv *)&unpacked->args; \
    glSamplerParameteriv(args->sampler, args->pname, args->param);; \
} while(0)
void glSamplerParameteriv(glSamplerParameteriv_ARG_EXPAND);
typedef void (*glSamplerParameteriv_PTR)(glSamplerParameteriv_ARG_EXPAND);
#define glScaled_INDEX 1867
#define glScaled_RETURN void
#define glScaled_ARG_NAMES x, y, z
#define glScaled_ARG_EXPAND GLdouble x, GLdouble y, GLdouble z
#define glScaled_PACKED PACKED_glScaled
#define glScaled_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glScaled_NOT_VOID_WRAP(...) {}
#define pack_glScaled(_x, _y, _z) ({ \
    glScaled_PACKED *packed_data = malloc(sizeof(glScaled_PACKED)); \
    packed_data->index = glScaled_INDEX; \
    packed_data->args.x = (GLdouble)_x; \
    packed_data->args.y = (GLdouble)_y; \
    packed_data->args.z = (GLdouble)_z; \
    (packed_call_t *)packed_data; \
})
#define call_glScaled(packed, ret_v) do { \
    PACKED_glScaled *unpacked = (PACKED_glScaled *)packed; \
    ARGS_glScaled *args = (ARGS_glScaled *)&unpacked->args; \
    glScaled(args->x, args->y, args->z);; \
} while(0)
void glScaled(glScaled_ARG_EXPAND);
typedef void (*glScaled_PTR)(glScaled_ARG_EXPAND);
#define glScalef_INDEX 1868
#define glScalef_RETURN void
#define glScalef_ARG_NAMES x, y, z
#define glScalef_ARG_EXPAND GLfloat x, GLfloat y, GLfloat z
#define glScalef_PACKED PACKED_glScalef
#define glScalef_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glScalef_NOT_VOID_WRAP(...) {}
#define pack_glScalef(_x, _y, _z) ({ \
    glScalef_PACKED *packed_data = malloc(sizeof(glScalef_PACKED)); \
    packed_data->index = glScalef_INDEX; \
    packed_data->args.x = (GLfloat)_x; \
    packed_data->args.y = (GLfloat)_y; \
    packed_data->args.z = (GLfloat)_z; \
    (packed_call_t *)packed_data; \
})
#define call_glScalef(packed, ret_v) do { \
    PACKED_glScalef *unpacked = (PACKED_glScalef *)packed; \
    ARGS_glScalef *args = (ARGS_glScalef *)&unpacked->args; \
    glScalef(args->x, args->y, args->z);; \
} while(0)
void glScalef(glScalef_ARG_EXPAND);
typedef void (*glScalef_PTR)(glScalef_ARG_EXPAND);
#define glScalex_INDEX 1869
#define glScalex_RETURN void
#define glScalex_ARG_NAMES x, y, z
#define glScalex_ARG_EXPAND GLfixed x, GLfixed y, GLfixed z
#define glScalex_PACKED PACKED_glScalex
#define glScalex_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glScalex_NOT_VOID_WRAP(...) {}
#define pack_glScalex(_x, _y, _z) ({ \
    glScalex_PACKED *packed_data = malloc(sizeof(glScalex_PACKED)); \
    packed_data->index = glScalex_INDEX; \
    packed_data->args.x = (GLfixed)_x; \
    packed_data->args.y = (GLfixed)_y; \
    packed_data->args.z = (GLfixed)_z; \
    (packed_call_t *)packed_data; \
})
#define call_glScalex(packed, ret_v) do { \
    PACKED_glScalex *unpacked = (PACKED_glScalex *)packed; \
    ARGS_glScalex *args = (ARGS_glScalex *)&unpacked->args; \
    glScalex(args->x, args->y, args->z);; \
} while(0)
void glScalex(glScalex_ARG_EXPAND);
typedef void (*glScalex_PTR)(glScalex_ARG_EXPAND);
#define glScalexOES_INDEX 1870
#define glScalexOES_RETURN void
#define glScalexOES_ARG_NAMES x, y, z
#define glScalexOES_ARG_EXPAND GLfixed x, GLfixed y, GLfixed z
#define glScalexOES_PACKED PACKED_glScalexOES
#define glScalexOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glScalexOES_NOT_VOID_WRAP(...) {}
#define pack_glScalexOES(_x, _y, _z) ({ \
    glScalexOES_PACKED *packed_data = malloc(sizeof(glScalexOES_PACKED)); \
    packed_data->index = glScalexOES_INDEX; \
    packed_data->args.x = (GLfixed)_x; \
    packed_data->args.y = (GLfixed)_y; \
    packed_data->args.z = (GLfixed)_z; \
    (packed_call_t *)packed_data; \
})
#define call_glScalexOES(packed, ret_v) do { \
    PACKED_glScalexOES *unpacked = (PACKED_glScalexOES *)packed; \
    ARGS_glScalexOES *args = (ARGS_glScalexOES *)&unpacked->args; \
    glScalexOES(args->x, args->y, args->z);; \
} while(0)
void glScalexOES(glScalexOES_ARG_EXPAND);
typedef void (*glScalexOES_PTR)(glScalexOES_ARG_EXPAND);
#define glScissor_INDEX 1871
#define glScissor_RETURN void
#define glScissor_ARG_NAMES x, y, width, height
#define glScissor_ARG_EXPAND GLint x, GLint y, GLsizei width, GLsizei height
#define glScissor_PACKED PACKED_glScissor
#define glScissor_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glScissor_NOT_VOID_WRAP(...) {}
#define pack_glScissor(_x, _y, _width, _height) ({ \
    glScissor_PACKED *packed_data = malloc(sizeof(glScissor_PACKED)); \
    packed_data->index = glScissor_INDEX; \
    packed_data->args.x = (GLint)_x; \
    packed_data->args.y = (GLint)_y; \
    packed_data->args.width = (GLsizei)_width; \
    packed_data->args.height = (GLsizei)_height; \
    (packed_call_t *)packed_data; \
})
#define call_glScissor(packed, ret_v) do { \
    PACKED_glScissor *unpacked = (PACKED_glScissor *)packed; \
    ARGS_glScissor *args = (ARGS_glScissor *)&unpacked->args; \
    glScissor(args->x, args->y, args->width, args->height);; \
} while(0)
void glScissor(glScissor_ARG_EXPAND);
typedef void (*glScissor_PTR)(glScissor_ARG_EXPAND);
#define glScissorArrayv_INDEX 1872
#define glScissorArrayv_RETURN void
#define glScissorArrayv_ARG_NAMES first, count, v
#define glScissorArrayv_ARG_EXPAND GLuint first, GLsizei count, const GLint * v
#define glScissorArrayv_PACKED PACKED_glScissorArrayv
#define glScissorArrayv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glScissorArrayv_NOT_VOID_WRAP(...) {}
#define pack_glScissorArrayv(_first, _count, _v) ({ \
    glScissorArrayv_PACKED *packed_data = malloc(sizeof(glScissorArrayv_PACKED)); \
    packed_data->index = glScissorArrayv_INDEX; \
    packed_data->args.first = (GLuint)_first; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.v = (GLint *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glScissorArrayv(packed, ret_v) do { \
    PACKED_glScissorArrayv *unpacked = (PACKED_glScissorArrayv *)packed; \
    ARGS_glScissorArrayv *args = (ARGS_glScissorArrayv *)&unpacked->args; \
    glScissorArrayv(args->first, args->count, args->v);; \
} while(0)
void glScissorArrayv(glScissorArrayv_ARG_EXPAND);
typedef void (*glScissorArrayv_PTR)(glScissorArrayv_ARG_EXPAND);
#define glScissorIndexed_INDEX 1873
#define glScissorIndexed_RETURN void
#define glScissorIndexed_ARG_NAMES index, left, bottom, width, height
#define glScissorIndexed_ARG_EXPAND GLuint index, GLint left, GLint bottom, GLsizei width, GLsizei height
#define glScissorIndexed_PACKED PACKED_glScissorIndexed
#define glScissorIndexed_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glScissorIndexed_NOT_VOID_WRAP(...) {}
#define pack_glScissorIndexed(_index, _left, _bottom, _width, _height) ({ \
    glScissorIndexed_PACKED *packed_data = malloc(sizeof(glScissorIndexed_PACKED)); \
    packed_data->index = glScissorIndexed_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.left = (GLint)_left; \
    packed_data->args.bottom = (GLint)_bottom; \
    packed_data->args.width = (GLsizei)_width; \
    packed_data->args.height = (GLsizei)_height; \
    (packed_call_t *)packed_data; \
})
#define call_glScissorIndexed(packed, ret_v) do { \
    PACKED_glScissorIndexed *unpacked = (PACKED_glScissorIndexed *)packed; \
    ARGS_glScissorIndexed *args = (ARGS_glScissorIndexed *)&unpacked->args; \
    glScissorIndexed(args->index, args->left, args->bottom, args->width, args->height);; \
} while(0)
void glScissorIndexed(glScissorIndexed_ARG_EXPAND);
typedef void (*glScissorIndexed_PTR)(glScissorIndexed_ARG_EXPAND);
#define glScissorIndexedv_INDEX 1874
#define glScissorIndexedv_RETURN void
#define glScissorIndexedv_ARG_NAMES index, v
#define glScissorIndexedv_ARG_EXPAND GLuint index, const GLint * v
#define glScissorIndexedv_PACKED PACKED_glScissorIndexedv
#define glScissorIndexedv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glScissorIndexedv_NOT_VOID_WRAP(...) {}
#define pack_glScissorIndexedv(_index, _v) ({ \
    glScissorIndexedv_PACKED *packed_data = malloc(sizeof(glScissorIndexedv_PACKED)); \
    packed_data->index = glScissorIndexedv_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.v = (GLint *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glScissorIndexedv(packed, ret_v) do { \
    PACKED_glScissorIndexedv *unpacked = (PACKED_glScissorIndexedv *)packed; \
    ARGS_glScissorIndexedv *args = (ARGS_glScissorIndexedv *)&unpacked->args; \
    glScissorIndexedv(args->index, args->v);; \
} while(0)
void glScissorIndexedv(glScissorIndexedv_ARG_EXPAND);
typedef void (*glScissorIndexedv_PTR)(glScissorIndexedv_ARG_EXPAND);
#define glSecondaryColor3b_INDEX 1875
#define glSecondaryColor3b_RETURN void
#define glSecondaryColor3b_ARG_NAMES red, green, blue
#define glSecondaryColor3b_ARG_EXPAND GLbyte red, GLbyte green, GLbyte blue
#define glSecondaryColor3b_PACKED PACKED_glSecondaryColor3b
#define glSecondaryColor3b_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glSecondaryColor3b_NOT_VOID_WRAP(...) {}
#define pack_glSecondaryColor3b(_red, _green, _blue) ({ \
    glSecondaryColor3b_PACKED *packed_data = malloc(sizeof(glSecondaryColor3b_PACKED)); \
    packed_data->index = glSecondaryColor3b_INDEX; \
    packed_data->args.red = (GLbyte)_red; \
    packed_data->args.green = (GLbyte)_green; \
    packed_data->args.blue = (GLbyte)_blue; \
    (packed_call_t *)packed_data; \
})
#define call_glSecondaryColor3b(packed, ret_v) do { \
    PACKED_glSecondaryColor3b *unpacked = (PACKED_glSecondaryColor3b *)packed; \
    ARGS_glSecondaryColor3b *args = (ARGS_glSecondaryColor3b *)&unpacked->args; \
    glSecondaryColor3b(args->red, args->green, args->blue);; \
} while(0)
void glSecondaryColor3b(glSecondaryColor3b_ARG_EXPAND);
typedef void (*glSecondaryColor3b_PTR)(glSecondaryColor3b_ARG_EXPAND);
#define glSecondaryColor3bEXT_INDEX 1876
#define glSecondaryColor3bEXT_RETURN void
#define glSecondaryColor3bEXT_ARG_NAMES red, green, blue
#define glSecondaryColor3bEXT_ARG_EXPAND GLbyte red, GLbyte green, GLbyte blue
#define glSecondaryColor3bEXT_PACKED PACKED_glSecondaryColor3bEXT
#define glSecondaryColor3bEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glSecondaryColor3bEXT_NOT_VOID_WRAP(...) {}
#define pack_glSecondaryColor3bEXT(_red, _green, _blue) ({ \
    glSecondaryColor3bEXT_PACKED *packed_data = malloc(sizeof(glSecondaryColor3bEXT_PACKED)); \
    packed_data->index = glSecondaryColor3bEXT_INDEX; \
    packed_data->args.red = (GLbyte)_red; \
    packed_data->args.green = (GLbyte)_green; \
    packed_data->args.blue = (GLbyte)_blue; \
    (packed_call_t *)packed_data; \
})
#define call_glSecondaryColor3bEXT(packed, ret_v) do { \
    PACKED_glSecondaryColor3bEXT *unpacked = (PACKED_glSecondaryColor3bEXT *)packed; \
    ARGS_glSecondaryColor3bEXT *args = (ARGS_glSecondaryColor3bEXT *)&unpacked->args; \
    glSecondaryColor3bEXT(args->red, args->green, args->blue);; \
} while(0)
void glSecondaryColor3bEXT(glSecondaryColor3bEXT_ARG_EXPAND);
typedef void (*glSecondaryColor3bEXT_PTR)(glSecondaryColor3bEXT_ARG_EXPAND);
#define glSecondaryColor3bv_INDEX 1877
#define glSecondaryColor3bv_RETURN void
#define glSecondaryColor3bv_ARG_NAMES v
#define glSecondaryColor3bv_ARG_EXPAND const GLbyte * v
#define glSecondaryColor3bv_PACKED PACKED_glSecondaryColor3bv
#define glSecondaryColor3bv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glSecondaryColor3bv_NOT_VOID_WRAP(...) {}
#define pack_glSecondaryColor3bv(_v) ({ \
    glSecondaryColor3bv_PACKED *packed_data = malloc(sizeof(glSecondaryColor3bv_PACKED)); \
    packed_data->index = glSecondaryColor3bv_INDEX; \
    packed_data->args.v = (GLbyte *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glSecondaryColor3bv(packed, ret_v) do { \
    PACKED_glSecondaryColor3bv *unpacked = (PACKED_glSecondaryColor3bv *)packed; \
    ARGS_glSecondaryColor3bv *args = (ARGS_glSecondaryColor3bv *)&unpacked->args; \
    glSecondaryColor3bv(args->v);; \
} while(0)
void glSecondaryColor3bv(glSecondaryColor3bv_ARG_EXPAND);
typedef void (*glSecondaryColor3bv_PTR)(glSecondaryColor3bv_ARG_EXPAND);
#define glSecondaryColor3bvEXT_INDEX 1878
#define glSecondaryColor3bvEXT_RETURN void
#define glSecondaryColor3bvEXT_ARG_NAMES v
#define glSecondaryColor3bvEXT_ARG_EXPAND const GLbyte * v
#define glSecondaryColor3bvEXT_PACKED PACKED_glSecondaryColor3bvEXT
#define glSecondaryColor3bvEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glSecondaryColor3bvEXT_NOT_VOID_WRAP(...) {}
#define pack_glSecondaryColor3bvEXT(_v) ({ \
    glSecondaryColor3bvEXT_PACKED *packed_data = malloc(sizeof(glSecondaryColor3bvEXT_PACKED)); \
    packed_data->index = glSecondaryColor3bvEXT_INDEX; \
    packed_data->args.v = (GLbyte *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glSecondaryColor3bvEXT(packed, ret_v) do { \
    PACKED_glSecondaryColor3bvEXT *unpacked = (PACKED_glSecondaryColor3bvEXT *)packed; \
    ARGS_glSecondaryColor3bvEXT *args = (ARGS_glSecondaryColor3bvEXT *)&unpacked->args; \
    glSecondaryColor3bvEXT(args->v);; \
} while(0)
void glSecondaryColor3bvEXT(glSecondaryColor3bvEXT_ARG_EXPAND);
typedef void (*glSecondaryColor3bvEXT_PTR)(glSecondaryColor3bvEXT_ARG_EXPAND);
#define glSecondaryColor3d_INDEX 1879
#define glSecondaryColor3d_RETURN void
#define glSecondaryColor3d_ARG_NAMES red, green, blue
#define glSecondaryColor3d_ARG_EXPAND GLdouble red, GLdouble green, GLdouble blue
#define glSecondaryColor3d_PACKED PACKED_glSecondaryColor3d
#define glSecondaryColor3d_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glSecondaryColor3d_NOT_VOID_WRAP(...) {}
#define pack_glSecondaryColor3d(_red, _green, _blue) ({ \
    glSecondaryColor3d_PACKED *packed_data = malloc(sizeof(glSecondaryColor3d_PACKED)); \
    packed_data->index = glSecondaryColor3d_INDEX; \
    packed_data->args.red = (GLdouble)_red; \
    packed_data->args.green = (GLdouble)_green; \
    packed_data->args.blue = (GLdouble)_blue; \
    (packed_call_t *)packed_data; \
})
#define call_glSecondaryColor3d(packed, ret_v) do { \
    PACKED_glSecondaryColor3d *unpacked = (PACKED_glSecondaryColor3d *)packed; \
    ARGS_glSecondaryColor3d *args = (ARGS_glSecondaryColor3d *)&unpacked->args; \
    glSecondaryColor3d(args->red, args->green, args->blue);; \
} while(0)
void glSecondaryColor3d(glSecondaryColor3d_ARG_EXPAND);
typedef void (*glSecondaryColor3d_PTR)(glSecondaryColor3d_ARG_EXPAND);
#define glSecondaryColor3dEXT_INDEX 1880
#define glSecondaryColor3dEXT_RETURN void
#define glSecondaryColor3dEXT_ARG_NAMES red, green, blue
#define glSecondaryColor3dEXT_ARG_EXPAND GLdouble red, GLdouble green, GLdouble blue
#define glSecondaryColor3dEXT_PACKED PACKED_glSecondaryColor3dEXT
#define glSecondaryColor3dEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glSecondaryColor3dEXT_NOT_VOID_WRAP(...) {}
#define pack_glSecondaryColor3dEXT(_red, _green, _blue) ({ \
    glSecondaryColor3dEXT_PACKED *packed_data = malloc(sizeof(glSecondaryColor3dEXT_PACKED)); \
    packed_data->index = glSecondaryColor3dEXT_INDEX; \
    packed_data->args.red = (GLdouble)_red; \
    packed_data->args.green = (GLdouble)_green; \
    packed_data->args.blue = (GLdouble)_blue; \
    (packed_call_t *)packed_data; \
})
#define call_glSecondaryColor3dEXT(packed, ret_v) do { \
    PACKED_glSecondaryColor3dEXT *unpacked = (PACKED_glSecondaryColor3dEXT *)packed; \
    ARGS_glSecondaryColor3dEXT *args = (ARGS_glSecondaryColor3dEXT *)&unpacked->args; \
    glSecondaryColor3dEXT(args->red, args->green, args->blue);; \
} while(0)
void glSecondaryColor3dEXT(glSecondaryColor3dEXT_ARG_EXPAND);
typedef void (*glSecondaryColor3dEXT_PTR)(glSecondaryColor3dEXT_ARG_EXPAND);
#define glSecondaryColor3dv_INDEX 1881
#define glSecondaryColor3dv_RETURN void
#define glSecondaryColor3dv_ARG_NAMES v
#define glSecondaryColor3dv_ARG_EXPAND const GLdouble * v
#define glSecondaryColor3dv_PACKED PACKED_glSecondaryColor3dv
#define glSecondaryColor3dv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glSecondaryColor3dv_NOT_VOID_WRAP(...) {}
#define pack_glSecondaryColor3dv(_v) ({ \
    glSecondaryColor3dv_PACKED *packed_data = malloc(sizeof(glSecondaryColor3dv_PACKED)); \
    packed_data->index = glSecondaryColor3dv_INDEX; \
    packed_data->args.v = (GLdouble *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glSecondaryColor3dv(packed, ret_v) do { \
    PACKED_glSecondaryColor3dv *unpacked = (PACKED_glSecondaryColor3dv *)packed; \
    ARGS_glSecondaryColor3dv *args = (ARGS_glSecondaryColor3dv *)&unpacked->args; \
    glSecondaryColor3dv(args->v);; \
} while(0)
void glSecondaryColor3dv(glSecondaryColor3dv_ARG_EXPAND);
typedef void (*glSecondaryColor3dv_PTR)(glSecondaryColor3dv_ARG_EXPAND);
#define glSecondaryColor3dvEXT_INDEX 1882
#define glSecondaryColor3dvEXT_RETURN void
#define glSecondaryColor3dvEXT_ARG_NAMES v
#define glSecondaryColor3dvEXT_ARG_EXPAND const GLdouble * v
#define glSecondaryColor3dvEXT_PACKED PACKED_glSecondaryColor3dvEXT
#define glSecondaryColor3dvEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glSecondaryColor3dvEXT_NOT_VOID_WRAP(...) {}
#define pack_glSecondaryColor3dvEXT(_v) ({ \
    glSecondaryColor3dvEXT_PACKED *packed_data = malloc(sizeof(glSecondaryColor3dvEXT_PACKED)); \
    packed_data->index = glSecondaryColor3dvEXT_INDEX; \
    packed_data->args.v = (GLdouble *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glSecondaryColor3dvEXT(packed, ret_v) do { \
    PACKED_glSecondaryColor3dvEXT *unpacked = (PACKED_glSecondaryColor3dvEXT *)packed; \
    ARGS_glSecondaryColor3dvEXT *args = (ARGS_glSecondaryColor3dvEXT *)&unpacked->args; \
    glSecondaryColor3dvEXT(args->v);; \
} while(0)
void glSecondaryColor3dvEXT(glSecondaryColor3dvEXT_ARG_EXPAND);
typedef void (*glSecondaryColor3dvEXT_PTR)(glSecondaryColor3dvEXT_ARG_EXPAND);
#define glSecondaryColor3f_INDEX 1883
#define glSecondaryColor3f_RETURN void
#define glSecondaryColor3f_ARG_NAMES red, green, blue
#define glSecondaryColor3f_ARG_EXPAND GLfloat red, GLfloat green, GLfloat blue
#define glSecondaryColor3f_PACKED PACKED_glSecondaryColor3f
#define glSecondaryColor3f_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glSecondaryColor3f_NOT_VOID_WRAP(...) {}
#define pack_glSecondaryColor3f(_red, _green, _blue) ({ \
    glSecondaryColor3f_PACKED *packed_data = malloc(sizeof(glSecondaryColor3f_PACKED)); \
    packed_data->index = glSecondaryColor3f_INDEX; \
    packed_data->args.red = (GLfloat)_red; \
    packed_data->args.green = (GLfloat)_green; \
    packed_data->args.blue = (GLfloat)_blue; \
    (packed_call_t *)packed_data; \
})
#define call_glSecondaryColor3f(packed, ret_v) do { \
    PACKED_glSecondaryColor3f *unpacked = (PACKED_glSecondaryColor3f *)packed; \
    ARGS_glSecondaryColor3f *args = (ARGS_glSecondaryColor3f *)&unpacked->args; \
    glSecondaryColor3f(args->red, args->green, args->blue);; \
} while(0)
void glSecondaryColor3f(glSecondaryColor3f_ARG_EXPAND);
typedef void (*glSecondaryColor3f_PTR)(glSecondaryColor3f_ARG_EXPAND);
#define glSecondaryColor3fEXT_INDEX 1884
#define glSecondaryColor3fEXT_RETURN void
#define glSecondaryColor3fEXT_ARG_NAMES red, green, blue
#define glSecondaryColor3fEXT_ARG_EXPAND GLfloat red, GLfloat green, GLfloat blue
#define glSecondaryColor3fEXT_PACKED PACKED_glSecondaryColor3fEXT
#define glSecondaryColor3fEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glSecondaryColor3fEXT_NOT_VOID_WRAP(...) {}
#define pack_glSecondaryColor3fEXT(_red, _green, _blue) ({ \
    glSecondaryColor3fEXT_PACKED *packed_data = malloc(sizeof(glSecondaryColor3fEXT_PACKED)); \
    packed_data->index = glSecondaryColor3fEXT_INDEX; \
    packed_data->args.red = (GLfloat)_red; \
    packed_data->args.green = (GLfloat)_green; \
    packed_data->args.blue = (GLfloat)_blue; \
    (packed_call_t *)packed_data; \
})
#define call_glSecondaryColor3fEXT(packed, ret_v) do { \
    PACKED_glSecondaryColor3fEXT *unpacked = (PACKED_glSecondaryColor3fEXT *)packed; \
    ARGS_glSecondaryColor3fEXT *args = (ARGS_glSecondaryColor3fEXT *)&unpacked->args; \
    glSecondaryColor3fEXT(args->red, args->green, args->blue);; \
} while(0)
void glSecondaryColor3fEXT(glSecondaryColor3fEXT_ARG_EXPAND);
typedef void (*glSecondaryColor3fEXT_PTR)(glSecondaryColor3fEXT_ARG_EXPAND);
#define glSecondaryColor3fv_INDEX 1885
#define glSecondaryColor3fv_RETURN void
#define glSecondaryColor3fv_ARG_NAMES v
#define glSecondaryColor3fv_ARG_EXPAND const GLfloat * v
#define glSecondaryColor3fv_PACKED PACKED_glSecondaryColor3fv
#define glSecondaryColor3fv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glSecondaryColor3fv_NOT_VOID_WRAP(...) {}
#define pack_glSecondaryColor3fv(_v) ({ \
    glSecondaryColor3fv_PACKED *packed_data = malloc(sizeof(glSecondaryColor3fv_PACKED)); \
    packed_data->index = glSecondaryColor3fv_INDEX; \
    packed_data->args.v = (GLfloat *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glSecondaryColor3fv(packed, ret_v) do { \
    PACKED_glSecondaryColor3fv *unpacked = (PACKED_glSecondaryColor3fv *)packed; \
    ARGS_glSecondaryColor3fv *args = (ARGS_glSecondaryColor3fv *)&unpacked->args; \
    glSecondaryColor3fv(args->v);; \
} while(0)
void glSecondaryColor3fv(glSecondaryColor3fv_ARG_EXPAND);
typedef void (*glSecondaryColor3fv_PTR)(glSecondaryColor3fv_ARG_EXPAND);
#define glSecondaryColor3fvEXT_INDEX 1886
#define glSecondaryColor3fvEXT_RETURN void
#define glSecondaryColor3fvEXT_ARG_NAMES v
#define glSecondaryColor3fvEXT_ARG_EXPAND const GLfloat * v
#define glSecondaryColor3fvEXT_PACKED PACKED_glSecondaryColor3fvEXT
#define glSecondaryColor3fvEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glSecondaryColor3fvEXT_NOT_VOID_WRAP(...) {}
#define pack_glSecondaryColor3fvEXT(_v) ({ \
    glSecondaryColor3fvEXT_PACKED *packed_data = malloc(sizeof(glSecondaryColor3fvEXT_PACKED)); \
    packed_data->index = glSecondaryColor3fvEXT_INDEX; \
    packed_data->args.v = (GLfloat *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glSecondaryColor3fvEXT(packed, ret_v) do { \
    PACKED_glSecondaryColor3fvEXT *unpacked = (PACKED_glSecondaryColor3fvEXT *)packed; \
    ARGS_glSecondaryColor3fvEXT *args = (ARGS_glSecondaryColor3fvEXT *)&unpacked->args; \
    glSecondaryColor3fvEXT(args->v);; \
} while(0)
void glSecondaryColor3fvEXT(glSecondaryColor3fvEXT_ARG_EXPAND);
typedef void (*glSecondaryColor3fvEXT_PTR)(glSecondaryColor3fvEXT_ARG_EXPAND);
#define glSecondaryColor3hNV_INDEX 1887
#define glSecondaryColor3hNV_RETURN void
#define glSecondaryColor3hNV_ARG_NAMES red, green, blue
#define glSecondaryColor3hNV_ARG_EXPAND GLhalfNV red, GLhalfNV green, GLhalfNV blue
#define glSecondaryColor3hNV_PACKED PACKED_glSecondaryColor3hNV
#define glSecondaryColor3hNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glSecondaryColor3hNV_NOT_VOID_WRAP(...) {}
#define pack_glSecondaryColor3hNV(_red, _green, _blue) ({ \
    glSecondaryColor3hNV_PACKED *packed_data = malloc(sizeof(glSecondaryColor3hNV_PACKED)); \
    packed_data->index = glSecondaryColor3hNV_INDEX; \
    packed_data->args.red = (GLhalfNV)_red; \
    packed_data->args.green = (GLhalfNV)_green; \
    packed_data->args.blue = (GLhalfNV)_blue; \
    (packed_call_t *)packed_data; \
})
#define call_glSecondaryColor3hNV(packed, ret_v) do { \
    PACKED_glSecondaryColor3hNV *unpacked = (PACKED_glSecondaryColor3hNV *)packed; \
    ARGS_glSecondaryColor3hNV *args = (ARGS_glSecondaryColor3hNV *)&unpacked->args; \
    glSecondaryColor3hNV(args->red, args->green, args->blue);; \
} while(0)
void glSecondaryColor3hNV(glSecondaryColor3hNV_ARG_EXPAND);
typedef void (*glSecondaryColor3hNV_PTR)(glSecondaryColor3hNV_ARG_EXPAND);
#define glSecondaryColor3hvNV_INDEX 1888
#define glSecondaryColor3hvNV_RETURN void
#define glSecondaryColor3hvNV_ARG_NAMES v
#define glSecondaryColor3hvNV_ARG_EXPAND const GLhalfNV * v
#define glSecondaryColor3hvNV_PACKED PACKED_glSecondaryColor3hvNV
#define glSecondaryColor3hvNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glSecondaryColor3hvNV_NOT_VOID_WRAP(...) {}
#define pack_glSecondaryColor3hvNV(_v) ({ \
    glSecondaryColor3hvNV_PACKED *packed_data = malloc(sizeof(glSecondaryColor3hvNV_PACKED)); \
    packed_data->index = glSecondaryColor3hvNV_INDEX; \
    packed_data->args.v = (GLhalfNV *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glSecondaryColor3hvNV(packed, ret_v) do { \
    PACKED_glSecondaryColor3hvNV *unpacked = (PACKED_glSecondaryColor3hvNV *)packed; \
    ARGS_glSecondaryColor3hvNV *args = (ARGS_glSecondaryColor3hvNV *)&unpacked->args; \
    glSecondaryColor3hvNV(args->v);; \
} while(0)
void glSecondaryColor3hvNV(glSecondaryColor3hvNV_ARG_EXPAND);
typedef void (*glSecondaryColor3hvNV_PTR)(glSecondaryColor3hvNV_ARG_EXPAND);
#define glSecondaryColor3i_INDEX 1889
#define glSecondaryColor3i_RETURN void
#define glSecondaryColor3i_ARG_NAMES red, green, blue
#define glSecondaryColor3i_ARG_EXPAND GLint red, GLint green, GLint blue
#define glSecondaryColor3i_PACKED PACKED_glSecondaryColor3i
#define glSecondaryColor3i_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glSecondaryColor3i_NOT_VOID_WRAP(...) {}
#define pack_glSecondaryColor3i(_red, _green, _blue) ({ \
    glSecondaryColor3i_PACKED *packed_data = malloc(sizeof(glSecondaryColor3i_PACKED)); \
    packed_data->index = glSecondaryColor3i_INDEX; \
    packed_data->args.red = (GLint)_red; \
    packed_data->args.green = (GLint)_green; \
    packed_data->args.blue = (GLint)_blue; \
    (packed_call_t *)packed_data; \
})
#define call_glSecondaryColor3i(packed, ret_v) do { \
    PACKED_glSecondaryColor3i *unpacked = (PACKED_glSecondaryColor3i *)packed; \
    ARGS_glSecondaryColor3i *args = (ARGS_glSecondaryColor3i *)&unpacked->args; \
    glSecondaryColor3i(args->red, args->green, args->blue);; \
} while(0)
void glSecondaryColor3i(glSecondaryColor3i_ARG_EXPAND);
typedef void (*glSecondaryColor3i_PTR)(glSecondaryColor3i_ARG_EXPAND);
#define glSecondaryColor3iEXT_INDEX 1890
#define glSecondaryColor3iEXT_RETURN void
#define glSecondaryColor3iEXT_ARG_NAMES red, green, blue
#define glSecondaryColor3iEXT_ARG_EXPAND GLint red, GLint green, GLint blue
#define glSecondaryColor3iEXT_PACKED PACKED_glSecondaryColor3iEXT
#define glSecondaryColor3iEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glSecondaryColor3iEXT_NOT_VOID_WRAP(...) {}
#define pack_glSecondaryColor3iEXT(_red, _green, _blue) ({ \
    glSecondaryColor3iEXT_PACKED *packed_data = malloc(sizeof(glSecondaryColor3iEXT_PACKED)); \
    packed_data->index = glSecondaryColor3iEXT_INDEX; \
    packed_data->args.red = (GLint)_red; \
    packed_data->args.green = (GLint)_green; \
    packed_data->args.blue = (GLint)_blue; \
    (packed_call_t *)packed_data; \
})
#define call_glSecondaryColor3iEXT(packed, ret_v) do { \
    PACKED_glSecondaryColor3iEXT *unpacked = (PACKED_glSecondaryColor3iEXT *)packed; \
    ARGS_glSecondaryColor3iEXT *args = (ARGS_glSecondaryColor3iEXT *)&unpacked->args; \
    glSecondaryColor3iEXT(args->red, args->green, args->blue);; \
} while(0)
void glSecondaryColor3iEXT(glSecondaryColor3iEXT_ARG_EXPAND);
typedef void (*glSecondaryColor3iEXT_PTR)(glSecondaryColor3iEXT_ARG_EXPAND);
#define glSecondaryColor3iv_INDEX 1891
#define glSecondaryColor3iv_RETURN void
#define glSecondaryColor3iv_ARG_NAMES v
#define glSecondaryColor3iv_ARG_EXPAND const GLint * v
#define glSecondaryColor3iv_PACKED PACKED_glSecondaryColor3iv
#define glSecondaryColor3iv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glSecondaryColor3iv_NOT_VOID_WRAP(...) {}
#define pack_glSecondaryColor3iv(_v) ({ \
    glSecondaryColor3iv_PACKED *packed_data = malloc(sizeof(glSecondaryColor3iv_PACKED)); \
    packed_data->index = glSecondaryColor3iv_INDEX; \
    packed_data->args.v = (GLint *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glSecondaryColor3iv(packed, ret_v) do { \
    PACKED_glSecondaryColor3iv *unpacked = (PACKED_glSecondaryColor3iv *)packed; \
    ARGS_glSecondaryColor3iv *args = (ARGS_glSecondaryColor3iv *)&unpacked->args; \
    glSecondaryColor3iv(args->v);; \
} while(0)
void glSecondaryColor3iv(glSecondaryColor3iv_ARG_EXPAND);
typedef void (*glSecondaryColor3iv_PTR)(glSecondaryColor3iv_ARG_EXPAND);
#define glSecondaryColor3ivEXT_INDEX 1892
#define glSecondaryColor3ivEXT_RETURN void
#define glSecondaryColor3ivEXT_ARG_NAMES v
#define glSecondaryColor3ivEXT_ARG_EXPAND const GLint * v
#define glSecondaryColor3ivEXT_PACKED PACKED_glSecondaryColor3ivEXT
#define glSecondaryColor3ivEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glSecondaryColor3ivEXT_NOT_VOID_WRAP(...) {}
#define pack_glSecondaryColor3ivEXT(_v) ({ \
    glSecondaryColor3ivEXT_PACKED *packed_data = malloc(sizeof(glSecondaryColor3ivEXT_PACKED)); \
    packed_data->index = glSecondaryColor3ivEXT_INDEX; \
    packed_data->args.v = (GLint *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glSecondaryColor3ivEXT(packed, ret_v) do { \
    PACKED_glSecondaryColor3ivEXT *unpacked = (PACKED_glSecondaryColor3ivEXT *)packed; \
    ARGS_glSecondaryColor3ivEXT *args = (ARGS_glSecondaryColor3ivEXT *)&unpacked->args; \
    glSecondaryColor3ivEXT(args->v);; \
} while(0)
void glSecondaryColor3ivEXT(glSecondaryColor3ivEXT_ARG_EXPAND);
typedef void (*glSecondaryColor3ivEXT_PTR)(glSecondaryColor3ivEXT_ARG_EXPAND);
#define glSecondaryColor3s_INDEX 1893
#define glSecondaryColor3s_RETURN void
#define glSecondaryColor3s_ARG_NAMES red, green, blue
#define glSecondaryColor3s_ARG_EXPAND GLshort red, GLshort green, GLshort blue
#define glSecondaryColor3s_PACKED PACKED_glSecondaryColor3s
#define glSecondaryColor3s_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glSecondaryColor3s_NOT_VOID_WRAP(...) {}
#define pack_glSecondaryColor3s(_red, _green, _blue) ({ \
    glSecondaryColor3s_PACKED *packed_data = malloc(sizeof(glSecondaryColor3s_PACKED)); \
    packed_data->index = glSecondaryColor3s_INDEX; \
    packed_data->args.red = (GLshort)_red; \
    packed_data->args.green = (GLshort)_green; \
    packed_data->args.blue = (GLshort)_blue; \
    (packed_call_t *)packed_data; \
})
#define call_glSecondaryColor3s(packed, ret_v) do { \
    PACKED_glSecondaryColor3s *unpacked = (PACKED_glSecondaryColor3s *)packed; \
    ARGS_glSecondaryColor3s *args = (ARGS_glSecondaryColor3s *)&unpacked->args; \
    glSecondaryColor3s(args->red, args->green, args->blue);; \
} while(0)
void glSecondaryColor3s(glSecondaryColor3s_ARG_EXPAND);
typedef void (*glSecondaryColor3s_PTR)(glSecondaryColor3s_ARG_EXPAND);
#define glSecondaryColor3sEXT_INDEX 1894
#define glSecondaryColor3sEXT_RETURN void
#define glSecondaryColor3sEXT_ARG_NAMES red, green, blue
#define glSecondaryColor3sEXT_ARG_EXPAND GLshort red, GLshort green, GLshort blue
#define glSecondaryColor3sEXT_PACKED PACKED_glSecondaryColor3sEXT
#define glSecondaryColor3sEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glSecondaryColor3sEXT_NOT_VOID_WRAP(...) {}
#define pack_glSecondaryColor3sEXT(_red, _green, _blue) ({ \
    glSecondaryColor3sEXT_PACKED *packed_data = malloc(sizeof(glSecondaryColor3sEXT_PACKED)); \
    packed_data->index = glSecondaryColor3sEXT_INDEX; \
    packed_data->args.red = (GLshort)_red; \
    packed_data->args.green = (GLshort)_green; \
    packed_data->args.blue = (GLshort)_blue; \
    (packed_call_t *)packed_data; \
})
#define call_glSecondaryColor3sEXT(packed, ret_v) do { \
    PACKED_glSecondaryColor3sEXT *unpacked = (PACKED_glSecondaryColor3sEXT *)packed; \
    ARGS_glSecondaryColor3sEXT *args = (ARGS_glSecondaryColor3sEXT *)&unpacked->args; \
    glSecondaryColor3sEXT(args->red, args->green, args->blue);; \
} while(0)
void glSecondaryColor3sEXT(glSecondaryColor3sEXT_ARG_EXPAND);
typedef void (*glSecondaryColor3sEXT_PTR)(glSecondaryColor3sEXT_ARG_EXPAND);
#define glSecondaryColor3sv_INDEX 1895
#define glSecondaryColor3sv_RETURN void
#define glSecondaryColor3sv_ARG_NAMES v
#define glSecondaryColor3sv_ARG_EXPAND const GLshort * v
#define glSecondaryColor3sv_PACKED PACKED_glSecondaryColor3sv
#define glSecondaryColor3sv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glSecondaryColor3sv_NOT_VOID_WRAP(...) {}
#define pack_glSecondaryColor3sv(_v) ({ \
    glSecondaryColor3sv_PACKED *packed_data = malloc(sizeof(glSecondaryColor3sv_PACKED)); \
    packed_data->index = glSecondaryColor3sv_INDEX; \
    packed_data->args.v = (GLshort *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glSecondaryColor3sv(packed, ret_v) do { \
    PACKED_glSecondaryColor3sv *unpacked = (PACKED_glSecondaryColor3sv *)packed; \
    ARGS_glSecondaryColor3sv *args = (ARGS_glSecondaryColor3sv *)&unpacked->args; \
    glSecondaryColor3sv(args->v);; \
} while(0)
void glSecondaryColor3sv(glSecondaryColor3sv_ARG_EXPAND);
typedef void (*glSecondaryColor3sv_PTR)(glSecondaryColor3sv_ARG_EXPAND);
#define glSecondaryColor3svEXT_INDEX 1896
#define glSecondaryColor3svEXT_RETURN void
#define glSecondaryColor3svEXT_ARG_NAMES v
#define glSecondaryColor3svEXT_ARG_EXPAND const GLshort * v
#define glSecondaryColor3svEXT_PACKED PACKED_glSecondaryColor3svEXT
#define glSecondaryColor3svEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glSecondaryColor3svEXT_NOT_VOID_WRAP(...) {}
#define pack_glSecondaryColor3svEXT(_v) ({ \
    glSecondaryColor3svEXT_PACKED *packed_data = malloc(sizeof(glSecondaryColor3svEXT_PACKED)); \
    packed_data->index = glSecondaryColor3svEXT_INDEX; \
    packed_data->args.v = (GLshort *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glSecondaryColor3svEXT(packed, ret_v) do { \
    PACKED_glSecondaryColor3svEXT *unpacked = (PACKED_glSecondaryColor3svEXT *)packed; \
    ARGS_glSecondaryColor3svEXT *args = (ARGS_glSecondaryColor3svEXT *)&unpacked->args; \
    glSecondaryColor3svEXT(args->v);; \
} while(0)
void glSecondaryColor3svEXT(glSecondaryColor3svEXT_ARG_EXPAND);
typedef void (*glSecondaryColor3svEXT_PTR)(glSecondaryColor3svEXT_ARG_EXPAND);
#define glSecondaryColor3ub_INDEX 1897
#define glSecondaryColor3ub_RETURN void
#define glSecondaryColor3ub_ARG_NAMES red, green, blue
#define glSecondaryColor3ub_ARG_EXPAND GLubyte red, GLubyte green, GLubyte blue
#define glSecondaryColor3ub_PACKED PACKED_glSecondaryColor3ub
#define glSecondaryColor3ub_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glSecondaryColor3ub_NOT_VOID_WRAP(...) {}
#define pack_glSecondaryColor3ub(_red, _green, _blue) ({ \
    glSecondaryColor3ub_PACKED *packed_data = malloc(sizeof(glSecondaryColor3ub_PACKED)); \
    packed_data->index = glSecondaryColor3ub_INDEX; \
    packed_data->args.red = (GLubyte)_red; \
    packed_data->args.green = (GLubyte)_green; \
    packed_data->args.blue = (GLubyte)_blue; \
    (packed_call_t *)packed_data; \
})
#define call_glSecondaryColor3ub(packed, ret_v) do { \
    PACKED_glSecondaryColor3ub *unpacked = (PACKED_glSecondaryColor3ub *)packed; \
    ARGS_glSecondaryColor3ub *args = (ARGS_glSecondaryColor3ub *)&unpacked->args; \
    glSecondaryColor3ub(args->red, args->green, args->blue);; \
} while(0)
void glSecondaryColor3ub(glSecondaryColor3ub_ARG_EXPAND);
typedef void (*glSecondaryColor3ub_PTR)(glSecondaryColor3ub_ARG_EXPAND);
#define glSecondaryColor3ubEXT_INDEX 1898
#define glSecondaryColor3ubEXT_RETURN void
#define glSecondaryColor3ubEXT_ARG_NAMES red, green, blue
#define glSecondaryColor3ubEXT_ARG_EXPAND GLubyte red, GLubyte green, GLubyte blue
#define glSecondaryColor3ubEXT_PACKED PACKED_glSecondaryColor3ubEXT
#define glSecondaryColor3ubEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glSecondaryColor3ubEXT_NOT_VOID_WRAP(...) {}
#define pack_glSecondaryColor3ubEXT(_red, _green, _blue) ({ \
    glSecondaryColor3ubEXT_PACKED *packed_data = malloc(sizeof(glSecondaryColor3ubEXT_PACKED)); \
    packed_data->index = glSecondaryColor3ubEXT_INDEX; \
    packed_data->args.red = (GLubyte)_red; \
    packed_data->args.green = (GLubyte)_green; \
    packed_data->args.blue = (GLubyte)_blue; \
    (packed_call_t *)packed_data; \
})
#define call_glSecondaryColor3ubEXT(packed, ret_v) do { \
    PACKED_glSecondaryColor3ubEXT *unpacked = (PACKED_glSecondaryColor3ubEXT *)packed; \
    ARGS_glSecondaryColor3ubEXT *args = (ARGS_glSecondaryColor3ubEXT *)&unpacked->args; \
    glSecondaryColor3ubEXT(args->red, args->green, args->blue);; \
} while(0)
void glSecondaryColor3ubEXT(glSecondaryColor3ubEXT_ARG_EXPAND);
typedef void (*glSecondaryColor3ubEXT_PTR)(glSecondaryColor3ubEXT_ARG_EXPAND);
#define glSecondaryColor3ubv_INDEX 1899
#define glSecondaryColor3ubv_RETURN void
#define glSecondaryColor3ubv_ARG_NAMES v
#define glSecondaryColor3ubv_ARG_EXPAND const GLubyte * v
#define glSecondaryColor3ubv_PACKED PACKED_glSecondaryColor3ubv
#define glSecondaryColor3ubv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glSecondaryColor3ubv_NOT_VOID_WRAP(...) {}
#define pack_glSecondaryColor3ubv(_v) ({ \
    glSecondaryColor3ubv_PACKED *packed_data = malloc(sizeof(glSecondaryColor3ubv_PACKED)); \
    packed_data->index = glSecondaryColor3ubv_INDEX; \
    packed_data->args.v = (GLubyte *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glSecondaryColor3ubv(packed, ret_v) do { \
    PACKED_glSecondaryColor3ubv *unpacked = (PACKED_glSecondaryColor3ubv *)packed; \
    ARGS_glSecondaryColor3ubv *args = (ARGS_glSecondaryColor3ubv *)&unpacked->args; \
    glSecondaryColor3ubv(args->v);; \
} while(0)
void glSecondaryColor3ubv(glSecondaryColor3ubv_ARG_EXPAND);
typedef void (*glSecondaryColor3ubv_PTR)(glSecondaryColor3ubv_ARG_EXPAND);
#define glSecondaryColor3ubvEXT_INDEX 1900
#define glSecondaryColor3ubvEXT_RETURN void
#define glSecondaryColor3ubvEXT_ARG_NAMES v
#define glSecondaryColor3ubvEXT_ARG_EXPAND const GLubyte * v
#define glSecondaryColor3ubvEXT_PACKED PACKED_glSecondaryColor3ubvEXT
#define glSecondaryColor3ubvEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glSecondaryColor3ubvEXT_NOT_VOID_WRAP(...) {}
#define pack_glSecondaryColor3ubvEXT(_v) ({ \
    glSecondaryColor3ubvEXT_PACKED *packed_data = malloc(sizeof(glSecondaryColor3ubvEXT_PACKED)); \
    packed_data->index = glSecondaryColor3ubvEXT_INDEX; \
    packed_data->args.v = (GLubyte *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glSecondaryColor3ubvEXT(packed, ret_v) do { \
    PACKED_glSecondaryColor3ubvEXT *unpacked = (PACKED_glSecondaryColor3ubvEXT *)packed; \
    ARGS_glSecondaryColor3ubvEXT *args = (ARGS_glSecondaryColor3ubvEXT *)&unpacked->args; \
    glSecondaryColor3ubvEXT(args->v);; \
} while(0)
void glSecondaryColor3ubvEXT(glSecondaryColor3ubvEXT_ARG_EXPAND);
typedef void (*glSecondaryColor3ubvEXT_PTR)(glSecondaryColor3ubvEXT_ARG_EXPAND);
#define glSecondaryColor3ui_INDEX 1901
#define glSecondaryColor3ui_RETURN void
#define glSecondaryColor3ui_ARG_NAMES red, green, blue
#define glSecondaryColor3ui_ARG_EXPAND GLuint red, GLuint green, GLuint blue
#define glSecondaryColor3ui_PACKED PACKED_glSecondaryColor3ui
#define glSecondaryColor3ui_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glSecondaryColor3ui_NOT_VOID_WRAP(...) {}
#define pack_glSecondaryColor3ui(_red, _green, _blue) ({ \
    glSecondaryColor3ui_PACKED *packed_data = malloc(sizeof(glSecondaryColor3ui_PACKED)); \
    packed_data->index = glSecondaryColor3ui_INDEX; \
    packed_data->args.red = (GLuint)_red; \
    packed_data->args.green = (GLuint)_green; \
    packed_data->args.blue = (GLuint)_blue; \
    (packed_call_t *)packed_data; \
})
#define call_glSecondaryColor3ui(packed, ret_v) do { \
    PACKED_glSecondaryColor3ui *unpacked = (PACKED_glSecondaryColor3ui *)packed; \
    ARGS_glSecondaryColor3ui *args = (ARGS_glSecondaryColor3ui *)&unpacked->args; \
    glSecondaryColor3ui(args->red, args->green, args->blue);; \
} while(0)
void glSecondaryColor3ui(glSecondaryColor3ui_ARG_EXPAND);
typedef void (*glSecondaryColor3ui_PTR)(glSecondaryColor3ui_ARG_EXPAND);
#define glSecondaryColor3uiEXT_INDEX 1902
#define glSecondaryColor3uiEXT_RETURN void
#define glSecondaryColor3uiEXT_ARG_NAMES red, green, blue
#define glSecondaryColor3uiEXT_ARG_EXPAND GLuint red, GLuint green, GLuint blue
#define glSecondaryColor3uiEXT_PACKED PACKED_glSecondaryColor3uiEXT
#define glSecondaryColor3uiEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glSecondaryColor3uiEXT_NOT_VOID_WRAP(...) {}
#define pack_glSecondaryColor3uiEXT(_red, _green, _blue) ({ \
    glSecondaryColor3uiEXT_PACKED *packed_data = malloc(sizeof(glSecondaryColor3uiEXT_PACKED)); \
    packed_data->index = glSecondaryColor3uiEXT_INDEX; \
    packed_data->args.red = (GLuint)_red; \
    packed_data->args.green = (GLuint)_green; \
    packed_data->args.blue = (GLuint)_blue; \
    (packed_call_t *)packed_data; \
})
#define call_glSecondaryColor3uiEXT(packed, ret_v) do { \
    PACKED_glSecondaryColor3uiEXT *unpacked = (PACKED_glSecondaryColor3uiEXT *)packed; \
    ARGS_glSecondaryColor3uiEXT *args = (ARGS_glSecondaryColor3uiEXT *)&unpacked->args; \
    glSecondaryColor3uiEXT(args->red, args->green, args->blue);; \
} while(0)
void glSecondaryColor3uiEXT(glSecondaryColor3uiEXT_ARG_EXPAND);
typedef void (*glSecondaryColor3uiEXT_PTR)(glSecondaryColor3uiEXT_ARG_EXPAND);
#define glSecondaryColor3uiv_INDEX 1903
#define glSecondaryColor3uiv_RETURN void
#define glSecondaryColor3uiv_ARG_NAMES v
#define glSecondaryColor3uiv_ARG_EXPAND const GLuint * v
#define glSecondaryColor3uiv_PACKED PACKED_glSecondaryColor3uiv
#define glSecondaryColor3uiv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glSecondaryColor3uiv_NOT_VOID_WRAP(...) {}
#define pack_glSecondaryColor3uiv(_v) ({ \
    glSecondaryColor3uiv_PACKED *packed_data = malloc(sizeof(glSecondaryColor3uiv_PACKED)); \
    packed_data->index = glSecondaryColor3uiv_INDEX; \
    packed_data->args.v = (GLuint *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glSecondaryColor3uiv(packed, ret_v) do { \
    PACKED_glSecondaryColor3uiv *unpacked = (PACKED_glSecondaryColor3uiv *)packed; \
    ARGS_glSecondaryColor3uiv *args = (ARGS_glSecondaryColor3uiv *)&unpacked->args; \
    glSecondaryColor3uiv(args->v);; \
} while(0)
void glSecondaryColor3uiv(glSecondaryColor3uiv_ARG_EXPAND);
typedef void (*glSecondaryColor3uiv_PTR)(glSecondaryColor3uiv_ARG_EXPAND);
#define glSecondaryColor3uivEXT_INDEX 1904
#define glSecondaryColor3uivEXT_RETURN void
#define glSecondaryColor3uivEXT_ARG_NAMES v
#define glSecondaryColor3uivEXT_ARG_EXPAND const GLuint * v
#define glSecondaryColor3uivEXT_PACKED PACKED_glSecondaryColor3uivEXT
#define glSecondaryColor3uivEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glSecondaryColor3uivEXT_NOT_VOID_WRAP(...) {}
#define pack_glSecondaryColor3uivEXT(_v) ({ \
    glSecondaryColor3uivEXT_PACKED *packed_data = malloc(sizeof(glSecondaryColor3uivEXT_PACKED)); \
    packed_data->index = glSecondaryColor3uivEXT_INDEX; \
    packed_data->args.v = (GLuint *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glSecondaryColor3uivEXT(packed, ret_v) do { \
    PACKED_glSecondaryColor3uivEXT *unpacked = (PACKED_glSecondaryColor3uivEXT *)packed; \
    ARGS_glSecondaryColor3uivEXT *args = (ARGS_glSecondaryColor3uivEXT *)&unpacked->args; \
    glSecondaryColor3uivEXT(args->v);; \
} while(0)
void glSecondaryColor3uivEXT(glSecondaryColor3uivEXT_ARG_EXPAND);
typedef void (*glSecondaryColor3uivEXT_PTR)(glSecondaryColor3uivEXT_ARG_EXPAND);
#define glSecondaryColor3us_INDEX 1905
#define glSecondaryColor3us_RETURN void
#define glSecondaryColor3us_ARG_NAMES red, green, blue
#define glSecondaryColor3us_ARG_EXPAND GLushort red, GLushort green, GLushort blue
#define glSecondaryColor3us_PACKED PACKED_glSecondaryColor3us
#define glSecondaryColor3us_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glSecondaryColor3us_NOT_VOID_WRAP(...) {}
#define pack_glSecondaryColor3us(_red, _green, _blue) ({ \
    glSecondaryColor3us_PACKED *packed_data = malloc(sizeof(glSecondaryColor3us_PACKED)); \
    packed_data->index = glSecondaryColor3us_INDEX; \
    packed_data->args.red = (GLushort)_red; \
    packed_data->args.green = (GLushort)_green; \
    packed_data->args.blue = (GLushort)_blue; \
    (packed_call_t *)packed_data; \
})
#define call_glSecondaryColor3us(packed, ret_v) do { \
    PACKED_glSecondaryColor3us *unpacked = (PACKED_glSecondaryColor3us *)packed; \
    ARGS_glSecondaryColor3us *args = (ARGS_glSecondaryColor3us *)&unpacked->args; \
    glSecondaryColor3us(args->red, args->green, args->blue);; \
} while(0)
void glSecondaryColor3us(glSecondaryColor3us_ARG_EXPAND);
typedef void (*glSecondaryColor3us_PTR)(glSecondaryColor3us_ARG_EXPAND);
#define glSecondaryColor3usEXT_INDEX 1906
#define glSecondaryColor3usEXT_RETURN void
#define glSecondaryColor3usEXT_ARG_NAMES red, green, blue
#define glSecondaryColor3usEXT_ARG_EXPAND GLushort red, GLushort green, GLushort blue
#define glSecondaryColor3usEXT_PACKED PACKED_glSecondaryColor3usEXT
#define glSecondaryColor3usEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glSecondaryColor3usEXT_NOT_VOID_WRAP(...) {}
#define pack_glSecondaryColor3usEXT(_red, _green, _blue) ({ \
    glSecondaryColor3usEXT_PACKED *packed_data = malloc(sizeof(glSecondaryColor3usEXT_PACKED)); \
    packed_data->index = glSecondaryColor3usEXT_INDEX; \
    packed_data->args.red = (GLushort)_red; \
    packed_data->args.green = (GLushort)_green; \
    packed_data->args.blue = (GLushort)_blue; \
    (packed_call_t *)packed_data; \
})
#define call_glSecondaryColor3usEXT(packed, ret_v) do { \
    PACKED_glSecondaryColor3usEXT *unpacked = (PACKED_glSecondaryColor3usEXT *)packed; \
    ARGS_glSecondaryColor3usEXT *args = (ARGS_glSecondaryColor3usEXT *)&unpacked->args; \
    glSecondaryColor3usEXT(args->red, args->green, args->blue);; \
} while(0)
void glSecondaryColor3usEXT(glSecondaryColor3usEXT_ARG_EXPAND);
typedef void (*glSecondaryColor3usEXT_PTR)(glSecondaryColor3usEXT_ARG_EXPAND);
#define glSecondaryColor3usv_INDEX 1907
#define glSecondaryColor3usv_RETURN void
#define glSecondaryColor3usv_ARG_NAMES v
#define glSecondaryColor3usv_ARG_EXPAND const GLushort * v
#define glSecondaryColor3usv_PACKED PACKED_glSecondaryColor3usv
#define glSecondaryColor3usv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glSecondaryColor3usv_NOT_VOID_WRAP(...) {}
#define pack_glSecondaryColor3usv(_v) ({ \
    glSecondaryColor3usv_PACKED *packed_data = malloc(sizeof(glSecondaryColor3usv_PACKED)); \
    packed_data->index = glSecondaryColor3usv_INDEX; \
    packed_data->args.v = (GLushort *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glSecondaryColor3usv(packed, ret_v) do { \
    PACKED_glSecondaryColor3usv *unpacked = (PACKED_glSecondaryColor3usv *)packed; \
    ARGS_glSecondaryColor3usv *args = (ARGS_glSecondaryColor3usv *)&unpacked->args; \
    glSecondaryColor3usv(args->v);; \
} while(0)
void glSecondaryColor3usv(glSecondaryColor3usv_ARG_EXPAND);
typedef void (*glSecondaryColor3usv_PTR)(glSecondaryColor3usv_ARG_EXPAND);
#define glSecondaryColor3usvEXT_INDEX 1908
#define glSecondaryColor3usvEXT_RETURN void
#define glSecondaryColor3usvEXT_ARG_NAMES v
#define glSecondaryColor3usvEXT_ARG_EXPAND const GLushort * v
#define glSecondaryColor3usvEXT_PACKED PACKED_glSecondaryColor3usvEXT
#define glSecondaryColor3usvEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glSecondaryColor3usvEXT_NOT_VOID_WRAP(...) {}
#define pack_glSecondaryColor3usvEXT(_v) ({ \
    glSecondaryColor3usvEXT_PACKED *packed_data = malloc(sizeof(glSecondaryColor3usvEXT_PACKED)); \
    packed_data->index = glSecondaryColor3usvEXT_INDEX; \
    packed_data->args.v = (GLushort *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glSecondaryColor3usvEXT(packed, ret_v) do { \
    PACKED_glSecondaryColor3usvEXT *unpacked = (PACKED_glSecondaryColor3usvEXT *)packed; \
    ARGS_glSecondaryColor3usvEXT *args = (ARGS_glSecondaryColor3usvEXT *)&unpacked->args; \
    glSecondaryColor3usvEXT(args->v);; \
} while(0)
void glSecondaryColor3usvEXT(glSecondaryColor3usvEXT_ARG_EXPAND);
typedef void (*glSecondaryColor3usvEXT_PTR)(glSecondaryColor3usvEXT_ARG_EXPAND);
#define glSecondaryColorFormatNV_INDEX 1909
#define glSecondaryColorFormatNV_RETURN void
#define glSecondaryColorFormatNV_ARG_NAMES size, type, stride
#define glSecondaryColorFormatNV_ARG_EXPAND GLint size, GLenum type, GLsizei stride
#define glSecondaryColorFormatNV_PACKED PACKED_glSecondaryColorFormatNV
#define glSecondaryColorFormatNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glSecondaryColorFormatNV_NOT_VOID_WRAP(...) {}
#define pack_glSecondaryColorFormatNV(_size, _type, _stride) ({ \
    glSecondaryColorFormatNV_PACKED *packed_data = malloc(sizeof(glSecondaryColorFormatNV_PACKED)); \
    packed_data->index = glSecondaryColorFormatNV_INDEX; \
    packed_data->args.size = (GLint)_size; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.stride = (GLsizei)_stride; \
    (packed_call_t *)packed_data; \
})
#define call_glSecondaryColorFormatNV(packed, ret_v) do { \
    PACKED_glSecondaryColorFormatNV *unpacked = (PACKED_glSecondaryColorFormatNV *)packed; \
    ARGS_glSecondaryColorFormatNV *args = (ARGS_glSecondaryColorFormatNV *)&unpacked->args; \
    glSecondaryColorFormatNV(args->size, args->type, args->stride);; \
} while(0)
void glSecondaryColorFormatNV(glSecondaryColorFormatNV_ARG_EXPAND);
typedef void (*glSecondaryColorFormatNV_PTR)(glSecondaryColorFormatNV_ARG_EXPAND);
#define glSecondaryColorP3ui_INDEX 1910
#define glSecondaryColorP3ui_RETURN void
#define glSecondaryColorP3ui_ARG_NAMES type, color
#define glSecondaryColorP3ui_ARG_EXPAND GLenum type, GLuint color
#define glSecondaryColorP3ui_PACKED PACKED_glSecondaryColorP3ui
#define glSecondaryColorP3ui_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glSecondaryColorP3ui_NOT_VOID_WRAP(...) {}
#define pack_glSecondaryColorP3ui(_type, _color) ({ \
    glSecondaryColorP3ui_PACKED *packed_data = malloc(sizeof(glSecondaryColorP3ui_PACKED)); \
    packed_data->index = glSecondaryColorP3ui_INDEX; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.color = (GLuint)_color; \
    (packed_call_t *)packed_data; \
})
#define call_glSecondaryColorP3ui(packed, ret_v) do { \
    PACKED_glSecondaryColorP3ui *unpacked = (PACKED_glSecondaryColorP3ui *)packed; \
    ARGS_glSecondaryColorP3ui *args = (ARGS_glSecondaryColorP3ui *)&unpacked->args; \
    glSecondaryColorP3ui(args->type, args->color);; \
} while(0)
void glSecondaryColorP3ui(glSecondaryColorP3ui_ARG_EXPAND);
typedef void (*glSecondaryColorP3ui_PTR)(glSecondaryColorP3ui_ARG_EXPAND);
#define glSecondaryColorP3uiv_INDEX 1911
#define glSecondaryColorP3uiv_RETURN void
#define glSecondaryColorP3uiv_ARG_NAMES type, color
#define glSecondaryColorP3uiv_ARG_EXPAND GLenum type, const GLuint * color
#define glSecondaryColorP3uiv_PACKED PACKED_glSecondaryColorP3uiv
#define glSecondaryColorP3uiv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glSecondaryColorP3uiv_NOT_VOID_WRAP(...) {}
#define pack_glSecondaryColorP3uiv(_type, _color) ({ \
    glSecondaryColorP3uiv_PACKED *packed_data = malloc(sizeof(glSecondaryColorP3uiv_PACKED)); \
    packed_data->index = glSecondaryColorP3uiv_INDEX; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.color = (GLuint *)_color; \
    (packed_call_t *)packed_data; \
})
#define call_glSecondaryColorP3uiv(packed, ret_v) do { \
    PACKED_glSecondaryColorP3uiv *unpacked = (PACKED_glSecondaryColorP3uiv *)packed; \
    ARGS_glSecondaryColorP3uiv *args = (ARGS_glSecondaryColorP3uiv *)&unpacked->args; \
    glSecondaryColorP3uiv(args->type, args->color);; \
} while(0)
void glSecondaryColorP3uiv(glSecondaryColorP3uiv_ARG_EXPAND);
typedef void (*glSecondaryColorP3uiv_PTR)(glSecondaryColorP3uiv_ARG_EXPAND);
#define glSecondaryColorPointer_INDEX 1912
#define glSecondaryColorPointer_RETURN void
#define glSecondaryColorPointer_ARG_NAMES size, type, stride, pointer
#define glSecondaryColorPointer_ARG_EXPAND GLint size, GLenum type, GLsizei stride, const GLvoid * pointer
#define glSecondaryColorPointer_PACKED PACKED_glSecondaryColorPointer
#define glSecondaryColorPointer_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glSecondaryColorPointer_NOT_VOID_WRAP(...) {}
#define pack_glSecondaryColorPointer(_size, _type, _stride, _pointer) ({ \
    glSecondaryColorPointer_PACKED *packed_data = malloc(sizeof(glSecondaryColorPointer_PACKED)); \
    packed_data->index = glSecondaryColorPointer_INDEX; \
    packed_data->args.size = (GLint)_size; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.stride = (GLsizei)_stride; \
    packed_data->args.pointer = (GLvoid *)_pointer; \
    (packed_call_t *)packed_data; \
})
#define call_glSecondaryColorPointer(packed, ret_v) do { \
    PACKED_glSecondaryColorPointer *unpacked = (PACKED_glSecondaryColorPointer *)packed; \
    ARGS_glSecondaryColorPointer *args = (ARGS_glSecondaryColorPointer *)&unpacked->args; \
    glSecondaryColorPointer(args->size, args->type, args->stride, args->pointer);; \
} while(0)
void glSecondaryColorPointer(glSecondaryColorPointer_ARG_EXPAND);
typedef void (*glSecondaryColorPointer_PTR)(glSecondaryColorPointer_ARG_EXPAND);
#define glSecondaryColorPointerEXT_INDEX 1913
#define glSecondaryColorPointerEXT_RETURN void
#define glSecondaryColorPointerEXT_ARG_NAMES size, type, stride, pointer
#define glSecondaryColorPointerEXT_ARG_EXPAND GLint size, GLenum type, GLsizei stride, const GLvoid * pointer
#define glSecondaryColorPointerEXT_PACKED PACKED_glSecondaryColorPointerEXT
#define glSecondaryColorPointerEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glSecondaryColorPointerEXT_NOT_VOID_WRAP(...) {}
#define pack_glSecondaryColorPointerEXT(_size, _type, _stride, _pointer) ({ \
    glSecondaryColorPointerEXT_PACKED *packed_data = malloc(sizeof(glSecondaryColorPointerEXT_PACKED)); \
    packed_data->index = glSecondaryColorPointerEXT_INDEX; \
    packed_data->args.size = (GLint)_size; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.stride = (GLsizei)_stride; \
    packed_data->args.pointer = (GLvoid *)_pointer; \
    (packed_call_t *)packed_data; \
})
#define call_glSecondaryColorPointerEXT(packed, ret_v) do { \
    PACKED_glSecondaryColorPointerEXT *unpacked = (PACKED_glSecondaryColorPointerEXT *)packed; \
    ARGS_glSecondaryColorPointerEXT *args = (ARGS_glSecondaryColorPointerEXT *)&unpacked->args; \
    glSecondaryColorPointerEXT(args->size, args->type, args->stride, args->pointer);; \
} while(0)
void glSecondaryColorPointerEXT(glSecondaryColorPointerEXT_ARG_EXPAND);
typedef void (*glSecondaryColorPointerEXT_PTR)(glSecondaryColorPointerEXT_ARG_EXPAND);
#define glSecondaryColorPointerListIBM_INDEX 1914
#define glSecondaryColorPointerListIBM_RETURN void
#define glSecondaryColorPointerListIBM_ARG_NAMES size, type, stride, pointer, ptrstride
#define glSecondaryColorPointerListIBM_ARG_EXPAND GLint size, GLenum type, GLint stride, const GLvoid * pointer, GLint ptrstride
#define glSecondaryColorPointerListIBM_PACKED PACKED_glSecondaryColorPointerListIBM
#define glSecondaryColorPointerListIBM_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glSecondaryColorPointerListIBM_NOT_VOID_WRAP(...) {}
#define pack_glSecondaryColorPointerListIBM(_size, _type, _stride, _pointer, _ptrstride) ({ \
    glSecondaryColorPointerListIBM_PACKED *packed_data = malloc(sizeof(glSecondaryColorPointerListIBM_PACKED)); \
    packed_data->index = glSecondaryColorPointerListIBM_INDEX; \
    packed_data->args.size = (GLint)_size; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.stride = (GLint)_stride; \
    packed_data->args.pointer = (GLvoid *)_pointer; \
    packed_data->args.ptrstride = (GLint)_ptrstride; \
    (packed_call_t *)packed_data; \
})
#define call_glSecondaryColorPointerListIBM(packed, ret_v) do { \
    PACKED_glSecondaryColorPointerListIBM *unpacked = (PACKED_glSecondaryColorPointerListIBM *)packed; \
    ARGS_glSecondaryColorPointerListIBM *args = (ARGS_glSecondaryColorPointerListIBM *)&unpacked->args; \
    glSecondaryColorPointerListIBM(args->size, args->type, args->stride, args->pointer, args->ptrstride);; \
} while(0)
void glSecondaryColorPointerListIBM(glSecondaryColorPointerListIBM_ARG_EXPAND);
typedef void (*glSecondaryColorPointerListIBM_PTR)(glSecondaryColorPointerListIBM_ARG_EXPAND);
#define glSelectBuffer_INDEX 1915
#define glSelectBuffer_RETURN void
#define glSelectBuffer_ARG_NAMES size, buffer
#define glSelectBuffer_ARG_EXPAND GLsizei size, GLuint * buffer
#define glSelectBuffer_PACKED PACKED_glSelectBuffer
#define glSelectBuffer_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glSelectBuffer_NOT_VOID_WRAP(...) {}
#define pack_glSelectBuffer(_size, _buffer) ({ \
    glSelectBuffer_PACKED *packed_data = malloc(sizeof(glSelectBuffer_PACKED)); \
    packed_data->index = glSelectBuffer_INDEX; \
    packed_data->args.size = (GLsizei)_size; \
    packed_data->args.buffer = (GLuint *)_buffer; \
    (packed_call_t *)packed_data; \
})
#define call_glSelectBuffer(packed, ret_v) do { \
    PACKED_glSelectBuffer *unpacked = (PACKED_glSelectBuffer *)packed; \
    ARGS_glSelectBuffer *args = (ARGS_glSelectBuffer *)&unpacked->args; \
    glSelectBuffer(args->size, args->buffer);; \
} while(0)
void glSelectBuffer(glSelectBuffer_ARG_EXPAND);
typedef void (*glSelectBuffer_PTR)(glSelectBuffer_ARG_EXPAND);
#define glSelectPerfMonitorCountersAMD_INDEX 1916
#define glSelectPerfMonitorCountersAMD_RETURN void
#define glSelectPerfMonitorCountersAMD_ARG_NAMES monitor, enable, group, numCounters, counterList
#define glSelectPerfMonitorCountersAMD_ARG_EXPAND GLuint monitor, GLboolean enable, GLuint group, GLint numCounters, GLuint * counterList
#define glSelectPerfMonitorCountersAMD_PACKED PACKED_glSelectPerfMonitorCountersAMD
#define glSelectPerfMonitorCountersAMD_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glSelectPerfMonitorCountersAMD_NOT_VOID_WRAP(...) {}
#define pack_glSelectPerfMonitorCountersAMD(_monitor, _enable, _group, _numCounters, _counterList) ({ \
    glSelectPerfMonitorCountersAMD_PACKED *packed_data = malloc(sizeof(glSelectPerfMonitorCountersAMD_PACKED)); \
    packed_data->index = glSelectPerfMonitorCountersAMD_INDEX; \
    packed_data->args.monitor = (GLuint)_monitor; \
    packed_data->args.enable = (GLboolean)_enable; \
    packed_data->args.group = (GLuint)_group; \
    packed_data->args.numCounters = (GLint)_numCounters; \
    packed_data->args.counterList = (GLuint *)_counterList; \
    (packed_call_t *)packed_data; \
})
#define call_glSelectPerfMonitorCountersAMD(packed, ret_v) do { \
    PACKED_glSelectPerfMonitorCountersAMD *unpacked = (PACKED_glSelectPerfMonitorCountersAMD *)packed; \
    ARGS_glSelectPerfMonitorCountersAMD *args = (ARGS_glSelectPerfMonitorCountersAMD *)&unpacked->args; \
    glSelectPerfMonitorCountersAMD(args->monitor, args->enable, args->group, args->numCounters, args->counterList);; \
} while(0)
void glSelectPerfMonitorCountersAMD(glSelectPerfMonitorCountersAMD_ARG_EXPAND);
typedef void (*glSelectPerfMonitorCountersAMD_PTR)(glSelectPerfMonitorCountersAMD_ARG_EXPAND);
#define glSeparableFilter2D_INDEX 1917
#define glSeparableFilter2D_RETURN void
#define glSeparableFilter2D_ARG_NAMES target, internalformat, width, height, format, type, row, column
#define glSeparableFilter2D_ARG_EXPAND GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid * row, const GLvoid * column
#define glSeparableFilter2D_PACKED PACKED_glSeparableFilter2D
#define glSeparableFilter2D_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glSeparableFilter2D_NOT_VOID_WRAP(...) {}
#define pack_glSeparableFilter2D(_target, _internalformat, _width, _height, _format, _type, _row, _column) ({ \
    glSeparableFilter2D_PACKED *packed_data = malloc(sizeof(glSeparableFilter2D_PACKED)); \
    packed_data->index = glSeparableFilter2D_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.internalformat = (GLenum)_internalformat; \
    packed_data->args.width = (GLsizei)_width; \
    packed_data->args.height = (GLsizei)_height; \
    packed_data->args.format = (GLenum)_format; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.row = (GLvoid *)_row; \
    packed_data->args.column = (GLvoid *)_column; \
    (packed_call_t *)packed_data; \
})
#define call_glSeparableFilter2D(packed, ret_v) do { \
    PACKED_glSeparableFilter2D *unpacked = (PACKED_glSeparableFilter2D *)packed; \
    ARGS_glSeparableFilter2D *args = (ARGS_glSeparableFilter2D *)&unpacked->args; \
    glSeparableFilter2D(args->target, args->internalformat, args->width, args->height, args->format, args->type, args->row, args->column);; \
} while(0)
void glSeparableFilter2D(glSeparableFilter2D_ARG_EXPAND);
typedef void (*glSeparableFilter2D_PTR)(glSeparableFilter2D_ARG_EXPAND);
#define glSeparableFilter2DEXT_INDEX 1918
#define glSeparableFilter2DEXT_RETURN void
#define glSeparableFilter2DEXT_ARG_NAMES target, internalformat, width, height, format, type, row, column
#define glSeparableFilter2DEXT_ARG_EXPAND GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid * row, const GLvoid * column
#define glSeparableFilter2DEXT_PACKED PACKED_glSeparableFilter2DEXT
#define glSeparableFilter2DEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glSeparableFilter2DEXT_NOT_VOID_WRAP(...) {}
#define pack_glSeparableFilter2DEXT(_target, _internalformat, _width, _height, _format, _type, _row, _column) ({ \
    glSeparableFilter2DEXT_PACKED *packed_data = malloc(sizeof(glSeparableFilter2DEXT_PACKED)); \
    packed_data->index = glSeparableFilter2DEXT_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.internalformat = (GLenum)_internalformat; \
    packed_data->args.width = (GLsizei)_width; \
    packed_data->args.height = (GLsizei)_height; \
    packed_data->args.format = (GLenum)_format; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.row = (GLvoid *)_row; \
    packed_data->args.column = (GLvoid *)_column; \
    (packed_call_t *)packed_data; \
})
#define call_glSeparableFilter2DEXT(packed, ret_v) do { \
    PACKED_glSeparableFilter2DEXT *unpacked = (PACKED_glSeparableFilter2DEXT *)packed; \
    ARGS_glSeparableFilter2DEXT *args = (ARGS_glSeparableFilter2DEXT *)&unpacked->args; \
    glSeparableFilter2DEXT(args->target, args->internalformat, args->width, args->height, args->format, args->type, args->row, args->column);; \
} while(0)
void glSeparableFilter2DEXT(glSeparableFilter2DEXT_ARG_EXPAND);
typedef void (*glSeparableFilter2DEXT_PTR)(glSeparableFilter2DEXT_ARG_EXPAND);
#define glSetFenceAPPLE_INDEX 1919
#define glSetFenceAPPLE_RETURN void
#define glSetFenceAPPLE_ARG_NAMES fence
#define glSetFenceAPPLE_ARG_EXPAND GLuint fence
#define glSetFenceAPPLE_PACKED PACKED_glSetFenceAPPLE
#define glSetFenceAPPLE_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glSetFenceAPPLE_NOT_VOID_WRAP(...) {}
#define pack_glSetFenceAPPLE(_fence) ({ \
    glSetFenceAPPLE_PACKED *packed_data = malloc(sizeof(glSetFenceAPPLE_PACKED)); \
    packed_data->index = glSetFenceAPPLE_INDEX; \
    packed_data->args.fence = (GLuint)_fence; \
    (packed_call_t *)packed_data; \
})
#define call_glSetFenceAPPLE(packed, ret_v) do { \
    PACKED_glSetFenceAPPLE *unpacked = (PACKED_glSetFenceAPPLE *)packed; \
    ARGS_glSetFenceAPPLE *args = (ARGS_glSetFenceAPPLE *)&unpacked->args; \
    glSetFenceAPPLE(args->fence);; \
} while(0)
void glSetFenceAPPLE(glSetFenceAPPLE_ARG_EXPAND);
typedef void (*glSetFenceAPPLE_PTR)(glSetFenceAPPLE_ARG_EXPAND);
#define glSetFenceNV_INDEX 1920
#define glSetFenceNV_RETURN void
#define glSetFenceNV_ARG_NAMES fence, condition
#define glSetFenceNV_ARG_EXPAND GLuint fence, GLenum condition
#define glSetFenceNV_PACKED PACKED_glSetFenceNV
#define glSetFenceNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glSetFenceNV_NOT_VOID_WRAP(...) {}
#define pack_glSetFenceNV(_fence, _condition) ({ \
    glSetFenceNV_PACKED *packed_data = malloc(sizeof(glSetFenceNV_PACKED)); \
    packed_data->index = glSetFenceNV_INDEX; \
    packed_data->args.fence = (GLuint)_fence; \
    packed_data->args.condition = (GLenum)_condition; \
    (packed_call_t *)packed_data; \
})
#define call_glSetFenceNV(packed, ret_v) do { \
    PACKED_glSetFenceNV *unpacked = (PACKED_glSetFenceNV *)packed; \
    ARGS_glSetFenceNV *args = (ARGS_glSetFenceNV *)&unpacked->args; \
    glSetFenceNV(args->fence, args->condition);; \
} while(0)
void glSetFenceNV(glSetFenceNV_ARG_EXPAND);
typedef void (*glSetFenceNV_PTR)(glSetFenceNV_ARG_EXPAND);
#define glSetFragmentShaderConstantATI_INDEX 1921
#define glSetFragmentShaderConstantATI_RETURN void
#define glSetFragmentShaderConstantATI_ARG_NAMES dst, value
#define glSetFragmentShaderConstantATI_ARG_EXPAND GLuint dst, const GLfloat * value
#define glSetFragmentShaderConstantATI_PACKED PACKED_glSetFragmentShaderConstantATI
#define glSetFragmentShaderConstantATI_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glSetFragmentShaderConstantATI_NOT_VOID_WRAP(...) {}
#define pack_glSetFragmentShaderConstantATI(_dst, _value) ({ \
    glSetFragmentShaderConstantATI_PACKED *packed_data = malloc(sizeof(glSetFragmentShaderConstantATI_PACKED)); \
    packed_data->index = glSetFragmentShaderConstantATI_INDEX; \
    packed_data->args.dst = (GLuint)_dst; \
    packed_data->args.value = (GLfloat *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glSetFragmentShaderConstantATI(packed, ret_v) do { \
    PACKED_glSetFragmentShaderConstantATI *unpacked = (PACKED_glSetFragmentShaderConstantATI *)packed; \
    ARGS_glSetFragmentShaderConstantATI *args = (ARGS_glSetFragmentShaderConstantATI *)&unpacked->args; \
    glSetFragmentShaderConstantATI(args->dst, args->value);; \
} while(0)
void glSetFragmentShaderConstantATI(glSetFragmentShaderConstantATI_ARG_EXPAND);
typedef void (*glSetFragmentShaderConstantATI_PTR)(glSetFragmentShaderConstantATI_ARG_EXPAND);
#define glSetInvariantEXT_INDEX 1922
#define glSetInvariantEXT_RETURN void
#define glSetInvariantEXT_ARG_NAMES id, type, addr
#define glSetInvariantEXT_ARG_EXPAND GLuint id, GLenum type, const GLvoid * addr
#define glSetInvariantEXT_PACKED PACKED_glSetInvariantEXT
#define glSetInvariantEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glSetInvariantEXT_NOT_VOID_WRAP(...) {}
#define pack_glSetInvariantEXT(_id, _type, _addr) ({ \
    glSetInvariantEXT_PACKED *packed_data = malloc(sizeof(glSetInvariantEXT_PACKED)); \
    packed_data->index = glSetInvariantEXT_INDEX; \
    packed_data->args.id = (GLuint)_id; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.addr = (GLvoid *)_addr; \
    (packed_call_t *)packed_data; \
})
#define call_glSetInvariantEXT(packed, ret_v) do { \
    PACKED_glSetInvariantEXT *unpacked = (PACKED_glSetInvariantEXT *)packed; \
    ARGS_glSetInvariantEXT *args = (ARGS_glSetInvariantEXT *)&unpacked->args; \
    glSetInvariantEXT(args->id, args->type, args->addr);; \
} while(0)
void glSetInvariantEXT(glSetInvariantEXT_ARG_EXPAND);
typedef void (*glSetInvariantEXT_PTR)(glSetInvariantEXT_ARG_EXPAND);
#define glSetLocalConstantEXT_INDEX 1923
#define glSetLocalConstantEXT_RETURN void
#define glSetLocalConstantEXT_ARG_NAMES id, type, addr
#define glSetLocalConstantEXT_ARG_EXPAND GLuint id, GLenum type, const GLvoid * addr
#define glSetLocalConstantEXT_PACKED PACKED_glSetLocalConstantEXT
#define glSetLocalConstantEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glSetLocalConstantEXT_NOT_VOID_WRAP(...) {}
#define pack_glSetLocalConstantEXT(_id, _type, _addr) ({ \
    glSetLocalConstantEXT_PACKED *packed_data = malloc(sizeof(glSetLocalConstantEXT_PACKED)); \
    packed_data->index = glSetLocalConstantEXT_INDEX; \
    packed_data->args.id = (GLuint)_id; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.addr = (GLvoid *)_addr; \
    (packed_call_t *)packed_data; \
})
#define call_glSetLocalConstantEXT(packed, ret_v) do { \
    PACKED_glSetLocalConstantEXT *unpacked = (PACKED_glSetLocalConstantEXT *)packed; \
    ARGS_glSetLocalConstantEXT *args = (ARGS_glSetLocalConstantEXT *)&unpacked->args; \
    glSetLocalConstantEXT(args->id, args->type, args->addr);; \
} while(0)
void glSetLocalConstantEXT(glSetLocalConstantEXT_ARG_EXPAND);
typedef void (*glSetLocalConstantEXT_PTR)(glSetLocalConstantEXT_ARG_EXPAND);
#define glSetMultisamplefvAMD_INDEX 1924
#define glSetMultisamplefvAMD_RETURN void
#define glSetMultisamplefvAMD_ARG_NAMES pname, index, val
#define glSetMultisamplefvAMD_ARG_EXPAND GLenum pname, GLuint index, const GLfloat * val
#define glSetMultisamplefvAMD_PACKED PACKED_glSetMultisamplefvAMD
#define glSetMultisamplefvAMD_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glSetMultisamplefvAMD_NOT_VOID_WRAP(...) {}
#define pack_glSetMultisamplefvAMD(_pname, _index, _val) ({ \
    glSetMultisamplefvAMD_PACKED *packed_data = malloc(sizeof(glSetMultisamplefvAMD_PACKED)); \
    packed_data->index = glSetMultisamplefvAMD_INDEX; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.val = (GLfloat *)_val; \
    (packed_call_t *)packed_data; \
})
#define call_glSetMultisamplefvAMD(packed, ret_v) do { \
    PACKED_glSetMultisamplefvAMD *unpacked = (PACKED_glSetMultisamplefvAMD *)packed; \
    ARGS_glSetMultisamplefvAMD *args = (ARGS_glSetMultisamplefvAMD *)&unpacked->args; \
    glSetMultisamplefvAMD(args->pname, args->index, args->val);; \
} while(0)
void glSetMultisamplefvAMD(glSetMultisamplefvAMD_ARG_EXPAND);
typedef void (*glSetMultisamplefvAMD_PTR)(glSetMultisamplefvAMD_ARG_EXPAND);
#define glShadeModel_INDEX 1925
#define glShadeModel_RETURN void
#define glShadeModel_ARG_NAMES mode
#define glShadeModel_ARG_EXPAND GLenum mode
#define glShadeModel_PACKED PACKED_glShadeModel
#define glShadeModel_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glShadeModel_NOT_VOID_WRAP(...) {}
#define pack_glShadeModel(_mode) ({ \
    glShadeModel_PACKED *packed_data = malloc(sizeof(glShadeModel_PACKED)); \
    packed_data->index = glShadeModel_INDEX; \
    packed_data->args.mode = (GLenum)_mode; \
    (packed_call_t *)packed_data; \
})
#define call_glShadeModel(packed, ret_v) do { \
    PACKED_glShadeModel *unpacked = (PACKED_glShadeModel *)packed; \
    ARGS_glShadeModel *args = (ARGS_glShadeModel *)&unpacked->args; \
    glShadeModel(args->mode);; \
} while(0)
void glShadeModel(glShadeModel_ARG_EXPAND);
typedef void (*glShadeModel_PTR)(glShadeModel_ARG_EXPAND);
#define glShaderBinary_INDEX 1926
#define glShaderBinary_RETURN void
#define glShaderBinary_ARG_NAMES count, shaders, binaryformat, binary, length
#define glShaderBinary_ARG_EXPAND GLsizei count, const GLuint * shaders, GLenum binaryformat, const GLvoid * binary, GLsizei length
#define glShaderBinary_PACKED PACKED_glShaderBinary
#define glShaderBinary_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glShaderBinary_NOT_VOID_WRAP(...) {}
#define pack_glShaderBinary(_count, _shaders, _binaryformat, _binary, _length) ({ \
    glShaderBinary_PACKED *packed_data = malloc(sizeof(glShaderBinary_PACKED)); \
    packed_data->index = glShaderBinary_INDEX; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.shaders = (GLuint *)_shaders; \
    packed_data->args.binaryformat = (GLenum)_binaryformat; \
    packed_data->args.binary = (GLvoid *)_binary; \
    packed_data->args.length = (GLsizei)_length; \
    (packed_call_t *)packed_data; \
})
#define call_glShaderBinary(packed, ret_v) do { \
    PACKED_glShaderBinary *unpacked = (PACKED_glShaderBinary *)packed; \
    ARGS_glShaderBinary *args = (ARGS_glShaderBinary *)&unpacked->args; \
    glShaderBinary(args->count, args->shaders, args->binaryformat, args->binary, args->length);; \
} while(0)
void glShaderBinary(glShaderBinary_ARG_EXPAND);
typedef void (*glShaderBinary_PTR)(glShaderBinary_ARG_EXPAND);
#define glShaderOp1EXT_INDEX 1927
#define glShaderOp1EXT_RETURN void
#define glShaderOp1EXT_ARG_NAMES op, res, arg1
#define glShaderOp1EXT_ARG_EXPAND GLenum op, GLuint res, GLuint arg1
#define glShaderOp1EXT_PACKED PACKED_glShaderOp1EXT
#define glShaderOp1EXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glShaderOp1EXT_NOT_VOID_WRAP(...) {}
#define pack_glShaderOp1EXT(_op, _res, _arg1) ({ \
    glShaderOp1EXT_PACKED *packed_data = malloc(sizeof(glShaderOp1EXT_PACKED)); \
    packed_data->index = glShaderOp1EXT_INDEX; \
    packed_data->args.op = (GLenum)_op; \
    packed_data->args.res = (GLuint)_res; \
    packed_data->args.arg1 = (GLuint)_arg1; \
    (packed_call_t *)packed_data; \
})
#define call_glShaderOp1EXT(packed, ret_v) do { \
    PACKED_glShaderOp1EXT *unpacked = (PACKED_glShaderOp1EXT *)packed; \
    ARGS_glShaderOp1EXT *args = (ARGS_glShaderOp1EXT *)&unpacked->args; \
    glShaderOp1EXT(args->op, args->res, args->arg1);; \
} while(0)
void glShaderOp1EXT(glShaderOp1EXT_ARG_EXPAND);
typedef void (*glShaderOp1EXT_PTR)(glShaderOp1EXT_ARG_EXPAND);
#define glShaderOp2EXT_INDEX 1928
#define glShaderOp2EXT_RETURN void
#define glShaderOp2EXT_ARG_NAMES op, res, arg1, arg2
#define glShaderOp2EXT_ARG_EXPAND GLenum op, GLuint res, GLuint arg1, GLuint arg2
#define glShaderOp2EXT_PACKED PACKED_glShaderOp2EXT
#define glShaderOp2EXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glShaderOp2EXT_NOT_VOID_WRAP(...) {}
#define pack_glShaderOp2EXT(_op, _res, _arg1, _arg2) ({ \
    glShaderOp2EXT_PACKED *packed_data = malloc(sizeof(glShaderOp2EXT_PACKED)); \
    packed_data->index = glShaderOp2EXT_INDEX; \
    packed_data->args.op = (GLenum)_op; \
    packed_data->args.res = (GLuint)_res; \
    packed_data->args.arg1 = (GLuint)_arg1; \
    packed_data->args.arg2 = (GLuint)_arg2; \
    (packed_call_t *)packed_data; \
})
#define call_glShaderOp2EXT(packed, ret_v) do { \
    PACKED_glShaderOp2EXT *unpacked = (PACKED_glShaderOp2EXT *)packed; \
    ARGS_glShaderOp2EXT *args = (ARGS_glShaderOp2EXT *)&unpacked->args; \
    glShaderOp2EXT(args->op, args->res, args->arg1, args->arg2);; \
} while(0)
void glShaderOp2EXT(glShaderOp2EXT_ARG_EXPAND);
typedef void (*glShaderOp2EXT_PTR)(glShaderOp2EXT_ARG_EXPAND);
#define glShaderOp3EXT_INDEX 1929
#define glShaderOp3EXT_RETURN void
#define glShaderOp3EXT_ARG_NAMES op, res, arg1, arg2, arg3
#define glShaderOp3EXT_ARG_EXPAND GLenum op, GLuint res, GLuint arg1, GLuint arg2, GLuint arg3
#define glShaderOp3EXT_PACKED PACKED_glShaderOp3EXT
#define glShaderOp3EXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glShaderOp3EXT_NOT_VOID_WRAP(...) {}
#define pack_glShaderOp3EXT(_op, _res, _arg1, _arg2, _arg3) ({ \
    glShaderOp3EXT_PACKED *packed_data = malloc(sizeof(glShaderOp3EXT_PACKED)); \
    packed_data->index = glShaderOp3EXT_INDEX; \
    packed_data->args.op = (GLenum)_op; \
    packed_data->args.res = (GLuint)_res; \
    packed_data->args.arg1 = (GLuint)_arg1; \
    packed_data->args.arg2 = (GLuint)_arg2; \
    packed_data->args.arg3 = (GLuint)_arg3; \
    (packed_call_t *)packed_data; \
})
#define call_glShaderOp3EXT(packed, ret_v) do { \
    PACKED_glShaderOp3EXT *unpacked = (PACKED_glShaderOp3EXT *)packed; \
    ARGS_glShaderOp3EXT *args = (ARGS_glShaderOp3EXT *)&unpacked->args; \
    glShaderOp3EXT(args->op, args->res, args->arg1, args->arg2, args->arg3);; \
} while(0)
void glShaderOp3EXT(glShaderOp3EXT_ARG_EXPAND);
typedef void (*glShaderOp3EXT_PTR)(glShaderOp3EXT_ARG_EXPAND);
#define glShaderSource_INDEX 1930
#define glShaderSource_RETURN void
#define glShaderSource_ARG_NAMES shader, count, string, length
#define glShaderSource_ARG_EXPAND GLuint shader, GLsizei count, const GLchar * const * string, const GLint * length
#define glShaderSource_PACKED PACKED_glShaderSource
#define glShaderSource_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glShaderSource_NOT_VOID_WRAP(...) {}
#define pack_glShaderSource(_shader, _count, _string, _length) ({ \
    glShaderSource_PACKED *packed_data = malloc(sizeof(glShaderSource_PACKED)); \
    packed_data->index = glShaderSource_INDEX; \
    packed_data->args.shader = (GLuint)_shader; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.string = (GLchar * *)_string; \
    packed_data->args.length = (GLint *)_length; \
    (packed_call_t *)packed_data; \
})
#define call_glShaderSource(packed, ret_v) do { \
    PACKED_glShaderSource *unpacked = (PACKED_glShaderSource *)packed; \
    ARGS_glShaderSource *args = (ARGS_glShaderSource *)&unpacked->args; \
    glShaderSource(args->shader, args->count, args->string, args->length);; \
} while(0)
void glShaderSource(glShaderSource_ARG_EXPAND);
typedef void (*glShaderSource_PTR)(glShaderSource_ARG_EXPAND);
#define glShaderSourceARB_INDEX 1931
#define glShaderSourceARB_RETURN void
#define glShaderSourceARB_ARG_NAMES shaderObj, count, string, length
#define glShaderSourceARB_ARG_EXPAND GLhandleARB shaderObj, GLsizei count, const GLcharARB * string, const GLint * length
#define glShaderSourceARB_PACKED PACKED_glShaderSourceARB
#define glShaderSourceARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glShaderSourceARB_NOT_VOID_WRAP(...) {}
#define pack_glShaderSourceARB(_shaderObj, _count, _string, _length) ({ \
    glShaderSourceARB_PACKED *packed_data = malloc(sizeof(glShaderSourceARB_PACKED)); \
    packed_data->index = glShaderSourceARB_INDEX; \
    packed_data->args.shaderObj = (GLhandleARB)_shaderObj; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.string = (GLcharARB *)_string; \
    packed_data->args.length = (GLint *)_length; \
    (packed_call_t *)packed_data; \
})
#define call_glShaderSourceARB(packed, ret_v) do { \
    PACKED_glShaderSourceARB *unpacked = (PACKED_glShaderSourceARB *)packed; \
    ARGS_glShaderSourceARB *args = (ARGS_glShaderSourceARB *)&unpacked->args; \
    glShaderSourceARB(args->shaderObj, args->count, args->string, args->length);; \
} while(0)
void glShaderSourceARB(glShaderSourceARB_ARG_EXPAND);
typedef void (*glShaderSourceARB_PTR)(glShaderSourceARB_ARG_EXPAND);
#define glShaderStorageBlockBinding_INDEX 1932
#define glShaderStorageBlockBinding_RETURN void
#define glShaderStorageBlockBinding_ARG_NAMES program, storageBlockIndex, storageBlockBinding
#define glShaderStorageBlockBinding_ARG_EXPAND GLuint program, GLuint storageBlockIndex, GLuint storageBlockBinding
#define glShaderStorageBlockBinding_PACKED PACKED_glShaderStorageBlockBinding
#define glShaderStorageBlockBinding_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glShaderStorageBlockBinding_NOT_VOID_WRAP(...) {}
#define pack_glShaderStorageBlockBinding(_program, _storageBlockIndex, _storageBlockBinding) ({ \
    glShaderStorageBlockBinding_PACKED *packed_data = malloc(sizeof(glShaderStorageBlockBinding_PACKED)); \
    packed_data->index = glShaderStorageBlockBinding_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.storageBlockIndex = (GLuint)_storageBlockIndex; \
    packed_data->args.storageBlockBinding = (GLuint)_storageBlockBinding; \
    (packed_call_t *)packed_data; \
})
#define call_glShaderStorageBlockBinding(packed, ret_v) do { \
    PACKED_glShaderStorageBlockBinding *unpacked = (PACKED_glShaderStorageBlockBinding *)packed; \
    ARGS_glShaderStorageBlockBinding *args = (ARGS_glShaderStorageBlockBinding *)&unpacked->args; \
    glShaderStorageBlockBinding(args->program, args->storageBlockIndex, args->storageBlockBinding);; \
} while(0)
void glShaderStorageBlockBinding(glShaderStorageBlockBinding_ARG_EXPAND);
typedef void (*glShaderStorageBlockBinding_PTR)(glShaderStorageBlockBinding_ARG_EXPAND);
#define glSharpenTexFuncSGIS_INDEX 1933
#define glSharpenTexFuncSGIS_RETURN void
#define glSharpenTexFuncSGIS_ARG_NAMES target, n, points
#define glSharpenTexFuncSGIS_ARG_EXPAND GLenum target, GLsizei n, const GLfloat * points
#define glSharpenTexFuncSGIS_PACKED PACKED_glSharpenTexFuncSGIS
#define glSharpenTexFuncSGIS_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glSharpenTexFuncSGIS_NOT_VOID_WRAP(...) {}
#define pack_glSharpenTexFuncSGIS(_target, _n, _points) ({ \
    glSharpenTexFuncSGIS_PACKED *packed_data = malloc(sizeof(glSharpenTexFuncSGIS_PACKED)); \
    packed_data->index = glSharpenTexFuncSGIS_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.n = (GLsizei)_n; \
    packed_data->args.points = (GLfloat *)_points; \
    (packed_call_t *)packed_data; \
})
#define call_glSharpenTexFuncSGIS(packed, ret_v) do { \
    PACKED_glSharpenTexFuncSGIS *unpacked = (PACKED_glSharpenTexFuncSGIS *)packed; \
    ARGS_glSharpenTexFuncSGIS *args = (ARGS_glSharpenTexFuncSGIS *)&unpacked->args; \
    glSharpenTexFuncSGIS(args->target, args->n, args->points);; \
} while(0)
void glSharpenTexFuncSGIS(glSharpenTexFuncSGIS_ARG_EXPAND);
typedef void (*glSharpenTexFuncSGIS_PTR)(glSharpenTexFuncSGIS_ARG_EXPAND);
#define glSpriteParameterfSGIX_INDEX 1934
#define glSpriteParameterfSGIX_RETURN void
#define glSpriteParameterfSGIX_ARG_NAMES pname, param
#define glSpriteParameterfSGIX_ARG_EXPAND GLenum pname, GLfloat param
#define glSpriteParameterfSGIX_PACKED PACKED_glSpriteParameterfSGIX
#define glSpriteParameterfSGIX_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glSpriteParameterfSGIX_NOT_VOID_WRAP(...) {}
#define pack_glSpriteParameterfSGIX(_pname, _param) ({ \
    glSpriteParameterfSGIX_PACKED *packed_data = malloc(sizeof(glSpriteParameterfSGIX_PACKED)); \
    packed_data->index = glSpriteParameterfSGIX_INDEX; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.param = (GLfloat)_param; \
    (packed_call_t *)packed_data; \
})
#define call_glSpriteParameterfSGIX(packed, ret_v) do { \
    PACKED_glSpriteParameterfSGIX *unpacked = (PACKED_glSpriteParameterfSGIX *)packed; \
    ARGS_glSpriteParameterfSGIX *args = (ARGS_glSpriteParameterfSGIX *)&unpacked->args; \
    glSpriteParameterfSGIX(args->pname, args->param);; \
} while(0)
void glSpriteParameterfSGIX(glSpriteParameterfSGIX_ARG_EXPAND);
typedef void (*glSpriteParameterfSGIX_PTR)(glSpriteParameterfSGIX_ARG_EXPAND);
#define glSpriteParameterfvSGIX_INDEX 1935
#define glSpriteParameterfvSGIX_RETURN void
#define glSpriteParameterfvSGIX_ARG_NAMES pname, params
#define glSpriteParameterfvSGIX_ARG_EXPAND GLenum pname, const GLfloat * params
#define glSpriteParameterfvSGIX_PACKED PACKED_glSpriteParameterfvSGIX
#define glSpriteParameterfvSGIX_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glSpriteParameterfvSGIX_NOT_VOID_WRAP(...) {}
#define pack_glSpriteParameterfvSGIX(_pname, _params) ({ \
    glSpriteParameterfvSGIX_PACKED *packed_data = malloc(sizeof(glSpriteParameterfvSGIX_PACKED)); \
    packed_data->index = glSpriteParameterfvSGIX_INDEX; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLfloat *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glSpriteParameterfvSGIX(packed, ret_v) do { \
    PACKED_glSpriteParameterfvSGIX *unpacked = (PACKED_glSpriteParameterfvSGIX *)packed; \
    ARGS_glSpriteParameterfvSGIX *args = (ARGS_glSpriteParameterfvSGIX *)&unpacked->args; \
    glSpriteParameterfvSGIX(args->pname, args->params);; \
} while(0)
void glSpriteParameterfvSGIX(glSpriteParameterfvSGIX_ARG_EXPAND);
typedef void (*glSpriteParameterfvSGIX_PTR)(glSpriteParameterfvSGIX_ARG_EXPAND);
#define glSpriteParameteriSGIX_INDEX 1936
#define glSpriteParameteriSGIX_RETURN void
#define glSpriteParameteriSGIX_ARG_NAMES pname, param
#define glSpriteParameteriSGIX_ARG_EXPAND GLenum pname, GLint param
#define glSpriteParameteriSGIX_PACKED PACKED_glSpriteParameteriSGIX
#define glSpriteParameteriSGIX_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glSpriteParameteriSGIX_NOT_VOID_WRAP(...) {}
#define pack_glSpriteParameteriSGIX(_pname, _param) ({ \
    glSpriteParameteriSGIX_PACKED *packed_data = malloc(sizeof(glSpriteParameteriSGIX_PACKED)); \
    packed_data->index = glSpriteParameteriSGIX_INDEX; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.param = (GLint)_param; \
    (packed_call_t *)packed_data; \
})
#define call_glSpriteParameteriSGIX(packed, ret_v) do { \
    PACKED_glSpriteParameteriSGIX *unpacked = (PACKED_glSpriteParameteriSGIX *)packed; \
    ARGS_glSpriteParameteriSGIX *args = (ARGS_glSpriteParameteriSGIX *)&unpacked->args; \
    glSpriteParameteriSGIX(args->pname, args->param);; \
} while(0)
void glSpriteParameteriSGIX(glSpriteParameteriSGIX_ARG_EXPAND);
typedef void (*glSpriteParameteriSGIX_PTR)(glSpriteParameteriSGIX_ARG_EXPAND);
#define glSpriteParameterivSGIX_INDEX 1937
#define glSpriteParameterivSGIX_RETURN void
#define glSpriteParameterivSGIX_ARG_NAMES pname, params
#define glSpriteParameterivSGIX_ARG_EXPAND GLenum pname, const GLint * params
#define glSpriteParameterivSGIX_PACKED PACKED_glSpriteParameterivSGIX
#define glSpriteParameterivSGIX_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glSpriteParameterivSGIX_NOT_VOID_WRAP(...) {}
#define pack_glSpriteParameterivSGIX(_pname, _params) ({ \
    glSpriteParameterivSGIX_PACKED *packed_data = malloc(sizeof(glSpriteParameterivSGIX_PACKED)); \
    packed_data->index = glSpriteParameterivSGIX_INDEX; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glSpriteParameterivSGIX(packed, ret_v) do { \
    PACKED_glSpriteParameterivSGIX *unpacked = (PACKED_glSpriteParameterivSGIX *)packed; \
    ARGS_glSpriteParameterivSGIX *args = (ARGS_glSpriteParameterivSGIX *)&unpacked->args; \
    glSpriteParameterivSGIX(args->pname, args->params);; \
} while(0)
void glSpriteParameterivSGIX(glSpriteParameterivSGIX_ARG_EXPAND);
typedef void (*glSpriteParameterivSGIX_PTR)(glSpriteParameterivSGIX_ARG_EXPAND);
#define glStartInstrumentsSGIX_INDEX 1938
#define glStartInstrumentsSGIX_RETURN void
#define glStartInstrumentsSGIX_ARG_NAMES 
#define glStartInstrumentsSGIX_ARG_EXPAND 
#define glStartInstrumentsSGIX_PACKED PACKED_glStartInstrumentsSGIX
#define glStartInstrumentsSGIX_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glStartInstrumentsSGIX_NOT_VOID_WRAP(...) {}
#define pack_glStartInstrumentsSGIX() ({ \
    glStartInstrumentsSGIX_PACKED *packed_data = malloc(sizeof(glStartInstrumentsSGIX_PACKED)); \
    packed_data->index = glStartInstrumentsSGIX_INDEX; \
    (packed_call_t *)packed_data; \
})
#define call_glStartInstrumentsSGIX(packed, ret_v) do { \
    glStartInstrumentsSGIX();; \
} while(0)
void glStartInstrumentsSGIX(glStartInstrumentsSGIX_ARG_EXPAND);
typedef void (*glStartInstrumentsSGIX_PTR)(glStartInstrumentsSGIX_ARG_EXPAND);
#define glStencilClearTagEXT_INDEX 1939
#define glStencilClearTagEXT_RETURN void
#define glStencilClearTagEXT_ARG_NAMES stencilTagBits, stencilClearTag
#define glStencilClearTagEXT_ARG_EXPAND GLsizei stencilTagBits, GLuint stencilClearTag
#define glStencilClearTagEXT_PACKED PACKED_glStencilClearTagEXT
#define glStencilClearTagEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glStencilClearTagEXT_NOT_VOID_WRAP(...) {}
#define pack_glStencilClearTagEXT(_stencilTagBits, _stencilClearTag) ({ \
    glStencilClearTagEXT_PACKED *packed_data = malloc(sizeof(glStencilClearTagEXT_PACKED)); \
    packed_data->index = glStencilClearTagEXT_INDEX; \
    packed_data->args.stencilTagBits = (GLsizei)_stencilTagBits; \
    packed_data->args.stencilClearTag = (GLuint)_stencilClearTag; \
    (packed_call_t *)packed_data; \
})
#define call_glStencilClearTagEXT(packed, ret_v) do { \
    PACKED_glStencilClearTagEXT *unpacked = (PACKED_glStencilClearTagEXT *)packed; \
    ARGS_glStencilClearTagEXT *args = (ARGS_glStencilClearTagEXT *)&unpacked->args; \
    glStencilClearTagEXT(args->stencilTagBits, args->stencilClearTag);; \
} while(0)
void glStencilClearTagEXT(glStencilClearTagEXT_ARG_EXPAND);
typedef void (*glStencilClearTagEXT_PTR)(glStencilClearTagEXT_ARG_EXPAND);
#define glStencilFillPathInstancedNV_INDEX 1940
#define glStencilFillPathInstancedNV_RETURN void
#define glStencilFillPathInstancedNV_ARG_NAMES numPaths, pathNameType, paths, pathBase, fillMode, mask, transformType, transformValues
#define glStencilFillPathInstancedNV_ARG_EXPAND GLsizei numPaths, GLenum pathNameType, const GLvoid * paths, GLuint pathBase, GLenum fillMode, GLuint mask, GLenum transformType, const GLfloat * transformValues
#define glStencilFillPathInstancedNV_PACKED PACKED_glStencilFillPathInstancedNV
#define glStencilFillPathInstancedNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glStencilFillPathInstancedNV_NOT_VOID_WRAP(...) {}
#define pack_glStencilFillPathInstancedNV(_numPaths, _pathNameType, _paths, _pathBase, _fillMode, _mask, _transformType, _transformValues) ({ \
    glStencilFillPathInstancedNV_PACKED *packed_data = malloc(sizeof(glStencilFillPathInstancedNV_PACKED)); \
    packed_data->index = glStencilFillPathInstancedNV_INDEX; \
    packed_data->args.numPaths = (GLsizei)_numPaths; \
    packed_data->args.pathNameType = (GLenum)_pathNameType; \
    packed_data->args.paths = (GLvoid *)_paths; \
    packed_data->args.pathBase = (GLuint)_pathBase; \
    packed_data->args.fillMode = (GLenum)_fillMode; \
    packed_data->args.mask = (GLuint)_mask; \
    packed_data->args.transformType = (GLenum)_transformType; \
    packed_data->args.transformValues = (GLfloat *)_transformValues; \
    (packed_call_t *)packed_data; \
})
#define call_glStencilFillPathInstancedNV(packed, ret_v) do { \
    PACKED_glStencilFillPathInstancedNV *unpacked = (PACKED_glStencilFillPathInstancedNV *)packed; \
    ARGS_glStencilFillPathInstancedNV *args = (ARGS_glStencilFillPathInstancedNV *)&unpacked->args; \
    glStencilFillPathInstancedNV(args->numPaths, args->pathNameType, args->paths, args->pathBase, args->fillMode, args->mask, args->transformType, args->transformValues);; \
} while(0)
void glStencilFillPathInstancedNV(glStencilFillPathInstancedNV_ARG_EXPAND);
typedef void (*glStencilFillPathInstancedNV_PTR)(glStencilFillPathInstancedNV_ARG_EXPAND);
#define glStencilFillPathNV_INDEX 1941
#define glStencilFillPathNV_RETURN void
#define glStencilFillPathNV_ARG_NAMES path, fillMode, mask
#define glStencilFillPathNV_ARG_EXPAND GLuint path, GLenum fillMode, GLuint mask
#define glStencilFillPathNV_PACKED PACKED_glStencilFillPathNV
#define glStencilFillPathNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glStencilFillPathNV_NOT_VOID_WRAP(...) {}
#define pack_glStencilFillPathNV(_path, _fillMode, _mask) ({ \
    glStencilFillPathNV_PACKED *packed_data = malloc(sizeof(glStencilFillPathNV_PACKED)); \
    packed_data->index = glStencilFillPathNV_INDEX; \
    packed_data->args.path = (GLuint)_path; \
    packed_data->args.fillMode = (GLenum)_fillMode; \
    packed_data->args.mask = (GLuint)_mask; \
    (packed_call_t *)packed_data; \
})
#define call_glStencilFillPathNV(packed, ret_v) do { \
    PACKED_glStencilFillPathNV *unpacked = (PACKED_glStencilFillPathNV *)packed; \
    ARGS_glStencilFillPathNV *args = (ARGS_glStencilFillPathNV *)&unpacked->args; \
    glStencilFillPathNV(args->path, args->fillMode, args->mask);; \
} while(0)
void glStencilFillPathNV(glStencilFillPathNV_ARG_EXPAND);
typedef void (*glStencilFillPathNV_PTR)(glStencilFillPathNV_ARG_EXPAND);
#define glStencilFunc_INDEX 1942
#define glStencilFunc_RETURN void
#define glStencilFunc_ARG_NAMES func, ref, mask
#define glStencilFunc_ARG_EXPAND GLenum func, GLint ref, GLuint mask
#define glStencilFunc_PACKED PACKED_glStencilFunc
#define glStencilFunc_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glStencilFunc_NOT_VOID_WRAP(...) {}
#define pack_glStencilFunc(_func, _ref, _mask) ({ \
    glStencilFunc_PACKED *packed_data = malloc(sizeof(glStencilFunc_PACKED)); \
    packed_data->index = glStencilFunc_INDEX; \
    packed_data->args.func = (GLenum)_func; \
    packed_data->args.ref = (GLint)_ref; \
    packed_data->args.mask = (GLuint)_mask; \
    (packed_call_t *)packed_data; \
})
#define call_glStencilFunc(packed, ret_v) do { \
    PACKED_glStencilFunc *unpacked = (PACKED_glStencilFunc *)packed; \
    ARGS_glStencilFunc *args = (ARGS_glStencilFunc *)&unpacked->args; \
    glStencilFunc(args->func, args->ref, args->mask);; \
} while(0)
void glStencilFunc(glStencilFunc_ARG_EXPAND);
typedef void (*glStencilFunc_PTR)(glStencilFunc_ARG_EXPAND);
#define glStencilFuncSeparate_INDEX 1943
#define glStencilFuncSeparate_RETURN void
#define glStencilFuncSeparate_ARG_NAMES face, func, ref, mask
#define glStencilFuncSeparate_ARG_EXPAND GLenum face, GLenum func, GLint ref, GLuint mask
#define glStencilFuncSeparate_PACKED PACKED_glStencilFuncSeparate
#define glStencilFuncSeparate_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glStencilFuncSeparate_NOT_VOID_WRAP(...) {}
#define pack_glStencilFuncSeparate(_face, _func, _ref, _mask) ({ \
    glStencilFuncSeparate_PACKED *packed_data = malloc(sizeof(glStencilFuncSeparate_PACKED)); \
    packed_data->index = glStencilFuncSeparate_INDEX; \
    packed_data->args.face = (GLenum)_face; \
    packed_data->args.func = (GLenum)_func; \
    packed_data->args.ref = (GLint)_ref; \
    packed_data->args.mask = (GLuint)_mask; \
    (packed_call_t *)packed_data; \
})
#define call_glStencilFuncSeparate(packed, ret_v) do { \
    PACKED_glStencilFuncSeparate *unpacked = (PACKED_glStencilFuncSeparate *)packed; \
    ARGS_glStencilFuncSeparate *args = (ARGS_glStencilFuncSeparate *)&unpacked->args; \
    glStencilFuncSeparate(args->face, args->func, args->ref, args->mask);; \
} while(0)
void glStencilFuncSeparate(glStencilFuncSeparate_ARG_EXPAND);
typedef void (*glStencilFuncSeparate_PTR)(glStencilFuncSeparate_ARG_EXPAND);
#define glStencilFuncSeparateATI_INDEX 1944
#define glStencilFuncSeparateATI_RETURN void
#define glStencilFuncSeparateATI_ARG_NAMES frontfunc, backfunc, ref, mask
#define glStencilFuncSeparateATI_ARG_EXPAND GLenum frontfunc, GLenum backfunc, GLint ref, GLuint mask
#define glStencilFuncSeparateATI_PACKED PACKED_glStencilFuncSeparateATI
#define glStencilFuncSeparateATI_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glStencilFuncSeparateATI_NOT_VOID_WRAP(...) {}
#define pack_glStencilFuncSeparateATI(_frontfunc, _backfunc, _ref, _mask) ({ \
    glStencilFuncSeparateATI_PACKED *packed_data = malloc(sizeof(glStencilFuncSeparateATI_PACKED)); \
    packed_data->index = glStencilFuncSeparateATI_INDEX; \
    packed_data->args.frontfunc = (GLenum)_frontfunc; \
    packed_data->args.backfunc = (GLenum)_backfunc; \
    packed_data->args.ref = (GLint)_ref; \
    packed_data->args.mask = (GLuint)_mask; \
    (packed_call_t *)packed_data; \
})
#define call_glStencilFuncSeparateATI(packed, ret_v) do { \
    PACKED_glStencilFuncSeparateATI *unpacked = (PACKED_glStencilFuncSeparateATI *)packed; \
    ARGS_glStencilFuncSeparateATI *args = (ARGS_glStencilFuncSeparateATI *)&unpacked->args; \
    glStencilFuncSeparateATI(args->frontfunc, args->backfunc, args->ref, args->mask);; \
} while(0)
void glStencilFuncSeparateATI(glStencilFuncSeparateATI_ARG_EXPAND);
typedef void (*glStencilFuncSeparateATI_PTR)(glStencilFuncSeparateATI_ARG_EXPAND);
#define glStencilMask_INDEX 1945
#define glStencilMask_RETURN void
#define glStencilMask_ARG_NAMES mask
#define glStencilMask_ARG_EXPAND GLuint mask
#define glStencilMask_PACKED PACKED_glStencilMask
#define glStencilMask_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glStencilMask_NOT_VOID_WRAP(...) {}
#define pack_glStencilMask(_mask) ({ \
    glStencilMask_PACKED *packed_data = malloc(sizeof(glStencilMask_PACKED)); \
    packed_data->index = glStencilMask_INDEX; \
    packed_data->args.mask = (GLuint)_mask; \
    (packed_call_t *)packed_data; \
})
#define call_glStencilMask(packed, ret_v) do { \
    PACKED_glStencilMask *unpacked = (PACKED_glStencilMask *)packed; \
    ARGS_glStencilMask *args = (ARGS_glStencilMask *)&unpacked->args; \
    glStencilMask(args->mask);; \
} while(0)
void glStencilMask(glStencilMask_ARG_EXPAND);
typedef void (*glStencilMask_PTR)(glStencilMask_ARG_EXPAND);
#define glStencilMaskSeparate_INDEX 1946
#define glStencilMaskSeparate_RETURN void
#define glStencilMaskSeparate_ARG_NAMES face, mask
#define glStencilMaskSeparate_ARG_EXPAND GLenum face, GLuint mask
#define glStencilMaskSeparate_PACKED PACKED_glStencilMaskSeparate
#define glStencilMaskSeparate_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glStencilMaskSeparate_NOT_VOID_WRAP(...) {}
#define pack_glStencilMaskSeparate(_face, _mask) ({ \
    glStencilMaskSeparate_PACKED *packed_data = malloc(sizeof(glStencilMaskSeparate_PACKED)); \
    packed_data->index = glStencilMaskSeparate_INDEX; \
    packed_data->args.face = (GLenum)_face; \
    packed_data->args.mask = (GLuint)_mask; \
    (packed_call_t *)packed_data; \
})
#define call_glStencilMaskSeparate(packed, ret_v) do { \
    PACKED_glStencilMaskSeparate *unpacked = (PACKED_glStencilMaskSeparate *)packed; \
    ARGS_glStencilMaskSeparate *args = (ARGS_glStencilMaskSeparate *)&unpacked->args; \
    glStencilMaskSeparate(args->face, args->mask);; \
} while(0)
void glStencilMaskSeparate(glStencilMaskSeparate_ARG_EXPAND);
typedef void (*glStencilMaskSeparate_PTR)(glStencilMaskSeparate_ARG_EXPAND);
#define glStencilOp_INDEX 1947
#define glStencilOp_RETURN void
#define glStencilOp_ARG_NAMES fail, zfail, zpass
#define glStencilOp_ARG_EXPAND GLenum fail, GLenum zfail, GLenum zpass
#define glStencilOp_PACKED PACKED_glStencilOp
#define glStencilOp_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glStencilOp_NOT_VOID_WRAP(...) {}
#define pack_glStencilOp(_fail, _zfail, _zpass) ({ \
    glStencilOp_PACKED *packed_data = malloc(sizeof(glStencilOp_PACKED)); \
    packed_data->index = glStencilOp_INDEX; \
    packed_data->args.fail = (GLenum)_fail; \
    packed_data->args.zfail = (GLenum)_zfail; \
    packed_data->args.zpass = (GLenum)_zpass; \
    (packed_call_t *)packed_data; \
})
#define call_glStencilOp(packed, ret_v) do { \
    PACKED_glStencilOp *unpacked = (PACKED_glStencilOp *)packed; \
    ARGS_glStencilOp *args = (ARGS_glStencilOp *)&unpacked->args; \
    glStencilOp(args->fail, args->zfail, args->zpass);; \
} while(0)
void glStencilOp(glStencilOp_ARG_EXPAND);
typedef void (*glStencilOp_PTR)(glStencilOp_ARG_EXPAND);
#define glStencilOpSeparate_INDEX 1948
#define glStencilOpSeparate_RETURN void
#define glStencilOpSeparate_ARG_NAMES face, sfail, dpfail, dppass
#define glStencilOpSeparate_ARG_EXPAND GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass
#define glStencilOpSeparate_PACKED PACKED_glStencilOpSeparate
#define glStencilOpSeparate_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glStencilOpSeparate_NOT_VOID_WRAP(...) {}
#define pack_glStencilOpSeparate(_face, _sfail, _dpfail, _dppass) ({ \
    glStencilOpSeparate_PACKED *packed_data = malloc(sizeof(glStencilOpSeparate_PACKED)); \
    packed_data->index = glStencilOpSeparate_INDEX; \
    packed_data->args.face = (GLenum)_face; \
    packed_data->args.sfail = (GLenum)_sfail; \
    packed_data->args.dpfail = (GLenum)_dpfail; \
    packed_data->args.dppass = (GLenum)_dppass; \
    (packed_call_t *)packed_data; \
})
#define call_glStencilOpSeparate(packed, ret_v) do { \
    PACKED_glStencilOpSeparate *unpacked = (PACKED_glStencilOpSeparate *)packed; \
    ARGS_glStencilOpSeparate *args = (ARGS_glStencilOpSeparate *)&unpacked->args; \
    glStencilOpSeparate(args->face, args->sfail, args->dpfail, args->dppass);; \
} while(0)
void glStencilOpSeparate(glStencilOpSeparate_ARG_EXPAND);
typedef void (*glStencilOpSeparate_PTR)(glStencilOpSeparate_ARG_EXPAND);
#define glStencilOpSeparateATI_INDEX 1949
#define glStencilOpSeparateATI_RETURN void
#define glStencilOpSeparateATI_ARG_NAMES face, sfail, dpfail, dppass
#define glStencilOpSeparateATI_ARG_EXPAND GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass
#define glStencilOpSeparateATI_PACKED PACKED_glStencilOpSeparateATI
#define glStencilOpSeparateATI_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glStencilOpSeparateATI_NOT_VOID_WRAP(...) {}
#define pack_glStencilOpSeparateATI(_face, _sfail, _dpfail, _dppass) ({ \
    glStencilOpSeparateATI_PACKED *packed_data = malloc(sizeof(glStencilOpSeparateATI_PACKED)); \
    packed_data->index = glStencilOpSeparateATI_INDEX; \
    packed_data->args.face = (GLenum)_face; \
    packed_data->args.sfail = (GLenum)_sfail; \
    packed_data->args.dpfail = (GLenum)_dpfail; \
    packed_data->args.dppass = (GLenum)_dppass; \
    (packed_call_t *)packed_data; \
})
#define call_glStencilOpSeparateATI(packed, ret_v) do { \
    PACKED_glStencilOpSeparateATI *unpacked = (PACKED_glStencilOpSeparateATI *)packed; \
    ARGS_glStencilOpSeparateATI *args = (ARGS_glStencilOpSeparateATI *)&unpacked->args; \
    glStencilOpSeparateATI(args->face, args->sfail, args->dpfail, args->dppass);; \
} while(0)
void glStencilOpSeparateATI(glStencilOpSeparateATI_ARG_EXPAND);
typedef void (*glStencilOpSeparateATI_PTR)(glStencilOpSeparateATI_ARG_EXPAND);
#define glStencilOpValueAMD_INDEX 1950
#define glStencilOpValueAMD_RETURN void
#define glStencilOpValueAMD_ARG_NAMES face, value
#define glStencilOpValueAMD_ARG_EXPAND GLenum face, GLuint value
#define glStencilOpValueAMD_PACKED PACKED_glStencilOpValueAMD
#define glStencilOpValueAMD_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glStencilOpValueAMD_NOT_VOID_WRAP(...) {}
#define pack_glStencilOpValueAMD(_face, _value) ({ \
    glStencilOpValueAMD_PACKED *packed_data = malloc(sizeof(glStencilOpValueAMD_PACKED)); \
    packed_data->index = glStencilOpValueAMD_INDEX; \
    packed_data->args.face = (GLenum)_face; \
    packed_data->args.value = (GLuint)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glStencilOpValueAMD(packed, ret_v) do { \
    PACKED_glStencilOpValueAMD *unpacked = (PACKED_glStencilOpValueAMD *)packed; \
    ARGS_glStencilOpValueAMD *args = (ARGS_glStencilOpValueAMD *)&unpacked->args; \
    glStencilOpValueAMD(args->face, args->value);; \
} while(0)
void glStencilOpValueAMD(glStencilOpValueAMD_ARG_EXPAND);
typedef void (*glStencilOpValueAMD_PTR)(glStencilOpValueAMD_ARG_EXPAND);
#define glStencilStrokePathInstancedNV_INDEX 1951
#define glStencilStrokePathInstancedNV_RETURN void
#define glStencilStrokePathInstancedNV_ARG_NAMES numPaths, pathNameType, paths, pathBase, reference, mask, transformType, transformValues
#define glStencilStrokePathInstancedNV_ARG_EXPAND GLsizei numPaths, GLenum pathNameType, const GLvoid * paths, GLuint pathBase, GLint reference, GLuint mask, GLenum transformType, const GLfloat * transformValues
#define glStencilStrokePathInstancedNV_PACKED PACKED_glStencilStrokePathInstancedNV
#define glStencilStrokePathInstancedNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glStencilStrokePathInstancedNV_NOT_VOID_WRAP(...) {}
#define pack_glStencilStrokePathInstancedNV(_numPaths, _pathNameType, _paths, _pathBase, _reference, _mask, _transformType, _transformValues) ({ \
    glStencilStrokePathInstancedNV_PACKED *packed_data = malloc(sizeof(glStencilStrokePathInstancedNV_PACKED)); \
    packed_data->index = glStencilStrokePathInstancedNV_INDEX; \
    packed_data->args.numPaths = (GLsizei)_numPaths; \
    packed_data->args.pathNameType = (GLenum)_pathNameType; \
    packed_data->args.paths = (GLvoid *)_paths; \
    packed_data->args.pathBase = (GLuint)_pathBase; \
    packed_data->args.reference = (GLint)_reference; \
    packed_data->args.mask = (GLuint)_mask; \
    packed_data->args.transformType = (GLenum)_transformType; \
    packed_data->args.transformValues = (GLfloat *)_transformValues; \
    (packed_call_t *)packed_data; \
})
#define call_glStencilStrokePathInstancedNV(packed, ret_v) do { \
    PACKED_glStencilStrokePathInstancedNV *unpacked = (PACKED_glStencilStrokePathInstancedNV *)packed; \
    ARGS_glStencilStrokePathInstancedNV *args = (ARGS_glStencilStrokePathInstancedNV *)&unpacked->args; \
    glStencilStrokePathInstancedNV(args->numPaths, args->pathNameType, args->paths, args->pathBase, args->reference, args->mask, args->transformType, args->transformValues);; \
} while(0)
void glStencilStrokePathInstancedNV(glStencilStrokePathInstancedNV_ARG_EXPAND);
typedef void (*glStencilStrokePathInstancedNV_PTR)(glStencilStrokePathInstancedNV_ARG_EXPAND);
#define glStencilStrokePathNV_INDEX 1952
#define glStencilStrokePathNV_RETURN void
#define glStencilStrokePathNV_ARG_NAMES path, reference, mask
#define glStencilStrokePathNV_ARG_EXPAND GLuint path, GLint reference, GLuint mask
#define glStencilStrokePathNV_PACKED PACKED_glStencilStrokePathNV
#define glStencilStrokePathNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glStencilStrokePathNV_NOT_VOID_WRAP(...) {}
#define pack_glStencilStrokePathNV(_path, _reference, _mask) ({ \
    glStencilStrokePathNV_PACKED *packed_data = malloc(sizeof(glStencilStrokePathNV_PACKED)); \
    packed_data->index = glStencilStrokePathNV_INDEX; \
    packed_data->args.path = (GLuint)_path; \
    packed_data->args.reference = (GLint)_reference; \
    packed_data->args.mask = (GLuint)_mask; \
    (packed_call_t *)packed_data; \
})
#define call_glStencilStrokePathNV(packed, ret_v) do { \
    PACKED_glStencilStrokePathNV *unpacked = (PACKED_glStencilStrokePathNV *)packed; \
    ARGS_glStencilStrokePathNV *args = (ARGS_glStencilStrokePathNV *)&unpacked->args; \
    glStencilStrokePathNV(args->path, args->reference, args->mask);; \
} while(0)
void glStencilStrokePathNV(glStencilStrokePathNV_ARG_EXPAND);
typedef void (*glStencilStrokePathNV_PTR)(glStencilStrokePathNV_ARG_EXPAND);
#define glStopInstrumentsSGIX_INDEX 1953
#define glStopInstrumentsSGIX_RETURN void
#define glStopInstrumentsSGIX_ARG_NAMES marker
#define glStopInstrumentsSGIX_ARG_EXPAND GLint marker
#define glStopInstrumentsSGIX_PACKED PACKED_glStopInstrumentsSGIX
#define glStopInstrumentsSGIX_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glStopInstrumentsSGIX_NOT_VOID_WRAP(...) {}
#define pack_glStopInstrumentsSGIX(_marker) ({ \
    glStopInstrumentsSGIX_PACKED *packed_data = malloc(sizeof(glStopInstrumentsSGIX_PACKED)); \
    packed_data->index = glStopInstrumentsSGIX_INDEX; \
    packed_data->args.marker = (GLint)_marker; \
    (packed_call_t *)packed_data; \
})
#define call_glStopInstrumentsSGIX(packed, ret_v) do { \
    PACKED_glStopInstrumentsSGIX *unpacked = (PACKED_glStopInstrumentsSGIX *)packed; \
    ARGS_glStopInstrumentsSGIX *args = (ARGS_glStopInstrumentsSGIX *)&unpacked->args; \
    glStopInstrumentsSGIX(args->marker);; \
} while(0)
void glStopInstrumentsSGIX(glStopInstrumentsSGIX_ARG_EXPAND);
typedef void (*glStopInstrumentsSGIX_PTR)(glStopInstrumentsSGIX_ARG_EXPAND);
#define glStringMarkerGREMEDY_INDEX 1954
#define glStringMarkerGREMEDY_RETURN void
#define glStringMarkerGREMEDY_ARG_NAMES len, string
#define glStringMarkerGREMEDY_ARG_EXPAND GLsizei len, const GLvoid * string
#define glStringMarkerGREMEDY_PACKED PACKED_glStringMarkerGREMEDY
#define glStringMarkerGREMEDY_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glStringMarkerGREMEDY_NOT_VOID_WRAP(...) {}
#define pack_glStringMarkerGREMEDY(_len, _string) ({ \
    glStringMarkerGREMEDY_PACKED *packed_data = malloc(sizeof(glStringMarkerGREMEDY_PACKED)); \
    packed_data->index = glStringMarkerGREMEDY_INDEX; \
    packed_data->args.len = (GLsizei)_len; \
    packed_data->args.string = (GLvoid *)_string; \
    (packed_call_t *)packed_data; \
})
#define call_glStringMarkerGREMEDY(packed, ret_v) do { \
    PACKED_glStringMarkerGREMEDY *unpacked = (PACKED_glStringMarkerGREMEDY *)packed; \
    ARGS_glStringMarkerGREMEDY *args = (ARGS_glStringMarkerGREMEDY *)&unpacked->args; \
    glStringMarkerGREMEDY(args->len, args->string);; \
} while(0)
void glStringMarkerGREMEDY(glStringMarkerGREMEDY_ARG_EXPAND);
typedef void (*glStringMarkerGREMEDY_PTR)(glStringMarkerGREMEDY_ARG_EXPAND);
#define glSwizzleEXT_INDEX 1955
#define glSwizzleEXT_RETURN void
#define glSwizzleEXT_ARG_NAMES res, in, outX, outY, outZ, outW
#define glSwizzleEXT_ARG_EXPAND GLuint res, GLuint in, GLenum outX, GLenum outY, GLenum outZ, GLenum outW
#define glSwizzleEXT_PACKED PACKED_glSwizzleEXT
#define glSwizzleEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glSwizzleEXT_NOT_VOID_WRAP(...) {}
#define pack_glSwizzleEXT(_res, _in, _outX, _outY, _outZ, _outW) ({ \
    glSwizzleEXT_PACKED *packed_data = malloc(sizeof(glSwizzleEXT_PACKED)); \
    packed_data->index = glSwizzleEXT_INDEX; \
    packed_data->args.res = (GLuint)_res; \
    packed_data->args.in = (GLuint)_in; \
    packed_data->args.outX = (GLenum)_outX; \
    packed_data->args.outY = (GLenum)_outY; \
    packed_data->args.outZ = (GLenum)_outZ; \
    packed_data->args.outW = (GLenum)_outW; \
    (packed_call_t *)packed_data; \
})
#define call_glSwizzleEXT(packed, ret_v) do { \
    PACKED_glSwizzleEXT *unpacked = (PACKED_glSwizzleEXT *)packed; \
    ARGS_glSwizzleEXT *args = (ARGS_glSwizzleEXT *)&unpacked->args; \
    glSwizzleEXT(args->res, args->in, args->outX, args->outY, args->outZ, args->outW);; \
} while(0)
void glSwizzleEXT(glSwizzleEXT_ARG_EXPAND);
typedef void (*glSwizzleEXT_PTR)(glSwizzleEXT_ARG_EXPAND);
#define glSyncTextureINTEL_INDEX 1956
#define glSyncTextureINTEL_RETURN void
#define glSyncTextureINTEL_ARG_NAMES texture
#define glSyncTextureINTEL_ARG_EXPAND GLuint texture
#define glSyncTextureINTEL_PACKED PACKED_glSyncTextureINTEL
#define glSyncTextureINTEL_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glSyncTextureINTEL_NOT_VOID_WRAP(...) {}
#define pack_glSyncTextureINTEL(_texture) ({ \
    glSyncTextureINTEL_PACKED *packed_data = malloc(sizeof(glSyncTextureINTEL_PACKED)); \
    packed_data->index = glSyncTextureINTEL_INDEX; \
    packed_data->args.texture = (GLuint)_texture; \
    (packed_call_t *)packed_data; \
})
#define call_glSyncTextureINTEL(packed, ret_v) do { \
    PACKED_glSyncTextureINTEL *unpacked = (PACKED_glSyncTextureINTEL *)packed; \
    ARGS_glSyncTextureINTEL *args = (ARGS_glSyncTextureINTEL *)&unpacked->args; \
    glSyncTextureINTEL(args->texture);; \
} while(0)
void glSyncTextureINTEL(glSyncTextureINTEL_ARG_EXPAND);
typedef void (*glSyncTextureINTEL_PTR)(glSyncTextureINTEL_ARG_EXPAND);
#define glTagSampleBufferSGIX_INDEX 1957
#define glTagSampleBufferSGIX_RETURN void
#define glTagSampleBufferSGIX_ARG_NAMES 
#define glTagSampleBufferSGIX_ARG_EXPAND 
#define glTagSampleBufferSGIX_PACKED PACKED_glTagSampleBufferSGIX
#define glTagSampleBufferSGIX_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTagSampleBufferSGIX_NOT_VOID_WRAP(...) {}
#define pack_glTagSampleBufferSGIX() ({ \
    glTagSampleBufferSGIX_PACKED *packed_data = malloc(sizeof(glTagSampleBufferSGIX_PACKED)); \
    packed_data->index = glTagSampleBufferSGIX_INDEX; \
    (packed_call_t *)packed_data; \
})
#define call_glTagSampleBufferSGIX(packed, ret_v) do { \
    glTagSampleBufferSGIX();; \
} while(0)
void glTagSampleBufferSGIX(glTagSampleBufferSGIX_ARG_EXPAND);
typedef void (*glTagSampleBufferSGIX_PTR)(glTagSampleBufferSGIX_ARG_EXPAND);
#define glTangent3bEXT_INDEX 1958
#define glTangent3bEXT_RETURN void
#define glTangent3bEXT_ARG_NAMES tx, ty, tz
#define glTangent3bEXT_ARG_EXPAND GLbyte tx, GLbyte ty, GLbyte tz
#define glTangent3bEXT_PACKED PACKED_glTangent3bEXT
#define glTangent3bEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTangent3bEXT_NOT_VOID_WRAP(...) {}
#define pack_glTangent3bEXT(_tx, _ty, _tz) ({ \
    glTangent3bEXT_PACKED *packed_data = malloc(sizeof(glTangent3bEXT_PACKED)); \
    packed_data->index = glTangent3bEXT_INDEX; \
    packed_data->args.tx = (GLbyte)_tx; \
    packed_data->args.ty = (GLbyte)_ty; \
    packed_data->args.tz = (GLbyte)_tz; \
    (packed_call_t *)packed_data; \
})
#define call_glTangent3bEXT(packed, ret_v) do { \
    PACKED_glTangent3bEXT *unpacked = (PACKED_glTangent3bEXT *)packed; \
    ARGS_glTangent3bEXT *args = (ARGS_glTangent3bEXT *)&unpacked->args; \
    glTangent3bEXT(args->tx, args->ty, args->tz);; \
} while(0)
void glTangent3bEXT(glTangent3bEXT_ARG_EXPAND);
typedef void (*glTangent3bEXT_PTR)(glTangent3bEXT_ARG_EXPAND);
#define glTangent3bvEXT_INDEX 1959
#define glTangent3bvEXT_RETURN void
#define glTangent3bvEXT_ARG_NAMES v
#define glTangent3bvEXT_ARG_EXPAND const GLbyte * v
#define glTangent3bvEXT_PACKED PACKED_glTangent3bvEXT
#define glTangent3bvEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTangent3bvEXT_NOT_VOID_WRAP(...) {}
#define pack_glTangent3bvEXT(_v) ({ \
    glTangent3bvEXT_PACKED *packed_data = malloc(sizeof(glTangent3bvEXT_PACKED)); \
    packed_data->index = glTangent3bvEXT_INDEX; \
    packed_data->args.v = (GLbyte *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glTangent3bvEXT(packed, ret_v) do { \
    PACKED_glTangent3bvEXT *unpacked = (PACKED_glTangent3bvEXT *)packed; \
    ARGS_glTangent3bvEXT *args = (ARGS_glTangent3bvEXT *)&unpacked->args; \
    glTangent3bvEXT(args->v);; \
} while(0)
void glTangent3bvEXT(glTangent3bvEXT_ARG_EXPAND);
typedef void (*glTangent3bvEXT_PTR)(glTangent3bvEXT_ARG_EXPAND);
#define glTangent3dEXT_INDEX 1960
#define glTangent3dEXT_RETURN void
#define glTangent3dEXT_ARG_NAMES tx, ty, tz
#define glTangent3dEXT_ARG_EXPAND GLdouble tx, GLdouble ty, GLdouble tz
#define glTangent3dEXT_PACKED PACKED_glTangent3dEXT
#define glTangent3dEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTangent3dEXT_NOT_VOID_WRAP(...) {}
#define pack_glTangent3dEXT(_tx, _ty, _tz) ({ \
    glTangent3dEXT_PACKED *packed_data = malloc(sizeof(glTangent3dEXT_PACKED)); \
    packed_data->index = glTangent3dEXT_INDEX; \
    packed_data->args.tx = (GLdouble)_tx; \
    packed_data->args.ty = (GLdouble)_ty; \
    packed_data->args.tz = (GLdouble)_tz; \
    (packed_call_t *)packed_data; \
})
#define call_glTangent3dEXT(packed, ret_v) do { \
    PACKED_glTangent3dEXT *unpacked = (PACKED_glTangent3dEXT *)packed; \
    ARGS_glTangent3dEXT *args = (ARGS_glTangent3dEXT *)&unpacked->args; \
    glTangent3dEXT(args->tx, args->ty, args->tz);; \
} while(0)
void glTangent3dEXT(glTangent3dEXT_ARG_EXPAND);
typedef void (*glTangent3dEXT_PTR)(glTangent3dEXT_ARG_EXPAND);
#define glTangent3dvEXT_INDEX 1961
#define glTangent3dvEXT_RETURN void
#define glTangent3dvEXT_ARG_NAMES v
#define glTangent3dvEXT_ARG_EXPAND const GLdouble * v
#define glTangent3dvEXT_PACKED PACKED_glTangent3dvEXT
#define glTangent3dvEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTangent3dvEXT_NOT_VOID_WRAP(...) {}
#define pack_glTangent3dvEXT(_v) ({ \
    glTangent3dvEXT_PACKED *packed_data = malloc(sizeof(glTangent3dvEXT_PACKED)); \
    packed_data->index = glTangent3dvEXT_INDEX; \
    packed_data->args.v = (GLdouble *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glTangent3dvEXT(packed, ret_v) do { \
    PACKED_glTangent3dvEXT *unpacked = (PACKED_glTangent3dvEXT *)packed; \
    ARGS_glTangent3dvEXT *args = (ARGS_glTangent3dvEXT *)&unpacked->args; \
    glTangent3dvEXT(args->v);; \
} while(0)
void glTangent3dvEXT(glTangent3dvEXT_ARG_EXPAND);
typedef void (*glTangent3dvEXT_PTR)(glTangent3dvEXT_ARG_EXPAND);
#define glTangent3fEXT_INDEX 1962
#define glTangent3fEXT_RETURN void
#define glTangent3fEXT_ARG_NAMES tx, ty, tz
#define glTangent3fEXT_ARG_EXPAND GLfloat tx, GLfloat ty, GLfloat tz
#define glTangent3fEXT_PACKED PACKED_glTangent3fEXT
#define glTangent3fEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTangent3fEXT_NOT_VOID_WRAP(...) {}
#define pack_glTangent3fEXT(_tx, _ty, _tz) ({ \
    glTangent3fEXT_PACKED *packed_data = malloc(sizeof(glTangent3fEXT_PACKED)); \
    packed_data->index = glTangent3fEXT_INDEX; \
    packed_data->args.tx = (GLfloat)_tx; \
    packed_data->args.ty = (GLfloat)_ty; \
    packed_data->args.tz = (GLfloat)_tz; \
    (packed_call_t *)packed_data; \
})
#define call_glTangent3fEXT(packed, ret_v) do { \
    PACKED_glTangent3fEXT *unpacked = (PACKED_glTangent3fEXT *)packed; \
    ARGS_glTangent3fEXT *args = (ARGS_glTangent3fEXT *)&unpacked->args; \
    glTangent3fEXT(args->tx, args->ty, args->tz);; \
} while(0)
void glTangent3fEXT(glTangent3fEXT_ARG_EXPAND);
typedef void (*glTangent3fEXT_PTR)(glTangent3fEXT_ARG_EXPAND);
#define glTangent3fvEXT_INDEX 1963
#define glTangent3fvEXT_RETURN void
#define glTangent3fvEXT_ARG_NAMES v
#define glTangent3fvEXT_ARG_EXPAND const GLfloat * v
#define glTangent3fvEXT_PACKED PACKED_glTangent3fvEXT
#define glTangent3fvEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTangent3fvEXT_NOT_VOID_WRAP(...) {}
#define pack_glTangent3fvEXT(_v) ({ \
    glTangent3fvEXT_PACKED *packed_data = malloc(sizeof(glTangent3fvEXT_PACKED)); \
    packed_data->index = glTangent3fvEXT_INDEX; \
    packed_data->args.v = (GLfloat *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glTangent3fvEXT(packed, ret_v) do { \
    PACKED_glTangent3fvEXT *unpacked = (PACKED_glTangent3fvEXT *)packed; \
    ARGS_glTangent3fvEXT *args = (ARGS_glTangent3fvEXT *)&unpacked->args; \
    glTangent3fvEXT(args->v);; \
} while(0)
void glTangent3fvEXT(glTangent3fvEXT_ARG_EXPAND);
typedef void (*glTangent3fvEXT_PTR)(glTangent3fvEXT_ARG_EXPAND);
#define glTangent3iEXT_INDEX 1964
#define glTangent3iEXT_RETURN void
#define glTangent3iEXT_ARG_NAMES tx, ty, tz
#define glTangent3iEXT_ARG_EXPAND GLint tx, GLint ty, GLint tz
#define glTangent3iEXT_PACKED PACKED_glTangent3iEXT
#define glTangent3iEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTangent3iEXT_NOT_VOID_WRAP(...) {}
#define pack_glTangent3iEXT(_tx, _ty, _tz) ({ \
    glTangent3iEXT_PACKED *packed_data = malloc(sizeof(glTangent3iEXT_PACKED)); \
    packed_data->index = glTangent3iEXT_INDEX; \
    packed_data->args.tx = (GLint)_tx; \
    packed_data->args.ty = (GLint)_ty; \
    packed_data->args.tz = (GLint)_tz; \
    (packed_call_t *)packed_data; \
})
#define call_glTangent3iEXT(packed, ret_v) do { \
    PACKED_glTangent3iEXT *unpacked = (PACKED_glTangent3iEXT *)packed; \
    ARGS_glTangent3iEXT *args = (ARGS_glTangent3iEXT *)&unpacked->args; \
    glTangent3iEXT(args->tx, args->ty, args->tz);; \
} while(0)
void glTangent3iEXT(glTangent3iEXT_ARG_EXPAND);
typedef void (*glTangent3iEXT_PTR)(glTangent3iEXT_ARG_EXPAND);
#define glTangent3ivEXT_INDEX 1965
#define glTangent3ivEXT_RETURN void
#define glTangent3ivEXT_ARG_NAMES v
#define glTangent3ivEXT_ARG_EXPAND const GLint * v
#define glTangent3ivEXT_PACKED PACKED_glTangent3ivEXT
#define glTangent3ivEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTangent3ivEXT_NOT_VOID_WRAP(...) {}
#define pack_glTangent3ivEXT(_v) ({ \
    glTangent3ivEXT_PACKED *packed_data = malloc(sizeof(glTangent3ivEXT_PACKED)); \
    packed_data->index = glTangent3ivEXT_INDEX; \
    packed_data->args.v = (GLint *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glTangent3ivEXT(packed, ret_v) do { \
    PACKED_glTangent3ivEXT *unpacked = (PACKED_glTangent3ivEXT *)packed; \
    ARGS_glTangent3ivEXT *args = (ARGS_glTangent3ivEXT *)&unpacked->args; \
    glTangent3ivEXT(args->v);; \
} while(0)
void glTangent3ivEXT(glTangent3ivEXT_ARG_EXPAND);
typedef void (*glTangent3ivEXT_PTR)(glTangent3ivEXT_ARG_EXPAND);
#define glTangent3sEXT_INDEX 1966
#define glTangent3sEXT_RETURN void
#define glTangent3sEXT_ARG_NAMES tx, ty, tz
#define glTangent3sEXT_ARG_EXPAND GLshort tx, GLshort ty, GLshort tz
#define glTangent3sEXT_PACKED PACKED_glTangent3sEXT
#define glTangent3sEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTangent3sEXT_NOT_VOID_WRAP(...) {}
#define pack_glTangent3sEXT(_tx, _ty, _tz) ({ \
    glTangent3sEXT_PACKED *packed_data = malloc(sizeof(glTangent3sEXT_PACKED)); \
    packed_data->index = glTangent3sEXT_INDEX; \
    packed_data->args.tx = (GLshort)_tx; \
    packed_data->args.ty = (GLshort)_ty; \
    packed_data->args.tz = (GLshort)_tz; \
    (packed_call_t *)packed_data; \
})
#define call_glTangent3sEXT(packed, ret_v) do { \
    PACKED_glTangent3sEXT *unpacked = (PACKED_glTangent3sEXT *)packed; \
    ARGS_glTangent3sEXT *args = (ARGS_glTangent3sEXT *)&unpacked->args; \
    glTangent3sEXT(args->tx, args->ty, args->tz);; \
} while(0)
void glTangent3sEXT(glTangent3sEXT_ARG_EXPAND);
typedef void (*glTangent3sEXT_PTR)(glTangent3sEXT_ARG_EXPAND);
#define glTangent3svEXT_INDEX 1967
#define glTangent3svEXT_RETURN void
#define glTangent3svEXT_ARG_NAMES v
#define glTangent3svEXT_ARG_EXPAND const GLshort * v
#define glTangent3svEXT_PACKED PACKED_glTangent3svEXT
#define glTangent3svEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTangent3svEXT_NOT_VOID_WRAP(...) {}
#define pack_glTangent3svEXT(_v) ({ \
    glTangent3svEXT_PACKED *packed_data = malloc(sizeof(glTangent3svEXT_PACKED)); \
    packed_data->index = glTangent3svEXT_INDEX; \
    packed_data->args.v = (GLshort *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glTangent3svEXT(packed, ret_v) do { \
    PACKED_glTangent3svEXT *unpacked = (PACKED_glTangent3svEXT *)packed; \
    ARGS_glTangent3svEXT *args = (ARGS_glTangent3svEXT *)&unpacked->args; \
    glTangent3svEXT(args->v);; \
} while(0)
void glTangent3svEXT(glTangent3svEXT_ARG_EXPAND);
typedef void (*glTangent3svEXT_PTR)(glTangent3svEXT_ARG_EXPAND);
#define glTangentPointerEXT_INDEX 1968
#define glTangentPointerEXT_RETURN void
#define glTangentPointerEXT_ARG_NAMES type, stride, pointer
#define glTangentPointerEXT_ARG_EXPAND GLenum type, GLsizei stride, const GLvoid * pointer
#define glTangentPointerEXT_PACKED PACKED_glTangentPointerEXT
#define glTangentPointerEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTangentPointerEXT_NOT_VOID_WRAP(...) {}
#define pack_glTangentPointerEXT(_type, _stride, _pointer) ({ \
    glTangentPointerEXT_PACKED *packed_data = malloc(sizeof(glTangentPointerEXT_PACKED)); \
    packed_data->index = glTangentPointerEXT_INDEX; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.stride = (GLsizei)_stride; \
    packed_data->args.pointer = (GLvoid *)_pointer; \
    (packed_call_t *)packed_data; \
})
#define call_glTangentPointerEXT(packed, ret_v) do { \
    PACKED_glTangentPointerEXT *unpacked = (PACKED_glTangentPointerEXT *)packed; \
    ARGS_glTangentPointerEXT *args = (ARGS_glTangentPointerEXT *)&unpacked->args; \
    glTangentPointerEXT(args->type, args->stride, args->pointer);; \
} while(0)
void glTangentPointerEXT(glTangentPointerEXT_ARG_EXPAND);
typedef void (*glTangentPointerEXT_PTR)(glTangentPointerEXT_ARG_EXPAND);
#define glTbufferMask3DFX_INDEX 1969
#define glTbufferMask3DFX_RETURN void
#define glTbufferMask3DFX_ARG_NAMES mask
#define glTbufferMask3DFX_ARG_EXPAND GLuint mask
#define glTbufferMask3DFX_PACKED PACKED_glTbufferMask3DFX
#define glTbufferMask3DFX_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTbufferMask3DFX_NOT_VOID_WRAP(...) {}
#define pack_glTbufferMask3DFX(_mask) ({ \
    glTbufferMask3DFX_PACKED *packed_data = malloc(sizeof(glTbufferMask3DFX_PACKED)); \
    packed_data->index = glTbufferMask3DFX_INDEX; \
    packed_data->args.mask = (GLuint)_mask; \
    (packed_call_t *)packed_data; \
})
#define call_glTbufferMask3DFX(packed, ret_v) do { \
    PACKED_glTbufferMask3DFX *unpacked = (PACKED_glTbufferMask3DFX *)packed; \
    ARGS_glTbufferMask3DFX *args = (ARGS_glTbufferMask3DFX *)&unpacked->args; \
    glTbufferMask3DFX(args->mask);; \
} while(0)
void glTbufferMask3DFX(glTbufferMask3DFX_ARG_EXPAND);
typedef void (*glTbufferMask3DFX_PTR)(glTbufferMask3DFX_ARG_EXPAND);
#define glTessellationFactorAMD_INDEX 1970
#define glTessellationFactorAMD_RETURN void
#define glTessellationFactorAMD_ARG_NAMES factor
#define glTessellationFactorAMD_ARG_EXPAND GLfloat factor
#define glTessellationFactorAMD_PACKED PACKED_glTessellationFactorAMD
#define glTessellationFactorAMD_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTessellationFactorAMD_NOT_VOID_WRAP(...) {}
#define pack_glTessellationFactorAMD(_factor) ({ \
    glTessellationFactorAMD_PACKED *packed_data = malloc(sizeof(glTessellationFactorAMD_PACKED)); \
    packed_data->index = glTessellationFactorAMD_INDEX; \
    packed_data->args.factor = (GLfloat)_factor; \
    (packed_call_t *)packed_data; \
})
#define call_glTessellationFactorAMD(packed, ret_v) do { \
    PACKED_glTessellationFactorAMD *unpacked = (PACKED_glTessellationFactorAMD *)packed; \
    ARGS_glTessellationFactorAMD *args = (ARGS_glTessellationFactorAMD *)&unpacked->args; \
    glTessellationFactorAMD(args->factor);; \
} while(0)
void glTessellationFactorAMD(glTessellationFactorAMD_ARG_EXPAND);
typedef void (*glTessellationFactorAMD_PTR)(glTessellationFactorAMD_ARG_EXPAND);
#define glTessellationModeAMD_INDEX 1971
#define glTessellationModeAMD_RETURN void
#define glTessellationModeAMD_ARG_NAMES mode
#define glTessellationModeAMD_ARG_EXPAND GLenum mode
#define glTessellationModeAMD_PACKED PACKED_glTessellationModeAMD
#define glTessellationModeAMD_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTessellationModeAMD_NOT_VOID_WRAP(...) {}
#define pack_glTessellationModeAMD(_mode) ({ \
    glTessellationModeAMD_PACKED *packed_data = malloc(sizeof(glTessellationModeAMD_PACKED)); \
    packed_data->index = glTessellationModeAMD_INDEX; \
    packed_data->args.mode = (GLenum)_mode; \
    (packed_call_t *)packed_data; \
})
#define call_glTessellationModeAMD(packed, ret_v) do { \
    PACKED_glTessellationModeAMD *unpacked = (PACKED_glTessellationModeAMD *)packed; \
    ARGS_glTessellationModeAMD *args = (ARGS_glTessellationModeAMD *)&unpacked->args; \
    glTessellationModeAMD(args->mode);; \
} while(0)
void glTessellationModeAMD(glTessellationModeAMD_ARG_EXPAND);
typedef void (*glTessellationModeAMD_PTR)(glTessellationModeAMD_ARG_EXPAND);
#define glTestFenceAPPLE_INDEX 1972
#define glTestFenceAPPLE_RETURN GLboolean
#define glTestFenceAPPLE_ARG_NAMES fence
#define glTestFenceAPPLE_ARG_EXPAND GLuint fence
#define glTestFenceAPPLE_PACKED PACKED_glTestFenceAPPLE
#define glTestFenceAPPLE_VOID_ONLY_WRAP(...) {}
#define glTestFenceAPPLE_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glTestFenceAPPLE(_fence) ({ \
    glTestFenceAPPLE_PACKED *packed_data = malloc(sizeof(glTestFenceAPPLE_PACKED)); \
    packed_data->index = glTestFenceAPPLE_INDEX; \
    packed_data->args.fence = (GLuint)_fence; \
    (packed_call_t *)packed_data; \
})
#define call_glTestFenceAPPLE(packed, ret_v) do { \
    PACKED_glTestFenceAPPLE *unpacked = (PACKED_glTestFenceAPPLE *)packed; \
    ARGS_glTestFenceAPPLE *args = (ARGS_glTestFenceAPPLE *)&unpacked->args; \
    GLboolean *ret = (GLboolean *)ret_v; \
    if (ret != NULL) { \
        *ret = glTestFenceAPPLE(args->fence);; \
    } else { \
        glTestFenceAPPLE(args->fence);; \
    } \
} while(0)
GLboolean glTestFenceAPPLE(glTestFenceAPPLE_ARG_EXPAND);
typedef GLboolean (*glTestFenceAPPLE_PTR)(glTestFenceAPPLE_ARG_EXPAND);
#define glTestFenceNV_INDEX 1973
#define glTestFenceNV_RETURN GLboolean
#define glTestFenceNV_ARG_NAMES fence
#define glTestFenceNV_ARG_EXPAND GLuint fence
#define glTestFenceNV_PACKED PACKED_glTestFenceNV
#define glTestFenceNV_VOID_ONLY_WRAP(...) {}
#define glTestFenceNV_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glTestFenceNV(_fence) ({ \
    glTestFenceNV_PACKED *packed_data = malloc(sizeof(glTestFenceNV_PACKED)); \
    packed_data->index = glTestFenceNV_INDEX; \
    packed_data->args.fence = (GLuint)_fence; \
    (packed_call_t *)packed_data; \
})
#define call_glTestFenceNV(packed, ret_v) do { \
    PACKED_glTestFenceNV *unpacked = (PACKED_glTestFenceNV *)packed; \
    ARGS_glTestFenceNV *args = (ARGS_glTestFenceNV *)&unpacked->args; \
    GLboolean *ret = (GLboolean *)ret_v; \
    if (ret != NULL) { \
        *ret = glTestFenceNV(args->fence);; \
    } else { \
        glTestFenceNV(args->fence);; \
    } \
} while(0)
GLboolean glTestFenceNV(glTestFenceNV_ARG_EXPAND);
typedef GLboolean (*glTestFenceNV_PTR)(glTestFenceNV_ARG_EXPAND);
#define glTestObjectAPPLE_INDEX 1974
#define glTestObjectAPPLE_RETURN GLboolean
#define glTestObjectAPPLE_ARG_NAMES object, name
#define glTestObjectAPPLE_ARG_EXPAND GLenum object, GLuint name
#define glTestObjectAPPLE_PACKED PACKED_glTestObjectAPPLE
#define glTestObjectAPPLE_VOID_ONLY_WRAP(...) {}
#define glTestObjectAPPLE_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glTestObjectAPPLE(_object, _name) ({ \
    glTestObjectAPPLE_PACKED *packed_data = malloc(sizeof(glTestObjectAPPLE_PACKED)); \
    packed_data->index = glTestObjectAPPLE_INDEX; \
    packed_data->args.object = (GLenum)_object; \
    packed_data->args.name = (GLuint)_name; \
    (packed_call_t *)packed_data; \
})
#define call_glTestObjectAPPLE(packed, ret_v) do { \
    PACKED_glTestObjectAPPLE *unpacked = (PACKED_glTestObjectAPPLE *)packed; \
    ARGS_glTestObjectAPPLE *args = (ARGS_glTestObjectAPPLE *)&unpacked->args; \
    GLboolean *ret = (GLboolean *)ret_v; \
    if (ret != NULL) { \
        *ret = glTestObjectAPPLE(args->object, args->name);; \
    } else { \
        glTestObjectAPPLE(args->object, args->name);; \
    } \
} while(0)
GLboolean glTestObjectAPPLE(glTestObjectAPPLE_ARG_EXPAND);
typedef GLboolean (*glTestObjectAPPLE_PTR)(glTestObjectAPPLE_ARG_EXPAND);
#define glTexBuffer_INDEX 1975
#define glTexBuffer_RETURN void
#define glTexBuffer_ARG_NAMES target, internalformat, buffer
#define glTexBuffer_ARG_EXPAND GLenum target, GLenum internalformat, GLuint buffer
#define glTexBuffer_PACKED PACKED_glTexBuffer
#define glTexBuffer_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexBuffer_NOT_VOID_WRAP(...) {}
#define pack_glTexBuffer(_target, _internalformat, _buffer) ({ \
    glTexBuffer_PACKED *packed_data = malloc(sizeof(glTexBuffer_PACKED)); \
    packed_data->index = glTexBuffer_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.internalformat = (GLenum)_internalformat; \
    packed_data->args.buffer = (GLuint)_buffer; \
    (packed_call_t *)packed_data; \
})
#define call_glTexBuffer(packed, ret_v) do { \
    PACKED_glTexBuffer *unpacked = (PACKED_glTexBuffer *)packed; \
    ARGS_glTexBuffer *args = (ARGS_glTexBuffer *)&unpacked->args; \
    glTexBuffer(args->target, args->internalformat, args->buffer);; \
} while(0)
void glTexBuffer(glTexBuffer_ARG_EXPAND);
typedef void (*glTexBuffer_PTR)(glTexBuffer_ARG_EXPAND);
#define glTexBufferARB_INDEX 1976
#define glTexBufferARB_RETURN void
#define glTexBufferARB_ARG_NAMES target, internalformat, buffer
#define glTexBufferARB_ARG_EXPAND GLenum target, GLenum internalformat, GLuint buffer
#define glTexBufferARB_PACKED PACKED_glTexBufferARB
#define glTexBufferARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexBufferARB_NOT_VOID_WRAP(...) {}
#define pack_glTexBufferARB(_target, _internalformat, _buffer) ({ \
    glTexBufferARB_PACKED *packed_data = malloc(sizeof(glTexBufferARB_PACKED)); \
    packed_data->index = glTexBufferARB_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.internalformat = (GLenum)_internalformat; \
    packed_data->args.buffer = (GLuint)_buffer; \
    (packed_call_t *)packed_data; \
})
#define call_glTexBufferARB(packed, ret_v) do { \
    PACKED_glTexBufferARB *unpacked = (PACKED_glTexBufferARB *)packed; \
    ARGS_glTexBufferARB *args = (ARGS_glTexBufferARB *)&unpacked->args; \
    glTexBufferARB(args->target, args->internalformat, args->buffer);; \
} while(0)
void glTexBufferARB(glTexBufferARB_ARG_EXPAND);
typedef void (*glTexBufferARB_PTR)(glTexBufferARB_ARG_EXPAND);
#define glTexBufferEXT_INDEX 1977
#define glTexBufferEXT_RETURN void
#define glTexBufferEXT_ARG_NAMES target, internalformat, buffer
#define glTexBufferEXT_ARG_EXPAND GLenum target, GLenum internalformat, GLuint buffer
#define glTexBufferEXT_PACKED PACKED_glTexBufferEXT
#define glTexBufferEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexBufferEXT_NOT_VOID_WRAP(...) {}
#define pack_glTexBufferEXT(_target, _internalformat, _buffer) ({ \
    glTexBufferEXT_PACKED *packed_data = malloc(sizeof(glTexBufferEXT_PACKED)); \
    packed_data->index = glTexBufferEXT_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.internalformat = (GLenum)_internalformat; \
    packed_data->args.buffer = (GLuint)_buffer; \
    (packed_call_t *)packed_data; \
})
#define call_glTexBufferEXT(packed, ret_v) do { \
    PACKED_glTexBufferEXT *unpacked = (PACKED_glTexBufferEXT *)packed; \
    ARGS_glTexBufferEXT *args = (ARGS_glTexBufferEXT *)&unpacked->args; \
    glTexBufferEXT(args->target, args->internalformat, args->buffer);; \
} while(0)
void glTexBufferEXT(glTexBufferEXT_ARG_EXPAND);
typedef void (*glTexBufferEXT_PTR)(glTexBufferEXT_ARG_EXPAND);
#define glTexBufferRange_INDEX 1978
#define glTexBufferRange_RETURN void
#define glTexBufferRange_ARG_NAMES target, internalformat, buffer, offset, size
#define glTexBufferRange_ARG_EXPAND GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size
#define glTexBufferRange_PACKED PACKED_glTexBufferRange
#define glTexBufferRange_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexBufferRange_NOT_VOID_WRAP(...) {}
#define pack_glTexBufferRange(_target, _internalformat, _buffer, _offset, _size) ({ \
    glTexBufferRange_PACKED *packed_data = malloc(sizeof(glTexBufferRange_PACKED)); \
    packed_data->index = glTexBufferRange_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.internalformat = (GLenum)_internalformat; \
    packed_data->args.buffer = (GLuint)_buffer; \
    packed_data->args.offset = (GLintptr)_offset; \
    packed_data->args.size = (GLsizeiptr)_size; \
    (packed_call_t *)packed_data; \
})
#define call_glTexBufferRange(packed, ret_v) do { \
    PACKED_glTexBufferRange *unpacked = (PACKED_glTexBufferRange *)packed; \
    ARGS_glTexBufferRange *args = (ARGS_glTexBufferRange *)&unpacked->args; \
    glTexBufferRange(args->target, args->internalformat, args->buffer, args->offset, args->size);; \
} while(0)
void glTexBufferRange(glTexBufferRange_ARG_EXPAND);
typedef void (*glTexBufferRange_PTR)(glTexBufferRange_ARG_EXPAND);
#define glTexBumpParameterfvATI_INDEX 1979
#define glTexBumpParameterfvATI_RETURN void
#define glTexBumpParameterfvATI_ARG_NAMES pname, param
#define glTexBumpParameterfvATI_ARG_EXPAND GLenum pname, const GLfloat * param
#define glTexBumpParameterfvATI_PACKED PACKED_glTexBumpParameterfvATI
#define glTexBumpParameterfvATI_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexBumpParameterfvATI_NOT_VOID_WRAP(...) {}
#define pack_glTexBumpParameterfvATI(_pname, _param) ({ \
    glTexBumpParameterfvATI_PACKED *packed_data = malloc(sizeof(glTexBumpParameterfvATI_PACKED)); \
    packed_data->index = glTexBumpParameterfvATI_INDEX; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.param = (GLfloat *)_param; \
    (packed_call_t *)packed_data; \
})
#define call_glTexBumpParameterfvATI(packed, ret_v) do { \
    PACKED_glTexBumpParameterfvATI *unpacked = (PACKED_glTexBumpParameterfvATI *)packed; \
    ARGS_glTexBumpParameterfvATI *args = (ARGS_glTexBumpParameterfvATI *)&unpacked->args; \
    glTexBumpParameterfvATI(args->pname, args->param);; \
} while(0)
void glTexBumpParameterfvATI(glTexBumpParameterfvATI_ARG_EXPAND);
typedef void (*glTexBumpParameterfvATI_PTR)(glTexBumpParameterfvATI_ARG_EXPAND);
#define glTexBumpParameterivATI_INDEX 1980
#define glTexBumpParameterivATI_RETURN void
#define glTexBumpParameterivATI_ARG_NAMES pname, param
#define glTexBumpParameterivATI_ARG_EXPAND GLenum pname, const GLint * param
#define glTexBumpParameterivATI_PACKED PACKED_glTexBumpParameterivATI
#define glTexBumpParameterivATI_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexBumpParameterivATI_NOT_VOID_WRAP(...) {}
#define pack_glTexBumpParameterivATI(_pname, _param) ({ \
    glTexBumpParameterivATI_PACKED *packed_data = malloc(sizeof(glTexBumpParameterivATI_PACKED)); \
    packed_data->index = glTexBumpParameterivATI_INDEX; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.param = (GLint *)_param; \
    (packed_call_t *)packed_data; \
})
#define call_glTexBumpParameterivATI(packed, ret_v) do { \
    PACKED_glTexBumpParameterivATI *unpacked = (PACKED_glTexBumpParameterivATI *)packed; \
    ARGS_glTexBumpParameterivATI *args = (ARGS_glTexBumpParameterivATI *)&unpacked->args; \
    glTexBumpParameterivATI(args->pname, args->param);; \
} while(0)
void glTexBumpParameterivATI(glTexBumpParameterivATI_ARG_EXPAND);
typedef void (*glTexBumpParameterivATI_PTR)(glTexBumpParameterivATI_ARG_EXPAND);
#define glTexCoord1bOES_INDEX 1981
#define glTexCoord1bOES_RETURN void
#define glTexCoord1bOES_ARG_NAMES s
#define glTexCoord1bOES_ARG_EXPAND GLbyte s
#define glTexCoord1bOES_PACKED PACKED_glTexCoord1bOES
#define glTexCoord1bOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexCoord1bOES_NOT_VOID_WRAP(...) {}
#define pack_glTexCoord1bOES(_s) ({ \
    glTexCoord1bOES_PACKED *packed_data = malloc(sizeof(glTexCoord1bOES_PACKED)); \
    packed_data->index = glTexCoord1bOES_INDEX; \
    packed_data->args.s = (GLbyte)_s; \
    (packed_call_t *)packed_data; \
})
#define call_glTexCoord1bOES(packed, ret_v) do { \
    PACKED_glTexCoord1bOES *unpacked = (PACKED_glTexCoord1bOES *)packed; \
    ARGS_glTexCoord1bOES *args = (ARGS_glTexCoord1bOES *)&unpacked->args; \
    glTexCoord1bOES(args->s);; \
} while(0)
void glTexCoord1bOES(glTexCoord1bOES_ARG_EXPAND);
typedef void (*glTexCoord1bOES_PTR)(glTexCoord1bOES_ARG_EXPAND);
#define glTexCoord1bvOES_INDEX 1982
#define glTexCoord1bvOES_RETURN void
#define glTexCoord1bvOES_ARG_NAMES coords
#define glTexCoord1bvOES_ARG_EXPAND const GLbyte * coords
#define glTexCoord1bvOES_PACKED PACKED_glTexCoord1bvOES
#define glTexCoord1bvOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexCoord1bvOES_NOT_VOID_WRAP(...) {}
#define pack_glTexCoord1bvOES(_coords) ({ \
    glTexCoord1bvOES_PACKED *packed_data = malloc(sizeof(glTexCoord1bvOES_PACKED)); \
    packed_data->index = glTexCoord1bvOES_INDEX; \
    packed_data->args.coords = (GLbyte *)_coords; \
    (packed_call_t *)packed_data; \
})
#define call_glTexCoord1bvOES(packed, ret_v) do { \
    PACKED_glTexCoord1bvOES *unpacked = (PACKED_glTexCoord1bvOES *)packed; \
    ARGS_glTexCoord1bvOES *args = (ARGS_glTexCoord1bvOES *)&unpacked->args; \
    glTexCoord1bvOES(args->coords);; \
} while(0)
void glTexCoord1bvOES(glTexCoord1bvOES_ARG_EXPAND);
typedef void (*glTexCoord1bvOES_PTR)(glTexCoord1bvOES_ARG_EXPAND);
#define glTexCoord1d_INDEX 1983
#define glTexCoord1d_RETURN void
#define glTexCoord1d_ARG_NAMES s
#define glTexCoord1d_ARG_EXPAND GLdouble s
#define glTexCoord1d_PACKED PACKED_glTexCoord1d
#define glTexCoord1d_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexCoord1d_NOT_VOID_WRAP(...) {}
#define pack_glTexCoord1d(_s) ({ \
    glTexCoord1d_PACKED *packed_data = malloc(sizeof(glTexCoord1d_PACKED)); \
    packed_data->index = glTexCoord1d_INDEX; \
    packed_data->args.s = (GLdouble)_s; \
    (packed_call_t *)packed_data; \
})
#define call_glTexCoord1d(packed, ret_v) do { \
    PACKED_glTexCoord1d *unpacked = (PACKED_glTexCoord1d *)packed; \
    ARGS_glTexCoord1d *args = (ARGS_glTexCoord1d *)&unpacked->args; \
    glTexCoord1d(args->s);; \
} while(0)
void glTexCoord1d(glTexCoord1d_ARG_EXPAND);
typedef void (*glTexCoord1d_PTR)(glTexCoord1d_ARG_EXPAND);
#define glTexCoord1dv_INDEX 1984
#define glTexCoord1dv_RETURN void
#define glTexCoord1dv_ARG_NAMES v
#define glTexCoord1dv_ARG_EXPAND const GLdouble * v
#define glTexCoord1dv_PACKED PACKED_glTexCoord1dv
#define glTexCoord1dv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexCoord1dv_NOT_VOID_WRAP(...) {}
#define pack_glTexCoord1dv(_v) ({ \
    glTexCoord1dv_PACKED *packed_data = malloc(sizeof(glTexCoord1dv_PACKED)); \
    packed_data->index = glTexCoord1dv_INDEX; \
    packed_data->args.v = (GLdouble *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glTexCoord1dv(packed, ret_v) do { \
    PACKED_glTexCoord1dv *unpacked = (PACKED_glTexCoord1dv *)packed; \
    ARGS_glTexCoord1dv *args = (ARGS_glTexCoord1dv *)&unpacked->args; \
    glTexCoord1dv(args->v);; \
} while(0)
void glTexCoord1dv(glTexCoord1dv_ARG_EXPAND);
typedef void (*glTexCoord1dv_PTR)(glTexCoord1dv_ARG_EXPAND);
#define glTexCoord1f_INDEX 1985
#define glTexCoord1f_RETURN void
#define glTexCoord1f_ARG_NAMES s
#define glTexCoord1f_ARG_EXPAND GLfloat s
#define glTexCoord1f_PACKED PACKED_glTexCoord1f
#define glTexCoord1f_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexCoord1f_NOT_VOID_WRAP(...) {}
#define pack_glTexCoord1f(_s) ({ \
    glTexCoord1f_PACKED *packed_data = malloc(sizeof(glTexCoord1f_PACKED)); \
    packed_data->index = glTexCoord1f_INDEX; \
    packed_data->args.s = (GLfloat)_s; \
    (packed_call_t *)packed_data; \
})
#define call_glTexCoord1f(packed, ret_v) do { \
    PACKED_glTexCoord1f *unpacked = (PACKED_glTexCoord1f *)packed; \
    ARGS_glTexCoord1f *args = (ARGS_glTexCoord1f *)&unpacked->args; \
    glTexCoord1f(args->s);; \
} while(0)
void glTexCoord1f(glTexCoord1f_ARG_EXPAND);
typedef void (*glTexCoord1f_PTR)(glTexCoord1f_ARG_EXPAND);
#define glTexCoord1fv_INDEX 1986
#define glTexCoord1fv_RETURN void
#define glTexCoord1fv_ARG_NAMES v
#define glTexCoord1fv_ARG_EXPAND const GLfloat * v
#define glTexCoord1fv_PACKED PACKED_glTexCoord1fv
#define glTexCoord1fv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexCoord1fv_NOT_VOID_WRAP(...) {}
#define pack_glTexCoord1fv(_v) ({ \
    glTexCoord1fv_PACKED *packed_data = malloc(sizeof(glTexCoord1fv_PACKED)); \
    packed_data->index = glTexCoord1fv_INDEX; \
    packed_data->args.v = (GLfloat *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glTexCoord1fv(packed, ret_v) do { \
    PACKED_glTexCoord1fv *unpacked = (PACKED_glTexCoord1fv *)packed; \
    ARGS_glTexCoord1fv *args = (ARGS_glTexCoord1fv *)&unpacked->args; \
    glTexCoord1fv(args->v);; \
} while(0)
void glTexCoord1fv(glTexCoord1fv_ARG_EXPAND);
typedef void (*glTexCoord1fv_PTR)(glTexCoord1fv_ARG_EXPAND);
#define glTexCoord1hNV_INDEX 1987
#define glTexCoord1hNV_RETURN void
#define glTexCoord1hNV_ARG_NAMES s
#define glTexCoord1hNV_ARG_EXPAND GLhalfNV s
#define glTexCoord1hNV_PACKED PACKED_glTexCoord1hNV
#define glTexCoord1hNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexCoord1hNV_NOT_VOID_WRAP(...) {}
#define pack_glTexCoord1hNV(_s) ({ \
    glTexCoord1hNV_PACKED *packed_data = malloc(sizeof(glTexCoord1hNV_PACKED)); \
    packed_data->index = glTexCoord1hNV_INDEX; \
    packed_data->args.s = (GLhalfNV)_s; \
    (packed_call_t *)packed_data; \
})
#define call_glTexCoord1hNV(packed, ret_v) do { \
    PACKED_glTexCoord1hNV *unpacked = (PACKED_glTexCoord1hNV *)packed; \
    ARGS_glTexCoord1hNV *args = (ARGS_glTexCoord1hNV *)&unpacked->args; \
    glTexCoord1hNV(args->s);; \
} while(0)
void glTexCoord1hNV(glTexCoord1hNV_ARG_EXPAND);
typedef void (*glTexCoord1hNV_PTR)(glTexCoord1hNV_ARG_EXPAND);
#define glTexCoord1hvNV_INDEX 1988
#define glTexCoord1hvNV_RETURN void
#define glTexCoord1hvNV_ARG_NAMES v
#define glTexCoord1hvNV_ARG_EXPAND const GLhalfNV * v
#define glTexCoord1hvNV_PACKED PACKED_glTexCoord1hvNV
#define glTexCoord1hvNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexCoord1hvNV_NOT_VOID_WRAP(...) {}
#define pack_glTexCoord1hvNV(_v) ({ \
    glTexCoord1hvNV_PACKED *packed_data = malloc(sizeof(glTexCoord1hvNV_PACKED)); \
    packed_data->index = glTexCoord1hvNV_INDEX; \
    packed_data->args.v = (GLhalfNV *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glTexCoord1hvNV(packed, ret_v) do { \
    PACKED_glTexCoord1hvNV *unpacked = (PACKED_glTexCoord1hvNV *)packed; \
    ARGS_glTexCoord1hvNV *args = (ARGS_glTexCoord1hvNV *)&unpacked->args; \
    glTexCoord1hvNV(args->v);; \
} while(0)
void glTexCoord1hvNV(glTexCoord1hvNV_ARG_EXPAND);
typedef void (*glTexCoord1hvNV_PTR)(glTexCoord1hvNV_ARG_EXPAND);
#define glTexCoord1i_INDEX 1989
#define glTexCoord1i_RETURN void
#define glTexCoord1i_ARG_NAMES s
#define glTexCoord1i_ARG_EXPAND GLint s
#define glTexCoord1i_PACKED PACKED_glTexCoord1i
#define glTexCoord1i_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexCoord1i_NOT_VOID_WRAP(...) {}
#define pack_glTexCoord1i(_s) ({ \
    glTexCoord1i_PACKED *packed_data = malloc(sizeof(glTexCoord1i_PACKED)); \
    packed_data->index = glTexCoord1i_INDEX; \
    packed_data->args.s = (GLint)_s; \
    (packed_call_t *)packed_data; \
})
#define call_glTexCoord1i(packed, ret_v) do { \
    PACKED_glTexCoord1i *unpacked = (PACKED_glTexCoord1i *)packed; \
    ARGS_glTexCoord1i *args = (ARGS_glTexCoord1i *)&unpacked->args; \
    glTexCoord1i(args->s);; \
} while(0)
void glTexCoord1i(glTexCoord1i_ARG_EXPAND);
typedef void (*glTexCoord1i_PTR)(glTexCoord1i_ARG_EXPAND);
#define glTexCoord1iv_INDEX 1990
#define glTexCoord1iv_RETURN void
#define glTexCoord1iv_ARG_NAMES v
#define glTexCoord1iv_ARG_EXPAND const GLint * v
#define glTexCoord1iv_PACKED PACKED_glTexCoord1iv
#define glTexCoord1iv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexCoord1iv_NOT_VOID_WRAP(...) {}
#define pack_glTexCoord1iv(_v) ({ \
    glTexCoord1iv_PACKED *packed_data = malloc(sizeof(glTexCoord1iv_PACKED)); \
    packed_data->index = glTexCoord1iv_INDEX; \
    packed_data->args.v = (GLint *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glTexCoord1iv(packed, ret_v) do { \
    PACKED_glTexCoord1iv *unpacked = (PACKED_glTexCoord1iv *)packed; \
    ARGS_glTexCoord1iv *args = (ARGS_glTexCoord1iv *)&unpacked->args; \
    glTexCoord1iv(args->v);; \
} while(0)
void glTexCoord1iv(glTexCoord1iv_ARG_EXPAND);
typedef void (*glTexCoord1iv_PTR)(glTexCoord1iv_ARG_EXPAND);
#define glTexCoord1s_INDEX 1991
#define glTexCoord1s_RETURN void
#define glTexCoord1s_ARG_NAMES s
#define glTexCoord1s_ARG_EXPAND GLshort s
#define glTexCoord1s_PACKED PACKED_glTexCoord1s
#define glTexCoord1s_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexCoord1s_NOT_VOID_WRAP(...) {}
#define pack_glTexCoord1s(_s) ({ \
    glTexCoord1s_PACKED *packed_data = malloc(sizeof(glTexCoord1s_PACKED)); \
    packed_data->index = glTexCoord1s_INDEX; \
    packed_data->args.s = (GLshort)_s; \
    (packed_call_t *)packed_data; \
})
#define call_glTexCoord1s(packed, ret_v) do { \
    PACKED_glTexCoord1s *unpacked = (PACKED_glTexCoord1s *)packed; \
    ARGS_glTexCoord1s *args = (ARGS_glTexCoord1s *)&unpacked->args; \
    glTexCoord1s(args->s);; \
} while(0)
void glTexCoord1s(glTexCoord1s_ARG_EXPAND);
typedef void (*glTexCoord1s_PTR)(glTexCoord1s_ARG_EXPAND);
#define glTexCoord1sv_INDEX 1992
#define glTexCoord1sv_RETURN void
#define glTexCoord1sv_ARG_NAMES v
#define glTexCoord1sv_ARG_EXPAND const GLshort * v
#define glTexCoord1sv_PACKED PACKED_glTexCoord1sv
#define glTexCoord1sv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexCoord1sv_NOT_VOID_WRAP(...) {}
#define pack_glTexCoord1sv(_v) ({ \
    glTexCoord1sv_PACKED *packed_data = malloc(sizeof(glTexCoord1sv_PACKED)); \
    packed_data->index = glTexCoord1sv_INDEX; \
    packed_data->args.v = (GLshort *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glTexCoord1sv(packed, ret_v) do { \
    PACKED_glTexCoord1sv *unpacked = (PACKED_glTexCoord1sv *)packed; \
    ARGS_glTexCoord1sv *args = (ARGS_glTexCoord1sv *)&unpacked->args; \
    glTexCoord1sv(args->v);; \
} while(0)
void glTexCoord1sv(glTexCoord1sv_ARG_EXPAND);
typedef void (*glTexCoord1sv_PTR)(glTexCoord1sv_ARG_EXPAND);
#define glTexCoord1xOES_INDEX 1993
#define glTexCoord1xOES_RETURN void
#define glTexCoord1xOES_ARG_NAMES s
#define glTexCoord1xOES_ARG_EXPAND GLfixed s
#define glTexCoord1xOES_PACKED PACKED_glTexCoord1xOES
#define glTexCoord1xOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexCoord1xOES_NOT_VOID_WRAP(...) {}
#define pack_glTexCoord1xOES(_s) ({ \
    glTexCoord1xOES_PACKED *packed_data = malloc(sizeof(glTexCoord1xOES_PACKED)); \
    packed_data->index = glTexCoord1xOES_INDEX; \
    packed_data->args.s = (GLfixed)_s; \
    (packed_call_t *)packed_data; \
})
#define call_glTexCoord1xOES(packed, ret_v) do { \
    PACKED_glTexCoord1xOES *unpacked = (PACKED_glTexCoord1xOES *)packed; \
    ARGS_glTexCoord1xOES *args = (ARGS_glTexCoord1xOES *)&unpacked->args; \
    glTexCoord1xOES(args->s);; \
} while(0)
void glTexCoord1xOES(glTexCoord1xOES_ARG_EXPAND);
typedef void (*glTexCoord1xOES_PTR)(glTexCoord1xOES_ARG_EXPAND);
#define glTexCoord1xvOES_INDEX 1994
#define glTexCoord1xvOES_RETURN void
#define glTexCoord1xvOES_ARG_NAMES coords
#define glTexCoord1xvOES_ARG_EXPAND const GLfixed * coords
#define glTexCoord1xvOES_PACKED PACKED_glTexCoord1xvOES
#define glTexCoord1xvOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexCoord1xvOES_NOT_VOID_WRAP(...) {}
#define pack_glTexCoord1xvOES(_coords) ({ \
    glTexCoord1xvOES_PACKED *packed_data = malloc(sizeof(glTexCoord1xvOES_PACKED)); \
    packed_data->index = glTexCoord1xvOES_INDEX; \
    packed_data->args.coords = (GLfixed *)_coords; \
    (packed_call_t *)packed_data; \
})
#define call_glTexCoord1xvOES(packed, ret_v) do { \
    PACKED_glTexCoord1xvOES *unpacked = (PACKED_glTexCoord1xvOES *)packed; \
    ARGS_glTexCoord1xvOES *args = (ARGS_glTexCoord1xvOES *)&unpacked->args; \
    glTexCoord1xvOES(args->coords);; \
} while(0)
void glTexCoord1xvOES(glTexCoord1xvOES_ARG_EXPAND);
typedef void (*glTexCoord1xvOES_PTR)(glTexCoord1xvOES_ARG_EXPAND);
#define glTexCoord2bOES_INDEX 1995
#define glTexCoord2bOES_RETURN void
#define glTexCoord2bOES_ARG_NAMES s, t
#define glTexCoord2bOES_ARG_EXPAND GLbyte s, GLbyte t
#define glTexCoord2bOES_PACKED PACKED_glTexCoord2bOES
#define glTexCoord2bOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexCoord2bOES_NOT_VOID_WRAP(...) {}
#define pack_glTexCoord2bOES(_s, _t) ({ \
    glTexCoord2bOES_PACKED *packed_data = malloc(sizeof(glTexCoord2bOES_PACKED)); \
    packed_data->index = glTexCoord2bOES_INDEX; \
    packed_data->args.s = (GLbyte)_s; \
    packed_data->args.t = (GLbyte)_t; \
    (packed_call_t *)packed_data; \
})
#define call_glTexCoord2bOES(packed, ret_v) do { \
    PACKED_glTexCoord2bOES *unpacked = (PACKED_glTexCoord2bOES *)packed; \
    ARGS_glTexCoord2bOES *args = (ARGS_glTexCoord2bOES *)&unpacked->args; \
    glTexCoord2bOES(args->s, args->t);; \
} while(0)
void glTexCoord2bOES(glTexCoord2bOES_ARG_EXPAND);
typedef void (*glTexCoord2bOES_PTR)(glTexCoord2bOES_ARG_EXPAND);
#define glTexCoord2bvOES_INDEX 1996
#define glTexCoord2bvOES_RETURN void
#define glTexCoord2bvOES_ARG_NAMES coords
#define glTexCoord2bvOES_ARG_EXPAND const GLbyte * coords
#define glTexCoord2bvOES_PACKED PACKED_glTexCoord2bvOES
#define glTexCoord2bvOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexCoord2bvOES_NOT_VOID_WRAP(...) {}
#define pack_glTexCoord2bvOES(_coords) ({ \
    glTexCoord2bvOES_PACKED *packed_data = malloc(sizeof(glTexCoord2bvOES_PACKED)); \
    packed_data->index = glTexCoord2bvOES_INDEX; \
    packed_data->args.coords = (GLbyte *)_coords; \
    (packed_call_t *)packed_data; \
})
#define call_glTexCoord2bvOES(packed, ret_v) do { \
    PACKED_glTexCoord2bvOES *unpacked = (PACKED_glTexCoord2bvOES *)packed; \
    ARGS_glTexCoord2bvOES *args = (ARGS_glTexCoord2bvOES *)&unpacked->args; \
    glTexCoord2bvOES(args->coords);; \
} while(0)
void glTexCoord2bvOES(glTexCoord2bvOES_ARG_EXPAND);
typedef void (*glTexCoord2bvOES_PTR)(glTexCoord2bvOES_ARG_EXPAND);
#define glTexCoord2d_INDEX 1997
#define glTexCoord2d_RETURN void
#define glTexCoord2d_ARG_NAMES s, t
#define glTexCoord2d_ARG_EXPAND GLdouble s, GLdouble t
#define glTexCoord2d_PACKED PACKED_glTexCoord2d
#define glTexCoord2d_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexCoord2d_NOT_VOID_WRAP(...) {}
#define pack_glTexCoord2d(_s, _t) ({ \
    glTexCoord2d_PACKED *packed_data = malloc(sizeof(glTexCoord2d_PACKED)); \
    packed_data->index = glTexCoord2d_INDEX; \
    packed_data->args.s = (GLdouble)_s; \
    packed_data->args.t = (GLdouble)_t; \
    (packed_call_t *)packed_data; \
})
#define call_glTexCoord2d(packed, ret_v) do { \
    PACKED_glTexCoord2d *unpacked = (PACKED_glTexCoord2d *)packed; \
    ARGS_glTexCoord2d *args = (ARGS_glTexCoord2d *)&unpacked->args; \
    glTexCoord2d(args->s, args->t);; \
} while(0)
void glTexCoord2d(glTexCoord2d_ARG_EXPAND);
typedef void (*glTexCoord2d_PTR)(glTexCoord2d_ARG_EXPAND);
#define glTexCoord2dv_INDEX 1998
#define glTexCoord2dv_RETURN void
#define glTexCoord2dv_ARG_NAMES v
#define glTexCoord2dv_ARG_EXPAND const GLdouble * v
#define glTexCoord2dv_PACKED PACKED_glTexCoord2dv
#define glTexCoord2dv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexCoord2dv_NOT_VOID_WRAP(...) {}
#define pack_glTexCoord2dv(_v) ({ \
    glTexCoord2dv_PACKED *packed_data = malloc(sizeof(glTexCoord2dv_PACKED)); \
    packed_data->index = glTexCoord2dv_INDEX; \
    packed_data->args.v = (GLdouble *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glTexCoord2dv(packed, ret_v) do { \
    PACKED_glTexCoord2dv *unpacked = (PACKED_glTexCoord2dv *)packed; \
    ARGS_glTexCoord2dv *args = (ARGS_glTexCoord2dv *)&unpacked->args; \
    glTexCoord2dv(args->v);; \
} while(0)
void glTexCoord2dv(glTexCoord2dv_ARG_EXPAND);
typedef void (*glTexCoord2dv_PTR)(glTexCoord2dv_ARG_EXPAND);
#define glTexCoord2f_INDEX 1999
#define glTexCoord2f_RETURN void
#define glTexCoord2f_ARG_NAMES s, t
#define glTexCoord2f_ARG_EXPAND GLfloat s, GLfloat t
#define glTexCoord2f_PACKED PACKED_glTexCoord2f
#define glTexCoord2f_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexCoord2f_NOT_VOID_WRAP(...) {}
#define pack_glTexCoord2f(_s, _t) ({ \
    glTexCoord2f_PACKED *packed_data = malloc(sizeof(glTexCoord2f_PACKED)); \
    packed_data->index = glTexCoord2f_INDEX; \
    packed_data->args.s = (GLfloat)_s; \
    packed_data->args.t = (GLfloat)_t; \
    (packed_call_t *)packed_data; \
})
#define call_glTexCoord2f(packed, ret_v) do { \
    PACKED_glTexCoord2f *unpacked = (PACKED_glTexCoord2f *)packed; \
    ARGS_glTexCoord2f *args = (ARGS_glTexCoord2f *)&unpacked->args; \
    glTexCoord2f(args->s, args->t);; \
} while(0)
void glTexCoord2f(glTexCoord2f_ARG_EXPAND);
typedef void (*glTexCoord2f_PTR)(glTexCoord2f_ARG_EXPAND);
#define glTexCoord2fColor3fVertex3fSUN_INDEX 2000
#define glTexCoord2fColor3fVertex3fSUN_RETURN void
#define glTexCoord2fColor3fVertex3fSUN_ARG_NAMES s, t, r, g, b, x, y, z
#define glTexCoord2fColor3fVertex3fSUN_ARG_EXPAND GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z
#define glTexCoord2fColor3fVertex3fSUN_PACKED PACKED_glTexCoord2fColor3fVertex3fSUN
#define glTexCoord2fColor3fVertex3fSUN_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexCoord2fColor3fVertex3fSUN_NOT_VOID_WRAP(...) {}
#define pack_glTexCoord2fColor3fVertex3fSUN(_s, _t, _r, _g, _b, _x, _y, _z) ({ \
    glTexCoord2fColor3fVertex3fSUN_PACKED *packed_data = malloc(sizeof(glTexCoord2fColor3fVertex3fSUN_PACKED)); \
    packed_data->index = glTexCoord2fColor3fVertex3fSUN_INDEX; \
    packed_data->args.s = (GLfloat)_s; \
    packed_data->args.t = (GLfloat)_t; \
    packed_data->args.r = (GLfloat)_r; \
    packed_data->args.g = (GLfloat)_g; \
    packed_data->args.b = (GLfloat)_b; \
    packed_data->args.x = (GLfloat)_x; \
    packed_data->args.y = (GLfloat)_y; \
    packed_data->args.z = (GLfloat)_z; \
    (packed_call_t *)packed_data; \
})
#define call_glTexCoord2fColor3fVertex3fSUN(packed, ret_v) do { \
    PACKED_glTexCoord2fColor3fVertex3fSUN *unpacked = (PACKED_glTexCoord2fColor3fVertex3fSUN *)packed; \
    ARGS_glTexCoord2fColor3fVertex3fSUN *args = (ARGS_glTexCoord2fColor3fVertex3fSUN *)&unpacked->args; \
    glTexCoord2fColor3fVertex3fSUN(args->s, args->t, args->r, args->g, args->b, args->x, args->y, args->z);; \
} while(0)
void glTexCoord2fColor3fVertex3fSUN(glTexCoord2fColor3fVertex3fSUN_ARG_EXPAND);
typedef void (*glTexCoord2fColor3fVertex3fSUN_PTR)(glTexCoord2fColor3fVertex3fSUN_ARG_EXPAND);
#define glTexCoord2fColor3fVertex3fvSUN_INDEX 2001
#define glTexCoord2fColor3fVertex3fvSUN_RETURN void
#define glTexCoord2fColor3fVertex3fvSUN_ARG_NAMES tc, c, v
#define glTexCoord2fColor3fVertex3fvSUN_ARG_EXPAND const GLfloat * tc, const GLfloat * c, const GLfloat * v
#define glTexCoord2fColor3fVertex3fvSUN_PACKED PACKED_glTexCoord2fColor3fVertex3fvSUN
#define glTexCoord2fColor3fVertex3fvSUN_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexCoord2fColor3fVertex3fvSUN_NOT_VOID_WRAP(...) {}
#define pack_glTexCoord2fColor3fVertex3fvSUN(_tc, _c, _v) ({ \
    glTexCoord2fColor3fVertex3fvSUN_PACKED *packed_data = malloc(sizeof(glTexCoord2fColor3fVertex3fvSUN_PACKED)); \
    packed_data->index = glTexCoord2fColor3fVertex3fvSUN_INDEX; \
    packed_data->args.tc = (GLfloat *)_tc; \
    packed_data->args.c = (GLfloat *)_c; \
    packed_data->args.v = (GLfloat *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glTexCoord2fColor3fVertex3fvSUN(packed, ret_v) do { \
    PACKED_glTexCoord2fColor3fVertex3fvSUN *unpacked = (PACKED_glTexCoord2fColor3fVertex3fvSUN *)packed; \
    ARGS_glTexCoord2fColor3fVertex3fvSUN *args = (ARGS_glTexCoord2fColor3fVertex3fvSUN *)&unpacked->args; \
    glTexCoord2fColor3fVertex3fvSUN(args->tc, args->c, args->v);; \
} while(0)
void glTexCoord2fColor3fVertex3fvSUN(glTexCoord2fColor3fVertex3fvSUN_ARG_EXPAND);
typedef void (*glTexCoord2fColor3fVertex3fvSUN_PTR)(glTexCoord2fColor3fVertex3fvSUN_ARG_EXPAND);
#define glTexCoord2fColor4fNormal3fVertex3fSUN_INDEX 2002
#define glTexCoord2fColor4fNormal3fVertex3fSUN_RETURN void
#define glTexCoord2fColor4fNormal3fVertex3fSUN_ARG_NAMES s, t, r, g, b, a, nx, ny, nz, x, y, z
#define glTexCoord2fColor4fNormal3fVertex3fSUN_ARG_EXPAND GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z
#define glTexCoord2fColor4fNormal3fVertex3fSUN_PACKED PACKED_glTexCoord2fColor4fNormal3fVertex3fSUN
#define glTexCoord2fColor4fNormal3fVertex3fSUN_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexCoord2fColor4fNormal3fVertex3fSUN_NOT_VOID_WRAP(...) {}
#define pack_glTexCoord2fColor4fNormal3fVertex3fSUN(_s, _t, _r, _g, _b, _a, _nx, _ny, _nz, _x, _y, _z) ({ \
    glTexCoord2fColor4fNormal3fVertex3fSUN_PACKED *packed_data = malloc(sizeof(glTexCoord2fColor4fNormal3fVertex3fSUN_PACKED)); \
    packed_data->index = glTexCoord2fColor4fNormal3fVertex3fSUN_INDEX; \
    packed_data->args.s = (GLfloat)_s; \
    packed_data->args.t = (GLfloat)_t; \
    packed_data->args.r = (GLfloat)_r; \
    packed_data->args.g = (GLfloat)_g; \
    packed_data->args.b = (GLfloat)_b; \
    packed_data->args.a = (GLfloat)_a; \
    packed_data->args.nx = (GLfloat)_nx; \
    packed_data->args.ny = (GLfloat)_ny; \
    packed_data->args.nz = (GLfloat)_nz; \
    packed_data->args.x = (GLfloat)_x; \
    packed_data->args.y = (GLfloat)_y; \
    packed_data->args.z = (GLfloat)_z; \
    (packed_call_t *)packed_data; \
})
#define call_glTexCoord2fColor4fNormal3fVertex3fSUN(packed, ret_v) do { \
    PACKED_glTexCoord2fColor4fNormal3fVertex3fSUN *unpacked = (PACKED_glTexCoord2fColor4fNormal3fVertex3fSUN *)packed; \
    ARGS_glTexCoord2fColor4fNormal3fVertex3fSUN *args = (ARGS_glTexCoord2fColor4fNormal3fVertex3fSUN *)&unpacked->args; \
    glTexCoord2fColor4fNormal3fVertex3fSUN(args->s, args->t, args->r, args->g, args->b, args->a, args->nx, args->ny, args->nz, args->x, args->y, args->z);; \
} while(0)
void glTexCoord2fColor4fNormal3fVertex3fSUN(glTexCoord2fColor4fNormal3fVertex3fSUN_ARG_EXPAND);
typedef void (*glTexCoord2fColor4fNormal3fVertex3fSUN_PTR)(glTexCoord2fColor4fNormal3fVertex3fSUN_ARG_EXPAND);
#define glTexCoord2fColor4fNormal3fVertex3fvSUN_INDEX 2003
#define glTexCoord2fColor4fNormal3fVertex3fvSUN_RETURN void
#define glTexCoord2fColor4fNormal3fVertex3fvSUN_ARG_NAMES tc, c, n, v
#define glTexCoord2fColor4fNormal3fVertex3fvSUN_ARG_EXPAND const GLfloat * tc, const GLfloat * c, const GLfloat * n, const GLfloat * v
#define glTexCoord2fColor4fNormal3fVertex3fvSUN_PACKED PACKED_glTexCoord2fColor4fNormal3fVertex3fvSUN
#define glTexCoord2fColor4fNormal3fVertex3fvSUN_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexCoord2fColor4fNormal3fVertex3fvSUN_NOT_VOID_WRAP(...) {}
#define pack_glTexCoord2fColor4fNormal3fVertex3fvSUN(_tc, _c, _n, _v) ({ \
    glTexCoord2fColor4fNormal3fVertex3fvSUN_PACKED *packed_data = malloc(sizeof(glTexCoord2fColor4fNormal3fVertex3fvSUN_PACKED)); \
    packed_data->index = glTexCoord2fColor4fNormal3fVertex3fvSUN_INDEX; \
    packed_data->args.tc = (GLfloat *)_tc; \
    packed_data->args.c = (GLfloat *)_c; \
    packed_data->args.n = (GLfloat *)_n; \
    packed_data->args.v = (GLfloat *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glTexCoord2fColor4fNormal3fVertex3fvSUN(packed, ret_v) do { \
    PACKED_glTexCoord2fColor4fNormal3fVertex3fvSUN *unpacked = (PACKED_glTexCoord2fColor4fNormal3fVertex3fvSUN *)packed; \
    ARGS_glTexCoord2fColor4fNormal3fVertex3fvSUN *args = (ARGS_glTexCoord2fColor4fNormal3fVertex3fvSUN *)&unpacked->args; \
    glTexCoord2fColor4fNormal3fVertex3fvSUN(args->tc, args->c, args->n, args->v);; \
} while(0)
void glTexCoord2fColor4fNormal3fVertex3fvSUN(glTexCoord2fColor4fNormal3fVertex3fvSUN_ARG_EXPAND);
typedef void (*glTexCoord2fColor4fNormal3fVertex3fvSUN_PTR)(glTexCoord2fColor4fNormal3fVertex3fvSUN_ARG_EXPAND);
#define glTexCoord2fColor4ubVertex3fSUN_INDEX 2004
#define glTexCoord2fColor4ubVertex3fSUN_RETURN void
#define glTexCoord2fColor4ubVertex3fSUN_ARG_NAMES s, t, r, g, b, a, x, y, z
#define glTexCoord2fColor4ubVertex3fSUN_ARG_EXPAND GLfloat s, GLfloat t, GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z
#define glTexCoord2fColor4ubVertex3fSUN_PACKED PACKED_glTexCoord2fColor4ubVertex3fSUN
#define glTexCoord2fColor4ubVertex3fSUN_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexCoord2fColor4ubVertex3fSUN_NOT_VOID_WRAP(...) {}
#define pack_glTexCoord2fColor4ubVertex3fSUN(_s, _t, _r, _g, _b, _a, _x, _y, _z) ({ \
    glTexCoord2fColor4ubVertex3fSUN_PACKED *packed_data = malloc(sizeof(glTexCoord2fColor4ubVertex3fSUN_PACKED)); \
    packed_data->index = glTexCoord2fColor4ubVertex3fSUN_INDEX; \
    packed_data->args.s = (GLfloat)_s; \
    packed_data->args.t = (GLfloat)_t; \
    packed_data->args.r = (GLubyte)_r; \
    packed_data->args.g = (GLubyte)_g; \
    packed_data->args.b = (GLubyte)_b; \
    packed_data->args.a = (GLubyte)_a; \
    packed_data->args.x = (GLfloat)_x; \
    packed_data->args.y = (GLfloat)_y; \
    packed_data->args.z = (GLfloat)_z; \
    (packed_call_t *)packed_data; \
})
#define call_glTexCoord2fColor4ubVertex3fSUN(packed, ret_v) do { \
    PACKED_glTexCoord2fColor4ubVertex3fSUN *unpacked = (PACKED_glTexCoord2fColor4ubVertex3fSUN *)packed; \
    ARGS_glTexCoord2fColor4ubVertex3fSUN *args = (ARGS_glTexCoord2fColor4ubVertex3fSUN *)&unpacked->args; \
    glTexCoord2fColor4ubVertex3fSUN(args->s, args->t, args->r, args->g, args->b, args->a, args->x, args->y, args->z);; \
} while(0)
void glTexCoord2fColor4ubVertex3fSUN(glTexCoord2fColor4ubVertex3fSUN_ARG_EXPAND);
typedef void (*glTexCoord2fColor4ubVertex3fSUN_PTR)(glTexCoord2fColor4ubVertex3fSUN_ARG_EXPAND);
#define glTexCoord2fColor4ubVertex3fvSUN_INDEX 2005
#define glTexCoord2fColor4ubVertex3fvSUN_RETURN void
#define glTexCoord2fColor4ubVertex3fvSUN_ARG_NAMES tc, c, v
#define glTexCoord2fColor4ubVertex3fvSUN_ARG_EXPAND const GLfloat * tc, const GLubyte * c, const GLfloat * v
#define glTexCoord2fColor4ubVertex3fvSUN_PACKED PACKED_glTexCoord2fColor4ubVertex3fvSUN
#define glTexCoord2fColor4ubVertex3fvSUN_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexCoord2fColor4ubVertex3fvSUN_NOT_VOID_WRAP(...) {}
#define pack_glTexCoord2fColor4ubVertex3fvSUN(_tc, _c, _v) ({ \
    glTexCoord2fColor4ubVertex3fvSUN_PACKED *packed_data = malloc(sizeof(glTexCoord2fColor4ubVertex3fvSUN_PACKED)); \
    packed_data->index = glTexCoord2fColor4ubVertex3fvSUN_INDEX; \
    packed_data->args.tc = (GLfloat *)_tc; \
    packed_data->args.c = (GLubyte *)_c; \
    packed_data->args.v = (GLfloat *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glTexCoord2fColor4ubVertex3fvSUN(packed, ret_v) do { \
    PACKED_glTexCoord2fColor4ubVertex3fvSUN *unpacked = (PACKED_glTexCoord2fColor4ubVertex3fvSUN *)packed; \
    ARGS_glTexCoord2fColor4ubVertex3fvSUN *args = (ARGS_glTexCoord2fColor4ubVertex3fvSUN *)&unpacked->args; \
    glTexCoord2fColor4ubVertex3fvSUN(args->tc, args->c, args->v);; \
} while(0)
void glTexCoord2fColor4ubVertex3fvSUN(glTexCoord2fColor4ubVertex3fvSUN_ARG_EXPAND);
typedef void (*glTexCoord2fColor4ubVertex3fvSUN_PTR)(glTexCoord2fColor4ubVertex3fvSUN_ARG_EXPAND);
#define glTexCoord2fNormal3fVertex3fSUN_INDEX 2006
#define glTexCoord2fNormal3fVertex3fSUN_RETURN void
#define glTexCoord2fNormal3fVertex3fSUN_ARG_NAMES s, t, nx, ny, nz, x, y, z
#define glTexCoord2fNormal3fVertex3fSUN_ARG_EXPAND GLfloat s, GLfloat t, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z
#define glTexCoord2fNormal3fVertex3fSUN_PACKED PACKED_glTexCoord2fNormal3fVertex3fSUN
#define glTexCoord2fNormal3fVertex3fSUN_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexCoord2fNormal3fVertex3fSUN_NOT_VOID_WRAP(...) {}
#define pack_glTexCoord2fNormal3fVertex3fSUN(_s, _t, _nx, _ny, _nz, _x, _y, _z) ({ \
    glTexCoord2fNormal3fVertex3fSUN_PACKED *packed_data = malloc(sizeof(glTexCoord2fNormal3fVertex3fSUN_PACKED)); \
    packed_data->index = glTexCoord2fNormal3fVertex3fSUN_INDEX; \
    packed_data->args.s = (GLfloat)_s; \
    packed_data->args.t = (GLfloat)_t; \
    packed_data->args.nx = (GLfloat)_nx; \
    packed_data->args.ny = (GLfloat)_ny; \
    packed_data->args.nz = (GLfloat)_nz; \
    packed_data->args.x = (GLfloat)_x; \
    packed_data->args.y = (GLfloat)_y; \
    packed_data->args.z = (GLfloat)_z; \
    (packed_call_t *)packed_data; \
})
#define call_glTexCoord2fNormal3fVertex3fSUN(packed, ret_v) do { \
    PACKED_glTexCoord2fNormal3fVertex3fSUN *unpacked = (PACKED_glTexCoord2fNormal3fVertex3fSUN *)packed; \
    ARGS_glTexCoord2fNormal3fVertex3fSUN *args = (ARGS_glTexCoord2fNormal3fVertex3fSUN *)&unpacked->args; \
    glTexCoord2fNormal3fVertex3fSUN(args->s, args->t, args->nx, args->ny, args->nz, args->x, args->y, args->z);; \
} while(0)
void glTexCoord2fNormal3fVertex3fSUN(glTexCoord2fNormal3fVertex3fSUN_ARG_EXPAND);
typedef void (*glTexCoord2fNormal3fVertex3fSUN_PTR)(glTexCoord2fNormal3fVertex3fSUN_ARG_EXPAND);
#define glTexCoord2fNormal3fVertex3fvSUN_INDEX 2007
#define glTexCoord2fNormal3fVertex3fvSUN_RETURN void
#define glTexCoord2fNormal3fVertex3fvSUN_ARG_NAMES tc, n, v
#define glTexCoord2fNormal3fVertex3fvSUN_ARG_EXPAND const GLfloat * tc, const GLfloat * n, const GLfloat * v
#define glTexCoord2fNormal3fVertex3fvSUN_PACKED PACKED_glTexCoord2fNormal3fVertex3fvSUN
#define glTexCoord2fNormal3fVertex3fvSUN_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexCoord2fNormal3fVertex3fvSUN_NOT_VOID_WRAP(...) {}
#define pack_glTexCoord2fNormal3fVertex3fvSUN(_tc, _n, _v) ({ \
    glTexCoord2fNormal3fVertex3fvSUN_PACKED *packed_data = malloc(sizeof(glTexCoord2fNormal3fVertex3fvSUN_PACKED)); \
    packed_data->index = glTexCoord2fNormal3fVertex3fvSUN_INDEX; \
    packed_data->args.tc = (GLfloat *)_tc; \
    packed_data->args.n = (GLfloat *)_n; \
    packed_data->args.v = (GLfloat *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glTexCoord2fNormal3fVertex3fvSUN(packed, ret_v) do { \
    PACKED_glTexCoord2fNormal3fVertex3fvSUN *unpacked = (PACKED_glTexCoord2fNormal3fVertex3fvSUN *)packed; \
    ARGS_glTexCoord2fNormal3fVertex3fvSUN *args = (ARGS_glTexCoord2fNormal3fVertex3fvSUN *)&unpacked->args; \
    glTexCoord2fNormal3fVertex3fvSUN(args->tc, args->n, args->v);; \
} while(0)
void glTexCoord2fNormal3fVertex3fvSUN(glTexCoord2fNormal3fVertex3fvSUN_ARG_EXPAND);
typedef void (*glTexCoord2fNormal3fVertex3fvSUN_PTR)(glTexCoord2fNormal3fVertex3fvSUN_ARG_EXPAND);
#define glTexCoord2fVertex3fSUN_INDEX 2008
#define glTexCoord2fVertex3fSUN_RETURN void
#define glTexCoord2fVertex3fSUN_ARG_NAMES s, t, x, y, z
#define glTexCoord2fVertex3fSUN_ARG_EXPAND GLfloat s, GLfloat t, GLfloat x, GLfloat y, GLfloat z
#define glTexCoord2fVertex3fSUN_PACKED PACKED_glTexCoord2fVertex3fSUN
#define glTexCoord2fVertex3fSUN_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexCoord2fVertex3fSUN_NOT_VOID_WRAP(...) {}
#define pack_glTexCoord2fVertex3fSUN(_s, _t, _x, _y, _z) ({ \
    glTexCoord2fVertex3fSUN_PACKED *packed_data = malloc(sizeof(glTexCoord2fVertex3fSUN_PACKED)); \
    packed_data->index = glTexCoord2fVertex3fSUN_INDEX; \
    packed_data->args.s = (GLfloat)_s; \
    packed_data->args.t = (GLfloat)_t; \
    packed_data->args.x = (GLfloat)_x; \
    packed_data->args.y = (GLfloat)_y; \
    packed_data->args.z = (GLfloat)_z; \
    (packed_call_t *)packed_data; \
})
#define call_glTexCoord2fVertex3fSUN(packed, ret_v) do { \
    PACKED_glTexCoord2fVertex3fSUN *unpacked = (PACKED_glTexCoord2fVertex3fSUN *)packed; \
    ARGS_glTexCoord2fVertex3fSUN *args = (ARGS_glTexCoord2fVertex3fSUN *)&unpacked->args; \
    glTexCoord2fVertex3fSUN(args->s, args->t, args->x, args->y, args->z);; \
} while(0)
void glTexCoord2fVertex3fSUN(glTexCoord2fVertex3fSUN_ARG_EXPAND);
typedef void (*glTexCoord2fVertex3fSUN_PTR)(glTexCoord2fVertex3fSUN_ARG_EXPAND);
#define glTexCoord2fVertex3fvSUN_INDEX 2009
#define glTexCoord2fVertex3fvSUN_RETURN void
#define glTexCoord2fVertex3fvSUN_ARG_NAMES tc, v
#define glTexCoord2fVertex3fvSUN_ARG_EXPAND const GLfloat * tc, const GLfloat * v
#define glTexCoord2fVertex3fvSUN_PACKED PACKED_glTexCoord2fVertex3fvSUN
#define glTexCoord2fVertex3fvSUN_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexCoord2fVertex3fvSUN_NOT_VOID_WRAP(...) {}
#define pack_glTexCoord2fVertex3fvSUN(_tc, _v) ({ \
    glTexCoord2fVertex3fvSUN_PACKED *packed_data = malloc(sizeof(glTexCoord2fVertex3fvSUN_PACKED)); \
    packed_data->index = glTexCoord2fVertex3fvSUN_INDEX; \
    packed_data->args.tc = (GLfloat *)_tc; \
    packed_data->args.v = (GLfloat *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glTexCoord2fVertex3fvSUN(packed, ret_v) do { \
    PACKED_glTexCoord2fVertex3fvSUN *unpacked = (PACKED_glTexCoord2fVertex3fvSUN *)packed; \
    ARGS_glTexCoord2fVertex3fvSUN *args = (ARGS_glTexCoord2fVertex3fvSUN *)&unpacked->args; \
    glTexCoord2fVertex3fvSUN(args->tc, args->v);; \
} while(0)
void glTexCoord2fVertex3fvSUN(glTexCoord2fVertex3fvSUN_ARG_EXPAND);
typedef void (*glTexCoord2fVertex3fvSUN_PTR)(glTexCoord2fVertex3fvSUN_ARG_EXPAND);
#define glTexCoord2fv_INDEX 2010
#define glTexCoord2fv_RETURN void
#define glTexCoord2fv_ARG_NAMES v
#define glTexCoord2fv_ARG_EXPAND const GLfloat * v
#define glTexCoord2fv_PACKED PACKED_glTexCoord2fv
#define glTexCoord2fv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexCoord2fv_NOT_VOID_WRAP(...) {}
#define pack_glTexCoord2fv(_v) ({ \
    glTexCoord2fv_PACKED *packed_data = malloc(sizeof(glTexCoord2fv_PACKED)); \
    packed_data->index = glTexCoord2fv_INDEX; \
    packed_data->args.v = (GLfloat *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glTexCoord2fv(packed, ret_v) do { \
    PACKED_glTexCoord2fv *unpacked = (PACKED_glTexCoord2fv *)packed; \
    ARGS_glTexCoord2fv *args = (ARGS_glTexCoord2fv *)&unpacked->args; \
    glTexCoord2fv(args->v);; \
} while(0)
void glTexCoord2fv(glTexCoord2fv_ARG_EXPAND);
typedef void (*glTexCoord2fv_PTR)(glTexCoord2fv_ARG_EXPAND);
#define glTexCoord2hNV_INDEX 2011
#define glTexCoord2hNV_RETURN void
#define glTexCoord2hNV_ARG_NAMES s, t
#define glTexCoord2hNV_ARG_EXPAND GLhalfNV s, GLhalfNV t
#define glTexCoord2hNV_PACKED PACKED_glTexCoord2hNV
#define glTexCoord2hNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexCoord2hNV_NOT_VOID_WRAP(...) {}
#define pack_glTexCoord2hNV(_s, _t) ({ \
    glTexCoord2hNV_PACKED *packed_data = malloc(sizeof(glTexCoord2hNV_PACKED)); \
    packed_data->index = glTexCoord2hNV_INDEX; \
    packed_data->args.s = (GLhalfNV)_s; \
    packed_data->args.t = (GLhalfNV)_t; \
    (packed_call_t *)packed_data; \
})
#define call_glTexCoord2hNV(packed, ret_v) do { \
    PACKED_glTexCoord2hNV *unpacked = (PACKED_glTexCoord2hNV *)packed; \
    ARGS_glTexCoord2hNV *args = (ARGS_glTexCoord2hNV *)&unpacked->args; \
    glTexCoord2hNV(args->s, args->t);; \
} while(0)
void glTexCoord2hNV(glTexCoord2hNV_ARG_EXPAND);
typedef void (*glTexCoord2hNV_PTR)(glTexCoord2hNV_ARG_EXPAND);
#define glTexCoord2hvNV_INDEX 2012
#define glTexCoord2hvNV_RETURN void
#define glTexCoord2hvNV_ARG_NAMES v
#define glTexCoord2hvNV_ARG_EXPAND const GLhalfNV * v
#define glTexCoord2hvNV_PACKED PACKED_glTexCoord2hvNV
#define glTexCoord2hvNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexCoord2hvNV_NOT_VOID_WRAP(...) {}
#define pack_glTexCoord2hvNV(_v) ({ \
    glTexCoord2hvNV_PACKED *packed_data = malloc(sizeof(glTexCoord2hvNV_PACKED)); \
    packed_data->index = glTexCoord2hvNV_INDEX; \
    packed_data->args.v = (GLhalfNV *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glTexCoord2hvNV(packed, ret_v) do { \
    PACKED_glTexCoord2hvNV *unpacked = (PACKED_glTexCoord2hvNV *)packed; \
    ARGS_glTexCoord2hvNV *args = (ARGS_glTexCoord2hvNV *)&unpacked->args; \
    glTexCoord2hvNV(args->v);; \
} while(0)
void glTexCoord2hvNV(glTexCoord2hvNV_ARG_EXPAND);
typedef void (*glTexCoord2hvNV_PTR)(glTexCoord2hvNV_ARG_EXPAND);
#define glTexCoord2i_INDEX 2013
#define glTexCoord2i_RETURN void
#define glTexCoord2i_ARG_NAMES s, t
#define glTexCoord2i_ARG_EXPAND GLint s, GLint t
#define glTexCoord2i_PACKED PACKED_glTexCoord2i
#define glTexCoord2i_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexCoord2i_NOT_VOID_WRAP(...) {}
#define pack_glTexCoord2i(_s, _t) ({ \
    glTexCoord2i_PACKED *packed_data = malloc(sizeof(glTexCoord2i_PACKED)); \
    packed_data->index = glTexCoord2i_INDEX; \
    packed_data->args.s = (GLint)_s; \
    packed_data->args.t = (GLint)_t; \
    (packed_call_t *)packed_data; \
})
#define call_glTexCoord2i(packed, ret_v) do { \
    PACKED_glTexCoord2i *unpacked = (PACKED_glTexCoord2i *)packed; \
    ARGS_glTexCoord2i *args = (ARGS_glTexCoord2i *)&unpacked->args; \
    glTexCoord2i(args->s, args->t);; \
} while(0)
void glTexCoord2i(glTexCoord2i_ARG_EXPAND);
typedef void (*glTexCoord2i_PTR)(glTexCoord2i_ARG_EXPAND);
#define glTexCoord2iv_INDEX 2014
#define glTexCoord2iv_RETURN void
#define glTexCoord2iv_ARG_NAMES v
#define glTexCoord2iv_ARG_EXPAND const GLint * v
#define glTexCoord2iv_PACKED PACKED_glTexCoord2iv
#define glTexCoord2iv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexCoord2iv_NOT_VOID_WRAP(...) {}
#define pack_glTexCoord2iv(_v) ({ \
    glTexCoord2iv_PACKED *packed_data = malloc(sizeof(glTexCoord2iv_PACKED)); \
    packed_data->index = glTexCoord2iv_INDEX; \
    packed_data->args.v = (GLint *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glTexCoord2iv(packed, ret_v) do { \
    PACKED_glTexCoord2iv *unpacked = (PACKED_glTexCoord2iv *)packed; \
    ARGS_glTexCoord2iv *args = (ARGS_glTexCoord2iv *)&unpacked->args; \
    glTexCoord2iv(args->v);; \
} while(0)
void glTexCoord2iv(glTexCoord2iv_ARG_EXPAND);
typedef void (*glTexCoord2iv_PTR)(glTexCoord2iv_ARG_EXPAND);
#define glTexCoord2s_INDEX 2015
#define glTexCoord2s_RETURN void
#define glTexCoord2s_ARG_NAMES s, t
#define glTexCoord2s_ARG_EXPAND GLshort s, GLshort t
#define glTexCoord2s_PACKED PACKED_glTexCoord2s
#define glTexCoord2s_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexCoord2s_NOT_VOID_WRAP(...) {}
#define pack_glTexCoord2s(_s, _t) ({ \
    glTexCoord2s_PACKED *packed_data = malloc(sizeof(glTexCoord2s_PACKED)); \
    packed_data->index = glTexCoord2s_INDEX; \
    packed_data->args.s = (GLshort)_s; \
    packed_data->args.t = (GLshort)_t; \
    (packed_call_t *)packed_data; \
})
#define call_glTexCoord2s(packed, ret_v) do { \
    PACKED_glTexCoord2s *unpacked = (PACKED_glTexCoord2s *)packed; \
    ARGS_glTexCoord2s *args = (ARGS_glTexCoord2s *)&unpacked->args; \
    glTexCoord2s(args->s, args->t);; \
} while(0)
void glTexCoord2s(glTexCoord2s_ARG_EXPAND);
typedef void (*glTexCoord2s_PTR)(glTexCoord2s_ARG_EXPAND);
#define glTexCoord2sv_INDEX 2016
#define glTexCoord2sv_RETURN void
#define glTexCoord2sv_ARG_NAMES v
#define glTexCoord2sv_ARG_EXPAND const GLshort * v
#define glTexCoord2sv_PACKED PACKED_glTexCoord2sv
#define glTexCoord2sv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexCoord2sv_NOT_VOID_WRAP(...) {}
#define pack_glTexCoord2sv(_v) ({ \
    glTexCoord2sv_PACKED *packed_data = malloc(sizeof(glTexCoord2sv_PACKED)); \
    packed_data->index = glTexCoord2sv_INDEX; \
    packed_data->args.v = (GLshort *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glTexCoord2sv(packed, ret_v) do { \
    PACKED_glTexCoord2sv *unpacked = (PACKED_glTexCoord2sv *)packed; \
    ARGS_glTexCoord2sv *args = (ARGS_glTexCoord2sv *)&unpacked->args; \
    glTexCoord2sv(args->v);; \
} while(0)
void glTexCoord2sv(glTexCoord2sv_ARG_EXPAND);
typedef void (*glTexCoord2sv_PTR)(glTexCoord2sv_ARG_EXPAND);
#define glTexCoord2xOES_INDEX 2017
#define glTexCoord2xOES_RETURN void
#define glTexCoord2xOES_ARG_NAMES s, t
#define glTexCoord2xOES_ARG_EXPAND GLfixed s, GLfixed t
#define glTexCoord2xOES_PACKED PACKED_glTexCoord2xOES
#define glTexCoord2xOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexCoord2xOES_NOT_VOID_WRAP(...) {}
#define pack_glTexCoord2xOES(_s, _t) ({ \
    glTexCoord2xOES_PACKED *packed_data = malloc(sizeof(glTexCoord2xOES_PACKED)); \
    packed_data->index = glTexCoord2xOES_INDEX; \
    packed_data->args.s = (GLfixed)_s; \
    packed_data->args.t = (GLfixed)_t; \
    (packed_call_t *)packed_data; \
})
#define call_glTexCoord2xOES(packed, ret_v) do { \
    PACKED_glTexCoord2xOES *unpacked = (PACKED_glTexCoord2xOES *)packed; \
    ARGS_glTexCoord2xOES *args = (ARGS_glTexCoord2xOES *)&unpacked->args; \
    glTexCoord2xOES(args->s, args->t);; \
} while(0)
void glTexCoord2xOES(glTexCoord2xOES_ARG_EXPAND);
typedef void (*glTexCoord2xOES_PTR)(glTexCoord2xOES_ARG_EXPAND);
#define glTexCoord2xvOES_INDEX 2018
#define glTexCoord2xvOES_RETURN void
#define glTexCoord2xvOES_ARG_NAMES coords
#define glTexCoord2xvOES_ARG_EXPAND const GLfixed * coords
#define glTexCoord2xvOES_PACKED PACKED_glTexCoord2xvOES
#define glTexCoord2xvOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexCoord2xvOES_NOT_VOID_WRAP(...) {}
#define pack_glTexCoord2xvOES(_coords) ({ \
    glTexCoord2xvOES_PACKED *packed_data = malloc(sizeof(glTexCoord2xvOES_PACKED)); \
    packed_data->index = glTexCoord2xvOES_INDEX; \
    packed_data->args.coords = (GLfixed *)_coords; \
    (packed_call_t *)packed_data; \
})
#define call_glTexCoord2xvOES(packed, ret_v) do { \
    PACKED_glTexCoord2xvOES *unpacked = (PACKED_glTexCoord2xvOES *)packed; \
    ARGS_glTexCoord2xvOES *args = (ARGS_glTexCoord2xvOES *)&unpacked->args; \
    glTexCoord2xvOES(args->coords);; \
} while(0)
void glTexCoord2xvOES(glTexCoord2xvOES_ARG_EXPAND);
typedef void (*glTexCoord2xvOES_PTR)(glTexCoord2xvOES_ARG_EXPAND);
#define glTexCoord3bOES_INDEX 2019
#define glTexCoord3bOES_RETURN void
#define glTexCoord3bOES_ARG_NAMES s, t, r
#define glTexCoord3bOES_ARG_EXPAND GLbyte s, GLbyte t, GLbyte r
#define glTexCoord3bOES_PACKED PACKED_glTexCoord3bOES
#define glTexCoord3bOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexCoord3bOES_NOT_VOID_WRAP(...) {}
#define pack_glTexCoord3bOES(_s, _t, _r) ({ \
    glTexCoord3bOES_PACKED *packed_data = malloc(sizeof(glTexCoord3bOES_PACKED)); \
    packed_data->index = glTexCoord3bOES_INDEX; \
    packed_data->args.s = (GLbyte)_s; \
    packed_data->args.t = (GLbyte)_t; \
    packed_data->args.r = (GLbyte)_r; \
    (packed_call_t *)packed_data; \
})
#define call_glTexCoord3bOES(packed, ret_v) do { \
    PACKED_glTexCoord3bOES *unpacked = (PACKED_glTexCoord3bOES *)packed; \
    ARGS_glTexCoord3bOES *args = (ARGS_glTexCoord3bOES *)&unpacked->args; \
    glTexCoord3bOES(args->s, args->t, args->r);; \
} while(0)
void glTexCoord3bOES(glTexCoord3bOES_ARG_EXPAND);
typedef void (*glTexCoord3bOES_PTR)(glTexCoord3bOES_ARG_EXPAND);
#define glTexCoord3bvOES_INDEX 2020
#define glTexCoord3bvOES_RETURN void
#define glTexCoord3bvOES_ARG_NAMES coords
#define glTexCoord3bvOES_ARG_EXPAND const GLbyte * coords
#define glTexCoord3bvOES_PACKED PACKED_glTexCoord3bvOES
#define glTexCoord3bvOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexCoord3bvOES_NOT_VOID_WRAP(...) {}
#define pack_glTexCoord3bvOES(_coords) ({ \
    glTexCoord3bvOES_PACKED *packed_data = malloc(sizeof(glTexCoord3bvOES_PACKED)); \
    packed_data->index = glTexCoord3bvOES_INDEX; \
    packed_data->args.coords = (GLbyte *)_coords; \
    (packed_call_t *)packed_data; \
})
#define call_glTexCoord3bvOES(packed, ret_v) do { \
    PACKED_glTexCoord3bvOES *unpacked = (PACKED_glTexCoord3bvOES *)packed; \
    ARGS_glTexCoord3bvOES *args = (ARGS_glTexCoord3bvOES *)&unpacked->args; \
    glTexCoord3bvOES(args->coords);; \
} while(0)
void glTexCoord3bvOES(glTexCoord3bvOES_ARG_EXPAND);
typedef void (*glTexCoord3bvOES_PTR)(glTexCoord3bvOES_ARG_EXPAND);
#define glTexCoord3d_INDEX 2021
#define glTexCoord3d_RETURN void
#define glTexCoord3d_ARG_NAMES s, t, r
#define glTexCoord3d_ARG_EXPAND GLdouble s, GLdouble t, GLdouble r
#define glTexCoord3d_PACKED PACKED_glTexCoord3d
#define glTexCoord3d_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexCoord3d_NOT_VOID_WRAP(...) {}
#define pack_glTexCoord3d(_s, _t, _r) ({ \
    glTexCoord3d_PACKED *packed_data = malloc(sizeof(glTexCoord3d_PACKED)); \
    packed_data->index = glTexCoord3d_INDEX; \
    packed_data->args.s = (GLdouble)_s; \
    packed_data->args.t = (GLdouble)_t; \
    packed_data->args.r = (GLdouble)_r; \
    (packed_call_t *)packed_data; \
})
#define call_glTexCoord3d(packed, ret_v) do { \
    PACKED_glTexCoord3d *unpacked = (PACKED_glTexCoord3d *)packed; \
    ARGS_glTexCoord3d *args = (ARGS_glTexCoord3d *)&unpacked->args; \
    glTexCoord3d(args->s, args->t, args->r);; \
} while(0)
void glTexCoord3d(glTexCoord3d_ARG_EXPAND);
typedef void (*glTexCoord3d_PTR)(glTexCoord3d_ARG_EXPAND);
#define glTexCoord3dv_INDEX 2022
#define glTexCoord3dv_RETURN void
#define glTexCoord3dv_ARG_NAMES v
#define glTexCoord3dv_ARG_EXPAND const GLdouble * v
#define glTexCoord3dv_PACKED PACKED_glTexCoord3dv
#define glTexCoord3dv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexCoord3dv_NOT_VOID_WRAP(...) {}
#define pack_glTexCoord3dv(_v) ({ \
    glTexCoord3dv_PACKED *packed_data = malloc(sizeof(glTexCoord3dv_PACKED)); \
    packed_data->index = glTexCoord3dv_INDEX; \
    packed_data->args.v = (GLdouble *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glTexCoord3dv(packed, ret_v) do { \
    PACKED_glTexCoord3dv *unpacked = (PACKED_glTexCoord3dv *)packed; \
    ARGS_glTexCoord3dv *args = (ARGS_glTexCoord3dv *)&unpacked->args; \
    glTexCoord3dv(args->v);; \
} while(0)
void glTexCoord3dv(glTexCoord3dv_ARG_EXPAND);
typedef void (*glTexCoord3dv_PTR)(glTexCoord3dv_ARG_EXPAND);
#define glTexCoord3f_INDEX 2023
#define glTexCoord3f_RETURN void
#define glTexCoord3f_ARG_NAMES s, t, r
#define glTexCoord3f_ARG_EXPAND GLfloat s, GLfloat t, GLfloat r
#define glTexCoord3f_PACKED PACKED_glTexCoord3f
#define glTexCoord3f_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexCoord3f_NOT_VOID_WRAP(...) {}
#define pack_glTexCoord3f(_s, _t, _r) ({ \
    glTexCoord3f_PACKED *packed_data = malloc(sizeof(glTexCoord3f_PACKED)); \
    packed_data->index = glTexCoord3f_INDEX; \
    packed_data->args.s = (GLfloat)_s; \
    packed_data->args.t = (GLfloat)_t; \
    packed_data->args.r = (GLfloat)_r; \
    (packed_call_t *)packed_data; \
})
#define call_glTexCoord3f(packed, ret_v) do { \
    PACKED_glTexCoord3f *unpacked = (PACKED_glTexCoord3f *)packed; \
    ARGS_glTexCoord3f *args = (ARGS_glTexCoord3f *)&unpacked->args; \
    glTexCoord3f(args->s, args->t, args->r);; \
} while(0)
void glTexCoord3f(glTexCoord3f_ARG_EXPAND);
typedef void (*glTexCoord3f_PTR)(glTexCoord3f_ARG_EXPAND);
#define glTexCoord3fv_INDEX 2024
#define glTexCoord3fv_RETURN void
#define glTexCoord3fv_ARG_NAMES v
#define glTexCoord3fv_ARG_EXPAND const GLfloat * v
#define glTexCoord3fv_PACKED PACKED_glTexCoord3fv
#define glTexCoord3fv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexCoord3fv_NOT_VOID_WRAP(...) {}
#define pack_glTexCoord3fv(_v) ({ \
    glTexCoord3fv_PACKED *packed_data = malloc(sizeof(glTexCoord3fv_PACKED)); \
    packed_data->index = glTexCoord3fv_INDEX; \
    packed_data->args.v = (GLfloat *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glTexCoord3fv(packed, ret_v) do { \
    PACKED_glTexCoord3fv *unpacked = (PACKED_glTexCoord3fv *)packed; \
    ARGS_glTexCoord3fv *args = (ARGS_glTexCoord3fv *)&unpacked->args; \
    glTexCoord3fv(args->v);; \
} while(0)
void glTexCoord3fv(glTexCoord3fv_ARG_EXPAND);
typedef void (*glTexCoord3fv_PTR)(glTexCoord3fv_ARG_EXPAND);
#define glTexCoord3hNV_INDEX 2025
#define glTexCoord3hNV_RETURN void
#define glTexCoord3hNV_ARG_NAMES s, t, r
#define glTexCoord3hNV_ARG_EXPAND GLhalfNV s, GLhalfNV t, GLhalfNV r
#define glTexCoord3hNV_PACKED PACKED_glTexCoord3hNV
#define glTexCoord3hNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexCoord3hNV_NOT_VOID_WRAP(...) {}
#define pack_glTexCoord3hNV(_s, _t, _r) ({ \
    glTexCoord3hNV_PACKED *packed_data = malloc(sizeof(glTexCoord3hNV_PACKED)); \
    packed_data->index = glTexCoord3hNV_INDEX; \
    packed_data->args.s = (GLhalfNV)_s; \
    packed_data->args.t = (GLhalfNV)_t; \
    packed_data->args.r = (GLhalfNV)_r; \
    (packed_call_t *)packed_data; \
})
#define call_glTexCoord3hNV(packed, ret_v) do { \
    PACKED_glTexCoord3hNV *unpacked = (PACKED_glTexCoord3hNV *)packed; \
    ARGS_glTexCoord3hNV *args = (ARGS_glTexCoord3hNV *)&unpacked->args; \
    glTexCoord3hNV(args->s, args->t, args->r);; \
} while(0)
void glTexCoord3hNV(glTexCoord3hNV_ARG_EXPAND);
typedef void (*glTexCoord3hNV_PTR)(glTexCoord3hNV_ARG_EXPAND);
#define glTexCoord3hvNV_INDEX 2026
#define glTexCoord3hvNV_RETURN void
#define glTexCoord3hvNV_ARG_NAMES v
#define glTexCoord3hvNV_ARG_EXPAND const GLhalfNV * v
#define glTexCoord3hvNV_PACKED PACKED_glTexCoord3hvNV
#define glTexCoord3hvNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexCoord3hvNV_NOT_VOID_WRAP(...) {}
#define pack_glTexCoord3hvNV(_v) ({ \
    glTexCoord3hvNV_PACKED *packed_data = malloc(sizeof(glTexCoord3hvNV_PACKED)); \
    packed_data->index = glTexCoord3hvNV_INDEX; \
    packed_data->args.v = (GLhalfNV *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glTexCoord3hvNV(packed, ret_v) do { \
    PACKED_glTexCoord3hvNV *unpacked = (PACKED_glTexCoord3hvNV *)packed; \
    ARGS_glTexCoord3hvNV *args = (ARGS_glTexCoord3hvNV *)&unpacked->args; \
    glTexCoord3hvNV(args->v);; \
} while(0)
void glTexCoord3hvNV(glTexCoord3hvNV_ARG_EXPAND);
typedef void (*glTexCoord3hvNV_PTR)(glTexCoord3hvNV_ARG_EXPAND);
#define glTexCoord3i_INDEX 2027
#define glTexCoord3i_RETURN void
#define glTexCoord3i_ARG_NAMES s, t, r
#define glTexCoord3i_ARG_EXPAND GLint s, GLint t, GLint r
#define glTexCoord3i_PACKED PACKED_glTexCoord3i
#define glTexCoord3i_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexCoord3i_NOT_VOID_WRAP(...) {}
#define pack_glTexCoord3i(_s, _t, _r) ({ \
    glTexCoord3i_PACKED *packed_data = malloc(sizeof(glTexCoord3i_PACKED)); \
    packed_data->index = glTexCoord3i_INDEX; \
    packed_data->args.s = (GLint)_s; \
    packed_data->args.t = (GLint)_t; \
    packed_data->args.r = (GLint)_r; \
    (packed_call_t *)packed_data; \
})
#define call_glTexCoord3i(packed, ret_v) do { \
    PACKED_glTexCoord3i *unpacked = (PACKED_glTexCoord3i *)packed; \
    ARGS_glTexCoord3i *args = (ARGS_glTexCoord3i *)&unpacked->args; \
    glTexCoord3i(args->s, args->t, args->r);; \
} while(0)
void glTexCoord3i(glTexCoord3i_ARG_EXPAND);
typedef void (*glTexCoord3i_PTR)(glTexCoord3i_ARG_EXPAND);
#define glTexCoord3iv_INDEX 2028
#define glTexCoord3iv_RETURN void
#define glTexCoord3iv_ARG_NAMES v
#define glTexCoord3iv_ARG_EXPAND const GLint * v
#define glTexCoord3iv_PACKED PACKED_glTexCoord3iv
#define glTexCoord3iv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexCoord3iv_NOT_VOID_WRAP(...) {}
#define pack_glTexCoord3iv(_v) ({ \
    glTexCoord3iv_PACKED *packed_data = malloc(sizeof(glTexCoord3iv_PACKED)); \
    packed_data->index = glTexCoord3iv_INDEX; \
    packed_data->args.v = (GLint *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glTexCoord3iv(packed, ret_v) do { \
    PACKED_glTexCoord3iv *unpacked = (PACKED_glTexCoord3iv *)packed; \
    ARGS_glTexCoord3iv *args = (ARGS_glTexCoord3iv *)&unpacked->args; \
    glTexCoord3iv(args->v);; \
} while(0)
void glTexCoord3iv(glTexCoord3iv_ARG_EXPAND);
typedef void (*glTexCoord3iv_PTR)(glTexCoord3iv_ARG_EXPAND);
#define glTexCoord3s_INDEX 2029
#define glTexCoord3s_RETURN void
#define glTexCoord3s_ARG_NAMES s, t, r
#define glTexCoord3s_ARG_EXPAND GLshort s, GLshort t, GLshort r
#define glTexCoord3s_PACKED PACKED_glTexCoord3s
#define glTexCoord3s_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexCoord3s_NOT_VOID_WRAP(...) {}
#define pack_glTexCoord3s(_s, _t, _r) ({ \
    glTexCoord3s_PACKED *packed_data = malloc(sizeof(glTexCoord3s_PACKED)); \
    packed_data->index = glTexCoord3s_INDEX; \
    packed_data->args.s = (GLshort)_s; \
    packed_data->args.t = (GLshort)_t; \
    packed_data->args.r = (GLshort)_r; \
    (packed_call_t *)packed_data; \
})
#define call_glTexCoord3s(packed, ret_v) do { \
    PACKED_glTexCoord3s *unpacked = (PACKED_glTexCoord3s *)packed; \
    ARGS_glTexCoord3s *args = (ARGS_glTexCoord3s *)&unpacked->args; \
    glTexCoord3s(args->s, args->t, args->r);; \
} while(0)
void glTexCoord3s(glTexCoord3s_ARG_EXPAND);
typedef void (*glTexCoord3s_PTR)(glTexCoord3s_ARG_EXPAND);
#define glTexCoord3sv_INDEX 2030
#define glTexCoord3sv_RETURN void
#define glTexCoord3sv_ARG_NAMES v
#define glTexCoord3sv_ARG_EXPAND const GLshort * v
#define glTexCoord3sv_PACKED PACKED_glTexCoord3sv
#define glTexCoord3sv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexCoord3sv_NOT_VOID_WRAP(...) {}
#define pack_glTexCoord3sv(_v) ({ \
    glTexCoord3sv_PACKED *packed_data = malloc(sizeof(glTexCoord3sv_PACKED)); \
    packed_data->index = glTexCoord3sv_INDEX; \
    packed_data->args.v = (GLshort *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glTexCoord3sv(packed, ret_v) do { \
    PACKED_glTexCoord3sv *unpacked = (PACKED_glTexCoord3sv *)packed; \
    ARGS_glTexCoord3sv *args = (ARGS_glTexCoord3sv *)&unpacked->args; \
    glTexCoord3sv(args->v);; \
} while(0)
void glTexCoord3sv(glTexCoord3sv_ARG_EXPAND);
typedef void (*glTexCoord3sv_PTR)(glTexCoord3sv_ARG_EXPAND);
#define glTexCoord3xOES_INDEX 2031
#define glTexCoord3xOES_RETURN void
#define glTexCoord3xOES_ARG_NAMES s, t, r
#define glTexCoord3xOES_ARG_EXPAND GLfixed s, GLfixed t, GLfixed r
#define glTexCoord3xOES_PACKED PACKED_glTexCoord3xOES
#define glTexCoord3xOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexCoord3xOES_NOT_VOID_WRAP(...) {}
#define pack_glTexCoord3xOES(_s, _t, _r) ({ \
    glTexCoord3xOES_PACKED *packed_data = malloc(sizeof(glTexCoord3xOES_PACKED)); \
    packed_data->index = glTexCoord3xOES_INDEX; \
    packed_data->args.s = (GLfixed)_s; \
    packed_data->args.t = (GLfixed)_t; \
    packed_data->args.r = (GLfixed)_r; \
    (packed_call_t *)packed_data; \
})
#define call_glTexCoord3xOES(packed, ret_v) do { \
    PACKED_glTexCoord3xOES *unpacked = (PACKED_glTexCoord3xOES *)packed; \
    ARGS_glTexCoord3xOES *args = (ARGS_glTexCoord3xOES *)&unpacked->args; \
    glTexCoord3xOES(args->s, args->t, args->r);; \
} while(0)
void glTexCoord3xOES(glTexCoord3xOES_ARG_EXPAND);
typedef void (*glTexCoord3xOES_PTR)(glTexCoord3xOES_ARG_EXPAND);
#define glTexCoord3xvOES_INDEX 2032
#define glTexCoord3xvOES_RETURN void
#define glTexCoord3xvOES_ARG_NAMES coords
#define glTexCoord3xvOES_ARG_EXPAND const GLfixed * coords
#define glTexCoord3xvOES_PACKED PACKED_glTexCoord3xvOES
#define glTexCoord3xvOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexCoord3xvOES_NOT_VOID_WRAP(...) {}
#define pack_glTexCoord3xvOES(_coords) ({ \
    glTexCoord3xvOES_PACKED *packed_data = malloc(sizeof(glTexCoord3xvOES_PACKED)); \
    packed_data->index = glTexCoord3xvOES_INDEX; \
    packed_data->args.coords = (GLfixed *)_coords; \
    (packed_call_t *)packed_data; \
})
#define call_glTexCoord3xvOES(packed, ret_v) do { \
    PACKED_glTexCoord3xvOES *unpacked = (PACKED_glTexCoord3xvOES *)packed; \
    ARGS_glTexCoord3xvOES *args = (ARGS_glTexCoord3xvOES *)&unpacked->args; \
    glTexCoord3xvOES(args->coords);; \
} while(0)
void glTexCoord3xvOES(glTexCoord3xvOES_ARG_EXPAND);
typedef void (*glTexCoord3xvOES_PTR)(glTexCoord3xvOES_ARG_EXPAND);
#define glTexCoord4bOES_INDEX 2033
#define glTexCoord4bOES_RETURN void
#define glTexCoord4bOES_ARG_NAMES s, t, r, q
#define glTexCoord4bOES_ARG_EXPAND GLbyte s, GLbyte t, GLbyte r, GLbyte q
#define glTexCoord4bOES_PACKED PACKED_glTexCoord4bOES
#define glTexCoord4bOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexCoord4bOES_NOT_VOID_WRAP(...) {}
#define pack_glTexCoord4bOES(_s, _t, _r, _q) ({ \
    glTexCoord4bOES_PACKED *packed_data = malloc(sizeof(glTexCoord4bOES_PACKED)); \
    packed_data->index = glTexCoord4bOES_INDEX; \
    packed_data->args.s = (GLbyte)_s; \
    packed_data->args.t = (GLbyte)_t; \
    packed_data->args.r = (GLbyte)_r; \
    packed_data->args.q = (GLbyte)_q; \
    (packed_call_t *)packed_data; \
})
#define call_glTexCoord4bOES(packed, ret_v) do { \
    PACKED_glTexCoord4bOES *unpacked = (PACKED_glTexCoord4bOES *)packed; \
    ARGS_glTexCoord4bOES *args = (ARGS_glTexCoord4bOES *)&unpacked->args; \
    glTexCoord4bOES(args->s, args->t, args->r, args->q);; \
} while(0)
void glTexCoord4bOES(glTexCoord4bOES_ARG_EXPAND);
typedef void (*glTexCoord4bOES_PTR)(glTexCoord4bOES_ARG_EXPAND);
#define glTexCoord4bvOES_INDEX 2034
#define glTexCoord4bvOES_RETURN void
#define glTexCoord4bvOES_ARG_NAMES coords
#define glTexCoord4bvOES_ARG_EXPAND const GLbyte * coords
#define glTexCoord4bvOES_PACKED PACKED_glTexCoord4bvOES
#define glTexCoord4bvOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexCoord4bvOES_NOT_VOID_WRAP(...) {}
#define pack_glTexCoord4bvOES(_coords) ({ \
    glTexCoord4bvOES_PACKED *packed_data = malloc(sizeof(glTexCoord4bvOES_PACKED)); \
    packed_data->index = glTexCoord4bvOES_INDEX; \
    packed_data->args.coords = (GLbyte *)_coords; \
    (packed_call_t *)packed_data; \
})
#define call_glTexCoord4bvOES(packed, ret_v) do { \
    PACKED_glTexCoord4bvOES *unpacked = (PACKED_glTexCoord4bvOES *)packed; \
    ARGS_glTexCoord4bvOES *args = (ARGS_glTexCoord4bvOES *)&unpacked->args; \
    glTexCoord4bvOES(args->coords);; \
} while(0)
void glTexCoord4bvOES(glTexCoord4bvOES_ARG_EXPAND);
typedef void (*glTexCoord4bvOES_PTR)(glTexCoord4bvOES_ARG_EXPAND);
#define glTexCoord4d_INDEX 2035
#define glTexCoord4d_RETURN void
#define glTexCoord4d_ARG_NAMES s, t, r, q
#define glTexCoord4d_ARG_EXPAND GLdouble s, GLdouble t, GLdouble r, GLdouble q
#define glTexCoord4d_PACKED PACKED_glTexCoord4d
#define glTexCoord4d_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexCoord4d_NOT_VOID_WRAP(...) {}
#define pack_glTexCoord4d(_s, _t, _r, _q) ({ \
    glTexCoord4d_PACKED *packed_data = malloc(sizeof(glTexCoord4d_PACKED)); \
    packed_data->index = glTexCoord4d_INDEX; \
    packed_data->args.s = (GLdouble)_s; \
    packed_data->args.t = (GLdouble)_t; \
    packed_data->args.r = (GLdouble)_r; \
    packed_data->args.q = (GLdouble)_q; \
    (packed_call_t *)packed_data; \
})
#define call_glTexCoord4d(packed, ret_v) do { \
    PACKED_glTexCoord4d *unpacked = (PACKED_glTexCoord4d *)packed; \
    ARGS_glTexCoord4d *args = (ARGS_glTexCoord4d *)&unpacked->args; \
    glTexCoord4d(args->s, args->t, args->r, args->q);; \
} while(0)
void glTexCoord4d(glTexCoord4d_ARG_EXPAND);
typedef void (*glTexCoord4d_PTR)(glTexCoord4d_ARG_EXPAND);
#define glTexCoord4dv_INDEX 2036
#define glTexCoord4dv_RETURN void
#define glTexCoord4dv_ARG_NAMES v
#define glTexCoord4dv_ARG_EXPAND const GLdouble * v
#define glTexCoord4dv_PACKED PACKED_glTexCoord4dv
#define glTexCoord4dv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexCoord4dv_NOT_VOID_WRAP(...) {}
#define pack_glTexCoord4dv(_v) ({ \
    glTexCoord4dv_PACKED *packed_data = malloc(sizeof(glTexCoord4dv_PACKED)); \
    packed_data->index = glTexCoord4dv_INDEX; \
    packed_data->args.v = (GLdouble *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glTexCoord4dv(packed, ret_v) do { \
    PACKED_glTexCoord4dv *unpacked = (PACKED_glTexCoord4dv *)packed; \
    ARGS_glTexCoord4dv *args = (ARGS_glTexCoord4dv *)&unpacked->args; \
    glTexCoord4dv(args->v);; \
} while(0)
void glTexCoord4dv(glTexCoord4dv_ARG_EXPAND);
typedef void (*glTexCoord4dv_PTR)(glTexCoord4dv_ARG_EXPAND);
#define glTexCoord4f_INDEX 2037
#define glTexCoord4f_RETURN void
#define glTexCoord4f_ARG_NAMES s, t, r, q
#define glTexCoord4f_ARG_EXPAND GLfloat s, GLfloat t, GLfloat r, GLfloat q
#define glTexCoord4f_PACKED PACKED_glTexCoord4f
#define glTexCoord4f_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexCoord4f_NOT_VOID_WRAP(...) {}
#define pack_glTexCoord4f(_s, _t, _r, _q) ({ \
    glTexCoord4f_PACKED *packed_data = malloc(sizeof(glTexCoord4f_PACKED)); \
    packed_data->index = glTexCoord4f_INDEX; \
    packed_data->args.s = (GLfloat)_s; \
    packed_data->args.t = (GLfloat)_t; \
    packed_data->args.r = (GLfloat)_r; \
    packed_data->args.q = (GLfloat)_q; \
    (packed_call_t *)packed_data; \
})
#define call_glTexCoord4f(packed, ret_v) do { \
    PACKED_glTexCoord4f *unpacked = (PACKED_glTexCoord4f *)packed; \
    ARGS_glTexCoord4f *args = (ARGS_glTexCoord4f *)&unpacked->args; \
    glTexCoord4f(args->s, args->t, args->r, args->q);; \
} while(0)
void glTexCoord4f(glTexCoord4f_ARG_EXPAND);
typedef void (*glTexCoord4f_PTR)(glTexCoord4f_ARG_EXPAND);
#define glTexCoord4fColor4fNormal3fVertex4fSUN_INDEX 2038
#define glTexCoord4fColor4fNormal3fVertex4fSUN_RETURN void
#define glTexCoord4fColor4fNormal3fVertex4fSUN_ARG_NAMES s, t, p, q, r, g, b, a, nx, ny, nz, x, y, z, w
#define glTexCoord4fColor4fNormal3fVertex4fSUN_ARG_EXPAND GLfloat s, GLfloat t, GLfloat p, GLfloat q, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z, GLfloat w
#define glTexCoord4fColor4fNormal3fVertex4fSUN_PACKED PACKED_glTexCoord4fColor4fNormal3fVertex4fSUN
#define glTexCoord4fColor4fNormal3fVertex4fSUN_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexCoord4fColor4fNormal3fVertex4fSUN_NOT_VOID_WRAP(...) {}
#define pack_glTexCoord4fColor4fNormal3fVertex4fSUN(_s, _t, _p, _q, _r, _g, _b, _a, _nx, _ny, _nz, _x, _y, _z, _w) ({ \
    glTexCoord4fColor4fNormal3fVertex4fSUN_PACKED *packed_data = malloc(sizeof(glTexCoord4fColor4fNormal3fVertex4fSUN_PACKED)); \
    packed_data->index = glTexCoord4fColor4fNormal3fVertex4fSUN_INDEX; \
    packed_data->args.s = (GLfloat)_s; \
    packed_data->args.t = (GLfloat)_t; \
    packed_data->args.p = (GLfloat)_p; \
    packed_data->args.q = (GLfloat)_q; \
    packed_data->args.r = (GLfloat)_r; \
    packed_data->args.g = (GLfloat)_g; \
    packed_data->args.b = (GLfloat)_b; \
    packed_data->args.a = (GLfloat)_a; \
    packed_data->args.nx = (GLfloat)_nx; \
    packed_data->args.ny = (GLfloat)_ny; \
    packed_data->args.nz = (GLfloat)_nz; \
    packed_data->args.x = (GLfloat)_x; \
    packed_data->args.y = (GLfloat)_y; \
    packed_data->args.z = (GLfloat)_z; \
    packed_data->args.w = (GLfloat)_w; \
    (packed_call_t *)packed_data; \
})
#define call_glTexCoord4fColor4fNormal3fVertex4fSUN(packed, ret_v) do { \
    PACKED_glTexCoord4fColor4fNormal3fVertex4fSUN *unpacked = (PACKED_glTexCoord4fColor4fNormal3fVertex4fSUN *)packed; \
    ARGS_glTexCoord4fColor4fNormal3fVertex4fSUN *args = (ARGS_glTexCoord4fColor4fNormal3fVertex4fSUN *)&unpacked->args; \
    glTexCoord4fColor4fNormal3fVertex4fSUN(args->s, args->t, args->p, args->q, args->r, args->g, args->b, args->a, args->nx, args->ny, args->nz, args->x, args->y, args->z, args->w);; \
} while(0)
void glTexCoord4fColor4fNormal3fVertex4fSUN(glTexCoord4fColor4fNormal3fVertex4fSUN_ARG_EXPAND);
typedef void (*glTexCoord4fColor4fNormal3fVertex4fSUN_PTR)(glTexCoord4fColor4fNormal3fVertex4fSUN_ARG_EXPAND);
#define glTexCoord4fColor4fNormal3fVertex4fvSUN_INDEX 2039
#define glTexCoord4fColor4fNormal3fVertex4fvSUN_RETURN void
#define glTexCoord4fColor4fNormal3fVertex4fvSUN_ARG_NAMES tc, c, n, v
#define glTexCoord4fColor4fNormal3fVertex4fvSUN_ARG_EXPAND const GLfloat * tc, const GLfloat * c, const GLfloat * n, const GLfloat * v
#define glTexCoord4fColor4fNormal3fVertex4fvSUN_PACKED PACKED_glTexCoord4fColor4fNormal3fVertex4fvSUN
#define glTexCoord4fColor4fNormal3fVertex4fvSUN_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexCoord4fColor4fNormal3fVertex4fvSUN_NOT_VOID_WRAP(...) {}
#define pack_glTexCoord4fColor4fNormal3fVertex4fvSUN(_tc, _c, _n, _v) ({ \
    glTexCoord4fColor4fNormal3fVertex4fvSUN_PACKED *packed_data = malloc(sizeof(glTexCoord4fColor4fNormal3fVertex4fvSUN_PACKED)); \
    packed_data->index = glTexCoord4fColor4fNormal3fVertex4fvSUN_INDEX; \
    packed_data->args.tc = (GLfloat *)_tc; \
    packed_data->args.c = (GLfloat *)_c; \
    packed_data->args.n = (GLfloat *)_n; \
    packed_data->args.v = (GLfloat *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glTexCoord4fColor4fNormal3fVertex4fvSUN(packed, ret_v) do { \
    PACKED_glTexCoord4fColor4fNormal3fVertex4fvSUN *unpacked = (PACKED_glTexCoord4fColor4fNormal3fVertex4fvSUN *)packed; \
    ARGS_glTexCoord4fColor4fNormal3fVertex4fvSUN *args = (ARGS_glTexCoord4fColor4fNormal3fVertex4fvSUN *)&unpacked->args; \
    glTexCoord4fColor4fNormal3fVertex4fvSUN(args->tc, args->c, args->n, args->v);; \
} while(0)
void glTexCoord4fColor4fNormal3fVertex4fvSUN(glTexCoord4fColor4fNormal3fVertex4fvSUN_ARG_EXPAND);
typedef void (*glTexCoord4fColor4fNormal3fVertex4fvSUN_PTR)(glTexCoord4fColor4fNormal3fVertex4fvSUN_ARG_EXPAND);
#define glTexCoord4fVertex4fSUN_INDEX 2040
#define glTexCoord4fVertex4fSUN_RETURN void
#define glTexCoord4fVertex4fSUN_ARG_NAMES s, t, p, q, x, y, z, w
#define glTexCoord4fVertex4fSUN_ARG_EXPAND GLfloat s, GLfloat t, GLfloat p, GLfloat q, GLfloat x, GLfloat y, GLfloat z, GLfloat w
#define glTexCoord4fVertex4fSUN_PACKED PACKED_glTexCoord4fVertex4fSUN
#define glTexCoord4fVertex4fSUN_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexCoord4fVertex4fSUN_NOT_VOID_WRAP(...) {}
#define pack_glTexCoord4fVertex4fSUN(_s, _t, _p, _q, _x, _y, _z, _w) ({ \
    glTexCoord4fVertex4fSUN_PACKED *packed_data = malloc(sizeof(glTexCoord4fVertex4fSUN_PACKED)); \
    packed_data->index = glTexCoord4fVertex4fSUN_INDEX; \
    packed_data->args.s = (GLfloat)_s; \
    packed_data->args.t = (GLfloat)_t; \
    packed_data->args.p = (GLfloat)_p; \
    packed_data->args.q = (GLfloat)_q; \
    packed_data->args.x = (GLfloat)_x; \
    packed_data->args.y = (GLfloat)_y; \
    packed_data->args.z = (GLfloat)_z; \
    packed_data->args.w = (GLfloat)_w; \
    (packed_call_t *)packed_data; \
})
#define call_glTexCoord4fVertex4fSUN(packed, ret_v) do { \
    PACKED_glTexCoord4fVertex4fSUN *unpacked = (PACKED_glTexCoord4fVertex4fSUN *)packed; \
    ARGS_glTexCoord4fVertex4fSUN *args = (ARGS_glTexCoord4fVertex4fSUN *)&unpacked->args; \
    glTexCoord4fVertex4fSUN(args->s, args->t, args->p, args->q, args->x, args->y, args->z, args->w);; \
} while(0)
void glTexCoord4fVertex4fSUN(glTexCoord4fVertex4fSUN_ARG_EXPAND);
typedef void (*glTexCoord4fVertex4fSUN_PTR)(glTexCoord4fVertex4fSUN_ARG_EXPAND);
#define glTexCoord4fVertex4fvSUN_INDEX 2041
#define glTexCoord4fVertex4fvSUN_RETURN void
#define glTexCoord4fVertex4fvSUN_ARG_NAMES tc, v
#define glTexCoord4fVertex4fvSUN_ARG_EXPAND const GLfloat * tc, const GLfloat * v
#define glTexCoord4fVertex4fvSUN_PACKED PACKED_glTexCoord4fVertex4fvSUN
#define glTexCoord4fVertex4fvSUN_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexCoord4fVertex4fvSUN_NOT_VOID_WRAP(...) {}
#define pack_glTexCoord4fVertex4fvSUN(_tc, _v) ({ \
    glTexCoord4fVertex4fvSUN_PACKED *packed_data = malloc(sizeof(glTexCoord4fVertex4fvSUN_PACKED)); \
    packed_data->index = glTexCoord4fVertex4fvSUN_INDEX; \
    packed_data->args.tc = (GLfloat *)_tc; \
    packed_data->args.v = (GLfloat *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glTexCoord4fVertex4fvSUN(packed, ret_v) do { \
    PACKED_glTexCoord4fVertex4fvSUN *unpacked = (PACKED_glTexCoord4fVertex4fvSUN *)packed; \
    ARGS_glTexCoord4fVertex4fvSUN *args = (ARGS_glTexCoord4fVertex4fvSUN *)&unpacked->args; \
    glTexCoord4fVertex4fvSUN(args->tc, args->v);; \
} while(0)
void glTexCoord4fVertex4fvSUN(glTexCoord4fVertex4fvSUN_ARG_EXPAND);
typedef void (*glTexCoord4fVertex4fvSUN_PTR)(glTexCoord4fVertex4fvSUN_ARG_EXPAND);
#define glTexCoord4fv_INDEX 2042
#define glTexCoord4fv_RETURN void
#define glTexCoord4fv_ARG_NAMES v
#define glTexCoord4fv_ARG_EXPAND const GLfloat * v
#define glTexCoord4fv_PACKED PACKED_glTexCoord4fv
#define glTexCoord4fv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexCoord4fv_NOT_VOID_WRAP(...) {}
#define pack_glTexCoord4fv(_v) ({ \
    glTexCoord4fv_PACKED *packed_data = malloc(sizeof(glTexCoord4fv_PACKED)); \
    packed_data->index = glTexCoord4fv_INDEX; \
    packed_data->args.v = (GLfloat *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glTexCoord4fv(packed, ret_v) do { \
    PACKED_glTexCoord4fv *unpacked = (PACKED_glTexCoord4fv *)packed; \
    ARGS_glTexCoord4fv *args = (ARGS_glTexCoord4fv *)&unpacked->args; \
    glTexCoord4fv(args->v);; \
} while(0)
void glTexCoord4fv(glTexCoord4fv_ARG_EXPAND);
typedef void (*glTexCoord4fv_PTR)(glTexCoord4fv_ARG_EXPAND);
#define glTexCoord4hNV_INDEX 2043
#define glTexCoord4hNV_RETURN void
#define glTexCoord4hNV_ARG_NAMES s, t, r, q
#define glTexCoord4hNV_ARG_EXPAND GLhalfNV s, GLhalfNV t, GLhalfNV r, GLhalfNV q
#define glTexCoord4hNV_PACKED PACKED_glTexCoord4hNV
#define glTexCoord4hNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexCoord4hNV_NOT_VOID_WRAP(...) {}
#define pack_glTexCoord4hNV(_s, _t, _r, _q) ({ \
    glTexCoord4hNV_PACKED *packed_data = malloc(sizeof(glTexCoord4hNV_PACKED)); \
    packed_data->index = glTexCoord4hNV_INDEX; \
    packed_data->args.s = (GLhalfNV)_s; \
    packed_data->args.t = (GLhalfNV)_t; \
    packed_data->args.r = (GLhalfNV)_r; \
    packed_data->args.q = (GLhalfNV)_q; \
    (packed_call_t *)packed_data; \
})
#define call_glTexCoord4hNV(packed, ret_v) do { \
    PACKED_glTexCoord4hNV *unpacked = (PACKED_glTexCoord4hNV *)packed; \
    ARGS_glTexCoord4hNV *args = (ARGS_glTexCoord4hNV *)&unpacked->args; \
    glTexCoord4hNV(args->s, args->t, args->r, args->q);; \
} while(0)
void glTexCoord4hNV(glTexCoord4hNV_ARG_EXPAND);
typedef void (*glTexCoord4hNV_PTR)(glTexCoord4hNV_ARG_EXPAND);
#define glTexCoord4hvNV_INDEX 2044
#define glTexCoord4hvNV_RETURN void
#define glTexCoord4hvNV_ARG_NAMES v
#define glTexCoord4hvNV_ARG_EXPAND const GLhalfNV * v
#define glTexCoord4hvNV_PACKED PACKED_glTexCoord4hvNV
#define glTexCoord4hvNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexCoord4hvNV_NOT_VOID_WRAP(...) {}
#define pack_glTexCoord4hvNV(_v) ({ \
    glTexCoord4hvNV_PACKED *packed_data = malloc(sizeof(glTexCoord4hvNV_PACKED)); \
    packed_data->index = glTexCoord4hvNV_INDEX; \
    packed_data->args.v = (GLhalfNV *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glTexCoord4hvNV(packed, ret_v) do { \
    PACKED_glTexCoord4hvNV *unpacked = (PACKED_glTexCoord4hvNV *)packed; \
    ARGS_glTexCoord4hvNV *args = (ARGS_glTexCoord4hvNV *)&unpacked->args; \
    glTexCoord4hvNV(args->v);; \
} while(0)
void glTexCoord4hvNV(glTexCoord4hvNV_ARG_EXPAND);
typedef void (*glTexCoord4hvNV_PTR)(glTexCoord4hvNV_ARG_EXPAND);
#define glTexCoord4i_INDEX 2045
#define glTexCoord4i_RETURN void
#define glTexCoord4i_ARG_NAMES s, t, r, q
#define glTexCoord4i_ARG_EXPAND GLint s, GLint t, GLint r, GLint q
#define glTexCoord4i_PACKED PACKED_glTexCoord4i
#define glTexCoord4i_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexCoord4i_NOT_VOID_WRAP(...) {}
#define pack_glTexCoord4i(_s, _t, _r, _q) ({ \
    glTexCoord4i_PACKED *packed_data = malloc(sizeof(glTexCoord4i_PACKED)); \
    packed_data->index = glTexCoord4i_INDEX; \
    packed_data->args.s = (GLint)_s; \
    packed_data->args.t = (GLint)_t; \
    packed_data->args.r = (GLint)_r; \
    packed_data->args.q = (GLint)_q; \
    (packed_call_t *)packed_data; \
})
#define call_glTexCoord4i(packed, ret_v) do { \
    PACKED_glTexCoord4i *unpacked = (PACKED_glTexCoord4i *)packed; \
    ARGS_glTexCoord4i *args = (ARGS_glTexCoord4i *)&unpacked->args; \
    glTexCoord4i(args->s, args->t, args->r, args->q);; \
} while(0)
void glTexCoord4i(glTexCoord4i_ARG_EXPAND);
typedef void (*glTexCoord4i_PTR)(glTexCoord4i_ARG_EXPAND);
#define glTexCoord4iv_INDEX 2046
#define glTexCoord4iv_RETURN void
#define glTexCoord4iv_ARG_NAMES v
#define glTexCoord4iv_ARG_EXPAND const GLint * v
#define glTexCoord4iv_PACKED PACKED_glTexCoord4iv
#define glTexCoord4iv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexCoord4iv_NOT_VOID_WRAP(...) {}
#define pack_glTexCoord4iv(_v) ({ \
    glTexCoord4iv_PACKED *packed_data = malloc(sizeof(glTexCoord4iv_PACKED)); \
    packed_data->index = glTexCoord4iv_INDEX; \
    packed_data->args.v = (GLint *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glTexCoord4iv(packed, ret_v) do { \
    PACKED_glTexCoord4iv *unpacked = (PACKED_glTexCoord4iv *)packed; \
    ARGS_glTexCoord4iv *args = (ARGS_glTexCoord4iv *)&unpacked->args; \
    glTexCoord4iv(args->v);; \
} while(0)
void glTexCoord4iv(glTexCoord4iv_ARG_EXPAND);
typedef void (*glTexCoord4iv_PTR)(glTexCoord4iv_ARG_EXPAND);
#define glTexCoord4s_INDEX 2047
#define glTexCoord4s_RETURN void
#define glTexCoord4s_ARG_NAMES s, t, r, q
#define glTexCoord4s_ARG_EXPAND GLshort s, GLshort t, GLshort r, GLshort q
#define glTexCoord4s_PACKED PACKED_glTexCoord4s
#define glTexCoord4s_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexCoord4s_NOT_VOID_WRAP(...) {}
#define pack_glTexCoord4s(_s, _t, _r, _q) ({ \
    glTexCoord4s_PACKED *packed_data = malloc(sizeof(glTexCoord4s_PACKED)); \
    packed_data->index = glTexCoord4s_INDEX; \
    packed_data->args.s = (GLshort)_s; \
    packed_data->args.t = (GLshort)_t; \
    packed_data->args.r = (GLshort)_r; \
    packed_data->args.q = (GLshort)_q; \
    (packed_call_t *)packed_data; \
})
#define call_glTexCoord4s(packed, ret_v) do { \
    PACKED_glTexCoord4s *unpacked = (PACKED_glTexCoord4s *)packed; \
    ARGS_glTexCoord4s *args = (ARGS_glTexCoord4s *)&unpacked->args; \
    glTexCoord4s(args->s, args->t, args->r, args->q);; \
} while(0)
void glTexCoord4s(glTexCoord4s_ARG_EXPAND);
typedef void (*glTexCoord4s_PTR)(glTexCoord4s_ARG_EXPAND);
#define glTexCoord4sv_INDEX 2048
#define glTexCoord4sv_RETURN void
#define glTexCoord4sv_ARG_NAMES v
#define glTexCoord4sv_ARG_EXPAND const GLshort * v
#define glTexCoord4sv_PACKED PACKED_glTexCoord4sv
#define glTexCoord4sv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexCoord4sv_NOT_VOID_WRAP(...) {}
#define pack_glTexCoord4sv(_v) ({ \
    glTexCoord4sv_PACKED *packed_data = malloc(sizeof(glTexCoord4sv_PACKED)); \
    packed_data->index = glTexCoord4sv_INDEX; \
    packed_data->args.v = (GLshort *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glTexCoord4sv(packed, ret_v) do { \
    PACKED_glTexCoord4sv *unpacked = (PACKED_glTexCoord4sv *)packed; \
    ARGS_glTexCoord4sv *args = (ARGS_glTexCoord4sv *)&unpacked->args; \
    glTexCoord4sv(args->v);; \
} while(0)
void glTexCoord4sv(glTexCoord4sv_ARG_EXPAND);
typedef void (*glTexCoord4sv_PTR)(glTexCoord4sv_ARG_EXPAND);
#define glTexCoord4xOES_INDEX 2049
#define glTexCoord4xOES_RETURN void
#define glTexCoord4xOES_ARG_NAMES s, t, r, q
#define glTexCoord4xOES_ARG_EXPAND GLfixed s, GLfixed t, GLfixed r, GLfixed q
#define glTexCoord4xOES_PACKED PACKED_glTexCoord4xOES
#define glTexCoord4xOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexCoord4xOES_NOT_VOID_WRAP(...) {}
#define pack_glTexCoord4xOES(_s, _t, _r, _q) ({ \
    glTexCoord4xOES_PACKED *packed_data = malloc(sizeof(glTexCoord4xOES_PACKED)); \
    packed_data->index = glTexCoord4xOES_INDEX; \
    packed_data->args.s = (GLfixed)_s; \
    packed_data->args.t = (GLfixed)_t; \
    packed_data->args.r = (GLfixed)_r; \
    packed_data->args.q = (GLfixed)_q; \
    (packed_call_t *)packed_data; \
})
#define call_glTexCoord4xOES(packed, ret_v) do { \
    PACKED_glTexCoord4xOES *unpacked = (PACKED_glTexCoord4xOES *)packed; \
    ARGS_glTexCoord4xOES *args = (ARGS_glTexCoord4xOES *)&unpacked->args; \
    glTexCoord4xOES(args->s, args->t, args->r, args->q);; \
} while(0)
void glTexCoord4xOES(glTexCoord4xOES_ARG_EXPAND);
typedef void (*glTexCoord4xOES_PTR)(glTexCoord4xOES_ARG_EXPAND);
#define glTexCoord4xvOES_INDEX 2050
#define glTexCoord4xvOES_RETURN void
#define glTexCoord4xvOES_ARG_NAMES coords
#define glTexCoord4xvOES_ARG_EXPAND const GLfixed * coords
#define glTexCoord4xvOES_PACKED PACKED_glTexCoord4xvOES
#define glTexCoord4xvOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexCoord4xvOES_NOT_VOID_WRAP(...) {}
#define pack_glTexCoord4xvOES(_coords) ({ \
    glTexCoord4xvOES_PACKED *packed_data = malloc(sizeof(glTexCoord4xvOES_PACKED)); \
    packed_data->index = glTexCoord4xvOES_INDEX; \
    packed_data->args.coords = (GLfixed *)_coords; \
    (packed_call_t *)packed_data; \
})
#define call_glTexCoord4xvOES(packed, ret_v) do { \
    PACKED_glTexCoord4xvOES *unpacked = (PACKED_glTexCoord4xvOES *)packed; \
    ARGS_glTexCoord4xvOES *args = (ARGS_glTexCoord4xvOES *)&unpacked->args; \
    glTexCoord4xvOES(args->coords);; \
} while(0)
void glTexCoord4xvOES(glTexCoord4xvOES_ARG_EXPAND);
typedef void (*glTexCoord4xvOES_PTR)(glTexCoord4xvOES_ARG_EXPAND);
#define glTexCoordFormatNV_INDEX 2051
#define glTexCoordFormatNV_RETURN void
#define glTexCoordFormatNV_ARG_NAMES size, type, stride
#define glTexCoordFormatNV_ARG_EXPAND GLint size, GLenum type, GLsizei stride
#define glTexCoordFormatNV_PACKED PACKED_glTexCoordFormatNV
#define glTexCoordFormatNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexCoordFormatNV_NOT_VOID_WRAP(...) {}
#define pack_glTexCoordFormatNV(_size, _type, _stride) ({ \
    glTexCoordFormatNV_PACKED *packed_data = malloc(sizeof(glTexCoordFormatNV_PACKED)); \
    packed_data->index = glTexCoordFormatNV_INDEX; \
    packed_data->args.size = (GLint)_size; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.stride = (GLsizei)_stride; \
    (packed_call_t *)packed_data; \
})
#define call_glTexCoordFormatNV(packed, ret_v) do { \
    PACKED_glTexCoordFormatNV *unpacked = (PACKED_glTexCoordFormatNV *)packed; \
    ARGS_glTexCoordFormatNV *args = (ARGS_glTexCoordFormatNV *)&unpacked->args; \
    glTexCoordFormatNV(args->size, args->type, args->stride);; \
} while(0)
void glTexCoordFormatNV(glTexCoordFormatNV_ARG_EXPAND);
typedef void (*glTexCoordFormatNV_PTR)(glTexCoordFormatNV_ARG_EXPAND);
#define glTexCoordP1ui_INDEX 2052
#define glTexCoordP1ui_RETURN void
#define glTexCoordP1ui_ARG_NAMES type, coords
#define glTexCoordP1ui_ARG_EXPAND GLenum type, GLuint coords
#define glTexCoordP1ui_PACKED PACKED_glTexCoordP1ui
#define glTexCoordP1ui_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexCoordP1ui_NOT_VOID_WRAP(...) {}
#define pack_glTexCoordP1ui(_type, _coords) ({ \
    glTexCoordP1ui_PACKED *packed_data = malloc(sizeof(glTexCoordP1ui_PACKED)); \
    packed_data->index = glTexCoordP1ui_INDEX; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.coords = (GLuint)_coords; \
    (packed_call_t *)packed_data; \
})
#define call_glTexCoordP1ui(packed, ret_v) do { \
    PACKED_glTexCoordP1ui *unpacked = (PACKED_glTexCoordP1ui *)packed; \
    ARGS_glTexCoordP1ui *args = (ARGS_glTexCoordP1ui *)&unpacked->args; \
    glTexCoordP1ui(args->type, args->coords);; \
} while(0)
void glTexCoordP1ui(glTexCoordP1ui_ARG_EXPAND);
typedef void (*glTexCoordP1ui_PTR)(glTexCoordP1ui_ARG_EXPAND);
#define glTexCoordP1uiv_INDEX 2053
#define glTexCoordP1uiv_RETURN void
#define glTexCoordP1uiv_ARG_NAMES type, coords
#define glTexCoordP1uiv_ARG_EXPAND GLenum type, const GLuint * coords
#define glTexCoordP1uiv_PACKED PACKED_glTexCoordP1uiv
#define glTexCoordP1uiv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexCoordP1uiv_NOT_VOID_WRAP(...) {}
#define pack_glTexCoordP1uiv(_type, _coords) ({ \
    glTexCoordP1uiv_PACKED *packed_data = malloc(sizeof(glTexCoordP1uiv_PACKED)); \
    packed_data->index = glTexCoordP1uiv_INDEX; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.coords = (GLuint *)_coords; \
    (packed_call_t *)packed_data; \
})
#define call_glTexCoordP1uiv(packed, ret_v) do { \
    PACKED_glTexCoordP1uiv *unpacked = (PACKED_glTexCoordP1uiv *)packed; \
    ARGS_glTexCoordP1uiv *args = (ARGS_glTexCoordP1uiv *)&unpacked->args; \
    glTexCoordP1uiv(args->type, args->coords);; \
} while(0)
void glTexCoordP1uiv(glTexCoordP1uiv_ARG_EXPAND);
typedef void (*glTexCoordP1uiv_PTR)(glTexCoordP1uiv_ARG_EXPAND);
#define glTexCoordP2ui_INDEX 2054
#define glTexCoordP2ui_RETURN void
#define glTexCoordP2ui_ARG_NAMES type, coords
#define glTexCoordP2ui_ARG_EXPAND GLenum type, GLuint coords
#define glTexCoordP2ui_PACKED PACKED_glTexCoordP2ui
#define glTexCoordP2ui_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexCoordP2ui_NOT_VOID_WRAP(...) {}
#define pack_glTexCoordP2ui(_type, _coords) ({ \
    glTexCoordP2ui_PACKED *packed_data = malloc(sizeof(glTexCoordP2ui_PACKED)); \
    packed_data->index = glTexCoordP2ui_INDEX; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.coords = (GLuint)_coords; \
    (packed_call_t *)packed_data; \
})
#define call_glTexCoordP2ui(packed, ret_v) do { \
    PACKED_glTexCoordP2ui *unpacked = (PACKED_glTexCoordP2ui *)packed; \
    ARGS_glTexCoordP2ui *args = (ARGS_glTexCoordP2ui *)&unpacked->args; \
    glTexCoordP2ui(args->type, args->coords);; \
} while(0)
void glTexCoordP2ui(glTexCoordP2ui_ARG_EXPAND);
typedef void (*glTexCoordP2ui_PTR)(glTexCoordP2ui_ARG_EXPAND);
#define glTexCoordP2uiv_INDEX 2055
#define glTexCoordP2uiv_RETURN void
#define glTexCoordP2uiv_ARG_NAMES type, coords
#define glTexCoordP2uiv_ARG_EXPAND GLenum type, const GLuint * coords
#define glTexCoordP2uiv_PACKED PACKED_glTexCoordP2uiv
#define glTexCoordP2uiv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexCoordP2uiv_NOT_VOID_WRAP(...) {}
#define pack_glTexCoordP2uiv(_type, _coords) ({ \
    glTexCoordP2uiv_PACKED *packed_data = malloc(sizeof(glTexCoordP2uiv_PACKED)); \
    packed_data->index = glTexCoordP2uiv_INDEX; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.coords = (GLuint *)_coords; \
    (packed_call_t *)packed_data; \
})
#define call_glTexCoordP2uiv(packed, ret_v) do { \
    PACKED_glTexCoordP2uiv *unpacked = (PACKED_glTexCoordP2uiv *)packed; \
    ARGS_glTexCoordP2uiv *args = (ARGS_glTexCoordP2uiv *)&unpacked->args; \
    glTexCoordP2uiv(args->type, args->coords);; \
} while(0)
void glTexCoordP2uiv(glTexCoordP2uiv_ARG_EXPAND);
typedef void (*glTexCoordP2uiv_PTR)(glTexCoordP2uiv_ARG_EXPAND);
#define glTexCoordP3ui_INDEX 2056
#define glTexCoordP3ui_RETURN void
#define glTexCoordP3ui_ARG_NAMES type, coords
#define glTexCoordP3ui_ARG_EXPAND GLenum type, GLuint coords
#define glTexCoordP3ui_PACKED PACKED_glTexCoordP3ui
#define glTexCoordP3ui_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexCoordP3ui_NOT_VOID_WRAP(...) {}
#define pack_glTexCoordP3ui(_type, _coords) ({ \
    glTexCoordP3ui_PACKED *packed_data = malloc(sizeof(glTexCoordP3ui_PACKED)); \
    packed_data->index = glTexCoordP3ui_INDEX; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.coords = (GLuint)_coords; \
    (packed_call_t *)packed_data; \
})
#define call_glTexCoordP3ui(packed, ret_v) do { \
    PACKED_glTexCoordP3ui *unpacked = (PACKED_glTexCoordP3ui *)packed; \
    ARGS_glTexCoordP3ui *args = (ARGS_glTexCoordP3ui *)&unpacked->args; \
    glTexCoordP3ui(args->type, args->coords);; \
} while(0)
void glTexCoordP3ui(glTexCoordP3ui_ARG_EXPAND);
typedef void (*glTexCoordP3ui_PTR)(glTexCoordP3ui_ARG_EXPAND);
#define glTexCoordP3uiv_INDEX 2057
#define glTexCoordP3uiv_RETURN void
#define glTexCoordP3uiv_ARG_NAMES type, coords
#define glTexCoordP3uiv_ARG_EXPAND GLenum type, const GLuint * coords
#define glTexCoordP3uiv_PACKED PACKED_glTexCoordP3uiv
#define glTexCoordP3uiv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexCoordP3uiv_NOT_VOID_WRAP(...) {}
#define pack_glTexCoordP3uiv(_type, _coords) ({ \
    glTexCoordP3uiv_PACKED *packed_data = malloc(sizeof(glTexCoordP3uiv_PACKED)); \
    packed_data->index = glTexCoordP3uiv_INDEX; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.coords = (GLuint *)_coords; \
    (packed_call_t *)packed_data; \
})
#define call_glTexCoordP3uiv(packed, ret_v) do { \
    PACKED_glTexCoordP3uiv *unpacked = (PACKED_glTexCoordP3uiv *)packed; \
    ARGS_glTexCoordP3uiv *args = (ARGS_glTexCoordP3uiv *)&unpacked->args; \
    glTexCoordP3uiv(args->type, args->coords);; \
} while(0)
void glTexCoordP3uiv(glTexCoordP3uiv_ARG_EXPAND);
typedef void (*glTexCoordP3uiv_PTR)(glTexCoordP3uiv_ARG_EXPAND);
#define glTexCoordP4ui_INDEX 2058
#define glTexCoordP4ui_RETURN void
#define glTexCoordP4ui_ARG_NAMES type, coords
#define glTexCoordP4ui_ARG_EXPAND GLenum type, GLuint coords
#define glTexCoordP4ui_PACKED PACKED_glTexCoordP4ui
#define glTexCoordP4ui_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexCoordP4ui_NOT_VOID_WRAP(...) {}
#define pack_glTexCoordP4ui(_type, _coords) ({ \
    glTexCoordP4ui_PACKED *packed_data = malloc(sizeof(glTexCoordP4ui_PACKED)); \
    packed_data->index = glTexCoordP4ui_INDEX; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.coords = (GLuint)_coords; \
    (packed_call_t *)packed_data; \
})
#define call_glTexCoordP4ui(packed, ret_v) do { \
    PACKED_glTexCoordP4ui *unpacked = (PACKED_glTexCoordP4ui *)packed; \
    ARGS_glTexCoordP4ui *args = (ARGS_glTexCoordP4ui *)&unpacked->args; \
    glTexCoordP4ui(args->type, args->coords);; \
} while(0)
void glTexCoordP4ui(glTexCoordP4ui_ARG_EXPAND);
typedef void (*glTexCoordP4ui_PTR)(glTexCoordP4ui_ARG_EXPAND);
#define glTexCoordP4uiv_INDEX 2059
#define glTexCoordP4uiv_RETURN void
#define glTexCoordP4uiv_ARG_NAMES type, coords
#define glTexCoordP4uiv_ARG_EXPAND GLenum type, const GLuint * coords
#define glTexCoordP4uiv_PACKED PACKED_glTexCoordP4uiv
#define glTexCoordP4uiv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexCoordP4uiv_NOT_VOID_WRAP(...) {}
#define pack_glTexCoordP4uiv(_type, _coords) ({ \
    glTexCoordP4uiv_PACKED *packed_data = malloc(sizeof(glTexCoordP4uiv_PACKED)); \
    packed_data->index = glTexCoordP4uiv_INDEX; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.coords = (GLuint *)_coords; \
    (packed_call_t *)packed_data; \
})
#define call_glTexCoordP4uiv(packed, ret_v) do { \
    PACKED_glTexCoordP4uiv *unpacked = (PACKED_glTexCoordP4uiv *)packed; \
    ARGS_glTexCoordP4uiv *args = (ARGS_glTexCoordP4uiv *)&unpacked->args; \
    glTexCoordP4uiv(args->type, args->coords);; \
} while(0)
void glTexCoordP4uiv(glTexCoordP4uiv_ARG_EXPAND);
typedef void (*glTexCoordP4uiv_PTR)(glTexCoordP4uiv_ARG_EXPAND);
#define glTexCoordPointer_INDEX 2060
#define glTexCoordPointer_RETURN void
#define glTexCoordPointer_ARG_NAMES size, type, stride, pointer
#define glTexCoordPointer_ARG_EXPAND GLint size, GLenum type, GLsizei stride, const GLvoid * pointer
#define glTexCoordPointer_PACKED PACKED_glTexCoordPointer
#define glTexCoordPointer_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexCoordPointer_NOT_VOID_WRAP(...) {}
#define pack_glTexCoordPointer(_size, _type, _stride, _pointer) ({ \
    glTexCoordPointer_PACKED *packed_data = malloc(sizeof(glTexCoordPointer_PACKED)); \
    packed_data->index = glTexCoordPointer_INDEX; \
    packed_data->args.size = (GLint)_size; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.stride = (GLsizei)_stride; \
    packed_data->args.pointer = (GLvoid *)_pointer; \
    (packed_call_t *)packed_data; \
})
#define call_glTexCoordPointer(packed, ret_v) do { \
    PACKED_glTexCoordPointer *unpacked = (PACKED_glTexCoordPointer *)packed; \
    ARGS_glTexCoordPointer *args = (ARGS_glTexCoordPointer *)&unpacked->args; \
    glTexCoordPointer(args->size, args->type, args->stride, args->pointer);; \
} while(0)
void glTexCoordPointer(glTexCoordPointer_ARG_EXPAND);
typedef void (*glTexCoordPointer_PTR)(glTexCoordPointer_ARG_EXPAND);
#define glTexCoordPointerEXT_INDEX 2061
#define glTexCoordPointerEXT_RETURN void
#define glTexCoordPointerEXT_ARG_NAMES size, type, stride, count, pointer
#define glTexCoordPointerEXT_ARG_EXPAND GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid * pointer
#define glTexCoordPointerEXT_PACKED PACKED_glTexCoordPointerEXT
#define glTexCoordPointerEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexCoordPointerEXT_NOT_VOID_WRAP(...) {}
#define pack_glTexCoordPointerEXT(_size, _type, _stride, _count, _pointer) ({ \
    glTexCoordPointerEXT_PACKED *packed_data = malloc(sizeof(glTexCoordPointerEXT_PACKED)); \
    packed_data->index = glTexCoordPointerEXT_INDEX; \
    packed_data->args.size = (GLint)_size; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.stride = (GLsizei)_stride; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.pointer = (GLvoid *)_pointer; \
    (packed_call_t *)packed_data; \
})
#define call_glTexCoordPointerEXT(packed, ret_v) do { \
    PACKED_glTexCoordPointerEXT *unpacked = (PACKED_glTexCoordPointerEXT *)packed; \
    ARGS_glTexCoordPointerEXT *args = (ARGS_glTexCoordPointerEXT *)&unpacked->args; \
    glTexCoordPointerEXT(args->size, args->type, args->stride, args->count, args->pointer);; \
} while(0)
void glTexCoordPointerEXT(glTexCoordPointerEXT_ARG_EXPAND);
typedef void (*glTexCoordPointerEXT_PTR)(glTexCoordPointerEXT_ARG_EXPAND);
#define glTexCoordPointerListIBM_INDEX 2062
#define glTexCoordPointerListIBM_RETURN void
#define glTexCoordPointerListIBM_ARG_NAMES size, type, stride, pointer, ptrstride
#define glTexCoordPointerListIBM_ARG_EXPAND GLint size, GLenum type, GLint stride, const GLvoid * pointer, GLint ptrstride
#define glTexCoordPointerListIBM_PACKED PACKED_glTexCoordPointerListIBM
#define glTexCoordPointerListIBM_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexCoordPointerListIBM_NOT_VOID_WRAP(...) {}
#define pack_glTexCoordPointerListIBM(_size, _type, _stride, _pointer, _ptrstride) ({ \
    glTexCoordPointerListIBM_PACKED *packed_data = malloc(sizeof(glTexCoordPointerListIBM_PACKED)); \
    packed_data->index = glTexCoordPointerListIBM_INDEX; \
    packed_data->args.size = (GLint)_size; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.stride = (GLint)_stride; \
    packed_data->args.pointer = (GLvoid *)_pointer; \
    packed_data->args.ptrstride = (GLint)_ptrstride; \
    (packed_call_t *)packed_data; \
})
#define call_glTexCoordPointerListIBM(packed, ret_v) do { \
    PACKED_glTexCoordPointerListIBM *unpacked = (PACKED_glTexCoordPointerListIBM *)packed; \
    ARGS_glTexCoordPointerListIBM *args = (ARGS_glTexCoordPointerListIBM *)&unpacked->args; \
    glTexCoordPointerListIBM(args->size, args->type, args->stride, args->pointer, args->ptrstride);; \
} while(0)
void glTexCoordPointerListIBM(glTexCoordPointerListIBM_ARG_EXPAND);
typedef void (*glTexCoordPointerListIBM_PTR)(glTexCoordPointerListIBM_ARG_EXPAND);
#define glTexCoordPointervINTEL_INDEX 2063
#define glTexCoordPointervINTEL_RETURN void
#define glTexCoordPointervINTEL_ARG_NAMES size, type, pointer
#define glTexCoordPointervINTEL_ARG_EXPAND GLint size, GLenum type, const GLvoid * pointer
#define glTexCoordPointervINTEL_PACKED PACKED_glTexCoordPointervINTEL
#define glTexCoordPointervINTEL_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexCoordPointervINTEL_NOT_VOID_WRAP(...) {}
#define pack_glTexCoordPointervINTEL(_size, _type, _pointer) ({ \
    glTexCoordPointervINTEL_PACKED *packed_data = malloc(sizeof(glTexCoordPointervINTEL_PACKED)); \
    packed_data->index = glTexCoordPointervINTEL_INDEX; \
    packed_data->args.size = (GLint)_size; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.pointer = (GLvoid *)_pointer; \
    (packed_call_t *)packed_data; \
})
#define call_glTexCoordPointervINTEL(packed, ret_v) do { \
    PACKED_glTexCoordPointervINTEL *unpacked = (PACKED_glTexCoordPointervINTEL *)packed; \
    ARGS_glTexCoordPointervINTEL *args = (ARGS_glTexCoordPointervINTEL *)&unpacked->args; \
    glTexCoordPointervINTEL(args->size, args->type, args->pointer);; \
} while(0)
void glTexCoordPointervINTEL(glTexCoordPointervINTEL_ARG_EXPAND);
typedef void (*glTexCoordPointervINTEL_PTR)(glTexCoordPointervINTEL_ARG_EXPAND);
#define glTexEnvf_INDEX 2064
#define glTexEnvf_RETURN void
#define glTexEnvf_ARG_NAMES target, pname, param
#define glTexEnvf_ARG_EXPAND GLenum target, GLenum pname, GLfloat param
#define glTexEnvf_PACKED PACKED_glTexEnvf
#define glTexEnvf_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexEnvf_NOT_VOID_WRAP(...) {}
#define pack_glTexEnvf(_target, _pname, _param) ({ \
    glTexEnvf_PACKED *packed_data = malloc(sizeof(glTexEnvf_PACKED)); \
    packed_data->index = glTexEnvf_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.param = (GLfloat)_param; \
    (packed_call_t *)packed_data; \
})
#define call_glTexEnvf(packed, ret_v) do { \
    PACKED_glTexEnvf *unpacked = (PACKED_glTexEnvf *)packed; \
    ARGS_glTexEnvf *args = (ARGS_glTexEnvf *)&unpacked->args; \
    glTexEnvf(args->target, args->pname, args->param);; \
} while(0)
void glTexEnvf(glTexEnvf_ARG_EXPAND);
typedef void (*glTexEnvf_PTR)(glTexEnvf_ARG_EXPAND);
#define glTexEnvfv_INDEX 2065
#define glTexEnvfv_RETURN void
#define glTexEnvfv_ARG_NAMES target, pname, params
#define glTexEnvfv_ARG_EXPAND GLenum target, GLenum pname, const GLfloat * params
#define glTexEnvfv_PACKED PACKED_glTexEnvfv
#define glTexEnvfv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexEnvfv_NOT_VOID_WRAP(...) {}
#define pack_glTexEnvfv(_target, _pname, _params) ({ \
    glTexEnvfv_PACKED *packed_data = malloc(sizeof(glTexEnvfv_PACKED)); \
    packed_data->index = glTexEnvfv_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLfloat *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glTexEnvfv(packed, ret_v) do { \
    PACKED_glTexEnvfv *unpacked = (PACKED_glTexEnvfv *)packed; \
    ARGS_glTexEnvfv *args = (ARGS_glTexEnvfv *)&unpacked->args; \
    glTexEnvfv(args->target, args->pname, args->params);; \
} while(0)
void glTexEnvfv(glTexEnvfv_ARG_EXPAND);
typedef void (*glTexEnvfv_PTR)(glTexEnvfv_ARG_EXPAND);
#define glTexEnvi_INDEX 2066
#define glTexEnvi_RETURN void
#define glTexEnvi_ARG_NAMES target, pname, param
#define glTexEnvi_ARG_EXPAND GLenum target, GLenum pname, GLint param
#define glTexEnvi_PACKED PACKED_glTexEnvi
#define glTexEnvi_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexEnvi_NOT_VOID_WRAP(...) {}
#define pack_glTexEnvi(_target, _pname, _param) ({ \
    glTexEnvi_PACKED *packed_data = malloc(sizeof(glTexEnvi_PACKED)); \
    packed_data->index = glTexEnvi_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.param = (GLint)_param; \
    (packed_call_t *)packed_data; \
})
#define call_glTexEnvi(packed, ret_v) do { \
    PACKED_glTexEnvi *unpacked = (PACKED_glTexEnvi *)packed; \
    ARGS_glTexEnvi *args = (ARGS_glTexEnvi *)&unpacked->args; \
    glTexEnvi(args->target, args->pname, args->param);; \
} while(0)
void glTexEnvi(glTexEnvi_ARG_EXPAND);
typedef void (*glTexEnvi_PTR)(glTexEnvi_ARG_EXPAND);
#define glTexEnviv_INDEX 2067
#define glTexEnviv_RETURN void
#define glTexEnviv_ARG_NAMES target, pname, params
#define glTexEnviv_ARG_EXPAND GLenum target, GLenum pname, const GLint * params
#define glTexEnviv_PACKED PACKED_glTexEnviv
#define glTexEnviv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexEnviv_NOT_VOID_WRAP(...) {}
#define pack_glTexEnviv(_target, _pname, _params) ({ \
    glTexEnviv_PACKED *packed_data = malloc(sizeof(glTexEnviv_PACKED)); \
    packed_data->index = glTexEnviv_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glTexEnviv(packed, ret_v) do { \
    PACKED_glTexEnviv *unpacked = (PACKED_glTexEnviv *)packed; \
    ARGS_glTexEnviv *args = (ARGS_glTexEnviv *)&unpacked->args; \
    glTexEnviv(args->target, args->pname, args->params);; \
} while(0)
void glTexEnviv(glTexEnviv_ARG_EXPAND);
typedef void (*glTexEnviv_PTR)(glTexEnviv_ARG_EXPAND);
#define glTexEnvx_INDEX 2068
#define glTexEnvx_RETURN void
#define glTexEnvx_ARG_NAMES target, pname, param
#define glTexEnvx_ARG_EXPAND GLenum target, GLenum pname, GLfixed param
#define glTexEnvx_PACKED PACKED_glTexEnvx
#define glTexEnvx_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexEnvx_NOT_VOID_WRAP(...) {}
#define pack_glTexEnvx(_target, _pname, _param) ({ \
    glTexEnvx_PACKED *packed_data = malloc(sizeof(glTexEnvx_PACKED)); \
    packed_data->index = glTexEnvx_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.param = (GLfixed)_param; \
    (packed_call_t *)packed_data; \
})
#define call_glTexEnvx(packed, ret_v) do { \
    PACKED_glTexEnvx *unpacked = (PACKED_glTexEnvx *)packed; \
    ARGS_glTexEnvx *args = (ARGS_glTexEnvx *)&unpacked->args; \
    glTexEnvx(args->target, args->pname, args->param);; \
} while(0)
void glTexEnvx(glTexEnvx_ARG_EXPAND);
typedef void (*glTexEnvx_PTR)(glTexEnvx_ARG_EXPAND);
#define glTexEnvxOES_INDEX 2069
#define glTexEnvxOES_RETURN void
#define glTexEnvxOES_ARG_NAMES target, pname, param
#define glTexEnvxOES_ARG_EXPAND GLenum target, GLenum pname, GLfixed param
#define glTexEnvxOES_PACKED PACKED_glTexEnvxOES
#define glTexEnvxOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexEnvxOES_NOT_VOID_WRAP(...) {}
#define pack_glTexEnvxOES(_target, _pname, _param) ({ \
    glTexEnvxOES_PACKED *packed_data = malloc(sizeof(glTexEnvxOES_PACKED)); \
    packed_data->index = glTexEnvxOES_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.param = (GLfixed)_param; \
    (packed_call_t *)packed_data; \
})
#define call_glTexEnvxOES(packed, ret_v) do { \
    PACKED_glTexEnvxOES *unpacked = (PACKED_glTexEnvxOES *)packed; \
    ARGS_glTexEnvxOES *args = (ARGS_glTexEnvxOES *)&unpacked->args; \
    glTexEnvxOES(args->target, args->pname, args->param);; \
} while(0)
void glTexEnvxOES(glTexEnvxOES_ARG_EXPAND);
typedef void (*glTexEnvxOES_PTR)(glTexEnvxOES_ARG_EXPAND);
#define glTexEnvxv_INDEX 2070
#define glTexEnvxv_RETURN void
#define glTexEnvxv_ARG_NAMES target, pname, params
#define glTexEnvxv_ARG_EXPAND GLenum target, GLenum pname, const GLfixed * params
#define glTexEnvxv_PACKED PACKED_glTexEnvxv
#define glTexEnvxv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexEnvxv_NOT_VOID_WRAP(...) {}
#define pack_glTexEnvxv(_target, _pname, _params) ({ \
    glTexEnvxv_PACKED *packed_data = malloc(sizeof(glTexEnvxv_PACKED)); \
    packed_data->index = glTexEnvxv_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLfixed *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glTexEnvxv(packed, ret_v) do { \
    PACKED_glTexEnvxv *unpacked = (PACKED_glTexEnvxv *)packed; \
    ARGS_glTexEnvxv *args = (ARGS_glTexEnvxv *)&unpacked->args; \
    glTexEnvxv(args->target, args->pname, args->params);; \
} while(0)
void glTexEnvxv(glTexEnvxv_ARG_EXPAND);
typedef void (*glTexEnvxv_PTR)(glTexEnvxv_ARG_EXPAND);
#define glTexEnvxvOES_INDEX 2071
#define glTexEnvxvOES_RETURN void
#define glTexEnvxvOES_ARG_NAMES target, pname, params
#define glTexEnvxvOES_ARG_EXPAND GLenum target, GLenum pname, const GLfixed * params
#define glTexEnvxvOES_PACKED PACKED_glTexEnvxvOES
#define glTexEnvxvOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexEnvxvOES_NOT_VOID_WRAP(...) {}
#define pack_glTexEnvxvOES(_target, _pname, _params) ({ \
    glTexEnvxvOES_PACKED *packed_data = malloc(sizeof(glTexEnvxvOES_PACKED)); \
    packed_data->index = glTexEnvxvOES_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLfixed *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glTexEnvxvOES(packed, ret_v) do { \
    PACKED_glTexEnvxvOES *unpacked = (PACKED_glTexEnvxvOES *)packed; \
    ARGS_glTexEnvxvOES *args = (ARGS_glTexEnvxvOES *)&unpacked->args; \
    glTexEnvxvOES(args->target, args->pname, args->params);; \
} while(0)
void glTexEnvxvOES(glTexEnvxvOES_ARG_EXPAND);
typedef void (*glTexEnvxvOES_PTR)(glTexEnvxvOES_ARG_EXPAND);
#define glTexFilterFuncSGIS_INDEX 2072
#define glTexFilterFuncSGIS_RETURN void
#define glTexFilterFuncSGIS_ARG_NAMES target, filter, n, weights
#define glTexFilterFuncSGIS_ARG_EXPAND GLenum target, GLenum filter, GLsizei n, const GLfloat * weights
#define glTexFilterFuncSGIS_PACKED PACKED_glTexFilterFuncSGIS
#define glTexFilterFuncSGIS_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexFilterFuncSGIS_NOT_VOID_WRAP(...) {}
#define pack_glTexFilterFuncSGIS(_target, _filter, _n, _weights) ({ \
    glTexFilterFuncSGIS_PACKED *packed_data = malloc(sizeof(glTexFilterFuncSGIS_PACKED)); \
    packed_data->index = glTexFilterFuncSGIS_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.filter = (GLenum)_filter; \
    packed_data->args.n = (GLsizei)_n; \
    packed_data->args.weights = (GLfloat *)_weights; \
    (packed_call_t *)packed_data; \
})
#define call_glTexFilterFuncSGIS(packed, ret_v) do { \
    PACKED_glTexFilterFuncSGIS *unpacked = (PACKED_glTexFilterFuncSGIS *)packed; \
    ARGS_glTexFilterFuncSGIS *args = (ARGS_glTexFilterFuncSGIS *)&unpacked->args; \
    glTexFilterFuncSGIS(args->target, args->filter, args->n, args->weights);; \
} while(0)
void glTexFilterFuncSGIS(glTexFilterFuncSGIS_ARG_EXPAND);
typedef void (*glTexFilterFuncSGIS_PTR)(glTexFilterFuncSGIS_ARG_EXPAND);
#define glTexGend_INDEX 2073
#define glTexGend_RETURN void
#define glTexGend_ARG_NAMES coord, pname, param
#define glTexGend_ARG_EXPAND GLenum coord, GLenum pname, GLdouble param
#define glTexGend_PACKED PACKED_glTexGend
#define glTexGend_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexGend_NOT_VOID_WRAP(...) {}
#define pack_glTexGend(_coord, _pname, _param) ({ \
    glTexGend_PACKED *packed_data = malloc(sizeof(glTexGend_PACKED)); \
    packed_data->index = glTexGend_INDEX; \
    packed_data->args.coord = (GLenum)_coord; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.param = (GLdouble)_param; \
    (packed_call_t *)packed_data; \
})
#define call_glTexGend(packed, ret_v) do { \
    PACKED_glTexGend *unpacked = (PACKED_glTexGend *)packed; \
    ARGS_glTexGend *args = (ARGS_glTexGend *)&unpacked->args; \
    glTexGend(args->coord, args->pname, args->param);; \
} while(0)
void glTexGend(glTexGend_ARG_EXPAND);
typedef void (*glTexGend_PTR)(glTexGend_ARG_EXPAND);
#define glTexGendv_INDEX 2074
#define glTexGendv_RETURN void
#define glTexGendv_ARG_NAMES coord, pname, params
#define glTexGendv_ARG_EXPAND GLenum coord, GLenum pname, const GLdouble * params
#define glTexGendv_PACKED PACKED_glTexGendv
#define glTexGendv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexGendv_NOT_VOID_WRAP(...) {}
#define pack_glTexGendv(_coord, _pname, _params) ({ \
    glTexGendv_PACKED *packed_data = malloc(sizeof(glTexGendv_PACKED)); \
    packed_data->index = glTexGendv_INDEX; \
    packed_data->args.coord = (GLenum)_coord; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLdouble *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glTexGendv(packed, ret_v) do { \
    PACKED_glTexGendv *unpacked = (PACKED_glTexGendv *)packed; \
    ARGS_glTexGendv *args = (ARGS_glTexGendv *)&unpacked->args; \
    glTexGendv(args->coord, args->pname, args->params);; \
} while(0)
void glTexGendv(glTexGendv_ARG_EXPAND);
typedef void (*glTexGendv_PTR)(glTexGendv_ARG_EXPAND);
#define glTexGenf_INDEX 2075
#define glTexGenf_RETURN void
#define glTexGenf_ARG_NAMES coord, pname, param
#define glTexGenf_ARG_EXPAND GLenum coord, GLenum pname, GLfloat param
#define glTexGenf_PACKED PACKED_glTexGenf
#define glTexGenf_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexGenf_NOT_VOID_WRAP(...) {}
#define pack_glTexGenf(_coord, _pname, _param) ({ \
    glTexGenf_PACKED *packed_data = malloc(sizeof(glTexGenf_PACKED)); \
    packed_data->index = glTexGenf_INDEX; \
    packed_data->args.coord = (GLenum)_coord; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.param = (GLfloat)_param; \
    (packed_call_t *)packed_data; \
})
#define call_glTexGenf(packed, ret_v) do { \
    PACKED_glTexGenf *unpacked = (PACKED_glTexGenf *)packed; \
    ARGS_glTexGenf *args = (ARGS_glTexGenf *)&unpacked->args; \
    glTexGenf(args->coord, args->pname, args->param);; \
} while(0)
void glTexGenf(glTexGenf_ARG_EXPAND);
typedef void (*glTexGenf_PTR)(glTexGenf_ARG_EXPAND);
#define glTexGenfv_INDEX 2076
#define glTexGenfv_RETURN void
#define glTexGenfv_ARG_NAMES coord, pname, params
#define glTexGenfv_ARG_EXPAND GLenum coord, GLenum pname, const GLfloat * params
#define glTexGenfv_PACKED PACKED_glTexGenfv
#define glTexGenfv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexGenfv_NOT_VOID_WRAP(...) {}
#define pack_glTexGenfv(_coord, _pname, _params) ({ \
    glTexGenfv_PACKED *packed_data = malloc(sizeof(glTexGenfv_PACKED)); \
    packed_data->index = glTexGenfv_INDEX; \
    packed_data->args.coord = (GLenum)_coord; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLfloat *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glTexGenfv(packed, ret_v) do { \
    PACKED_glTexGenfv *unpacked = (PACKED_glTexGenfv *)packed; \
    ARGS_glTexGenfv *args = (ARGS_glTexGenfv *)&unpacked->args; \
    glTexGenfv(args->coord, args->pname, args->params);; \
} while(0)
void glTexGenfv(glTexGenfv_ARG_EXPAND);
typedef void (*glTexGenfv_PTR)(glTexGenfv_ARG_EXPAND);
#define glTexGeni_INDEX 2077
#define glTexGeni_RETURN void
#define glTexGeni_ARG_NAMES coord, pname, param
#define glTexGeni_ARG_EXPAND GLenum coord, GLenum pname, GLint param
#define glTexGeni_PACKED PACKED_glTexGeni
#define glTexGeni_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexGeni_NOT_VOID_WRAP(...) {}
#define pack_glTexGeni(_coord, _pname, _param) ({ \
    glTexGeni_PACKED *packed_data = malloc(sizeof(glTexGeni_PACKED)); \
    packed_data->index = glTexGeni_INDEX; \
    packed_data->args.coord = (GLenum)_coord; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.param = (GLint)_param; \
    (packed_call_t *)packed_data; \
})
#define call_glTexGeni(packed, ret_v) do { \
    PACKED_glTexGeni *unpacked = (PACKED_glTexGeni *)packed; \
    ARGS_glTexGeni *args = (ARGS_glTexGeni *)&unpacked->args; \
    glTexGeni(args->coord, args->pname, args->param);; \
} while(0)
void glTexGeni(glTexGeni_ARG_EXPAND);
typedef void (*glTexGeni_PTR)(glTexGeni_ARG_EXPAND);
#define glTexGeniv_INDEX 2078
#define glTexGeniv_RETURN void
#define glTexGeniv_ARG_NAMES coord, pname, params
#define glTexGeniv_ARG_EXPAND GLenum coord, GLenum pname, const GLint * params
#define glTexGeniv_PACKED PACKED_glTexGeniv
#define glTexGeniv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexGeniv_NOT_VOID_WRAP(...) {}
#define pack_glTexGeniv(_coord, _pname, _params) ({ \
    glTexGeniv_PACKED *packed_data = malloc(sizeof(glTexGeniv_PACKED)); \
    packed_data->index = glTexGeniv_INDEX; \
    packed_data->args.coord = (GLenum)_coord; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glTexGeniv(packed, ret_v) do { \
    PACKED_glTexGeniv *unpacked = (PACKED_glTexGeniv *)packed; \
    ARGS_glTexGeniv *args = (ARGS_glTexGeniv *)&unpacked->args; \
    glTexGeniv(args->coord, args->pname, args->params);; \
} while(0)
void glTexGeniv(glTexGeniv_ARG_EXPAND);
typedef void (*glTexGeniv_PTR)(glTexGeniv_ARG_EXPAND);
#define glTexGenxOES_INDEX 2079
#define glTexGenxOES_RETURN void
#define glTexGenxOES_ARG_NAMES coord, pname, param
#define glTexGenxOES_ARG_EXPAND GLenum coord, GLenum pname, GLfixed param
#define glTexGenxOES_PACKED PACKED_glTexGenxOES
#define glTexGenxOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexGenxOES_NOT_VOID_WRAP(...) {}
#define pack_glTexGenxOES(_coord, _pname, _param) ({ \
    glTexGenxOES_PACKED *packed_data = malloc(sizeof(glTexGenxOES_PACKED)); \
    packed_data->index = glTexGenxOES_INDEX; \
    packed_data->args.coord = (GLenum)_coord; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.param = (GLfixed)_param; \
    (packed_call_t *)packed_data; \
})
#define call_glTexGenxOES(packed, ret_v) do { \
    PACKED_glTexGenxOES *unpacked = (PACKED_glTexGenxOES *)packed; \
    ARGS_glTexGenxOES *args = (ARGS_glTexGenxOES *)&unpacked->args; \
    glTexGenxOES(args->coord, args->pname, args->param);; \
} while(0)
void glTexGenxOES(glTexGenxOES_ARG_EXPAND);
typedef void (*glTexGenxOES_PTR)(glTexGenxOES_ARG_EXPAND);
#define glTexGenxvOES_INDEX 2080
#define glTexGenxvOES_RETURN void
#define glTexGenxvOES_ARG_NAMES coord, pname, params
#define glTexGenxvOES_ARG_EXPAND GLenum coord, GLenum pname, const GLfixed * params
#define glTexGenxvOES_PACKED PACKED_glTexGenxvOES
#define glTexGenxvOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexGenxvOES_NOT_VOID_WRAP(...) {}
#define pack_glTexGenxvOES(_coord, _pname, _params) ({ \
    glTexGenxvOES_PACKED *packed_data = malloc(sizeof(glTexGenxvOES_PACKED)); \
    packed_data->index = glTexGenxvOES_INDEX; \
    packed_data->args.coord = (GLenum)_coord; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLfixed *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glTexGenxvOES(packed, ret_v) do { \
    PACKED_glTexGenxvOES *unpacked = (PACKED_glTexGenxvOES *)packed; \
    ARGS_glTexGenxvOES *args = (ARGS_glTexGenxvOES *)&unpacked->args; \
    glTexGenxvOES(args->coord, args->pname, args->params);; \
} while(0)
void glTexGenxvOES(glTexGenxvOES_ARG_EXPAND);
typedef void (*glTexGenxvOES_PTR)(glTexGenxvOES_ARG_EXPAND);
#define glTexImage1D_INDEX 2081
#define glTexImage1D_RETURN void
#define glTexImage1D_ARG_NAMES target, level, internalformat, width, border, format, type, pixels
#define glTexImage1D_ARG_EXPAND GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid * pixels
#define glTexImage1D_PACKED PACKED_glTexImage1D
#define glTexImage1D_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexImage1D_NOT_VOID_WRAP(...) {}
#define pack_glTexImage1D(_target, _level, _internalformat, _width, _border, _format, _type, _pixels) ({ \
    glTexImage1D_PACKED *packed_data = malloc(sizeof(glTexImage1D_PACKED)); \
    packed_data->index = glTexImage1D_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.level = (GLint)_level; \
    packed_data->args.internalformat = (GLint)_internalformat; \
    packed_data->args.width = (GLsizei)_width; \
    packed_data->args.border = (GLint)_border; \
    packed_data->args.format = (GLenum)_format; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.pixels = (GLvoid *)_pixels; \
    (packed_call_t *)packed_data; \
})
#define call_glTexImage1D(packed, ret_v) do { \
    PACKED_glTexImage1D *unpacked = (PACKED_glTexImage1D *)packed; \
    ARGS_glTexImage1D *args = (ARGS_glTexImage1D *)&unpacked->args; \
    glTexImage1D(args->target, args->level, args->internalformat, args->width, args->border, args->format, args->type, args->pixels);; \
} while(0)
void glTexImage1D(glTexImage1D_ARG_EXPAND);
typedef void (*glTexImage1D_PTR)(glTexImage1D_ARG_EXPAND);
#define glTexImage2D_INDEX 2082
#define glTexImage2D_RETURN void
#define glTexImage2D_ARG_NAMES target, level, internalformat, width, height, border, format, type, pixels
#define glTexImage2D_ARG_EXPAND GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid * pixels
#define glTexImage2D_PACKED PACKED_glTexImage2D
#define glTexImage2D_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexImage2D_NOT_VOID_WRAP(...) {}
#define pack_glTexImage2D(_target, _level, _internalformat, _width, _height, _border, _format, _type, _pixels) ({ \
    glTexImage2D_PACKED *packed_data = malloc(sizeof(glTexImage2D_PACKED)); \
    packed_data->index = glTexImage2D_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.level = (GLint)_level; \
    packed_data->args.internalformat = (GLint)_internalformat; \
    packed_data->args.width = (GLsizei)_width; \
    packed_data->args.height = (GLsizei)_height; \
    packed_data->args.border = (GLint)_border; \
    packed_data->args.format = (GLenum)_format; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.pixels = (GLvoid *)_pixels; \
    (packed_call_t *)packed_data; \
})
#define call_glTexImage2D(packed, ret_v) do { \
    PACKED_glTexImage2D *unpacked = (PACKED_glTexImage2D *)packed; \
    ARGS_glTexImage2D *args = (ARGS_glTexImage2D *)&unpacked->args; \
    glTexImage2D(args->target, args->level, args->internalformat, args->width, args->height, args->border, args->format, args->type, args->pixels);; \
} while(0)
void glTexImage2D(glTexImage2D_ARG_EXPAND);
typedef void (*glTexImage2D_PTR)(glTexImage2D_ARG_EXPAND);
#define glTexImage2DMultisample_INDEX 2083
#define glTexImage2DMultisample_RETURN void
#define glTexImage2DMultisample_ARG_NAMES target, samples, internalformat, width, height, fixedsamplelocations
#define glTexImage2DMultisample_ARG_EXPAND GLenum target, GLsizei samples, GLint internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations
#define glTexImage2DMultisample_PACKED PACKED_glTexImage2DMultisample
#define glTexImage2DMultisample_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexImage2DMultisample_NOT_VOID_WRAP(...) {}
#define pack_glTexImage2DMultisample(_target, _samples, _internalformat, _width, _height, _fixedsamplelocations) ({ \
    glTexImage2DMultisample_PACKED *packed_data = malloc(sizeof(glTexImage2DMultisample_PACKED)); \
    packed_data->index = glTexImage2DMultisample_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.samples = (GLsizei)_samples; \
    packed_data->args.internalformat = (GLint)_internalformat; \
    packed_data->args.width = (GLsizei)_width; \
    packed_data->args.height = (GLsizei)_height; \
    packed_data->args.fixedsamplelocations = (GLboolean)_fixedsamplelocations; \
    (packed_call_t *)packed_data; \
})
#define call_glTexImage2DMultisample(packed, ret_v) do { \
    PACKED_glTexImage2DMultisample *unpacked = (PACKED_glTexImage2DMultisample *)packed; \
    ARGS_glTexImage2DMultisample *args = (ARGS_glTexImage2DMultisample *)&unpacked->args; \
    glTexImage2DMultisample(args->target, args->samples, args->internalformat, args->width, args->height, args->fixedsamplelocations);; \
} while(0)
void glTexImage2DMultisample(glTexImage2DMultisample_ARG_EXPAND);
typedef void (*glTexImage2DMultisample_PTR)(glTexImage2DMultisample_ARG_EXPAND);
#define glTexImage2DMultisampleCoverageNV_INDEX 2084
#define glTexImage2DMultisampleCoverageNV_RETURN void
#define glTexImage2DMultisampleCoverageNV_ARG_NAMES target, coverageSamples, colorSamples, internalFormat, width, height, fixedSampleLocations
#define glTexImage2DMultisampleCoverageNV_ARG_EXPAND GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations
#define glTexImage2DMultisampleCoverageNV_PACKED PACKED_glTexImage2DMultisampleCoverageNV
#define glTexImage2DMultisampleCoverageNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexImage2DMultisampleCoverageNV_NOT_VOID_WRAP(...) {}
#define pack_glTexImage2DMultisampleCoverageNV(_target, _coverageSamples, _colorSamples, _internalFormat, _width, _height, _fixedSampleLocations) ({ \
    glTexImage2DMultisampleCoverageNV_PACKED *packed_data = malloc(sizeof(glTexImage2DMultisampleCoverageNV_PACKED)); \
    packed_data->index = glTexImage2DMultisampleCoverageNV_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.coverageSamples = (GLsizei)_coverageSamples; \
    packed_data->args.colorSamples = (GLsizei)_colorSamples; \
    packed_data->args.internalFormat = (GLint)_internalFormat; \
    packed_data->args.width = (GLsizei)_width; \
    packed_data->args.height = (GLsizei)_height; \
    packed_data->args.fixedSampleLocations = (GLboolean)_fixedSampleLocations; \
    (packed_call_t *)packed_data; \
})
#define call_glTexImage2DMultisampleCoverageNV(packed, ret_v) do { \
    PACKED_glTexImage2DMultisampleCoverageNV *unpacked = (PACKED_glTexImage2DMultisampleCoverageNV *)packed; \
    ARGS_glTexImage2DMultisampleCoverageNV *args = (ARGS_glTexImage2DMultisampleCoverageNV *)&unpacked->args; \
    glTexImage2DMultisampleCoverageNV(args->target, args->coverageSamples, args->colorSamples, args->internalFormat, args->width, args->height, args->fixedSampleLocations);; \
} while(0)
void glTexImage2DMultisampleCoverageNV(glTexImage2DMultisampleCoverageNV_ARG_EXPAND);
typedef void (*glTexImage2DMultisampleCoverageNV_PTR)(glTexImage2DMultisampleCoverageNV_ARG_EXPAND);
#define glTexImage3D_INDEX 2085
#define glTexImage3D_RETURN void
#define glTexImage3D_ARG_NAMES target, level, internalformat, width, height, depth, border, format, type, pixels
#define glTexImage3D_ARG_EXPAND GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid * pixels
#define glTexImage3D_PACKED PACKED_glTexImage3D
#define glTexImage3D_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexImage3D_NOT_VOID_WRAP(...) {}
#define pack_glTexImage3D(_target, _level, _internalformat, _width, _height, _depth, _border, _format, _type, _pixels) ({ \
    glTexImage3D_PACKED *packed_data = malloc(sizeof(glTexImage3D_PACKED)); \
    packed_data->index = glTexImage3D_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.level = (GLint)_level; \
    packed_data->args.internalformat = (GLint)_internalformat; \
    packed_data->args.width = (GLsizei)_width; \
    packed_data->args.height = (GLsizei)_height; \
    packed_data->args.depth = (GLsizei)_depth; \
    packed_data->args.border = (GLint)_border; \
    packed_data->args.format = (GLenum)_format; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.pixels = (GLvoid *)_pixels; \
    (packed_call_t *)packed_data; \
})
#define call_glTexImage3D(packed, ret_v) do { \
    PACKED_glTexImage3D *unpacked = (PACKED_glTexImage3D *)packed; \
    ARGS_glTexImage3D *args = (ARGS_glTexImage3D *)&unpacked->args; \
    glTexImage3D(args->target, args->level, args->internalformat, args->width, args->height, args->depth, args->border, args->format, args->type, args->pixels);; \
} while(0)
void glTexImage3D(glTexImage3D_ARG_EXPAND);
typedef void (*glTexImage3D_PTR)(glTexImage3D_ARG_EXPAND);
#define glTexImage3DEXT_INDEX 2086
#define glTexImage3DEXT_RETURN void
#define glTexImage3DEXT_ARG_NAMES target, level, internalformat, width, height, depth, border, format, type, pixels
#define glTexImage3DEXT_ARG_EXPAND GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid * pixels
#define glTexImage3DEXT_PACKED PACKED_glTexImage3DEXT
#define glTexImage3DEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexImage3DEXT_NOT_VOID_WRAP(...) {}
#define pack_glTexImage3DEXT(_target, _level, _internalformat, _width, _height, _depth, _border, _format, _type, _pixels) ({ \
    glTexImage3DEXT_PACKED *packed_data = malloc(sizeof(glTexImage3DEXT_PACKED)); \
    packed_data->index = glTexImage3DEXT_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.level = (GLint)_level; \
    packed_data->args.internalformat = (GLenum)_internalformat; \
    packed_data->args.width = (GLsizei)_width; \
    packed_data->args.height = (GLsizei)_height; \
    packed_data->args.depth = (GLsizei)_depth; \
    packed_data->args.border = (GLint)_border; \
    packed_data->args.format = (GLenum)_format; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.pixels = (GLvoid *)_pixels; \
    (packed_call_t *)packed_data; \
})
#define call_glTexImage3DEXT(packed, ret_v) do { \
    PACKED_glTexImage3DEXT *unpacked = (PACKED_glTexImage3DEXT *)packed; \
    ARGS_glTexImage3DEXT *args = (ARGS_glTexImage3DEXT *)&unpacked->args; \
    glTexImage3DEXT(args->target, args->level, args->internalformat, args->width, args->height, args->depth, args->border, args->format, args->type, args->pixels);; \
} while(0)
void glTexImage3DEXT(glTexImage3DEXT_ARG_EXPAND);
typedef void (*glTexImage3DEXT_PTR)(glTexImage3DEXT_ARG_EXPAND);
#define glTexImage3DMultisample_INDEX 2087
#define glTexImage3DMultisample_RETURN void
#define glTexImage3DMultisample_ARG_NAMES target, samples, internalformat, width, height, depth, fixedsamplelocations
#define glTexImage3DMultisample_ARG_EXPAND GLenum target, GLsizei samples, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations
#define glTexImage3DMultisample_PACKED PACKED_glTexImage3DMultisample
#define glTexImage3DMultisample_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexImage3DMultisample_NOT_VOID_WRAP(...) {}
#define pack_glTexImage3DMultisample(_target, _samples, _internalformat, _width, _height, _depth, _fixedsamplelocations) ({ \
    glTexImage3DMultisample_PACKED *packed_data = malloc(sizeof(glTexImage3DMultisample_PACKED)); \
    packed_data->index = glTexImage3DMultisample_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.samples = (GLsizei)_samples; \
    packed_data->args.internalformat = (GLint)_internalformat; \
    packed_data->args.width = (GLsizei)_width; \
    packed_data->args.height = (GLsizei)_height; \
    packed_data->args.depth = (GLsizei)_depth; \
    packed_data->args.fixedsamplelocations = (GLboolean)_fixedsamplelocations; \
    (packed_call_t *)packed_data; \
})
#define call_glTexImage3DMultisample(packed, ret_v) do { \
    PACKED_glTexImage3DMultisample *unpacked = (PACKED_glTexImage3DMultisample *)packed; \
    ARGS_glTexImage3DMultisample *args = (ARGS_glTexImage3DMultisample *)&unpacked->args; \
    glTexImage3DMultisample(args->target, args->samples, args->internalformat, args->width, args->height, args->depth, args->fixedsamplelocations);; \
} while(0)
void glTexImage3DMultisample(glTexImage3DMultisample_ARG_EXPAND);
typedef void (*glTexImage3DMultisample_PTR)(glTexImage3DMultisample_ARG_EXPAND);
#define glTexImage3DMultisampleCoverageNV_INDEX 2088
#define glTexImage3DMultisampleCoverageNV_RETURN void
#define glTexImage3DMultisampleCoverageNV_ARG_NAMES target, coverageSamples, colorSamples, internalFormat, width, height, depth, fixedSampleLocations
#define glTexImage3DMultisampleCoverageNV_ARG_EXPAND GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations
#define glTexImage3DMultisampleCoverageNV_PACKED PACKED_glTexImage3DMultisampleCoverageNV
#define glTexImage3DMultisampleCoverageNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexImage3DMultisampleCoverageNV_NOT_VOID_WRAP(...) {}
#define pack_glTexImage3DMultisampleCoverageNV(_target, _coverageSamples, _colorSamples, _internalFormat, _width, _height, _depth, _fixedSampleLocations) ({ \
    glTexImage3DMultisampleCoverageNV_PACKED *packed_data = malloc(sizeof(glTexImage3DMultisampleCoverageNV_PACKED)); \
    packed_data->index = glTexImage3DMultisampleCoverageNV_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.coverageSamples = (GLsizei)_coverageSamples; \
    packed_data->args.colorSamples = (GLsizei)_colorSamples; \
    packed_data->args.internalFormat = (GLint)_internalFormat; \
    packed_data->args.width = (GLsizei)_width; \
    packed_data->args.height = (GLsizei)_height; \
    packed_data->args.depth = (GLsizei)_depth; \
    packed_data->args.fixedSampleLocations = (GLboolean)_fixedSampleLocations; \
    (packed_call_t *)packed_data; \
})
#define call_glTexImage3DMultisampleCoverageNV(packed, ret_v) do { \
    PACKED_glTexImage3DMultisampleCoverageNV *unpacked = (PACKED_glTexImage3DMultisampleCoverageNV *)packed; \
    ARGS_glTexImage3DMultisampleCoverageNV *args = (ARGS_glTexImage3DMultisampleCoverageNV *)&unpacked->args; \
    glTexImage3DMultisampleCoverageNV(args->target, args->coverageSamples, args->colorSamples, args->internalFormat, args->width, args->height, args->depth, args->fixedSampleLocations);; \
} while(0)
void glTexImage3DMultisampleCoverageNV(glTexImage3DMultisampleCoverageNV_ARG_EXPAND);
typedef void (*glTexImage3DMultisampleCoverageNV_PTR)(glTexImage3DMultisampleCoverageNV_ARG_EXPAND);
#define glTexImage4DSGIS_INDEX 2089
#define glTexImage4DSGIS_RETURN void
#define glTexImage4DSGIS_ARG_NAMES target, level, internalformat, width, height, depth, size4d, border, format, type, pixels
#define glTexImage4DSGIS_ARG_EXPAND GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLsizei size4d, GLint border, GLenum format, GLenum type, const GLvoid * pixels
#define glTexImage4DSGIS_PACKED PACKED_glTexImage4DSGIS
#define glTexImage4DSGIS_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexImage4DSGIS_NOT_VOID_WRAP(...) {}
#define pack_glTexImage4DSGIS(_target, _level, _internalformat, _width, _height, _depth, _size4d, _border, _format, _type, _pixels) ({ \
    glTexImage4DSGIS_PACKED *packed_data = malloc(sizeof(glTexImage4DSGIS_PACKED)); \
    packed_data->index = glTexImage4DSGIS_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.level = (GLint)_level; \
    packed_data->args.internalformat = (GLenum)_internalformat; \
    packed_data->args.width = (GLsizei)_width; \
    packed_data->args.height = (GLsizei)_height; \
    packed_data->args.depth = (GLsizei)_depth; \
    packed_data->args.size4d = (GLsizei)_size4d; \
    packed_data->args.border = (GLint)_border; \
    packed_data->args.format = (GLenum)_format; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.pixels = (GLvoid *)_pixels; \
    (packed_call_t *)packed_data; \
})
#define call_glTexImage4DSGIS(packed, ret_v) do { \
    PACKED_glTexImage4DSGIS *unpacked = (PACKED_glTexImage4DSGIS *)packed; \
    ARGS_glTexImage4DSGIS *args = (ARGS_glTexImage4DSGIS *)&unpacked->args; \
    glTexImage4DSGIS(args->target, args->level, args->internalformat, args->width, args->height, args->depth, args->size4d, args->border, args->format, args->type, args->pixels);; \
} while(0)
void glTexImage4DSGIS(glTexImage4DSGIS_ARG_EXPAND);
typedef void (*glTexImage4DSGIS_PTR)(glTexImage4DSGIS_ARG_EXPAND);
#define glTexParameterIiv_INDEX 2090
#define glTexParameterIiv_RETURN void
#define glTexParameterIiv_ARG_NAMES target, pname, params
#define glTexParameterIiv_ARG_EXPAND GLenum target, GLenum pname, const GLint * params
#define glTexParameterIiv_PACKED PACKED_glTexParameterIiv
#define glTexParameterIiv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexParameterIiv_NOT_VOID_WRAP(...) {}
#define pack_glTexParameterIiv(_target, _pname, _params) ({ \
    glTexParameterIiv_PACKED *packed_data = malloc(sizeof(glTexParameterIiv_PACKED)); \
    packed_data->index = glTexParameterIiv_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glTexParameterIiv(packed, ret_v) do { \
    PACKED_glTexParameterIiv *unpacked = (PACKED_glTexParameterIiv *)packed; \
    ARGS_glTexParameterIiv *args = (ARGS_glTexParameterIiv *)&unpacked->args; \
    glTexParameterIiv(args->target, args->pname, args->params);; \
} while(0)
void glTexParameterIiv(glTexParameterIiv_ARG_EXPAND);
typedef void (*glTexParameterIiv_PTR)(glTexParameterIiv_ARG_EXPAND);
#define glTexParameterIivEXT_INDEX 2091
#define glTexParameterIivEXT_RETURN void
#define glTexParameterIivEXT_ARG_NAMES target, pname, params
#define glTexParameterIivEXT_ARG_EXPAND GLenum target, GLenum pname, const GLint * params
#define glTexParameterIivEXT_PACKED PACKED_glTexParameterIivEXT
#define glTexParameterIivEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexParameterIivEXT_NOT_VOID_WRAP(...) {}
#define pack_glTexParameterIivEXT(_target, _pname, _params) ({ \
    glTexParameterIivEXT_PACKED *packed_data = malloc(sizeof(glTexParameterIivEXT_PACKED)); \
    packed_data->index = glTexParameterIivEXT_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glTexParameterIivEXT(packed, ret_v) do { \
    PACKED_glTexParameterIivEXT *unpacked = (PACKED_glTexParameterIivEXT *)packed; \
    ARGS_glTexParameterIivEXT *args = (ARGS_glTexParameterIivEXT *)&unpacked->args; \
    glTexParameterIivEXT(args->target, args->pname, args->params);; \
} while(0)
void glTexParameterIivEXT(glTexParameterIivEXT_ARG_EXPAND);
typedef void (*glTexParameterIivEXT_PTR)(glTexParameterIivEXT_ARG_EXPAND);
#define glTexParameterIuiv_INDEX 2092
#define glTexParameterIuiv_RETURN void
#define glTexParameterIuiv_ARG_NAMES target, pname, params
#define glTexParameterIuiv_ARG_EXPAND GLenum target, GLenum pname, const GLuint * params
#define glTexParameterIuiv_PACKED PACKED_glTexParameterIuiv
#define glTexParameterIuiv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexParameterIuiv_NOT_VOID_WRAP(...) {}
#define pack_glTexParameterIuiv(_target, _pname, _params) ({ \
    glTexParameterIuiv_PACKED *packed_data = malloc(sizeof(glTexParameterIuiv_PACKED)); \
    packed_data->index = glTexParameterIuiv_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLuint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glTexParameterIuiv(packed, ret_v) do { \
    PACKED_glTexParameterIuiv *unpacked = (PACKED_glTexParameterIuiv *)packed; \
    ARGS_glTexParameterIuiv *args = (ARGS_glTexParameterIuiv *)&unpacked->args; \
    glTexParameterIuiv(args->target, args->pname, args->params);; \
} while(0)
void glTexParameterIuiv(glTexParameterIuiv_ARG_EXPAND);
typedef void (*glTexParameterIuiv_PTR)(glTexParameterIuiv_ARG_EXPAND);
#define glTexParameterIuivEXT_INDEX 2093
#define glTexParameterIuivEXT_RETURN void
#define glTexParameterIuivEXT_ARG_NAMES target, pname, params
#define glTexParameterIuivEXT_ARG_EXPAND GLenum target, GLenum pname, const GLuint * params
#define glTexParameterIuivEXT_PACKED PACKED_glTexParameterIuivEXT
#define glTexParameterIuivEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexParameterIuivEXT_NOT_VOID_WRAP(...) {}
#define pack_glTexParameterIuivEXT(_target, _pname, _params) ({ \
    glTexParameterIuivEXT_PACKED *packed_data = malloc(sizeof(glTexParameterIuivEXT_PACKED)); \
    packed_data->index = glTexParameterIuivEXT_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLuint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glTexParameterIuivEXT(packed, ret_v) do { \
    PACKED_glTexParameterIuivEXT *unpacked = (PACKED_glTexParameterIuivEXT *)packed; \
    ARGS_glTexParameterIuivEXT *args = (ARGS_glTexParameterIuivEXT *)&unpacked->args; \
    glTexParameterIuivEXT(args->target, args->pname, args->params);; \
} while(0)
void glTexParameterIuivEXT(glTexParameterIuivEXT_ARG_EXPAND);
typedef void (*glTexParameterIuivEXT_PTR)(glTexParameterIuivEXT_ARG_EXPAND);
#define glTexParameterf_INDEX 2094
#define glTexParameterf_RETURN void
#define glTexParameterf_ARG_NAMES target, pname, param
#define glTexParameterf_ARG_EXPAND GLenum target, GLenum pname, GLfloat param
#define glTexParameterf_PACKED PACKED_glTexParameterf
#define glTexParameterf_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexParameterf_NOT_VOID_WRAP(...) {}
#define pack_glTexParameterf(_target, _pname, _param) ({ \
    glTexParameterf_PACKED *packed_data = malloc(sizeof(glTexParameterf_PACKED)); \
    packed_data->index = glTexParameterf_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.param = (GLfloat)_param; \
    (packed_call_t *)packed_data; \
})
#define call_glTexParameterf(packed, ret_v) do { \
    PACKED_glTexParameterf *unpacked = (PACKED_glTexParameterf *)packed; \
    ARGS_glTexParameterf *args = (ARGS_glTexParameterf *)&unpacked->args; \
    glTexParameterf(args->target, args->pname, args->param);; \
} while(0)
void glTexParameterf(glTexParameterf_ARG_EXPAND);
typedef void (*glTexParameterf_PTR)(glTexParameterf_ARG_EXPAND);
#define glTexParameterfv_INDEX 2095
#define glTexParameterfv_RETURN void
#define glTexParameterfv_ARG_NAMES target, pname, params
#define glTexParameterfv_ARG_EXPAND GLenum target, GLenum pname, const GLfloat * params
#define glTexParameterfv_PACKED PACKED_glTexParameterfv
#define glTexParameterfv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexParameterfv_NOT_VOID_WRAP(...) {}
#define pack_glTexParameterfv(_target, _pname, _params) ({ \
    glTexParameterfv_PACKED *packed_data = malloc(sizeof(glTexParameterfv_PACKED)); \
    packed_data->index = glTexParameterfv_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLfloat *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glTexParameterfv(packed, ret_v) do { \
    PACKED_glTexParameterfv *unpacked = (PACKED_glTexParameterfv *)packed; \
    ARGS_glTexParameterfv *args = (ARGS_glTexParameterfv *)&unpacked->args; \
    glTexParameterfv(args->target, args->pname, args->params);; \
} while(0)
void glTexParameterfv(glTexParameterfv_ARG_EXPAND);
typedef void (*glTexParameterfv_PTR)(glTexParameterfv_ARG_EXPAND);
#define glTexParameteri_INDEX 2096
#define glTexParameteri_RETURN void
#define glTexParameteri_ARG_NAMES target, pname, param
#define glTexParameteri_ARG_EXPAND GLenum target, GLenum pname, GLint param
#define glTexParameteri_PACKED PACKED_glTexParameteri
#define glTexParameteri_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexParameteri_NOT_VOID_WRAP(...) {}
#define pack_glTexParameteri(_target, _pname, _param) ({ \
    glTexParameteri_PACKED *packed_data = malloc(sizeof(glTexParameteri_PACKED)); \
    packed_data->index = glTexParameteri_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.param = (GLint)_param; \
    (packed_call_t *)packed_data; \
})
#define call_glTexParameteri(packed, ret_v) do { \
    PACKED_glTexParameteri *unpacked = (PACKED_glTexParameteri *)packed; \
    ARGS_glTexParameteri *args = (ARGS_glTexParameteri *)&unpacked->args; \
    glTexParameteri(args->target, args->pname, args->param);; \
} while(0)
void glTexParameteri(glTexParameteri_ARG_EXPAND);
typedef void (*glTexParameteri_PTR)(glTexParameteri_ARG_EXPAND);
#define glTexParameteriv_INDEX 2097
#define glTexParameteriv_RETURN void
#define glTexParameteriv_ARG_NAMES target, pname, params
#define glTexParameteriv_ARG_EXPAND GLenum target, GLenum pname, const GLint * params
#define glTexParameteriv_PACKED PACKED_glTexParameteriv
#define glTexParameteriv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexParameteriv_NOT_VOID_WRAP(...) {}
#define pack_glTexParameteriv(_target, _pname, _params) ({ \
    glTexParameteriv_PACKED *packed_data = malloc(sizeof(glTexParameteriv_PACKED)); \
    packed_data->index = glTexParameteriv_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glTexParameteriv(packed, ret_v) do { \
    PACKED_glTexParameteriv *unpacked = (PACKED_glTexParameteriv *)packed; \
    ARGS_glTexParameteriv *args = (ARGS_glTexParameteriv *)&unpacked->args; \
    glTexParameteriv(args->target, args->pname, args->params);; \
} while(0)
void glTexParameteriv(glTexParameteriv_ARG_EXPAND);
typedef void (*glTexParameteriv_PTR)(glTexParameteriv_ARG_EXPAND);
#define glTexParameterx_INDEX 2098
#define glTexParameterx_RETURN void
#define glTexParameterx_ARG_NAMES target, pname, param
#define glTexParameterx_ARG_EXPAND GLenum target, GLenum pname, GLfixed param
#define glTexParameterx_PACKED PACKED_glTexParameterx
#define glTexParameterx_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexParameterx_NOT_VOID_WRAP(...) {}
#define pack_glTexParameterx(_target, _pname, _param) ({ \
    glTexParameterx_PACKED *packed_data = malloc(sizeof(glTexParameterx_PACKED)); \
    packed_data->index = glTexParameterx_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.param = (GLfixed)_param; \
    (packed_call_t *)packed_data; \
})
#define call_glTexParameterx(packed, ret_v) do { \
    PACKED_glTexParameterx *unpacked = (PACKED_glTexParameterx *)packed; \
    ARGS_glTexParameterx *args = (ARGS_glTexParameterx *)&unpacked->args; \
    glTexParameterx(args->target, args->pname, args->param);; \
} while(0)
void glTexParameterx(glTexParameterx_ARG_EXPAND);
typedef void (*glTexParameterx_PTR)(glTexParameterx_ARG_EXPAND);
#define glTexParameterxOES_INDEX 2099
#define glTexParameterxOES_RETURN void
#define glTexParameterxOES_ARG_NAMES target, pname, param
#define glTexParameterxOES_ARG_EXPAND GLenum target, GLenum pname, GLfixed param
#define glTexParameterxOES_PACKED PACKED_glTexParameterxOES
#define glTexParameterxOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexParameterxOES_NOT_VOID_WRAP(...) {}
#define pack_glTexParameterxOES(_target, _pname, _param) ({ \
    glTexParameterxOES_PACKED *packed_data = malloc(sizeof(glTexParameterxOES_PACKED)); \
    packed_data->index = glTexParameterxOES_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.param = (GLfixed)_param; \
    (packed_call_t *)packed_data; \
})
#define call_glTexParameterxOES(packed, ret_v) do { \
    PACKED_glTexParameterxOES *unpacked = (PACKED_glTexParameterxOES *)packed; \
    ARGS_glTexParameterxOES *args = (ARGS_glTexParameterxOES *)&unpacked->args; \
    glTexParameterxOES(args->target, args->pname, args->param);; \
} while(0)
void glTexParameterxOES(glTexParameterxOES_ARG_EXPAND);
typedef void (*glTexParameterxOES_PTR)(glTexParameterxOES_ARG_EXPAND);
#define glTexParameterxv_INDEX 2100
#define glTexParameterxv_RETURN void
#define glTexParameterxv_ARG_NAMES target, pname, params
#define glTexParameterxv_ARG_EXPAND GLenum target, GLenum pname, const GLfixed * params
#define glTexParameterxv_PACKED PACKED_glTexParameterxv
#define glTexParameterxv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexParameterxv_NOT_VOID_WRAP(...) {}
#define pack_glTexParameterxv(_target, _pname, _params) ({ \
    glTexParameterxv_PACKED *packed_data = malloc(sizeof(glTexParameterxv_PACKED)); \
    packed_data->index = glTexParameterxv_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLfixed *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glTexParameterxv(packed, ret_v) do { \
    PACKED_glTexParameterxv *unpacked = (PACKED_glTexParameterxv *)packed; \
    ARGS_glTexParameterxv *args = (ARGS_glTexParameterxv *)&unpacked->args; \
    glTexParameterxv(args->target, args->pname, args->params);; \
} while(0)
void glTexParameterxv(glTexParameterxv_ARG_EXPAND);
typedef void (*glTexParameterxv_PTR)(glTexParameterxv_ARG_EXPAND);
#define glTexParameterxvOES_INDEX 2101
#define glTexParameterxvOES_RETURN void
#define glTexParameterxvOES_ARG_NAMES target, pname, params
#define glTexParameterxvOES_ARG_EXPAND GLenum target, GLenum pname, const GLfixed * params
#define glTexParameterxvOES_PACKED PACKED_glTexParameterxvOES
#define glTexParameterxvOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexParameterxvOES_NOT_VOID_WRAP(...) {}
#define pack_glTexParameterxvOES(_target, _pname, _params) ({ \
    glTexParameterxvOES_PACKED *packed_data = malloc(sizeof(glTexParameterxvOES_PACKED)); \
    packed_data->index = glTexParameterxvOES_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLfixed *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glTexParameterxvOES(packed, ret_v) do { \
    PACKED_glTexParameterxvOES *unpacked = (PACKED_glTexParameterxvOES *)packed; \
    ARGS_glTexParameterxvOES *args = (ARGS_glTexParameterxvOES *)&unpacked->args; \
    glTexParameterxvOES(args->target, args->pname, args->params);; \
} while(0)
void glTexParameterxvOES(glTexParameterxvOES_ARG_EXPAND);
typedef void (*glTexParameterxvOES_PTR)(glTexParameterxvOES_ARG_EXPAND);
#define glTexRenderbufferNV_INDEX 2102
#define glTexRenderbufferNV_RETURN void
#define glTexRenderbufferNV_ARG_NAMES target, renderbuffer
#define glTexRenderbufferNV_ARG_EXPAND GLenum target, GLuint renderbuffer
#define glTexRenderbufferNV_PACKED PACKED_glTexRenderbufferNV
#define glTexRenderbufferNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexRenderbufferNV_NOT_VOID_WRAP(...) {}
#define pack_glTexRenderbufferNV(_target, _renderbuffer) ({ \
    glTexRenderbufferNV_PACKED *packed_data = malloc(sizeof(glTexRenderbufferNV_PACKED)); \
    packed_data->index = glTexRenderbufferNV_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.renderbuffer = (GLuint)_renderbuffer; \
    (packed_call_t *)packed_data; \
})
#define call_glTexRenderbufferNV(packed, ret_v) do { \
    PACKED_glTexRenderbufferNV *unpacked = (PACKED_glTexRenderbufferNV *)packed; \
    ARGS_glTexRenderbufferNV *args = (ARGS_glTexRenderbufferNV *)&unpacked->args; \
    glTexRenderbufferNV(args->target, args->renderbuffer);; \
} while(0)
void glTexRenderbufferNV(glTexRenderbufferNV_ARG_EXPAND);
typedef void (*glTexRenderbufferNV_PTR)(glTexRenderbufferNV_ARG_EXPAND);
#define glTexStorage1D_INDEX 2103
#define glTexStorage1D_RETURN void
#define glTexStorage1D_ARG_NAMES target, levels, internalformat, width
#define glTexStorage1D_ARG_EXPAND GLenum target, GLsizei levels, GLenum internalformat, GLsizei width
#define glTexStorage1D_PACKED PACKED_glTexStorage1D
#define glTexStorage1D_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexStorage1D_NOT_VOID_WRAP(...) {}
#define pack_glTexStorage1D(_target, _levels, _internalformat, _width) ({ \
    glTexStorage1D_PACKED *packed_data = malloc(sizeof(glTexStorage1D_PACKED)); \
    packed_data->index = glTexStorage1D_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.levels = (GLsizei)_levels; \
    packed_data->args.internalformat = (GLenum)_internalformat; \
    packed_data->args.width = (GLsizei)_width; \
    (packed_call_t *)packed_data; \
})
#define call_glTexStorage1D(packed, ret_v) do { \
    PACKED_glTexStorage1D *unpacked = (PACKED_glTexStorage1D *)packed; \
    ARGS_glTexStorage1D *args = (ARGS_glTexStorage1D *)&unpacked->args; \
    glTexStorage1D(args->target, args->levels, args->internalformat, args->width);; \
} while(0)
void glTexStorage1D(glTexStorage1D_ARG_EXPAND);
typedef void (*glTexStorage1D_PTR)(glTexStorage1D_ARG_EXPAND);
#define glTexStorage2D_INDEX 2104
#define glTexStorage2D_RETURN void
#define glTexStorage2D_ARG_NAMES target, levels, internalformat, width, height
#define glTexStorage2D_ARG_EXPAND GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height
#define glTexStorage2D_PACKED PACKED_glTexStorage2D
#define glTexStorage2D_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexStorage2D_NOT_VOID_WRAP(...) {}
#define pack_glTexStorage2D(_target, _levels, _internalformat, _width, _height) ({ \
    glTexStorage2D_PACKED *packed_data = malloc(sizeof(glTexStorage2D_PACKED)); \
    packed_data->index = glTexStorage2D_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.levels = (GLsizei)_levels; \
    packed_data->args.internalformat = (GLenum)_internalformat; \
    packed_data->args.width = (GLsizei)_width; \
    packed_data->args.height = (GLsizei)_height; \
    (packed_call_t *)packed_data; \
})
#define call_glTexStorage2D(packed, ret_v) do { \
    PACKED_glTexStorage2D *unpacked = (PACKED_glTexStorage2D *)packed; \
    ARGS_glTexStorage2D *args = (ARGS_glTexStorage2D *)&unpacked->args; \
    glTexStorage2D(args->target, args->levels, args->internalformat, args->width, args->height);; \
} while(0)
void glTexStorage2D(glTexStorage2D_ARG_EXPAND);
typedef void (*glTexStorage2D_PTR)(glTexStorage2D_ARG_EXPAND);
#define glTexStorage2DMultisample_INDEX 2105
#define glTexStorage2DMultisample_RETURN void
#define glTexStorage2DMultisample_ARG_NAMES target, samples, internalformat, width, height, fixedsamplelocations
#define glTexStorage2DMultisample_ARG_EXPAND GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations
#define glTexStorage2DMultisample_PACKED PACKED_glTexStorage2DMultisample
#define glTexStorage2DMultisample_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexStorage2DMultisample_NOT_VOID_WRAP(...) {}
#define pack_glTexStorage2DMultisample(_target, _samples, _internalformat, _width, _height, _fixedsamplelocations) ({ \
    glTexStorage2DMultisample_PACKED *packed_data = malloc(sizeof(glTexStorage2DMultisample_PACKED)); \
    packed_data->index = glTexStorage2DMultisample_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.samples = (GLsizei)_samples; \
    packed_data->args.internalformat = (GLenum)_internalformat; \
    packed_data->args.width = (GLsizei)_width; \
    packed_data->args.height = (GLsizei)_height; \
    packed_data->args.fixedsamplelocations = (GLboolean)_fixedsamplelocations; \
    (packed_call_t *)packed_data; \
})
#define call_glTexStorage2DMultisample(packed, ret_v) do { \
    PACKED_glTexStorage2DMultisample *unpacked = (PACKED_glTexStorage2DMultisample *)packed; \
    ARGS_glTexStorage2DMultisample *args = (ARGS_glTexStorage2DMultisample *)&unpacked->args; \
    glTexStorage2DMultisample(args->target, args->samples, args->internalformat, args->width, args->height, args->fixedsamplelocations);; \
} while(0)
void glTexStorage2DMultisample(glTexStorage2DMultisample_ARG_EXPAND);
typedef void (*glTexStorage2DMultisample_PTR)(glTexStorage2DMultisample_ARG_EXPAND);
#define glTexStorage3D_INDEX 2106
#define glTexStorage3D_RETURN void
#define glTexStorage3D_ARG_NAMES target, levels, internalformat, width, height, depth
#define glTexStorage3D_ARG_EXPAND GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth
#define glTexStorage3D_PACKED PACKED_glTexStorage3D
#define glTexStorage3D_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexStorage3D_NOT_VOID_WRAP(...) {}
#define pack_glTexStorage3D(_target, _levels, _internalformat, _width, _height, _depth) ({ \
    glTexStorage3D_PACKED *packed_data = malloc(sizeof(glTexStorage3D_PACKED)); \
    packed_data->index = glTexStorage3D_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.levels = (GLsizei)_levels; \
    packed_data->args.internalformat = (GLenum)_internalformat; \
    packed_data->args.width = (GLsizei)_width; \
    packed_data->args.height = (GLsizei)_height; \
    packed_data->args.depth = (GLsizei)_depth; \
    (packed_call_t *)packed_data; \
})
#define call_glTexStorage3D(packed, ret_v) do { \
    PACKED_glTexStorage3D *unpacked = (PACKED_glTexStorage3D *)packed; \
    ARGS_glTexStorage3D *args = (ARGS_glTexStorage3D *)&unpacked->args; \
    glTexStorage3D(args->target, args->levels, args->internalformat, args->width, args->height, args->depth);; \
} while(0)
void glTexStorage3D(glTexStorage3D_ARG_EXPAND);
typedef void (*glTexStorage3D_PTR)(glTexStorage3D_ARG_EXPAND);
#define glTexStorage3DMultisample_INDEX 2107
#define glTexStorage3DMultisample_RETURN void
#define glTexStorage3DMultisample_ARG_NAMES target, samples, internalformat, width, height, depth, fixedsamplelocations
#define glTexStorage3DMultisample_ARG_EXPAND GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations
#define glTexStorage3DMultisample_PACKED PACKED_glTexStorage3DMultisample
#define glTexStorage3DMultisample_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexStorage3DMultisample_NOT_VOID_WRAP(...) {}
#define pack_glTexStorage3DMultisample(_target, _samples, _internalformat, _width, _height, _depth, _fixedsamplelocations) ({ \
    glTexStorage3DMultisample_PACKED *packed_data = malloc(sizeof(glTexStorage3DMultisample_PACKED)); \
    packed_data->index = glTexStorage3DMultisample_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.samples = (GLsizei)_samples; \
    packed_data->args.internalformat = (GLenum)_internalformat; \
    packed_data->args.width = (GLsizei)_width; \
    packed_data->args.height = (GLsizei)_height; \
    packed_data->args.depth = (GLsizei)_depth; \
    packed_data->args.fixedsamplelocations = (GLboolean)_fixedsamplelocations; \
    (packed_call_t *)packed_data; \
})
#define call_glTexStorage3DMultisample(packed, ret_v) do { \
    PACKED_glTexStorage3DMultisample *unpacked = (PACKED_glTexStorage3DMultisample *)packed; \
    ARGS_glTexStorage3DMultisample *args = (ARGS_glTexStorage3DMultisample *)&unpacked->args; \
    glTexStorage3DMultisample(args->target, args->samples, args->internalformat, args->width, args->height, args->depth, args->fixedsamplelocations);; \
} while(0)
void glTexStorage3DMultisample(glTexStorage3DMultisample_ARG_EXPAND);
typedef void (*glTexStorage3DMultisample_PTR)(glTexStorage3DMultisample_ARG_EXPAND);
#define glTexStorageSparseAMD_INDEX 2108
#define glTexStorageSparseAMD_RETURN void
#define glTexStorageSparseAMD_ARG_NAMES target, internalFormat, width, height, depth, layers, flags
#define glTexStorageSparseAMD_ARG_EXPAND GLenum target, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLsizei layers, GLbitfield flags
#define glTexStorageSparseAMD_PACKED PACKED_glTexStorageSparseAMD
#define glTexStorageSparseAMD_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexStorageSparseAMD_NOT_VOID_WRAP(...) {}
#define pack_glTexStorageSparseAMD(_target, _internalFormat, _width, _height, _depth, _layers, _flags) ({ \
    glTexStorageSparseAMD_PACKED *packed_data = malloc(sizeof(glTexStorageSparseAMD_PACKED)); \
    packed_data->index = glTexStorageSparseAMD_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.internalFormat = (GLenum)_internalFormat; \
    packed_data->args.width = (GLsizei)_width; \
    packed_data->args.height = (GLsizei)_height; \
    packed_data->args.depth = (GLsizei)_depth; \
    packed_data->args.layers = (GLsizei)_layers; \
    packed_data->args.flags = (GLbitfield)_flags; \
    (packed_call_t *)packed_data; \
})
#define call_glTexStorageSparseAMD(packed, ret_v) do { \
    PACKED_glTexStorageSparseAMD *unpacked = (PACKED_glTexStorageSparseAMD *)packed; \
    ARGS_glTexStorageSparseAMD *args = (ARGS_glTexStorageSparseAMD *)&unpacked->args; \
    glTexStorageSparseAMD(args->target, args->internalFormat, args->width, args->height, args->depth, args->layers, args->flags);; \
} while(0)
void glTexStorageSparseAMD(glTexStorageSparseAMD_ARG_EXPAND);
typedef void (*glTexStorageSparseAMD_PTR)(glTexStorageSparseAMD_ARG_EXPAND);
#define glTexSubImage1D_INDEX 2109
#define glTexSubImage1D_RETURN void
#define glTexSubImage1D_ARG_NAMES target, level, xoffset, width, format, type, pixels
#define glTexSubImage1D_ARG_EXPAND GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid * pixels
#define glTexSubImage1D_PACKED PACKED_glTexSubImage1D
#define glTexSubImage1D_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexSubImage1D_NOT_VOID_WRAP(...) {}
#define pack_glTexSubImage1D(_target, _level, _xoffset, _width, _format, _type, _pixels) ({ \
    glTexSubImage1D_PACKED *packed_data = malloc(sizeof(glTexSubImage1D_PACKED)); \
    packed_data->index = glTexSubImage1D_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.level = (GLint)_level; \
    packed_data->args.xoffset = (GLint)_xoffset; \
    packed_data->args.width = (GLsizei)_width; \
    packed_data->args.format = (GLenum)_format; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.pixels = (GLvoid *)_pixels; \
    (packed_call_t *)packed_data; \
})
#define call_glTexSubImage1D(packed, ret_v) do { \
    PACKED_glTexSubImage1D *unpacked = (PACKED_glTexSubImage1D *)packed; \
    ARGS_glTexSubImage1D *args = (ARGS_glTexSubImage1D *)&unpacked->args; \
    glTexSubImage1D(args->target, args->level, args->xoffset, args->width, args->format, args->type, args->pixels);; \
} while(0)
void glTexSubImage1D(glTexSubImage1D_ARG_EXPAND);
typedef void (*glTexSubImage1D_PTR)(glTexSubImage1D_ARG_EXPAND);
#define glTexSubImage1DEXT_INDEX 2110
#define glTexSubImage1DEXT_RETURN void
#define glTexSubImage1DEXT_ARG_NAMES target, level, xoffset, width, format, type, pixels
#define glTexSubImage1DEXT_ARG_EXPAND GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid * pixels
#define glTexSubImage1DEXT_PACKED PACKED_glTexSubImage1DEXT
#define glTexSubImage1DEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexSubImage1DEXT_NOT_VOID_WRAP(...) {}
#define pack_glTexSubImage1DEXT(_target, _level, _xoffset, _width, _format, _type, _pixels) ({ \
    glTexSubImage1DEXT_PACKED *packed_data = malloc(sizeof(glTexSubImage1DEXT_PACKED)); \
    packed_data->index = glTexSubImage1DEXT_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.level = (GLint)_level; \
    packed_data->args.xoffset = (GLint)_xoffset; \
    packed_data->args.width = (GLsizei)_width; \
    packed_data->args.format = (GLenum)_format; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.pixels = (GLvoid *)_pixels; \
    (packed_call_t *)packed_data; \
})
#define call_glTexSubImage1DEXT(packed, ret_v) do { \
    PACKED_glTexSubImage1DEXT *unpacked = (PACKED_glTexSubImage1DEXT *)packed; \
    ARGS_glTexSubImage1DEXT *args = (ARGS_glTexSubImage1DEXT *)&unpacked->args; \
    glTexSubImage1DEXT(args->target, args->level, args->xoffset, args->width, args->format, args->type, args->pixels);; \
} while(0)
void glTexSubImage1DEXT(glTexSubImage1DEXT_ARG_EXPAND);
typedef void (*glTexSubImage1DEXT_PTR)(glTexSubImage1DEXT_ARG_EXPAND);
#define glTexSubImage2D_INDEX 2111
#define glTexSubImage2D_RETURN void
#define glTexSubImage2D_ARG_NAMES target, level, xoffset, yoffset, width, height, format, type, pixels
#define glTexSubImage2D_ARG_EXPAND GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid * pixels
#define glTexSubImage2D_PACKED PACKED_glTexSubImage2D
#define glTexSubImage2D_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexSubImage2D_NOT_VOID_WRAP(...) {}
#define pack_glTexSubImage2D(_target, _level, _xoffset, _yoffset, _width, _height, _format, _type, _pixels) ({ \
    glTexSubImage2D_PACKED *packed_data = malloc(sizeof(glTexSubImage2D_PACKED)); \
    packed_data->index = glTexSubImage2D_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.level = (GLint)_level; \
    packed_data->args.xoffset = (GLint)_xoffset; \
    packed_data->args.yoffset = (GLint)_yoffset; \
    packed_data->args.width = (GLsizei)_width; \
    packed_data->args.height = (GLsizei)_height; \
    packed_data->args.format = (GLenum)_format; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.pixels = (GLvoid *)_pixels; \
    (packed_call_t *)packed_data; \
})
#define call_glTexSubImage2D(packed, ret_v) do { \
    PACKED_glTexSubImage2D *unpacked = (PACKED_glTexSubImage2D *)packed; \
    ARGS_glTexSubImage2D *args = (ARGS_glTexSubImage2D *)&unpacked->args; \
    glTexSubImage2D(args->target, args->level, args->xoffset, args->yoffset, args->width, args->height, args->format, args->type, args->pixels);; \
} while(0)
void glTexSubImage2D(glTexSubImage2D_ARG_EXPAND);
typedef void (*glTexSubImage2D_PTR)(glTexSubImage2D_ARG_EXPAND);
#define glTexSubImage2DEXT_INDEX 2112
#define glTexSubImage2DEXT_RETURN void
#define glTexSubImage2DEXT_ARG_NAMES target, level, xoffset, yoffset, width, height, format, type, pixels
#define glTexSubImage2DEXT_ARG_EXPAND GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid * pixels
#define glTexSubImage2DEXT_PACKED PACKED_glTexSubImage2DEXT
#define glTexSubImage2DEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexSubImage2DEXT_NOT_VOID_WRAP(...) {}
#define pack_glTexSubImage2DEXT(_target, _level, _xoffset, _yoffset, _width, _height, _format, _type, _pixels) ({ \
    glTexSubImage2DEXT_PACKED *packed_data = malloc(sizeof(glTexSubImage2DEXT_PACKED)); \
    packed_data->index = glTexSubImage2DEXT_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.level = (GLint)_level; \
    packed_data->args.xoffset = (GLint)_xoffset; \
    packed_data->args.yoffset = (GLint)_yoffset; \
    packed_data->args.width = (GLsizei)_width; \
    packed_data->args.height = (GLsizei)_height; \
    packed_data->args.format = (GLenum)_format; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.pixels = (GLvoid *)_pixels; \
    (packed_call_t *)packed_data; \
})
#define call_glTexSubImage2DEXT(packed, ret_v) do { \
    PACKED_glTexSubImage2DEXT *unpacked = (PACKED_glTexSubImage2DEXT *)packed; \
    ARGS_glTexSubImage2DEXT *args = (ARGS_glTexSubImage2DEXT *)&unpacked->args; \
    glTexSubImage2DEXT(args->target, args->level, args->xoffset, args->yoffset, args->width, args->height, args->format, args->type, args->pixels);; \
} while(0)
void glTexSubImage2DEXT(glTexSubImage2DEXT_ARG_EXPAND);
typedef void (*glTexSubImage2DEXT_PTR)(glTexSubImage2DEXT_ARG_EXPAND);
#define glTexSubImage3D_INDEX 2113
#define glTexSubImage3D_RETURN void
#define glTexSubImage3D_ARG_NAMES target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels
#define glTexSubImage3D_ARG_EXPAND GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid * pixels
#define glTexSubImage3D_PACKED PACKED_glTexSubImage3D
#define glTexSubImage3D_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexSubImage3D_NOT_VOID_WRAP(...) {}
#define pack_glTexSubImage3D(_target, _level, _xoffset, _yoffset, _zoffset, _width, _height, _depth, _format, _type, _pixels) ({ \
    glTexSubImage3D_PACKED *packed_data = malloc(sizeof(glTexSubImage3D_PACKED)); \
    packed_data->index = glTexSubImage3D_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.level = (GLint)_level; \
    packed_data->args.xoffset = (GLint)_xoffset; \
    packed_data->args.yoffset = (GLint)_yoffset; \
    packed_data->args.zoffset = (GLint)_zoffset; \
    packed_data->args.width = (GLsizei)_width; \
    packed_data->args.height = (GLsizei)_height; \
    packed_data->args.depth = (GLsizei)_depth; \
    packed_data->args.format = (GLenum)_format; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.pixels = (GLvoid *)_pixels; \
    (packed_call_t *)packed_data; \
})
#define call_glTexSubImage3D(packed, ret_v) do { \
    PACKED_glTexSubImage3D *unpacked = (PACKED_glTexSubImage3D *)packed; \
    ARGS_glTexSubImage3D *args = (ARGS_glTexSubImage3D *)&unpacked->args; \
    glTexSubImage3D(args->target, args->level, args->xoffset, args->yoffset, args->zoffset, args->width, args->height, args->depth, args->format, args->type, args->pixels);; \
} while(0)
void glTexSubImage3D(glTexSubImage3D_ARG_EXPAND);
typedef void (*glTexSubImage3D_PTR)(glTexSubImage3D_ARG_EXPAND);
#define glTexSubImage3DEXT_INDEX 2114
#define glTexSubImage3DEXT_RETURN void
#define glTexSubImage3DEXT_ARG_NAMES target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels
#define glTexSubImage3DEXT_ARG_EXPAND GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid * pixels
#define glTexSubImage3DEXT_PACKED PACKED_glTexSubImage3DEXT
#define glTexSubImage3DEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexSubImage3DEXT_NOT_VOID_WRAP(...) {}
#define pack_glTexSubImage3DEXT(_target, _level, _xoffset, _yoffset, _zoffset, _width, _height, _depth, _format, _type, _pixels) ({ \
    glTexSubImage3DEXT_PACKED *packed_data = malloc(sizeof(glTexSubImage3DEXT_PACKED)); \
    packed_data->index = glTexSubImage3DEXT_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.level = (GLint)_level; \
    packed_data->args.xoffset = (GLint)_xoffset; \
    packed_data->args.yoffset = (GLint)_yoffset; \
    packed_data->args.zoffset = (GLint)_zoffset; \
    packed_data->args.width = (GLsizei)_width; \
    packed_data->args.height = (GLsizei)_height; \
    packed_data->args.depth = (GLsizei)_depth; \
    packed_data->args.format = (GLenum)_format; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.pixels = (GLvoid *)_pixels; \
    (packed_call_t *)packed_data; \
})
#define call_glTexSubImage3DEXT(packed, ret_v) do { \
    PACKED_glTexSubImage3DEXT *unpacked = (PACKED_glTexSubImage3DEXT *)packed; \
    ARGS_glTexSubImage3DEXT *args = (ARGS_glTexSubImage3DEXT *)&unpacked->args; \
    glTexSubImage3DEXT(args->target, args->level, args->xoffset, args->yoffset, args->zoffset, args->width, args->height, args->depth, args->format, args->type, args->pixels);; \
} while(0)
void glTexSubImage3DEXT(glTexSubImage3DEXT_ARG_EXPAND);
typedef void (*glTexSubImage3DEXT_PTR)(glTexSubImage3DEXT_ARG_EXPAND);
#define glTexSubImage4DSGIS_INDEX 2115
#define glTexSubImage4DSGIS_RETURN void
#define glTexSubImage4DSGIS_ARG_NAMES target, level, xoffset, yoffset, zoffset, woffset, width, height, depth, size4d, format, type, pixels
#define glTexSubImage4DSGIS_ARG_EXPAND GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint woffset, GLsizei width, GLsizei height, GLsizei depth, GLsizei size4d, GLenum format, GLenum type, const GLvoid * pixels
#define glTexSubImage4DSGIS_PACKED PACKED_glTexSubImage4DSGIS
#define glTexSubImage4DSGIS_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTexSubImage4DSGIS_NOT_VOID_WRAP(...) {}
#define pack_glTexSubImage4DSGIS(_target, _level, _xoffset, _yoffset, _zoffset, _woffset, _width, _height, _depth, _size4d, _format, _type, _pixels) ({ \
    glTexSubImage4DSGIS_PACKED *packed_data = malloc(sizeof(glTexSubImage4DSGIS_PACKED)); \
    packed_data->index = glTexSubImage4DSGIS_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.level = (GLint)_level; \
    packed_data->args.xoffset = (GLint)_xoffset; \
    packed_data->args.yoffset = (GLint)_yoffset; \
    packed_data->args.zoffset = (GLint)_zoffset; \
    packed_data->args.woffset = (GLint)_woffset; \
    packed_data->args.width = (GLsizei)_width; \
    packed_data->args.height = (GLsizei)_height; \
    packed_data->args.depth = (GLsizei)_depth; \
    packed_data->args.size4d = (GLsizei)_size4d; \
    packed_data->args.format = (GLenum)_format; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.pixels = (GLvoid *)_pixels; \
    (packed_call_t *)packed_data; \
})
#define call_glTexSubImage4DSGIS(packed, ret_v) do { \
    PACKED_glTexSubImage4DSGIS *unpacked = (PACKED_glTexSubImage4DSGIS *)packed; \
    ARGS_glTexSubImage4DSGIS *args = (ARGS_glTexSubImage4DSGIS *)&unpacked->args; \
    glTexSubImage4DSGIS(args->target, args->level, args->xoffset, args->yoffset, args->zoffset, args->woffset, args->width, args->height, args->depth, args->size4d, args->format, args->type, args->pixels);; \
} while(0)
void glTexSubImage4DSGIS(glTexSubImage4DSGIS_ARG_EXPAND);
typedef void (*glTexSubImage4DSGIS_PTR)(glTexSubImage4DSGIS_ARG_EXPAND);
#define glTextureBarrierNV_INDEX 2116
#define glTextureBarrierNV_RETURN void
#define glTextureBarrierNV_ARG_NAMES 
#define glTextureBarrierNV_ARG_EXPAND 
#define glTextureBarrierNV_PACKED PACKED_glTextureBarrierNV
#define glTextureBarrierNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTextureBarrierNV_NOT_VOID_WRAP(...) {}
#define pack_glTextureBarrierNV() ({ \
    glTextureBarrierNV_PACKED *packed_data = malloc(sizeof(glTextureBarrierNV_PACKED)); \
    packed_data->index = glTextureBarrierNV_INDEX; \
    (packed_call_t *)packed_data; \
})
#define call_glTextureBarrierNV(packed, ret_v) do { \
    glTextureBarrierNV();; \
} while(0)
void glTextureBarrierNV(glTextureBarrierNV_ARG_EXPAND);
typedef void (*glTextureBarrierNV_PTR)(glTextureBarrierNV_ARG_EXPAND);
#define glTextureBufferEXT_INDEX 2117
#define glTextureBufferEXT_RETURN void
#define glTextureBufferEXT_ARG_NAMES texture, target, internalformat, buffer
#define glTextureBufferEXT_ARG_EXPAND GLuint texture, GLenum target, GLenum internalformat, GLuint buffer
#define glTextureBufferEXT_PACKED PACKED_glTextureBufferEXT
#define glTextureBufferEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTextureBufferEXT_NOT_VOID_WRAP(...) {}
#define pack_glTextureBufferEXT(_texture, _target, _internalformat, _buffer) ({ \
    glTextureBufferEXT_PACKED *packed_data = malloc(sizeof(glTextureBufferEXT_PACKED)); \
    packed_data->index = glTextureBufferEXT_INDEX; \
    packed_data->args.texture = (GLuint)_texture; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.internalformat = (GLenum)_internalformat; \
    packed_data->args.buffer = (GLuint)_buffer; \
    (packed_call_t *)packed_data; \
})
#define call_glTextureBufferEXT(packed, ret_v) do { \
    PACKED_glTextureBufferEXT *unpacked = (PACKED_glTextureBufferEXT *)packed; \
    ARGS_glTextureBufferEXT *args = (ARGS_glTextureBufferEXT *)&unpacked->args; \
    glTextureBufferEXT(args->texture, args->target, args->internalformat, args->buffer);; \
} while(0)
void glTextureBufferEXT(glTextureBufferEXT_ARG_EXPAND);
typedef void (*glTextureBufferEXT_PTR)(glTextureBufferEXT_ARG_EXPAND);
#define glTextureBufferRangeEXT_INDEX 2118
#define glTextureBufferRangeEXT_RETURN void
#define glTextureBufferRangeEXT_ARG_NAMES texture, target, internalformat, buffer, offset, size
#define glTextureBufferRangeEXT_ARG_EXPAND GLuint texture, GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size
#define glTextureBufferRangeEXT_PACKED PACKED_glTextureBufferRangeEXT
#define glTextureBufferRangeEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTextureBufferRangeEXT_NOT_VOID_WRAP(...) {}
#define pack_glTextureBufferRangeEXT(_texture, _target, _internalformat, _buffer, _offset, _size) ({ \
    glTextureBufferRangeEXT_PACKED *packed_data = malloc(sizeof(glTextureBufferRangeEXT_PACKED)); \
    packed_data->index = glTextureBufferRangeEXT_INDEX; \
    packed_data->args.texture = (GLuint)_texture; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.internalformat = (GLenum)_internalformat; \
    packed_data->args.buffer = (GLuint)_buffer; \
    packed_data->args.offset = (GLintptr)_offset; \
    packed_data->args.size = (GLsizeiptr)_size; \
    (packed_call_t *)packed_data; \
})
#define call_glTextureBufferRangeEXT(packed, ret_v) do { \
    PACKED_glTextureBufferRangeEXT *unpacked = (PACKED_glTextureBufferRangeEXT *)packed; \
    ARGS_glTextureBufferRangeEXT *args = (ARGS_glTextureBufferRangeEXT *)&unpacked->args; \
    glTextureBufferRangeEXT(args->texture, args->target, args->internalformat, args->buffer, args->offset, args->size);; \
} while(0)
void glTextureBufferRangeEXT(glTextureBufferRangeEXT_ARG_EXPAND);
typedef void (*glTextureBufferRangeEXT_PTR)(glTextureBufferRangeEXT_ARG_EXPAND);
#define glTextureColorMaskSGIS_INDEX 2119
#define glTextureColorMaskSGIS_RETURN void
#define glTextureColorMaskSGIS_ARG_NAMES red, green, blue, alpha
#define glTextureColorMaskSGIS_ARG_EXPAND GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha
#define glTextureColorMaskSGIS_PACKED PACKED_glTextureColorMaskSGIS
#define glTextureColorMaskSGIS_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTextureColorMaskSGIS_NOT_VOID_WRAP(...) {}
#define pack_glTextureColorMaskSGIS(_red, _green, _blue, _alpha) ({ \
    glTextureColorMaskSGIS_PACKED *packed_data = malloc(sizeof(glTextureColorMaskSGIS_PACKED)); \
    packed_data->index = glTextureColorMaskSGIS_INDEX; \
    packed_data->args.red = (GLboolean)_red; \
    packed_data->args.green = (GLboolean)_green; \
    packed_data->args.blue = (GLboolean)_blue; \
    packed_data->args.alpha = (GLboolean)_alpha; \
    (packed_call_t *)packed_data; \
})
#define call_glTextureColorMaskSGIS(packed, ret_v) do { \
    PACKED_glTextureColorMaskSGIS *unpacked = (PACKED_glTextureColorMaskSGIS *)packed; \
    ARGS_glTextureColorMaskSGIS *args = (ARGS_glTextureColorMaskSGIS *)&unpacked->args; \
    glTextureColorMaskSGIS(args->red, args->green, args->blue, args->alpha);; \
} while(0)
void glTextureColorMaskSGIS(glTextureColorMaskSGIS_ARG_EXPAND);
typedef void (*glTextureColorMaskSGIS_PTR)(glTextureColorMaskSGIS_ARG_EXPAND);
#define glTextureImage1DEXT_INDEX 2120
#define glTextureImage1DEXT_RETURN void
#define glTextureImage1DEXT_ARG_NAMES texture, target, level, internalformat, width, border, format, type, pixels
#define glTextureImage1DEXT_ARG_EXPAND GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid * pixels
#define glTextureImage1DEXT_PACKED PACKED_glTextureImage1DEXT
#define glTextureImage1DEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTextureImage1DEXT_NOT_VOID_WRAP(...) {}
#define pack_glTextureImage1DEXT(_texture, _target, _level, _internalformat, _width, _border, _format, _type, _pixels) ({ \
    glTextureImage1DEXT_PACKED *packed_data = malloc(sizeof(glTextureImage1DEXT_PACKED)); \
    packed_data->index = glTextureImage1DEXT_INDEX; \
    packed_data->args.texture = (GLuint)_texture; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.level = (GLint)_level; \
    packed_data->args.internalformat = (GLenum)_internalformat; \
    packed_data->args.width = (GLsizei)_width; \
    packed_data->args.border = (GLint)_border; \
    packed_data->args.format = (GLenum)_format; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.pixels = (GLvoid *)_pixels; \
    (packed_call_t *)packed_data; \
})
#define call_glTextureImage1DEXT(packed, ret_v) do { \
    PACKED_glTextureImage1DEXT *unpacked = (PACKED_glTextureImage1DEXT *)packed; \
    ARGS_glTextureImage1DEXT *args = (ARGS_glTextureImage1DEXT *)&unpacked->args; \
    glTextureImage1DEXT(args->texture, args->target, args->level, args->internalformat, args->width, args->border, args->format, args->type, args->pixels);; \
} while(0)
void glTextureImage1DEXT(glTextureImage1DEXT_ARG_EXPAND);
typedef void (*glTextureImage1DEXT_PTR)(glTextureImage1DEXT_ARG_EXPAND);
#define glTextureImage2DEXT_INDEX 2121
#define glTextureImage2DEXT_RETURN void
#define glTextureImage2DEXT_ARG_NAMES texture, target, level, internalformat, width, height, border, format, type, pixels
#define glTextureImage2DEXT_ARG_EXPAND GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid * pixels
#define glTextureImage2DEXT_PACKED PACKED_glTextureImage2DEXT
#define glTextureImage2DEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTextureImage2DEXT_NOT_VOID_WRAP(...) {}
#define pack_glTextureImage2DEXT(_texture, _target, _level, _internalformat, _width, _height, _border, _format, _type, _pixels) ({ \
    glTextureImage2DEXT_PACKED *packed_data = malloc(sizeof(glTextureImage2DEXT_PACKED)); \
    packed_data->index = glTextureImage2DEXT_INDEX; \
    packed_data->args.texture = (GLuint)_texture; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.level = (GLint)_level; \
    packed_data->args.internalformat = (GLenum)_internalformat; \
    packed_data->args.width = (GLsizei)_width; \
    packed_data->args.height = (GLsizei)_height; \
    packed_data->args.border = (GLint)_border; \
    packed_data->args.format = (GLenum)_format; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.pixels = (GLvoid *)_pixels; \
    (packed_call_t *)packed_data; \
})
#define call_glTextureImage2DEXT(packed, ret_v) do { \
    PACKED_glTextureImage2DEXT *unpacked = (PACKED_glTextureImage2DEXT *)packed; \
    ARGS_glTextureImage2DEXT *args = (ARGS_glTextureImage2DEXT *)&unpacked->args; \
    glTextureImage2DEXT(args->texture, args->target, args->level, args->internalformat, args->width, args->height, args->border, args->format, args->type, args->pixels);; \
} while(0)
void glTextureImage2DEXT(glTextureImage2DEXT_ARG_EXPAND);
typedef void (*glTextureImage2DEXT_PTR)(glTextureImage2DEXT_ARG_EXPAND);
#define glTextureImage2DMultisampleCoverageNV_INDEX 2122
#define glTextureImage2DMultisampleCoverageNV_RETURN void
#define glTextureImage2DMultisampleCoverageNV_ARG_NAMES texture, target, coverageSamples, colorSamples, internalFormat, width, height, fixedSampleLocations
#define glTextureImage2DMultisampleCoverageNV_ARG_EXPAND GLuint texture, GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations
#define glTextureImage2DMultisampleCoverageNV_PACKED PACKED_glTextureImage2DMultisampleCoverageNV
#define glTextureImage2DMultisampleCoverageNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTextureImage2DMultisampleCoverageNV_NOT_VOID_WRAP(...) {}
#define pack_glTextureImage2DMultisampleCoverageNV(_texture, _target, _coverageSamples, _colorSamples, _internalFormat, _width, _height, _fixedSampleLocations) ({ \
    glTextureImage2DMultisampleCoverageNV_PACKED *packed_data = malloc(sizeof(glTextureImage2DMultisampleCoverageNV_PACKED)); \
    packed_data->index = glTextureImage2DMultisampleCoverageNV_INDEX; \
    packed_data->args.texture = (GLuint)_texture; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.coverageSamples = (GLsizei)_coverageSamples; \
    packed_data->args.colorSamples = (GLsizei)_colorSamples; \
    packed_data->args.internalFormat = (GLint)_internalFormat; \
    packed_data->args.width = (GLsizei)_width; \
    packed_data->args.height = (GLsizei)_height; \
    packed_data->args.fixedSampleLocations = (GLboolean)_fixedSampleLocations; \
    (packed_call_t *)packed_data; \
})
#define call_glTextureImage2DMultisampleCoverageNV(packed, ret_v) do { \
    PACKED_glTextureImage2DMultisampleCoverageNV *unpacked = (PACKED_glTextureImage2DMultisampleCoverageNV *)packed; \
    ARGS_glTextureImage2DMultisampleCoverageNV *args = (ARGS_glTextureImage2DMultisampleCoverageNV *)&unpacked->args; \
    glTextureImage2DMultisampleCoverageNV(args->texture, args->target, args->coverageSamples, args->colorSamples, args->internalFormat, args->width, args->height, args->fixedSampleLocations);; \
} while(0)
void glTextureImage2DMultisampleCoverageNV(glTextureImage2DMultisampleCoverageNV_ARG_EXPAND);
typedef void (*glTextureImage2DMultisampleCoverageNV_PTR)(glTextureImage2DMultisampleCoverageNV_ARG_EXPAND);
#define glTextureImage2DMultisampleNV_INDEX 2123
#define glTextureImage2DMultisampleNV_RETURN void
#define glTextureImage2DMultisampleNV_ARG_NAMES texture, target, samples, internalFormat, width, height, fixedSampleLocations
#define glTextureImage2DMultisampleNV_ARG_EXPAND GLuint texture, GLenum target, GLsizei samples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations
#define glTextureImage2DMultisampleNV_PACKED PACKED_glTextureImage2DMultisampleNV
#define glTextureImage2DMultisampleNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTextureImage2DMultisampleNV_NOT_VOID_WRAP(...) {}
#define pack_glTextureImage2DMultisampleNV(_texture, _target, _samples, _internalFormat, _width, _height, _fixedSampleLocations) ({ \
    glTextureImage2DMultisampleNV_PACKED *packed_data = malloc(sizeof(glTextureImage2DMultisampleNV_PACKED)); \
    packed_data->index = glTextureImage2DMultisampleNV_INDEX; \
    packed_data->args.texture = (GLuint)_texture; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.samples = (GLsizei)_samples; \
    packed_data->args.internalFormat = (GLint)_internalFormat; \
    packed_data->args.width = (GLsizei)_width; \
    packed_data->args.height = (GLsizei)_height; \
    packed_data->args.fixedSampleLocations = (GLboolean)_fixedSampleLocations; \
    (packed_call_t *)packed_data; \
})
#define call_glTextureImage2DMultisampleNV(packed, ret_v) do { \
    PACKED_glTextureImage2DMultisampleNV *unpacked = (PACKED_glTextureImage2DMultisampleNV *)packed; \
    ARGS_glTextureImage2DMultisampleNV *args = (ARGS_glTextureImage2DMultisampleNV *)&unpacked->args; \
    glTextureImage2DMultisampleNV(args->texture, args->target, args->samples, args->internalFormat, args->width, args->height, args->fixedSampleLocations);; \
} while(0)
void glTextureImage2DMultisampleNV(glTextureImage2DMultisampleNV_ARG_EXPAND);
typedef void (*glTextureImage2DMultisampleNV_PTR)(glTextureImage2DMultisampleNV_ARG_EXPAND);
#define glTextureImage3DEXT_INDEX 2124
#define glTextureImage3DEXT_RETURN void
#define glTextureImage3DEXT_ARG_NAMES texture, target, level, internalformat, width, height, depth, border, format, type, pixels
#define glTextureImage3DEXT_ARG_EXPAND GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid * pixels
#define glTextureImage3DEXT_PACKED PACKED_glTextureImage3DEXT
#define glTextureImage3DEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTextureImage3DEXT_NOT_VOID_WRAP(...) {}
#define pack_glTextureImage3DEXT(_texture, _target, _level, _internalformat, _width, _height, _depth, _border, _format, _type, _pixels) ({ \
    glTextureImage3DEXT_PACKED *packed_data = malloc(sizeof(glTextureImage3DEXT_PACKED)); \
    packed_data->index = glTextureImage3DEXT_INDEX; \
    packed_data->args.texture = (GLuint)_texture; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.level = (GLint)_level; \
    packed_data->args.internalformat = (GLenum)_internalformat; \
    packed_data->args.width = (GLsizei)_width; \
    packed_data->args.height = (GLsizei)_height; \
    packed_data->args.depth = (GLsizei)_depth; \
    packed_data->args.border = (GLint)_border; \
    packed_data->args.format = (GLenum)_format; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.pixels = (GLvoid *)_pixels; \
    (packed_call_t *)packed_data; \
})
#define call_glTextureImage3DEXT(packed, ret_v) do { \
    PACKED_glTextureImage3DEXT *unpacked = (PACKED_glTextureImage3DEXT *)packed; \
    ARGS_glTextureImage3DEXT *args = (ARGS_glTextureImage3DEXT *)&unpacked->args; \
    glTextureImage3DEXT(args->texture, args->target, args->level, args->internalformat, args->width, args->height, args->depth, args->border, args->format, args->type, args->pixels);; \
} while(0)
void glTextureImage3DEXT(glTextureImage3DEXT_ARG_EXPAND);
typedef void (*glTextureImage3DEXT_PTR)(glTextureImage3DEXT_ARG_EXPAND);
#define glTextureImage3DMultisampleCoverageNV_INDEX 2125
#define glTextureImage3DMultisampleCoverageNV_RETURN void
#define glTextureImage3DMultisampleCoverageNV_ARG_NAMES texture, target, coverageSamples, colorSamples, internalFormat, width, height, depth, fixedSampleLocations
#define glTextureImage3DMultisampleCoverageNV_ARG_EXPAND GLuint texture, GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations
#define glTextureImage3DMultisampleCoverageNV_PACKED PACKED_glTextureImage3DMultisampleCoverageNV
#define glTextureImage3DMultisampleCoverageNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTextureImage3DMultisampleCoverageNV_NOT_VOID_WRAP(...) {}
#define pack_glTextureImage3DMultisampleCoverageNV(_texture, _target, _coverageSamples, _colorSamples, _internalFormat, _width, _height, _depth, _fixedSampleLocations) ({ \
    glTextureImage3DMultisampleCoverageNV_PACKED *packed_data = malloc(sizeof(glTextureImage3DMultisampleCoverageNV_PACKED)); \
    packed_data->index = glTextureImage3DMultisampleCoverageNV_INDEX; \
    packed_data->args.texture = (GLuint)_texture; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.coverageSamples = (GLsizei)_coverageSamples; \
    packed_data->args.colorSamples = (GLsizei)_colorSamples; \
    packed_data->args.internalFormat = (GLint)_internalFormat; \
    packed_data->args.width = (GLsizei)_width; \
    packed_data->args.height = (GLsizei)_height; \
    packed_data->args.depth = (GLsizei)_depth; \
    packed_data->args.fixedSampleLocations = (GLboolean)_fixedSampleLocations; \
    (packed_call_t *)packed_data; \
})
#define call_glTextureImage3DMultisampleCoverageNV(packed, ret_v) do { \
    PACKED_glTextureImage3DMultisampleCoverageNV *unpacked = (PACKED_glTextureImage3DMultisampleCoverageNV *)packed; \
    ARGS_glTextureImage3DMultisampleCoverageNV *args = (ARGS_glTextureImage3DMultisampleCoverageNV *)&unpacked->args; \
    glTextureImage3DMultisampleCoverageNV(args->texture, args->target, args->coverageSamples, args->colorSamples, args->internalFormat, args->width, args->height, args->depth, args->fixedSampleLocations);; \
} while(0)
void glTextureImage3DMultisampleCoverageNV(glTextureImage3DMultisampleCoverageNV_ARG_EXPAND);
typedef void (*glTextureImage3DMultisampleCoverageNV_PTR)(glTextureImage3DMultisampleCoverageNV_ARG_EXPAND);
#define glTextureImage3DMultisampleNV_INDEX 2126
#define glTextureImage3DMultisampleNV_RETURN void
#define glTextureImage3DMultisampleNV_ARG_NAMES texture, target, samples, internalFormat, width, height, depth, fixedSampleLocations
#define glTextureImage3DMultisampleNV_ARG_EXPAND GLuint texture, GLenum target, GLsizei samples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations
#define glTextureImage3DMultisampleNV_PACKED PACKED_glTextureImage3DMultisampleNV
#define glTextureImage3DMultisampleNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTextureImage3DMultisampleNV_NOT_VOID_WRAP(...) {}
#define pack_glTextureImage3DMultisampleNV(_texture, _target, _samples, _internalFormat, _width, _height, _depth, _fixedSampleLocations) ({ \
    glTextureImage3DMultisampleNV_PACKED *packed_data = malloc(sizeof(glTextureImage3DMultisampleNV_PACKED)); \
    packed_data->index = glTextureImage3DMultisampleNV_INDEX; \
    packed_data->args.texture = (GLuint)_texture; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.samples = (GLsizei)_samples; \
    packed_data->args.internalFormat = (GLint)_internalFormat; \
    packed_data->args.width = (GLsizei)_width; \
    packed_data->args.height = (GLsizei)_height; \
    packed_data->args.depth = (GLsizei)_depth; \
    packed_data->args.fixedSampleLocations = (GLboolean)_fixedSampleLocations; \
    (packed_call_t *)packed_data; \
})
#define call_glTextureImage3DMultisampleNV(packed, ret_v) do { \
    PACKED_glTextureImage3DMultisampleNV *unpacked = (PACKED_glTextureImage3DMultisampleNV *)packed; \
    ARGS_glTextureImage3DMultisampleNV *args = (ARGS_glTextureImage3DMultisampleNV *)&unpacked->args; \
    glTextureImage3DMultisampleNV(args->texture, args->target, args->samples, args->internalFormat, args->width, args->height, args->depth, args->fixedSampleLocations);; \
} while(0)
void glTextureImage3DMultisampleNV(glTextureImage3DMultisampleNV_ARG_EXPAND);
typedef void (*glTextureImage3DMultisampleNV_PTR)(glTextureImage3DMultisampleNV_ARG_EXPAND);
#define glTextureLightEXT_INDEX 2127
#define glTextureLightEXT_RETURN void
#define glTextureLightEXT_ARG_NAMES pname
#define glTextureLightEXT_ARG_EXPAND GLenum pname
#define glTextureLightEXT_PACKED PACKED_glTextureLightEXT
#define glTextureLightEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTextureLightEXT_NOT_VOID_WRAP(...) {}
#define pack_glTextureLightEXT(_pname) ({ \
    glTextureLightEXT_PACKED *packed_data = malloc(sizeof(glTextureLightEXT_PACKED)); \
    packed_data->index = glTextureLightEXT_INDEX; \
    packed_data->args.pname = (GLenum)_pname; \
    (packed_call_t *)packed_data; \
})
#define call_glTextureLightEXT(packed, ret_v) do { \
    PACKED_glTextureLightEXT *unpacked = (PACKED_glTextureLightEXT *)packed; \
    ARGS_glTextureLightEXT *args = (ARGS_glTextureLightEXT *)&unpacked->args; \
    glTextureLightEXT(args->pname);; \
} while(0)
void glTextureLightEXT(glTextureLightEXT_ARG_EXPAND);
typedef void (*glTextureLightEXT_PTR)(glTextureLightEXT_ARG_EXPAND);
#define glTextureMaterialEXT_INDEX 2128
#define glTextureMaterialEXT_RETURN void
#define glTextureMaterialEXT_ARG_NAMES face, mode
#define glTextureMaterialEXT_ARG_EXPAND GLenum face, GLenum mode
#define glTextureMaterialEXT_PACKED PACKED_glTextureMaterialEXT
#define glTextureMaterialEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTextureMaterialEXT_NOT_VOID_WRAP(...) {}
#define pack_glTextureMaterialEXT(_face, _mode) ({ \
    glTextureMaterialEXT_PACKED *packed_data = malloc(sizeof(glTextureMaterialEXT_PACKED)); \
    packed_data->index = glTextureMaterialEXT_INDEX; \
    packed_data->args.face = (GLenum)_face; \
    packed_data->args.mode = (GLenum)_mode; \
    (packed_call_t *)packed_data; \
})
#define call_glTextureMaterialEXT(packed, ret_v) do { \
    PACKED_glTextureMaterialEXT *unpacked = (PACKED_glTextureMaterialEXT *)packed; \
    ARGS_glTextureMaterialEXT *args = (ARGS_glTextureMaterialEXT *)&unpacked->args; \
    glTextureMaterialEXT(args->face, args->mode);; \
} while(0)
void glTextureMaterialEXT(glTextureMaterialEXT_ARG_EXPAND);
typedef void (*glTextureMaterialEXT_PTR)(glTextureMaterialEXT_ARG_EXPAND);
#define glTextureNormalEXT_INDEX 2129
#define glTextureNormalEXT_RETURN void
#define glTextureNormalEXT_ARG_NAMES mode
#define glTextureNormalEXT_ARG_EXPAND GLenum mode
#define glTextureNormalEXT_PACKED PACKED_glTextureNormalEXT
#define glTextureNormalEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTextureNormalEXT_NOT_VOID_WRAP(...) {}
#define pack_glTextureNormalEXT(_mode) ({ \
    glTextureNormalEXT_PACKED *packed_data = malloc(sizeof(glTextureNormalEXT_PACKED)); \
    packed_data->index = glTextureNormalEXT_INDEX; \
    packed_data->args.mode = (GLenum)_mode; \
    (packed_call_t *)packed_data; \
})
#define call_glTextureNormalEXT(packed, ret_v) do { \
    PACKED_glTextureNormalEXT *unpacked = (PACKED_glTextureNormalEXT *)packed; \
    ARGS_glTextureNormalEXT *args = (ARGS_glTextureNormalEXT *)&unpacked->args; \
    glTextureNormalEXT(args->mode);; \
} while(0)
void glTextureNormalEXT(glTextureNormalEXT_ARG_EXPAND);
typedef void (*glTextureNormalEXT_PTR)(glTextureNormalEXT_ARG_EXPAND);
#define glTextureParameterIivEXT_INDEX 2130
#define glTextureParameterIivEXT_RETURN void
#define glTextureParameterIivEXT_ARG_NAMES texture, target, pname, params
#define glTextureParameterIivEXT_ARG_EXPAND GLuint texture, GLenum target, GLenum pname, const GLint * params
#define glTextureParameterIivEXT_PACKED PACKED_glTextureParameterIivEXT
#define glTextureParameterIivEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTextureParameterIivEXT_NOT_VOID_WRAP(...) {}
#define pack_glTextureParameterIivEXT(_texture, _target, _pname, _params) ({ \
    glTextureParameterIivEXT_PACKED *packed_data = malloc(sizeof(glTextureParameterIivEXT_PACKED)); \
    packed_data->index = glTextureParameterIivEXT_INDEX; \
    packed_data->args.texture = (GLuint)_texture; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glTextureParameterIivEXT(packed, ret_v) do { \
    PACKED_glTextureParameterIivEXT *unpacked = (PACKED_glTextureParameterIivEXT *)packed; \
    ARGS_glTextureParameterIivEXT *args = (ARGS_glTextureParameterIivEXT *)&unpacked->args; \
    glTextureParameterIivEXT(args->texture, args->target, args->pname, args->params);; \
} while(0)
void glTextureParameterIivEXT(glTextureParameterIivEXT_ARG_EXPAND);
typedef void (*glTextureParameterIivEXT_PTR)(glTextureParameterIivEXT_ARG_EXPAND);
#define glTextureParameterIuivEXT_INDEX 2131
#define glTextureParameterIuivEXT_RETURN void
#define glTextureParameterIuivEXT_ARG_NAMES texture, target, pname, params
#define glTextureParameterIuivEXT_ARG_EXPAND GLuint texture, GLenum target, GLenum pname, const GLuint * params
#define glTextureParameterIuivEXT_PACKED PACKED_glTextureParameterIuivEXT
#define glTextureParameterIuivEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTextureParameterIuivEXT_NOT_VOID_WRAP(...) {}
#define pack_glTextureParameterIuivEXT(_texture, _target, _pname, _params) ({ \
    glTextureParameterIuivEXT_PACKED *packed_data = malloc(sizeof(glTextureParameterIuivEXT_PACKED)); \
    packed_data->index = glTextureParameterIuivEXT_INDEX; \
    packed_data->args.texture = (GLuint)_texture; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLuint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glTextureParameterIuivEXT(packed, ret_v) do { \
    PACKED_glTextureParameterIuivEXT *unpacked = (PACKED_glTextureParameterIuivEXT *)packed; \
    ARGS_glTextureParameterIuivEXT *args = (ARGS_glTextureParameterIuivEXT *)&unpacked->args; \
    glTextureParameterIuivEXT(args->texture, args->target, args->pname, args->params);; \
} while(0)
void glTextureParameterIuivEXT(glTextureParameterIuivEXT_ARG_EXPAND);
typedef void (*glTextureParameterIuivEXT_PTR)(glTextureParameterIuivEXT_ARG_EXPAND);
#define glTextureParameterfEXT_INDEX 2132
#define glTextureParameterfEXT_RETURN void
#define glTextureParameterfEXT_ARG_NAMES texture, target, pname, param
#define glTextureParameterfEXT_ARG_EXPAND GLuint texture, GLenum target, GLenum pname, GLfloat param
#define glTextureParameterfEXT_PACKED PACKED_glTextureParameterfEXT
#define glTextureParameterfEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTextureParameterfEXT_NOT_VOID_WRAP(...) {}
#define pack_glTextureParameterfEXT(_texture, _target, _pname, _param) ({ \
    glTextureParameterfEXT_PACKED *packed_data = malloc(sizeof(glTextureParameterfEXT_PACKED)); \
    packed_data->index = glTextureParameterfEXT_INDEX; \
    packed_data->args.texture = (GLuint)_texture; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.param = (GLfloat)_param; \
    (packed_call_t *)packed_data; \
})
#define call_glTextureParameterfEXT(packed, ret_v) do { \
    PACKED_glTextureParameterfEXT *unpacked = (PACKED_glTextureParameterfEXT *)packed; \
    ARGS_glTextureParameterfEXT *args = (ARGS_glTextureParameterfEXT *)&unpacked->args; \
    glTextureParameterfEXT(args->texture, args->target, args->pname, args->param);; \
} while(0)
void glTextureParameterfEXT(glTextureParameterfEXT_ARG_EXPAND);
typedef void (*glTextureParameterfEXT_PTR)(glTextureParameterfEXT_ARG_EXPAND);
#define glTextureParameterfvEXT_INDEX 2133
#define glTextureParameterfvEXT_RETURN void
#define glTextureParameterfvEXT_ARG_NAMES texture, target, pname, params
#define glTextureParameterfvEXT_ARG_EXPAND GLuint texture, GLenum target, GLenum pname, const GLfloat * params
#define glTextureParameterfvEXT_PACKED PACKED_glTextureParameterfvEXT
#define glTextureParameterfvEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTextureParameterfvEXT_NOT_VOID_WRAP(...) {}
#define pack_glTextureParameterfvEXT(_texture, _target, _pname, _params) ({ \
    glTextureParameterfvEXT_PACKED *packed_data = malloc(sizeof(glTextureParameterfvEXT_PACKED)); \
    packed_data->index = glTextureParameterfvEXT_INDEX; \
    packed_data->args.texture = (GLuint)_texture; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLfloat *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glTextureParameterfvEXT(packed, ret_v) do { \
    PACKED_glTextureParameterfvEXT *unpacked = (PACKED_glTextureParameterfvEXT *)packed; \
    ARGS_glTextureParameterfvEXT *args = (ARGS_glTextureParameterfvEXT *)&unpacked->args; \
    glTextureParameterfvEXT(args->texture, args->target, args->pname, args->params);; \
} while(0)
void glTextureParameterfvEXT(glTextureParameterfvEXT_ARG_EXPAND);
typedef void (*glTextureParameterfvEXT_PTR)(glTextureParameterfvEXT_ARG_EXPAND);
#define glTextureParameteriEXT_INDEX 2134
#define glTextureParameteriEXT_RETURN void
#define glTextureParameteriEXT_ARG_NAMES texture, target, pname, param
#define glTextureParameteriEXT_ARG_EXPAND GLuint texture, GLenum target, GLenum pname, GLint param
#define glTextureParameteriEXT_PACKED PACKED_glTextureParameteriEXT
#define glTextureParameteriEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTextureParameteriEXT_NOT_VOID_WRAP(...) {}
#define pack_glTextureParameteriEXT(_texture, _target, _pname, _param) ({ \
    glTextureParameteriEXT_PACKED *packed_data = malloc(sizeof(glTextureParameteriEXT_PACKED)); \
    packed_data->index = glTextureParameteriEXT_INDEX; \
    packed_data->args.texture = (GLuint)_texture; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.param = (GLint)_param; \
    (packed_call_t *)packed_data; \
})
#define call_glTextureParameteriEXT(packed, ret_v) do { \
    PACKED_glTextureParameteriEXT *unpacked = (PACKED_glTextureParameteriEXT *)packed; \
    ARGS_glTextureParameteriEXT *args = (ARGS_glTextureParameteriEXT *)&unpacked->args; \
    glTextureParameteriEXT(args->texture, args->target, args->pname, args->param);; \
} while(0)
void glTextureParameteriEXT(glTextureParameteriEXT_ARG_EXPAND);
typedef void (*glTextureParameteriEXT_PTR)(glTextureParameteriEXT_ARG_EXPAND);
#define glTextureParameterivEXT_INDEX 2135
#define glTextureParameterivEXT_RETURN void
#define glTextureParameterivEXT_ARG_NAMES texture, target, pname, params
#define glTextureParameterivEXT_ARG_EXPAND GLuint texture, GLenum target, GLenum pname, const GLint * params
#define glTextureParameterivEXT_PACKED PACKED_glTextureParameterivEXT
#define glTextureParameterivEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTextureParameterivEXT_NOT_VOID_WRAP(...) {}
#define pack_glTextureParameterivEXT(_texture, _target, _pname, _params) ({ \
    glTextureParameterivEXT_PACKED *packed_data = malloc(sizeof(glTextureParameterivEXT_PACKED)); \
    packed_data->index = glTextureParameterivEXT_INDEX; \
    packed_data->args.texture = (GLuint)_texture; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glTextureParameterivEXT(packed, ret_v) do { \
    PACKED_glTextureParameterivEXT *unpacked = (PACKED_glTextureParameterivEXT *)packed; \
    ARGS_glTextureParameterivEXT *args = (ARGS_glTextureParameterivEXT *)&unpacked->args; \
    glTextureParameterivEXT(args->texture, args->target, args->pname, args->params);; \
} while(0)
void glTextureParameterivEXT(glTextureParameterivEXT_ARG_EXPAND);
typedef void (*glTextureParameterivEXT_PTR)(glTextureParameterivEXT_ARG_EXPAND);
#define glTextureRangeAPPLE_INDEX 2136
#define glTextureRangeAPPLE_RETURN void
#define glTextureRangeAPPLE_ARG_NAMES target, length, pointer
#define glTextureRangeAPPLE_ARG_EXPAND GLenum target, GLsizei length, const GLvoid * pointer
#define glTextureRangeAPPLE_PACKED PACKED_glTextureRangeAPPLE
#define glTextureRangeAPPLE_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTextureRangeAPPLE_NOT_VOID_WRAP(...) {}
#define pack_glTextureRangeAPPLE(_target, _length, _pointer) ({ \
    glTextureRangeAPPLE_PACKED *packed_data = malloc(sizeof(glTextureRangeAPPLE_PACKED)); \
    packed_data->index = glTextureRangeAPPLE_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.length = (GLsizei)_length; \
    packed_data->args.pointer = (GLvoid *)_pointer; \
    (packed_call_t *)packed_data; \
})
#define call_glTextureRangeAPPLE(packed, ret_v) do { \
    PACKED_glTextureRangeAPPLE *unpacked = (PACKED_glTextureRangeAPPLE *)packed; \
    ARGS_glTextureRangeAPPLE *args = (ARGS_glTextureRangeAPPLE *)&unpacked->args; \
    glTextureRangeAPPLE(args->target, args->length, args->pointer);; \
} while(0)
void glTextureRangeAPPLE(glTextureRangeAPPLE_ARG_EXPAND);
typedef void (*glTextureRangeAPPLE_PTR)(glTextureRangeAPPLE_ARG_EXPAND);
#define glTextureRenderbufferEXT_INDEX 2137
#define glTextureRenderbufferEXT_RETURN void
#define glTextureRenderbufferEXT_ARG_NAMES texture, target, renderbuffer
#define glTextureRenderbufferEXT_ARG_EXPAND GLuint texture, GLenum target, GLuint renderbuffer
#define glTextureRenderbufferEXT_PACKED PACKED_glTextureRenderbufferEXT
#define glTextureRenderbufferEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTextureRenderbufferEXT_NOT_VOID_WRAP(...) {}
#define pack_glTextureRenderbufferEXT(_texture, _target, _renderbuffer) ({ \
    glTextureRenderbufferEXT_PACKED *packed_data = malloc(sizeof(glTextureRenderbufferEXT_PACKED)); \
    packed_data->index = glTextureRenderbufferEXT_INDEX; \
    packed_data->args.texture = (GLuint)_texture; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.renderbuffer = (GLuint)_renderbuffer; \
    (packed_call_t *)packed_data; \
})
#define call_glTextureRenderbufferEXT(packed, ret_v) do { \
    PACKED_glTextureRenderbufferEXT *unpacked = (PACKED_glTextureRenderbufferEXT *)packed; \
    ARGS_glTextureRenderbufferEXT *args = (ARGS_glTextureRenderbufferEXT *)&unpacked->args; \
    glTextureRenderbufferEXT(args->texture, args->target, args->renderbuffer);; \
} while(0)
void glTextureRenderbufferEXT(glTextureRenderbufferEXT_ARG_EXPAND);
typedef void (*glTextureRenderbufferEXT_PTR)(glTextureRenderbufferEXT_ARG_EXPAND);
#define glTextureStorage1DEXT_INDEX 2138
#define glTextureStorage1DEXT_RETURN void
#define glTextureStorage1DEXT_ARG_NAMES texture, target, levels, internalformat, width
#define glTextureStorage1DEXT_ARG_EXPAND GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width
#define glTextureStorage1DEXT_PACKED PACKED_glTextureStorage1DEXT
#define glTextureStorage1DEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTextureStorage1DEXT_NOT_VOID_WRAP(...) {}
#define pack_glTextureStorage1DEXT(_texture, _target, _levels, _internalformat, _width) ({ \
    glTextureStorage1DEXT_PACKED *packed_data = malloc(sizeof(glTextureStorage1DEXT_PACKED)); \
    packed_data->index = glTextureStorage1DEXT_INDEX; \
    packed_data->args.texture = (GLuint)_texture; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.levels = (GLsizei)_levels; \
    packed_data->args.internalformat = (GLenum)_internalformat; \
    packed_data->args.width = (GLsizei)_width; \
    (packed_call_t *)packed_data; \
})
#define call_glTextureStorage1DEXT(packed, ret_v) do { \
    PACKED_glTextureStorage1DEXT *unpacked = (PACKED_glTextureStorage1DEXT *)packed; \
    ARGS_glTextureStorage1DEXT *args = (ARGS_glTextureStorage1DEXT *)&unpacked->args; \
    glTextureStorage1DEXT(args->texture, args->target, args->levels, args->internalformat, args->width);; \
} while(0)
void glTextureStorage1DEXT(glTextureStorage1DEXT_ARG_EXPAND);
typedef void (*glTextureStorage1DEXT_PTR)(glTextureStorage1DEXT_ARG_EXPAND);
#define glTextureStorage2DEXT_INDEX 2139
#define glTextureStorage2DEXT_RETURN void
#define glTextureStorage2DEXT_ARG_NAMES texture, target, levels, internalformat, width, height
#define glTextureStorage2DEXT_ARG_EXPAND GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height
#define glTextureStorage2DEXT_PACKED PACKED_glTextureStorage2DEXT
#define glTextureStorage2DEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTextureStorage2DEXT_NOT_VOID_WRAP(...) {}
#define pack_glTextureStorage2DEXT(_texture, _target, _levels, _internalformat, _width, _height) ({ \
    glTextureStorage2DEXT_PACKED *packed_data = malloc(sizeof(glTextureStorage2DEXT_PACKED)); \
    packed_data->index = glTextureStorage2DEXT_INDEX; \
    packed_data->args.texture = (GLuint)_texture; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.levels = (GLsizei)_levels; \
    packed_data->args.internalformat = (GLenum)_internalformat; \
    packed_data->args.width = (GLsizei)_width; \
    packed_data->args.height = (GLsizei)_height; \
    (packed_call_t *)packed_data; \
})
#define call_glTextureStorage2DEXT(packed, ret_v) do { \
    PACKED_glTextureStorage2DEXT *unpacked = (PACKED_glTextureStorage2DEXT *)packed; \
    ARGS_glTextureStorage2DEXT *args = (ARGS_glTextureStorage2DEXT *)&unpacked->args; \
    glTextureStorage2DEXT(args->texture, args->target, args->levels, args->internalformat, args->width, args->height);; \
} while(0)
void glTextureStorage2DEXT(glTextureStorage2DEXT_ARG_EXPAND);
typedef void (*glTextureStorage2DEXT_PTR)(glTextureStorage2DEXT_ARG_EXPAND);
#define glTextureStorage2DMultisampleEXT_INDEX 2140
#define glTextureStorage2DMultisampleEXT_RETURN void
#define glTextureStorage2DMultisampleEXT_ARG_NAMES texture, target, samples, internalformat, width, height, fixedsamplelocations
#define glTextureStorage2DMultisampleEXT_ARG_EXPAND GLuint texture, GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations
#define glTextureStorage2DMultisampleEXT_PACKED PACKED_glTextureStorage2DMultisampleEXT
#define glTextureStorage2DMultisampleEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTextureStorage2DMultisampleEXT_NOT_VOID_WRAP(...) {}
#define pack_glTextureStorage2DMultisampleEXT(_texture, _target, _samples, _internalformat, _width, _height, _fixedsamplelocations) ({ \
    glTextureStorage2DMultisampleEXT_PACKED *packed_data = malloc(sizeof(glTextureStorage2DMultisampleEXT_PACKED)); \
    packed_data->index = glTextureStorage2DMultisampleEXT_INDEX; \
    packed_data->args.texture = (GLuint)_texture; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.samples = (GLsizei)_samples; \
    packed_data->args.internalformat = (GLenum)_internalformat; \
    packed_data->args.width = (GLsizei)_width; \
    packed_data->args.height = (GLsizei)_height; \
    packed_data->args.fixedsamplelocations = (GLboolean)_fixedsamplelocations; \
    (packed_call_t *)packed_data; \
})
#define call_glTextureStorage2DMultisampleEXT(packed, ret_v) do { \
    PACKED_glTextureStorage2DMultisampleEXT *unpacked = (PACKED_glTextureStorage2DMultisampleEXT *)packed; \
    ARGS_glTextureStorage2DMultisampleEXT *args = (ARGS_glTextureStorage2DMultisampleEXT *)&unpacked->args; \
    glTextureStorage2DMultisampleEXT(args->texture, args->target, args->samples, args->internalformat, args->width, args->height, args->fixedsamplelocations);; \
} while(0)
void glTextureStorage2DMultisampleEXT(glTextureStorage2DMultisampleEXT_ARG_EXPAND);
typedef void (*glTextureStorage2DMultisampleEXT_PTR)(glTextureStorage2DMultisampleEXT_ARG_EXPAND);
#define glTextureStorage3DEXT_INDEX 2141
#define glTextureStorage3DEXT_RETURN void
#define glTextureStorage3DEXT_ARG_NAMES texture, target, levels, internalformat, width, height, depth
#define glTextureStorage3DEXT_ARG_EXPAND GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth
#define glTextureStorage3DEXT_PACKED PACKED_glTextureStorage3DEXT
#define glTextureStorage3DEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTextureStorage3DEXT_NOT_VOID_WRAP(...) {}
#define pack_glTextureStorage3DEXT(_texture, _target, _levels, _internalformat, _width, _height, _depth) ({ \
    glTextureStorage3DEXT_PACKED *packed_data = malloc(sizeof(glTextureStorage3DEXT_PACKED)); \
    packed_data->index = glTextureStorage3DEXT_INDEX; \
    packed_data->args.texture = (GLuint)_texture; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.levels = (GLsizei)_levels; \
    packed_data->args.internalformat = (GLenum)_internalformat; \
    packed_data->args.width = (GLsizei)_width; \
    packed_data->args.height = (GLsizei)_height; \
    packed_data->args.depth = (GLsizei)_depth; \
    (packed_call_t *)packed_data; \
})
#define call_glTextureStorage3DEXT(packed, ret_v) do { \
    PACKED_glTextureStorage3DEXT *unpacked = (PACKED_glTextureStorage3DEXT *)packed; \
    ARGS_glTextureStorage3DEXT *args = (ARGS_glTextureStorage3DEXT *)&unpacked->args; \
    glTextureStorage3DEXT(args->texture, args->target, args->levels, args->internalformat, args->width, args->height, args->depth);; \
} while(0)
void glTextureStorage3DEXT(glTextureStorage3DEXT_ARG_EXPAND);
typedef void (*glTextureStorage3DEXT_PTR)(glTextureStorage3DEXT_ARG_EXPAND);
#define glTextureStorage3DMultisampleEXT_INDEX 2142
#define glTextureStorage3DMultisampleEXT_RETURN void
#define glTextureStorage3DMultisampleEXT_ARG_NAMES texture, target, samples, internalformat, width, height, depth, fixedsamplelocations
#define glTextureStorage3DMultisampleEXT_ARG_EXPAND GLuint texture, GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations
#define glTextureStorage3DMultisampleEXT_PACKED PACKED_glTextureStorage3DMultisampleEXT
#define glTextureStorage3DMultisampleEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTextureStorage3DMultisampleEXT_NOT_VOID_WRAP(...) {}
#define pack_glTextureStorage3DMultisampleEXT(_texture, _target, _samples, _internalformat, _width, _height, _depth, _fixedsamplelocations) ({ \
    glTextureStorage3DMultisampleEXT_PACKED *packed_data = malloc(sizeof(glTextureStorage3DMultisampleEXT_PACKED)); \
    packed_data->index = glTextureStorage3DMultisampleEXT_INDEX; \
    packed_data->args.texture = (GLuint)_texture; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.samples = (GLsizei)_samples; \
    packed_data->args.internalformat = (GLenum)_internalformat; \
    packed_data->args.width = (GLsizei)_width; \
    packed_data->args.height = (GLsizei)_height; \
    packed_data->args.depth = (GLsizei)_depth; \
    packed_data->args.fixedsamplelocations = (GLboolean)_fixedsamplelocations; \
    (packed_call_t *)packed_data; \
})
#define call_glTextureStorage3DMultisampleEXT(packed, ret_v) do { \
    PACKED_glTextureStorage3DMultisampleEXT *unpacked = (PACKED_glTextureStorage3DMultisampleEXT *)packed; \
    ARGS_glTextureStorage3DMultisampleEXT *args = (ARGS_glTextureStorage3DMultisampleEXT *)&unpacked->args; \
    glTextureStorage3DMultisampleEXT(args->texture, args->target, args->samples, args->internalformat, args->width, args->height, args->depth, args->fixedsamplelocations);; \
} while(0)
void glTextureStorage3DMultisampleEXT(glTextureStorage3DMultisampleEXT_ARG_EXPAND);
typedef void (*glTextureStorage3DMultisampleEXT_PTR)(glTextureStorage3DMultisampleEXT_ARG_EXPAND);
#define glTextureStorageSparseAMD_INDEX 2143
#define glTextureStorageSparseAMD_RETURN void
#define glTextureStorageSparseAMD_ARG_NAMES texture, target, internalFormat, width, height, depth, layers, flags
#define glTextureStorageSparseAMD_ARG_EXPAND GLuint texture, GLenum target, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLsizei layers, GLbitfield flags
#define glTextureStorageSparseAMD_PACKED PACKED_glTextureStorageSparseAMD
#define glTextureStorageSparseAMD_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTextureStorageSparseAMD_NOT_VOID_WRAP(...) {}
#define pack_glTextureStorageSparseAMD(_texture, _target, _internalFormat, _width, _height, _depth, _layers, _flags) ({ \
    glTextureStorageSparseAMD_PACKED *packed_data = malloc(sizeof(glTextureStorageSparseAMD_PACKED)); \
    packed_data->index = glTextureStorageSparseAMD_INDEX; \
    packed_data->args.texture = (GLuint)_texture; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.internalFormat = (GLenum)_internalFormat; \
    packed_data->args.width = (GLsizei)_width; \
    packed_data->args.height = (GLsizei)_height; \
    packed_data->args.depth = (GLsizei)_depth; \
    packed_data->args.layers = (GLsizei)_layers; \
    packed_data->args.flags = (GLbitfield)_flags; \
    (packed_call_t *)packed_data; \
})
#define call_glTextureStorageSparseAMD(packed, ret_v) do { \
    PACKED_glTextureStorageSparseAMD *unpacked = (PACKED_glTextureStorageSparseAMD *)packed; \
    ARGS_glTextureStorageSparseAMD *args = (ARGS_glTextureStorageSparseAMD *)&unpacked->args; \
    glTextureStorageSparseAMD(args->texture, args->target, args->internalFormat, args->width, args->height, args->depth, args->layers, args->flags);; \
} while(0)
void glTextureStorageSparseAMD(glTextureStorageSparseAMD_ARG_EXPAND);
typedef void (*glTextureStorageSparseAMD_PTR)(glTextureStorageSparseAMD_ARG_EXPAND);
#define glTextureSubImage1DEXT_INDEX 2144
#define glTextureSubImage1DEXT_RETURN void
#define glTextureSubImage1DEXT_ARG_NAMES texture, target, level, xoffset, width, format, type, pixels
#define glTextureSubImage1DEXT_ARG_EXPAND GLuint texture, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid * pixels
#define glTextureSubImage1DEXT_PACKED PACKED_glTextureSubImage1DEXT
#define glTextureSubImage1DEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTextureSubImage1DEXT_NOT_VOID_WRAP(...) {}
#define pack_glTextureSubImage1DEXT(_texture, _target, _level, _xoffset, _width, _format, _type, _pixels) ({ \
    glTextureSubImage1DEXT_PACKED *packed_data = malloc(sizeof(glTextureSubImage1DEXT_PACKED)); \
    packed_data->index = glTextureSubImage1DEXT_INDEX; \
    packed_data->args.texture = (GLuint)_texture; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.level = (GLint)_level; \
    packed_data->args.xoffset = (GLint)_xoffset; \
    packed_data->args.width = (GLsizei)_width; \
    packed_data->args.format = (GLenum)_format; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.pixels = (GLvoid *)_pixels; \
    (packed_call_t *)packed_data; \
})
#define call_glTextureSubImage1DEXT(packed, ret_v) do { \
    PACKED_glTextureSubImage1DEXT *unpacked = (PACKED_glTextureSubImage1DEXT *)packed; \
    ARGS_glTextureSubImage1DEXT *args = (ARGS_glTextureSubImage1DEXT *)&unpacked->args; \
    glTextureSubImage1DEXT(args->texture, args->target, args->level, args->xoffset, args->width, args->format, args->type, args->pixels);; \
} while(0)
void glTextureSubImage1DEXT(glTextureSubImage1DEXT_ARG_EXPAND);
typedef void (*glTextureSubImage1DEXT_PTR)(glTextureSubImage1DEXT_ARG_EXPAND);
#define glTextureSubImage2DEXT_INDEX 2145
#define glTextureSubImage2DEXT_RETURN void
#define glTextureSubImage2DEXT_ARG_NAMES texture, target, level, xoffset, yoffset, width, height, format, type, pixels
#define glTextureSubImage2DEXT_ARG_EXPAND GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid * pixels
#define glTextureSubImage2DEXT_PACKED PACKED_glTextureSubImage2DEXT
#define glTextureSubImage2DEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTextureSubImage2DEXT_NOT_VOID_WRAP(...) {}
#define pack_glTextureSubImage2DEXT(_texture, _target, _level, _xoffset, _yoffset, _width, _height, _format, _type, _pixels) ({ \
    glTextureSubImage2DEXT_PACKED *packed_data = malloc(sizeof(glTextureSubImage2DEXT_PACKED)); \
    packed_data->index = glTextureSubImage2DEXT_INDEX; \
    packed_data->args.texture = (GLuint)_texture; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.level = (GLint)_level; \
    packed_data->args.xoffset = (GLint)_xoffset; \
    packed_data->args.yoffset = (GLint)_yoffset; \
    packed_data->args.width = (GLsizei)_width; \
    packed_data->args.height = (GLsizei)_height; \
    packed_data->args.format = (GLenum)_format; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.pixels = (GLvoid *)_pixels; \
    (packed_call_t *)packed_data; \
})
#define call_glTextureSubImage2DEXT(packed, ret_v) do { \
    PACKED_glTextureSubImage2DEXT *unpacked = (PACKED_glTextureSubImage2DEXT *)packed; \
    ARGS_glTextureSubImage2DEXT *args = (ARGS_glTextureSubImage2DEXT *)&unpacked->args; \
    glTextureSubImage2DEXT(args->texture, args->target, args->level, args->xoffset, args->yoffset, args->width, args->height, args->format, args->type, args->pixels);; \
} while(0)
void glTextureSubImage2DEXT(glTextureSubImage2DEXT_ARG_EXPAND);
typedef void (*glTextureSubImage2DEXT_PTR)(glTextureSubImage2DEXT_ARG_EXPAND);
#define glTextureSubImage3DEXT_INDEX 2146
#define glTextureSubImage3DEXT_RETURN void
#define glTextureSubImage3DEXT_ARG_NAMES texture, target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels
#define glTextureSubImage3DEXT_ARG_EXPAND GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid * pixels
#define glTextureSubImage3DEXT_PACKED PACKED_glTextureSubImage3DEXT
#define glTextureSubImage3DEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTextureSubImage3DEXT_NOT_VOID_WRAP(...) {}
#define pack_glTextureSubImage3DEXT(_texture, _target, _level, _xoffset, _yoffset, _zoffset, _width, _height, _depth, _format, _type, _pixels) ({ \
    glTextureSubImage3DEXT_PACKED *packed_data = malloc(sizeof(glTextureSubImage3DEXT_PACKED)); \
    packed_data->index = glTextureSubImage3DEXT_INDEX; \
    packed_data->args.texture = (GLuint)_texture; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.level = (GLint)_level; \
    packed_data->args.xoffset = (GLint)_xoffset; \
    packed_data->args.yoffset = (GLint)_yoffset; \
    packed_data->args.zoffset = (GLint)_zoffset; \
    packed_data->args.width = (GLsizei)_width; \
    packed_data->args.height = (GLsizei)_height; \
    packed_data->args.depth = (GLsizei)_depth; \
    packed_data->args.format = (GLenum)_format; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.pixels = (GLvoid *)_pixels; \
    (packed_call_t *)packed_data; \
})
#define call_glTextureSubImage3DEXT(packed, ret_v) do { \
    PACKED_glTextureSubImage3DEXT *unpacked = (PACKED_glTextureSubImage3DEXT *)packed; \
    ARGS_glTextureSubImage3DEXT *args = (ARGS_glTextureSubImage3DEXT *)&unpacked->args; \
    glTextureSubImage3DEXT(args->texture, args->target, args->level, args->xoffset, args->yoffset, args->zoffset, args->width, args->height, args->depth, args->format, args->type, args->pixels);; \
} while(0)
void glTextureSubImage3DEXT(glTextureSubImage3DEXT_ARG_EXPAND);
typedef void (*glTextureSubImage3DEXT_PTR)(glTextureSubImage3DEXT_ARG_EXPAND);
#define glTextureView_INDEX 2147
#define glTextureView_RETURN void
#define glTextureView_ARG_NAMES texture, target, origtexture, internalformat, minlevel, numlevels, minlayer, numlayers
#define glTextureView_ARG_EXPAND GLuint texture, GLenum target, GLuint origtexture, GLenum internalformat, GLuint minlevel, GLuint numlevels, GLuint minlayer, GLuint numlayers
#define glTextureView_PACKED PACKED_glTextureView
#define glTextureView_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTextureView_NOT_VOID_WRAP(...) {}
#define pack_glTextureView(_texture, _target, _origtexture, _internalformat, _minlevel, _numlevels, _minlayer, _numlayers) ({ \
    glTextureView_PACKED *packed_data = malloc(sizeof(glTextureView_PACKED)); \
    packed_data->index = glTextureView_INDEX; \
    packed_data->args.texture = (GLuint)_texture; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.origtexture = (GLuint)_origtexture; \
    packed_data->args.internalformat = (GLenum)_internalformat; \
    packed_data->args.minlevel = (GLuint)_minlevel; \
    packed_data->args.numlevels = (GLuint)_numlevels; \
    packed_data->args.minlayer = (GLuint)_minlayer; \
    packed_data->args.numlayers = (GLuint)_numlayers; \
    (packed_call_t *)packed_data; \
})
#define call_glTextureView(packed, ret_v) do { \
    PACKED_glTextureView *unpacked = (PACKED_glTextureView *)packed; \
    ARGS_glTextureView *args = (ARGS_glTextureView *)&unpacked->args; \
    glTextureView(args->texture, args->target, args->origtexture, args->internalformat, args->minlevel, args->numlevels, args->minlayer, args->numlayers);; \
} while(0)
void glTextureView(glTextureView_ARG_EXPAND);
typedef void (*glTextureView_PTR)(glTextureView_ARG_EXPAND);
#define glTrackMatrixNV_INDEX 2148
#define glTrackMatrixNV_RETURN void
#define glTrackMatrixNV_ARG_NAMES target, address, matrix, transform
#define glTrackMatrixNV_ARG_EXPAND GLenum target, GLuint address, GLenum matrix, GLenum transform
#define glTrackMatrixNV_PACKED PACKED_glTrackMatrixNV
#define glTrackMatrixNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTrackMatrixNV_NOT_VOID_WRAP(...) {}
#define pack_glTrackMatrixNV(_target, _address, _matrix, _transform) ({ \
    glTrackMatrixNV_PACKED *packed_data = malloc(sizeof(glTrackMatrixNV_PACKED)); \
    packed_data->index = glTrackMatrixNV_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.address = (GLuint)_address; \
    packed_data->args.matrix = (GLenum)_matrix; \
    packed_data->args.transform = (GLenum)_transform; \
    (packed_call_t *)packed_data; \
})
#define call_glTrackMatrixNV(packed, ret_v) do { \
    PACKED_glTrackMatrixNV *unpacked = (PACKED_glTrackMatrixNV *)packed; \
    ARGS_glTrackMatrixNV *args = (ARGS_glTrackMatrixNV *)&unpacked->args; \
    glTrackMatrixNV(args->target, args->address, args->matrix, args->transform);; \
} while(0)
void glTrackMatrixNV(glTrackMatrixNV_ARG_EXPAND);
typedef void (*glTrackMatrixNV_PTR)(glTrackMatrixNV_ARG_EXPAND);
#define glTransformFeedbackAttribsNV_INDEX 2149
#define glTransformFeedbackAttribsNV_RETURN void
#define glTransformFeedbackAttribsNV_ARG_NAMES count, attribs, bufferMode
#define glTransformFeedbackAttribsNV_ARG_EXPAND GLsizei count, const GLint * attribs, GLenum bufferMode
#define glTransformFeedbackAttribsNV_PACKED PACKED_glTransformFeedbackAttribsNV
#define glTransformFeedbackAttribsNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTransformFeedbackAttribsNV_NOT_VOID_WRAP(...) {}
#define pack_glTransformFeedbackAttribsNV(_count, _attribs, _bufferMode) ({ \
    glTransformFeedbackAttribsNV_PACKED *packed_data = malloc(sizeof(glTransformFeedbackAttribsNV_PACKED)); \
    packed_data->index = glTransformFeedbackAttribsNV_INDEX; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.attribs = (GLint *)_attribs; \
    packed_data->args.bufferMode = (GLenum)_bufferMode; \
    (packed_call_t *)packed_data; \
})
#define call_glTransformFeedbackAttribsNV(packed, ret_v) do { \
    PACKED_glTransformFeedbackAttribsNV *unpacked = (PACKED_glTransformFeedbackAttribsNV *)packed; \
    ARGS_glTransformFeedbackAttribsNV *args = (ARGS_glTransformFeedbackAttribsNV *)&unpacked->args; \
    glTransformFeedbackAttribsNV(args->count, args->attribs, args->bufferMode);; \
} while(0)
void glTransformFeedbackAttribsNV(glTransformFeedbackAttribsNV_ARG_EXPAND);
typedef void (*glTransformFeedbackAttribsNV_PTR)(glTransformFeedbackAttribsNV_ARG_EXPAND);
#define glTransformFeedbackStreamAttribsNV_INDEX 2150
#define glTransformFeedbackStreamAttribsNV_RETURN void
#define glTransformFeedbackStreamAttribsNV_ARG_NAMES count, attribs, nbuffers, bufstreams, bufferMode
#define glTransformFeedbackStreamAttribsNV_ARG_EXPAND GLsizei count, const GLint * attribs, GLsizei nbuffers, const GLint * bufstreams, GLenum bufferMode
#define glTransformFeedbackStreamAttribsNV_PACKED PACKED_glTransformFeedbackStreamAttribsNV
#define glTransformFeedbackStreamAttribsNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTransformFeedbackStreamAttribsNV_NOT_VOID_WRAP(...) {}
#define pack_glTransformFeedbackStreamAttribsNV(_count, _attribs, _nbuffers, _bufstreams, _bufferMode) ({ \
    glTransformFeedbackStreamAttribsNV_PACKED *packed_data = malloc(sizeof(glTransformFeedbackStreamAttribsNV_PACKED)); \
    packed_data->index = glTransformFeedbackStreamAttribsNV_INDEX; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.attribs = (GLint *)_attribs; \
    packed_data->args.nbuffers = (GLsizei)_nbuffers; \
    packed_data->args.bufstreams = (GLint *)_bufstreams; \
    packed_data->args.bufferMode = (GLenum)_bufferMode; \
    (packed_call_t *)packed_data; \
})
#define call_glTransformFeedbackStreamAttribsNV(packed, ret_v) do { \
    PACKED_glTransformFeedbackStreamAttribsNV *unpacked = (PACKED_glTransformFeedbackStreamAttribsNV *)packed; \
    ARGS_glTransformFeedbackStreamAttribsNV *args = (ARGS_glTransformFeedbackStreamAttribsNV *)&unpacked->args; \
    glTransformFeedbackStreamAttribsNV(args->count, args->attribs, args->nbuffers, args->bufstreams, args->bufferMode);; \
} while(0)
void glTransformFeedbackStreamAttribsNV(glTransformFeedbackStreamAttribsNV_ARG_EXPAND);
typedef void (*glTransformFeedbackStreamAttribsNV_PTR)(glTransformFeedbackStreamAttribsNV_ARG_EXPAND);
#define glTransformFeedbackVaryings_INDEX 2151
#define glTransformFeedbackVaryings_RETURN void
#define glTransformFeedbackVaryings_ARG_NAMES program, count, varyings, bufferMode
#define glTransformFeedbackVaryings_ARG_EXPAND GLuint program, GLsizei count, GLchar*const * varyings, GLenum bufferMode
#define glTransformFeedbackVaryings_PACKED PACKED_glTransformFeedbackVaryings
#define glTransformFeedbackVaryings_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTransformFeedbackVaryings_NOT_VOID_WRAP(...) {}
#define pack_glTransformFeedbackVaryings(_program, _count, _varyings, _bufferMode) ({ \
    glTransformFeedbackVaryings_PACKED *packed_data = malloc(sizeof(glTransformFeedbackVaryings_PACKED)); \
    packed_data->index = glTransformFeedbackVaryings_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.varyings = (GLchar*const *)_varyings; \
    packed_data->args.bufferMode = (GLenum)_bufferMode; \
    (packed_call_t *)packed_data; \
})
#define call_glTransformFeedbackVaryings(packed, ret_v) do { \
    PACKED_glTransformFeedbackVaryings *unpacked = (PACKED_glTransformFeedbackVaryings *)packed; \
    ARGS_glTransformFeedbackVaryings *args = (ARGS_glTransformFeedbackVaryings *)&unpacked->args; \
    glTransformFeedbackVaryings(args->program, args->count, args->varyings, args->bufferMode);; \
} while(0)
void glTransformFeedbackVaryings(glTransformFeedbackVaryings_ARG_EXPAND);
typedef void (*glTransformFeedbackVaryings_PTR)(glTransformFeedbackVaryings_ARG_EXPAND);
#define glTransformFeedbackVaryingsEXT_INDEX 2152
#define glTransformFeedbackVaryingsEXT_RETURN void
#define glTransformFeedbackVaryingsEXT_ARG_NAMES program, count, varyings, bufferMode
#define glTransformFeedbackVaryingsEXT_ARG_EXPAND GLuint program, GLsizei count, const GLchar * varyings, GLenum bufferMode
#define glTransformFeedbackVaryingsEXT_PACKED PACKED_glTransformFeedbackVaryingsEXT
#define glTransformFeedbackVaryingsEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTransformFeedbackVaryingsEXT_NOT_VOID_WRAP(...) {}
#define pack_glTransformFeedbackVaryingsEXT(_program, _count, _varyings, _bufferMode) ({ \
    glTransformFeedbackVaryingsEXT_PACKED *packed_data = malloc(sizeof(glTransformFeedbackVaryingsEXT_PACKED)); \
    packed_data->index = glTransformFeedbackVaryingsEXT_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.varyings = (GLchar *)_varyings; \
    packed_data->args.bufferMode = (GLenum)_bufferMode; \
    (packed_call_t *)packed_data; \
})
#define call_glTransformFeedbackVaryingsEXT(packed, ret_v) do { \
    PACKED_glTransformFeedbackVaryingsEXT *unpacked = (PACKED_glTransformFeedbackVaryingsEXT *)packed; \
    ARGS_glTransformFeedbackVaryingsEXT *args = (ARGS_glTransformFeedbackVaryingsEXT *)&unpacked->args; \
    glTransformFeedbackVaryingsEXT(args->program, args->count, args->varyings, args->bufferMode);; \
} while(0)
void glTransformFeedbackVaryingsEXT(glTransformFeedbackVaryingsEXT_ARG_EXPAND);
typedef void (*glTransformFeedbackVaryingsEXT_PTR)(glTransformFeedbackVaryingsEXT_ARG_EXPAND);
#define glTransformFeedbackVaryingsNV_INDEX 2153
#define glTransformFeedbackVaryingsNV_RETURN void
#define glTransformFeedbackVaryingsNV_ARG_NAMES program, count, locations, bufferMode
#define glTransformFeedbackVaryingsNV_ARG_EXPAND GLuint program, GLsizei count, const GLint * locations, GLenum bufferMode
#define glTransformFeedbackVaryingsNV_PACKED PACKED_glTransformFeedbackVaryingsNV
#define glTransformFeedbackVaryingsNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTransformFeedbackVaryingsNV_NOT_VOID_WRAP(...) {}
#define pack_glTransformFeedbackVaryingsNV(_program, _count, _locations, _bufferMode) ({ \
    glTransformFeedbackVaryingsNV_PACKED *packed_data = malloc(sizeof(glTransformFeedbackVaryingsNV_PACKED)); \
    packed_data->index = glTransformFeedbackVaryingsNV_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.locations = (GLint *)_locations; \
    packed_data->args.bufferMode = (GLenum)_bufferMode; \
    (packed_call_t *)packed_data; \
})
#define call_glTransformFeedbackVaryingsNV(packed, ret_v) do { \
    PACKED_glTransformFeedbackVaryingsNV *unpacked = (PACKED_glTransformFeedbackVaryingsNV *)packed; \
    ARGS_glTransformFeedbackVaryingsNV *args = (ARGS_glTransformFeedbackVaryingsNV *)&unpacked->args; \
    glTransformFeedbackVaryingsNV(args->program, args->count, args->locations, args->bufferMode);; \
} while(0)
void glTransformFeedbackVaryingsNV(glTransformFeedbackVaryingsNV_ARG_EXPAND);
typedef void (*glTransformFeedbackVaryingsNV_PTR)(glTransformFeedbackVaryingsNV_ARG_EXPAND);
#define glTransformPathNV_INDEX 2154
#define glTransformPathNV_RETURN void
#define glTransformPathNV_ARG_NAMES resultPath, srcPath, transformType, transformValues
#define glTransformPathNV_ARG_EXPAND GLuint resultPath, GLuint srcPath, GLenum transformType, const GLfloat * transformValues
#define glTransformPathNV_PACKED PACKED_glTransformPathNV
#define glTransformPathNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTransformPathNV_NOT_VOID_WRAP(...) {}
#define pack_glTransformPathNV(_resultPath, _srcPath, _transformType, _transformValues) ({ \
    glTransformPathNV_PACKED *packed_data = malloc(sizeof(glTransformPathNV_PACKED)); \
    packed_data->index = glTransformPathNV_INDEX; \
    packed_data->args.resultPath = (GLuint)_resultPath; \
    packed_data->args.srcPath = (GLuint)_srcPath; \
    packed_data->args.transformType = (GLenum)_transformType; \
    packed_data->args.transformValues = (GLfloat *)_transformValues; \
    (packed_call_t *)packed_data; \
})
#define call_glTransformPathNV(packed, ret_v) do { \
    PACKED_glTransformPathNV *unpacked = (PACKED_glTransformPathNV *)packed; \
    ARGS_glTransformPathNV *args = (ARGS_glTransformPathNV *)&unpacked->args; \
    glTransformPathNV(args->resultPath, args->srcPath, args->transformType, args->transformValues);; \
} while(0)
void glTransformPathNV(glTransformPathNV_ARG_EXPAND);
typedef void (*glTransformPathNV_PTR)(glTransformPathNV_ARG_EXPAND);
#define glTranslated_INDEX 2155
#define glTranslated_RETURN void
#define glTranslated_ARG_NAMES x, y, z
#define glTranslated_ARG_EXPAND GLdouble x, GLdouble y, GLdouble z
#define glTranslated_PACKED PACKED_glTranslated
#define glTranslated_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTranslated_NOT_VOID_WRAP(...) {}
#define pack_glTranslated(_x, _y, _z) ({ \
    glTranslated_PACKED *packed_data = malloc(sizeof(glTranslated_PACKED)); \
    packed_data->index = glTranslated_INDEX; \
    packed_data->args.x = (GLdouble)_x; \
    packed_data->args.y = (GLdouble)_y; \
    packed_data->args.z = (GLdouble)_z; \
    (packed_call_t *)packed_data; \
})
#define call_glTranslated(packed, ret_v) do { \
    PACKED_glTranslated *unpacked = (PACKED_glTranslated *)packed; \
    ARGS_glTranslated *args = (ARGS_glTranslated *)&unpacked->args; \
    glTranslated(args->x, args->y, args->z);; \
} while(0)
void glTranslated(glTranslated_ARG_EXPAND);
typedef void (*glTranslated_PTR)(glTranslated_ARG_EXPAND);
#define glTranslatef_INDEX 2156
#define glTranslatef_RETURN void
#define glTranslatef_ARG_NAMES x, y, z
#define glTranslatef_ARG_EXPAND GLfloat x, GLfloat y, GLfloat z
#define glTranslatef_PACKED PACKED_glTranslatef
#define glTranslatef_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTranslatef_NOT_VOID_WRAP(...) {}
#define pack_glTranslatef(_x, _y, _z) ({ \
    glTranslatef_PACKED *packed_data = malloc(sizeof(glTranslatef_PACKED)); \
    packed_data->index = glTranslatef_INDEX; \
    packed_data->args.x = (GLfloat)_x; \
    packed_data->args.y = (GLfloat)_y; \
    packed_data->args.z = (GLfloat)_z; \
    (packed_call_t *)packed_data; \
})
#define call_glTranslatef(packed, ret_v) do { \
    PACKED_glTranslatef *unpacked = (PACKED_glTranslatef *)packed; \
    ARGS_glTranslatef *args = (ARGS_glTranslatef *)&unpacked->args; \
    glTranslatef(args->x, args->y, args->z);; \
} while(0)
void glTranslatef(glTranslatef_ARG_EXPAND);
typedef void (*glTranslatef_PTR)(glTranslatef_ARG_EXPAND);
#define glTranslatex_INDEX 2157
#define glTranslatex_RETURN void
#define glTranslatex_ARG_NAMES x, y, z
#define glTranslatex_ARG_EXPAND GLfixed x, GLfixed y, GLfixed z
#define glTranslatex_PACKED PACKED_glTranslatex
#define glTranslatex_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTranslatex_NOT_VOID_WRAP(...) {}
#define pack_glTranslatex(_x, _y, _z) ({ \
    glTranslatex_PACKED *packed_data = malloc(sizeof(glTranslatex_PACKED)); \
    packed_data->index = glTranslatex_INDEX; \
    packed_data->args.x = (GLfixed)_x; \
    packed_data->args.y = (GLfixed)_y; \
    packed_data->args.z = (GLfixed)_z; \
    (packed_call_t *)packed_data; \
})
#define call_glTranslatex(packed, ret_v) do { \
    PACKED_glTranslatex *unpacked = (PACKED_glTranslatex *)packed; \
    ARGS_glTranslatex *args = (ARGS_glTranslatex *)&unpacked->args; \
    glTranslatex(args->x, args->y, args->z);; \
} while(0)
void glTranslatex(glTranslatex_ARG_EXPAND);
typedef void (*glTranslatex_PTR)(glTranslatex_ARG_EXPAND);
#define glTranslatexOES_INDEX 2158
#define glTranslatexOES_RETURN void
#define glTranslatexOES_ARG_NAMES x, y, z
#define glTranslatexOES_ARG_EXPAND GLfixed x, GLfixed y, GLfixed z
#define glTranslatexOES_PACKED PACKED_glTranslatexOES
#define glTranslatexOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glTranslatexOES_NOT_VOID_WRAP(...) {}
#define pack_glTranslatexOES(_x, _y, _z) ({ \
    glTranslatexOES_PACKED *packed_data = malloc(sizeof(glTranslatexOES_PACKED)); \
    packed_data->index = glTranslatexOES_INDEX; \
    packed_data->args.x = (GLfixed)_x; \
    packed_data->args.y = (GLfixed)_y; \
    packed_data->args.z = (GLfixed)_z; \
    (packed_call_t *)packed_data; \
})
#define call_glTranslatexOES(packed, ret_v) do { \
    PACKED_glTranslatexOES *unpacked = (PACKED_glTranslatexOES *)packed; \
    ARGS_glTranslatexOES *args = (ARGS_glTranslatexOES *)&unpacked->args; \
    glTranslatexOES(args->x, args->y, args->z);; \
} while(0)
void glTranslatexOES(glTranslatexOES_ARG_EXPAND);
typedef void (*glTranslatexOES_PTR)(glTranslatexOES_ARG_EXPAND);
#define glUniform1d_INDEX 2159
#define glUniform1d_RETURN void
#define glUniform1d_ARG_NAMES location, x
#define glUniform1d_ARG_EXPAND GLint location, GLdouble x
#define glUniform1d_PACKED PACKED_glUniform1d
#define glUniform1d_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glUniform1d_NOT_VOID_WRAP(...) {}
#define pack_glUniform1d(_location, _x) ({ \
    glUniform1d_PACKED *packed_data = malloc(sizeof(glUniform1d_PACKED)); \
    packed_data->index = glUniform1d_INDEX; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.x = (GLdouble)_x; \
    (packed_call_t *)packed_data; \
})
#define call_glUniform1d(packed, ret_v) do { \
    PACKED_glUniform1d *unpacked = (PACKED_glUniform1d *)packed; \
    ARGS_glUniform1d *args = (ARGS_glUniform1d *)&unpacked->args; \
    glUniform1d(args->location, args->x);; \
} while(0)
void glUniform1d(glUniform1d_ARG_EXPAND);
typedef void (*glUniform1d_PTR)(glUniform1d_ARG_EXPAND);
#define glUniform1dv_INDEX 2160
#define glUniform1dv_RETURN void
#define glUniform1dv_ARG_NAMES location, count, value
#define glUniform1dv_ARG_EXPAND GLint location, GLsizei count, const GLdouble * value
#define glUniform1dv_PACKED PACKED_glUniform1dv
#define glUniform1dv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glUniform1dv_NOT_VOID_WRAP(...) {}
#define pack_glUniform1dv(_location, _count, _value) ({ \
    glUniform1dv_PACKED *packed_data = malloc(sizeof(glUniform1dv_PACKED)); \
    packed_data->index = glUniform1dv_INDEX; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.value = (GLdouble *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glUniform1dv(packed, ret_v) do { \
    PACKED_glUniform1dv *unpacked = (PACKED_glUniform1dv *)packed; \
    ARGS_glUniform1dv *args = (ARGS_glUniform1dv *)&unpacked->args; \
    glUniform1dv(args->location, args->count, args->value);; \
} while(0)
void glUniform1dv(glUniform1dv_ARG_EXPAND);
typedef void (*glUniform1dv_PTR)(glUniform1dv_ARG_EXPAND);
#define glUniform1f_INDEX 2161
#define glUniform1f_RETURN void
#define glUniform1f_ARG_NAMES location, v0
#define glUniform1f_ARG_EXPAND GLint location, GLfloat v0
#define glUniform1f_PACKED PACKED_glUniform1f
#define glUniform1f_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glUniform1f_NOT_VOID_WRAP(...) {}
#define pack_glUniform1f(_location, _v0) ({ \
    glUniform1f_PACKED *packed_data = malloc(sizeof(glUniform1f_PACKED)); \
    packed_data->index = glUniform1f_INDEX; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.v0 = (GLfloat)_v0; \
    (packed_call_t *)packed_data; \
})
#define call_glUniform1f(packed, ret_v) do { \
    PACKED_glUniform1f *unpacked = (PACKED_glUniform1f *)packed; \
    ARGS_glUniform1f *args = (ARGS_glUniform1f *)&unpacked->args; \
    glUniform1f(args->location, args->v0);; \
} while(0)
void glUniform1f(glUniform1f_ARG_EXPAND);
typedef void (*glUniform1f_PTR)(glUniform1f_ARG_EXPAND);
#define glUniform1fARB_INDEX 2162
#define glUniform1fARB_RETURN void
#define glUniform1fARB_ARG_NAMES location, v0
#define glUniform1fARB_ARG_EXPAND GLint location, GLfloat v0
#define glUniform1fARB_PACKED PACKED_glUniform1fARB
#define glUniform1fARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glUniform1fARB_NOT_VOID_WRAP(...) {}
#define pack_glUniform1fARB(_location, _v0) ({ \
    glUniform1fARB_PACKED *packed_data = malloc(sizeof(glUniform1fARB_PACKED)); \
    packed_data->index = glUniform1fARB_INDEX; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.v0 = (GLfloat)_v0; \
    (packed_call_t *)packed_data; \
})
#define call_glUniform1fARB(packed, ret_v) do { \
    PACKED_glUniform1fARB *unpacked = (PACKED_glUniform1fARB *)packed; \
    ARGS_glUniform1fARB *args = (ARGS_glUniform1fARB *)&unpacked->args; \
    glUniform1fARB(args->location, args->v0);; \
} while(0)
void glUniform1fARB(glUniform1fARB_ARG_EXPAND);
typedef void (*glUniform1fARB_PTR)(glUniform1fARB_ARG_EXPAND);
#define glUniform1fv_INDEX 2163
#define glUniform1fv_RETURN void
#define glUniform1fv_ARG_NAMES location, count, value
#define glUniform1fv_ARG_EXPAND GLint location, GLsizei count, const GLfloat * value
#define glUniform1fv_PACKED PACKED_glUniform1fv
#define glUniform1fv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glUniform1fv_NOT_VOID_WRAP(...) {}
#define pack_glUniform1fv(_location, _count, _value) ({ \
    glUniform1fv_PACKED *packed_data = malloc(sizeof(glUniform1fv_PACKED)); \
    packed_data->index = glUniform1fv_INDEX; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.value = (GLfloat *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glUniform1fv(packed, ret_v) do { \
    PACKED_glUniform1fv *unpacked = (PACKED_glUniform1fv *)packed; \
    ARGS_glUniform1fv *args = (ARGS_glUniform1fv *)&unpacked->args; \
    glUniform1fv(args->location, args->count, args->value);; \
} while(0)
void glUniform1fv(glUniform1fv_ARG_EXPAND);
typedef void (*glUniform1fv_PTR)(glUniform1fv_ARG_EXPAND);
#define glUniform1fvARB_INDEX 2164
#define glUniform1fvARB_RETURN void
#define glUniform1fvARB_ARG_NAMES location, count, value
#define glUniform1fvARB_ARG_EXPAND GLint location, GLsizei count, const GLfloat * value
#define glUniform1fvARB_PACKED PACKED_glUniform1fvARB
#define glUniform1fvARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glUniform1fvARB_NOT_VOID_WRAP(...) {}
#define pack_glUniform1fvARB(_location, _count, _value) ({ \
    glUniform1fvARB_PACKED *packed_data = malloc(sizeof(glUniform1fvARB_PACKED)); \
    packed_data->index = glUniform1fvARB_INDEX; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.value = (GLfloat *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glUniform1fvARB(packed, ret_v) do { \
    PACKED_glUniform1fvARB *unpacked = (PACKED_glUniform1fvARB *)packed; \
    ARGS_glUniform1fvARB *args = (ARGS_glUniform1fvARB *)&unpacked->args; \
    glUniform1fvARB(args->location, args->count, args->value);; \
} while(0)
void glUniform1fvARB(glUniform1fvARB_ARG_EXPAND);
typedef void (*glUniform1fvARB_PTR)(glUniform1fvARB_ARG_EXPAND);
#define glUniform1i_INDEX 2165
#define glUniform1i_RETURN void
#define glUniform1i_ARG_NAMES location, v0
#define glUniform1i_ARG_EXPAND GLint location, GLint v0
#define glUniform1i_PACKED PACKED_glUniform1i
#define glUniform1i_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glUniform1i_NOT_VOID_WRAP(...) {}
#define pack_glUniform1i(_location, _v0) ({ \
    glUniform1i_PACKED *packed_data = malloc(sizeof(glUniform1i_PACKED)); \
    packed_data->index = glUniform1i_INDEX; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.v0 = (GLint)_v0; \
    (packed_call_t *)packed_data; \
})
#define call_glUniform1i(packed, ret_v) do { \
    PACKED_glUniform1i *unpacked = (PACKED_glUniform1i *)packed; \
    ARGS_glUniform1i *args = (ARGS_glUniform1i *)&unpacked->args; \
    glUniform1i(args->location, args->v0);; \
} while(0)
void glUniform1i(glUniform1i_ARG_EXPAND);
typedef void (*glUniform1i_PTR)(glUniform1i_ARG_EXPAND);
#define glUniform1i64NV_INDEX 2166
#define glUniform1i64NV_RETURN void
#define glUniform1i64NV_ARG_NAMES location, x
#define glUniform1i64NV_ARG_EXPAND GLint location, GLint64EXT x
#define glUniform1i64NV_PACKED PACKED_glUniform1i64NV
#define glUniform1i64NV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glUniform1i64NV_NOT_VOID_WRAP(...) {}
#define pack_glUniform1i64NV(_location, _x) ({ \
    glUniform1i64NV_PACKED *packed_data = malloc(sizeof(glUniform1i64NV_PACKED)); \
    packed_data->index = glUniform1i64NV_INDEX; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.x = (GLint64EXT)_x; \
    (packed_call_t *)packed_data; \
})
#define call_glUniform1i64NV(packed, ret_v) do { \
    PACKED_glUniform1i64NV *unpacked = (PACKED_glUniform1i64NV *)packed; \
    ARGS_glUniform1i64NV *args = (ARGS_glUniform1i64NV *)&unpacked->args; \
    glUniform1i64NV(args->location, args->x);; \
} while(0)
void glUniform1i64NV(glUniform1i64NV_ARG_EXPAND);
typedef void (*glUniform1i64NV_PTR)(glUniform1i64NV_ARG_EXPAND);
#define glUniform1i64vNV_INDEX 2167
#define glUniform1i64vNV_RETURN void
#define glUniform1i64vNV_ARG_NAMES location, count, value
#define glUniform1i64vNV_ARG_EXPAND GLint location, GLsizei count, const GLint64EXT * value
#define glUniform1i64vNV_PACKED PACKED_glUniform1i64vNV
#define glUniform1i64vNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glUniform1i64vNV_NOT_VOID_WRAP(...) {}
#define pack_glUniform1i64vNV(_location, _count, _value) ({ \
    glUniform1i64vNV_PACKED *packed_data = malloc(sizeof(glUniform1i64vNV_PACKED)); \
    packed_data->index = glUniform1i64vNV_INDEX; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.value = (GLint64EXT *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glUniform1i64vNV(packed, ret_v) do { \
    PACKED_glUniform1i64vNV *unpacked = (PACKED_glUniform1i64vNV *)packed; \
    ARGS_glUniform1i64vNV *args = (ARGS_glUniform1i64vNV *)&unpacked->args; \
    glUniform1i64vNV(args->location, args->count, args->value);; \
} while(0)
void glUniform1i64vNV(glUniform1i64vNV_ARG_EXPAND);
typedef void (*glUniform1i64vNV_PTR)(glUniform1i64vNV_ARG_EXPAND);
#define glUniform1iARB_INDEX 2168
#define glUniform1iARB_RETURN void
#define glUniform1iARB_ARG_NAMES location, v0
#define glUniform1iARB_ARG_EXPAND GLint location, GLint v0
#define glUniform1iARB_PACKED PACKED_glUniform1iARB
#define glUniform1iARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glUniform1iARB_NOT_VOID_WRAP(...) {}
#define pack_glUniform1iARB(_location, _v0) ({ \
    glUniform1iARB_PACKED *packed_data = malloc(sizeof(glUniform1iARB_PACKED)); \
    packed_data->index = glUniform1iARB_INDEX; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.v0 = (GLint)_v0; \
    (packed_call_t *)packed_data; \
})
#define call_glUniform1iARB(packed, ret_v) do { \
    PACKED_glUniform1iARB *unpacked = (PACKED_glUniform1iARB *)packed; \
    ARGS_glUniform1iARB *args = (ARGS_glUniform1iARB *)&unpacked->args; \
    glUniform1iARB(args->location, args->v0);; \
} while(0)
void glUniform1iARB(glUniform1iARB_ARG_EXPAND);
typedef void (*glUniform1iARB_PTR)(glUniform1iARB_ARG_EXPAND);
#define glUniform1iv_INDEX 2169
#define glUniform1iv_RETURN void
#define glUniform1iv_ARG_NAMES location, count, value
#define glUniform1iv_ARG_EXPAND GLint location, GLsizei count, const GLint * value
#define glUniform1iv_PACKED PACKED_glUniform1iv
#define glUniform1iv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glUniform1iv_NOT_VOID_WRAP(...) {}
#define pack_glUniform1iv(_location, _count, _value) ({ \
    glUniform1iv_PACKED *packed_data = malloc(sizeof(glUniform1iv_PACKED)); \
    packed_data->index = glUniform1iv_INDEX; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.value = (GLint *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glUniform1iv(packed, ret_v) do { \
    PACKED_glUniform1iv *unpacked = (PACKED_glUniform1iv *)packed; \
    ARGS_glUniform1iv *args = (ARGS_glUniform1iv *)&unpacked->args; \
    glUniform1iv(args->location, args->count, args->value);; \
} while(0)
void glUniform1iv(glUniform1iv_ARG_EXPAND);
typedef void (*glUniform1iv_PTR)(glUniform1iv_ARG_EXPAND);
#define glUniform1ivARB_INDEX 2170
#define glUniform1ivARB_RETURN void
#define glUniform1ivARB_ARG_NAMES location, count, value
#define glUniform1ivARB_ARG_EXPAND GLint location, GLsizei count, const GLint * value
#define glUniform1ivARB_PACKED PACKED_glUniform1ivARB
#define glUniform1ivARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glUniform1ivARB_NOT_VOID_WRAP(...) {}
#define pack_glUniform1ivARB(_location, _count, _value) ({ \
    glUniform1ivARB_PACKED *packed_data = malloc(sizeof(glUniform1ivARB_PACKED)); \
    packed_data->index = glUniform1ivARB_INDEX; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.value = (GLint *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glUniform1ivARB(packed, ret_v) do { \
    PACKED_glUniform1ivARB *unpacked = (PACKED_glUniform1ivARB *)packed; \
    ARGS_glUniform1ivARB *args = (ARGS_glUniform1ivARB *)&unpacked->args; \
    glUniform1ivARB(args->location, args->count, args->value);; \
} while(0)
void glUniform1ivARB(glUniform1ivARB_ARG_EXPAND);
typedef void (*glUniform1ivARB_PTR)(glUniform1ivARB_ARG_EXPAND);
#define glUniform1ui_INDEX 2171
#define glUniform1ui_RETURN void
#define glUniform1ui_ARG_NAMES location, v0
#define glUniform1ui_ARG_EXPAND GLint location, GLuint v0
#define glUniform1ui_PACKED PACKED_glUniform1ui
#define glUniform1ui_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glUniform1ui_NOT_VOID_WRAP(...) {}
#define pack_glUniform1ui(_location, _v0) ({ \
    glUniform1ui_PACKED *packed_data = malloc(sizeof(glUniform1ui_PACKED)); \
    packed_data->index = glUniform1ui_INDEX; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.v0 = (GLuint)_v0; \
    (packed_call_t *)packed_data; \
})
#define call_glUniform1ui(packed, ret_v) do { \
    PACKED_glUniform1ui *unpacked = (PACKED_glUniform1ui *)packed; \
    ARGS_glUniform1ui *args = (ARGS_glUniform1ui *)&unpacked->args; \
    glUniform1ui(args->location, args->v0);; \
} while(0)
void glUniform1ui(glUniform1ui_ARG_EXPAND);
typedef void (*glUniform1ui_PTR)(glUniform1ui_ARG_EXPAND);
#define glUniform1ui64NV_INDEX 2172
#define glUniform1ui64NV_RETURN void
#define glUniform1ui64NV_ARG_NAMES location, x
#define glUniform1ui64NV_ARG_EXPAND GLint location, GLuint64EXT x
#define glUniform1ui64NV_PACKED PACKED_glUniform1ui64NV
#define glUniform1ui64NV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glUniform1ui64NV_NOT_VOID_WRAP(...) {}
#define pack_glUniform1ui64NV(_location, _x) ({ \
    glUniform1ui64NV_PACKED *packed_data = malloc(sizeof(glUniform1ui64NV_PACKED)); \
    packed_data->index = glUniform1ui64NV_INDEX; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.x = (GLuint64EXT)_x; \
    (packed_call_t *)packed_data; \
})
#define call_glUniform1ui64NV(packed, ret_v) do { \
    PACKED_glUniform1ui64NV *unpacked = (PACKED_glUniform1ui64NV *)packed; \
    ARGS_glUniform1ui64NV *args = (ARGS_glUniform1ui64NV *)&unpacked->args; \
    glUniform1ui64NV(args->location, args->x);; \
} while(0)
void glUniform1ui64NV(glUniform1ui64NV_ARG_EXPAND);
typedef void (*glUniform1ui64NV_PTR)(glUniform1ui64NV_ARG_EXPAND);
#define glUniform1ui64vNV_INDEX 2173
#define glUniform1ui64vNV_RETURN void
#define glUniform1ui64vNV_ARG_NAMES location, count, value
#define glUniform1ui64vNV_ARG_EXPAND GLint location, GLsizei count, const GLuint64EXT * value
#define glUniform1ui64vNV_PACKED PACKED_glUniform1ui64vNV
#define glUniform1ui64vNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glUniform1ui64vNV_NOT_VOID_WRAP(...) {}
#define pack_glUniform1ui64vNV(_location, _count, _value) ({ \
    glUniform1ui64vNV_PACKED *packed_data = malloc(sizeof(glUniform1ui64vNV_PACKED)); \
    packed_data->index = glUniform1ui64vNV_INDEX; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.value = (GLuint64EXT *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glUniform1ui64vNV(packed, ret_v) do { \
    PACKED_glUniform1ui64vNV *unpacked = (PACKED_glUniform1ui64vNV *)packed; \
    ARGS_glUniform1ui64vNV *args = (ARGS_glUniform1ui64vNV *)&unpacked->args; \
    glUniform1ui64vNV(args->location, args->count, args->value);; \
} while(0)
void glUniform1ui64vNV(glUniform1ui64vNV_ARG_EXPAND);
typedef void (*glUniform1ui64vNV_PTR)(glUniform1ui64vNV_ARG_EXPAND);
#define glUniform1uiEXT_INDEX 2174
#define glUniform1uiEXT_RETURN void
#define glUniform1uiEXT_ARG_NAMES location, v0
#define glUniform1uiEXT_ARG_EXPAND GLint location, GLuint v0
#define glUniform1uiEXT_PACKED PACKED_glUniform1uiEXT
#define glUniform1uiEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glUniform1uiEXT_NOT_VOID_WRAP(...) {}
#define pack_glUniform1uiEXT(_location, _v0) ({ \
    glUniform1uiEXT_PACKED *packed_data = malloc(sizeof(glUniform1uiEXT_PACKED)); \
    packed_data->index = glUniform1uiEXT_INDEX; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.v0 = (GLuint)_v0; \
    (packed_call_t *)packed_data; \
})
#define call_glUniform1uiEXT(packed, ret_v) do { \
    PACKED_glUniform1uiEXT *unpacked = (PACKED_glUniform1uiEXT *)packed; \
    ARGS_glUniform1uiEXT *args = (ARGS_glUniform1uiEXT *)&unpacked->args; \
    glUniform1uiEXT(args->location, args->v0);; \
} while(0)
void glUniform1uiEXT(glUniform1uiEXT_ARG_EXPAND);
typedef void (*glUniform1uiEXT_PTR)(glUniform1uiEXT_ARG_EXPAND);
#define glUniform1uiv_INDEX 2175
#define glUniform1uiv_RETURN void
#define glUniform1uiv_ARG_NAMES location, count, value
#define glUniform1uiv_ARG_EXPAND GLint location, GLsizei count, const GLuint * value
#define glUniform1uiv_PACKED PACKED_glUniform1uiv
#define glUniform1uiv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glUniform1uiv_NOT_VOID_WRAP(...) {}
#define pack_glUniform1uiv(_location, _count, _value) ({ \
    glUniform1uiv_PACKED *packed_data = malloc(sizeof(glUniform1uiv_PACKED)); \
    packed_data->index = glUniform1uiv_INDEX; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.value = (GLuint *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glUniform1uiv(packed, ret_v) do { \
    PACKED_glUniform1uiv *unpacked = (PACKED_glUniform1uiv *)packed; \
    ARGS_glUniform1uiv *args = (ARGS_glUniform1uiv *)&unpacked->args; \
    glUniform1uiv(args->location, args->count, args->value);; \
} while(0)
void glUniform1uiv(glUniform1uiv_ARG_EXPAND);
typedef void (*glUniform1uiv_PTR)(glUniform1uiv_ARG_EXPAND);
#define glUniform1uivEXT_INDEX 2176
#define glUniform1uivEXT_RETURN void
#define glUniform1uivEXT_ARG_NAMES location, count, value
#define glUniform1uivEXT_ARG_EXPAND GLint location, GLsizei count, const GLuint * value
#define glUniform1uivEXT_PACKED PACKED_glUniform1uivEXT
#define glUniform1uivEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glUniform1uivEXT_NOT_VOID_WRAP(...) {}
#define pack_glUniform1uivEXT(_location, _count, _value) ({ \
    glUniform1uivEXT_PACKED *packed_data = malloc(sizeof(glUniform1uivEXT_PACKED)); \
    packed_data->index = glUniform1uivEXT_INDEX; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.value = (GLuint *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glUniform1uivEXT(packed, ret_v) do { \
    PACKED_glUniform1uivEXT *unpacked = (PACKED_glUniform1uivEXT *)packed; \
    ARGS_glUniform1uivEXT *args = (ARGS_glUniform1uivEXT *)&unpacked->args; \
    glUniform1uivEXT(args->location, args->count, args->value);; \
} while(0)
void glUniform1uivEXT(glUniform1uivEXT_ARG_EXPAND);
typedef void (*glUniform1uivEXT_PTR)(glUniform1uivEXT_ARG_EXPAND);
#define glUniform2d_INDEX 2177
#define glUniform2d_RETURN void
#define glUniform2d_ARG_NAMES location, x, y
#define glUniform2d_ARG_EXPAND GLint location, GLdouble x, GLdouble y
#define glUniform2d_PACKED PACKED_glUniform2d
#define glUniform2d_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glUniform2d_NOT_VOID_WRAP(...) {}
#define pack_glUniform2d(_location, _x, _y) ({ \
    glUniform2d_PACKED *packed_data = malloc(sizeof(glUniform2d_PACKED)); \
    packed_data->index = glUniform2d_INDEX; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.x = (GLdouble)_x; \
    packed_data->args.y = (GLdouble)_y; \
    (packed_call_t *)packed_data; \
})
#define call_glUniform2d(packed, ret_v) do { \
    PACKED_glUniform2d *unpacked = (PACKED_glUniform2d *)packed; \
    ARGS_glUniform2d *args = (ARGS_glUniform2d *)&unpacked->args; \
    glUniform2d(args->location, args->x, args->y);; \
} while(0)
void glUniform2d(glUniform2d_ARG_EXPAND);
typedef void (*glUniform2d_PTR)(glUniform2d_ARG_EXPAND);
#define glUniform2dv_INDEX 2178
#define glUniform2dv_RETURN void
#define glUniform2dv_ARG_NAMES location, count, value
#define glUniform2dv_ARG_EXPAND GLint location, GLsizei count, const GLdouble * value
#define glUniform2dv_PACKED PACKED_glUniform2dv
#define glUniform2dv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glUniform2dv_NOT_VOID_WRAP(...) {}
#define pack_glUniform2dv(_location, _count, _value) ({ \
    glUniform2dv_PACKED *packed_data = malloc(sizeof(glUniform2dv_PACKED)); \
    packed_data->index = glUniform2dv_INDEX; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.value = (GLdouble *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glUniform2dv(packed, ret_v) do { \
    PACKED_glUniform2dv *unpacked = (PACKED_glUniform2dv *)packed; \
    ARGS_glUniform2dv *args = (ARGS_glUniform2dv *)&unpacked->args; \
    glUniform2dv(args->location, args->count, args->value);; \
} while(0)
void glUniform2dv(glUniform2dv_ARG_EXPAND);
typedef void (*glUniform2dv_PTR)(glUniform2dv_ARG_EXPAND);
#define glUniform2f_INDEX 2179
#define glUniform2f_RETURN void
#define glUniform2f_ARG_NAMES location, v0, v1
#define glUniform2f_ARG_EXPAND GLint location, GLfloat v0, GLfloat v1
#define glUniform2f_PACKED PACKED_glUniform2f
#define glUniform2f_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glUniform2f_NOT_VOID_WRAP(...) {}
#define pack_glUniform2f(_location, _v0, _v1) ({ \
    glUniform2f_PACKED *packed_data = malloc(sizeof(glUniform2f_PACKED)); \
    packed_data->index = glUniform2f_INDEX; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.v0 = (GLfloat)_v0; \
    packed_data->args.v1 = (GLfloat)_v1; \
    (packed_call_t *)packed_data; \
})
#define call_glUniform2f(packed, ret_v) do { \
    PACKED_glUniform2f *unpacked = (PACKED_glUniform2f *)packed; \
    ARGS_glUniform2f *args = (ARGS_glUniform2f *)&unpacked->args; \
    glUniform2f(args->location, args->v0, args->v1);; \
} while(0)
void glUniform2f(glUniform2f_ARG_EXPAND);
typedef void (*glUniform2f_PTR)(glUniform2f_ARG_EXPAND);
#define glUniform2fARB_INDEX 2180
#define glUniform2fARB_RETURN void
#define glUniform2fARB_ARG_NAMES location, v0, v1
#define glUniform2fARB_ARG_EXPAND GLint location, GLfloat v0, GLfloat v1
#define glUniform2fARB_PACKED PACKED_glUniform2fARB
#define glUniform2fARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glUniform2fARB_NOT_VOID_WRAP(...) {}
#define pack_glUniform2fARB(_location, _v0, _v1) ({ \
    glUniform2fARB_PACKED *packed_data = malloc(sizeof(glUniform2fARB_PACKED)); \
    packed_data->index = glUniform2fARB_INDEX; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.v0 = (GLfloat)_v0; \
    packed_data->args.v1 = (GLfloat)_v1; \
    (packed_call_t *)packed_data; \
})
#define call_glUniform2fARB(packed, ret_v) do { \
    PACKED_glUniform2fARB *unpacked = (PACKED_glUniform2fARB *)packed; \
    ARGS_glUniform2fARB *args = (ARGS_glUniform2fARB *)&unpacked->args; \
    glUniform2fARB(args->location, args->v0, args->v1);; \
} while(0)
void glUniform2fARB(glUniform2fARB_ARG_EXPAND);
typedef void (*glUniform2fARB_PTR)(glUniform2fARB_ARG_EXPAND);
#define glUniform2fv_INDEX 2181
#define glUniform2fv_RETURN void
#define glUniform2fv_ARG_NAMES location, count, value
#define glUniform2fv_ARG_EXPAND GLint location, GLsizei count, const GLfloat * value
#define glUniform2fv_PACKED PACKED_glUniform2fv
#define glUniform2fv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glUniform2fv_NOT_VOID_WRAP(...) {}
#define pack_glUniform2fv(_location, _count, _value) ({ \
    glUniform2fv_PACKED *packed_data = malloc(sizeof(glUniform2fv_PACKED)); \
    packed_data->index = glUniform2fv_INDEX; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.value = (GLfloat *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glUniform2fv(packed, ret_v) do { \
    PACKED_glUniform2fv *unpacked = (PACKED_glUniform2fv *)packed; \
    ARGS_glUniform2fv *args = (ARGS_glUniform2fv *)&unpacked->args; \
    glUniform2fv(args->location, args->count, args->value);; \
} while(0)
void glUniform2fv(glUniform2fv_ARG_EXPAND);
typedef void (*glUniform2fv_PTR)(glUniform2fv_ARG_EXPAND);
#define glUniform2fvARB_INDEX 2182
#define glUniform2fvARB_RETURN void
#define glUniform2fvARB_ARG_NAMES location, count, value
#define glUniform2fvARB_ARG_EXPAND GLint location, GLsizei count, const GLfloat * value
#define glUniform2fvARB_PACKED PACKED_glUniform2fvARB
#define glUniform2fvARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glUniform2fvARB_NOT_VOID_WRAP(...) {}
#define pack_glUniform2fvARB(_location, _count, _value) ({ \
    glUniform2fvARB_PACKED *packed_data = malloc(sizeof(glUniform2fvARB_PACKED)); \
    packed_data->index = glUniform2fvARB_INDEX; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.value = (GLfloat *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glUniform2fvARB(packed, ret_v) do { \
    PACKED_glUniform2fvARB *unpacked = (PACKED_glUniform2fvARB *)packed; \
    ARGS_glUniform2fvARB *args = (ARGS_glUniform2fvARB *)&unpacked->args; \
    glUniform2fvARB(args->location, args->count, args->value);; \
} while(0)
void glUniform2fvARB(glUniform2fvARB_ARG_EXPAND);
typedef void (*glUniform2fvARB_PTR)(glUniform2fvARB_ARG_EXPAND);
#define glUniform2i_INDEX 2183
#define glUniform2i_RETURN void
#define glUniform2i_ARG_NAMES location, v0, v1
#define glUniform2i_ARG_EXPAND GLint location, GLint v0, GLint v1
#define glUniform2i_PACKED PACKED_glUniform2i
#define glUniform2i_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glUniform2i_NOT_VOID_WRAP(...) {}
#define pack_glUniform2i(_location, _v0, _v1) ({ \
    glUniform2i_PACKED *packed_data = malloc(sizeof(glUniform2i_PACKED)); \
    packed_data->index = glUniform2i_INDEX; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.v0 = (GLint)_v0; \
    packed_data->args.v1 = (GLint)_v1; \
    (packed_call_t *)packed_data; \
})
#define call_glUniform2i(packed, ret_v) do { \
    PACKED_glUniform2i *unpacked = (PACKED_glUniform2i *)packed; \
    ARGS_glUniform2i *args = (ARGS_glUniform2i *)&unpacked->args; \
    glUniform2i(args->location, args->v0, args->v1);; \
} while(0)
void glUniform2i(glUniform2i_ARG_EXPAND);
typedef void (*glUniform2i_PTR)(glUniform2i_ARG_EXPAND);
#define glUniform2i64NV_INDEX 2184
#define glUniform2i64NV_RETURN void
#define glUniform2i64NV_ARG_NAMES location, x, y
#define glUniform2i64NV_ARG_EXPAND GLint location, GLint64EXT x, GLint64EXT y
#define glUniform2i64NV_PACKED PACKED_glUniform2i64NV
#define glUniform2i64NV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glUniform2i64NV_NOT_VOID_WRAP(...) {}
#define pack_glUniform2i64NV(_location, _x, _y) ({ \
    glUniform2i64NV_PACKED *packed_data = malloc(sizeof(glUniform2i64NV_PACKED)); \
    packed_data->index = glUniform2i64NV_INDEX; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.x = (GLint64EXT)_x; \
    packed_data->args.y = (GLint64EXT)_y; \
    (packed_call_t *)packed_data; \
})
#define call_glUniform2i64NV(packed, ret_v) do { \
    PACKED_glUniform2i64NV *unpacked = (PACKED_glUniform2i64NV *)packed; \
    ARGS_glUniform2i64NV *args = (ARGS_glUniform2i64NV *)&unpacked->args; \
    glUniform2i64NV(args->location, args->x, args->y);; \
} while(0)
void glUniform2i64NV(glUniform2i64NV_ARG_EXPAND);
typedef void (*glUniform2i64NV_PTR)(glUniform2i64NV_ARG_EXPAND);
#define glUniform2i64vNV_INDEX 2185
#define glUniform2i64vNV_RETURN void
#define glUniform2i64vNV_ARG_NAMES location, count, value
#define glUniform2i64vNV_ARG_EXPAND GLint location, GLsizei count, const GLint64EXT * value
#define glUniform2i64vNV_PACKED PACKED_glUniform2i64vNV
#define glUniform2i64vNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glUniform2i64vNV_NOT_VOID_WRAP(...) {}
#define pack_glUniform2i64vNV(_location, _count, _value) ({ \
    glUniform2i64vNV_PACKED *packed_data = malloc(sizeof(glUniform2i64vNV_PACKED)); \
    packed_data->index = glUniform2i64vNV_INDEX; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.value = (GLint64EXT *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glUniform2i64vNV(packed, ret_v) do { \
    PACKED_glUniform2i64vNV *unpacked = (PACKED_glUniform2i64vNV *)packed; \
    ARGS_glUniform2i64vNV *args = (ARGS_glUniform2i64vNV *)&unpacked->args; \
    glUniform2i64vNV(args->location, args->count, args->value);; \
} while(0)
void glUniform2i64vNV(glUniform2i64vNV_ARG_EXPAND);
typedef void (*glUniform2i64vNV_PTR)(glUniform2i64vNV_ARG_EXPAND);
#define glUniform2iARB_INDEX 2186
#define glUniform2iARB_RETURN void
#define glUniform2iARB_ARG_NAMES location, v0, v1
#define glUniform2iARB_ARG_EXPAND GLint location, GLint v0, GLint v1
#define glUniform2iARB_PACKED PACKED_glUniform2iARB
#define glUniform2iARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glUniform2iARB_NOT_VOID_WRAP(...) {}
#define pack_glUniform2iARB(_location, _v0, _v1) ({ \
    glUniform2iARB_PACKED *packed_data = malloc(sizeof(glUniform2iARB_PACKED)); \
    packed_data->index = glUniform2iARB_INDEX; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.v0 = (GLint)_v0; \
    packed_data->args.v1 = (GLint)_v1; \
    (packed_call_t *)packed_data; \
})
#define call_glUniform2iARB(packed, ret_v) do { \
    PACKED_glUniform2iARB *unpacked = (PACKED_glUniform2iARB *)packed; \
    ARGS_glUniform2iARB *args = (ARGS_glUniform2iARB *)&unpacked->args; \
    glUniform2iARB(args->location, args->v0, args->v1);; \
} while(0)
void glUniform2iARB(glUniform2iARB_ARG_EXPAND);
typedef void (*glUniform2iARB_PTR)(glUniform2iARB_ARG_EXPAND);
#define glUniform2iv_INDEX 2187
#define glUniform2iv_RETURN void
#define glUniform2iv_ARG_NAMES location, count, value
#define glUniform2iv_ARG_EXPAND GLint location, GLsizei count, const GLint * value
#define glUniform2iv_PACKED PACKED_glUniform2iv
#define glUniform2iv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glUniform2iv_NOT_VOID_WRAP(...) {}
#define pack_glUniform2iv(_location, _count, _value) ({ \
    glUniform2iv_PACKED *packed_data = malloc(sizeof(glUniform2iv_PACKED)); \
    packed_data->index = glUniform2iv_INDEX; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.value = (GLint *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glUniform2iv(packed, ret_v) do { \
    PACKED_glUniform2iv *unpacked = (PACKED_glUniform2iv *)packed; \
    ARGS_glUniform2iv *args = (ARGS_glUniform2iv *)&unpacked->args; \
    glUniform2iv(args->location, args->count, args->value);; \
} while(0)
void glUniform2iv(glUniform2iv_ARG_EXPAND);
typedef void (*glUniform2iv_PTR)(glUniform2iv_ARG_EXPAND);
#define glUniform2ivARB_INDEX 2188
#define glUniform2ivARB_RETURN void
#define glUniform2ivARB_ARG_NAMES location, count, value
#define glUniform2ivARB_ARG_EXPAND GLint location, GLsizei count, const GLint * value
#define glUniform2ivARB_PACKED PACKED_glUniform2ivARB
#define glUniform2ivARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glUniform2ivARB_NOT_VOID_WRAP(...) {}
#define pack_glUniform2ivARB(_location, _count, _value) ({ \
    glUniform2ivARB_PACKED *packed_data = malloc(sizeof(glUniform2ivARB_PACKED)); \
    packed_data->index = glUniform2ivARB_INDEX; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.value = (GLint *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glUniform2ivARB(packed, ret_v) do { \
    PACKED_glUniform2ivARB *unpacked = (PACKED_glUniform2ivARB *)packed; \
    ARGS_glUniform2ivARB *args = (ARGS_glUniform2ivARB *)&unpacked->args; \
    glUniform2ivARB(args->location, args->count, args->value);; \
} while(0)
void glUniform2ivARB(glUniform2ivARB_ARG_EXPAND);
typedef void (*glUniform2ivARB_PTR)(glUniform2ivARB_ARG_EXPAND);
#define glUniform2ui_INDEX 2189
#define glUniform2ui_RETURN void
#define glUniform2ui_ARG_NAMES location, v0, v1
#define glUniform2ui_ARG_EXPAND GLint location, GLuint v0, GLuint v1
#define glUniform2ui_PACKED PACKED_glUniform2ui
#define glUniform2ui_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glUniform2ui_NOT_VOID_WRAP(...) {}
#define pack_glUniform2ui(_location, _v0, _v1) ({ \
    glUniform2ui_PACKED *packed_data = malloc(sizeof(glUniform2ui_PACKED)); \
    packed_data->index = glUniform2ui_INDEX; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.v0 = (GLuint)_v0; \
    packed_data->args.v1 = (GLuint)_v1; \
    (packed_call_t *)packed_data; \
})
#define call_glUniform2ui(packed, ret_v) do { \
    PACKED_glUniform2ui *unpacked = (PACKED_glUniform2ui *)packed; \
    ARGS_glUniform2ui *args = (ARGS_glUniform2ui *)&unpacked->args; \
    glUniform2ui(args->location, args->v0, args->v1);; \
} while(0)
void glUniform2ui(glUniform2ui_ARG_EXPAND);
typedef void (*glUniform2ui_PTR)(glUniform2ui_ARG_EXPAND);
#define glUniform2ui64NV_INDEX 2190
#define glUniform2ui64NV_RETURN void
#define glUniform2ui64NV_ARG_NAMES location, x, y
#define glUniform2ui64NV_ARG_EXPAND GLint location, GLuint64EXT x, GLuint64EXT y
#define glUniform2ui64NV_PACKED PACKED_glUniform2ui64NV
#define glUniform2ui64NV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glUniform2ui64NV_NOT_VOID_WRAP(...) {}
#define pack_glUniform2ui64NV(_location, _x, _y) ({ \
    glUniform2ui64NV_PACKED *packed_data = malloc(sizeof(glUniform2ui64NV_PACKED)); \
    packed_data->index = glUniform2ui64NV_INDEX; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.x = (GLuint64EXT)_x; \
    packed_data->args.y = (GLuint64EXT)_y; \
    (packed_call_t *)packed_data; \
})
#define call_glUniform2ui64NV(packed, ret_v) do { \
    PACKED_glUniform2ui64NV *unpacked = (PACKED_glUniform2ui64NV *)packed; \
    ARGS_glUniform2ui64NV *args = (ARGS_glUniform2ui64NV *)&unpacked->args; \
    glUniform2ui64NV(args->location, args->x, args->y);; \
} while(0)
void glUniform2ui64NV(glUniform2ui64NV_ARG_EXPAND);
typedef void (*glUniform2ui64NV_PTR)(glUniform2ui64NV_ARG_EXPAND);
#define glUniform2ui64vNV_INDEX 2191
#define glUniform2ui64vNV_RETURN void
#define glUniform2ui64vNV_ARG_NAMES location, count, value
#define glUniform2ui64vNV_ARG_EXPAND GLint location, GLsizei count, const GLuint64EXT * value
#define glUniform2ui64vNV_PACKED PACKED_glUniform2ui64vNV
#define glUniform2ui64vNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glUniform2ui64vNV_NOT_VOID_WRAP(...) {}
#define pack_glUniform2ui64vNV(_location, _count, _value) ({ \
    glUniform2ui64vNV_PACKED *packed_data = malloc(sizeof(glUniform2ui64vNV_PACKED)); \
    packed_data->index = glUniform2ui64vNV_INDEX; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.value = (GLuint64EXT *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glUniform2ui64vNV(packed, ret_v) do { \
    PACKED_glUniform2ui64vNV *unpacked = (PACKED_glUniform2ui64vNV *)packed; \
    ARGS_glUniform2ui64vNV *args = (ARGS_glUniform2ui64vNV *)&unpacked->args; \
    glUniform2ui64vNV(args->location, args->count, args->value);; \
} while(0)
void glUniform2ui64vNV(glUniform2ui64vNV_ARG_EXPAND);
typedef void (*glUniform2ui64vNV_PTR)(glUniform2ui64vNV_ARG_EXPAND);
#define glUniform2uiEXT_INDEX 2192
#define glUniform2uiEXT_RETURN void
#define glUniform2uiEXT_ARG_NAMES location, v0, v1
#define glUniform2uiEXT_ARG_EXPAND GLint location, GLuint v0, GLuint v1
#define glUniform2uiEXT_PACKED PACKED_glUniform2uiEXT
#define glUniform2uiEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glUniform2uiEXT_NOT_VOID_WRAP(...) {}
#define pack_glUniform2uiEXT(_location, _v0, _v1) ({ \
    glUniform2uiEXT_PACKED *packed_data = malloc(sizeof(glUniform2uiEXT_PACKED)); \
    packed_data->index = glUniform2uiEXT_INDEX; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.v0 = (GLuint)_v0; \
    packed_data->args.v1 = (GLuint)_v1; \
    (packed_call_t *)packed_data; \
})
#define call_glUniform2uiEXT(packed, ret_v) do { \
    PACKED_glUniform2uiEXT *unpacked = (PACKED_glUniform2uiEXT *)packed; \
    ARGS_glUniform2uiEXT *args = (ARGS_glUniform2uiEXT *)&unpacked->args; \
    glUniform2uiEXT(args->location, args->v0, args->v1);; \
} while(0)
void glUniform2uiEXT(glUniform2uiEXT_ARG_EXPAND);
typedef void (*glUniform2uiEXT_PTR)(glUniform2uiEXT_ARG_EXPAND);
#define glUniform2uiv_INDEX 2193
#define glUniform2uiv_RETURN void
#define glUniform2uiv_ARG_NAMES location, count, value
#define glUniform2uiv_ARG_EXPAND GLint location, GLsizei count, const GLuint * value
#define glUniform2uiv_PACKED PACKED_glUniform2uiv
#define glUniform2uiv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glUniform2uiv_NOT_VOID_WRAP(...) {}
#define pack_glUniform2uiv(_location, _count, _value) ({ \
    glUniform2uiv_PACKED *packed_data = malloc(sizeof(glUniform2uiv_PACKED)); \
    packed_data->index = glUniform2uiv_INDEX; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.value = (GLuint *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glUniform2uiv(packed, ret_v) do { \
    PACKED_glUniform2uiv *unpacked = (PACKED_glUniform2uiv *)packed; \
    ARGS_glUniform2uiv *args = (ARGS_glUniform2uiv *)&unpacked->args; \
    glUniform2uiv(args->location, args->count, args->value);; \
} while(0)
void glUniform2uiv(glUniform2uiv_ARG_EXPAND);
typedef void (*glUniform2uiv_PTR)(glUniform2uiv_ARG_EXPAND);
#define glUniform2uivEXT_INDEX 2194
#define glUniform2uivEXT_RETURN void
#define glUniform2uivEXT_ARG_NAMES location, count, value
#define glUniform2uivEXT_ARG_EXPAND GLint location, GLsizei count, const GLuint * value
#define glUniform2uivEXT_PACKED PACKED_glUniform2uivEXT
#define glUniform2uivEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glUniform2uivEXT_NOT_VOID_WRAP(...) {}
#define pack_glUniform2uivEXT(_location, _count, _value) ({ \
    glUniform2uivEXT_PACKED *packed_data = malloc(sizeof(glUniform2uivEXT_PACKED)); \
    packed_data->index = glUniform2uivEXT_INDEX; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.value = (GLuint *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glUniform2uivEXT(packed, ret_v) do { \
    PACKED_glUniform2uivEXT *unpacked = (PACKED_glUniform2uivEXT *)packed; \
    ARGS_glUniform2uivEXT *args = (ARGS_glUniform2uivEXT *)&unpacked->args; \
    glUniform2uivEXT(args->location, args->count, args->value);; \
} while(0)
void glUniform2uivEXT(glUniform2uivEXT_ARG_EXPAND);
typedef void (*glUniform2uivEXT_PTR)(glUniform2uivEXT_ARG_EXPAND);
#define glUniform3d_INDEX 2195
#define glUniform3d_RETURN void
#define glUniform3d_ARG_NAMES location, x, y, z
#define glUniform3d_ARG_EXPAND GLint location, GLdouble x, GLdouble y, GLdouble z
#define glUniform3d_PACKED PACKED_glUniform3d
#define glUniform3d_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glUniform3d_NOT_VOID_WRAP(...) {}
#define pack_glUniform3d(_location, _x, _y, _z) ({ \
    glUniform3d_PACKED *packed_data = malloc(sizeof(glUniform3d_PACKED)); \
    packed_data->index = glUniform3d_INDEX; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.x = (GLdouble)_x; \
    packed_data->args.y = (GLdouble)_y; \
    packed_data->args.z = (GLdouble)_z; \
    (packed_call_t *)packed_data; \
})
#define call_glUniform3d(packed, ret_v) do { \
    PACKED_glUniform3d *unpacked = (PACKED_glUniform3d *)packed; \
    ARGS_glUniform3d *args = (ARGS_glUniform3d *)&unpacked->args; \
    glUniform3d(args->location, args->x, args->y, args->z);; \
} while(0)
void glUniform3d(glUniform3d_ARG_EXPAND);
typedef void (*glUniform3d_PTR)(glUniform3d_ARG_EXPAND);
#define glUniform3dv_INDEX 2196
#define glUniform3dv_RETURN void
#define glUniform3dv_ARG_NAMES location, count, value
#define glUniform3dv_ARG_EXPAND GLint location, GLsizei count, const GLdouble * value
#define glUniform3dv_PACKED PACKED_glUniform3dv
#define glUniform3dv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glUniform3dv_NOT_VOID_WRAP(...) {}
#define pack_glUniform3dv(_location, _count, _value) ({ \
    glUniform3dv_PACKED *packed_data = malloc(sizeof(glUniform3dv_PACKED)); \
    packed_data->index = glUniform3dv_INDEX; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.value = (GLdouble *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glUniform3dv(packed, ret_v) do { \
    PACKED_glUniform3dv *unpacked = (PACKED_glUniform3dv *)packed; \
    ARGS_glUniform3dv *args = (ARGS_glUniform3dv *)&unpacked->args; \
    glUniform3dv(args->location, args->count, args->value);; \
} while(0)
void glUniform3dv(glUniform3dv_ARG_EXPAND);
typedef void (*glUniform3dv_PTR)(glUniform3dv_ARG_EXPAND);
#define glUniform3f_INDEX 2197
#define glUniform3f_RETURN void
#define glUniform3f_ARG_NAMES location, v0, v1, v2
#define glUniform3f_ARG_EXPAND GLint location, GLfloat v0, GLfloat v1, GLfloat v2
#define glUniform3f_PACKED PACKED_glUniform3f
#define glUniform3f_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glUniform3f_NOT_VOID_WRAP(...) {}
#define pack_glUniform3f(_location, _v0, _v1, _v2) ({ \
    glUniform3f_PACKED *packed_data = malloc(sizeof(glUniform3f_PACKED)); \
    packed_data->index = glUniform3f_INDEX; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.v0 = (GLfloat)_v0; \
    packed_data->args.v1 = (GLfloat)_v1; \
    packed_data->args.v2 = (GLfloat)_v2; \
    (packed_call_t *)packed_data; \
})
#define call_glUniform3f(packed, ret_v) do { \
    PACKED_glUniform3f *unpacked = (PACKED_glUniform3f *)packed; \
    ARGS_glUniform3f *args = (ARGS_glUniform3f *)&unpacked->args; \
    glUniform3f(args->location, args->v0, args->v1, args->v2);; \
} while(0)
void glUniform3f(glUniform3f_ARG_EXPAND);
typedef void (*glUniform3f_PTR)(glUniform3f_ARG_EXPAND);
#define glUniform3fARB_INDEX 2198
#define glUniform3fARB_RETURN void
#define glUniform3fARB_ARG_NAMES location, v0, v1, v2
#define glUniform3fARB_ARG_EXPAND GLint location, GLfloat v0, GLfloat v1, GLfloat v2
#define glUniform3fARB_PACKED PACKED_glUniform3fARB
#define glUniform3fARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glUniform3fARB_NOT_VOID_WRAP(...) {}
#define pack_glUniform3fARB(_location, _v0, _v1, _v2) ({ \
    glUniform3fARB_PACKED *packed_data = malloc(sizeof(glUniform3fARB_PACKED)); \
    packed_data->index = glUniform3fARB_INDEX; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.v0 = (GLfloat)_v0; \
    packed_data->args.v1 = (GLfloat)_v1; \
    packed_data->args.v2 = (GLfloat)_v2; \
    (packed_call_t *)packed_data; \
})
#define call_glUniform3fARB(packed, ret_v) do { \
    PACKED_glUniform3fARB *unpacked = (PACKED_glUniform3fARB *)packed; \
    ARGS_glUniform3fARB *args = (ARGS_glUniform3fARB *)&unpacked->args; \
    glUniform3fARB(args->location, args->v0, args->v1, args->v2);; \
} while(0)
void glUniform3fARB(glUniform3fARB_ARG_EXPAND);
typedef void (*glUniform3fARB_PTR)(glUniform3fARB_ARG_EXPAND);
#define glUniform3fv_INDEX 2199
#define glUniform3fv_RETURN void
#define glUniform3fv_ARG_NAMES location, count, value
#define glUniform3fv_ARG_EXPAND GLint location, GLsizei count, const GLfloat * value
#define glUniform3fv_PACKED PACKED_glUniform3fv
#define glUniform3fv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glUniform3fv_NOT_VOID_WRAP(...) {}
#define pack_glUniform3fv(_location, _count, _value) ({ \
    glUniform3fv_PACKED *packed_data = malloc(sizeof(glUniform3fv_PACKED)); \
    packed_data->index = glUniform3fv_INDEX; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.value = (GLfloat *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glUniform3fv(packed, ret_v) do { \
    PACKED_glUniform3fv *unpacked = (PACKED_glUniform3fv *)packed; \
    ARGS_glUniform3fv *args = (ARGS_glUniform3fv *)&unpacked->args; \
    glUniform3fv(args->location, args->count, args->value);; \
} while(0)
void glUniform3fv(glUniform3fv_ARG_EXPAND);
typedef void (*glUniform3fv_PTR)(glUniform3fv_ARG_EXPAND);
#define glUniform3fvARB_INDEX 2200
#define glUniform3fvARB_RETURN void
#define glUniform3fvARB_ARG_NAMES location, count, value
#define glUniform3fvARB_ARG_EXPAND GLint location, GLsizei count, const GLfloat * value
#define glUniform3fvARB_PACKED PACKED_glUniform3fvARB
#define glUniform3fvARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glUniform3fvARB_NOT_VOID_WRAP(...) {}
#define pack_glUniform3fvARB(_location, _count, _value) ({ \
    glUniform3fvARB_PACKED *packed_data = malloc(sizeof(glUniform3fvARB_PACKED)); \
    packed_data->index = glUniform3fvARB_INDEX; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.value = (GLfloat *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glUniform3fvARB(packed, ret_v) do { \
    PACKED_glUniform3fvARB *unpacked = (PACKED_glUniform3fvARB *)packed; \
    ARGS_glUniform3fvARB *args = (ARGS_glUniform3fvARB *)&unpacked->args; \
    glUniform3fvARB(args->location, args->count, args->value);; \
} while(0)
void glUniform3fvARB(glUniform3fvARB_ARG_EXPAND);
typedef void (*glUniform3fvARB_PTR)(glUniform3fvARB_ARG_EXPAND);
#define glUniform3i_INDEX 2201
#define glUniform3i_RETURN void
#define glUniform3i_ARG_NAMES location, v0, v1, v2
#define glUniform3i_ARG_EXPAND GLint location, GLint v0, GLint v1, GLint v2
#define glUniform3i_PACKED PACKED_glUniform3i
#define glUniform3i_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glUniform3i_NOT_VOID_WRAP(...) {}
#define pack_glUniform3i(_location, _v0, _v1, _v2) ({ \
    glUniform3i_PACKED *packed_data = malloc(sizeof(glUniform3i_PACKED)); \
    packed_data->index = glUniform3i_INDEX; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.v0 = (GLint)_v0; \
    packed_data->args.v1 = (GLint)_v1; \
    packed_data->args.v2 = (GLint)_v2; \
    (packed_call_t *)packed_data; \
})
#define call_glUniform3i(packed, ret_v) do { \
    PACKED_glUniform3i *unpacked = (PACKED_glUniform3i *)packed; \
    ARGS_glUniform3i *args = (ARGS_glUniform3i *)&unpacked->args; \
    glUniform3i(args->location, args->v0, args->v1, args->v2);; \
} while(0)
void glUniform3i(glUniform3i_ARG_EXPAND);
typedef void (*glUniform3i_PTR)(glUniform3i_ARG_EXPAND);
#define glUniform3i64NV_INDEX 2202
#define glUniform3i64NV_RETURN void
#define glUniform3i64NV_ARG_NAMES location, x, y, z
#define glUniform3i64NV_ARG_EXPAND GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z
#define glUniform3i64NV_PACKED PACKED_glUniform3i64NV
#define glUniform3i64NV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glUniform3i64NV_NOT_VOID_WRAP(...) {}
#define pack_glUniform3i64NV(_location, _x, _y, _z) ({ \
    glUniform3i64NV_PACKED *packed_data = malloc(sizeof(glUniform3i64NV_PACKED)); \
    packed_data->index = glUniform3i64NV_INDEX; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.x = (GLint64EXT)_x; \
    packed_data->args.y = (GLint64EXT)_y; \
    packed_data->args.z = (GLint64EXT)_z; \
    (packed_call_t *)packed_data; \
})
#define call_glUniform3i64NV(packed, ret_v) do { \
    PACKED_glUniform3i64NV *unpacked = (PACKED_glUniform3i64NV *)packed; \
    ARGS_glUniform3i64NV *args = (ARGS_glUniform3i64NV *)&unpacked->args; \
    glUniform3i64NV(args->location, args->x, args->y, args->z);; \
} while(0)
void glUniform3i64NV(glUniform3i64NV_ARG_EXPAND);
typedef void (*glUniform3i64NV_PTR)(glUniform3i64NV_ARG_EXPAND);
#define glUniform3i64vNV_INDEX 2203
#define glUniform3i64vNV_RETURN void
#define glUniform3i64vNV_ARG_NAMES location, count, value
#define glUniform3i64vNV_ARG_EXPAND GLint location, GLsizei count, const GLint64EXT * value
#define glUniform3i64vNV_PACKED PACKED_glUniform3i64vNV
#define glUniform3i64vNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glUniform3i64vNV_NOT_VOID_WRAP(...) {}
#define pack_glUniform3i64vNV(_location, _count, _value) ({ \
    glUniform3i64vNV_PACKED *packed_data = malloc(sizeof(glUniform3i64vNV_PACKED)); \
    packed_data->index = glUniform3i64vNV_INDEX; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.value = (GLint64EXT *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glUniform3i64vNV(packed, ret_v) do { \
    PACKED_glUniform3i64vNV *unpacked = (PACKED_glUniform3i64vNV *)packed; \
    ARGS_glUniform3i64vNV *args = (ARGS_glUniform3i64vNV *)&unpacked->args; \
    glUniform3i64vNV(args->location, args->count, args->value);; \
} while(0)
void glUniform3i64vNV(glUniform3i64vNV_ARG_EXPAND);
typedef void (*glUniform3i64vNV_PTR)(glUniform3i64vNV_ARG_EXPAND);
#define glUniform3iARB_INDEX 2204
#define glUniform3iARB_RETURN void
#define glUniform3iARB_ARG_NAMES location, v0, v1, v2
#define glUniform3iARB_ARG_EXPAND GLint location, GLint v0, GLint v1, GLint v2
#define glUniform3iARB_PACKED PACKED_glUniform3iARB
#define glUniform3iARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glUniform3iARB_NOT_VOID_WRAP(...) {}
#define pack_glUniform3iARB(_location, _v0, _v1, _v2) ({ \
    glUniform3iARB_PACKED *packed_data = malloc(sizeof(glUniform3iARB_PACKED)); \
    packed_data->index = glUniform3iARB_INDEX; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.v0 = (GLint)_v0; \
    packed_data->args.v1 = (GLint)_v1; \
    packed_data->args.v2 = (GLint)_v2; \
    (packed_call_t *)packed_data; \
})
#define call_glUniform3iARB(packed, ret_v) do { \
    PACKED_glUniform3iARB *unpacked = (PACKED_glUniform3iARB *)packed; \
    ARGS_glUniform3iARB *args = (ARGS_glUniform3iARB *)&unpacked->args; \
    glUniform3iARB(args->location, args->v0, args->v1, args->v2);; \
} while(0)
void glUniform3iARB(glUniform3iARB_ARG_EXPAND);
typedef void (*glUniform3iARB_PTR)(glUniform3iARB_ARG_EXPAND);
#define glUniform3iv_INDEX 2205
#define glUniform3iv_RETURN void
#define glUniform3iv_ARG_NAMES location, count, value
#define glUniform3iv_ARG_EXPAND GLint location, GLsizei count, const GLint * value
#define glUniform3iv_PACKED PACKED_glUniform3iv
#define glUniform3iv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glUniform3iv_NOT_VOID_WRAP(...) {}
#define pack_glUniform3iv(_location, _count, _value) ({ \
    glUniform3iv_PACKED *packed_data = malloc(sizeof(glUniform3iv_PACKED)); \
    packed_data->index = glUniform3iv_INDEX; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.value = (GLint *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glUniform3iv(packed, ret_v) do { \
    PACKED_glUniform3iv *unpacked = (PACKED_glUniform3iv *)packed; \
    ARGS_glUniform3iv *args = (ARGS_glUniform3iv *)&unpacked->args; \
    glUniform3iv(args->location, args->count, args->value);; \
} while(0)
void glUniform3iv(glUniform3iv_ARG_EXPAND);
typedef void (*glUniform3iv_PTR)(glUniform3iv_ARG_EXPAND);
#define glUniform3ivARB_INDEX 2206
#define glUniform3ivARB_RETURN void
#define glUniform3ivARB_ARG_NAMES location, count, value
#define glUniform3ivARB_ARG_EXPAND GLint location, GLsizei count, const GLint * value
#define glUniform3ivARB_PACKED PACKED_glUniform3ivARB
#define glUniform3ivARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glUniform3ivARB_NOT_VOID_WRAP(...) {}
#define pack_glUniform3ivARB(_location, _count, _value) ({ \
    glUniform3ivARB_PACKED *packed_data = malloc(sizeof(glUniform3ivARB_PACKED)); \
    packed_data->index = glUniform3ivARB_INDEX; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.value = (GLint *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glUniform3ivARB(packed, ret_v) do { \
    PACKED_glUniform3ivARB *unpacked = (PACKED_glUniform3ivARB *)packed; \
    ARGS_glUniform3ivARB *args = (ARGS_glUniform3ivARB *)&unpacked->args; \
    glUniform3ivARB(args->location, args->count, args->value);; \
} while(0)
void glUniform3ivARB(glUniform3ivARB_ARG_EXPAND);
typedef void (*glUniform3ivARB_PTR)(glUniform3ivARB_ARG_EXPAND);
#define glUniform3ui_INDEX 2207
#define glUniform3ui_RETURN void
#define glUniform3ui_ARG_NAMES location, v0, v1, v2
#define glUniform3ui_ARG_EXPAND GLint location, GLuint v0, GLuint v1, GLuint v2
#define glUniform3ui_PACKED PACKED_glUniform3ui
#define glUniform3ui_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glUniform3ui_NOT_VOID_WRAP(...) {}
#define pack_glUniform3ui(_location, _v0, _v1, _v2) ({ \
    glUniform3ui_PACKED *packed_data = malloc(sizeof(glUniform3ui_PACKED)); \
    packed_data->index = glUniform3ui_INDEX; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.v0 = (GLuint)_v0; \
    packed_data->args.v1 = (GLuint)_v1; \
    packed_data->args.v2 = (GLuint)_v2; \
    (packed_call_t *)packed_data; \
})
#define call_glUniform3ui(packed, ret_v) do { \
    PACKED_glUniform3ui *unpacked = (PACKED_glUniform3ui *)packed; \
    ARGS_glUniform3ui *args = (ARGS_glUniform3ui *)&unpacked->args; \
    glUniform3ui(args->location, args->v0, args->v1, args->v2);; \
} while(0)
void glUniform3ui(glUniform3ui_ARG_EXPAND);
typedef void (*glUniform3ui_PTR)(glUniform3ui_ARG_EXPAND);
#define glUniform3ui64NV_INDEX 2208
#define glUniform3ui64NV_RETURN void
#define glUniform3ui64NV_ARG_NAMES location, x, y, z
#define glUniform3ui64NV_ARG_EXPAND GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z
#define glUniform3ui64NV_PACKED PACKED_glUniform3ui64NV
#define glUniform3ui64NV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glUniform3ui64NV_NOT_VOID_WRAP(...) {}
#define pack_glUniform3ui64NV(_location, _x, _y, _z) ({ \
    glUniform3ui64NV_PACKED *packed_data = malloc(sizeof(glUniform3ui64NV_PACKED)); \
    packed_data->index = glUniform3ui64NV_INDEX; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.x = (GLuint64EXT)_x; \
    packed_data->args.y = (GLuint64EXT)_y; \
    packed_data->args.z = (GLuint64EXT)_z; \
    (packed_call_t *)packed_data; \
})
#define call_glUniform3ui64NV(packed, ret_v) do { \
    PACKED_glUniform3ui64NV *unpacked = (PACKED_glUniform3ui64NV *)packed; \
    ARGS_glUniform3ui64NV *args = (ARGS_glUniform3ui64NV *)&unpacked->args; \
    glUniform3ui64NV(args->location, args->x, args->y, args->z);; \
} while(0)
void glUniform3ui64NV(glUniform3ui64NV_ARG_EXPAND);
typedef void (*glUniform3ui64NV_PTR)(glUniform3ui64NV_ARG_EXPAND);
#define glUniform3ui64vNV_INDEX 2209
#define glUniform3ui64vNV_RETURN void
#define glUniform3ui64vNV_ARG_NAMES location, count, value
#define glUniform3ui64vNV_ARG_EXPAND GLint location, GLsizei count, const GLuint64EXT * value
#define glUniform3ui64vNV_PACKED PACKED_glUniform3ui64vNV
#define glUniform3ui64vNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glUniform3ui64vNV_NOT_VOID_WRAP(...) {}
#define pack_glUniform3ui64vNV(_location, _count, _value) ({ \
    glUniform3ui64vNV_PACKED *packed_data = malloc(sizeof(glUniform3ui64vNV_PACKED)); \
    packed_data->index = glUniform3ui64vNV_INDEX; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.value = (GLuint64EXT *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glUniform3ui64vNV(packed, ret_v) do { \
    PACKED_glUniform3ui64vNV *unpacked = (PACKED_glUniform3ui64vNV *)packed; \
    ARGS_glUniform3ui64vNV *args = (ARGS_glUniform3ui64vNV *)&unpacked->args; \
    glUniform3ui64vNV(args->location, args->count, args->value);; \
} while(0)
void glUniform3ui64vNV(glUniform3ui64vNV_ARG_EXPAND);
typedef void (*glUniform3ui64vNV_PTR)(glUniform3ui64vNV_ARG_EXPAND);
#define glUniform3uiEXT_INDEX 2210
#define glUniform3uiEXT_RETURN void
#define glUniform3uiEXT_ARG_NAMES location, v0, v1, v2
#define glUniform3uiEXT_ARG_EXPAND GLint location, GLuint v0, GLuint v1, GLuint v2
#define glUniform3uiEXT_PACKED PACKED_glUniform3uiEXT
#define glUniform3uiEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glUniform3uiEXT_NOT_VOID_WRAP(...) {}
#define pack_glUniform3uiEXT(_location, _v0, _v1, _v2) ({ \
    glUniform3uiEXT_PACKED *packed_data = malloc(sizeof(glUniform3uiEXT_PACKED)); \
    packed_data->index = glUniform3uiEXT_INDEX; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.v0 = (GLuint)_v0; \
    packed_data->args.v1 = (GLuint)_v1; \
    packed_data->args.v2 = (GLuint)_v2; \
    (packed_call_t *)packed_data; \
})
#define call_glUniform3uiEXT(packed, ret_v) do { \
    PACKED_glUniform3uiEXT *unpacked = (PACKED_glUniform3uiEXT *)packed; \
    ARGS_glUniform3uiEXT *args = (ARGS_glUniform3uiEXT *)&unpacked->args; \
    glUniform3uiEXT(args->location, args->v0, args->v1, args->v2);; \
} while(0)
void glUniform3uiEXT(glUniform3uiEXT_ARG_EXPAND);
typedef void (*glUniform3uiEXT_PTR)(glUniform3uiEXT_ARG_EXPAND);
#define glUniform3uiv_INDEX 2211
#define glUniform3uiv_RETURN void
#define glUniform3uiv_ARG_NAMES location, count, value
#define glUniform3uiv_ARG_EXPAND GLint location, GLsizei count, const GLuint * value
#define glUniform3uiv_PACKED PACKED_glUniform3uiv
#define glUniform3uiv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glUniform3uiv_NOT_VOID_WRAP(...) {}
#define pack_glUniform3uiv(_location, _count, _value) ({ \
    glUniform3uiv_PACKED *packed_data = malloc(sizeof(glUniform3uiv_PACKED)); \
    packed_data->index = glUniform3uiv_INDEX; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.value = (GLuint *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glUniform3uiv(packed, ret_v) do { \
    PACKED_glUniform3uiv *unpacked = (PACKED_glUniform3uiv *)packed; \
    ARGS_glUniform3uiv *args = (ARGS_glUniform3uiv *)&unpacked->args; \
    glUniform3uiv(args->location, args->count, args->value);; \
} while(0)
void glUniform3uiv(glUniform3uiv_ARG_EXPAND);
typedef void (*glUniform3uiv_PTR)(glUniform3uiv_ARG_EXPAND);
#define glUniform3uivEXT_INDEX 2212
#define glUniform3uivEXT_RETURN void
#define glUniform3uivEXT_ARG_NAMES location, count, value
#define glUniform3uivEXT_ARG_EXPAND GLint location, GLsizei count, const GLuint * value
#define glUniform3uivEXT_PACKED PACKED_glUniform3uivEXT
#define glUniform3uivEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glUniform3uivEXT_NOT_VOID_WRAP(...) {}
#define pack_glUniform3uivEXT(_location, _count, _value) ({ \
    glUniform3uivEXT_PACKED *packed_data = malloc(sizeof(glUniform3uivEXT_PACKED)); \
    packed_data->index = glUniform3uivEXT_INDEX; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.value = (GLuint *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glUniform3uivEXT(packed, ret_v) do { \
    PACKED_glUniform3uivEXT *unpacked = (PACKED_glUniform3uivEXT *)packed; \
    ARGS_glUniform3uivEXT *args = (ARGS_glUniform3uivEXT *)&unpacked->args; \
    glUniform3uivEXT(args->location, args->count, args->value);; \
} while(0)
void glUniform3uivEXT(glUniform3uivEXT_ARG_EXPAND);
typedef void (*glUniform3uivEXT_PTR)(glUniform3uivEXT_ARG_EXPAND);
#define glUniform4d_INDEX 2213
#define glUniform4d_RETURN void
#define glUniform4d_ARG_NAMES location, x, y, z, w
#define glUniform4d_ARG_EXPAND GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w
#define glUniform4d_PACKED PACKED_glUniform4d
#define glUniform4d_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glUniform4d_NOT_VOID_WRAP(...) {}
#define pack_glUniform4d(_location, _x, _y, _z, _w) ({ \
    glUniform4d_PACKED *packed_data = malloc(sizeof(glUniform4d_PACKED)); \
    packed_data->index = glUniform4d_INDEX; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.x = (GLdouble)_x; \
    packed_data->args.y = (GLdouble)_y; \
    packed_data->args.z = (GLdouble)_z; \
    packed_data->args.w = (GLdouble)_w; \
    (packed_call_t *)packed_data; \
})
#define call_glUniform4d(packed, ret_v) do { \
    PACKED_glUniform4d *unpacked = (PACKED_glUniform4d *)packed; \
    ARGS_glUniform4d *args = (ARGS_glUniform4d *)&unpacked->args; \
    glUniform4d(args->location, args->x, args->y, args->z, args->w);; \
} while(0)
void glUniform4d(glUniform4d_ARG_EXPAND);
typedef void (*glUniform4d_PTR)(glUniform4d_ARG_EXPAND);
#define glUniform4dv_INDEX 2214
#define glUniform4dv_RETURN void
#define glUniform4dv_ARG_NAMES location, count, value
#define glUniform4dv_ARG_EXPAND GLint location, GLsizei count, const GLdouble * value
#define glUniform4dv_PACKED PACKED_glUniform4dv
#define glUniform4dv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glUniform4dv_NOT_VOID_WRAP(...) {}
#define pack_glUniform4dv(_location, _count, _value) ({ \
    glUniform4dv_PACKED *packed_data = malloc(sizeof(glUniform4dv_PACKED)); \
    packed_data->index = glUniform4dv_INDEX; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.value = (GLdouble *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glUniform4dv(packed, ret_v) do { \
    PACKED_glUniform4dv *unpacked = (PACKED_glUniform4dv *)packed; \
    ARGS_glUniform4dv *args = (ARGS_glUniform4dv *)&unpacked->args; \
    glUniform4dv(args->location, args->count, args->value);; \
} while(0)
void glUniform4dv(glUniform4dv_ARG_EXPAND);
typedef void (*glUniform4dv_PTR)(glUniform4dv_ARG_EXPAND);
#define glUniform4f_INDEX 2215
#define glUniform4f_RETURN void
#define glUniform4f_ARG_NAMES location, v0, v1, v2, v3
#define glUniform4f_ARG_EXPAND GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3
#define glUniform4f_PACKED PACKED_glUniform4f
#define glUniform4f_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glUniform4f_NOT_VOID_WRAP(...) {}
#define pack_glUniform4f(_location, _v0, _v1, _v2, _v3) ({ \
    glUniform4f_PACKED *packed_data = malloc(sizeof(glUniform4f_PACKED)); \
    packed_data->index = glUniform4f_INDEX; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.v0 = (GLfloat)_v0; \
    packed_data->args.v1 = (GLfloat)_v1; \
    packed_data->args.v2 = (GLfloat)_v2; \
    packed_data->args.v3 = (GLfloat)_v3; \
    (packed_call_t *)packed_data; \
})
#define call_glUniform4f(packed, ret_v) do { \
    PACKED_glUniform4f *unpacked = (PACKED_glUniform4f *)packed; \
    ARGS_glUniform4f *args = (ARGS_glUniform4f *)&unpacked->args; \
    glUniform4f(args->location, args->v0, args->v1, args->v2, args->v3);; \
} while(0)
void glUniform4f(glUniform4f_ARG_EXPAND);
typedef void (*glUniform4f_PTR)(glUniform4f_ARG_EXPAND);
#define glUniform4fARB_INDEX 2216
#define glUniform4fARB_RETURN void
#define glUniform4fARB_ARG_NAMES location, v0, v1, v2, v3
#define glUniform4fARB_ARG_EXPAND GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3
#define glUniform4fARB_PACKED PACKED_glUniform4fARB
#define glUniform4fARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glUniform4fARB_NOT_VOID_WRAP(...) {}
#define pack_glUniform4fARB(_location, _v0, _v1, _v2, _v3) ({ \
    glUniform4fARB_PACKED *packed_data = malloc(sizeof(glUniform4fARB_PACKED)); \
    packed_data->index = glUniform4fARB_INDEX; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.v0 = (GLfloat)_v0; \
    packed_data->args.v1 = (GLfloat)_v1; \
    packed_data->args.v2 = (GLfloat)_v2; \
    packed_data->args.v3 = (GLfloat)_v3; \
    (packed_call_t *)packed_data; \
})
#define call_glUniform4fARB(packed, ret_v) do { \
    PACKED_glUniform4fARB *unpacked = (PACKED_glUniform4fARB *)packed; \
    ARGS_glUniform4fARB *args = (ARGS_glUniform4fARB *)&unpacked->args; \
    glUniform4fARB(args->location, args->v0, args->v1, args->v2, args->v3);; \
} while(0)
void glUniform4fARB(glUniform4fARB_ARG_EXPAND);
typedef void (*glUniform4fARB_PTR)(glUniform4fARB_ARG_EXPAND);
#define glUniform4fv_INDEX 2217
#define glUniform4fv_RETURN void
#define glUniform4fv_ARG_NAMES location, count, value
#define glUniform4fv_ARG_EXPAND GLint location, GLsizei count, const GLfloat * value
#define glUniform4fv_PACKED PACKED_glUniform4fv
#define glUniform4fv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glUniform4fv_NOT_VOID_WRAP(...) {}
#define pack_glUniform4fv(_location, _count, _value) ({ \
    glUniform4fv_PACKED *packed_data = malloc(sizeof(glUniform4fv_PACKED)); \
    packed_data->index = glUniform4fv_INDEX; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.value = (GLfloat *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glUniform4fv(packed, ret_v) do { \
    PACKED_glUniform4fv *unpacked = (PACKED_glUniform4fv *)packed; \
    ARGS_glUniform4fv *args = (ARGS_glUniform4fv *)&unpacked->args; \
    glUniform4fv(args->location, args->count, args->value);; \
} while(0)
void glUniform4fv(glUniform4fv_ARG_EXPAND);
typedef void (*glUniform4fv_PTR)(glUniform4fv_ARG_EXPAND);
#define glUniform4fvARB_INDEX 2218
#define glUniform4fvARB_RETURN void
#define glUniform4fvARB_ARG_NAMES location, count, value
#define glUniform4fvARB_ARG_EXPAND GLint location, GLsizei count, const GLfloat * value
#define glUniform4fvARB_PACKED PACKED_glUniform4fvARB
#define glUniform4fvARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glUniform4fvARB_NOT_VOID_WRAP(...) {}
#define pack_glUniform4fvARB(_location, _count, _value) ({ \
    glUniform4fvARB_PACKED *packed_data = malloc(sizeof(glUniform4fvARB_PACKED)); \
    packed_data->index = glUniform4fvARB_INDEX; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.value = (GLfloat *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glUniform4fvARB(packed, ret_v) do { \
    PACKED_glUniform4fvARB *unpacked = (PACKED_glUniform4fvARB *)packed; \
    ARGS_glUniform4fvARB *args = (ARGS_glUniform4fvARB *)&unpacked->args; \
    glUniform4fvARB(args->location, args->count, args->value);; \
} while(0)
void glUniform4fvARB(glUniform4fvARB_ARG_EXPAND);
typedef void (*glUniform4fvARB_PTR)(glUniform4fvARB_ARG_EXPAND);
#define glUniform4i_INDEX 2219
#define glUniform4i_RETURN void
#define glUniform4i_ARG_NAMES location, v0, v1, v2, v3
#define glUniform4i_ARG_EXPAND GLint location, GLint v0, GLint v1, GLint v2, GLint v3
#define glUniform4i_PACKED PACKED_glUniform4i
#define glUniform4i_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glUniform4i_NOT_VOID_WRAP(...) {}
#define pack_glUniform4i(_location, _v0, _v1, _v2, _v3) ({ \
    glUniform4i_PACKED *packed_data = malloc(sizeof(glUniform4i_PACKED)); \
    packed_data->index = glUniform4i_INDEX; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.v0 = (GLint)_v0; \
    packed_data->args.v1 = (GLint)_v1; \
    packed_data->args.v2 = (GLint)_v2; \
    packed_data->args.v3 = (GLint)_v3; \
    (packed_call_t *)packed_data; \
})
#define call_glUniform4i(packed, ret_v) do { \
    PACKED_glUniform4i *unpacked = (PACKED_glUniform4i *)packed; \
    ARGS_glUniform4i *args = (ARGS_glUniform4i *)&unpacked->args; \
    glUniform4i(args->location, args->v0, args->v1, args->v2, args->v3);; \
} while(0)
void glUniform4i(glUniform4i_ARG_EXPAND);
typedef void (*glUniform4i_PTR)(glUniform4i_ARG_EXPAND);
#define glUniform4i64NV_INDEX 2220
#define glUniform4i64NV_RETURN void
#define glUniform4i64NV_ARG_NAMES location, x, y, z, w
#define glUniform4i64NV_ARG_EXPAND GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w
#define glUniform4i64NV_PACKED PACKED_glUniform4i64NV
#define glUniform4i64NV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glUniform4i64NV_NOT_VOID_WRAP(...) {}
#define pack_glUniform4i64NV(_location, _x, _y, _z, _w) ({ \
    glUniform4i64NV_PACKED *packed_data = malloc(sizeof(glUniform4i64NV_PACKED)); \
    packed_data->index = glUniform4i64NV_INDEX; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.x = (GLint64EXT)_x; \
    packed_data->args.y = (GLint64EXT)_y; \
    packed_data->args.z = (GLint64EXT)_z; \
    packed_data->args.w = (GLint64EXT)_w; \
    (packed_call_t *)packed_data; \
})
#define call_glUniform4i64NV(packed, ret_v) do { \
    PACKED_glUniform4i64NV *unpacked = (PACKED_glUniform4i64NV *)packed; \
    ARGS_glUniform4i64NV *args = (ARGS_glUniform4i64NV *)&unpacked->args; \
    glUniform4i64NV(args->location, args->x, args->y, args->z, args->w);; \
} while(0)
void glUniform4i64NV(glUniform4i64NV_ARG_EXPAND);
typedef void (*glUniform4i64NV_PTR)(glUniform4i64NV_ARG_EXPAND);
#define glUniform4i64vNV_INDEX 2221
#define glUniform4i64vNV_RETURN void
#define glUniform4i64vNV_ARG_NAMES location, count, value
#define glUniform4i64vNV_ARG_EXPAND GLint location, GLsizei count, const GLint64EXT * value
#define glUniform4i64vNV_PACKED PACKED_glUniform4i64vNV
#define glUniform4i64vNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glUniform4i64vNV_NOT_VOID_WRAP(...) {}
#define pack_glUniform4i64vNV(_location, _count, _value) ({ \
    glUniform4i64vNV_PACKED *packed_data = malloc(sizeof(glUniform4i64vNV_PACKED)); \
    packed_data->index = glUniform4i64vNV_INDEX; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.value = (GLint64EXT *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glUniform4i64vNV(packed, ret_v) do { \
    PACKED_glUniform4i64vNV *unpacked = (PACKED_glUniform4i64vNV *)packed; \
    ARGS_glUniform4i64vNV *args = (ARGS_glUniform4i64vNV *)&unpacked->args; \
    glUniform4i64vNV(args->location, args->count, args->value);; \
} while(0)
void glUniform4i64vNV(glUniform4i64vNV_ARG_EXPAND);
typedef void (*glUniform4i64vNV_PTR)(glUniform4i64vNV_ARG_EXPAND);
#define glUniform4iARB_INDEX 2222
#define glUniform4iARB_RETURN void
#define glUniform4iARB_ARG_NAMES location, v0, v1, v2, v3
#define glUniform4iARB_ARG_EXPAND GLint location, GLint v0, GLint v1, GLint v2, GLint v3
#define glUniform4iARB_PACKED PACKED_glUniform4iARB
#define glUniform4iARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glUniform4iARB_NOT_VOID_WRAP(...) {}
#define pack_glUniform4iARB(_location, _v0, _v1, _v2, _v3) ({ \
    glUniform4iARB_PACKED *packed_data = malloc(sizeof(glUniform4iARB_PACKED)); \
    packed_data->index = glUniform4iARB_INDEX; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.v0 = (GLint)_v0; \
    packed_data->args.v1 = (GLint)_v1; \
    packed_data->args.v2 = (GLint)_v2; \
    packed_data->args.v3 = (GLint)_v3; \
    (packed_call_t *)packed_data; \
})
#define call_glUniform4iARB(packed, ret_v) do { \
    PACKED_glUniform4iARB *unpacked = (PACKED_glUniform4iARB *)packed; \
    ARGS_glUniform4iARB *args = (ARGS_glUniform4iARB *)&unpacked->args; \
    glUniform4iARB(args->location, args->v0, args->v1, args->v2, args->v3);; \
} while(0)
void glUniform4iARB(glUniform4iARB_ARG_EXPAND);
typedef void (*glUniform4iARB_PTR)(glUniform4iARB_ARG_EXPAND);
#define glUniform4iv_INDEX 2223
#define glUniform4iv_RETURN void
#define glUniform4iv_ARG_NAMES location, count, value
#define glUniform4iv_ARG_EXPAND GLint location, GLsizei count, const GLint * value
#define glUniform4iv_PACKED PACKED_glUniform4iv
#define glUniform4iv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glUniform4iv_NOT_VOID_WRAP(...) {}
#define pack_glUniform4iv(_location, _count, _value) ({ \
    glUniform4iv_PACKED *packed_data = malloc(sizeof(glUniform4iv_PACKED)); \
    packed_data->index = glUniform4iv_INDEX; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.value = (GLint *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glUniform4iv(packed, ret_v) do { \
    PACKED_glUniform4iv *unpacked = (PACKED_glUniform4iv *)packed; \
    ARGS_glUniform4iv *args = (ARGS_glUniform4iv *)&unpacked->args; \
    glUniform4iv(args->location, args->count, args->value);; \
} while(0)
void glUniform4iv(glUniform4iv_ARG_EXPAND);
typedef void (*glUniform4iv_PTR)(glUniform4iv_ARG_EXPAND);
#define glUniform4ivARB_INDEX 2224
#define glUniform4ivARB_RETURN void
#define glUniform4ivARB_ARG_NAMES location, count, value
#define glUniform4ivARB_ARG_EXPAND GLint location, GLsizei count, const GLint * value
#define glUniform4ivARB_PACKED PACKED_glUniform4ivARB
#define glUniform4ivARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glUniform4ivARB_NOT_VOID_WRAP(...) {}
#define pack_glUniform4ivARB(_location, _count, _value) ({ \
    glUniform4ivARB_PACKED *packed_data = malloc(sizeof(glUniform4ivARB_PACKED)); \
    packed_data->index = glUniform4ivARB_INDEX; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.value = (GLint *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glUniform4ivARB(packed, ret_v) do { \
    PACKED_glUniform4ivARB *unpacked = (PACKED_glUniform4ivARB *)packed; \
    ARGS_glUniform4ivARB *args = (ARGS_glUniform4ivARB *)&unpacked->args; \
    glUniform4ivARB(args->location, args->count, args->value);; \
} while(0)
void glUniform4ivARB(glUniform4ivARB_ARG_EXPAND);
typedef void (*glUniform4ivARB_PTR)(glUniform4ivARB_ARG_EXPAND);
#define glUniform4ui_INDEX 2225
#define glUniform4ui_RETURN void
#define glUniform4ui_ARG_NAMES location, v0, v1, v2, v3
#define glUniform4ui_ARG_EXPAND GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3
#define glUniform4ui_PACKED PACKED_glUniform4ui
#define glUniform4ui_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glUniform4ui_NOT_VOID_WRAP(...) {}
#define pack_glUniform4ui(_location, _v0, _v1, _v2, _v3) ({ \
    glUniform4ui_PACKED *packed_data = malloc(sizeof(glUniform4ui_PACKED)); \
    packed_data->index = glUniform4ui_INDEX; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.v0 = (GLuint)_v0; \
    packed_data->args.v1 = (GLuint)_v1; \
    packed_data->args.v2 = (GLuint)_v2; \
    packed_data->args.v3 = (GLuint)_v3; \
    (packed_call_t *)packed_data; \
})
#define call_glUniform4ui(packed, ret_v) do { \
    PACKED_glUniform4ui *unpacked = (PACKED_glUniform4ui *)packed; \
    ARGS_glUniform4ui *args = (ARGS_glUniform4ui *)&unpacked->args; \
    glUniform4ui(args->location, args->v0, args->v1, args->v2, args->v3);; \
} while(0)
void glUniform4ui(glUniform4ui_ARG_EXPAND);
typedef void (*glUniform4ui_PTR)(glUniform4ui_ARG_EXPAND);
#define glUniform4ui64NV_INDEX 2226
#define glUniform4ui64NV_RETURN void
#define glUniform4ui64NV_ARG_NAMES location, x, y, z, w
#define glUniform4ui64NV_ARG_EXPAND GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w
#define glUniform4ui64NV_PACKED PACKED_glUniform4ui64NV
#define glUniform4ui64NV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glUniform4ui64NV_NOT_VOID_WRAP(...) {}
#define pack_glUniform4ui64NV(_location, _x, _y, _z, _w) ({ \
    glUniform4ui64NV_PACKED *packed_data = malloc(sizeof(glUniform4ui64NV_PACKED)); \
    packed_data->index = glUniform4ui64NV_INDEX; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.x = (GLuint64EXT)_x; \
    packed_data->args.y = (GLuint64EXT)_y; \
    packed_data->args.z = (GLuint64EXT)_z; \
    packed_data->args.w = (GLuint64EXT)_w; \
    (packed_call_t *)packed_data; \
})
#define call_glUniform4ui64NV(packed, ret_v) do { \
    PACKED_glUniform4ui64NV *unpacked = (PACKED_glUniform4ui64NV *)packed; \
    ARGS_glUniform4ui64NV *args = (ARGS_glUniform4ui64NV *)&unpacked->args; \
    glUniform4ui64NV(args->location, args->x, args->y, args->z, args->w);; \
} while(0)
void glUniform4ui64NV(glUniform4ui64NV_ARG_EXPAND);
typedef void (*glUniform4ui64NV_PTR)(glUniform4ui64NV_ARG_EXPAND);
#define glUniform4ui64vNV_INDEX 2227
#define glUniform4ui64vNV_RETURN void
#define glUniform4ui64vNV_ARG_NAMES location, count, value
#define glUniform4ui64vNV_ARG_EXPAND GLint location, GLsizei count, const GLuint64EXT * value
#define glUniform4ui64vNV_PACKED PACKED_glUniform4ui64vNV
#define glUniform4ui64vNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glUniform4ui64vNV_NOT_VOID_WRAP(...) {}
#define pack_glUniform4ui64vNV(_location, _count, _value) ({ \
    glUniform4ui64vNV_PACKED *packed_data = malloc(sizeof(glUniform4ui64vNV_PACKED)); \
    packed_data->index = glUniform4ui64vNV_INDEX; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.value = (GLuint64EXT *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glUniform4ui64vNV(packed, ret_v) do { \
    PACKED_glUniform4ui64vNV *unpacked = (PACKED_glUniform4ui64vNV *)packed; \
    ARGS_glUniform4ui64vNV *args = (ARGS_glUniform4ui64vNV *)&unpacked->args; \
    glUniform4ui64vNV(args->location, args->count, args->value);; \
} while(0)
void glUniform4ui64vNV(glUniform4ui64vNV_ARG_EXPAND);
typedef void (*glUniform4ui64vNV_PTR)(glUniform4ui64vNV_ARG_EXPAND);
#define glUniform4uiEXT_INDEX 2228
#define glUniform4uiEXT_RETURN void
#define glUniform4uiEXT_ARG_NAMES location, v0, v1, v2, v3
#define glUniform4uiEXT_ARG_EXPAND GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3
#define glUniform4uiEXT_PACKED PACKED_glUniform4uiEXT
#define glUniform4uiEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glUniform4uiEXT_NOT_VOID_WRAP(...) {}
#define pack_glUniform4uiEXT(_location, _v0, _v1, _v2, _v3) ({ \
    glUniform4uiEXT_PACKED *packed_data = malloc(sizeof(glUniform4uiEXT_PACKED)); \
    packed_data->index = glUniform4uiEXT_INDEX; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.v0 = (GLuint)_v0; \
    packed_data->args.v1 = (GLuint)_v1; \
    packed_data->args.v2 = (GLuint)_v2; \
    packed_data->args.v3 = (GLuint)_v3; \
    (packed_call_t *)packed_data; \
})
#define call_glUniform4uiEXT(packed, ret_v) do { \
    PACKED_glUniform4uiEXT *unpacked = (PACKED_glUniform4uiEXT *)packed; \
    ARGS_glUniform4uiEXT *args = (ARGS_glUniform4uiEXT *)&unpacked->args; \
    glUniform4uiEXT(args->location, args->v0, args->v1, args->v2, args->v3);; \
} while(0)
void glUniform4uiEXT(glUniform4uiEXT_ARG_EXPAND);
typedef void (*glUniform4uiEXT_PTR)(glUniform4uiEXT_ARG_EXPAND);
#define glUniform4uiv_INDEX 2229
#define glUniform4uiv_RETURN void
#define glUniform4uiv_ARG_NAMES location, count, value
#define glUniform4uiv_ARG_EXPAND GLint location, GLsizei count, const GLuint * value
#define glUniform4uiv_PACKED PACKED_glUniform4uiv
#define glUniform4uiv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glUniform4uiv_NOT_VOID_WRAP(...) {}
#define pack_glUniform4uiv(_location, _count, _value) ({ \
    glUniform4uiv_PACKED *packed_data = malloc(sizeof(glUniform4uiv_PACKED)); \
    packed_data->index = glUniform4uiv_INDEX; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.value = (GLuint *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glUniform4uiv(packed, ret_v) do { \
    PACKED_glUniform4uiv *unpacked = (PACKED_glUniform4uiv *)packed; \
    ARGS_glUniform4uiv *args = (ARGS_glUniform4uiv *)&unpacked->args; \
    glUniform4uiv(args->location, args->count, args->value);; \
} while(0)
void glUniform4uiv(glUniform4uiv_ARG_EXPAND);
typedef void (*glUniform4uiv_PTR)(glUniform4uiv_ARG_EXPAND);
#define glUniform4uivEXT_INDEX 2230
#define glUniform4uivEXT_RETURN void
#define glUniform4uivEXT_ARG_NAMES location, count, value
#define glUniform4uivEXT_ARG_EXPAND GLint location, GLsizei count, const GLuint * value
#define glUniform4uivEXT_PACKED PACKED_glUniform4uivEXT
#define glUniform4uivEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glUniform4uivEXT_NOT_VOID_WRAP(...) {}
#define pack_glUniform4uivEXT(_location, _count, _value) ({ \
    glUniform4uivEXT_PACKED *packed_data = malloc(sizeof(glUniform4uivEXT_PACKED)); \
    packed_data->index = glUniform4uivEXT_INDEX; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.value = (GLuint *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glUniform4uivEXT(packed, ret_v) do { \
    PACKED_glUniform4uivEXT *unpacked = (PACKED_glUniform4uivEXT *)packed; \
    ARGS_glUniform4uivEXT *args = (ARGS_glUniform4uivEXT *)&unpacked->args; \
    glUniform4uivEXT(args->location, args->count, args->value);; \
} while(0)
void glUniform4uivEXT(glUniform4uivEXT_ARG_EXPAND);
typedef void (*glUniform4uivEXT_PTR)(glUniform4uivEXT_ARG_EXPAND);
#define glUniformBlockBinding_INDEX 2231
#define glUniformBlockBinding_RETURN void
#define glUniformBlockBinding_ARG_NAMES program, uniformBlockIndex, uniformBlockBinding
#define glUniformBlockBinding_ARG_EXPAND GLuint program, GLuint uniformBlockIndex, GLuint uniformBlockBinding
#define glUniformBlockBinding_PACKED PACKED_glUniformBlockBinding
#define glUniformBlockBinding_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glUniformBlockBinding_NOT_VOID_WRAP(...) {}
#define pack_glUniformBlockBinding(_program, _uniformBlockIndex, _uniformBlockBinding) ({ \
    glUniformBlockBinding_PACKED *packed_data = malloc(sizeof(glUniformBlockBinding_PACKED)); \
    packed_data->index = glUniformBlockBinding_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.uniformBlockIndex = (GLuint)_uniformBlockIndex; \
    packed_data->args.uniformBlockBinding = (GLuint)_uniformBlockBinding; \
    (packed_call_t *)packed_data; \
})
#define call_glUniformBlockBinding(packed, ret_v) do { \
    PACKED_glUniformBlockBinding *unpacked = (PACKED_glUniformBlockBinding *)packed; \
    ARGS_glUniformBlockBinding *args = (ARGS_glUniformBlockBinding *)&unpacked->args; \
    glUniformBlockBinding(args->program, args->uniformBlockIndex, args->uniformBlockBinding);; \
} while(0)
void glUniformBlockBinding(glUniformBlockBinding_ARG_EXPAND);
typedef void (*glUniformBlockBinding_PTR)(glUniformBlockBinding_ARG_EXPAND);
#define glUniformBufferEXT_INDEX 2232
#define glUniformBufferEXT_RETURN void
#define glUniformBufferEXT_ARG_NAMES program, location, buffer
#define glUniformBufferEXT_ARG_EXPAND GLuint program, GLint location, GLuint buffer
#define glUniformBufferEXT_PACKED PACKED_glUniformBufferEXT
#define glUniformBufferEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glUniformBufferEXT_NOT_VOID_WRAP(...) {}
#define pack_glUniformBufferEXT(_program, _location, _buffer) ({ \
    glUniformBufferEXT_PACKED *packed_data = malloc(sizeof(glUniformBufferEXT_PACKED)); \
    packed_data->index = glUniformBufferEXT_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.buffer = (GLuint)_buffer; \
    (packed_call_t *)packed_data; \
})
#define call_glUniformBufferEXT(packed, ret_v) do { \
    PACKED_glUniformBufferEXT *unpacked = (PACKED_glUniformBufferEXT *)packed; \
    ARGS_glUniformBufferEXT *args = (ARGS_glUniformBufferEXT *)&unpacked->args; \
    glUniformBufferEXT(args->program, args->location, args->buffer);; \
} while(0)
void glUniformBufferEXT(glUniformBufferEXT_ARG_EXPAND);
typedef void (*glUniformBufferEXT_PTR)(glUniformBufferEXT_ARG_EXPAND);
#define glUniformHandleui64NV_INDEX 2233
#define glUniformHandleui64NV_RETURN void
#define glUniformHandleui64NV_ARG_NAMES location, value
#define glUniformHandleui64NV_ARG_EXPAND GLint location, GLuint64 value
#define glUniformHandleui64NV_PACKED PACKED_glUniformHandleui64NV
#define glUniformHandleui64NV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glUniformHandleui64NV_NOT_VOID_WRAP(...) {}
#define pack_glUniformHandleui64NV(_location, _value) ({ \
    glUniformHandleui64NV_PACKED *packed_data = malloc(sizeof(glUniformHandleui64NV_PACKED)); \
    packed_data->index = glUniformHandleui64NV_INDEX; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.value = (GLuint64)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glUniformHandleui64NV(packed, ret_v) do { \
    PACKED_glUniformHandleui64NV *unpacked = (PACKED_glUniformHandleui64NV *)packed; \
    ARGS_glUniformHandleui64NV *args = (ARGS_glUniformHandleui64NV *)&unpacked->args; \
    glUniformHandleui64NV(args->location, args->value);; \
} while(0)
void glUniformHandleui64NV(glUniformHandleui64NV_ARG_EXPAND);
typedef void (*glUniformHandleui64NV_PTR)(glUniformHandleui64NV_ARG_EXPAND);
#define glUniformHandleui64vNV_INDEX 2234
#define glUniformHandleui64vNV_RETURN void
#define glUniformHandleui64vNV_ARG_NAMES location, count, value
#define glUniformHandleui64vNV_ARG_EXPAND GLint location, GLsizei count, const GLuint64 * value
#define glUniformHandleui64vNV_PACKED PACKED_glUniformHandleui64vNV
#define glUniformHandleui64vNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glUniformHandleui64vNV_NOT_VOID_WRAP(...) {}
#define pack_glUniformHandleui64vNV(_location, _count, _value) ({ \
    glUniformHandleui64vNV_PACKED *packed_data = malloc(sizeof(glUniformHandleui64vNV_PACKED)); \
    packed_data->index = glUniformHandleui64vNV_INDEX; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.value = (GLuint64 *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glUniformHandleui64vNV(packed, ret_v) do { \
    PACKED_glUniformHandleui64vNV *unpacked = (PACKED_glUniformHandleui64vNV *)packed; \
    ARGS_glUniformHandleui64vNV *args = (ARGS_glUniformHandleui64vNV *)&unpacked->args; \
    glUniformHandleui64vNV(args->location, args->count, args->value);; \
} while(0)
void glUniformHandleui64vNV(glUniformHandleui64vNV_ARG_EXPAND);
typedef void (*glUniformHandleui64vNV_PTR)(glUniformHandleui64vNV_ARG_EXPAND);
#define glUniformMatrix2dv_INDEX 2235
#define glUniformMatrix2dv_RETURN void
#define glUniformMatrix2dv_ARG_NAMES location, count, transpose, value
#define glUniformMatrix2dv_ARG_EXPAND GLint location, GLsizei count, GLboolean transpose, const GLdouble * value
#define glUniformMatrix2dv_PACKED PACKED_glUniformMatrix2dv
#define glUniformMatrix2dv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glUniformMatrix2dv_NOT_VOID_WRAP(...) {}
#define pack_glUniformMatrix2dv(_location, _count, _transpose, _value) ({ \
    glUniformMatrix2dv_PACKED *packed_data = malloc(sizeof(glUniformMatrix2dv_PACKED)); \
    packed_data->index = glUniformMatrix2dv_INDEX; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.transpose = (GLboolean)_transpose; \
    packed_data->args.value = (GLdouble *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glUniformMatrix2dv(packed, ret_v) do { \
    PACKED_glUniformMatrix2dv *unpacked = (PACKED_glUniformMatrix2dv *)packed; \
    ARGS_glUniformMatrix2dv *args = (ARGS_glUniformMatrix2dv *)&unpacked->args; \
    glUniformMatrix2dv(args->location, args->count, args->transpose, args->value);; \
} while(0)
void glUniformMatrix2dv(glUniformMatrix2dv_ARG_EXPAND);
typedef void (*glUniformMatrix2dv_PTR)(glUniformMatrix2dv_ARG_EXPAND);
#define glUniformMatrix2fv_INDEX 2236
#define glUniformMatrix2fv_RETURN void
#define glUniformMatrix2fv_ARG_NAMES location, count, transpose, value
#define glUniformMatrix2fv_ARG_EXPAND GLint location, GLsizei count, GLboolean transpose, const GLfloat * value
#define glUniformMatrix2fv_PACKED PACKED_glUniformMatrix2fv
#define glUniformMatrix2fv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glUniformMatrix2fv_NOT_VOID_WRAP(...) {}
#define pack_glUniformMatrix2fv(_location, _count, _transpose, _value) ({ \
    glUniformMatrix2fv_PACKED *packed_data = malloc(sizeof(glUniformMatrix2fv_PACKED)); \
    packed_data->index = glUniformMatrix2fv_INDEX; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.transpose = (GLboolean)_transpose; \
    packed_data->args.value = (GLfloat *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glUniformMatrix2fv(packed, ret_v) do { \
    PACKED_glUniformMatrix2fv *unpacked = (PACKED_glUniformMatrix2fv *)packed; \
    ARGS_glUniformMatrix2fv *args = (ARGS_glUniformMatrix2fv *)&unpacked->args; \
    glUniformMatrix2fv(args->location, args->count, args->transpose, args->value);; \
} while(0)
void glUniformMatrix2fv(glUniformMatrix2fv_ARG_EXPAND);
typedef void (*glUniformMatrix2fv_PTR)(glUniformMatrix2fv_ARG_EXPAND);
#define glUniformMatrix2fvARB_INDEX 2237
#define glUniformMatrix2fvARB_RETURN void
#define glUniformMatrix2fvARB_ARG_NAMES location, count, transpose, value
#define glUniformMatrix2fvARB_ARG_EXPAND GLint location, GLsizei count, GLboolean transpose, const GLfloat * value
#define glUniformMatrix2fvARB_PACKED PACKED_glUniformMatrix2fvARB
#define glUniformMatrix2fvARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glUniformMatrix2fvARB_NOT_VOID_WRAP(...) {}
#define pack_glUniformMatrix2fvARB(_location, _count, _transpose, _value) ({ \
    glUniformMatrix2fvARB_PACKED *packed_data = malloc(sizeof(glUniformMatrix2fvARB_PACKED)); \
    packed_data->index = glUniformMatrix2fvARB_INDEX; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.transpose = (GLboolean)_transpose; \
    packed_data->args.value = (GLfloat *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glUniformMatrix2fvARB(packed, ret_v) do { \
    PACKED_glUniformMatrix2fvARB *unpacked = (PACKED_glUniformMatrix2fvARB *)packed; \
    ARGS_glUniformMatrix2fvARB *args = (ARGS_glUniformMatrix2fvARB *)&unpacked->args; \
    glUniformMatrix2fvARB(args->location, args->count, args->transpose, args->value);; \
} while(0)
void glUniformMatrix2fvARB(glUniformMatrix2fvARB_ARG_EXPAND);
typedef void (*glUniformMatrix2fvARB_PTR)(glUniformMatrix2fvARB_ARG_EXPAND);
#define glUniformMatrix2x3dv_INDEX 2238
#define glUniformMatrix2x3dv_RETURN void
#define glUniformMatrix2x3dv_ARG_NAMES location, count, transpose, value
#define glUniformMatrix2x3dv_ARG_EXPAND GLint location, GLsizei count, GLboolean transpose, const GLdouble * value
#define glUniformMatrix2x3dv_PACKED PACKED_glUniformMatrix2x3dv
#define glUniformMatrix2x3dv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glUniformMatrix2x3dv_NOT_VOID_WRAP(...) {}
#define pack_glUniformMatrix2x3dv(_location, _count, _transpose, _value) ({ \
    glUniformMatrix2x3dv_PACKED *packed_data = malloc(sizeof(glUniformMatrix2x3dv_PACKED)); \
    packed_data->index = glUniformMatrix2x3dv_INDEX; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.transpose = (GLboolean)_transpose; \
    packed_data->args.value = (GLdouble *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glUniformMatrix2x3dv(packed, ret_v) do { \
    PACKED_glUniformMatrix2x3dv *unpacked = (PACKED_glUniformMatrix2x3dv *)packed; \
    ARGS_glUniformMatrix2x3dv *args = (ARGS_glUniformMatrix2x3dv *)&unpacked->args; \
    glUniformMatrix2x3dv(args->location, args->count, args->transpose, args->value);; \
} while(0)
void glUniformMatrix2x3dv(glUniformMatrix2x3dv_ARG_EXPAND);
typedef void (*glUniformMatrix2x3dv_PTR)(glUniformMatrix2x3dv_ARG_EXPAND);
#define glUniformMatrix2x3fv_INDEX 2239
#define glUniformMatrix2x3fv_RETURN void
#define glUniformMatrix2x3fv_ARG_NAMES location, count, transpose, value
#define glUniformMatrix2x3fv_ARG_EXPAND GLint location, GLsizei count, GLboolean transpose, const GLfloat * value
#define glUniformMatrix2x3fv_PACKED PACKED_glUniformMatrix2x3fv
#define glUniformMatrix2x3fv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glUniformMatrix2x3fv_NOT_VOID_WRAP(...) {}
#define pack_glUniformMatrix2x3fv(_location, _count, _transpose, _value) ({ \
    glUniformMatrix2x3fv_PACKED *packed_data = malloc(sizeof(glUniformMatrix2x3fv_PACKED)); \
    packed_data->index = glUniformMatrix2x3fv_INDEX; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.transpose = (GLboolean)_transpose; \
    packed_data->args.value = (GLfloat *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glUniformMatrix2x3fv(packed, ret_v) do { \
    PACKED_glUniformMatrix2x3fv *unpacked = (PACKED_glUniformMatrix2x3fv *)packed; \
    ARGS_glUniformMatrix2x3fv *args = (ARGS_glUniformMatrix2x3fv *)&unpacked->args; \
    glUniformMatrix2x3fv(args->location, args->count, args->transpose, args->value);; \
} while(0)
void glUniformMatrix2x3fv(glUniformMatrix2x3fv_ARG_EXPAND);
typedef void (*glUniformMatrix2x3fv_PTR)(glUniformMatrix2x3fv_ARG_EXPAND);
#define glUniformMatrix2x4dv_INDEX 2240
#define glUniformMatrix2x4dv_RETURN void
#define glUniformMatrix2x4dv_ARG_NAMES location, count, transpose, value
#define glUniformMatrix2x4dv_ARG_EXPAND GLint location, GLsizei count, GLboolean transpose, const GLdouble * value
#define glUniformMatrix2x4dv_PACKED PACKED_glUniformMatrix2x4dv
#define glUniformMatrix2x4dv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glUniformMatrix2x4dv_NOT_VOID_WRAP(...) {}
#define pack_glUniformMatrix2x4dv(_location, _count, _transpose, _value) ({ \
    glUniformMatrix2x4dv_PACKED *packed_data = malloc(sizeof(glUniformMatrix2x4dv_PACKED)); \
    packed_data->index = glUniformMatrix2x4dv_INDEX; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.transpose = (GLboolean)_transpose; \
    packed_data->args.value = (GLdouble *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glUniformMatrix2x4dv(packed, ret_v) do { \
    PACKED_glUniformMatrix2x4dv *unpacked = (PACKED_glUniformMatrix2x4dv *)packed; \
    ARGS_glUniformMatrix2x4dv *args = (ARGS_glUniformMatrix2x4dv *)&unpacked->args; \
    glUniformMatrix2x4dv(args->location, args->count, args->transpose, args->value);; \
} while(0)
void glUniformMatrix2x4dv(glUniformMatrix2x4dv_ARG_EXPAND);
typedef void (*glUniformMatrix2x4dv_PTR)(glUniformMatrix2x4dv_ARG_EXPAND);
#define glUniformMatrix2x4fv_INDEX 2241
#define glUniformMatrix2x4fv_RETURN void
#define glUniformMatrix2x4fv_ARG_NAMES location, count, transpose, value
#define glUniformMatrix2x4fv_ARG_EXPAND GLint location, GLsizei count, GLboolean transpose, const GLfloat * value
#define glUniformMatrix2x4fv_PACKED PACKED_glUniformMatrix2x4fv
#define glUniformMatrix2x4fv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glUniformMatrix2x4fv_NOT_VOID_WRAP(...) {}
#define pack_glUniformMatrix2x4fv(_location, _count, _transpose, _value) ({ \
    glUniformMatrix2x4fv_PACKED *packed_data = malloc(sizeof(glUniformMatrix2x4fv_PACKED)); \
    packed_data->index = glUniformMatrix2x4fv_INDEX; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.transpose = (GLboolean)_transpose; \
    packed_data->args.value = (GLfloat *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glUniformMatrix2x4fv(packed, ret_v) do { \
    PACKED_glUniformMatrix2x4fv *unpacked = (PACKED_glUniformMatrix2x4fv *)packed; \
    ARGS_glUniformMatrix2x4fv *args = (ARGS_glUniformMatrix2x4fv *)&unpacked->args; \
    glUniformMatrix2x4fv(args->location, args->count, args->transpose, args->value);; \
} while(0)
void glUniformMatrix2x4fv(glUniformMatrix2x4fv_ARG_EXPAND);
typedef void (*glUniformMatrix2x4fv_PTR)(glUniformMatrix2x4fv_ARG_EXPAND);
#define glUniformMatrix3dv_INDEX 2242
#define glUniformMatrix3dv_RETURN void
#define glUniformMatrix3dv_ARG_NAMES location, count, transpose, value
#define glUniformMatrix3dv_ARG_EXPAND GLint location, GLsizei count, GLboolean transpose, const GLdouble * value
#define glUniformMatrix3dv_PACKED PACKED_glUniformMatrix3dv
#define glUniformMatrix3dv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glUniformMatrix3dv_NOT_VOID_WRAP(...) {}
#define pack_glUniformMatrix3dv(_location, _count, _transpose, _value) ({ \
    glUniformMatrix3dv_PACKED *packed_data = malloc(sizeof(glUniformMatrix3dv_PACKED)); \
    packed_data->index = glUniformMatrix3dv_INDEX; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.transpose = (GLboolean)_transpose; \
    packed_data->args.value = (GLdouble *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glUniformMatrix3dv(packed, ret_v) do { \
    PACKED_glUniformMatrix3dv *unpacked = (PACKED_glUniformMatrix3dv *)packed; \
    ARGS_glUniformMatrix3dv *args = (ARGS_glUniformMatrix3dv *)&unpacked->args; \
    glUniformMatrix3dv(args->location, args->count, args->transpose, args->value);; \
} while(0)
void glUniformMatrix3dv(glUniformMatrix3dv_ARG_EXPAND);
typedef void (*glUniformMatrix3dv_PTR)(glUniformMatrix3dv_ARG_EXPAND);
#define glUniformMatrix3fv_INDEX 2243
#define glUniformMatrix3fv_RETURN void
#define glUniformMatrix3fv_ARG_NAMES location, count, transpose, value
#define glUniformMatrix3fv_ARG_EXPAND GLint location, GLsizei count, GLboolean transpose, const GLfloat * value
#define glUniformMatrix3fv_PACKED PACKED_glUniformMatrix3fv
#define glUniformMatrix3fv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glUniformMatrix3fv_NOT_VOID_WRAP(...) {}
#define pack_glUniformMatrix3fv(_location, _count, _transpose, _value) ({ \
    glUniformMatrix3fv_PACKED *packed_data = malloc(sizeof(glUniformMatrix3fv_PACKED)); \
    packed_data->index = glUniformMatrix3fv_INDEX; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.transpose = (GLboolean)_transpose; \
    packed_data->args.value = (GLfloat *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glUniformMatrix3fv(packed, ret_v) do { \
    PACKED_glUniformMatrix3fv *unpacked = (PACKED_glUniformMatrix3fv *)packed; \
    ARGS_glUniformMatrix3fv *args = (ARGS_glUniformMatrix3fv *)&unpacked->args; \
    glUniformMatrix3fv(args->location, args->count, args->transpose, args->value);; \
} while(0)
void glUniformMatrix3fv(glUniformMatrix3fv_ARG_EXPAND);
typedef void (*glUniformMatrix3fv_PTR)(glUniformMatrix3fv_ARG_EXPAND);
#define glUniformMatrix3fvARB_INDEX 2244
#define glUniformMatrix3fvARB_RETURN void
#define glUniformMatrix3fvARB_ARG_NAMES location, count, transpose, value
#define glUniformMatrix3fvARB_ARG_EXPAND GLint location, GLsizei count, GLboolean transpose, const GLfloat * value
#define glUniformMatrix3fvARB_PACKED PACKED_glUniformMatrix3fvARB
#define glUniformMatrix3fvARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glUniformMatrix3fvARB_NOT_VOID_WRAP(...) {}
#define pack_glUniformMatrix3fvARB(_location, _count, _transpose, _value) ({ \
    glUniformMatrix3fvARB_PACKED *packed_data = malloc(sizeof(glUniformMatrix3fvARB_PACKED)); \
    packed_data->index = glUniformMatrix3fvARB_INDEX; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.transpose = (GLboolean)_transpose; \
    packed_data->args.value = (GLfloat *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glUniformMatrix3fvARB(packed, ret_v) do { \
    PACKED_glUniformMatrix3fvARB *unpacked = (PACKED_glUniformMatrix3fvARB *)packed; \
    ARGS_glUniformMatrix3fvARB *args = (ARGS_glUniformMatrix3fvARB *)&unpacked->args; \
    glUniformMatrix3fvARB(args->location, args->count, args->transpose, args->value);; \
} while(0)
void glUniformMatrix3fvARB(glUniformMatrix3fvARB_ARG_EXPAND);
typedef void (*glUniformMatrix3fvARB_PTR)(glUniformMatrix3fvARB_ARG_EXPAND);
#define glUniformMatrix3x2dv_INDEX 2245
#define glUniformMatrix3x2dv_RETURN void
#define glUniformMatrix3x2dv_ARG_NAMES location, count, transpose, value
#define glUniformMatrix3x2dv_ARG_EXPAND GLint location, GLsizei count, GLboolean transpose, const GLdouble * value
#define glUniformMatrix3x2dv_PACKED PACKED_glUniformMatrix3x2dv
#define glUniformMatrix3x2dv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glUniformMatrix3x2dv_NOT_VOID_WRAP(...) {}
#define pack_glUniformMatrix3x2dv(_location, _count, _transpose, _value) ({ \
    glUniformMatrix3x2dv_PACKED *packed_data = malloc(sizeof(glUniformMatrix3x2dv_PACKED)); \
    packed_data->index = glUniformMatrix3x2dv_INDEX; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.transpose = (GLboolean)_transpose; \
    packed_data->args.value = (GLdouble *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glUniformMatrix3x2dv(packed, ret_v) do { \
    PACKED_glUniformMatrix3x2dv *unpacked = (PACKED_glUniformMatrix3x2dv *)packed; \
    ARGS_glUniformMatrix3x2dv *args = (ARGS_glUniformMatrix3x2dv *)&unpacked->args; \
    glUniformMatrix3x2dv(args->location, args->count, args->transpose, args->value);; \
} while(0)
void glUniformMatrix3x2dv(glUniformMatrix3x2dv_ARG_EXPAND);
typedef void (*glUniformMatrix3x2dv_PTR)(glUniformMatrix3x2dv_ARG_EXPAND);
#define glUniformMatrix3x2fv_INDEX 2246
#define glUniformMatrix3x2fv_RETURN void
#define glUniformMatrix3x2fv_ARG_NAMES location, count, transpose, value
#define glUniformMatrix3x2fv_ARG_EXPAND GLint location, GLsizei count, GLboolean transpose, const GLfloat * value
#define glUniformMatrix3x2fv_PACKED PACKED_glUniformMatrix3x2fv
#define glUniformMatrix3x2fv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glUniformMatrix3x2fv_NOT_VOID_WRAP(...) {}
#define pack_glUniformMatrix3x2fv(_location, _count, _transpose, _value) ({ \
    glUniformMatrix3x2fv_PACKED *packed_data = malloc(sizeof(glUniformMatrix3x2fv_PACKED)); \
    packed_data->index = glUniformMatrix3x2fv_INDEX; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.transpose = (GLboolean)_transpose; \
    packed_data->args.value = (GLfloat *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glUniformMatrix3x2fv(packed, ret_v) do { \
    PACKED_glUniformMatrix3x2fv *unpacked = (PACKED_glUniformMatrix3x2fv *)packed; \
    ARGS_glUniformMatrix3x2fv *args = (ARGS_glUniformMatrix3x2fv *)&unpacked->args; \
    glUniformMatrix3x2fv(args->location, args->count, args->transpose, args->value);; \
} while(0)
void glUniformMatrix3x2fv(glUniformMatrix3x2fv_ARG_EXPAND);
typedef void (*glUniformMatrix3x2fv_PTR)(glUniformMatrix3x2fv_ARG_EXPAND);
#define glUniformMatrix3x4dv_INDEX 2247
#define glUniformMatrix3x4dv_RETURN void
#define glUniformMatrix3x4dv_ARG_NAMES location, count, transpose, value
#define glUniformMatrix3x4dv_ARG_EXPAND GLint location, GLsizei count, GLboolean transpose, const GLdouble * value
#define glUniformMatrix3x4dv_PACKED PACKED_glUniformMatrix3x4dv
#define glUniformMatrix3x4dv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glUniformMatrix3x4dv_NOT_VOID_WRAP(...) {}
#define pack_glUniformMatrix3x4dv(_location, _count, _transpose, _value) ({ \
    glUniformMatrix3x4dv_PACKED *packed_data = malloc(sizeof(glUniformMatrix3x4dv_PACKED)); \
    packed_data->index = glUniformMatrix3x4dv_INDEX; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.transpose = (GLboolean)_transpose; \
    packed_data->args.value = (GLdouble *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glUniformMatrix3x4dv(packed, ret_v) do { \
    PACKED_glUniformMatrix3x4dv *unpacked = (PACKED_glUniformMatrix3x4dv *)packed; \
    ARGS_glUniformMatrix3x4dv *args = (ARGS_glUniformMatrix3x4dv *)&unpacked->args; \
    glUniformMatrix3x4dv(args->location, args->count, args->transpose, args->value);; \
} while(0)
void glUniformMatrix3x4dv(glUniformMatrix3x4dv_ARG_EXPAND);
typedef void (*glUniformMatrix3x4dv_PTR)(glUniformMatrix3x4dv_ARG_EXPAND);
#define glUniformMatrix3x4fv_INDEX 2248
#define glUniformMatrix3x4fv_RETURN void
#define glUniformMatrix3x4fv_ARG_NAMES location, count, transpose, value
#define glUniformMatrix3x4fv_ARG_EXPAND GLint location, GLsizei count, GLboolean transpose, const GLfloat * value
#define glUniformMatrix3x4fv_PACKED PACKED_glUniformMatrix3x4fv
#define glUniformMatrix3x4fv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glUniformMatrix3x4fv_NOT_VOID_WRAP(...) {}
#define pack_glUniformMatrix3x4fv(_location, _count, _transpose, _value) ({ \
    glUniformMatrix3x4fv_PACKED *packed_data = malloc(sizeof(glUniformMatrix3x4fv_PACKED)); \
    packed_data->index = glUniformMatrix3x4fv_INDEX; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.transpose = (GLboolean)_transpose; \
    packed_data->args.value = (GLfloat *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glUniformMatrix3x4fv(packed, ret_v) do { \
    PACKED_glUniformMatrix3x4fv *unpacked = (PACKED_glUniformMatrix3x4fv *)packed; \
    ARGS_glUniformMatrix3x4fv *args = (ARGS_glUniformMatrix3x4fv *)&unpacked->args; \
    glUniformMatrix3x4fv(args->location, args->count, args->transpose, args->value);; \
} while(0)
void glUniformMatrix3x4fv(glUniformMatrix3x4fv_ARG_EXPAND);
typedef void (*glUniformMatrix3x4fv_PTR)(glUniformMatrix3x4fv_ARG_EXPAND);
#define glUniformMatrix4dv_INDEX 2249
#define glUniformMatrix4dv_RETURN void
#define glUniformMatrix4dv_ARG_NAMES location, count, transpose, value
#define glUniformMatrix4dv_ARG_EXPAND GLint location, GLsizei count, GLboolean transpose, const GLdouble * value
#define glUniformMatrix4dv_PACKED PACKED_glUniformMatrix4dv
#define glUniformMatrix4dv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glUniformMatrix4dv_NOT_VOID_WRAP(...) {}
#define pack_glUniformMatrix4dv(_location, _count, _transpose, _value) ({ \
    glUniformMatrix4dv_PACKED *packed_data = malloc(sizeof(glUniformMatrix4dv_PACKED)); \
    packed_data->index = glUniformMatrix4dv_INDEX; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.transpose = (GLboolean)_transpose; \
    packed_data->args.value = (GLdouble *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glUniformMatrix4dv(packed, ret_v) do { \
    PACKED_glUniformMatrix4dv *unpacked = (PACKED_glUniformMatrix4dv *)packed; \
    ARGS_glUniformMatrix4dv *args = (ARGS_glUniformMatrix4dv *)&unpacked->args; \
    glUniformMatrix4dv(args->location, args->count, args->transpose, args->value);; \
} while(0)
void glUniformMatrix4dv(glUniformMatrix4dv_ARG_EXPAND);
typedef void (*glUniformMatrix4dv_PTR)(glUniformMatrix4dv_ARG_EXPAND);
#define glUniformMatrix4fv_INDEX 2250
#define glUniformMatrix4fv_RETURN void
#define glUniformMatrix4fv_ARG_NAMES location, count, transpose, value
#define glUniformMatrix4fv_ARG_EXPAND GLint location, GLsizei count, GLboolean transpose, const GLfloat * value
#define glUniformMatrix4fv_PACKED PACKED_glUniformMatrix4fv
#define glUniformMatrix4fv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glUniformMatrix4fv_NOT_VOID_WRAP(...) {}
#define pack_glUniformMatrix4fv(_location, _count, _transpose, _value) ({ \
    glUniformMatrix4fv_PACKED *packed_data = malloc(sizeof(glUniformMatrix4fv_PACKED)); \
    packed_data->index = glUniformMatrix4fv_INDEX; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.transpose = (GLboolean)_transpose; \
    packed_data->args.value = (GLfloat *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glUniformMatrix4fv(packed, ret_v) do { \
    PACKED_glUniformMatrix4fv *unpacked = (PACKED_glUniformMatrix4fv *)packed; \
    ARGS_glUniformMatrix4fv *args = (ARGS_glUniformMatrix4fv *)&unpacked->args; \
    glUniformMatrix4fv(args->location, args->count, args->transpose, args->value);; \
} while(0)
void glUniformMatrix4fv(glUniformMatrix4fv_ARG_EXPAND);
typedef void (*glUniformMatrix4fv_PTR)(glUniformMatrix4fv_ARG_EXPAND);
#define glUniformMatrix4fvARB_INDEX 2251
#define glUniformMatrix4fvARB_RETURN void
#define glUniformMatrix4fvARB_ARG_NAMES location, count, transpose, value
#define glUniformMatrix4fvARB_ARG_EXPAND GLint location, GLsizei count, GLboolean transpose, const GLfloat * value
#define glUniformMatrix4fvARB_PACKED PACKED_glUniformMatrix4fvARB
#define glUniformMatrix4fvARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glUniformMatrix4fvARB_NOT_VOID_WRAP(...) {}
#define pack_glUniformMatrix4fvARB(_location, _count, _transpose, _value) ({ \
    glUniformMatrix4fvARB_PACKED *packed_data = malloc(sizeof(glUniformMatrix4fvARB_PACKED)); \
    packed_data->index = glUniformMatrix4fvARB_INDEX; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.transpose = (GLboolean)_transpose; \
    packed_data->args.value = (GLfloat *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glUniformMatrix4fvARB(packed, ret_v) do { \
    PACKED_glUniformMatrix4fvARB *unpacked = (PACKED_glUniformMatrix4fvARB *)packed; \
    ARGS_glUniformMatrix4fvARB *args = (ARGS_glUniformMatrix4fvARB *)&unpacked->args; \
    glUniformMatrix4fvARB(args->location, args->count, args->transpose, args->value);; \
} while(0)
void glUniformMatrix4fvARB(glUniformMatrix4fvARB_ARG_EXPAND);
typedef void (*glUniformMatrix4fvARB_PTR)(glUniformMatrix4fvARB_ARG_EXPAND);
#define glUniformMatrix4x2dv_INDEX 2252
#define glUniformMatrix4x2dv_RETURN void
#define glUniformMatrix4x2dv_ARG_NAMES location, count, transpose, value
#define glUniformMatrix4x2dv_ARG_EXPAND GLint location, GLsizei count, GLboolean transpose, const GLdouble * value
#define glUniformMatrix4x2dv_PACKED PACKED_glUniformMatrix4x2dv
#define glUniformMatrix4x2dv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glUniformMatrix4x2dv_NOT_VOID_WRAP(...) {}
#define pack_glUniformMatrix4x2dv(_location, _count, _transpose, _value) ({ \
    glUniformMatrix4x2dv_PACKED *packed_data = malloc(sizeof(glUniformMatrix4x2dv_PACKED)); \
    packed_data->index = glUniformMatrix4x2dv_INDEX; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.transpose = (GLboolean)_transpose; \
    packed_data->args.value = (GLdouble *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glUniformMatrix4x2dv(packed, ret_v) do { \
    PACKED_glUniformMatrix4x2dv *unpacked = (PACKED_glUniformMatrix4x2dv *)packed; \
    ARGS_glUniformMatrix4x2dv *args = (ARGS_glUniformMatrix4x2dv *)&unpacked->args; \
    glUniformMatrix4x2dv(args->location, args->count, args->transpose, args->value);; \
} while(0)
void glUniformMatrix4x2dv(glUniformMatrix4x2dv_ARG_EXPAND);
typedef void (*glUniformMatrix4x2dv_PTR)(glUniformMatrix4x2dv_ARG_EXPAND);
#define glUniformMatrix4x2fv_INDEX 2253
#define glUniformMatrix4x2fv_RETURN void
#define glUniformMatrix4x2fv_ARG_NAMES location, count, transpose, value
#define glUniformMatrix4x2fv_ARG_EXPAND GLint location, GLsizei count, GLboolean transpose, const GLfloat * value
#define glUniformMatrix4x2fv_PACKED PACKED_glUniformMatrix4x2fv
#define glUniformMatrix4x2fv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glUniformMatrix4x2fv_NOT_VOID_WRAP(...) {}
#define pack_glUniformMatrix4x2fv(_location, _count, _transpose, _value) ({ \
    glUniformMatrix4x2fv_PACKED *packed_data = malloc(sizeof(glUniformMatrix4x2fv_PACKED)); \
    packed_data->index = glUniformMatrix4x2fv_INDEX; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.transpose = (GLboolean)_transpose; \
    packed_data->args.value = (GLfloat *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glUniformMatrix4x2fv(packed, ret_v) do { \
    PACKED_glUniformMatrix4x2fv *unpacked = (PACKED_glUniformMatrix4x2fv *)packed; \
    ARGS_glUniformMatrix4x2fv *args = (ARGS_glUniformMatrix4x2fv *)&unpacked->args; \
    glUniformMatrix4x2fv(args->location, args->count, args->transpose, args->value);; \
} while(0)
void glUniformMatrix4x2fv(glUniformMatrix4x2fv_ARG_EXPAND);
typedef void (*glUniformMatrix4x2fv_PTR)(glUniformMatrix4x2fv_ARG_EXPAND);
#define glUniformMatrix4x3dv_INDEX 2254
#define glUniformMatrix4x3dv_RETURN void
#define glUniformMatrix4x3dv_ARG_NAMES location, count, transpose, value
#define glUniformMatrix4x3dv_ARG_EXPAND GLint location, GLsizei count, GLboolean transpose, const GLdouble * value
#define glUniformMatrix4x3dv_PACKED PACKED_glUniformMatrix4x3dv
#define glUniformMatrix4x3dv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glUniformMatrix4x3dv_NOT_VOID_WRAP(...) {}
#define pack_glUniformMatrix4x3dv(_location, _count, _transpose, _value) ({ \
    glUniformMatrix4x3dv_PACKED *packed_data = malloc(sizeof(glUniformMatrix4x3dv_PACKED)); \
    packed_data->index = glUniformMatrix4x3dv_INDEX; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.transpose = (GLboolean)_transpose; \
    packed_data->args.value = (GLdouble *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glUniformMatrix4x3dv(packed, ret_v) do { \
    PACKED_glUniformMatrix4x3dv *unpacked = (PACKED_glUniformMatrix4x3dv *)packed; \
    ARGS_glUniformMatrix4x3dv *args = (ARGS_glUniformMatrix4x3dv *)&unpacked->args; \
    glUniformMatrix4x3dv(args->location, args->count, args->transpose, args->value);; \
} while(0)
void glUniformMatrix4x3dv(glUniformMatrix4x3dv_ARG_EXPAND);
typedef void (*glUniformMatrix4x3dv_PTR)(glUniformMatrix4x3dv_ARG_EXPAND);
#define glUniformMatrix4x3fv_INDEX 2255
#define glUniformMatrix4x3fv_RETURN void
#define glUniformMatrix4x3fv_ARG_NAMES location, count, transpose, value
#define glUniformMatrix4x3fv_ARG_EXPAND GLint location, GLsizei count, GLboolean transpose, const GLfloat * value
#define glUniformMatrix4x3fv_PACKED PACKED_glUniformMatrix4x3fv
#define glUniformMatrix4x3fv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glUniformMatrix4x3fv_NOT_VOID_WRAP(...) {}
#define pack_glUniformMatrix4x3fv(_location, _count, _transpose, _value) ({ \
    glUniformMatrix4x3fv_PACKED *packed_data = malloc(sizeof(glUniformMatrix4x3fv_PACKED)); \
    packed_data->index = glUniformMatrix4x3fv_INDEX; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.transpose = (GLboolean)_transpose; \
    packed_data->args.value = (GLfloat *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glUniformMatrix4x3fv(packed, ret_v) do { \
    PACKED_glUniformMatrix4x3fv *unpacked = (PACKED_glUniformMatrix4x3fv *)packed; \
    ARGS_glUniformMatrix4x3fv *args = (ARGS_glUniformMatrix4x3fv *)&unpacked->args; \
    glUniformMatrix4x3fv(args->location, args->count, args->transpose, args->value);; \
} while(0)
void glUniformMatrix4x3fv(glUniformMatrix4x3fv_ARG_EXPAND);
typedef void (*glUniformMatrix4x3fv_PTR)(glUniformMatrix4x3fv_ARG_EXPAND);
#define glUniformSubroutinesuiv_INDEX 2256
#define glUniformSubroutinesuiv_RETURN void
#define glUniformSubroutinesuiv_ARG_NAMES shadertype, count, indices
#define glUniformSubroutinesuiv_ARG_EXPAND GLenum shadertype, GLsizei count, const GLuint * indices
#define glUniformSubroutinesuiv_PACKED PACKED_glUniformSubroutinesuiv
#define glUniformSubroutinesuiv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glUniformSubroutinesuiv_NOT_VOID_WRAP(...) {}
#define pack_glUniformSubroutinesuiv(_shadertype, _count, _indices) ({ \
    glUniformSubroutinesuiv_PACKED *packed_data = malloc(sizeof(glUniformSubroutinesuiv_PACKED)); \
    packed_data->index = glUniformSubroutinesuiv_INDEX; \
    packed_data->args.shadertype = (GLenum)_shadertype; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.indices = (GLuint *)_indices; \
    (packed_call_t *)packed_data; \
})
#define call_glUniformSubroutinesuiv(packed, ret_v) do { \
    PACKED_glUniformSubroutinesuiv *unpacked = (PACKED_glUniformSubroutinesuiv *)packed; \
    ARGS_glUniformSubroutinesuiv *args = (ARGS_glUniformSubroutinesuiv *)&unpacked->args; \
    glUniformSubroutinesuiv(args->shadertype, args->count, args->indices);; \
} while(0)
void glUniformSubroutinesuiv(glUniformSubroutinesuiv_ARG_EXPAND);
typedef void (*glUniformSubroutinesuiv_PTR)(glUniformSubroutinesuiv_ARG_EXPAND);
#define glUniformui64NV_INDEX 2257
#define glUniformui64NV_RETURN void
#define glUniformui64NV_ARG_NAMES location, value
#define glUniformui64NV_ARG_EXPAND GLint location, GLuint64EXT value
#define glUniformui64NV_PACKED PACKED_glUniformui64NV
#define glUniformui64NV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glUniformui64NV_NOT_VOID_WRAP(...) {}
#define pack_glUniformui64NV(_location, _value) ({ \
    glUniformui64NV_PACKED *packed_data = malloc(sizeof(glUniformui64NV_PACKED)); \
    packed_data->index = glUniformui64NV_INDEX; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.value = (GLuint64EXT)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glUniformui64NV(packed, ret_v) do { \
    PACKED_glUniformui64NV *unpacked = (PACKED_glUniformui64NV *)packed; \
    ARGS_glUniformui64NV *args = (ARGS_glUniformui64NV *)&unpacked->args; \
    glUniformui64NV(args->location, args->value);; \
} while(0)
void glUniformui64NV(glUniformui64NV_ARG_EXPAND);
typedef void (*glUniformui64NV_PTR)(glUniformui64NV_ARG_EXPAND);
#define glUniformui64vNV_INDEX 2258
#define glUniformui64vNV_RETURN void
#define glUniformui64vNV_ARG_NAMES location, count, value
#define glUniformui64vNV_ARG_EXPAND GLint location, GLsizei count, const GLuint64EXT * value
#define glUniformui64vNV_PACKED PACKED_glUniformui64vNV
#define glUniformui64vNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glUniformui64vNV_NOT_VOID_WRAP(...) {}
#define pack_glUniformui64vNV(_location, _count, _value) ({ \
    glUniformui64vNV_PACKED *packed_data = malloc(sizeof(glUniformui64vNV_PACKED)); \
    packed_data->index = glUniformui64vNV_INDEX; \
    packed_data->args.location = (GLint)_location; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.value = (GLuint64EXT *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glUniformui64vNV(packed, ret_v) do { \
    PACKED_glUniformui64vNV *unpacked = (PACKED_glUniformui64vNV *)packed; \
    ARGS_glUniformui64vNV *args = (ARGS_glUniformui64vNV *)&unpacked->args; \
    glUniformui64vNV(args->location, args->count, args->value);; \
} while(0)
void glUniformui64vNV(glUniformui64vNV_ARG_EXPAND);
typedef void (*glUniformui64vNV_PTR)(glUniformui64vNV_ARG_EXPAND);
#define glUnlockArraysEXT_INDEX 2259
#define glUnlockArraysEXT_RETURN void
#define glUnlockArraysEXT_ARG_NAMES 
#define glUnlockArraysEXT_ARG_EXPAND 
#define glUnlockArraysEXT_PACKED PACKED_glUnlockArraysEXT
#define glUnlockArraysEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glUnlockArraysEXT_NOT_VOID_WRAP(...) {}
#define pack_glUnlockArraysEXT() ({ \
    glUnlockArraysEXT_PACKED *packed_data = malloc(sizeof(glUnlockArraysEXT_PACKED)); \
    packed_data->index = glUnlockArraysEXT_INDEX; \
    (packed_call_t *)packed_data; \
})
#define call_glUnlockArraysEXT(packed, ret_v) do { \
    glUnlockArraysEXT();; \
} while(0)
void glUnlockArraysEXT(glUnlockArraysEXT_ARG_EXPAND);
typedef void (*glUnlockArraysEXT_PTR)(glUnlockArraysEXT_ARG_EXPAND);
#define glUnmapBuffer_INDEX 2260
#define glUnmapBuffer_RETURN GLboolean
#define glUnmapBuffer_ARG_NAMES target
#define glUnmapBuffer_ARG_EXPAND GLenum target
#define glUnmapBuffer_PACKED PACKED_glUnmapBuffer
#define glUnmapBuffer_VOID_ONLY_WRAP(...) {}
#define glUnmapBuffer_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glUnmapBuffer(_target) ({ \
    glUnmapBuffer_PACKED *packed_data = malloc(sizeof(glUnmapBuffer_PACKED)); \
    packed_data->index = glUnmapBuffer_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    (packed_call_t *)packed_data; \
})
#define call_glUnmapBuffer(packed, ret_v) do { \
    PACKED_glUnmapBuffer *unpacked = (PACKED_glUnmapBuffer *)packed; \
    ARGS_glUnmapBuffer *args = (ARGS_glUnmapBuffer *)&unpacked->args; \
    GLboolean *ret = (GLboolean *)ret_v; \
    if (ret != NULL) { \
        *ret = glUnmapBuffer(args->target);; \
    } else { \
        glUnmapBuffer(args->target);; \
    } \
} while(0)
GLboolean glUnmapBuffer(glUnmapBuffer_ARG_EXPAND);
typedef GLboolean (*glUnmapBuffer_PTR)(glUnmapBuffer_ARG_EXPAND);
#define glUnmapBufferARB_INDEX 2261
#define glUnmapBufferARB_RETURN GLboolean
#define glUnmapBufferARB_ARG_NAMES target
#define glUnmapBufferARB_ARG_EXPAND GLenum target
#define glUnmapBufferARB_PACKED PACKED_glUnmapBufferARB
#define glUnmapBufferARB_VOID_ONLY_WRAP(...) {}
#define glUnmapBufferARB_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glUnmapBufferARB(_target) ({ \
    glUnmapBufferARB_PACKED *packed_data = malloc(sizeof(glUnmapBufferARB_PACKED)); \
    packed_data->index = glUnmapBufferARB_INDEX; \
    packed_data->args.target = (GLenum)_target; \
    (packed_call_t *)packed_data; \
})
#define call_glUnmapBufferARB(packed, ret_v) do { \
    PACKED_glUnmapBufferARB *unpacked = (PACKED_glUnmapBufferARB *)packed; \
    ARGS_glUnmapBufferARB *args = (ARGS_glUnmapBufferARB *)&unpacked->args; \
    GLboolean *ret = (GLboolean *)ret_v; \
    if (ret != NULL) { \
        *ret = glUnmapBufferARB(args->target);; \
    } else { \
        glUnmapBufferARB(args->target);; \
    } \
} while(0)
GLboolean glUnmapBufferARB(glUnmapBufferARB_ARG_EXPAND);
typedef GLboolean (*glUnmapBufferARB_PTR)(glUnmapBufferARB_ARG_EXPAND);
#define glUnmapNamedBufferEXT_INDEX 2262
#define glUnmapNamedBufferEXT_RETURN GLboolean
#define glUnmapNamedBufferEXT_ARG_NAMES buffer
#define glUnmapNamedBufferEXT_ARG_EXPAND GLuint buffer
#define glUnmapNamedBufferEXT_PACKED PACKED_glUnmapNamedBufferEXT
#define glUnmapNamedBufferEXT_VOID_ONLY_WRAP(...) {}
#define glUnmapNamedBufferEXT_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glUnmapNamedBufferEXT(_buffer) ({ \
    glUnmapNamedBufferEXT_PACKED *packed_data = malloc(sizeof(glUnmapNamedBufferEXT_PACKED)); \
    packed_data->index = glUnmapNamedBufferEXT_INDEX; \
    packed_data->args.buffer = (GLuint)_buffer; \
    (packed_call_t *)packed_data; \
})
#define call_glUnmapNamedBufferEXT(packed, ret_v) do { \
    PACKED_glUnmapNamedBufferEXT *unpacked = (PACKED_glUnmapNamedBufferEXT *)packed; \
    ARGS_glUnmapNamedBufferEXT *args = (ARGS_glUnmapNamedBufferEXT *)&unpacked->args; \
    GLboolean *ret = (GLboolean *)ret_v; \
    if (ret != NULL) { \
        *ret = glUnmapNamedBufferEXT(args->buffer);; \
    } else { \
        glUnmapNamedBufferEXT(args->buffer);; \
    } \
} while(0)
GLboolean glUnmapNamedBufferEXT(glUnmapNamedBufferEXT_ARG_EXPAND);
typedef GLboolean (*glUnmapNamedBufferEXT_PTR)(glUnmapNamedBufferEXT_ARG_EXPAND);
#define glUnmapObjectBufferATI_INDEX 2263
#define glUnmapObjectBufferATI_RETURN void
#define glUnmapObjectBufferATI_ARG_NAMES buffer
#define glUnmapObjectBufferATI_ARG_EXPAND GLuint buffer
#define glUnmapObjectBufferATI_PACKED PACKED_glUnmapObjectBufferATI
#define glUnmapObjectBufferATI_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glUnmapObjectBufferATI_NOT_VOID_WRAP(...) {}
#define pack_glUnmapObjectBufferATI(_buffer) ({ \
    glUnmapObjectBufferATI_PACKED *packed_data = malloc(sizeof(glUnmapObjectBufferATI_PACKED)); \
    packed_data->index = glUnmapObjectBufferATI_INDEX; \
    packed_data->args.buffer = (GLuint)_buffer; \
    (packed_call_t *)packed_data; \
})
#define call_glUnmapObjectBufferATI(packed, ret_v) do { \
    PACKED_glUnmapObjectBufferATI *unpacked = (PACKED_glUnmapObjectBufferATI *)packed; \
    ARGS_glUnmapObjectBufferATI *args = (ARGS_glUnmapObjectBufferATI *)&unpacked->args; \
    glUnmapObjectBufferATI(args->buffer);; \
} while(0)
void glUnmapObjectBufferATI(glUnmapObjectBufferATI_ARG_EXPAND);
typedef void (*glUnmapObjectBufferATI_PTR)(glUnmapObjectBufferATI_ARG_EXPAND);
#define glUnmapTexture2DINTEL_INDEX 2264
#define glUnmapTexture2DINTEL_RETURN void
#define glUnmapTexture2DINTEL_ARG_NAMES texture, level
#define glUnmapTexture2DINTEL_ARG_EXPAND GLuint texture, GLint level
#define glUnmapTexture2DINTEL_PACKED PACKED_glUnmapTexture2DINTEL
#define glUnmapTexture2DINTEL_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glUnmapTexture2DINTEL_NOT_VOID_WRAP(...) {}
#define pack_glUnmapTexture2DINTEL(_texture, _level) ({ \
    glUnmapTexture2DINTEL_PACKED *packed_data = malloc(sizeof(glUnmapTexture2DINTEL_PACKED)); \
    packed_data->index = glUnmapTexture2DINTEL_INDEX; \
    packed_data->args.texture = (GLuint)_texture; \
    packed_data->args.level = (GLint)_level; \
    (packed_call_t *)packed_data; \
})
#define call_glUnmapTexture2DINTEL(packed, ret_v) do { \
    PACKED_glUnmapTexture2DINTEL *unpacked = (PACKED_glUnmapTexture2DINTEL *)packed; \
    ARGS_glUnmapTexture2DINTEL *args = (ARGS_glUnmapTexture2DINTEL *)&unpacked->args; \
    glUnmapTexture2DINTEL(args->texture, args->level);; \
} while(0)
void glUnmapTexture2DINTEL(glUnmapTexture2DINTEL_ARG_EXPAND);
typedef void (*glUnmapTexture2DINTEL_PTR)(glUnmapTexture2DINTEL_ARG_EXPAND);
#define glUpdateObjectBufferATI_INDEX 2265
#define glUpdateObjectBufferATI_RETURN void
#define glUpdateObjectBufferATI_ARG_NAMES buffer, offset, size, pointer, preserve
#define glUpdateObjectBufferATI_ARG_EXPAND GLuint buffer, GLuint offset, GLsizei size, const GLvoid * pointer, GLenum preserve
#define glUpdateObjectBufferATI_PACKED PACKED_glUpdateObjectBufferATI
#define glUpdateObjectBufferATI_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glUpdateObjectBufferATI_NOT_VOID_WRAP(...) {}
#define pack_glUpdateObjectBufferATI(_buffer, _offset, _size, _pointer, _preserve) ({ \
    glUpdateObjectBufferATI_PACKED *packed_data = malloc(sizeof(glUpdateObjectBufferATI_PACKED)); \
    packed_data->index = glUpdateObjectBufferATI_INDEX; \
    packed_data->args.buffer = (GLuint)_buffer; \
    packed_data->args.offset = (GLuint)_offset; \
    packed_data->args.size = (GLsizei)_size; \
    packed_data->args.pointer = (GLvoid *)_pointer; \
    packed_data->args.preserve = (GLenum)_preserve; \
    (packed_call_t *)packed_data; \
})
#define call_glUpdateObjectBufferATI(packed, ret_v) do { \
    PACKED_glUpdateObjectBufferATI *unpacked = (PACKED_glUpdateObjectBufferATI *)packed; \
    ARGS_glUpdateObjectBufferATI *args = (ARGS_glUpdateObjectBufferATI *)&unpacked->args; \
    glUpdateObjectBufferATI(args->buffer, args->offset, args->size, args->pointer, args->preserve);; \
} while(0)
void glUpdateObjectBufferATI(glUpdateObjectBufferATI_ARG_EXPAND);
typedef void (*glUpdateObjectBufferATI_PTR)(glUpdateObjectBufferATI_ARG_EXPAND);
#define glUseProgram_INDEX 2266
#define glUseProgram_RETURN void
#define glUseProgram_ARG_NAMES program
#define glUseProgram_ARG_EXPAND GLuint program
#define glUseProgram_PACKED PACKED_glUseProgram
#define glUseProgram_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glUseProgram_NOT_VOID_WRAP(...) {}
#define pack_glUseProgram(_program) ({ \
    glUseProgram_PACKED *packed_data = malloc(sizeof(glUseProgram_PACKED)); \
    packed_data->index = glUseProgram_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    (packed_call_t *)packed_data; \
})
#define call_glUseProgram(packed, ret_v) do { \
    PACKED_glUseProgram *unpacked = (PACKED_glUseProgram *)packed; \
    ARGS_glUseProgram *args = (ARGS_glUseProgram *)&unpacked->args; \
    glUseProgram(args->program);; \
} while(0)
void glUseProgram(glUseProgram_ARG_EXPAND);
typedef void (*glUseProgram_PTR)(glUseProgram_ARG_EXPAND);
#define glUseProgramObjectARB_INDEX 2267
#define glUseProgramObjectARB_RETURN void
#define glUseProgramObjectARB_ARG_NAMES programObj
#define glUseProgramObjectARB_ARG_EXPAND GLhandleARB programObj
#define glUseProgramObjectARB_PACKED PACKED_glUseProgramObjectARB
#define glUseProgramObjectARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glUseProgramObjectARB_NOT_VOID_WRAP(...) {}
#define pack_glUseProgramObjectARB(_programObj) ({ \
    glUseProgramObjectARB_PACKED *packed_data = malloc(sizeof(glUseProgramObjectARB_PACKED)); \
    packed_data->index = glUseProgramObjectARB_INDEX; \
    packed_data->args.programObj = (GLhandleARB)_programObj; \
    (packed_call_t *)packed_data; \
})
#define call_glUseProgramObjectARB(packed, ret_v) do { \
    PACKED_glUseProgramObjectARB *unpacked = (PACKED_glUseProgramObjectARB *)packed; \
    ARGS_glUseProgramObjectARB *args = (ARGS_glUseProgramObjectARB *)&unpacked->args; \
    glUseProgramObjectARB(args->programObj);; \
} while(0)
void glUseProgramObjectARB(glUseProgramObjectARB_ARG_EXPAND);
typedef void (*glUseProgramObjectARB_PTR)(glUseProgramObjectARB_ARG_EXPAND);
#define glUseProgramStages_INDEX 2268
#define glUseProgramStages_RETURN void
#define glUseProgramStages_ARG_NAMES pipeline, stages, program
#define glUseProgramStages_ARG_EXPAND GLuint pipeline, GLbitfield stages, GLuint program
#define glUseProgramStages_PACKED PACKED_glUseProgramStages
#define glUseProgramStages_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glUseProgramStages_NOT_VOID_WRAP(...) {}
#define pack_glUseProgramStages(_pipeline, _stages, _program) ({ \
    glUseProgramStages_PACKED *packed_data = malloc(sizeof(glUseProgramStages_PACKED)); \
    packed_data->index = glUseProgramStages_INDEX; \
    packed_data->args.pipeline = (GLuint)_pipeline; \
    packed_data->args.stages = (GLbitfield)_stages; \
    packed_data->args.program = (GLuint)_program; \
    (packed_call_t *)packed_data; \
})
#define call_glUseProgramStages(packed, ret_v) do { \
    PACKED_glUseProgramStages *unpacked = (PACKED_glUseProgramStages *)packed; \
    ARGS_glUseProgramStages *args = (ARGS_glUseProgramStages *)&unpacked->args; \
    glUseProgramStages(args->pipeline, args->stages, args->program);; \
} while(0)
void glUseProgramStages(glUseProgramStages_ARG_EXPAND);
typedef void (*glUseProgramStages_PTR)(glUseProgramStages_ARG_EXPAND);
#define glUseShaderProgramEXT_INDEX 2269
#define glUseShaderProgramEXT_RETURN void
#define glUseShaderProgramEXT_ARG_NAMES type, program
#define glUseShaderProgramEXT_ARG_EXPAND GLenum type, GLuint program
#define glUseShaderProgramEXT_PACKED PACKED_glUseShaderProgramEXT
#define glUseShaderProgramEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glUseShaderProgramEXT_NOT_VOID_WRAP(...) {}
#define pack_glUseShaderProgramEXT(_type, _program) ({ \
    glUseShaderProgramEXT_PACKED *packed_data = malloc(sizeof(glUseShaderProgramEXT_PACKED)); \
    packed_data->index = glUseShaderProgramEXT_INDEX; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.program = (GLuint)_program; \
    (packed_call_t *)packed_data; \
})
#define call_glUseShaderProgramEXT(packed, ret_v) do { \
    PACKED_glUseShaderProgramEXT *unpacked = (PACKED_glUseShaderProgramEXT *)packed; \
    ARGS_glUseShaderProgramEXT *args = (ARGS_glUseShaderProgramEXT *)&unpacked->args; \
    glUseShaderProgramEXT(args->type, args->program);; \
} while(0)
void glUseShaderProgramEXT(glUseShaderProgramEXT_ARG_EXPAND);
typedef void (*glUseShaderProgramEXT_PTR)(glUseShaderProgramEXT_ARG_EXPAND);
#define glVDPAUFiniNV_INDEX 2270
#define glVDPAUFiniNV_RETURN void
#define glVDPAUFiniNV_ARG_NAMES 
#define glVDPAUFiniNV_ARG_EXPAND 
#define glVDPAUFiniNV_PACKED PACKED_glVDPAUFiniNV
#define glVDPAUFiniNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVDPAUFiniNV_NOT_VOID_WRAP(...) {}
#define pack_glVDPAUFiniNV() ({ \
    glVDPAUFiniNV_PACKED *packed_data = malloc(sizeof(glVDPAUFiniNV_PACKED)); \
    packed_data->index = glVDPAUFiniNV_INDEX; \
    (packed_call_t *)packed_data; \
})
#define call_glVDPAUFiniNV(packed, ret_v) do { \
    glVDPAUFiniNV();; \
} while(0)
void glVDPAUFiniNV(glVDPAUFiniNV_ARG_EXPAND);
typedef void (*glVDPAUFiniNV_PTR)(glVDPAUFiniNV_ARG_EXPAND);
#define glVDPAUGetSurfaceivNV_INDEX 2271
#define glVDPAUGetSurfaceivNV_RETURN void
#define glVDPAUGetSurfaceivNV_ARG_NAMES surface, pname, bufSize, length, values
#define glVDPAUGetSurfaceivNV_ARG_EXPAND GLvdpauSurfaceNV surface, GLenum pname, GLsizei bufSize, GLsizei * length, GLint * values
#define glVDPAUGetSurfaceivNV_PACKED PACKED_glVDPAUGetSurfaceivNV
#define glVDPAUGetSurfaceivNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVDPAUGetSurfaceivNV_NOT_VOID_WRAP(...) {}
#define pack_glVDPAUGetSurfaceivNV(_surface, _pname, _bufSize, _length, _values) ({ \
    glVDPAUGetSurfaceivNV_PACKED *packed_data = malloc(sizeof(glVDPAUGetSurfaceivNV_PACKED)); \
    packed_data->index = glVDPAUGetSurfaceivNV_INDEX; \
    packed_data->args.surface = (GLvdpauSurfaceNV)_surface; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.bufSize = (GLsizei)_bufSize; \
    packed_data->args.length = (GLsizei *)_length; \
    packed_data->args.values = (GLint *)_values; \
    (packed_call_t *)packed_data; \
})
#define call_glVDPAUGetSurfaceivNV(packed, ret_v) do { \
    PACKED_glVDPAUGetSurfaceivNV *unpacked = (PACKED_glVDPAUGetSurfaceivNV *)packed; \
    ARGS_glVDPAUGetSurfaceivNV *args = (ARGS_glVDPAUGetSurfaceivNV *)&unpacked->args; \
    glVDPAUGetSurfaceivNV(args->surface, args->pname, args->bufSize, args->length, args->values);; \
} while(0)
void glVDPAUGetSurfaceivNV(glVDPAUGetSurfaceivNV_ARG_EXPAND);
typedef void (*glVDPAUGetSurfaceivNV_PTR)(glVDPAUGetSurfaceivNV_ARG_EXPAND);
#define glVDPAUInitNV_INDEX 2272
#define glVDPAUInitNV_RETURN void
#define glVDPAUInitNV_ARG_NAMES vdpDevice, getProcAddress
#define glVDPAUInitNV_ARG_EXPAND const GLvoid * vdpDevice, const GLvoid * getProcAddress
#define glVDPAUInitNV_PACKED PACKED_glVDPAUInitNV
#define glVDPAUInitNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVDPAUInitNV_NOT_VOID_WRAP(...) {}
#define pack_glVDPAUInitNV(_vdpDevice, _getProcAddress) ({ \
    glVDPAUInitNV_PACKED *packed_data = malloc(sizeof(glVDPAUInitNV_PACKED)); \
    packed_data->index = glVDPAUInitNV_INDEX; \
    packed_data->args.vdpDevice = (GLvoid *)_vdpDevice; \
    packed_data->args.getProcAddress = (GLvoid *)_getProcAddress; \
    (packed_call_t *)packed_data; \
})
#define call_glVDPAUInitNV(packed, ret_v) do { \
    PACKED_glVDPAUInitNV *unpacked = (PACKED_glVDPAUInitNV *)packed; \
    ARGS_glVDPAUInitNV *args = (ARGS_glVDPAUInitNV *)&unpacked->args; \
    glVDPAUInitNV(args->vdpDevice, args->getProcAddress);; \
} while(0)
void glVDPAUInitNV(glVDPAUInitNV_ARG_EXPAND);
typedef void (*glVDPAUInitNV_PTR)(glVDPAUInitNV_ARG_EXPAND);
#define glVDPAUIsSurfaceNV_INDEX 2273
#define glVDPAUIsSurfaceNV_RETURN void
#define glVDPAUIsSurfaceNV_ARG_NAMES surface
#define glVDPAUIsSurfaceNV_ARG_EXPAND GLvdpauSurfaceNV surface
#define glVDPAUIsSurfaceNV_PACKED PACKED_glVDPAUIsSurfaceNV
#define glVDPAUIsSurfaceNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVDPAUIsSurfaceNV_NOT_VOID_WRAP(...) {}
#define pack_glVDPAUIsSurfaceNV(_surface) ({ \
    glVDPAUIsSurfaceNV_PACKED *packed_data = malloc(sizeof(glVDPAUIsSurfaceNV_PACKED)); \
    packed_data->index = glVDPAUIsSurfaceNV_INDEX; \
    packed_data->args.surface = (GLvdpauSurfaceNV)_surface; \
    (packed_call_t *)packed_data; \
})
#define call_glVDPAUIsSurfaceNV(packed, ret_v) do { \
    PACKED_glVDPAUIsSurfaceNV *unpacked = (PACKED_glVDPAUIsSurfaceNV *)packed; \
    ARGS_glVDPAUIsSurfaceNV *args = (ARGS_glVDPAUIsSurfaceNV *)&unpacked->args; \
    glVDPAUIsSurfaceNV(args->surface);; \
} while(0)
void glVDPAUIsSurfaceNV(glVDPAUIsSurfaceNV_ARG_EXPAND);
typedef void (*glVDPAUIsSurfaceNV_PTR)(glVDPAUIsSurfaceNV_ARG_EXPAND);
#define glVDPAUMapSurfacesNV_INDEX 2274
#define glVDPAUMapSurfacesNV_RETURN void
#define glVDPAUMapSurfacesNV_ARG_NAMES numSurfaces, surfaces
#define glVDPAUMapSurfacesNV_ARG_EXPAND GLsizei numSurfaces, const GLvdpauSurfaceNV * surfaces
#define glVDPAUMapSurfacesNV_PACKED PACKED_glVDPAUMapSurfacesNV
#define glVDPAUMapSurfacesNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVDPAUMapSurfacesNV_NOT_VOID_WRAP(...) {}
#define pack_glVDPAUMapSurfacesNV(_numSurfaces, _surfaces) ({ \
    glVDPAUMapSurfacesNV_PACKED *packed_data = malloc(sizeof(glVDPAUMapSurfacesNV_PACKED)); \
    packed_data->index = glVDPAUMapSurfacesNV_INDEX; \
    packed_data->args.numSurfaces = (GLsizei)_numSurfaces; \
    packed_data->args.surfaces = (GLvdpauSurfaceNV *)_surfaces; \
    (packed_call_t *)packed_data; \
})
#define call_glVDPAUMapSurfacesNV(packed, ret_v) do { \
    PACKED_glVDPAUMapSurfacesNV *unpacked = (PACKED_glVDPAUMapSurfacesNV *)packed; \
    ARGS_glVDPAUMapSurfacesNV *args = (ARGS_glVDPAUMapSurfacesNV *)&unpacked->args; \
    glVDPAUMapSurfacesNV(args->numSurfaces, args->surfaces);; \
} while(0)
void glVDPAUMapSurfacesNV(glVDPAUMapSurfacesNV_ARG_EXPAND);
typedef void (*glVDPAUMapSurfacesNV_PTR)(glVDPAUMapSurfacesNV_ARG_EXPAND);
#define glVDPAURegisterOutputSurfaceNV_INDEX 2275
#define glVDPAURegisterOutputSurfaceNV_RETURN GLvdpauSurfaceNV
#define glVDPAURegisterOutputSurfaceNV_ARG_NAMES vdpSurface, target, numTextureNames, textureNames
#define glVDPAURegisterOutputSurfaceNV_ARG_EXPAND GLvoid * vdpSurface, GLenum target, GLsizei numTextureNames, const GLuint * textureNames
#define glVDPAURegisterOutputSurfaceNV_PACKED PACKED_glVDPAURegisterOutputSurfaceNV
#define glVDPAURegisterOutputSurfaceNV_VOID_ONLY_WRAP(...) {}
#define glVDPAURegisterOutputSurfaceNV_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glVDPAURegisterOutputSurfaceNV(_vdpSurface, _target, _numTextureNames, _textureNames) ({ \
    glVDPAURegisterOutputSurfaceNV_PACKED *packed_data = malloc(sizeof(glVDPAURegisterOutputSurfaceNV_PACKED)); \
    packed_data->index = glVDPAURegisterOutputSurfaceNV_INDEX; \
    packed_data->args.vdpSurface = (GLvoid *)_vdpSurface; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.numTextureNames = (GLsizei)_numTextureNames; \
    packed_data->args.textureNames = (GLuint *)_textureNames; \
    (packed_call_t *)packed_data; \
})
#define call_glVDPAURegisterOutputSurfaceNV(packed, ret_v) do { \
    PACKED_glVDPAURegisterOutputSurfaceNV *unpacked = (PACKED_glVDPAURegisterOutputSurfaceNV *)packed; \
    ARGS_glVDPAURegisterOutputSurfaceNV *args = (ARGS_glVDPAURegisterOutputSurfaceNV *)&unpacked->args; \
    GLvdpauSurfaceNV *ret = (GLvdpauSurfaceNV *)ret_v; \
    if (ret != NULL) { \
        *ret = glVDPAURegisterOutputSurfaceNV(args->vdpSurface, args->target, args->numTextureNames, args->textureNames);; \
    } else { \
        glVDPAURegisterOutputSurfaceNV(args->vdpSurface, args->target, args->numTextureNames, args->textureNames);; \
    } \
} while(0)
GLvdpauSurfaceNV glVDPAURegisterOutputSurfaceNV(glVDPAURegisterOutputSurfaceNV_ARG_EXPAND);
typedef GLvdpauSurfaceNV (*glVDPAURegisterOutputSurfaceNV_PTR)(glVDPAURegisterOutputSurfaceNV_ARG_EXPAND);
#define glVDPAURegisterVideoSurfaceNV_INDEX 2276
#define glVDPAURegisterVideoSurfaceNV_RETURN GLvdpauSurfaceNV
#define glVDPAURegisterVideoSurfaceNV_ARG_NAMES vdpSurface, target, numTextureNames, textureNames
#define glVDPAURegisterVideoSurfaceNV_ARG_EXPAND const GLvoid * vdpSurface, GLenum target, GLsizei numTextureNames, const GLuint * textureNames
#define glVDPAURegisterVideoSurfaceNV_PACKED PACKED_glVDPAURegisterVideoSurfaceNV
#define glVDPAURegisterVideoSurfaceNV_VOID_ONLY_WRAP(...) {}
#define glVDPAURegisterVideoSurfaceNV_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glVDPAURegisterVideoSurfaceNV(_vdpSurface, _target, _numTextureNames, _textureNames) ({ \
    glVDPAURegisterVideoSurfaceNV_PACKED *packed_data = malloc(sizeof(glVDPAURegisterVideoSurfaceNV_PACKED)); \
    packed_data->index = glVDPAURegisterVideoSurfaceNV_INDEX; \
    packed_data->args.vdpSurface = (GLvoid *)_vdpSurface; \
    packed_data->args.target = (GLenum)_target; \
    packed_data->args.numTextureNames = (GLsizei)_numTextureNames; \
    packed_data->args.textureNames = (GLuint *)_textureNames; \
    (packed_call_t *)packed_data; \
})
#define call_glVDPAURegisterVideoSurfaceNV(packed, ret_v) do { \
    PACKED_glVDPAURegisterVideoSurfaceNV *unpacked = (PACKED_glVDPAURegisterVideoSurfaceNV *)packed; \
    ARGS_glVDPAURegisterVideoSurfaceNV *args = (ARGS_glVDPAURegisterVideoSurfaceNV *)&unpacked->args; \
    GLvdpauSurfaceNV *ret = (GLvdpauSurfaceNV *)ret_v; \
    if (ret != NULL) { \
        *ret = glVDPAURegisterVideoSurfaceNV(args->vdpSurface, args->target, args->numTextureNames, args->textureNames);; \
    } else { \
        glVDPAURegisterVideoSurfaceNV(args->vdpSurface, args->target, args->numTextureNames, args->textureNames);; \
    } \
} while(0)
GLvdpauSurfaceNV glVDPAURegisterVideoSurfaceNV(glVDPAURegisterVideoSurfaceNV_ARG_EXPAND);
typedef GLvdpauSurfaceNV (*glVDPAURegisterVideoSurfaceNV_PTR)(glVDPAURegisterVideoSurfaceNV_ARG_EXPAND);
#define glVDPAUSurfaceAccessNV_INDEX 2277
#define glVDPAUSurfaceAccessNV_RETURN void
#define glVDPAUSurfaceAccessNV_ARG_NAMES surface, access
#define glVDPAUSurfaceAccessNV_ARG_EXPAND GLvdpauSurfaceNV surface, GLenum access
#define glVDPAUSurfaceAccessNV_PACKED PACKED_glVDPAUSurfaceAccessNV
#define glVDPAUSurfaceAccessNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVDPAUSurfaceAccessNV_NOT_VOID_WRAP(...) {}
#define pack_glVDPAUSurfaceAccessNV(_surface, _access) ({ \
    glVDPAUSurfaceAccessNV_PACKED *packed_data = malloc(sizeof(glVDPAUSurfaceAccessNV_PACKED)); \
    packed_data->index = glVDPAUSurfaceAccessNV_INDEX; \
    packed_data->args.surface = (GLvdpauSurfaceNV)_surface; \
    packed_data->args.access = (GLenum)_access; \
    (packed_call_t *)packed_data; \
})
#define call_glVDPAUSurfaceAccessNV(packed, ret_v) do { \
    PACKED_glVDPAUSurfaceAccessNV *unpacked = (PACKED_glVDPAUSurfaceAccessNV *)packed; \
    ARGS_glVDPAUSurfaceAccessNV *args = (ARGS_glVDPAUSurfaceAccessNV *)&unpacked->args; \
    glVDPAUSurfaceAccessNV(args->surface, args->access);; \
} while(0)
void glVDPAUSurfaceAccessNV(glVDPAUSurfaceAccessNV_ARG_EXPAND);
typedef void (*glVDPAUSurfaceAccessNV_PTR)(glVDPAUSurfaceAccessNV_ARG_EXPAND);
#define glVDPAUUnmapSurfacesNV_INDEX 2278
#define glVDPAUUnmapSurfacesNV_RETURN void
#define glVDPAUUnmapSurfacesNV_ARG_NAMES numSurface, surfaces
#define glVDPAUUnmapSurfacesNV_ARG_EXPAND GLsizei numSurface, const GLvdpauSurfaceNV * surfaces
#define glVDPAUUnmapSurfacesNV_PACKED PACKED_glVDPAUUnmapSurfacesNV
#define glVDPAUUnmapSurfacesNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVDPAUUnmapSurfacesNV_NOT_VOID_WRAP(...) {}
#define pack_glVDPAUUnmapSurfacesNV(_numSurface, _surfaces) ({ \
    glVDPAUUnmapSurfacesNV_PACKED *packed_data = malloc(sizeof(glVDPAUUnmapSurfacesNV_PACKED)); \
    packed_data->index = glVDPAUUnmapSurfacesNV_INDEX; \
    packed_data->args.numSurface = (GLsizei)_numSurface; \
    packed_data->args.surfaces = (GLvdpauSurfaceNV *)_surfaces; \
    (packed_call_t *)packed_data; \
})
#define call_glVDPAUUnmapSurfacesNV(packed, ret_v) do { \
    PACKED_glVDPAUUnmapSurfacesNV *unpacked = (PACKED_glVDPAUUnmapSurfacesNV *)packed; \
    ARGS_glVDPAUUnmapSurfacesNV *args = (ARGS_glVDPAUUnmapSurfacesNV *)&unpacked->args; \
    glVDPAUUnmapSurfacesNV(args->numSurface, args->surfaces);; \
} while(0)
void glVDPAUUnmapSurfacesNV(glVDPAUUnmapSurfacesNV_ARG_EXPAND);
typedef void (*glVDPAUUnmapSurfacesNV_PTR)(glVDPAUUnmapSurfacesNV_ARG_EXPAND);
#define glVDPAUUnregisterSurfaceNV_INDEX 2279
#define glVDPAUUnregisterSurfaceNV_RETURN void
#define glVDPAUUnregisterSurfaceNV_ARG_NAMES surface
#define glVDPAUUnregisterSurfaceNV_ARG_EXPAND GLvdpauSurfaceNV surface
#define glVDPAUUnregisterSurfaceNV_PACKED PACKED_glVDPAUUnregisterSurfaceNV
#define glVDPAUUnregisterSurfaceNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVDPAUUnregisterSurfaceNV_NOT_VOID_WRAP(...) {}
#define pack_glVDPAUUnregisterSurfaceNV(_surface) ({ \
    glVDPAUUnregisterSurfaceNV_PACKED *packed_data = malloc(sizeof(glVDPAUUnregisterSurfaceNV_PACKED)); \
    packed_data->index = glVDPAUUnregisterSurfaceNV_INDEX; \
    packed_data->args.surface = (GLvdpauSurfaceNV)_surface; \
    (packed_call_t *)packed_data; \
})
#define call_glVDPAUUnregisterSurfaceNV(packed, ret_v) do { \
    PACKED_glVDPAUUnregisterSurfaceNV *unpacked = (PACKED_glVDPAUUnregisterSurfaceNV *)packed; \
    ARGS_glVDPAUUnregisterSurfaceNV *args = (ARGS_glVDPAUUnregisterSurfaceNV *)&unpacked->args; \
    glVDPAUUnregisterSurfaceNV(args->surface);; \
} while(0)
void glVDPAUUnregisterSurfaceNV(glVDPAUUnregisterSurfaceNV_ARG_EXPAND);
typedef void (*glVDPAUUnregisterSurfaceNV_PTR)(glVDPAUUnregisterSurfaceNV_ARG_EXPAND);
#define glValidateProgram_INDEX 2280
#define glValidateProgram_RETURN void
#define glValidateProgram_ARG_NAMES program
#define glValidateProgram_ARG_EXPAND GLuint program
#define glValidateProgram_PACKED PACKED_glValidateProgram
#define glValidateProgram_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glValidateProgram_NOT_VOID_WRAP(...) {}
#define pack_glValidateProgram(_program) ({ \
    glValidateProgram_PACKED *packed_data = malloc(sizeof(glValidateProgram_PACKED)); \
    packed_data->index = glValidateProgram_INDEX; \
    packed_data->args.program = (GLuint)_program; \
    (packed_call_t *)packed_data; \
})
#define call_glValidateProgram(packed, ret_v) do { \
    PACKED_glValidateProgram *unpacked = (PACKED_glValidateProgram *)packed; \
    ARGS_glValidateProgram *args = (ARGS_glValidateProgram *)&unpacked->args; \
    glValidateProgram(args->program);; \
} while(0)
void glValidateProgram(glValidateProgram_ARG_EXPAND);
typedef void (*glValidateProgram_PTR)(glValidateProgram_ARG_EXPAND);
#define glValidateProgramARB_INDEX 2281
#define glValidateProgramARB_RETURN void
#define glValidateProgramARB_ARG_NAMES programObj
#define glValidateProgramARB_ARG_EXPAND GLhandleARB programObj
#define glValidateProgramARB_PACKED PACKED_glValidateProgramARB
#define glValidateProgramARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glValidateProgramARB_NOT_VOID_WRAP(...) {}
#define pack_glValidateProgramARB(_programObj) ({ \
    glValidateProgramARB_PACKED *packed_data = malloc(sizeof(glValidateProgramARB_PACKED)); \
    packed_data->index = glValidateProgramARB_INDEX; \
    packed_data->args.programObj = (GLhandleARB)_programObj; \
    (packed_call_t *)packed_data; \
})
#define call_glValidateProgramARB(packed, ret_v) do { \
    PACKED_glValidateProgramARB *unpacked = (PACKED_glValidateProgramARB *)packed; \
    ARGS_glValidateProgramARB *args = (ARGS_glValidateProgramARB *)&unpacked->args; \
    glValidateProgramARB(args->programObj);; \
} while(0)
void glValidateProgramARB(glValidateProgramARB_ARG_EXPAND);
typedef void (*glValidateProgramARB_PTR)(glValidateProgramARB_ARG_EXPAND);
#define glValidateProgramPipeline_INDEX 2282
#define glValidateProgramPipeline_RETURN void
#define glValidateProgramPipeline_ARG_NAMES pipeline
#define glValidateProgramPipeline_ARG_EXPAND GLuint pipeline
#define glValidateProgramPipeline_PACKED PACKED_glValidateProgramPipeline
#define glValidateProgramPipeline_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glValidateProgramPipeline_NOT_VOID_WRAP(...) {}
#define pack_glValidateProgramPipeline(_pipeline) ({ \
    glValidateProgramPipeline_PACKED *packed_data = malloc(sizeof(glValidateProgramPipeline_PACKED)); \
    packed_data->index = glValidateProgramPipeline_INDEX; \
    packed_data->args.pipeline = (GLuint)_pipeline; \
    (packed_call_t *)packed_data; \
})
#define call_glValidateProgramPipeline(packed, ret_v) do { \
    PACKED_glValidateProgramPipeline *unpacked = (PACKED_glValidateProgramPipeline *)packed; \
    ARGS_glValidateProgramPipeline *args = (ARGS_glValidateProgramPipeline *)&unpacked->args; \
    glValidateProgramPipeline(args->pipeline);; \
} while(0)
void glValidateProgramPipeline(glValidateProgramPipeline_ARG_EXPAND);
typedef void (*glValidateProgramPipeline_PTR)(glValidateProgramPipeline_ARG_EXPAND);
#define glVariantArrayObjectATI_INDEX 2283
#define glVariantArrayObjectATI_RETURN void
#define glVariantArrayObjectATI_ARG_NAMES id, type, stride, buffer, offset
#define glVariantArrayObjectATI_ARG_EXPAND GLuint id, GLenum type, GLsizei stride, GLuint buffer, GLuint offset
#define glVariantArrayObjectATI_PACKED PACKED_glVariantArrayObjectATI
#define glVariantArrayObjectATI_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVariantArrayObjectATI_NOT_VOID_WRAP(...) {}
#define pack_glVariantArrayObjectATI(_id, _type, _stride, _buffer, _offset) ({ \
    glVariantArrayObjectATI_PACKED *packed_data = malloc(sizeof(glVariantArrayObjectATI_PACKED)); \
    packed_data->index = glVariantArrayObjectATI_INDEX; \
    packed_data->args.id = (GLuint)_id; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.stride = (GLsizei)_stride; \
    packed_data->args.buffer = (GLuint)_buffer; \
    packed_data->args.offset = (GLuint)_offset; \
    (packed_call_t *)packed_data; \
})
#define call_glVariantArrayObjectATI(packed, ret_v) do { \
    PACKED_glVariantArrayObjectATI *unpacked = (PACKED_glVariantArrayObjectATI *)packed; \
    ARGS_glVariantArrayObjectATI *args = (ARGS_glVariantArrayObjectATI *)&unpacked->args; \
    glVariantArrayObjectATI(args->id, args->type, args->stride, args->buffer, args->offset);; \
} while(0)
void glVariantArrayObjectATI(glVariantArrayObjectATI_ARG_EXPAND);
typedef void (*glVariantArrayObjectATI_PTR)(glVariantArrayObjectATI_ARG_EXPAND);
#define glVariantPointerEXT_INDEX 2284
#define glVariantPointerEXT_RETURN void
#define glVariantPointerEXT_ARG_NAMES id, type, stride, addr
#define glVariantPointerEXT_ARG_EXPAND GLuint id, GLenum type, GLuint stride, const GLvoid * addr
#define glVariantPointerEXT_PACKED PACKED_glVariantPointerEXT
#define glVariantPointerEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVariantPointerEXT_NOT_VOID_WRAP(...) {}
#define pack_glVariantPointerEXT(_id, _type, _stride, _addr) ({ \
    glVariantPointerEXT_PACKED *packed_data = malloc(sizeof(glVariantPointerEXT_PACKED)); \
    packed_data->index = glVariantPointerEXT_INDEX; \
    packed_data->args.id = (GLuint)_id; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.stride = (GLuint)_stride; \
    packed_data->args.addr = (GLvoid *)_addr; \
    (packed_call_t *)packed_data; \
})
#define call_glVariantPointerEXT(packed, ret_v) do { \
    PACKED_glVariantPointerEXT *unpacked = (PACKED_glVariantPointerEXT *)packed; \
    ARGS_glVariantPointerEXT *args = (ARGS_glVariantPointerEXT *)&unpacked->args; \
    glVariantPointerEXT(args->id, args->type, args->stride, args->addr);; \
} while(0)
void glVariantPointerEXT(glVariantPointerEXT_ARG_EXPAND);
typedef void (*glVariantPointerEXT_PTR)(glVariantPointerEXT_ARG_EXPAND);
#define glVariantbvEXT_INDEX 2285
#define glVariantbvEXT_RETURN void
#define glVariantbvEXT_ARG_NAMES id, addr
#define glVariantbvEXT_ARG_EXPAND GLuint id, const GLbyte * addr
#define glVariantbvEXT_PACKED PACKED_glVariantbvEXT
#define glVariantbvEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVariantbvEXT_NOT_VOID_WRAP(...) {}
#define pack_glVariantbvEXT(_id, _addr) ({ \
    glVariantbvEXT_PACKED *packed_data = malloc(sizeof(glVariantbvEXT_PACKED)); \
    packed_data->index = glVariantbvEXT_INDEX; \
    packed_data->args.id = (GLuint)_id; \
    packed_data->args.addr = (GLbyte *)_addr; \
    (packed_call_t *)packed_data; \
})
#define call_glVariantbvEXT(packed, ret_v) do { \
    PACKED_glVariantbvEXT *unpacked = (PACKED_glVariantbvEXT *)packed; \
    ARGS_glVariantbvEXT *args = (ARGS_glVariantbvEXT *)&unpacked->args; \
    glVariantbvEXT(args->id, args->addr);; \
} while(0)
void glVariantbvEXT(glVariantbvEXT_ARG_EXPAND);
typedef void (*glVariantbvEXT_PTR)(glVariantbvEXT_ARG_EXPAND);
#define glVariantdvEXT_INDEX 2286
#define glVariantdvEXT_RETURN void
#define glVariantdvEXT_ARG_NAMES id, addr
#define glVariantdvEXT_ARG_EXPAND GLuint id, const GLdouble * addr
#define glVariantdvEXT_PACKED PACKED_glVariantdvEXT
#define glVariantdvEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVariantdvEXT_NOT_VOID_WRAP(...) {}
#define pack_glVariantdvEXT(_id, _addr) ({ \
    glVariantdvEXT_PACKED *packed_data = malloc(sizeof(glVariantdvEXT_PACKED)); \
    packed_data->index = glVariantdvEXT_INDEX; \
    packed_data->args.id = (GLuint)_id; \
    packed_data->args.addr = (GLdouble *)_addr; \
    (packed_call_t *)packed_data; \
})
#define call_glVariantdvEXT(packed, ret_v) do { \
    PACKED_glVariantdvEXT *unpacked = (PACKED_glVariantdvEXT *)packed; \
    ARGS_glVariantdvEXT *args = (ARGS_glVariantdvEXT *)&unpacked->args; \
    glVariantdvEXT(args->id, args->addr);; \
} while(0)
void glVariantdvEXT(glVariantdvEXT_ARG_EXPAND);
typedef void (*glVariantdvEXT_PTR)(glVariantdvEXT_ARG_EXPAND);
#define glVariantfvEXT_INDEX 2287
#define glVariantfvEXT_RETURN void
#define glVariantfvEXT_ARG_NAMES id, addr
#define glVariantfvEXT_ARG_EXPAND GLuint id, const GLfloat * addr
#define glVariantfvEXT_PACKED PACKED_glVariantfvEXT
#define glVariantfvEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVariantfvEXT_NOT_VOID_WRAP(...) {}
#define pack_glVariantfvEXT(_id, _addr) ({ \
    glVariantfvEXT_PACKED *packed_data = malloc(sizeof(glVariantfvEXT_PACKED)); \
    packed_data->index = glVariantfvEXT_INDEX; \
    packed_data->args.id = (GLuint)_id; \
    packed_data->args.addr = (GLfloat *)_addr; \
    (packed_call_t *)packed_data; \
})
#define call_glVariantfvEXT(packed, ret_v) do { \
    PACKED_glVariantfvEXT *unpacked = (PACKED_glVariantfvEXT *)packed; \
    ARGS_glVariantfvEXT *args = (ARGS_glVariantfvEXT *)&unpacked->args; \
    glVariantfvEXT(args->id, args->addr);; \
} while(0)
void glVariantfvEXT(glVariantfvEXT_ARG_EXPAND);
typedef void (*glVariantfvEXT_PTR)(glVariantfvEXT_ARG_EXPAND);
#define glVariantivEXT_INDEX 2288
#define glVariantivEXT_RETURN void
#define glVariantivEXT_ARG_NAMES id, addr
#define glVariantivEXT_ARG_EXPAND GLuint id, const GLint * addr
#define glVariantivEXT_PACKED PACKED_glVariantivEXT
#define glVariantivEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVariantivEXT_NOT_VOID_WRAP(...) {}
#define pack_glVariantivEXT(_id, _addr) ({ \
    glVariantivEXT_PACKED *packed_data = malloc(sizeof(glVariantivEXT_PACKED)); \
    packed_data->index = glVariantivEXT_INDEX; \
    packed_data->args.id = (GLuint)_id; \
    packed_data->args.addr = (GLint *)_addr; \
    (packed_call_t *)packed_data; \
})
#define call_glVariantivEXT(packed, ret_v) do { \
    PACKED_glVariantivEXT *unpacked = (PACKED_glVariantivEXT *)packed; \
    ARGS_glVariantivEXT *args = (ARGS_glVariantivEXT *)&unpacked->args; \
    glVariantivEXT(args->id, args->addr);; \
} while(0)
void glVariantivEXT(glVariantivEXT_ARG_EXPAND);
typedef void (*glVariantivEXT_PTR)(glVariantivEXT_ARG_EXPAND);
#define glVariantsvEXT_INDEX 2289
#define glVariantsvEXT_RETURN void
#define glVariantsvEXT_ARG_NAMES id, addr
#define glVariantsvEXT_ARG_EXPAND GLuint id, const GLshort * addr
#define glVariantsvEXT_PACKED PACKED_glVariantsvEXT
#define glVariantsvEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVariantsvEXT_NOT_VOID_WRAP(...) {}
#define pack_glVariantsvEXT(_id, _addr) ({ \
    glVariantsvEXT_PACKED *packed_data = malloc(sizeof(glVariantsvEXT_PACKED)); \
    packed_data->index = glVariantsvEXT_INDEX; \
    packed_data->args.id = (GLuint)_id; \
    packed_data->args.addr = (GLshort *)_addr; \
    (packed_call_t *)packed_data; \
})
#define call_glVariantsvEXT(packed, ret_v) do { \
    PACKED_glVariantsvEXT *unpacked = (PACKED_glVariantsvEXT *)packed; \
    ARGS_glVariantsvEXT *args = (ARGS_glVariantsvEXT *)&unpacked->args; \
    glVariantsvEXT(args->id, args->addr);; \
} while(0)
void glVariantsvEXT(glVariantsvEXT_ARG_EXPAND);
typedef void (*glVariantsvEXT_PTR)(glVariantsvEXT_ARG_EXPAND);
#define glVariantubvEXT_INDEX 2290
#define glVariantubvEXT_RETURN void
#define glVariantubvEXT_ARG_NAMES id, addr
#define glVariantubvEXT_ARG_EXPAND GLuint id, const GLubyte * addr
#define glVariantubvEXT_PACKED PACKED_glVariantubvEXT
#define glVariantubvEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVariantubvEXT_NOT_VOID_WRAP(...) {}
#define pack_glVariantubvEXT(_id, _addr) ({ \
    glVariantubvEXT_PACKED *packed_data = malloc(sizeof(glVariantubvEXT_PACKED)); \
    packed_data->index = glVariantubvEXT_INDEX; \
    packed_data->args.id = (GLuint)_id; \
    packed_data->args.addr = (GLubyte *)_addr; \
    (packed_call_t *)packed_data; \
})
#define call_glVariantubvEXT(packed, ret_v) do { \
    PACKED_glVariantubvEXT *unpacked = (PACKED_glVariantubvEXT *)packed; \
    ARGS_glVariantubvEXT *args = (ARGS_glVariantubvEXT *)&unpacked->args; \
    glVariantubvEXT(args->id, args->addr);; \
} while(0)
void glVariantubvEXT(glVariantubvEXT_ARG_EXPAND);
typedef void (*glVariantubvEXT_PTR)(glVariantubvEXT_ARG_EXPAND);
#define glVariantuivEXT_INDEX 2291
#define glVariantuivEXT_RETURN void
#define glVariantuivEXT_ARG_NAMES id, addr
#define glVariantuivEXT_ARG_EXPAND GLuint id, const GLuint * addr
#define glVariantuivEXT_PACKED PACKED_glVariantuivEXT
#define glVariantuivEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVariantuivEXT_NOT_VOID_WRAP(...) {}
#define pack_glVariantuivEXT(_id, _addr) ({ \
    glVariantuivEXT_PACKED *packed_data = malloc(sizeof(glVariantuivEXT_PACKED)); \
    packed_data->index = glVariantuivEXT_INDEX; \
    packed_data->args.id = (GLuint)_id; \
    packed_data->args.addr = (GLuint *)_addr; \
    (packed_call_t *)packed_data; \
})
#define call_glVariantuivEXT(packed, ret_v) do { \
    PACKED_glVariantuivEXT *unpacked = (PACKED_glVariantuivEXT *)packed; \
    ARGS_glVariantuivEXT *args = (ARGS_glVariantuivEXT *)&unpacked->args; \
    glVariantuivEXT(args->id, args->addr);; \
} while(0)
void glVariantuivEXT(glVariantuivEXT_ARG_EXPAND);
typedef void (*glVariantuivEXT_PTR)(glVariantuivEXT_ARG_EXPAND);
#define glVariantusvEXT_INDEX 2292
#define glVariantusvEXT_RETURN void
#define glVariantusvEXT_ARG_NAMES id, addr
#define glVariantusvEXT_ARG_EXPAND GLuint id, const GLushort * addr
#define glVariantusvEXT_PACKED PACKED_glVariantusvEXT
#define glVariantusvEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVariantusvEXT_NOT_VOID_WRAP(...) {}
#define pack_glVariantusvEXT(_id, _addr) ({ \
    glVariantusvEXT_PACKED *packed_data = malloc(sizeof(glVariantusvEXT_PACKED)); \
    packed_data->index = glVariantusvEXT_INDEX; \
    packed_data->args.id = (GLuint)_id; \
    packed_data->args.addr = (GLushort *)_addr; \
    (packed_call_t *)packed_data; \
})
#define call_glVariantusvEXT(packed, ret_v) do { \
    PACKED_glVariantusvEXT *unpacked = (PACKED_glVariantusvEXT *)packed; \
    ARGS_glVariantusvEXT *args = (ARGS_glVariantusvEXT *)&unpacked->args; \
    glVariantusvEXT(args->id, args->addr);; \
} while(0)
void glVariantusvEXT(glVariantusvEXT_ARG_EXPAND);
typedef void (*glVariantusvEXT_PTR)(glVariantusvEXT_ARG_EXPAND);
#define glVertex2bOES_INDEX 2293
#define glVertex2bOES_RETURN void
#define glVertex2bOES_ARG_NAMES x
#define glVertex2bOES_ARG_EXPAND GLbyte x
#define glVertex2bOES_PACKED PACKED_glVertex2bOES
#define glVertex2bOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertex2bOES_NOT_VOID_WRAP(...) {}
#define pack_glVertex2bOES(_x) ({ \
    glVertex2bOES_PACKED *packed_data = malloc(sizeof(glVertex2bOES_PACKED)); \
    packed_data->index = glVertex2bOES_INDEX; \
    packed_data->args.x = (GLbyte)_x; \
    (packed_call_t *)packed_data; \
})
#define call_glVertex2bOES(packed, ret_v) do { \
    PACKED_glVertex2bOES *unpacked = (PACKED_glVertex2bOES *)packed; \
    ARGS_glVertex2bOES *args = (ARGS_glVertex2bOES *)&unpacked->args; \
    glVertex2bOES(args->x);; \
} while(0)
void glVertex2bOES(glVertex2bOES_ARG_EXPAND);
typedef void (*glVertex2bOES_PTR)(glVertex2bOES_ARG_EXPAND);
#define glVertex2bvOES_INDEX 2294
#define glVertex2bvOES_RETURN void
#define glVertex2bvOES_ARG_NAMES coords
#define glVertex2bvOES_ARG_EXPAND const GLbyte * coords
#define glVertex2bvOES_PACKED PACKED_glVertex2bvOES
#define glVertex2bvOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertex2bvOES_NOT_VOID_WRAP(...) {}
#define pack_glVertex2bvOES(_coords) ({ \
    glVertex2bvOES_PACKED *packed_data = malloc(sizeof(glVertex2bvOES_PACKED)); \
    packed_data->index = glVertex2bvOES_INDEX; \
    packed_data->args.coords = (GLbyte *)_coords; \
    (packed_call_t *)packed_data; \
})
#define call_glVertex2bvOES(packed, ret_v) do { \
    PACKED_glVertex2bvOES *unpacked = (PACKED_glVertex2bvOES *)packed; \
    ARGS_glVertex2bvOES *args = (ARGS_glVertex2bvOES *)&unpacked->args; \
    glVertex2bvOES(args->coords);; \
} while(0)
void glVertex2bvOES(glVertex2bvOES_ARG_EXPAND);
typedef void (*glVertex2bvOES_PTR)(glVertex2bvOES_ARG_EXPAND);
#define glVertex2d_INDEX 2295
#define glVertex2d_RETURN void
#define glVertex2d_ARG_NAMES x, y
#define glVertex2d_ARG_EXPAND GLdouble x, GLdouble y
#define glVertex2d_PACKED PACKED_glVertex2d
#define glVertex2d_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertex2d_NOT_VOID_WRAP(...) {}
#define pack_glVertex2d(_x, _y) ({ \
    glVertex2d_PACKED *packed_data = malloc(sizeof(glVertex2d_PACKED)); \
    packed_data->index = glVertex2d_INDEX; \
    packed_data->args.x = (GLdouble)_x; \
    packed_data->args.y = (GLdouble)_y; \
    (packed_call_t *)packed_data; \
})
#define call_glVertex2d(packed, ret_v) do { \
    PACKED_glVertex2d *unpacked = (PACKED_glVertex2d *)packed; \
    ARGS_glVertex2d *args = (ARGS_glVertex2d *)&unpacked->args; \
    glVertex2d(args->x, args->y);; \
} while(0)
void glVertex2d(glVertex2d_ARG_EXPAND);
typedef void (*glVertex2d_PTR)(glVertex2d_ARG_EXPAND);
#define glVertex2dv_INDEX 2296
#define glVertex2dv_RETURN void
#define glVertex2dv_ARG_NAMES v
#define glVertex2dv_ARG_EXPAND const GLdouble * v
#define glVertex2dv_PACKED PACKED_glVertex2dv
#define glVertex2dv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertex2dv_NOT_VOID_WRAP(...) {}
#define pack_glVertex2dv(_v) ({ \
    glVertex2dv_PACKED *packed_data = malloc(sizeof(glVertex2dv_PACKED)); \
    packed_data->index = glVertex2dv_INDEX; \
    packed_data->args.v = (GLdouble *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertex2dv(packed, ret_v) do { \
    PACKED_glVertex2dv *unpacked = (PACKED_glVertex2dv *)packed; \
    ARGS_glVertex2dv *args = (ARGS_glVertex2dv *)&unpacked->args; \
    glVertex2dv(args->v);; \
} while(0)
void glVertex2dv(glVertex2dv_ARG_EXPAND);
typedef void (*glVertex2dv_PTR)(glVertex2dv_ARG_EXPAND);
#define glVertex2f_INDEX 2297
#define glVertex2f_RETURN void
#define glVertex2f_ARG_NAMES x, y
#define glVertex2f_ARG_EXPAND GLfloat x, GLfloat y
#define glVertex2f_PACKED PACKED_glVertex2f
#define glVertex2f_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertex2f_NOT_VOID_WRAP(...) {}
#define pack_glVertex2f(_x, _y) ({ \
    glVertex2f_PACKED *packed_data = malloc(sizeof(glVertex2f_PACKED)); \
    packed_data->index = glVertex2f_INDEX; \
    packed_data->args.x = (GLfloat)_x; \
    packed_data->args.y = (GLfloat)_y; \
    (packed_call_t *)packed_data; \
})
#define call_glVertex2f(packed, ret_v) do { \
    PACKED_glVertex2f *unpacked = (PACKED_glVertex2f *)packed; \
    ARGS_glVertex2f *args = (ARGS_glVertex2f *)&unpacked->args; \
    glVertex2f(args->x, args->y);; \
} while(0)
void glVertex2f(glVertex2f_ARG_EXPAND);
typedef void (*glVertex2f_PTR)(glVertex2f_ARG_EXPAND);
#define glVertex2fv_INDEX 2298
#define glVertex2fv_RETURN void
#define glVertex2fv_ARG_NAMES v
#define glVertex2fv_ARG_EXPAND const GLfloat * v
#define glVertex2fv_PACKED PACKED_glVertex2fv
#define glVertex2fv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertex2fv_NOT_VOID_WRAP(...) {}
#define pack_glVertex2fv(_v) ({ \
    glVertex2fv_PACKED *packed_data = malloc(sizeof(glVertex2fv_PACKED)); \
    packed_data->index = glVertex2fv_INDEX; \
    packed_data->args.v = (GLfloat *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertex2fv(packed, ret_v) do { \
    PACKED_glVertex2fv *unpacked = (PACKED_glVertex2fv *)packed; \
    ARGS_glVertex2fv *args = (ARGS_glVertex2fv *)&unpacked->args; \
    glVertex2fv(args->v);; \
} while(0)
void glVertex2fv(glVertex2fv_ARG_EXPAND);
typedef void (*glVertex2fv_PTR)(glVertex2fv_ARG_EXPAND);
#define glVertex2hNV_INDEX 2299
#define glVertex2hNV_RETURN void
#define glVertex2hNV_ARG_NAMES x, y
#define glVertex2hNV_ARG_EXPAND GLhalfNV x, GLhalfNV y
#define glVertex2hNV_PACKED PACKED_glVertex2hNV
#define glVertex2hNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertex2hNV_NOT_VOID_WRAP(...) {}
#define pack_glVertex2hNV(_x, _y) ({ \
    glVertex2hNV_PACKED *packed_data = malloc(sizeof(glVertex2hNV_PACKED)); \
    packed_data->index = glVertex2hNV_INDEX; \
    packed_data->args.x = (GLhalfNV)_x; \
    packed_data->args.y = (GLhalfNV)_y; \
    (packed_call_t *)packed_data; \
})
#define call_glVertex2hNV(packed, ret_v) do { \
    PACKED_glVertex2hNV *unpacked = (PACKED_glVertex2hNV *)packed; \
    ARGS_glVertex2hNV *args = (ARGS_glVertex2hNV *)&unpacked->args; \
    glVertex2hNV(args->x, args->y);; \
} while(0)
void glVertex2hNV(glVertex2hNV_ARG_EXPAND);
typedef void (*glVertex2hNV_PTR)(glVertex2hNV_ARG_EXPAND);
#define glVertex2hvNV_INDEX 2300
#define glVertex2hvNV_RETURN void
#define glVertex2hvNV_ARG_NAMES v
#define glVertex2hvNV_ARG_EXPAND const GLhalfNV * v
#define glVertex2hvNV_PACKED PACKED_glVertex2hvNV
#define glVertex2hvNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertex2hvNV_NOT_VOID_WRAP(...) {}
#define pack_glVertex2hvNV(_v) ({ \
    glVertex2hvNV_PACKED *packed_data = malloc(sizeof(glVertex2hvNV_PACKED)); \
    packed_data->index = glVertex2hvNV_INDEX; \
    packed_data->args.v = (GLhalfNV *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertex2hvNV(packed, ret_v) do { \
    PACKED_glVertex2hvNV *unpacked = (PACKED_glVertex2hvNV *)packed; \
    ARGS_glVertex2hvNV *args = (ARGS_glVertex2hvNV *)&unpacked->args; \
    glVertex2hvNV(args->v);; \
} while(0)
void glVertex2hvNV(glVertex2hvNV_ARG_EXPAND);
typedef void (*glVertex2hvNV_PTR)(glVertex2hvNV_ARG_EXPAND);
#define glVertex2i_INDEX 2301
#define glVertex2i_RETURN void
#define glVertex2i_ARG_NAMES x, y
#define glVertex2i_ARG_EXPAND GLint x, GLint y
#define glVertex2i_PACKED PACKED_glVertex2i
#define glVertex2i_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertex2i_NOT_VOID_WRAP(...) {}
#define pack_glVertex2i(_x, _y) ({ \
    glVertex2i_PACKED *packed_data = malloc(sizeof(glVertex2i_PACKED)); \
    packed_data->index = glVertex2i_INDEX; \
    packed_data->args.x = (GLint)_x; \
    packed_data->args.y = (GLint)_y; \
    (packed_call_t *)packed_data; \
})
#define call_glVertex2i(packed, ret_v) do { \
    PACKED_glVertex2i *unpacked = (PACKED_glVertex2i *)packed; \
    ARGS_glVertex2i *args = (ARGS_glVertex2i *)&unpacked->args; \
    glVertex2i(args->x, args->y);; \
} while(0)
void glVertex2i(glVertex2i_ARG_EXPAND);
typedef void (*glVertex2i_PTR)(glVertex2i_ARG_EXPAND);
#define glVertex2iv_INDEX 2302
#define glVertex2iv_RETURN void
#define glVertex2iv_ARG_NAMES v
#define glVertex2iv_ARG_EXPAND const GLint * v
#define glVertex2iv_PACKED PACKED_glVertex2iv
#define glVertex2iv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertex2iv_NOT_VOID_WRAP(...) {}
#define pack_glVertex2iv(_v) ({ \
    glVertex2iv_PACKED *packed_data = malloc(sizeof(glVertex2iv_PACKED)); \
    packed_data->index = glVertex2iv_INDEX; \
    packed_data->args.v = (GLint *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertex2iv(packed, ret_v) do { \
    PACKED_glVertex2iv *unpacked = (PACKED_glVertex2iv *)packed; \
    ARGS_glVertex2iv *args = (ARGS_glVertex2iv *)&unpacked->args; \
    glVertex2iv(args->v);; \
} while(0)
void glVertex2iv(glVertex2iv_ARG_EXPAND);
typedef void (*glVertex2iv_PTR)(glVertex2iv_ARG_EXPAND);
#define glVertex2s_INDEX 2303
#define glVertex2s_RETURN void
#define glVertex2s_ARG_NAMES x, y
#define glVertex2s_ARG_EXPAND GLshort x, GLshort y
#define glVertex2s_PACKED PACKED_glVertex2s
#define glVertex2s_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertex2s_NOT_VOID_WRAP(...) {}
#define pack_glVertex2s(_x, _y) ({ \
    glVertex2s_PACKED *packed_data = malloc(sizeof(glVertex2s_PACKED)); \
    packed_data->index = glVertex2s_INDEX; \
    packed_data->args.x = (GLshort)_x; \
    packed_data->args.y = (GLshort)_y; \
    (packed_call_t *)packed_data; \
})
#define call_glVertex2s(packed, ret_v) do { \
    PACKED_glVertex2s *unpacked = (PACKED_glVertex2s *)packed; \
    ARGS_glVertex2s *args = (ARGS_glVertex2s *)&unpacked->args; \
    glVertex2s(args->x, args->y);; \
} while(0)
void glVertex2s(glVertex2s_ARG_EXPAND);
typedef void (*glVertex2s_PTR)(glVertex2s_ARG_EXPAND);
#define glVertex2sv_INDEX 2304
#define glVertex2sv_RETURN void
#define glVertex2sv_ARG_NAMES v
#define glVertex2sv_ARG_EXPAND const GLshort * v
#define glVertex2sv_PACKED PACKED_glVertex2sv
#define glVertex2sv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertex2sv_NOT_VOID_WRAP(...) {}
#define pack_glVertex2sv(_v) ({ \
    glVertex2sv_PACKED *packed_data = malloc(sizeof(glVertex2sv_PACKED)); \
    packed_data->index = glVertex2sv_INDEX; \
    packed_data->args.v = (GLshort *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertex2sv(packed, ret_v) do { \
    PACKED_glVertex2sv *unpacked = (PACKED_glVertex2sv *)packed; \
    ARGS_glVertex2sv *args = (ARGS_glVertex2sv *)&unpacked->args; \
    glVertex2sv(args->v);; \
} while(0)
void glVertex2sv(glVertex2sv_ARG_EXPAND);
typedef void (*glVertex2sv_PTR)(glVertex2sv_ARG_EXPAND);
#define glVertex2xOES_INDEX 2305
#define glVertex2xOES_RETURN void
#define glVertex2xOES_ARG_NAMES x
#define glVertex2xOES_ARG_EXPAND GLfixed x
#define glVertex2xOES_PACKED PACKED_glVertex2xOES
#define glVertex2xOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertex2xOES_NOT_VOID_WRAP(...) {}
#define pack_glVertex2xOES(_x) ({ \
    glVertex2xOES_PACKED *packed_data = malloc(sizeof(glVertex2xOES_PACKED)); \
    packed_data->index = glVertex2xOES_INDEX; \
    packed_data->args.x = (GLfixed)_x; \
    (packed_call_t *)packed_data; \
})
#define call_glVertex2xOES(packed, ret_v) do { \
    PACKED_glVertex2xOES *unpacked = (PACKED_glVertex2xOES *)packed; \
    ARGS_glVertex2xOES *args = (ARGS_glVertex2xOES *)&unpacked->args; \
    glVertex2xOES(args->x);; \
} while(0)
void glVertex2xOES(glVertex2xOES_ARG_EXPAND);
typedef void (*glVertex2xOES_PTR)(glVertex2xOES_ARG_EXPAND);
#define glVertex2xvOES_INDEX 2306
#define glVertex2xvOES_RETURN void
#define glVertex2xvOES_ARG_NAMES coords
#define glVertex2xvOES_ARG_EXPAND const GLfixed * coords
#define glVertex2xvOES_PACKED PACKED_glVertex2xvOES
#define glVertex2xvOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertex2xvOES_NOT_VOID_WRAP(...) {}
#define pack_glVertex2xvOES(_coords) ({ \
    glVertex2xvOES_PACKED *packed_data = malloc(sizeof(glVertex2xvOES_PACKED)); \
    packed_data->index = glVertex2xvOES_INDEX; \
    packed_data->args.coords = (GLfixed *)_coords; \
    (packed_call_t *)packed_data; \
})
#define call_glVertex2xvOES(packed, ret_v) do { \
    PACKED_glVertex2xvOES *unpacked = (PACKED_glVertex2xvOES *)packed; \
    ARGS_glVertex2xvOES *args = (ARGS_glVertex2xvOES *)&unpacked->args; \
    glVertex2xvOES(args->coords);; \
} while(0)
void glVertex2xvOES(glVertex2xvOES_ARG_EXPAND);
typedef void (*glVertex2xvOES_PTR)(glVertex2xvOES_ARG_EXPAND);
#define glVertex3bOES_INDEX 2307
#define glVertex3bOES_RETURN void
#define glVertex3bOES_ARG_NAMES x, y
#define glVertex3bOES_ARG_EXPAND GLbyte x, GLbyte y
#define glVertex3bOES_PACKED PACKED_glVertex3bOES
#define glVertex3bOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertex3bOES_NOT_VOID_WRAP(...) {}
#define pack_glVertex3bOES(_x, _y) ({ \
    glVertex3bOES_PACKED *packed_data = malloc(sizeof(glVertex3bOES_PACKED)); \
    packed_data->index = glVertex3bOES_INDEX; \
    packed_data->args.x = (GLbyte)_x; \
    packed_data->args.y = (GLbyte)_y; \
    (packed_call_t *)packed_data; \
})
#define call_glVertex3bOES(packed, ret_v) do { \
    PACKED_glVertex3bOES *unpacked = (PACKED_glVertex3bOES *)packed; \
    ARGS_glVertex3bOES *args = (ARGS_glVertex3bOES *)&unpacked->args; \
    glVertex3bOES(args->x, args->y);; \
} while(0)
void glVertex3bOES(glVertex3bOES_ARG_EXPAND);
typedef void (*glVertex3bOES_PTR)(glVertex3bOES_ARG_EXPAND);
#define glVertex3bvOES_INDEX 2308
#define glVertex3bvOES_RETURN void
#define glVertex3bvOES_ARG_NAMES coords
#define glVertex3bvOES_ARG_EXPAND const GLbyte * coords
#define glVertex3bvOES_PACKED PACKED_glVertex3bvOES
#define glVertex3bvOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertex3bvOES_NOT_VOID_WRAP(...) {}
#define pack_glVertex3bvOES(_coords) ({ \
    glVertex3bvOES_PACKED *packed_data = malloc(sizeof(glVertex3bvOES_PACKED)); \
    packed_data->index = glVertex3bvOES_INDEX; \
    packed_data->args.coords = (GLbyte *)_coords; \
    (packed_call_t *)packed_data; \
})
#define call_glVertex3bvOES(packed, ret_v) do { \
    PACKED_glVertex3bvOES *unpacked = (PACKED_glVertex3bvOES *)packed; \
    ARGS_glVertex3bvOES *args = (ARGS_glVertex3bvOES *)&unpacked->args; \
    glVertex3bvOES(args->coords);; \
} while(0)
void glVertex3bvOES(glVertex3bvOES_ARG_EXPAND);
typedef void (*glVertex3bvOES_PTR)(glVertex3bvOES_ARG_EXPAND);
#define glVertex3d_INDEX 2309
#define glVertex3d_RETURN void
#define glVertex3d_ARG_NAMES x, y, z
#define glVertex3d_ARG_EXPAND GLdouble x, GLdouble y, GLdouble z
#define glVertex3d_PACKED PACKED_glVertex3d
#define glVertex3d_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertex3d_NOT_VOID_WRAP(...) {}
#define pack_glVertex3d(_x, _y, _z) ({ \
    glVertex3d_PACKED *packed_data = malloc(sizeof(glVertex3d_PACKED)); \
    packed_data->index = glVertex3d_INDEX; \
    packed_data->args.x = (GLdouble)_x; \
    packed_data->args.y = (GLdouble)_y; \
    packed_data->args.z = (GLdouble)_z; \
    (packed_call_t *)packed_data; \
})
#define call_glVertex3d(packed, ret_v) do { \
    PACKED_glVertex3d *unpacked = (PACKED_glVertex3d *)packed; \
    ARGS_glVertex3d *args = (ARGS_glVertex3d *)&unpacked->args; \
    glVertex3d(args->x, args->y, args->z);; \
} while(0)
void glVertex3d(glVertex3d_ARG_EXPAND);
typedef void (*glVertex3d_PTR)(glVertex3d_ARG_EXPAND);
#define glVertex3dv_INDEX 2310
#define glVertex3dv_RETURN void
#define glVertex3dv_ARG_NAMES v
#define glVertex3dv_ARG_EXPAND const GLdouble * v
#define glVertex3dv_PACKED PACKED_glVertex3dv
#define glVertex3dv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertex3dv_NOT_VOID_WRAP(...) {}
#define pack_glVertex3dv(_v) ({ \
    glVertex3dv_PACKED *packed_data = malloc(sizeof(glVertex3dv_PACKED)); \
    packed_data->index = glVertex3dv_INDEX; \
    packed_data->args.v = (GLdouble *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertex3dv(packed, ret_v) do { \
    PACKED_glVertex3dv *unpacked = (PACKED_glVertex3dv *)packed; \
    ARGS_glVertex3dv *args = (ARGS_glVertex3dv *)&unpacked->args; \
    glVertex3dv(args->v);; \
} while(0)
void glVertex3dv(glVertex3dv_ARG_EXPAND);
typedef void (*glVertex3dv_PTR)(glVertex3dv_ARG_EXPAND);
#define glVertex3f_INDEX 2311
#define glVertex3f_RETURN void
#define glVertex3f_ARG_NAMES x, y, z
#define glVertex3f_ARG_EXPAND GLfloat x, GLfloat y, GLfloat z
#define glVertex3f_PACKED PACKED_glVertex3f
#define glVertex3f_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertex3f_NOT_VOID_WRAP(...) {}
#define pack_glVertex3f(_x, _y, _z) ({ \
    glVertex3f_PACKED *packed_data = malloc(sizeof(glVertex3f_PACKED)); \
    packed_data->index = glVertex3f_INDEX; \
    packed_data->args.x = (GLfloat)_x; \
    packed_data->args.y = (GLfloat)_y; \
    packed_data->args.z = (GLfloat)_z; \
    (packed_call_t *)packed_data; \
})
#define call_glVertex3f(packed, ret_v) do { \
    PACKED_glVertex3f *unpacked = (PACKED_glVertex3f *)packed; \
    ARGS_glVertex3f *args = (ARGS_glVertex3f *)&unpacked->args; \
    glVertex3f(args->x, args->y, args->z);; \
} while(0)
void glVertex3f(glVertex3f_ARG_EXPAND);
typedef void (*glVertex3f_PTR)(glVertex3f_ARG_EXPAND);
#define glVertex3fv_INDEX 2312
#define glVertex3fv_RETURN void
#define glVertex3fv_ARG_NAMES v
#define glVertex3fv_ARG_EXPAND const GLfloat * v
#define glVertex3fv_PACKED PACKED_glVertex3fv
#define glVertex3fv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertex3fv_NOT_VOID_WRAP(...) {}
#define pack_glVertex3fv(_v) ({ \
    glVertex3fv_PACKED *packed_data = malloc(sizeof(glVertex3fv_PACKED)); \
    packed_data->index = glVertex3fv_INDEX; \
    packed_data->args.v = (GLfloat *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertex3fv(packed, ret_v) do { \
    PACKED_glVertex3fv *unpacked = (PACKED_glVertex3fv *)packed; \
    ARGS_glVertex3fv *args = (ARGS_glVertex3fv *)&unpacked->args; \
    glVertex3fv(args->v);; \
} while(0)
void glVertex3fv(glVertex3fv_ARG_EXPAND);
typedef void (*glVertex3fv_PTR)(glVertex3fv_ARG_EXPAND);
#define glVertex3hNV_INDEX 2313
#define glVertex3hNV_RETURN void
#define glVertex3hNV_ARG_NAMES x, y, z
#define glVertex3hNV_ARG_EXPAND GLhalfNV x, GLhalfNV y, GLhalfNV z
#define glVertex3hNV_PACKED PACKED_glVertex3hNV
#define glVertex3hNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertex3hNV_NOT_VOID_WRAP(...) {}
#define pack_glVertex3hNV(_x, _y, _z) ({ \
    glVertex3hNV_PACKED *packed_data = malloc(sizeof(glVertex3hNV_PACKED)); \
    packed_data->index = glVertex3hNV_INDEX; \
    packed_data->args.x = (GLhalfNV)_x; \
    packed_data->args.y = (GLhalfNV)_y; \
    packed_data->args.z = (GLhalfNV)_z; \
    (packed_call_t *)packed_data; \
})
#define call_glVertex3hNV(packed, ret_v) do { \
    PACKED_glVertex3hNV *unpacked = (PACKED_glVertex3hNV *)packed; \
    ARGS_glVertex3hNV *args = (ARGS_glVertex3hNV *)&unpacked->args; \
    glVertex3hNV(args->x, args->y, args->z);; \
} while(0)
void glVertex3hNV(glVertex3hNV_ARG_EXPAND);
typedef void (*glVertex3hNV_PTR)(glVertex3hNV_ARG_EXPAND);
#define glVertex3hvNV_INDEX 2314
#define glVertex3hvNV_RETURN void
#define glVertex3hvNV_ARG_NAMES v
#define glVertex3hvNV_ARG_EXPAND const GLhalfNV * v
#define glVertex3hvNV_PACKED PACKED_glVertex3hvNV
#define glVertex3hvNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertex3hvNV_NOT_VOID_WRAP(...) {}
#define pack_glVertex3hvNV(_v) ({ \
    glVertex3hvNV_PACKED *packed_data = malloc(sizeof(glVertex3hvNV_PACKED)); \
    packed_data->index = glVertex3hvNV_INDEX; \
    packed_data->args.v = (GLhalfNV *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertex3hvNV(packed, ret_v) do { \
    PACKED_glVertex3hvNV *unpacked = (PACKED_glVertex3hvNV *)packed; \
    ARGS_glVertex3hvNV *args = (ARGS_glVertex3hvNV *)&unpacked->args; \
    glVertex3hvNV(args->v);; \
} while(0)
void glVertex3hvNV(glVertex3hvNV_ARG_EXPAND);
typedef void (*glVertex3hvNV_PTR)(glVertex3hvNV_ARG_EXPAND);
#define glVertex3i_INDEX 2315
#define glVertex3i_RETURN void
#define glVertex3i_ARG_NAMES x, y, z
#define glVertex3i_ARG_EXPAND GLint x, GLint y, GLint z
#define glVertex3i_PACKED PACKED_glVertex3i
#define glVertex3i_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertex3i_NOT_VOID_WRAP(...) {}
#define pack_glVertex3i(_x, _y, _z) ({ \
    glVertex3i_PACKED *packed_data = malloc(sizeof(glVertex3i_PACKED)); \
    packed_data->index = glVertex3i_INDEX; \
    packed_data->args.x = (GLint)_x; \
    packed_data->args.y = (GLint)_y; \
    packed_data->args.z = (GLint)_z; \
    (packed_call_t *)packed_data; \
})
#define call_glVertex3i(packed, ret_v) do { \
    PACKED_glVertex3i *unpacked = (PACKED_glVertex3i *)packed; \
    ARGS_glVertex3i *args = (ARGS_glVertex3i *)&unpacked->args; \
    glVertex3i(args->x, args->y, args->z);; \
} while(0)
void glVertex3i(glVertex3i_ARG_EXPAND);
typedef void (*glVertex3i_PTR)(glVertex3i_ARG_EXPAND);
#define glVertex3iv_INDEX 2316
#define glVertex3iv_RETURN void
#define glVertex3iv_ARG_NAMES v
#define glVertex3iv_ARG_EXPAND const GLint * v
#define glVertex3iv_PACKED PACKED_glVertex3iv
#define glVertex3iv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertex3iv_NOT_VOID_WRAP(...) {}
#define pack_glVertex3iv(_v) ({ \
    glVertex3iv_PACKED *packed_data = malloc(sizeof(glVertex3iv_PACKED)); \
    packed_data->index = glVertex3iv_INDEX; \
    packed_data->args.v = (GLint *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertex3iv(packed, ret_v) do { \
    PACKED_glVertex3iv *unpacked = (PACKED_glVertex3iv *)packed; \
    ARGS_glVertex3iv *args = (ARGS_glVertex3iv *)&unpacked->args; \
    glVertex3iv(args->v);; \
} while(0)
void glVertex3iv(glVertex3iv_ARG_EXPAND);
typedef void (*glVertex3iv_PTR)(glVertex3iv_ARG_EXPAND);
#define glVertex3s_INDEX 2317
#define glVertex3s_RETURN void
#define glVertex3s_ARG_NAMES x, y, z
#define glVertex3s_ARG_EXPAND GLshort x, GLshort y, GLshort z
#define glVertex3s_PACKED PACKED_glVertex3s
#define glVertex3s_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertex3s_NOT_VOID_WRAP(...) {}
#define pack_glVertex3s(_x, _y, _z) ({ \
    glVertex3s_PACKED *packed_data = malloc(sizeof(glVertex3s_PACKED)); \
    packed_data->index = glVertex3s_INDEX; \
    packed_data->args.x = (GLshort)_x; \
    packed_data->args.y = (GLshort)_y; \
    packed_data->args.z = (GLshort)_z; \
    (packed_call_t *)packed_data; \
})
#define call_glVertex3s(packed, ret_v) do { \
    PACKED_glVertex3s *unpacked = (PACKED_glVertex3s *)packed; \
    ARGS_glVertex3s *args = (ARGS_glVertex3s *)&unpacked->args; \
    glVertex3s(args->x, args->y, args->z);; \
} while(0)
void glVertex3s(glVertex3s_ARG_EXPAND);
typedef void (*glVertex3s_PTR)(glVertex3s_ARG_EXPAND);
#define glVertex3sv_INDEX 2318
#define glVertex3sv_RETURN void
#define glVertex3sv_ARG_NAMES v
#define glVertex3sv_ARG_EXPAND const GLshort * v
#define glVertex3sv_PACKED PACKED_glVertex3sv
#define glVertex3sv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertex3sv_NOT_VOID_WRAP(...) {}
#define pack_glVertex3sv(_v) ({ \
    glVertex3sv_PACKED *packed_data = malloc(sizeof(glVertex3sv_PACKED)); \
    packed_data->index = glVertex3sv_INDEX; \
    packed_data->args.v = (GLshort *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertex3sv(packed, ret_v) do { \
    PACKED_glVertex3sv *unpacked = (PACKED_glVertex3sv *)packed; \
    ARGS_glVertex3sv *args = (ARGS_glVertex3sv *)&unpacked->args; \
    glVertex3sv(args->v);; \
} while(0)
void glVertex3sv(glVertex3sv_ARG_EXPAND);
typedef void (*glVertex3sv_PTR)(glVertex3sv_ARG_EXPAND);
#define glVertex3xOES_INDEX 2319
#define glVertex3xOES_RETURN void
#define glVertex3xOES_ARG_NAMES x, y
#define glVertex3xOES_ARG_EXPAND GLfixed x, GLfixed y
#define glVertex3xOES_PACKED PACKED_glVertex3xOES
#define glVertex3xOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertex3xOES_NOT_VOID_WRAP(...) {}
#define pack_glVertex3xOES(_x, _y) ({ \
    glVertex3xOES_PACKED *packed_data = malloc(sizeof(glVertex3xOES_PACKED)); \
    packed_data->index = glVertex3xOES_INDEX; \
    packed_data->args.x = (GLfixed)_x; \
    packed_data->args.y = (GLfixed)_y; \
    (packed_call_t *)packed_data; \
})
#define call_glVertex3xOES(packed, ret_v) do { \
    PACKED_glVertex3xOES *unpacked = (PACKED_glVertex3xOES *)packed; \
    ARGS_glVertex3xOES *args = (ARGS_glVertex3xOES *)&unpacked->args; \
    glVertex3xOES(args->x, args->y);; \
} while(0)
void glVertex3xOES(glVertex3xOES_ARG_EXPAND);
typedef void (*glVertex3xOES_PTR)(glVertex3xOES_ARG_EXPAND);
#define glVertex3xvOES_INDEX 2320
#define glVertex3xvOES_RETURN void
#define glVertex3xvOES_ARG_NAMES coords
#define glVertex3xvOES_ARG_EXPAND const GLfixed * coords
#define glVertex3xvOES_PACKED PACKED_glVertex3xvOES
#define glVertex3xvOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertex3xvOES_NOT_VOID_WRAP(...) {}
#define pack_glVertex3xvOES(_coords) ({ \
    glVertex3xvOES_PACKED *packed_data = malloc(sizeof(glVertex3xvOES_PACKED)); \
    packed_data->index = glVertex3xvOES_INDEX; \
    packed_data->args.coords = (GLfixed *)_coords; \
    (packed_call_t *)packed_data; \
})
#define call_glVertex3xvOES(packed, ret_v) do { \
    PACKED_glVertex3xvOES *unpacked = (PACKED_glVertex3xvOES *)packed; \
    ARGS_glVertex3xvOES *args = (ARGS_glVertex3xvOES *)&unpacked->args; \
    glVertex3xvOES(args->coords);; \
} while(0)
void glVertex3xvOES(glVertex3xvOES_ARG_EXPAND);
typedef void (*glVertex3xvOES_PTR)(glVertex3xvOES_ARG_EXPAND);
#define glVertex4bOES_INDEX 2321
#define glVertex4bOES_RETURN void
#define glVertex4bOES_ARG_NAMES x, y, z
#define glVertex4bOES_ARG_EXPAND GLbyte x, GLbyte y, GLbyte z
#define glVertex4bOES_PACKED PACKED_glVertex4bOES
#define glVertex4bOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertex4bOES_NOT_VOID_WRAP(...) {}
#define pack_glVertex4bOES(_x, _y, _z) ({ \
    glVertex4bOES_PACKED *packed_data = malloc(sizeof(glVertex4bOES_PACKED)); \
    packed_data->index = glVertex4bOES_INDEX; \
    packed_data->args.x = (GLbyte)_x; \
    packed_data->args.y = (GLbyte)_y; \
    packed_data->args.z = (GLbyte)_z; \
    (packed_call_t *)packed_data; \
})
#define call_glVertex4bOES(packed, ret_v) do { \
    PACKED_glVertex4bOES *unpacked = (PACKED_glVertex4bOES *)packed; \
    ARGS_glVertex4bOES *args = (ARGS_glVertex4bOES *)&unpacked->args; \
    glVertex4bOES(args->x, args->y, args->z);; \
} while(0)
void glVertex4bOES(glVertex4bOES_ARG_EXPAND);
typedef void (*glVertex4bOES_PTR)(glVertex4bOES_ARG_EXPAND);
#define glVertex4bvOES_INDEX 2322
#define glVertex4bvOES_RETURN void
#define glVertex4bvOES_ARG_NAMES coords
#define glVertex4bvOES_ARG_EXPAND const GLbyte * coords
#define glVertex4bvOES_PACKED PACKED_glVertex4bvOES
#define glVertex4bvOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertex4bvOES_NOT_VOID_WRAP(...) {}
#define pack_glVertex4bvOES(_coords) ({ \
    glVertex4bvOES_PACKED *packed_data = malloc(sizeof(glVertex4bvOES_PACKED)); \
    packed_data->index = glVertex4bvOES_INDEX; \
    packed_data->args.coords = (GLbyte *)_coords; \
    (packed_call_t *)packed_data; \
})
#define call_glVertex4bvOES(packed, ret_v) do { \
    PACKED_glVertex4bvOES *unpacked = (PACKED_glVertex4bvOES *)packed; \
    ARGS_glVertex4bvOES *args = (ARGS_glVertex4bvOES *)&unpacked->args; \
    glVertex4bvOES(args->coords);; \
} while(0)
void glVertex4bvOES(glVertex4bvOES_ARG_EXPAND);
typedef void (*glVertex4bvOES_PTR)(glVertex4bvOES_ARG_EXPAND);
#define glVertex4d_INDEX 2323
#define glVertex4d_RETURN void
#define glVertex4d_ARG_NAMES x, y, z, w
#define glVertex4d_ARG_EXPAND GLdouble x, GLdouble y, GLdouble z, GLdouble w
#define glVertex4d_PACKED PACKED_glVertex4d
#define glVertex4d_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertex4d_NOT_VOID_WRAP(...) {}
#define pack_glVertex4d(_x, _y, _z, _w) ({ \
    glVertex4d_PACKED *packed_data = malloc(sizeof(glVertex4d_PACKED)); \
    packed_data->index = glVertex4d_INDEX; \
    packed_data->args.x = (GLdouble)_x; \
    packed_data->args.y = (GLdouble)_y; \
    packed_data->args.z = (GLdouble)_z; \
    packed_data->args.w = (GLdouble)_w; \
    (packed_call_t *)packed_data; \
})
#define call_glVertex4d(packed, ret_v) do { \
    PACKED_glVertex4d *unpacked = (PACKED_glVertex4d *)packed; \
    ARGS_glVertex4d *args = (ARGS_glVertex4d *)&unpacked->args; \
    glVertex4d(args->x, args->y, args->z, args->w);; \
} while(0)
void glVertex4d(glVertex4d_ARG_EXPAND);
typedef void (*glVertex4d_PTR)(glVertex4d_ARG_EXPAND);
#define glVertex4dv_INDEX 2324
#define glVertex4dv_RETURN void
#define glVertex4dv_ARG_NAMES v
#define glVertex4dv_ARG_EXPAND const GLdouble * v
#define glVertex4dv_PACKED PACKED_glVertex4dv
#define glVertex4dv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertex4dv_NOT_VOID_WRAP(...) {}
#define pack_glVertex4dv(_v) ({ \
    glVertex4dv_PACKED *packed_data = malloc(sizeof(glVertex4dv_PACKED)); \
    packed_data->index = glVertex4dv_INDEX; \
    packed_data->args.v = (GLdouble *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertex4dv(packed, ret_v) do { \
    PACKED_glVertex4dv *unpacked = (PACKED_glVertex4dv *)packed; \
    ARGS_glVertex4dv *args = (ARGS_glVertex4dv *)&unpacked->args; \
    glVertex4dv(args->v);; \
} while(0)
void glVertex4dv(glVertex4dv_ARG_EXPAND);
typedef void (*glVertex4dv_PTR)(glVertex4dv_ARG_EXPAND);
#define glVertex4f_INDEX 2325
#define glVertex4f_RETURN void
#define glVertex4f_ARG_NAMES x, y, z, w
#define glVertex4f_ARG_EXPAND GLfloat x, GLfloat y, GLfloat z, GLfloat w
#define glVertex4f_PACKED PACKED_glVertex4f
#define glVertex4f_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertex4f_NOT_VOID_WRAP(...) {}
#define pack_glVertex4f(_x, _y, _z, _w) ({ \
    glVertex4f_PACKED *packed_data = malloc(sizeof(glVertex4f_PACKED)); \
    packed_data->index = glVertex4f_INDEX; \
    packed_data->args.x = (GLfloat)_x; \
    packed_data->args.y = (GLfloat)_y; \
    packed_data->args.z = (GLfloat)_z; \
    packed_data->args.w = (GLfloat)_w; \
    (packed_call_t *)packed_data; \
})
#define call_glVertex4f(packed, ret_v) do { \
    PACKED_glVertex4f *unpacked = (PACKED_glVertex4f *)packed; \
    ARGS_glVertex4f *args = (ARGS_glVertex4f *)&unpacked->args; \
    glVertex4f(args->x, args->y, args->z, args->w);; \
} while(0)
void glVertex4f(glVertex4f_ARG_EXPAND);
typedef void (*glVertex4f_PTR)(glVertex4f_ARG_EXPAND);
#define glVertex4fv_INDEX 2326
#define glVertex4fv_RETURN void
#define glVertex4fv_ARG_NAMES v
#define glVertex4fv_ARG_EXPAND const GLfloat * v
#define glVertex4fv_PACKED PACKED_glVertex4fv
#define glVertex4fv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertex4fv_NOT_VOID_WRAP(...) {}
#define pack_glVertex4fv(_v) ({ \
    glVertex4fv_PACKED *packed_data = malloc(sizeof(glVertex4fv_PACKED)); \
    packed_data->index = glVertex4fv_INDEX; \
    packed_data->args.v = (GLfloat *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertex4fv(packed, ret_v) do { \
    PACKED_glVertex4fv *unpacked = (PACKED_glVertex4fv *)packed; \
    ARGS_glVertex4fv *args = (ARGS_glVertex4fv *)&unpacked->args; \
    glVertex4fv(args->v);; \
} while(0)
void glVertex4fv(glVertex4fv_ARG_EXPAND);
typedef void (*glVertex4fv_PTR)(glVertex4fv_ARG_EXPAND);
#define glVertex4hNV_INDEX 2327
#define glVertex4hNV_RETURN void
#define glVertex4hNV_ARG_NAMES x, y, z, w
#define glVertex4hNV_ARG_EXPAND GLhalfNV x, GLhalfNV y, GLhalfNV z, GLhalfNV w
#define glVertex4hNV_PACKED PACKED_glVertex4hNV
#define glVertex4hNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertex4hNV_NOT_VOID_WRAP(...) {}
#define pack_glVertex4hNV(_x, _y, _z, _w) ({ \
    glVertex4hNV_PACKED *packed_data = malloc(sizeof(glVertex4hNV_PACKED)); \
    packed_data->index = glVertex4hNV_INDEX; \
    packed_data->args.x = (GLhalfNV)_x; \
    packed_data->args.y = (GLhalfNV)_y; \
    packed_data->args.z = (GLhalfNV)_z; \
    packed_data->args.w = (GLhalfNV)_w; \
    (packed_call_t *)packed_data; \
})
#define call_glVertex4hNV(packed, ret_v) do { \
    PACKED_glVertex4hNV *unpacked = (PACKED_glVertex4hNV *)packed; \
    ARGS_glVertex4hNV *args = (ARGS_glVertex4hNV *)&unpacked->args; \
    glVertex4hNV(args->x, args->y, args->z, args->w);; \
} while(0)
void glVertex4hNV(glVertex4hNV_ARG_EXPAND);
typedef void (*glVertex4hNV_PTR)(glVertex4hNV_ARG_EXPAND);
#define glVertex4hvNV_INDEX 2328
#define glVertex4hvNV_RETURN void
#define glVertex4hvNV_ARG_NAMES v
#define glVertex4hvNV_ARG_EXPAND const GLhalfNV * v
#define glVertex4hvNV_PACKED PACKED_glVertex4hvNV
#define glVertex4hvNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertex4hvNV_NOT_VOID_WRAP(...) {}
#define pack_glVertex4hvNV(_v) ({ \
    glVertex4hvNV_PACKED *packed_data = malloc(sizeof(glVertex4hvNV_PACKED)); \
    packed_data->index = glVertex4hvNV_INDEX; \
    packed_data->args.v = (GLhalfNV *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertex4hvNV(packed, ret_v) do { \
    PACKED_glVertex4hvNV *unpacked = (PACKED_glVertex4hvNV *)packed; \
    ARGS_glVertex4hvNV *args = (ARGS_glVertex4hvNV *)&unpacked->args; \
    glVertex4hvNV(args->v);; \
} while(0)
void glVertex4hvNV(glVertex4hvNV_ARG_EXPAND);
typedef void (*glVertex4hvNV_PTR)(glVertex4hvNV_ARG_EXPAND);
#define glVertex4i_INDEX 2329
#define glVertex4i_RETURN void
#define glVertex4i_ARG_NAMES x, y, z, w
#define glVertex4i_ARG_EXPAND GLint x, GLint y, GLint z, GLint w
#define glVertex4i_PACKED PACKED_glVertex4i
#define glVertex4i_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertex4i_NOT_VOID_WRAP(...) {}
#define pack_glVertex4i(_x, _y, _z, _w) ({ \
    glVertex4i_PACKED *packed_data = malloc(sizeof(glVertex4i_PACKED)); \
    packed_data->index = glVertex4i_INDEX; \
    packed_data->args.x = (GLint)_x; \
    packed_data->args.y = (GLint)_y; \
    packed_data->args.z = (GLint)_z; \
    packed_data->args.w = (GLint)_w; \
    (packed_call_t *)packed_data; \
})
#define call_glVertex4i(packed, ret_v) do { \
    PACKED_glVertex4i *unpacked = (PACKED_glVertex4i *)packed; \
    ARGS_glVertex4i *args = (ARGS_glVertex4i *)&unpacked->args; \
    glVertex4i(args->x, args->y, args->z, args->w);; \
} while(0)
void glVertex4i(glVertex4i_ARG_EXPAND);
typedef void (*glVertex4i_PTR)(glVertex4i_ARG_EXPAND);
#define glVertex4iv_INDEX 2330
#define glVertex4iv_RETURN void
#define glVertex4iv_ARG_NAMES v
#define glVertex4iv_ARG_EXPAND const GLint * v
#define glVertex4iv_PACKED PACKED_glVertex4iv
#define glVertex4iv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertex4iv_NOT_VOID_WRAP(...) {}
#define pack_glVertex4iv(_v) ({ \
    glVertex4iv_PACKED *packed_data = malloc(sizeof(glVertex4iv_PACKED)); \
    packed_data->index = glVertex4iv_INDEX; \
    packed_data->args.v = (GLint *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertex4iv(packed, ret_v) do { \
    PACKED_glVertex4iv *unpacked = (PACKED_glVertex4iv *)packed; \
    ARGS_glVertex4iv *args = (ARGS_glVertex4iv *)&unpacked->args; \
    glVertex4iv(args->v);; \
} while(0)
void glVertex4iv(glVertex4iv_ARG_EXPAND);
typedef void (*glVertex4iv_PTR)(glVertex4iv_ARG_EXPAND);
#define glVertex4s_INDEX 2331
#define glVertex4s_RETURN void
#define glVertex4s_ARG_NAMES x, y, z, w
#define glVertex4s_ARG_EXPAND GLshort x, GLshort y, GLshort z, GLshort w
#define glVertex4s_PACKED PACKED_glVertex4s
#define glVertex4s_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertex4s_NOT_VOID_WRAP(...) {}
#define pack_glVertex4s(_x, _y, _z, _w) ({ \
    glVertex4s_PACKED *packed_data = malloc(sizeof(glVertex4s_PACKED)); \
    packed_data->index = glVertex4s_INDEX; \
    packed_data->args.x = (GLshort)_x; \
    packed_data->args.y = (GLshort)_y; \
    packed_data->args.z = (GLshort)_z; \
    packed_data->args.w = (GLshort)_w; \
    (packed_call_t *)packed_data; \
})
#define call_glVertex4s(packed, ret_v) do { \
    PACKED_glVertex4s *unpacked = (PACKED_glVertex4s *)packed; \
    ARGS_glVertex4s *args = (ARGS_glVertex4s *)&unpacked->args; \
    glVertex4s(args->x, args->y, args->z, args->w);; \
} while(0)
void glVertex4s(glVertex4s_ARG_EXPAND);
typedef void (*glVertex4s_PTR)(glVertex4s_ARG_EXPAND);
#define glVertex4sv_INDEX 2332
#define glVertex4sv_RETURN void
#define glVertex4sv_ARG_NAMES v
#define glVertex4sv_ARG_EXPAND const GLshort * v
#define glVertex4sv_PACKED PACKED_glVertex4sv
#define glVertex4sv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertex4sv_NOT_VOID_WRAP(...) {}
#define pack_glVertex4sv(_v) ({ \
    glVertex4sv_PACKED *packed_data = malloc(sizeof(glVertex4sv_PACKED)); \
    packed_data->index = glVertex4sv_INDEX; \
    packed_data->args.v = (GLshort *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertex4sv(packed, ret_v) do { \
    PACKED_glVertex4sv *unpacked = (PACKED_glVertex4sv *)packed; \
    ARGS_glVertex4sv *args = (ARGS_glVertex4sv *)&unpacked->args; \
    glVertex4sv(args->v);; \
} while(0)
void glVertex4sv(glVertex4sv_ARG_EXPAND);
typedef void (*glVertex4sv_PTR)(glVertex4sv_ARG_EXPAND);
#define glVertex4xOES_INDEX 2333
#define glVertex4xOES_RETURN void
#define glVertex4xOES_ARG_NAMES x, y, z
#define glVertex4xOES_ARG_EXPAND GLfixed x, GLfixed y, GLfixed z
#define glVertex4xOES_PACKED PACKED_glVertex4xOES
#define glVertex4xOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertex4xOES_NOT_VOID_WRAP(...) {}
#define pack_glVertex4xOES(_x, _y, _z) ({ \
    glVertex4xOES_PACKED *packed_data = malloc(sizeof(glVertex4xOES_PACKED)); \
    packed_data->index = glVertex4xOES_INDEX; \
    packed_data->args.x = (GLfixed)_x; \
    packed_data->args.y = (GLfixed)_y; \
    packed_data->args.z = (GLfixed)_z; \
    (packed_call_t *)packed_data; \
})
#define call_glVertex4xOES(packed, ret_v) do { \
    PACKED_glVertex4xOES *unpacked = (PACKED_glVertex4xOES *)packed; \
    ARGS_glVertex4xOES *args = (ARGS_glVertex4xOES *)&unpacked->args; \
    glVertex4xOES(args->x, args->y, args->z);; \
} while(0)
void glVertex4xOES(glVertex4xOES_ARG_EXPAND);
typedef void (*glVertex4xOES_PTR)(glVertex4xOES_ARG_EXPAND);
#define glVertex4xvOES_INDEX 2334
#define glVertex4xvOES_RETURN void
#define glVertex4xvOES_ARG_NAMES coords
#define glVertex4xvOES_ARG_EXPAND const GLfixed * coords
#define glVertex4xvOES_PACKED PACKED_glVertex4xvOES
#define glVertex4xvOES_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertex4xvOES_NOT_VOID_WRAP(...) {}
#define pack_glVertex4xvOES(_coords) ({ \
    glVertex4xvOES_PACKED *packed_data = malloc(sizeof(glVertex4xvOES_PACKED)); \
    packed_data->index = glVertex4xvOES_INDEX; \
    packed_data->args.coords = (GLfixed *)_coords; \
    (packed_call_t *)packed_data; \
})
#define call_glVertex4xvOES(packed, ret_v) do { \
    PACKED_glVertex4xvOES *unpacked = (PACKED_glVertex4xvOES *)packed; \
    ARGS_glVertex4xvOES *args = (ARGS_glVertex4xvOES *)&unpacked->args; \
    glVertex4xvOES(args->coords);; \
} while(0)
void glVertex4xvOES(glVertex4xvOES_ARG_EXPAND);
typedef void (*glVertex4xvOES_PTR)(glVertex4xvOES_ARG_EXPAND);
#define glVertexArrayBindVertexBufferEXT_INDEX 2335
#define glVertexArrayBindVertexBufferEXT_RETURN void
#define glVertexArrayBindVertexBufferEXT_ARG_NAMES vaobj, bindingindex, buffer, offset, stride
#define glVertexArrayBindVertexBufferEXT_ARG_EXPAND GLuint vaobj, GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride
#define glVertexArrayBindVertexBufferEXT_PACKED PACKED_glVertexArrayBindVertexBufferEXT
#define glVertexArrayBindVertexBufferEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexArrayBindVertexBufferEXT_NOT_VOID_WRAP(...) {}
#define pack_glVertexArrayBindVertexBufferEXT(_vaobj, _bindingindex, _buffer, _offset, _stride) ({ \
    glVertexArrayBindVertexBufferEXT_PACKED *packed_data = malloc(sizeof(glVertexArrayBindVertexBufferEXT_PACKED)); \
    packed_data->index = glVertexArrayBindVertexBufferEXT_INDEX; \
    packed_data->args.vaobj = (GLuint)_vaobj; \
    packed_data->args.bindingindex = (GLuint)_bindingindex; \
    packed_data->args.buffer = (GLuint)_buffer; \
    packed_data->args.offset = (GLintptr)_offset; \
    packed_data->args.stride = (GLsizei)_stride; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexArrayBindVertexBufferEXT(packed, ret_v) do { \
    PACKED_glVertexArrayBindVertexBufferEXT *unpacked = (PACKED_glVertexArrayBindVertexBufferEXT *)packed; \
    ARGS_glVertexArrayBindVertexBufferEXT *args = (ARGS_glVertexArrayBindVertexBufferEXT *)&unpacked->args; \
    glVertexArrayBindVertexBufferEXT(args->vaobj, args->bindingindex, args->buffer, args->offset, args->stride);; \
} while(0)
void glVertexArrayBindVertexBufferEXT(glVertexArrayBindVertexBufferEXT_ARG_EXPAND);
typedef void (*glVertexArrayBindVertexBufferEXT_PTR)(glVertexArrayBindVertexBufferEXT_ARG_EXPAND);
#define glVertexArrayColorOffsetEXT_INDEX 2336
#define glVertexArrayColorOffsetEXT_RETURN void
#define glVertexArrayColorOffsetEXT_ARG_NAMES vaobj, buffer, size, type, stride, offset
#define glVertexArrayColorOffsetEXT_ARG_EXPAND GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset
#define glVertexArrayColorOffsetEXT_PACKED PACKED_glVertexArrayColorOffsetEXT
#define glVertexArrayColorOffsetEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexArrayColorOffsetEXT_NOT_VOID_WRAP(...) {}
#define pack_glVertexArrayColorOffsetEXT(_vaobj, _buffer, _size, _type, _stride, _offset) ({ \
    glVertexArrayColorOffsetEXT_PACKED *packed_data = malloc(sizeof(glVertexArrayColorOffsetEXT_PACKED)); \
    packed_data->index = glVertexArrayColorOffsetEXT_INDEX; \
    packed_data->args.vaobj = (GLuint)_vaobj; \
    packed_data->args.buffer = (GLuint)_buffer; \
    packed_data->args.size = (GLint)_size; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.stride = (GLsizei)_stride; \
    packed_data->args.offset = (GLintptr)_offset; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexArrayColorOffsetEXT(packed, ret_v) do { \
    PACKED_glVertexArrayColorOffsetEXT *unpacked = (PACKED_glVertexArrayColorOffsetEXT *)packed; \
    ARGS_glVertexArrayColorOffsetEXT *args = (ARGS_glVertexArrayColorOffsetEXT *)&unpacked->args; \
    glVertexArrayColorOffsetEXT(args->vaobj, args->buffer, args->size, args->type, args->stride, args->offset);; \
} while(0)
void glVertexArrayColorOffsetEXT(glVertexArrayColorOffsetEXT_ARG_EXPAND);
typedef void (*glVertexArrayColorOffsetEXT_PTR)(glVertexArrayColorOffsetEXT_ARG_EXPAND);
#define glVertexArrayEdgeFlagOffsetEXT_INDEX 2337
#define glVertexArrayEdgeFlagOffsetEXT_RETURN void
#define glVertexArrayEdgeFlagOffsetEXT_ARG_NAMES vaobj, buffer, stride, offset
#define glVertexArrayEdgeFlagOffsetEXT_ARG_EXPAND GLuint vaobj, GLuint buffer, GLsizei stride, GLintptr offset
#define glVertexArrayEdgeFlagOffsetEXT_PACKED PACKED_glVertexArrayEdgeFlagOffsetEXT
#define glVertexArrayEdgeFlagOffsetEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexArrayEdgeFlagOffsetEXT_NOT_VOID_WRAP(...) {}
#define pack_glVertexArrayEdgeFlagOffsetEXT(_vaobj, _buffer, _stride, _offset) ({ \
    glVertexArrayEdgeFlagOffsetEXT_PACKED *packed_data = malloc(sizeof(glVertexArrayEdgeFlagOffsetEXT_PACKED)); \
    packed_data->index = glVertexArrayEdgeFlagOffsetEXT_INDEX; \
    packed_data->args.vaobj = (GLuint)_vaobj; \
    packed_data->args.buffer = (GLuint)_buffer; \
    packed_data->args.stride = (GLsizei)_stride; \
    packed_data->args.offset = (GLintptr)_offset; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexArrayEdgeFlagOffsetEXT(packed, ret_v) do { \
    PACKED_glVertexArrayEdgeFlagOffsetEXT *unpacked = (PACKED_glVertexArrayEdgeFlagOffsetEXT *)packed; \
    ARGS_glVertexArrayEdgeFlagOffsetEXT *args = (ARGS_glVertexArrayEdgeFlagOffsetEXT *)&unpacked->args; \
    glVertexArrayEdgeFlagOffsetEXT(args->vaobj, args->buffer, args->stride, args->offset);; \
} while(0)
void glVertexArrayEdgeFlagOffsetEXT(glVertexArrayEdgeFlagOffsetEXT_ARG_EXPAND);
typedef void (*glVertexArrayEdgeFlagOffsetEXT_PTR)(glVertexArrayEdgeFlagOffsetEXT_ARG_EXPAND);
#define glVertexArrayFogCoordOffsetEXT_INDEX 2338
#define glVertexArrayFogCoordOffsetEXT_RETURN void
#define glVertexArrayFogCoordOffsetEXT_ARG_NAMES vaobj, buffer, type, stride, offset
#define glVertexArrayFogCoordOffsetEXT_ARG_EXPAND GLuint vaobj, GLuint buffer, GLenum type, GLsizei stride, GLintptr offset
#define glVertexArrayFogCoordOffsetEXT_PACKED PACKED_glVertexArrayFogCoordOffsetEXT
#define glVertexArrayFogCoordOffsetEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexArrayFogCoordOffsetEXT_NOT_VOID_WRAP(...) {}
#define pack_glVertexArrayFogCoordOffsetEXT(_vaobj, _buffer, _type, _stride, _offset) ({ \
    glVertexArrayFogCoordOffsetEXT_PACKED *packed_data = malloc(sizeof(glVertexArrayFogCoordOffsetEXT_PACKED)); \
    packed_data->index = glVertexArrayFogCoordOffsetEXT_INDEX; \
    packed_data->args.vaobj = (GLuint)_vaobj; \
    packed_data->args.buffer = (GLuint)_buffer; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.stride = (GLsizei)_stride; \
    packed_data->args.offset = (GLintptr)_offset; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexArrayFogCoordOffsetEXT(packed, ret_v) do { \
    PACKED_glVertexArrayFogCoordOffsetEXT *unpacked = (PACKED_glVertexArrayFogCoordOffsetEXT *)packed; \
    ARGS_glVertexArrayFogCoordOffsetEXT *args = (ARGS_glVertexArrayFogCoordOffsetEXT *)&unpacked->args; \
    glVertexArrayFogCoordOffsetEXT(args->vaobj, args->buffer, args->type, args->stride, args->offset);; \
} while(0)
void glVertexArrayFogCoordOffsetEXT(glVertexArrayFogCoordOffsetEXT_ARG_EXPAND);
typedef void (*glVertexArrayFogCoordOffsetEXT_PTR)(glVertexArrayFogCoordOffsetEXT_ARG_EXPAND);
#define glVertexArrayIndexOffsetEXT_INDEX 2339
#define glVertexArrayIndexOffsetEXT_RETURN void
#define glVertexArrayIndexOffsetEXT_ARG_NAMES vaobj, buffer, type, stride, offset
#define glVertexArrayIndexOffsetEXT_ARG_EXPAND GLuint vaobj, GLuint buffer, GLenum type, GLsizei stride, GLintptr offset
#define glVertexArrayIndexOffsetEXT_PACKED PACKED_glVertexArrayIndexOffsetEXT
#define glVertexArrayIndexOffsetEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexArrayIndexOffsetEXT_NOT_VOID_WRAP(...) {}
#define pack_glVertexArrayIndexOffsetEXT(_vaobj, _buffer, _type, _stride, _offset) ({ \
    glVertexArrayIndexOffsetEXT_PACKED *packed_data = malloc(sizeof(glVertexArrayIndexOffsetEXT_PACKED)); \
    packed_data->index = glVertexArrayIndexOffsetEXT_INDEX; \
    packed_data->args.vaobj = (GLuint)_vaobj; \
    packed_data->args.buffer = (GLuint)_buffer; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.stride = (GLsizei)_stride; \
    packed_data->args.offset = (GLintptr)_offset; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexArrayIndexOffsetEXT(packed, ret_v) do { \
    PACKED_glVertexArrayIndexOffsetEXT *unpacked = (PACKED_glVertexArrayIndexOffsetEXT *)packed; \
    ARGS_glVertexArrayIndexOffsetEXT *args = (ARGS_glVertexArrayIndexOffsetEXT *)&unpacked->args; \
    glVertexArrayIndexOffsetEXT(args->vaobj, args->buffer, args->type, args->stride, args->offset);; \
} while(0)
void glVertexArrayIndexOffsetEXT(glVertexArrayIndexOffsetEXT_ARG_EXPAND);
typedef void (*glVertexArrayIndexOffsetEXT_PTR)(glVertexArrayIndexOffsetEXT_ARG_EXPAND);
#define glVertexArrayMultiTexCoordOffsetEXT_INDEX 2340
#define glVertexArrayMultiTexCoordOffsetEXT_RETURN void
#define glVertexArrayMultiTexCoordOffsetEXT_ARG_NAMES vaobj, buffer, texunit, size, type, stride, offset
#define glVertexArrayMultiTexCoordOffsetEXT_ARG_EXPAND GLuint vaobj, GLuint buffer, GLenum texunit, GLint size, GLenum type, GLsizei stride, GLintptr offset
#define glVertexArrayMultiTexCoordOffsetEXT_PACKED PACKED_glVertexArrayMultiTexCoordOffsetEXT
#define glVertexArrayMultiTexCoordOffsetEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexArrayMultiTexCoordOffsetEXT_NOT_VOID_WRAP(...) {}
#define pack_glVertexArrayMultiTexCoordOffsetEXT(_vaobj, _buffer, _texunit, _size, _type, _stride, _offset) ({ \
    glVertexArrayMultiTexCoordOffsetEXT_PACKED *packed_data = malloc(sizeof(glVertexArrayMultiTexCoordOffsetEXT_PACKED)); \
    packed_data->index = glVertexArrayMultiTexCoordOffsetEXT_INDEX; \
    packed_data->args.vaobj = (GLuint)_vaobj; \
    packed_data->args.buffer = (GLuint)_buffer; \
    packed_data->args.texunit = (GLenum)_texunit; \
    packed_data->args.size = (GLint)_size; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.stride = (GLsizei)_stride; \
    packed_data->args.offset = (GLintptr)_offset; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexArrayMultiTexCoordOffsetEXT(packed, ret_v) do { \
    PACKED_glVertexArrayMultiTexCoordOffsetEXT *unpacked = (PACKED_glVertexArrayMultiTexCoordOffsetEXT *)packed; \
    ARGS_glVertexArrayMultiTexCoordOffsetEXT *args = (ARGS_glVertexArrayMultiTexCoordOffsetEXT *)&unpacked->args; \
    glVertexArrayMultiTexCoordOffsetEXT(args->vaobj, args->buffer, args->texunit, args->size, args->type, args->stride, args->offset);; \
} while(0)
void glVertexArrayMultiTexCoordOffsetEXT(glVertexArrayMultiTexCoordOffsetEXT_ARG_EXPAND);
typedef void (*glVertexArrayMultiTexCoordOffsetEXT_PTR)(glVertexArrayMultiTexCoordOffsetEXT_ARG_EXPAND);
#define glVertexArrayNormalOffsetEXT_INDEX 2341
#define glVertexArrayNormalOffsetEXT_RETURN void
#define glVertexArrayNormalOffsetEXT_ARG_NAMES vaobj, buffer, type, stride, offset
#define glVertexArrayNormalOffsetEXT_ARG_EXPAND GLuint vaobj, GLuint buffer, GLenum type, GLsizei stride, GLintptr offset
#define glVertexArrayNormalOffsetEXT_PACKED PACKED_glVertexArrayNormalOffsetEXT
#define glVertexArrayNormalOffsetEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexArrayNormalOffsetEXT_NOT_VOID_WRAP(...) {}
#define pack_glVertexArrayNormalOffsetEXT(_vaobj, _buffer, _type, _stride, _offset) ({ \
    glVertexArrayNormalOffsetEXT_PACKED *packed_data = malloc(sizeof(glVertexArrayNormalOffsetEXT_PACKED)); \
    packed_data->index = glVertexArrayNormalOffsetEXT_INDEX; \
    packed_data->args.vaobj = (GLuint)_vaobj; \
    packed_data->args.buffer = (GLuint)_buffer; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.stride = (GLsizei)_stride; \
    packed_data->args.offset = (GLintptr)_offset; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexArrayNormalOffsetEXT(packed, ret_v) do { \
    PACKED_glVertexArrayNormalOffsetEXT *unpacked = (PACKED_glVertexArrayNormalOffsetEXT *)packed; \
    ARGS_glVertexArrayNormalOffsetEXT *args = (ARGS_glVertexArrayNormalOffsetEXT *)&unpacked->args; \
    glVertexArrayNormalOffsetEXT(args->vaobj, args->buffer, args->type, args->stride, args->offset);; \
} while(0)
void glVertexArrayNormalOffsetEXT(glVertexArrayNormalOffsetEXT_ARG_EXPAND);
typedef void (*glVertexArrayNormalOffsetEXT_PTR)(glVertexArrayNormalOffsetEXT_ARG_EXPAND);
#define glVertexArrayParameteriAPPLE_INDEX 2342
#define glVertexArrayParameteriAPPLE_RETURN void
#define glVertexArrayParameteriAPPLE_ARG_NAMES pname, param
#define glVertexArrayParameteriAPPLE_ARG_EXPAND GLenum pname, GLint param
#define glVertexArrayParameteriAPPLE_PACKED PACKED_glVertexArrayParameteriAPPLE
#define glVertexArrayParameteriAPPLE_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexArrayParameteriAPPLE_NOT_VOID_WRAP(...) {}
#define pack_glVertexArrayParameteriAPPLE(_pname, _param) ({ \
    glVertexArrayParameteriAPPLE_PACKED *packed_data = malloc(sizeof(glVertexArrayParameteriAPPLE_PACKED)); \
    packed_data->index = glVertexArrayParameteriAPPLE_INDEX; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.param = (GLint)_param; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexArrayParameteriAPPLE(packed, ret_v) do { \
    PACKED_glVertexArrayParameteriAPPLE *unpacked = (PACKED_glVertexArrayParameteriAPPLE *)packed; \
    ARGS_glVertexArrayParameteriAPPLE *args = (ARGS_glVertexArrayParameteriAPPLE *)&unpacked->args; \
    glVertexArrayParameteriAPPLE(args->pname, args->param);; \
} while(0)
void glVertexArrayParameteriAPPLE(glVertexArrayParameteriAPPLE_ARG_EXPAND);
typedef void (*glVertexArrayParameteriAPPLE_PTR)(glVertexArrayParameteriAPPLE_ARG_EXPAND);
#define glVertexArrayRangeAPPLE_INDEX 2343
#define glVertexArrayRangeAPPLE_RETURN void
#define glVertexArrayRangeAPPLE_ARG_NAMES length, pointer
#define glVertexArrayRangeAPPLE_ARG_EXPAND GLsizei length, GLvoid * pointer
#define glVertexArrayRangeAPPLE_PACKED PACKED_glVertexArrayRangeAPPLE
#define glVertexArrayRangeAPPLE_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexArrayRangeAPPLE_NOT_VOID_WRAP(...) {}
#define pack_glVertexArrayRangeAPPLE(_length, _pointer) ({ \
    glVertexArrayRangeAPPLE_PACKED *packed_data = malloc(sizeof(glVertexArrayRangeAPPLE_PACKED)); \
    packed_data->index = glVertexArrayRangeAPPLE_INDEX; \
    packed_data->args.length = (GLsizei)_length; \
    packed_data->args.pointer = (GLvoid *)_pointer; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexArrayRangeAPPLE(packed, ret_v) do { \
    PACKED_glVertexArrayRangeAPPLE *unpacked = (PACKED_glVertexArrayRangeAPPLE *)packed; \
    ARGS_glVertexArrayRangeAPPLE *args = (ARGS_glVertexArrayRangeAPPLE *)&unpacked->args; \
    glVertexArrayRangeAPPLE(args->length, args->pointer);; \
} while(0)
void glVertexArrayRangeAPPLE(glVertexArrayRangeAPPLE_ARG_EXPAND);
typedef void (*glVertexArrayRangeAPPLE_PTR)(glVertexArrayRangeAPPLE_ARG_EXPAND);
#define glVertexArrayRangeNV_INDEX 2344
#define glVertexArrayRangeNV_RETURN void
#define glVertexArrayRangeNV_ARG_NAMES length, pointer
#define glVertexArrayRangeNV_ARG_EXPAND GLsizei length, const GLvoid * pointer
#define glVertexArrayRangeNV_PACKED PACKED_glVertexArrayRangeNV
#define glVertexArrayRangeNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexArrayRangeNV_NOT_VOID_WRAP(...) {}
#define pack_glVertexArrayRangeNV(_length, _pointer) ({ \
    glVertexArrayRangeNV_PACKED *packed_data = malloc(sizeof(glVertexArrayRangeNV_PACKED)); \
    packed_data->index = glVertexArrayRangeNV_INDEX; \
    packed_data->args.length = (GLsizei)_length; \
    packed_data->args.pointer = (GLvoid *)_pointer; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexArrayRangeNV(packed, ret_v) do { \
    PACKED_glVertexArrayRangeNV *unpacked = (PACKED_glVertexArrayRangeNV *)packed; \
    ARGS_glVertexArrayRangeNV *args = (ARGS_glVertexArrayRangeNV *)&unpacked->args; \
    glVertexArrayRangeNV(args->length, args->pointer);; \
} while(0)
void glVertexArrayRangeNV(glVertexArrayRangeNV_ARG_EXPAND);
typedef void (*glVertexArrayRangeNV_PTR)(glVertexArrayRangeNV_ARG_EXPAND);
#define glVertexArraySecondaryColorOffsetEXT_INDEX 2345
#define glVertexArraySecondaryColorOffsetEXT_RETURN void
#define glVertexArraySecondaryColorOffsetEXT_ARG_NAMES vaobj, buffer, size, type, stride, offset
#define glVertexArraySecondaryColorOffsetEXT_ARG_EXPAND GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset
#define glVertexArraySecondaryColorOffsetEXT_PACKED PACKED_glVertexArraySecondaryColorOffsetEXT
#define glVertexArraySecondaryColorOffsetEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexArraySecondaryColorOffsetEXT_NOT_VOID_WRAP(...) {}
#define pack_glVertexArraySecondaryColorOffsetEXT(_vaobj, _buffer, _size, _type, _stride, _offset) ({ \
    glVertexArraySecondaryColorOffsetEXT_PACKED *packed_data = malloc(sizeof(glVertexArraySecondaryColorOffsetEXT_PACKED)); \
    packed_data->index = glVertexArraySecondaryColorOffsetEXT_INDEX; \
    packed_data->args.vaobj = (GLuint)_vaobj; \
    packed_data->args.buffer = (GLuint)_buffer; \
    packed_data->args.size = (GLint)_size; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.stride = (GLsizei)_stride; \
    packed_data->args.offset = (GLintptr)_offset; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexArraySecondaryColorOffsetEXT(packed, ret_v) do { \
    PACKED_glVertexArraySecondaryColorOffsetEXT *unpacked = (PACKED_glVertexArraySecondaryColorOffsetEXT *)packed; \
    ARGS_glVertexArraySecondaryColorOffsetEXT *args = (ARGS_glVertexArraySecondaryColorOffsetEXT *)&unpacked->args; \
    glVertexArraySecondaryColorOffsetEXT(args->vaobj, args->buffer, args->size, args->type, args->stride, args->offset);; \
} while(0)
void glVertexArraySecondaryColorOffsetEXT(glVertexArraySecondaryColorOffsetEXT_ARG_EXPAND);
typedef void (*glVertexArraySecondaryColorOffsetEXT_PTR)(glVertexArraySecondaryColorOffsetEXT_ARG_EXPAND);
#define glVertexArrayTexCoordOffsetEXT_INDEX 2346
#define glVertexArrayTexCoordOffsetEXT_RETURN void
#define glVertexArrayTexCoordOffsetEXT_ARG_NAMES vaobj, buffer, size, type, stride, offset
#define glVertexArrayTexCoordOffsetEXT_ARG_EXPAND GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset
#define glVertexArrayTexCoordOffsetEXT_PACKED PACKED_glVertexArrayTexCoordOffsetEXT
#define glVertexArrayTexCoordOffsetEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexArrayTexCoordOffsetEXT_NOT_VOID_WRAP(...) {}
#define pack_glVertexArrayTexCoordOffsetEXT(_vaobj, _buffer, _size, _type, _stride, _offset) ({ \
    glVertexArrayTexCoordOffsetEXT_PACKED *packed_data = malloc(sizeof(glVertexArrayTexCoordOffsetEXT_PACKED)); \
    packed_data->index = glVertexArrayTexCoordOffsetEXT_INDEX; \
    packed_data->args.vaobj = (GLuint)_vaobj; \
    packed_data->args.buffer = (GLuint)_buffer; \
    packed_data->args.size = (GLint)_size; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.stride = (GLsizei)_stride; \
    packed_data->args.offset = (GLintptr)_offset; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexArrayTexCoordOffsetEXT(packed, ret_v) do { \
    PACKED_glVertexArrayTexCoordOffsetEXT *unpacked = (PACKED_glVertexArrayTexCoordOffsetEXT *)packed; \
    ARGS_glVertexArrayTexCoordOffsetEXT *args = (ARGS_glVertexArrayTexCoordOffsetEXT *)&unpacked->args; \
    glVertexArrayTexCoordOffsetEXT(args->vaobj, args->buffer, args->size, args->type, args->stride, args->offset);; \
} while(0)
void glVertexArrayTexCoordOffsetEXT(glVertexArrayTexCoordOffsetEXT_ARG_EXPAND);
typedef void (*glVertexArrayTexCoordOffsetEXT_PTR)(glVertexArrayTexCoordOffsetEXT_ARG_EXPAND);
#define glVertexArrayVertexAttribBindingEXT_INDEX 2347
#define glVertexArrayVertexAttribBindingEXT_RETURN void
#define glVertexArrayVertexAttribBindingEXT_ARG_NAMES vaobj, attribindex, bindingindex
#define glVertexArrayVertexAttribBindingEXT_ARG_EXPAND GLuint vaobj, GLuint attribindex, GLuint bindingindex
#define glVertexArrayVertexAttribBindingEXT_PACKED PACKED_glVertexArrayVertexAttribBindingEXT
#define glVertexArrayVertexAttribBindingEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexArrayVertexAttribBindingEXT_NOT_VOID_WRAP(...) {}
#define pack_glVertexArrayVertexAttribBindingEXT(_vaobj, _attribindex, _bindingindex) ({ \
    glVertexArrayVertexAttribBindingEXT_PACKED *packed_data = malloc(sizeof(glVertexArrayVertexAttribBindingEXT_PACKED)); \
    packed_data->index = glVertexArrayVertexAttribBindingEXT_INDEX; \
    packed_data->args.vaobj = (GLuint)_vaobj; \
    packed_data->args.attribindex = (GLuint)_attribindex; \
    packed_data->args.bindingindex = (GLuint)_bindingindex; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexArrayVertexAttribBindingEXT(packed, ret_v) do { \
    PACKED_glVertexArrayVertexAttribBindingEXT *unpacked = (PACKED_glVertexArrayVertexAttribBindingEXT *)packed; \
    ARGS_glVertexArrayVertexAttribBindingEXT *args = (ARGS_glVertexArrayVertexAttribBindingEXT *)&unpacked->args; \
    glVertexArrayVertexAttribBindingEXT(args->vaobj, args->attribindex, args->bindingindex);; \
} while(0)
void glVertexArrayVertexAttribBindingEXT(glVertexArrayVertexAttribBindingEXT_ARG_EXPAND);
typedef void (*glVertexArrayVertexAttribBindingEXT_PTR)(glVertexArrayVertexAttribBindingEXT_ARG_EXPAND);
#define glVertexArrayVertexAttribFormatEXT_INDEX 2348
#define glVertexArrayVertexAttribFormatEXT_RETURN void
#define glVertexArrayVertexAttribFormatEXT_ARG_NAMES vaobj, attribindex, size, type, normalized, relativeoffset
#define glVertexArrayVertexAttribFormatEXT_ARG_EXPAND GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset
#define glVertexArrayVertexAttribFormatEXT_PACKED PACKED_glVertexArrayVertexAttribFormatEXT
#define glVertexArrayVertexAttribFormatEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexArrayVertexAttribFormatEXT_NOT_VOID_WRAP(...) {}
#define pack_glVertexArrayVertexAttribFormatEXT(_vaobj, _attribindex, _size, _type, _normalized, _relativeoffset) ({ \
    glVertexArrayVertexAttribFormatEXT_PACKED *packed_data = malloc(sizeof(glVertexArrayVertexAttribFormatEXT_PACKED)); \
    packed_data->index = glVertexArrayVertexAttribFormatEXT_INDEX; \
    packed_data->args.vaobj = (GLuint)_vaobj; \
    packed_data->args.attribindex = (GLuint)_attribindex; \
    packed_data->args.size = (GLint)_size; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.normalized = (GLboolean)_normalized; \
    packed_data->args.relativeoffset = (GLuint)_relativeoffset; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexArrayVertexAttribFormatEXT(packed, ret_v) do { \
    PACKED_glVertexArrayVertexAttribFormatEXT *unpacked = (PACKED_glVertexArrayVertexAttribFormatEXT *)packed; \
    ARGS_glVertexArrayVertexAttribFormatEXT *args = (ARGS_glVertexArrayVertexAttribFormatEXT *)&unpacked->args; \
    glVertexArrayVertexAttribFormatEXT(args->vaobj, args->attribindex, args->size, args->type, args->normalized, args->relativeoffset);; \
} while(0)
void glVertexArrayVertexAttribFormatEXT(glVertexArrayVertexAttribFormatEXT_ARG_EXPAND);
typedef void (*glVertexArrayVertexAttribFormatEXT_PTR)(glVertexArrayVertexAttribFormatEXT_ARG_EXPAND);
#define glVertexArrayVertexAttribIFormatEXT_INDEX 2349
#define glVertexArrayVertexAttribIFormatEXT_RETURN void
#define glVertexArrayVertexAttribIFormatEXT_ARG_NAMES vaobj, attribindex, size, type, relativeoffset
#define glVertexArrayVertexAttribIFormatEXT_ARG_EXPAND GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset
#define glVertexArrayVertexAttribIFormatEXT_PACKED PACKED_glVertexArrayVertexAttribIFormatEXT
#define glVertexArrayVertexAttribIFormatEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexArrayVertexAttribIFormatEXT_NOT_VOID_WRAP(...) {}
#define pack_glVertexArrayVertexAttribIFormatEXT(_vaobj, _attribindex, _size, _type, _relativeoffset) ({ \
    glVertexArrayVertexAttribIFormatEXT_PACKED *packed_data = malloc(sizeof(glVertexArrayVertexAttribIFormatEXT_PACKED)); \
    packed_data->index = glVertexArrayVertexAttribIFormatEXT_INDEX; \
    packed_data->args.vaobj = (GLuint)_vaobj; \
    packed_data->args.attribindex = (GLuint)_attribindex; \
    packed_data->args.size = (GLint)_size; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.relativeoffset = (GLuint)_relativeoffset; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexArrayVertexAttribIFormatEXT(packed, ret_v) do { \
    PACKED_glVertexArrayVertexAttribIFormatEXT *unpacked = (PACKED_glVertexArrayVertexAttribIFormatEXT *)packed; \
    ARGS_glVertexArrayVertexAttribIFormatEXT *args = (ARGS_glVertexArrayVertexAttribIFormatEXT *)&unpacked->args; \
    glVertexArrayVertexAttribIFormatEXT(args->vaobj, args->attribindex, args->size, args->type, args->relativeoffset);; \
} while(0)
void glVertexArrayVertexAttribIFormatEXT(glVertexArrayVertexAttribIFormatEXT_ARG_EXPAND);
typedef void (*glVertexArrayVertexAttribIFormatEXT_PTR)(glVertexArrayVertexAttribIFormatEXT_ARG_EXPAND);
#define glVertexArrayVertexAttribIOffsetEXT_INDEX 2350
#define glVertexArrayVertexAttribIOffsetEXT_RETURN void
#define glVertexArrayVertexAttribIOffsetEXT_ARG_NAMES vaobj, buffer, index, size, type, stride, offset
#define glVertexArrayVertexAttribIOffsetEXT_ARG_EXPAND GLuint vaobj, GLuint buffer, GLuint index, GLint size, GLenum type, GLsizei stride, GLintptr offset
#define glVertexArrayVertexAttribIOffsetEXT_PACKED PACKED_glVertexArrayVertexAttribIOffsetEXT
#define glVertexArrayVertexAttribIOffsetEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexArrayVertexAttribIOffsetEXT_NOT_VOID_WRAP(...) {}
#define pack_glVertexArrayVertexAttribIOffsetEXT(_vaobj, _buffer, _index, _size, _type, _stride, _offset) ({ \
    glVertexArrayVertexAttribIOffsetEXT_PACKED *packed_data = malloc(sizeof(glVertexArrayVertexAttribIOffsetEXT_PACKED)); \
    packed_data->index = glVertexArrayVertexAttribIOffsetEXT_INDEX; \
    packed_data->args.vaobj = (GLuint)_vaobj; \
    packed_data->args.buffer = (GLuint)_buffer; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.size = (GLint)_size; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.stride = (GLsizei)_stride; \
    packed_data->args.offset = (GLintptr)_offset; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexArrayVertexAttribIOffsetEXT(packed, ret_v) do { \
    PACKED_glVertexArrayVertexAttribIOffsetEXT *unpacked = (PACKED_glVertexArrayVertexAttribIOffsetEXT *)packed; \
    ARGS_glVertexArrayVertexAttribIOffsetEXT *args = (ARGS_glVertexArrayVertexAttribIOffsetEXT *)&unpacked->args; \
    glVertexArrayVertexAttribIOffsetEXT(args->vaobj, args->buffer, args->index, args->size, args->type, args->stride, args->offset);; \
} while(0)
void glVertexArrayVertexAttribIOffsetEXT(glVertexArrayVertexAttribIOffsetEXT_ARG_EXPAND);
typedef void (*glVertexArrayVertexAttribIOffsetEXT_PTR)(glVertexArrayVertexAttribIOffsetEXT_ARG_EXPAND);
#define glVertexArrayVertexAttribLFormatEXT_INDEX 2351
#define glVertexArrayVertexAttribLFormatEXT_RETURN void
#define glVertexArrayVertexAttribLFormatEXT_ARG_NAMES vaobj, attribindex, size, type, relativeoffset
#define glVertexArrayVertexAttribLFormatEXT_ARG_EXPAND GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset
#define glVertexArrayVertexAttribLFormatEXT_PACKED PACKED_glVertexArrayVertexAttribLFormatEXT
#define glVertexArrayVertexAttribLFormatEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexArrayVertexAttribLFormatEXT_NOT_VOID_WRAP(...) {}
#define pack_glVertexArrayVertexAttribLFormatEXT(_vaobj, _attribindex, _size, _type, _relativeoffset) ({ \
    glVertexArrayVertexAttribLFormatEXT_PACKED *packed_data = malloc(sizeof(glVertexArrayVertexAttribLFormatEXT_PACKED)); \
    packed_data->index = glVertexArrayVertexAttribLFormatEXT_INDEX; \
    packed_data->args.vaobj = (GLuint)_vaobj; \
    packed_data->args.attribindex = (GLuint)_attribindex; \
    packed_data->args.size = (GLint)_size; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.relativeoffset = (GLuint)_relativeoffset; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexArrayVertexAttribLFormatEXT(packed, ret_v) do { \
    PACKED_glVertexArrayVertexAttribLFormatEXT *unpacked = (PACKED_glVertexArrayVertexAttribLFormatEXT *)packed; \
    ARGS_glVertexArrayVertexAttribLFormatEXT *args = (ARGS_glVertexArrayVertexAttribLFormatEXT *)&unpacked->args; \
    glVertexArrayVertexAttribLFormatEXT(args->vaobj, args->attribindex, args->size, args->type, args->relativeoffset);; \
} while(0)
void glVertexArrayVertexAttribLFormatEXT(glVertexArrayVertexAttribLFormatEXT_ARG_EXPAND);
typedef void (*glVertexArrayVertexAttribLFormatEXT_PTR)(glVertexArrayVertexAttribLFormatEXT_ARG_EXPAND);
#define glVertexArrayVertexAttribLOffsetEXT_INDEX 2352
#define glVertexArrayVertexAttribLOffsetEXT_RETURN void
#define glVertexArrayVertexAttribLOffsetEXT_ARG_NAMES vaobj, buffer, index, size, type, stride, offset
#define glVertexArrayVertexAttribLOffsetEXT_ARG_EXPAND GLuint vaobj, GLuint buffer, GLuint index, GLint size, GLenum type, GLsizei stride, GLintptr offset
#define glVertexArrayVertexAttribLOffsetEXT_PACKED PACKED_glVertexArrayVertexAttribLOffsetEXT
#define glVertexArrayVertexAttribLOffsetEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexArrayVertexAttribLOffsetEXT_NOT_VOID_WRAP(...) {}
#define pack_glVertexArrayVertexAttribLOffsetEXT(_vaobj, _buffer, _index, _size, _type, _stride, _offset) ({ \
    glVertexArrayVertexAttribLOffsetEXT_PACKED *packed_data = malloc(sizeof(glVertexArrayVertexAttribLOffsetEXT_PACKED)); \
    packed_data->index = glVertexArrayVertexAttribLOffsetEXT_INDEX; \
    packed_data->args.vaobj = (GLuint)_vaobj; \
    packed_data->args.buffer = (GLuint)_buffer; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.size = (GLint)_size; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.stride = (GLsizei)_stride; \
    packed_data->args.offset = (GLintptr)_offset; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexArrayVertexAttribLOffsetEXT(packed, ret_v) do { \
    PACKED_glVertexArrayVertexAttribLOffsetEXT *unpacked = (PACKED_glVertexArrayVertexAttribLOffsetEXT *)packed; \
    ARGS_glVertexArrayVertexAttribLOffsetEXT *args = (ARGS_glVertexArrayVertexAttribLOffsetEXT *)&unpacked->args; \
    glVertexArrayVertexAttribLOffsetEXT(args->vaobj, args->buffer, args->index, args->size, args->type, args->stride, args->offset);; \
} while(0)
void glVertexArrayVertexAttribLOffsetEXT(glVertexArrayVertexAttribLOffsetEXT_ARG_EXPAND);
typedef void (*glVertexArrayVertexAttribLOffsetEXT_PTR)(glVertexArrayVertexAttribLOffsetEXT_ARG_EXPAND);
#define glVertexArrayVertexAttribOffsetEXT_INDEX 2353
#define glVertexArrayVertexAttribOffsetEXT_RETURN void
#define glVertexArrayVertexAttribOffsetEXT_ARG_NAMES vaobj, buffer, index, size, type, normalized, stride, offset
#define glVertexArrayVertexAttribOffsetEXT_ARG_EXPAND GLuint vaobj, GLuint buffer, GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, GLintptr offset
#define glVertexArrayVertexAttribOffsetEXT_PACKED PACKED_glVertexArrayVertexAttribOffsetEXT
#define glVertexArrayVertexAttribOffsetEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexArrayVertexAttribOffsetEXT_NOT_VOID_WRAP(...) {}
#define pack_glVertexArrayVertexAttribOffsetEXT(_vaobj, _buffer, _index, _size, _type, _normalized, _stride, _offset) ({ \
    glVertexArrayVertexAttribOffsetEXT_PACKED *packed_data = malloc(sizeof(glVertexArrayVertexAttribOffsetEXT_PACKED)); \
    packed_data->index = glVertexArrayVertexAttribOffsetEXT_INDEX; \
    packed_data->args.vaobj = (GLuint)_vaobj; \
    packed_data->args.buffer = (GLuint)_buffer; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.size = (GLint)_size; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.normalized = (GLboolean)_normalized; \
    packed_data->args.stride = (GLsizei)_stride; \
    packed_data->args.offset = (GLintptr)_offset; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexArrayVertexAttribOffsetEXT(packed, ret_v) do { \
    PACKED_glVertexArrayVertexAttribOffsetEXT *unpacked = (PACKED_glVertexArrayVertexAttribOffsetEXT *)packed; \
    ARGS_glVertexArrayVertexAttribOffsetEXT *args = (ARGS_glVertexArrayVertexAttribOffsetEXT *)&unpacked->args; \
    glVertexArrayVertexAttribOffsetEXT(args->vaobj, args->buffer, args->index, args->size, args->type, args->normalized, args->stride, args->offset);; \
} while(0)
void glVertexArrayVertexAttribOffsetEXT(glVertexArrayVertexAttribOffsetEXT_ARG_EXPAND);
typedef void (*glVertexArrayVertexAttribOffsetEXT_PTR)(glVertexArrayVertexAttribOffsetEXT_ARG_EXPAND);
#define glVertexArrayVertexBindingDivisorEXT_INDEX 2354
#define glVertexArrayVertexBindingDivisorEXT_RETURN void
#define glVertexArrayVertexBindingDivisorEXT_ARG_NAMES vaobj, bindingindex, divisor
#define glVertexArrayVertexBindingDivisorEXT_ARG_EXPAND GLuint vaobj, GLuint bindingindex, GLuint divisor
#define glVertexArrayVertexBindingDivisorEXT_PACKED PACKED_glVertexArrayVertexBindingDivisorEXT
#define glVertexArrayVertexBindingDivisorEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexArrayVertexBindingDivisorEXT_NOT_VOID_WRAP(...) {}
#define pack_glVertexArrayVertexBindingDivisorEXT(_vaobj, _bindingindex, _divisor) ({ \
    glVertexArrayVertexBindingDivisorEXT_PACKED *packed_data = malloc(sizeof(glVertexArrayVertexBindingDivisorEXT_PACKED)); \
    packed_data->index = glVertexArrayVertexBindingDivisorEXT_INDEX; \
    packed_data->args.vaobj = (GLuint)_vaobj; \
    packed_data->args.bindingindex = (GLuint)_bindingindex; \
    packed_data->args.divisor = (GLuint)_divisor; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexArrayVertexBindingDivisorEXT(packed, ret_v) do { \
    PACKED_glVertexArrayVertexBindingDivisorEXT *unpacked = (PACKED_glVertexArrayVertexBindingDivisorEXT *)packed; \
    ARGS_glVertexArrayVertexBindingDivisorEXT *args = (ARGS_glVertexArrayVertexBindingDivisorEXT *)&unpacked->args; \
    glVertexArrayVertexBindingDivisorEXT(args->vaobj, args->bindingindex, args->divisor);; \
} while(0)
void glVertexArrayVertexBindingDivisorEXT(glVertexArrayVertexBindingDivisorEXT_ARG_EXPAND);
typedef void (*glVertexArrayVertexBindingDivisorEXT_PTR)(glVertexArrayVertexBindingDivisorEXT_ARG_EXPAND);
#define glVertexArrayVertexOffsetEXT_INDEX 2355
#define glVertexArrayVertexOffsetEXT_RETURN void
#define glVertexArrayVertexOffsetEXT_ARG_NAMES vaobj, buffer, size, type, stride, offset
#define glVertexArrayVertexOffsetEXT_ARG_EXPAND GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset
#define glVertexArrayVertexOffsetEXT_PACKED PACKED_glVertexArrayVertexOffsetEXT
#define glVertexArrayVertexOffsetEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexArrayVertexOffsetEXT_NOT_VOID_WRAP(...) {}
#define pack_glVertexArrayVertexOffsetEXT(_vaobj, _buffer, _size, _type, _stride, _offset) ({ \
    glVertexArrayVertexOffsetEXT_PACKED *packed_data = malloc(sizeof(glVertexArrayVertexOffsetEXT_PACKED)); \
    packed_data->index = glVertexArrayVertexOffsetEXT_INDEX; \
    packed_data->args.vaobj = (GLuint)_vaobj; \
    packed_data->args.buffer = (GLuint)_buffer; \
    packed_data->args.size = (GLint)_size; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.stride = (GLsizei)_stride; \
    packed_data->args.offset = (GLintptr)_offset; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexArrayVertexOffsetEXT(packed, ret_v) do { \
    PACKED_glVertexArrayVertexOffsetEXT *unpacked = (PACKED_glVertexArrayVertexOffsetEXT *)packed; \
    ARGS_glVertexArrayVertexOffsetEXT *args = (ARGS_glVertexArrayVertexOffsetEXT *)&unpacked->args; \
    glVertexArrayVertexOffsetEXT(args->vaobj, args->buffer, args->size, args->type, args->stride, args->offset);; \
} while(0)
void glVertexArrayVertexOffsetEXT(glVertexArrayVertexOffsetEXT_ARG_EXPAND);
typedef void (*glVertexArrayVertexOffsetEXT_PTR)(glVertexArrayVertexOffsetEXT_ARG_EXPAND);
#define glVertexAttrib1d_INDEX 2356
#define glVertexAttrib1d_RETURN void
#define glVertexAttrib1d_ARG_NAMES index, x
#define glVertexAttrib1d_ARG_EXPAND GLuint index, GLdouble x
#define glVertexAttrib1d_PACKED PACKED_glVertexAttrib1d
#define glVertexAttrib1d_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttrib1d_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttrib1d(_index, _x) ({ \
    glVertexAttrib1d_PACKED *packed_data = malloc(sizeof(glVertexAttrib1d_PACKED)); \
    packed_data->index = glVertexAttrib1d_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.x = (GLdouble)_x; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttrib1d(packed, ret_v) do { \
    PACKED_glVertexAttrib1d *unpacked = (PACKED_glVertexAttrib1d *)packed; \
    ARGS_glVertexAttrib1d *args = (ARGS_glVertexAttrib1d *)&unpacked->args; \
    glVertexAttrib1d(args->index, args->x);; \
} while(0)
void glVertexAttrib1d(glVertexAttrib1d_ARG_EXPAND);
typedef void (*glVertexAttrib1d_PTR)(glVertexAttrib1d_ARG_EXPAND);
#define glVertexAttrib1dARB_INDEX 2357
#define glVertexAttrib1dARB_RETURN void
#define glVertexAttrib1dARB_ARG_NAMES index, x
#define glVertexAttrib1dARB_ARG_EXPAND GLuint index, GLdouble x
#define glVertexAttrib1dARB_PACKED PACKED_glVertexAttrib1dARB
#define glVertexAttrib1dARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttrib1dARB_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttrib1dARB(_index, _x) ({ \
    glVertexAttrib1dARB_PACKED *packed_data = malloc(sizeof(glVertexAttrib1dARB_PACKED)); \
    packed_data->index = glVertexAttrib1dARB_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.x = (GLdouble)_x; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttrib1dARB(packed, ret_v) do { \
    PACKED_glVertexAttrib1dARB *unpacked = (PACKED_glVertexAttrib1dARB *)packed; \
    ARGS_glVertexAttrib1dARB *args = (ARGS_glVertexAttrib1dARB *)&unpacked->args; \
    glVertexAttrib1dARB(args->index, args->x);; \
} while(0)
void glVertexAttrib1dARB(glVertexAttrib1dARB_ARG_EXPAND);
typedef void (*glVertexAttrib1dARB_PTR)(glVertexAttrib1dARB_ARG_EXPAND);
#define glVertexAttrib1dNV_INDEX 2358
#define glVertexAttrib1dNV_RETURN void
#define glVertexAttrib1dNV_ARG_NAMES index, x
#define glVertexAttrib1dNV_ARG_EXPAND GLuint index, GLdouble x
#define glVertexAttrib1dNV_PACKED PACKED_glVertexAttrib1dNV
#define glVertexAttrib1dNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttrib1dNV_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttrib1dNV(_index, _x) ({ \
    glVertexAttrib1dNV_PACKED *packed_data = malloc(sizeof(glVertexAttrib1dNV_PACKED)); \
    packed_data->index = glVertexAttrib1dNV_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.x = (GLdouble)_x; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttrib1dNV(packed, ret_v) do { \
    PACKED_glVertexAttrib1dNV *unpacked = (PACKED_glVertexAttrib1dNV *)packed; \
    ARGS_glVertexAttrib1dNV *args = (ARGS_glVertexAttrib1dNV *)&unpacked->args; \
    glVertexAttrib1dNV(args->index, args->x);; \
} while(0)
void glVertexAttrib1dNV(glVertexAttrib1dNV_ARG_EXPAND);
typedef void (*glVertexAttrib1dNV_PTR)(glVertexAttrib1dNV_ARG_EXPAND);
#define glVertexAttrib1dv_INDEX 2359
#define glVertexAttrib1dv_RETURN void
#define glVertexAttrib1dv_ARG_NAMES index, v
#define glVertexAttrib1dv_ARG_EXPAND GLuint index, const GLdouble * v
#define glVertexAttrib1dv_PACKED PACKED_glVertexAttrib1dv
#define glVertexAttrib1dv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttrib1dv_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttrib1dv(_index, _v) ({ \
    glVertexAttrib1dv_PACKED *packed_data = malloc(sizeof(glVertexAttrib1dv_PACKED)); \
    packed_data->index = glVertexAttrib1dv_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.v = (GLdouble *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttrib1dv(packed, ret_v) do { \
    PACKED_glVertexAttrib1dv *unpacked = (PACKED_glVertexAttrib1dv *)packed; \
    ARGS_glVertexAttrib1dv *args = (ARGS_glVertexAttrib1dv *)&unpacked->args; \
    glVertexAttrib1dv(args->index, args->v);; \
} while(0)
void glVertexAttrib1dv(glVertexAttrib1dv_ARG_EXPAND);
typedef void (*glVertexAttrib1dv_PTR)(glVertexAttrib1dv_ARG_EXPAND);
#define glVertexAttrib1dvARB_INDEX 2360
#define glVertexAttrib1dvARB_RETURN void
#define glVertexAttrib1dvARB_ARG_NAMES index, v
#define glVertexAttrib1dvARB_ARG_EXPAND GLuint index, const GLdouble * v
#define glVertexAttrib1dvARB_PACKED PACKED_glVertexAttrib1dvARB
#define glVertexAttrib1dvARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttrib1dvARB_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttrib1dvARB(_index, _v) ({ \
    glVertexAttrib1dvARB_PACKED *packed_data = malloc(sizeof(glVertexAttrib1dvARB_PACKED)); \
    packed_data->index = glVertexAttrib1dvARB_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.v = (GLdouble *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttrib1dvARB(packed, ret_v) do { \
    PACKED_glVertexAttrib1dvARB *unpacked = (PACKED_glVertexAttrib1dvARB *)packed; \
    ARGS_glVertexAttrib1dvARB *args = (ARGS_glVertexAttrib1dvARB *)&unpacked->args; \
    glVertexAttrib1dvARB(args->index, args->v);; \
} while(0)
void glVertexAttrib1dvARB(glVertexAttrib1dvARB_ARG_EXPAND);
typedef void (*glVertexAttrib1dvARB_PTR)(glVertexAttrib1dvARB_ARG_EXPAND);
#define glVertexAttrib1dvNV_INDEX 2361
#define glVertexAttrib1dvNV_RETURN void
#define glVertexAttrib1dvNV_ARG_NAMES index, v
#define glVertexAttrib1dvNV_ARG_EXPAND GLuint index, const GLdouble * v
#define glVertexAttrib1dvNV_PACKED PACKED_glVertexAttrib1dvNV
#define glVertexAttrib1dvNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttrib1dvNV_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttrib1dvNV(_index, _v) ({ \
    glVertexAttrib1dvNV_PACKED *packed_data = malloc(sizeof(glVertexAttrib1dvNV_PACKED)); \
    packed_data->index = glVertexAttrib1dvNV_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.v = (GLdouble *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttrib1dvNV(packed, ret_v) do { \
    PACKED_glVertexAttrib1dvNV *unpacked = (PACKED_glVertexAttrib1dvNV *)packed; \
    ARGS_glVertexAttrib1dvNV *args = (ARGS_glVertexAttrib1dvNV *)&unpacked->args; \
    glVertexAttrib1dvNV(args->index, args->v);; \
} while(0)
void glVertexAttrib1dvNV(glVertexAttrib1dvNV_ARG_EXPAND);
typedef void (*glVertexAttrib1dvNV_PTR)(glVertexAttrib1dvNV_ARG_EXPAND);
#define glVertexAttrib1f_INDEX 2362
#define glVertexAttrib1f_RETURN void
#define glVertexAttrib1f_ARG_NAMES index, x
#define glVertexAttrib1f_ARG_EXPAND GLuint index, GLfloat x
#define glVertexAttrib1f_PACKED PACKED_glVertexAttrib1f
#define glVertexAttrib1f_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttrib1f_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttrib1f(_index, _x) ({ \
    glVertexAttrib1f_PACKED *packed_data = malloc(sizeof(glVertexAttrib1f_PACKED)); \
    packed_data->index = glVertexAttrib1f_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.x = (GLfloat)_x; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttrib1f(packed, ret_v) do { \
    PACKED_glVertexAttrib1f *unpacked = (PACKED_glVertexAttrib1f *)packed; \
    ARGS_glVertexAttrib1f *args = (ARGS_glVertexAttrib1f *)&unpacked->args; \
    glVertexAttrib1f(args->index, args->x);; \
} while(0)
void glVertexAttrib1f(glVertexAttrib1f_ARG_EXPAND);
typedef void (*glVertexAttrib1f_PTR)(glVertexAttrib1f_ARG_EXPAND);
#define glVertexAttrib1fARB_INDEX 2363
#define glVertexAttrib1fARB_RETURN void
#define glVertexAttrib1fARB_ARG_NAMES index, x
#define glVertexAttrib1fARB_ARG_EXPAND GLuint index, GLfloat x
#define glVertexAttrib1fARB_PACKED PACKED_glVertexAttrib1fARB
#define glVertexAttrib1fARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttrib1fARB_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttrib1fARB(_index, _x) ({ \
    glVertexAttrib1fARB_PACKED *packed_data = malloc(sizeof(glVertexAttrib1fARB_PACKED)); \
    packed_data->index = glVertexAttrib1fARB_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.x = (GLfloat)_x; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttrib1fARB(packed, ret_v) do { \
    PACKED_glVertexAttrib1fARB *unpacked = (PACKED_glVertexAttrib1fARB *)packed; \
    ARGS_glVertexAttrib1fARB *args = (ARGS_glVertexAttrib1fARB *)&unpacked->args; \
    glVertexAttrib1fARB(args->index, args->x);; \
} while(0)
void glVertexAttrib1fARB(glVertexAttrib1fARB_ARG_EXPAND);
typedef void (*glVertexAttrib1fARB_PTR)(glVertexAttrib1fARB_ARG_EXPAND);
#define glVertexAttrib1fNV_INDEX 2364
#define glVertexAttrib1fNV_RETURN void
#define glVertexAttrib1fNV_ARG_NAMES index, x
#define glVertexAttrib1fNV_ARG_EXPAND GLuint index, GLfloat x
#define glVertexAttrib1fNV_PACKED PACKED_glVertexAttrib1fNV
#define glVertexAttrib1fNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttrib1fNV_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttrib1fNV(_index, _x) ({ \
    glVertexAttrib1fNV_PACKED *packed_data = malloc(sizeof(glVertexAttrib1fNV_PACKED)); \
    packed_data->index = glVertexAttrib1fNV_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.x = (GLfloat)_x; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttrib1fNV(packed, ret_v) do { \
    PACKED_glVertexAttrib1fNV *unpacked = (PACKED_glVertexAttrib1fNV *)packed; \
    ARGS_glVertexAttrib1fNV *args = (ARGS_glVertexAttrib1fNV *)&unpacked->args; \
    glVertexAttrib1fNV(args->index, args->x);; \
} while(0)
void glVertexAttrib1fNV(glVertexAttrib1fNV_ARG_EXPAND);
typedef void (*glVertexAttrib1fNV_PTR)(glVertexAttrib1fNV_ARG_EXPAND);
#define glVertexAttrib1fv_INDEX 2365
#define glVertexAttrib1fv_RETURN void
#define glVertexAttrib1fv_ARG_NAMES index, v
#define glVertexAttrib1fv_ARG_EXPAND GLuint index, const GLfloat * v
#define glVertexAttrib1fv_PACKED PACKED_glVertexAttrib1fv
#define glVertexAttrib1fv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttrib1fv_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttrib1fv(_index, _v) ({ \
    glVertexAttrib1fv_PACKED *packed_data = malloc(sizeof(glVertexAttrib1fv_PACKED)); \
    packed_data->index = glVertexAttrib1fv_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.v = (GLfloat *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttrib1fv(packed, ret_v) do { \
    PACKED_glVertexAttrib1fv *unpacked = (PACKED_glVertexAttrib1fv *)packed; \
    ARGS_glVertexAttrib1fv *args = (ARGS_glVertexAttrib1fv *)&unpacked->args; \
    glVertexAttrib1fv(args->index, args->v);; \
} while(0)
void glVertexAttrib1fv(glVertexAttrib1fv_ARG_EXPAND);
typedef void (*glVertexAttrib1fv_PTR)(glVertexAttrib1fv_ARG_EXPAND);
#define glVertexAttrib1fvARB_INDEX 2366
#define glVertexAttrib1fvARB_RETURN void
#define glVertexAttrib1fvARB_ARG_NAMES index, v
#define glVertexAttrib1fvARB_ARG_EXPAND GLuint index, const GLfloat * v
#define glVertexAttrib1fvARB_PACKED PACKED_glVertexAttrib1fvARB
#define glVertexAttrib1fvARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttrib1fvARB_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttrib1fvARB(_index, _v) ({ \
    glVertexAttrib1fvARB_PACKED *packed_data = malloc(sizeof(glVertexAttrib1fvARB_PACKED)); \
    packed_data->index = glVertexAttrib1fvARB_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.v = (GLfloat *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttrib1fvARB(packed, ret_v) do { \
    PACKED_glVertexAttrib1fvARB *unpacked = (PACKED_glVertexAttrib1fvARB *)packed; \
    ARGS_glVertexAttrib1fvARB *args = (ARGS_glVertexAttrib1fvARB *)&unpacked->args; \
    glVertexAttrib1fvARB(args->index, args->v);; \
} while(0)
void glVertexAttrib1fvARB(glVertexAttrib1fvARB_ARG_EXPAND);
typedef void (*glVertexAttrib1fvARB_PTR)(glVertexAttrib1fvARB_ARG_EXPAND);
#define glVertexAttrib1fvNV_INDEX 2367
#define glVertexAttrib1fvNV_RETURN void
#define glVertexAttrib1fvNV_ARG_NAMES index, v
#define glVertexAttrib1fvNV_ARG_EXPAND GLuint index, const GLfloat * v
#define glVertexAttrib1fvNV_PACKED PACKED_glVertexAttrib1fvNV
#define glVertexAttrib1fvNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttrib1fvNV_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttrib1fvNV(_index, _v) ({ \
    glVertexAttrib1fvNV_PACKED *packed_data = malloc(sizeof(glVertexAttrib1fvNV_PACKED)); \
    packed_data->index = glVertexAttrib1fvNV_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.v = (GLfloat *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttrib1fvNV(packed, ret_v) do { \
    PACKED_glVertexAttrib1fvNV *unpacked = (PACKED_glVertexAttrib1fvNV *)packed; \
    ARGS_glVertexAttrib1fvNV *args = (ARGS_glVertexAttrib1fvNV *)&unpacked->args; \
    glVertexAttrib1fvNV(args->index, args->v);; \
} while(0)
void glVertexAttrib1fvNV(glVertexAttrib1fvNV_ARG_EXPAND);
typedef void (*glVertexAttrib1fvNV_PTR)(glVertexAttrib1fvNV_ARG_EXPAND);
#define glVertexAttrib1hNV_INDEX 2368
#define glVertexAttrib1hNV_RETURN void
#define glVertexAttrib1hNV_ARG_NAMES index, x
#define glVertexAttrib1hNV_ARG_EXPAND GLuint index, GLhalfNV x
#define glVertexAttrib1hNV_PACKED PACKED_glVertexAttrib1hNV
#define glVertexAttrib1hNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttrib1hNV_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttrib1hNV(_index, _x) ({ \
    glVertexAttrib1hNV_PACKED *packed_data = malloc(sizeof(glVertexAttrib1hNV_PACKED)); \
    packed_data->index = glVertexAttrib1hNV_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.x = (GLhalfNV)_x; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttrib1hNV(packed, ret_v) do { \
    PACKED_glVertexAttrib1hNV *unpacked = (PACKED_glVertexAttrib1hNV *)packed; \
    ARGS_glVertexAttrib1hNV *args = (ARGS_glVertexAttrib1hNV *)&unpacked->args; \
    glVertexAttrib1hNV(args->index, args->x);; \
} while(0)
void glVertexAttrib1hNV(glVertexAttrib1hNV_ARG_EXPAND);
typedef void (*glVertexAttrib1hNV_PTR)(glVertexAttrib1hNV_ARG_EXPAND);
#define glVertexAttrib1hvNV_INDEX 2369
#define glVertexAttrib1hvNV_RETURN void
#define glVertexAttrib1hvNV_ARG_NAMES index, v
#define glVertexAttrib1hvNV_ARG_EXPAND GLuint index, const GLhalfNV * v
#define glVertexAttrib1hvNV_PACKED PACKED_glVertexAttrib1hvNV
#define glVertexAttrib1hvNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttrib1hvNV_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttrib1hvNV(_index, _v) ({ \
    glVertexAttrib1hvNV_PACKED *packed_data = malloc(sizeof(glVertexAttrib1hvNV_PACKED)); \
    packed_data->index = glVertexAttrib1hvNV_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.v = (GLhalfNV *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttrib1hvNV(packed, ret_v) do { \
    PACKED_glVertexAttrib1hvNV *unpacked = (PACKED_glVertexAttrib1hvNV *)packed; \
    ARGS_glVertexAttrib1hvNV *args = (ARGS_glVertexAttrib1hvNV *)&unpacked->args; \
    glVertexAttrib1hvNV(args->index, args->v);; \
} while(0)
void glVertexAttrib1hvNV(glVertexAttrib1hvNV_ARG_EXPAND);
typedef void (*glVertexAttrib1hvNV_PTR)(glVertexAttrib1hvNV_ARG_EXPAND);
#define glVertexAttrib1s_INDEX 2370
#define glVertexAttrib1s_RETURN void
#define glVertexAttrib1s_ARG_NAMES index, x
#define glVertexAttrib1s_ARG_EXPAND GLuint index, GLshort x
#define glVertexAttrib1s_PACKED PACKED_glVertexAttrib1s
#define glVertexAttrib1s_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttrib1s_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttrib1s(_index, _x) ({ \
    glVertexAttrib1s_PACKED *packed_data = malloc(sizeof(glVertexAttrib1s_PACKED)); \
    packed_data->index = glVertexAttrib1s_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.x = (GLshort)_x; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttrib1s(packed, ret_v) do { \
    PACKED_glVertexAttrib1s *unpacked = (PACKED_glVertexAttrib1s *)packed; \
    ARGS_glVertexAttrib1s *args = (ARGS_glVertexAttrib1s *)&unpacked->args; \
    glVertexAttrib1s(args->index, args->x);; \
} while(0)
void glVertexAttrib1s(glVertexAttrib1s_ARG_EXPAND);
typedef void (*glVertexAttrib1s_PTR)(glVertexAttrib1s_ARG_EXPAND);
#define glVertexAttrib1sARB_INDEX 2371
#define glVertexAttrib1sARB_RETURN void
#define glVertexAttrib1sARB_ARG_NAMES index, x
#define glVertexAttrib1sARB_ARG_EXPAND GLuint index, GLshort x
#define glVertexAttrib1sARB_PACKED PACKED_glVertexAttrib1sARB
#define glVertexAttrib1sARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttrib1sARB_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttrib1sARB(_index, _x) ({ \
    glVertexAttrib1sARB_PACKED *packed_data = malloc(sizeof(glVertexAttrib1sARB_PACKED)); \
    packed_data->index = glVertexAttrib1sARB_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.x = (GLshort)_x; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttrib1sARB(packed, ret_v) do { \
    PACKED_glVertexAttrib1sARB *unpacked = (PACKED_glVertexAttrib1sARB *)packed; \
    ARGS_glVertexAttrib1sARB *args = (ARGS_glVertexAttrib1sARB *)&unpacked->args; \
    glVertexAttrib1sARB(args->index, args->x);; \
} while(0)
void glVertexAttrib1sARB(glVertexAttrib1sARB_ARG_EXPAND);
typedef void (*glVertexAttrib1sARB_PTR)(glVertexAttrib1sARB_ARG_EXPAND);
#define glVertexAttrib1sNV_INDEX 2372
#define glVertexAttrib1sNV_RETURN void
#define glVertexAttrib1sNV_ARG_NAMES index, x
#define glVertexAttrib1sNV_ARG_EXPAND GLuint index, GLshort x
#define glVertexAttrib1sNV_PACKED PACKED_glVertexAttrib1sNV
#define glVertexAttrib1sNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttrib1sNV_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttrib1sNV(_index, _x) ({ \
    glVertexAttrib1sNV_PACKED *packed_data = malloc(sizeof(glVertexAttrib1sNV_PACKED)); \
    packed_data->index = glVertexAttrib1sNV_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.x = (GLshort)_x; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttrib1sNV(packed, ret_v) do { \
    PACKED_glVertexAttrib1sNV *unpacked = (PACKED_glVertexAttrib1sNV *)packed; \
    ARGS_glVertexAttrib1sNV *args = (ARGS_glVertexAttrib1sNV *)&unpacked->args; \
    glVertexAttrib1sNV(args->index, args->x);; \
} while(0)
void glVertexAttrib1sNV(glVertexAttrib1sNV_ARG_EXPAND);
typedef void (*glVertexAttrib1sNV_PTR)(glVertexAttrib1sNV_ARG_EXPAND);
#define glVertexAttrib1sv_INDEX 2373
#define glVertexAttrib1sv_RETURN void
#define glVertexAttrib1sv_ARG_NAMES index, v
#define glVertexAttrib1sv_ARG_EXPAND GLuint index, const GLshort * v
#define glVertexAttrib1sv_PACKED PACKED_glVertexAttrib1sv
#define glVertexAttrib1sv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttrib1sv_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttrib1sv(_index, _v) ({ \
    glVertexAttrib1sv_PACKED *packed_data = malloc(sizeof(glVertexAttrib1sv_PACKED)); \
    packed_data->index = glVertexAttrib1sv_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.v = (GLshort *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttrib1sv(packed, ret_v) do { \
    PACKED_glVertexAttrib1sv *unpacked = (PACKED_glVertexAttrib1sv *)packed; \
    ARGS_glVertexAttrib1sv *args = (ARGS_glVertexAttrib1sv *)&unpacked->args; \
    glVertexAttrib1sv(args->index, args->v);; \
} while(0)
void glVertexAttrib1sv(glVertexAttrib1sv_ARG_EXPAND);
typedef void (*glVertexAttrib1sv_PTR)(glVertexAttrib1sv_ARG_EXPAND);
#define glVertexAttrib1svARB_INDEX 2374
#define glVertexAttrib1svARB_RETURN void
#define glVertexAttrib1svARB_ARG_NAMES index, v
#define glVertexAttrib1svARB_ARG_EXPAND GLuint index, const GLshort * v
#define glVertexAttrib1svARB_PACKED PACKED_glVertexAttrib1svARB
#define glVertexAttrib1svARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttrib1svARB_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttrib1svARB(_index, _v) ({ \
    glVertexAttrib1svARB_PACKED *packed_data = malloc(sizeof(glVertexAttrib1svARB_PACKED)); \
    packed_data->index = glVertexAttrib1svARB_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.v = (GLshort *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttrib1svARB(packed, ret_v) do { \
    PACKED_glVertexAttrib1svARB *unpacked = (PACKED_glVertexAttrib1svARB *)packed; \
    ARGS_glVertexAttrib1svARB *args = (ARGS_glVertexAttrib1svARB *)&unpacked->args; \
    glVertexAttrib1svARB(args->index, args->v);; \
} while(0)
void glVertexAttrib1svARB(glVertexAttrib1svARB_ARG_EXPAND);
typedef void (*glVertexAttrib1svARB_PTR)(glVertexAttrib1svARB_ARG_EXPAND);
#define glVertexAttrib1svNV_INDEX 2375
#define glVertexAttrib1svNV_RETURN void
#define glVertexAttrib1svNV_ARG_NAMES index, v
#define glVertexAttrib1svNV_ARG_EXPAND GLuint index, const GLshort * v
#define glVertexAttrib1svNV_PACKED PACKED_glVertexAttrib1svNV
#define glVertexAttrib1svNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttrib1svNV_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttrib1svNV(_index, _v) ({ \
    glVertexAttrib1svNV_PACKED *packed_data = malloc(sizeof(glVertexAttrib1svNV_PACKED)); \
    packed_data->index = glVertexAttrib1svNV_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.v = (GLshort *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttrib1svNV(packed, ret_v) do { \
    PACKED_glVertexAttrib1svNV *unpacked = (PACKED_glVertexAttrib1svNV *)packed; \
    ARGS_glVertexAttrib1svNV *args = (ARGS_glVertexAttrib1svNV *)&unpacked->args; \
    glVertexAttrib1svNV(args->index, args->v);; \
} while(0)
void glVertexAttrib1svNV(glVertexAttrib1svNV_ARG_EXPAND);
typedef void (*glVertexAttrib1svNV_PTR)(glVertexAttrib1svNV_ARG_EXPAND);
#define glVertexAttrib2d_INDEX 2376
#define glVertexAttrib2d_RETURN void
#define glVertexAttrib2d_ARG_NAMES index, x, y
#define glVertexAttrib2d_ARG_EXPAND GLuint index, GLdouble x, GLdouble y
#define glVertexAttrib2d_PACKED PACKED_glVertexAttrib2d
#define glVertexAttrib2d_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttrib2d_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttrib2d(_index, _x, _y) ({ \
    glVertexAttrib2d_PACKED *packed_data = malloc(sizeof(glVertexAttrib2d_PACKED)); \
    packed_data->index = glVertexAttrib2d_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.x = (GLdouble)_x; \
    packed_data->args.y = (GLdouble)_y; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttrib2d(packed, ret_v) do { \
    PACKED_glVertexAttrib2d *unpacked = (PACKED_glVertexAttrib2d *)packed; \
    ARGS_glVertexAttrib2d *args = (ARGS_glVertexAttrib2d *)&unpacked->args; \
    glVertexAttrib2d(args->index, args->x, args->y);; \
} while(0)
void glVertexAttrib2d(glVertexAttrib2d_ARG_EXPAND);
typedef void (*glVertexAttrib2d_PTR)(glVertexAttrib2d_ARG_EXPAND);
#define glVertexAttrib2dARB_INDEX 2377
#define glVertexAttrib2dARB_RETURN void
#define glVertexAttrib2dARB_ARG_NAMES index, x, y
#define glVertexAttrib2dARB_ARG_EXPAND GLuint index, GLdouble x, GLdouble y
#define glVertexAttrib2dARB_PACKED PACKED_glVertexAttrib2dARB
#define glVertexAttrib2dARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttrib2dARB_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttrib2dARB(_index, _x, _y) ({ \
    glVertexAttrib2dARB_PACKED *packed_data = malloc(sizeof(glVertexAttrib2dARB_PACKED)); \
    packed_data->index = glVertexAttrib2dARB_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.x = (GLdouble)_x; \
    packed_data->args.y = (GLdouble)_y; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttrib2dARB(packed, ret_v) do { \
    PACKED_glVertexAttrib2dARB *unpacked = (PACKED_glVertexAttrib2dARB *)packed; \
    ARGS_glVertexAttrib2dARB *args = (ARGS_glVertexAttrib2dARB *)&unpacked->args; \
    glVertexAttrib2dARB(args->index, args->x, args->y);; \
} while(0)
void glVertexAttrib2dARB(glVertexAttrib2dARB_ARG_EXPAND);
typedef void (*glVertexAttrib2dARB_PTR)(glVertexAttrib2dARB_ARG_EXPAND);
#define glVertexAttrib2dNV_INDEX 2378
#define glVertexAttrib2dNV_RETURN void
#define glVertexAttrib2dNV_ARG_NAMES index, x, y
#define glVertexAttrib2dNV_ARG_EXPAND GLuint index, GLdouble x, GLdouble y
#define glVertexAttrib2dNV_PACKED PACKED_glVertexAttrib2dNV
#define glVertexAttrib2dNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttrib2dNV_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttrib2dNV(_index, _x, _y) ({ \
    glVertexAttrib2dNV_PACKED *packed_data = malloc(sizeof(glVertexAttrib2dNV_PACKED)); \
    packed_data->index = glVertexAttrib2dNV_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.x = (GLdouble)_x; \
    packed_data->args.y = (GLdouble)_y; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttrib2dNV(packed, ret_v) do { \
    PACKED_glVertexAttrib2dNV *unpacked = (PACKED_glVertexAttrib2dNV *)packed; \
    ARGS_glVertexAttrib2dNV *args = (ARGS_glVertexAttrib2dNV *)&unpacked->args; \
    glVertexAttrib2dNV(args->index, args->x, args->y);; \
} while(0)
void glVertexAttrib2dNV(glVertexAttrib2dNV_ARG_EXPAND);
typedef void (*glVertexAttrib2dNV_PTR)(glVertexAttrib2dNV_ARG_EXPAND);
#define glVertexAttrib2dv_INDEX 2379
#define glVertexAttrib2dv_RETURN void
#define glVertexAttrib2dv_ARG_NAMES index, v
#define glVertexAttrib2dv_ARG_EXPAND GLuint index, const GLdouble * v
#define glVertexAttrib2dv_PACKED PACKED_glVertexAttrib2dv
#define glVertexAttrib2dv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttrib2dv_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttrib2dv(_index, _v) ({ \
    glVertexAttrib2dv_PACKED *packed_data = malloc(sizeof(glVertexAttrib2dv_PACKED)); \
    packed_data->index = glVertexAttrib2dv_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.v = (GLdouble *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttrib2dv(packed, ret_v) do { \
    PACKED_glVertexAttrib2dv *unpacked = (PACKED_glVertexAttrib2dv *)packed; \
    ARGS_glVertexAttrib2dv *args = (ARGS_glVertexAttrib2dv *)&unpacked->args; \
    glVertexAttrib2dv(args->index, args->v);; \
} while(0)
void glVertexAttrib2dv(glVertexAttrib2dv_ARG_EXPAND);
typedef void (*glVertexAttrib2dv_PTR)(glVertexAttrib2dv_ARG_EXPAND);
#define glVertexAttrib2dvARB_INDEX 2380
#define glVertexAttrib2dvARB_RETURN void
#define glVertexAttrib2dvARB_ARG_NAMES index, v
#define glVertexAttrib2dvARB_ARG_EXPAND GLuint index, const GLdouble * v
#define glVertexAttrib2dvARB_PACKED PACKED_glVertexAttrib2dvARB
#define glVertexAttrib2dvARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttrib2dvARB_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttrib2dvARB(_index, _v) ({ \
    glVertexAttrib2dvARB_PACKED *packed_data = malloc(sizeof(glVertexAttrib2dvARB_PACKED)); \
    packed_data->index = glVertexAttrib2dvARB_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.v = (GLdouble *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttrib2dvARB(packed, ret_v) do { \
    PACKED_glVertexAttrib2dvARB *unpacked = (PACKED_glVertexAttrib2dvARB *)packed; \
    ARGS_glVertexAttrib2dvARB *args = (ARGS_glVertexAttrib2dvARB *)&unpacked->args; \
    glVertexAttrib2dvARB(args->index, args->v);; \
} while(0)
void glVertexAttrib2dvARB(glVertexAttrib2dvARB_ARG_EXPAND);
typedef void (*glVertexAttrib2dvARB_PTR)(glVertexAttrib2dvARB_ARG_EXPAND);
#define glVertexAttrib2dvNV_INDEX 2381
#define glVertexAttrib2dvNV_RETURN void
#define glVertexAttrib2dvNV_ARG_NAMES index, v
#define glVertexAttrib2dvNV_ARG_EXPAND GLuint index, const GLdouble * v
#define glVertexAttrib2dvNV_PACKED PACKED_glVertexAttrib2dvNV
#define glVertexAttrib2dvNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttrib2dvNV_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttrib2dvNV(_index, _v) ({ \
    glVertexAttrib2dvNV_PACKED *packed_data = malloc(sizeof(glVertexAttrib2dvNV_PACKED)); \
    packed_data->index = glVertexAttrib2dvNV_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.v = (GLdouble *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttrib2dvNV(packed, ret_v) do { \
    PACKED_glVertexAttrib2dvNV *unpacked = (PACKED_glVertexAttrib2dvNV *)packed; \
    ARGS_glVertexAttrib2dvNV *args = (ARGS_glVertexAttrib2dvNV *)&unpacked->args; \
    glVertexAttrib2dvNV(args->index, args->v);; \
} while(0)
void glVertexAttrib2dvNV(glVertexAttrib2dvNV_ARG_EXPAND);
typedef void (*glVertexAttrib2dvNV_PTR)(glVertexAttrib2dvNV_ARG_EXPAND);
#define glVertexAttrib2f_INDEX 2382
#define glVertexAttrib2f_RETURN void
#define glVertexAttrib2f_ARG_NAMES index, x, y
#define glVertexAttrib2f_ARG_EXPAND GLuint index, GLfloat x, GLfloat y
#define glVertexAttrib2f_PACKED PACKED_glVertexAttrib2f
#define glVertexAttrib2f_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttrib2f_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttrib2f(_index, _x, _y) ({ \
    glVertexAttrib2f_PACKED *packed_data = malloc(sizeof(glVertexAttrib2f_PACKED)); \
    packed_data->index = glVertexAttrib2f_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.x = (GLfloat)_x; \
    packed_data->args.y = (GLfloat)_y; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttrib2f(packed, ret_v) do { \
    PACKED_glVertexAttrib2f *unpacked = (PACKED_glVertexAttrib2f *)packed; \
    ARGS_glVertexAttrib2f *args = (ARGS_glVertexAttrib2f *)&unpacked->args; \
    glVertexAttrib2f(args->index, args->x, args->y);; \
} while(0)
void glVertexAttrib2f(glVertexAttrib2f_ARG_EXPAND);
typedef void (*glVertexAttrib2f_PTR)(glVertexAttrib2f_ARG_EXPAND);
#define glVertexAttrib2fARB_INDEX 2383
#define glVertexAttrib2fARB_RETURN void
#define glVertexAttrib2fARB_ARG_NAMES index, x, y
#define glVertexAttrib2fARB_ARG_EXPAND GLuint index, GLfloat x, GLfloat y
#define glVertexAttrib2fARB_PACKED PACKED_glVertexAttrib2fARB
#define glVertexAttrib2fARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttrib2fARB_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttrib2fARB(_index, _x, _y) ({ \
    glVertexAttrib2fARB_PACKED *packed_data = malloc(sizeof(glVertexAttrib2fARB_PACKED)); \
    packed_data->index = glVertexAttrib2fARB_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.x = (GLfloat)_x; \
    packed_data->args.y = (GLfloat)_y; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttrib2fARB(packed, ret_v) do { \
    PACKED_glVertexAttrib2fARB *unpacked = (PACKED_glVertexAttrib2fARB *)packed; \
    ARGS_glVertexAttrib2fARB *args = (ARGS_glVertexAttrib2fARB *)&unpacked->args; \
    glVertexAttrib2fARB(args->index, args->x, args->y);; \
} while(0)
void glVertexAttrib2fARB(glVertexAttrib2fARB_ARG_EXPAND);
typedef void (*glVertexAttrib2fARB_PTR)(glVertexAttrib2fARB_ARG_EXPAND);
#define glVertexAttrib2fNV_INDEX 2384
#define glVertexAttrib2fNV_RETURN void
#define glVertexAttrib2fNV_ARG_NAMES index, x, y
#define glVertexAttrib2fNV_ARG_EXPAND GLuint index, GLfloat x, GLfloat y
#define glVertexAttrib2fNV_PACKED PACKED_glVertexAttrib2fNV
#define glVertexAttrib2fNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttrib2fNV_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttrib2fNV(_index, _x, _y) ({ \
    glVertexAttrib2fNV_PACKED *packed_data = malloc(sizeof(glVertexAttrib2fNV_PACKED)); \
    packed_data->index = glVertexAttrib2fNV_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.x = (GLfloat)_x; \
    packed_data->args.y = (GLfloat)_y; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttrib2fNV(packed, ret_v) do { \
    PACKED_glVertexAttrib2fNV *unpacked = (PACKED_glVertexAttrib2fNV *)packed; \
    ARGS_glVertexAttrib2fNV *args = (ARGS_glVertexAttrib2fNV *)&unpacked->args; \
    glVertexAttrib2fNV(args->index, args->x, args->y);; \
} while(0)
void glVertexAttrib2fNV(glVertexAttrib2fNV_ARG_EXPAND);
typedef void (*glVertexAttrib2fNV_PTR)(glVertexAttrib2fNV_ARG_EXPAND);
#define glVertexAttrib2fv_INDEX 2385
#define glVertexAttrib2fv_RETURN void
#define glVertexAttrib2fv_ARG_NAMES index, v
#define glVertexAttrib2fv_ARG_EXPAND GLuint index, const GLfloat * v
#define glVertexAttrib2fv_PACKED PACKED_glVertexAttrib2fv
#define glVertexAttrib2fv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttrib2fv_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttrib2fv(_index, _v) ({ \
    glVertexAttrib2fv_PACKED *packed_data = malloc(sizeof(glVertexAttrib2fv_PACKED)); \
    packed_data->index = glVertexAttrib2fv_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.v = (GLfloat *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttrib2fv(packed, ret_v) do { \
    PACKED_glVertexAttrib2fv *unpacked = (PACKED_glVertexAttrib2fv *)packed; \
    ARGS_glVertexAttrib2fv *args = (ARGS_glVertexAttrib2fv *)&unpacked->args; \
    glVertexAttrib2fv(args->index, args->v);; \
} while(0)
void glVertexAttrib2fv(glVertexAttrib2fv_ARG_EXPAND);
typedef void (*glVertexAttrib2fv_PTR)(glVertexAttrib2fv_ARG_EXPAND);
#define glVertexAttrib2fvARB_INDEX 2386
#define glVertexAttrib2fvARB_RETURN void
#define glVertexAttrib2fvARB_ARG_NAMES index, v
#define glVertexAttrib2fvARB_ARG_EXPAND GLuint index, const GLfloat * v
#define glVertexAttrib2fvARB_PACKED PACKED_glVertexAttrib2fvARB
#define glVertexAttrib2fvARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttrib2fvARB_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttrib2fvARB(_index, _v) ({ \
    glVertexAttrib2fvARB_PACKED *packed_data = malloc(sizeof(glVertexAttrib2fvARB_PACKED)); \
    packed_data->index = glVertexAttrib2fvARB_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.v = (GLfloat *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttrib2fvARB(packed, ret_v) do { \
    PACKED_glVertexAttrib2fvARB *unpacked = (PACKED_glVertexAttrib2fvARB *)packed; \
    ARGS_glVertexAttrib2fvARB *args = (ARGS_glVertexAttrib2fvARB *)&unpacked->args; \
    glVertexAttrib2fvARB(args->index, args->v);; \
} while(0)
void glVertexAttrib2fvARB(glVertexAttrib2fvARB_ARG_EXPAND);
typedef void (*glVertexAttrib2fvARB_PTR)(glVertexAttrib2fvARB_ARG_EXPAND);
#define glVertexAttrib2fvNV_INDEX 2387
#define glVertexAttrib2fvNV_RETURN void
#define glVertexAttrib2fvNV_ARG_NAMES index, v
#define glVertexAttrib2fvNV_ARG_EXPAND GLuint index, const GLfloat * v
#define glVertexAttrib2fvNV_PACKED PACKED_glVertexAttrib2fvNV
#define glVertexAttrib2fvNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttrib2fvNV_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttrib2fvNV(_index, _v) ({ \
    glVertexAttrib2fvNV_PACKED *packed_data = malloc(sizeof(glVertexAttrib2fvNV_PACKED)); \
    packed_data->index = glVertexAttrib2fvNV_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.v = (GLfloat *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttrib2fvNV(packed, ret_v) do { \
    PACKED_glVertexAttrib2fvNV *unpacked = (PACKED_glVertexAttrib2fvNV *)packed; \
    ARGS_glVertexAttrib2fvNV *args = (ARGS_glVertexAttrib2fvNV *)&unpacked->args; \
    glVertexAttrib2fvNV(args->index, args->v);; \
} while(0)
void glVertexAttrib2fvNV(glVertexAttrib2fvNV_ARG_EXPAND);
typedef void (*glVertexAttrib2fvNV_PTR)(glVertexAttrib2fvNV_ARG_EXPAND);
#define glVertexAttrib2hNV_INDEX 2388
#define glVertexAttrib2hNV_RETURN void
#define glVertexAttrib2hNV_ARG_NAMES index, x, y
#define glVertexAttrib2hNV_ARG_EXPAND GLuint index, GLhalfNV x, GLhalfNV y
#define glVertexAttrib2hNV_PACKED PACKED_glVertexAttrib2hNV
#define glVertexAttrib2hNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttrib2hNV_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttrib2hNV(_index, _x, _y) ({ \
    glVertexAttrib2hNV_PACKED *packed_data = malloc(sizeof(glVertexAttrib2hNV_PACKED)); \
    packed_data->index = glVertexAttrib2hNV_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.x = (GLhalfNV)_x; \
    packed_data->args.y = (GLhalfNV)_y; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttrib2hNV(packed, ret_v) do { \
    PACKED_glVertexAttrib2hNV *unpacked = (PACKED_glVertexAttrib2hNV *)packed; \
    ARGS_glVertexAttrib2hNV *args = (ARGS_glVertexAttrib2hNV *)&unpacked->args; \
    glVertexAttrib2hNV(args->index, args->x, args->y);; \
} while(0)
void glVertexAttrib2hNV(glVertexAttrib2hNV_ARG_EXPAND);
typedef void (*glVertexAttrib2hNV_PTR)(glVertexAttrib2hNV_ARG_EXPAND);
#define glVertexAttrib2hvNV_INDEX 2389
#define glVertexAttrib2hvNV_RETURN void
#define glVertexAttrib2hvNV_ARG_NAMES index, v
#define glVertexAttrib2hvNV_ARG_EXPAND GLuint index, const GLhalfNV * v
#define glVertexAttrib2hvNV_PACKED PACKED_glVertexAttrib2hvNV
#define glVertexAttrib2hvNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttrib2hvNV_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttrib2hvNV(_index, _v) ({ \
    glVertexAttrib2hvNV_PACKED *packed_data = malloc(sizeof(glVertexAttrib2hvNV_PACKED)); \
    packed_data->index = glVertexAttrib2hvNV_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.v = (GLhalfNV *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttrib2hvNV(packed, ret_v) do { \
    PACKED_glVertexAttrib2hvNV *unpacked = (PACKED_glVertexAttrib2hvNV *)packed; \
    ARGS_glVertexAttrib2hvNV *args = (ARGS_glVertexAttrib2hvNV *)&unpacked->args; \
    glVertexAttrib2hvNV(args->index, args->v);; \
} while(0)
void glVertexAttrib2hvNV(glVertexAttrib2hvNV_ARG_EXPAND);
typedef void (*glVertexAttrib2hvNV_PTR)(glVertexAttrib2hvNV_ARG_EXPAND);
#define glVertexAttrib2s_INDEX 2390
#define glVertexAttrib2s_RETURN void
#define glVertexAttrib2s_ARG_NAMES index, x, y
#define glVertexAttrib2s_ARG_EXPAND GLuint index, GLshort x, GLshort y
#define glVertexAttrib2s_PACKED PACKED_glVertexAttrib2s
#define glVertexAttrib2s_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttrib2s_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttrib2s(_index, _x, _y) ({ \
    glVertexAttrib2s_PACKED *packed_data = malloc(sizeof(glVertexAttrib2s_PACKED)); \
    packed_data->index = glVertexAttrib2s_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.x = (GLshort)_x; \
    packed_data->args.y = (GLshort)_y; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttrib2s(packed, ret_v) do { \
    PACKED_glVertexAttrib2s *unpacked = (PACKED_glVertexAttrib2s *)packed; \
    ARGS_glVertexAttrib2s *args = (ARGS_glVertexAttrib2s *)&unpacked->args; \
    glVertexAttrib2s(args->index, args->x, args->y);; \
} while(0)
void glVertexAttrib2s(glVertexAttrib2s_ARG_EXPAND);
typedef void (*glVertexAttrib2s_PTR)(glVertexAttrib2s_ARG_EXPAND);
#define glVertexAttrib2sARB_INDEX 2391
#define glVertexAttrib2sARB_RETURN void
#define glVertexAttrib2sARB_ARG_NAMES index, x, y
#define glVertexAttrib2sARB_ARG_EXPAND GLuint index, GLshort x, GLshort y
#define glVertexAttrib2sARB_PACKED PACKED_glVertexAttrib2sARB
#define glVertexAttrib2sARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttrib2sARB_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttrib2sARB(_index, _x, _y) ({ \
    glVertexAttrib2sARB_PACKED *packed_data = malloc(sizeof(glVertexAttrib2sARB_PACKED)); \
    packed_data->index = glVertexAttrib2sARB_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.x = (GLshort)_x; \
    packed_data->args.y = (GLshort)_y; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttrib2sARB(packed, ret_v) do { \
    PACKED_glVertexAttrib2sARB *unpacked = (PACKED_glVertexAttrib2sARB *)packed; \
    ARGS_glVertexAttrib2sARB *args = (ARGS_glVertexAttrib2sARB *)&unpacked->args; \
    glVertexAttrib2sARB(args->index, args->x, args->y);; \
} while(0)
void glVertexAttrib2sARB(glVertexAttrib2sARB_ARG_EXPAND);
typedef void (*glVertexAttrib2sARB_PTR)(glVertexAttrib2sARB_ARG_EXPAND);
#define glVertexAttrib2sNV_INDEX 2392
#define glVertexAttrib2sNV_RETURN void
#define glVertexAttrib2sNV_ARG_NAMES index, x, y
#define glVertexAttrib2sNV_ARG_EXPAND GLuint index, GLshort x, GLshort y
#define glVertexAttrib2sNV_PACKED PACKED_glVertexAttrib2sNV
#define glVertexAttrib2sNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttrib2sNV_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttrib2sNV(_index, _x, _y) ({ \
    glVertexAttrib2sNV_PACKED *packed_data = malloc(sizeof(glVertexAttrib2sNV_PACKED)); \
    packed_data->index = glVertexAttrib2sNV_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.x = (GLshort)_x; \
    packed_data->args.y = (GLshort)_y; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttrib2sNV(packed, ret_v) do { \
    PACKED_glVertexAttrib2sNV *unpacked = (PACKED_glVertexAttrib2sNV *)packed; \
    ARGS_glVertexAttrib2sNV *args = (ARGS_glVertexAttrib2sNV *)&unpacked->args; \
    glVertexAttrib2sNV(args->index, args->x, args->y);; \
} while(0)
void glVertexAttrib2sNV(glVertexAttrib2sNV_ARG_EXPAND);
typedef void (*glVertexAttrib2sNV_PTR)(glVertexAttrib2sNV_ARG_EXPAND);
#define glVertexAttrib2sv_INDEX 2393
#define glVertexAttrib2sv_RETURN void
#define glVertexAttrib2sv_ARG_NAMES index, v
#define glVertexAttrib2sv_ARG_EXPAND GLuint index, const GLshort * v
#define glVertexAttrib2sv_PACKED PACKED_glVertexAttrib2sv
#define glVertexAttrib2sv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttrib2sv_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttrib2sv(_index, _v) ({ \
    glVertexAttrib2sv_PACKED *packed_data = malloc(sizeof(glVertexAttrib2sv_PACKED)); \
    packed_data->index = glVertexAttrib2sv_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.v = (GLshort *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttrib2sv(packed, ret_v) do { \
    PACKED_glVertexAttrib2sv *unpacked = (PACKED_glVertexAttrib2sv *)packed; \
    ARGS_glVertexAttrib2sv *args = (ARGS_glVertexAttrib2sv *)&unpacked->args; \
    glVertexAttrib2sv(args->index, args->v);; \
} while(0)
void glVertexAttrib2sv(glVertexAttrib2sv_ARG_EXPAND);
typedef void (*glVertexAttrib2sv_PTR)(glVertexAttrib2sv_ARG_EXPAND);
#define glVertexAttrib2svARB_INDEX 2394
#define glVertexAttrib2svARB_RETURN void
#define glVertexAttrib2svARB_ARG_NAMES index, v
#define glVertexAttrib2svARB_ARG_EXPAND GLuint index, const GLshort * v
#define glVertexAttrib2svARB_PACKED PACKED_glVertexAttrib2svARB
#define glVertexAttrib2svARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttrib2svARB_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttrib2svARB(_index, _v) ({ \
    glVertexAttrib2svARB_PACKED *packed_data = malloc(sizeof(glVertexAttrib2svARB_PACKED)); \
    packed_data->index = glVertexAttrib2svARB_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.v = (GLshort *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttrib2svARB(packed, ret_v) do { \
    PACKED_glVertexAttrib2svARB *unpacked = (PACKED_glVertexAttrib2svARB *)packed; \
    ARGS_glVertexAttrib2svARB *args = (ARGS_glVertexAttrib2svARB *)&unpacked->args; \
    glVertexAttrib2svARB(args->index, args->v);; \
} while(0)
void glVertexAttrib2svARB(glVertexAttrib2svARB_ARG_EXPAND);
typedef void (*glVertexAttrib2svARB_PTR)(glVertexAttrib2svARB_ARG_EXPAND);
#define glVertexAttrib2svNV_INDEX 2395
#define glVertexAttrib2svNV_RETURN void
#define glVertexAttrib2svNV_ARG_NAMES index, v
#define glVertexAttrib2svNV_ARG_EXPAND GLuint index, const GLshort * v
#define glVertexAttrib2svNV_PACKED PACKED_glVertexAttrib2svNV
#define glVertexAttrib2svNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttrib2svNV_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttrib2svNV(_index, _v) ({ \
    glVertexAttrib2svNV_PACKED *packed_data = malloc(sizeof(glVertexAttrib2svNV_PACKED)); \
    packed_data->index = glVertexAttrib2svNV_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.v = (GLshort *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttrib2svNV(packed, ret_v) do { \
    PACKED_glVertexAttrib2svNV *unpacked = (PACKED_glVertexAttrib2svNV *)packed; \
    ARGS_glVertexAttrib2svNV *args = (ARGS_glVertexAttrib2svNV *)&unpacked->args; \
    glVertexAttrib2svNV(args->index, args->v);; \
} while(0)
void glVertexAttrib2svNV(glVertexAttrib2svNV_ARG_EXPAND);
typedef void (*glVertexAttrib2svNV_PTR)(glVertexAttrib2svNV_ARG_EXPAND);
#define glVertexAttrib3d_INDEX 2396
#define glVertexAttrib3d_RETURN void
#define glVertexAttrib3d_ARG_NAMES index, x, y, z
#define glVertexAttrib3d_ARG_EXPAND GLuint index, GLdouble x, GLdouble y, GLdouble z
#define glVertexAttrib3d_PACKED PACKED_glVertexAttrib3d
#define glVertexAttrib3d_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttrib3d_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttrib3d(_index, _x, _y, _z) ({ \
    glVertexAttrib3d_PACKED *packed_data = malloc(sizeof(glVertexAttrib3d_PACKED)); \
    packed_data->index = glVertexAttrib3d_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.x = (GLdouble)_x; \
    packed_data->args.y = (GLdouble)_y; \
    packed_data->args.z = (GLdouble)_z; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttrib3d(packed, ret_v) do { \
    PACKED_glVertexAttrib3d *unpacked = (PACKED_glVertexAttrib3d *)packed; \
    ARGS_glVertexAttrib3d *args = (ARGS_glVertexAttrib3d *)&unpacked->args; \
    glVertexAttrib3d(args->index, args->x, args->y, args->z);; \
} while(0)
void glVertexAttrib3d(glVertexAttrib3d_ARG_EXPAND);
typedef void (*glVertexAttrib3d_PTR)(glVertexAttrib3d_ARG_EXPAND);
#define glVertexAttrib3dARB_INDEX 2397
#define glVertexAttrib3dARB_RETURN void
#define glVertexAttrib3dARB_ARG_NAMES index, x, y, z
#define glVertexAttrib3dARB_ARG_EXPAND GLuint index, GLdouble x, GLdouble y, GLdouble z
#define glVertexAttrib3dARB_PACKED PACKED_glVertexAttrib3dARB
#define glVertexAttrib3dARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttrib3dARB_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttrib3dARB(_index, _x, _y, _z) ({ \
    glVertexAttrib3dARB_PACKED *packed_data = malloc(sizeof(glVertexAttrib3dARB_PACKED)); \
    packed_data->index = glVertexAttrib3dARB_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.x = (GLdouble)_x; \
    packed_data->args.y = (GLdouble)_y; \
    packed_data->args.z = (GLdouble)_z; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttrib3dARB(packed, ret_v) do { \
    PACKED_glVertexAttrib3dARB *unpacked = (PACKED_glVertexAttrib3dARB *)packed; \
    ARGS_glVertexAttrib3dARB *args = (ARGS_glVertexAttrib3dARB *)&unpacked->args; \
    glVertexAttrib3dARB(args->index, args->x, args->y, args->z);; \
} while(0)
void glVertexAttrib3dARB(glVertexAttrib3dARB_ARG_EXPAND);
typedef void (*glVertexAttrib3dARB_PTR)(glVertexAttrib3dARB_ARG_EXPAND);
#define glVertexAttrib3dNV_INDEX 2398
#define glVertexAttrib3dNV_RETURN void
#define glVertexAttrib3dNV_ARG_NAMES index, x, y, z
#define glVertexAttrib3dNV_ARG_EXPAND GLuint index, GLdouble x, GLdouble y, GLdouble z
#define glVertexAttrib3dNV_PACKED PACKED_glVertexAttrib3dNV
#define glVertexAttrib3dNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttrib3dNV_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttrib3dNV(_index, _x, _y, _z) ({ \
    glVertexAttrib3dNV_PACKED *packed_data = malloc(sizeof(glVertexAttrib3dNV_PACKED)); \
    packed_data->index = glVertexAttrib3dNV_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.x = (GLdouble)_x; \
    packed_data->args.y = (GLdouble)_y; \
    packed_data->args.z = (GLdouble)_z; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttrib3dNV(packed, ret_v) do { \
    PACKED_glVertexAttrib3dNV *unpacked = (PACKED_glVertexAttrib3dNV *)packed; \
    ARGS_glVertexAttrib3dNV *args = (ARGS_glVertexAttrib3dNV *)&unpacked->args; \
    glVertexAttrib3dNV(args->index, args->x, args->y, args->z);; \
} while(0)
void glVertexAttrib3dNV(glVertexAttrib3dNV_ARG_EXPAND);
typedef void (*glVertexAttrib3dNV_PTR)(glVertexAttrib3dNV_ARG_EXPAND);
#define glVertexAttrib3dv_INDEX 2399
#define glVertexAttrib3dv_RETURN void
#define glVertexAttrib3dv_ARG_NAMES index, v
#define glVertexAttrib3dv_ARG_EXPAND GLuint index, const GLdouble * v
#define glVertexAttrib3dv_PACKED PACKED_glVertexAttrib3dv
#define glVertexAttrib3dv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttrib3dv_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttrib3dv(_index, _v) ({ \
    glVertexAttrib3dv_PACKED *packed_data = malloc(sizeof(glVertexAttrib3dv_PACKED)); \
    packed_data->index = glVertexAttrib3dv_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.v = (GLdouble *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttrib3dv(packed, ret_v) do { \
    PACKED_glVertexAttrib3dv *unpacked = (PACKED_glVertexAttrib3dv *)packed; \
    ARGS_glVertexAttrib3dv *args = (ARGS_glVertexAttrib3dv *)&unpacked->args; \
    glVertexAttrib3dv(args->index, args->v);; \
} while(0)
void glVertexAttrib3dv(glVertexAttrib3dv_ARG_EXPAND);
typedef void (*glVertexAttrib3dv_PTR)(glVertexAttrib3dv_ARG_EXPAND);
#define glVertexAttrib3dvARB_INDEX 2400
#define glVertexAttrib3dvARB_RETURN void
#define glVertexAttrib3dvARB_ARG_NAMES index, v
#define glVertexAttrib3dvARB_ARG_EXPAND GLuint index, const GLdouble * v
#define glVertexAttrib3dvARB_PACKED PACKED_glVertexAttrib3dvARB
#define glVertexAttrib3dvARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttrib3dvARB_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttrib3dvARB(_index, _v) ({ \
    glVertexAttrib3dvARB_PACKED *packed_data = malloc(sizeof(glVertexAttrib3dvARB_PACKED)); \
    packed_data->index = glVertexAttrib3dvARB_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.v = (GLdouble *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttrib3dvARB(packed, ret_v) do { \
    PACKED_glVertexAttrib3dvARB *unpacked = (PACKED_glVertexAttrib3dvARB *)packed; \
    ARGS_glVertexAttrib3dvARB *args = (ARGS_glVertexAttrib3dvARB *)&unpacked->args; \
    glVertexAttrib3dvARB(args->index, args->v);; \
} while(0)
void glVertexAttrib3dvARB(glVertexAttrib3dvARB_ARG_EXPAND);
typedef void (*glVertexAttrib3dvARB_PTR)(glVertexAttrib3dvARB_ARG_EXPAND);
#define glVertexAttrib3dvNV_INDEX 2401
#define glVertexAttrib3dvNV_RETURN void
#define glVertexAttrib3dvNV_ARG_NAMES index, v
#define glVertexAttrib3dvNV_ARG_EXPAND GLuint index, const GLdouble * v
#define glVertexAttrib3dvNV_PACKED PACKED_glVertexAttrib3dvNV
#define glVertexAttrib3dvNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttrib3dvNV_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttrib3dvNV(_index, _v) ({ \
    glVertexAttrib3dvNV_PACKED *packed_data = malloc(sizeof(glVertexAttrib3dvNV_PACKED)); \
    packed_data->index = glVertexAttrib3dvNV_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.v = (GLdouble *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttrib3dvNV(packed, ret_v) do { \
    PACKED_glVertexAttrib3dvNV *unpacked = (PACKED_glVertexAttrib3dvNV *)packed; \
    ARGS_glVertexAttrib3dvNV *args = (ARGS_glVertexAttrib3dvNV *)&unpacked->args; \
    glVertexAttrib3dvNV(args->index, args->v);; \
} while(0)
void glVertexAttrib3dvNV(glVertexAttrib3dvNV_ARG_EXPAND);
typedef void (*glVertexAttrib3dvNV_PTR)(glVertexAttrib3dvNV_ARG_EXPAND);
#define glVertexAttrib3f_INDEX 2402
#define glVertexAttrib3f_RETURN void
#define glVertexAttrib3f_ARG_NAMES index, x, y, z
#define glVertexAttrib3f_ARG_EXPAND GLuint index, GLfloat x, GLfloat y, GLfloat z
#define glVertexAttrib3f_PACKED PACKED_glVertexAttrib3f
#define glVertexAttrib3f_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttrib3f_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttrib3f(_index, _x, _y, _z) ({ \
    glVertexAttrib3f_PACKED *packed_data = malloc(sizeof(glVertexAttrib3f_PACKED)); \
    packed_data->index = glVertexAttrib3f_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.x = (GLfloat)_x; \
    packed_data->args.y = (GLfloat)_y; \
    packed_data->args.z = (GLfloat)_z; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttrib3f(packed, ret_v) do { \
    PACKED_glVertexAttrib3f *unpacked = (PACKED_glVertexAttrib3f *)packed; \
    ARGS_glVertexAttrib3f *args = (ARGS_glVertexAttrib3f *)&unpacked->args; \
    glVertexAttrib3f(args->index, args->x, args->y, args->z);; \
} while(0)
void glVertexAttrib3f(glVertexAttrib3f_ARG_EXPAND);
typedef void (*glVertexAttrib3f_PTR)(glVertexAttrib3f_ARG_EXPAND);
#define glVertexAttrib3fARB_INDEX 2403
#define glVertexAttrib3fARB_RETURN void
#define glVertexAttrib3fARB_ARG_NAMES index, x, y, z
#define glVertexAttrib3fARB_ARG_EXPAND GLuint index, GLfloat x, GLfloat y, GLfloat z
#define glVertexAttrib3fARB_PACKED PACKED_glVertexAttrib3fARB
#define glVertexAttrib3fARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttrib3fARB_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttrib3fARB(_index, _x, _y, _z) ({ \
    glVertexAttrib3fARB_PACKED *packed_data = malloc(sizeof(glVertexAttrib3fARB_PACKED)); \
    packed_data->index = glVertexAttrib3fARB_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.x = (GLfloat)_x; \
    packed_data->args.y = (GLfloat)_y; \
    packed_data->args.z = (GLfloat)_z; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttrib3fARB(packed, ret_v) do { \
    PACKED_glVertexAttrib3fARB *unpacked = (PACKED_glVertexAttrib3fARB *)packed; \
    ARGS_glVertexAttrib3fARB *args = (ARGS_glVertexAttrib3fARB *)&unpacked->args; \
    glVertexAttrib3fARB(args->index, args->x, args->y, args->z);; \
} while(0)
void glVertexAttrib3fARB(glVertexAttrib3fARB_ARG_EXPAND);
typedef void (*glVertexAttrib3fARB_PTR)(glVertexAttrib3fARB_ARG_EXPAND);
#define glVertexAttrib3fNV_INDEX 2404
#define glVertexAttrib3fNV_RETURN void
#define glVertexAttrib3fNV_ARG_NAMES index, x, y, z
#define glVertexAttrib3fNV_ARG_EXPAND GLuint index, GLfloat x, GLfloat y, GLfloat z
#define glVertexAttrib3fNV_PACKED PACKED_glVertexAttrib3fNV
#define glVertexAttrib3fNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttrib3fNV_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttrib3fNV(_index, _x, _y, _z) ({ \
    glVertexAttrib3fNV_PACKED *packed_data = malloc(sizeof(glVertexAttrib3fNV_PACKED)); \
    packed_data->index = glVertexAttrib3fNV_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.x = (GLfloat)_x; \
    packed_data->args.y = (GLfloat)_y; \
    packed_data->args.z = (GLfloat)_z; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttrib3fNV(packed, ret_v) do { \
    PACKED_glVertexAttrib3fNV *unpacked = (PACKED_glVertexAttrib3fNV *)packed; \
    ARGS_glVertexAttrib3fNV *args = (ARGS_glVertexAttrib3fNV *)&unpacked->args; \
    glVertexAttrib3fNV(args->index, args->x, args->y, args->z);; \
} while(0)
void glVertexAttrib3fNV(glVertexAttrib3fNV_ARG_EXPAND);
typedef void (*glVertexAttrib3fNV_PTR)(glVertexAttrib3fNV_ARG_EXPAND);
#define glVertexAttrib3fv_INDEX 2405
#define glVertexAttrib3fv_RETURN void
#define glVertexAttrib3fv_ARG_NAMES index, v
#define glVertexAttrib3fv_ARG_EXPAND GLuint index, const GLfloat * v
#define glVertexAttrib3fv_PACKED PACKED_glVertexAttrib3fv
#define glVertexAttrib3fv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttrib3fv_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttrib3fv(_index, _v) ({ \
    glVertexAttrib3fv_PACKED *packed_data = malloc(sizeof(glVertexAttrib3fv_PACKED)); \
    packed_data->index = glVertexAttrib3fv_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.v = (GLfloat *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttrib3fv(packed, ret_v) do { \
    PACKED_glVertexAttrib3fv *unpacked = (PACKED_glVertexAttrib3fv *)packed; \
    ARGS_glVertexAttrib3fv *args = (ARGS_glVertexAttrib3fv *)&unpacked->args; \
    glVertexAttrib3fv(args->index, args->v);; \
} while(0)
void glVertexAttrib3fv(glVertexAttrib3fv_ARG_EXPAND);
typedef void (*glVertexAttrib3fv_PTR)(glVertexAttrib3fv_ARG_EXPAND);
#define glVertexAttrib3fvARB_INDEX 2406
#define glVertexAttrib3fvARB_RETURN void
#define glVertexAttrib3fvARB_ARG_NAMES index, v
#define glVertexAttrib3fvARB_ARG_EXPAND GLuint index, const GLfloat * v
#define glVertexAttrib3fvARB_PACKED PACKED_glVertexAttrib3fvARB
#define glVertexAttrib3fvARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttrib3fvARB_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttrib3fvARB(_index, _v) ({ \
    glVertexAttrib3fvARB_PACKED *packed_data = malloc(sizeof(glVertexAttrib3fvARB_PACKED)); \
    packed_data->index = glVertexAttrib3fvARB_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.v = (GLfloat *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttrib3fvARB(packed, ret_v) do { \
    PACKED_glVertexAttrib3fvARB *unpacked = (PACKED_glVertexAttrib3fvARB *)packed; \
    ARGS_glVertexAttrib3fvARB *args = (ARGS_glVertexAttrib3fvARB *)&unpacked->args; \
    glVertexAttrib3fvARB(args->index, args->v);; \
} while(0)
void glVertexAttrib3fvARB(glVertexAttrib3fvARB_ARG_EXPAND);
typedef void (*glVertexAttrib3fvARB_PTR)(glVertexAttrib3fvARB_ARG_EXPAND);
#define glVertexAttrib3fvNV_INDEX 2407
#define glVertexAttrib3fvNV_RETURN void
#define glVertexAttrib3fvNV_ARG_NAMES index, v
#define glVertexAttrib3fvNV_ARG_EXPAND GLuint index, const GLfloat * v
#define glVertexAttrib3fvNV_PACKED PACKED_glVertexAttrib3fvNV
#define glVertexAttrib3fvNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttrib3fvNV_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttrib3fvNV(_index, _v) ({ \
    glVertexAttrib3fvNV_PACKED *packed_data = malloc(sizeof(glVertexAttrib3fvNV_PACKED)); \
    packed_data->index = glVertexAttrib3fvNV_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.v = (GLfloat *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttrib3fvNV(packed, ret_v) do { \
    PACKED_glVertexAttrib3fvNV *unpacked = (PACKED_glVertexAttrib3fvNV *)packed; \
    ARGS_glVertexAttrib3fvNV *args = (ARGS_glVertexAttrib3fvNV *)&unpacked->args; \
    glVertexAttrib3fvNV(args->index, args->v);; \
} while(0)
void glVertexAttrib3fvNV(glVertexAttrib3fvNV_ARG_EXPAND);
typedef void (*glVertexAttrib3fvNV_PTR)(glVertexAttrib3fvNV_ARG_EXPAND);
#define glVertexAttrib3hNV_INDEX 2408
#define glVertexAttrib3hNV_RETURN void
#define glVertexAttrib3hNV_ARG_NAMES index, x, y, z
#define glVertexAttrib3hNV_ARG_EXPAND GLuint index, GLhalfNV x, GLhalfNV y, GLhalfNV z
#define glVertexAttrib3hNV_PACKED PACKED_glVertexAttrib3hNV
#define glVertexAttrib3hNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttrib3hNV_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttrib3hNV(_index, _x, _y, _z) ({ \
    glVertexAttrib3hNV_PACKED *packed_data = malloc(sizeof(glVertexAttrib3hNV_PACKED)); \
    packed_data->index = glVertexAttrib3hNV_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.x = (GLhalfNV)_x; \
    packed_data->args.y = (GLhalfNV)_y; \
    packed_data->args.z = (GLhalfNV)_z; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttrib3hNV(packed, ret_v) do { \
    PACKED_glVertexAttrib3hNV *unpacked = (PACKED_glVertexAttrib3hNV *)packed; \
    ARGS_glVertexAttrib3hNV *args = (ARGS_glVertexAttrib3hNV *)&unpacked->args; \
    glVertexAttrib3hNV(args->index, args->x, args->y, args->z);; \
} while(0)
void glVertexAttrib3hNV(glVertexAttrib3hNV_ARG_EXPAND);
typedef void (*glVertexAttrib3hNV_PTR)(glVertexAttrib3hNV_ARG_EXPAND);
#define glVertexAttrib3hvNV_INDEX 2409
#define glVertexAttrib3hvNV_RETURN void
#define glVertexAttrib3hvNV_ARG_NAMES index, v
#define glVertexAttrib3hvNV_ARG_EXPAND GLuint index, const GLhalfNV * v
#define glVertexAttrib3hvNV_PACKED PACKED_glVertexAttrib3hvNV
#define glVertexAttrib3hvNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttrib3hvNV_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttrib3hvNV(_index, _v) ({ \
    glVertexAttrib3hvNV_PACKED *packed_data = malloc(sizeof(glVertexAttrib3hvNV_PACKED)); \
    packed_data->index = glVertexAttrib3hvNV_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.v = (GLhalfNV *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttrib3hvNV(packed, ret_v) do { \
    PACKED_glVertexAttrib3hvNV *unpacked = (PACKED_glVertexAttrib3hvNV *)packed; \
    ARGS_glVertexAttrib3hvNV *args = (ARGS_glVertexAttrib3hvNV *)&unpacked->args; \
    glVertexAttrib3hvNV(args->index, args->v);; \
} while(0)
void glVertexAttrib3hvNV(glVertexAttrib3hvNV_ARG_EXPAND);
typedef void (*glVertexAttrib3hvNV_PTR)(glVertexAttrib3hvNV_ARG_EXPAND);
#define glVertexAttrib3s_INDEX 2410
#define glVertexAttrib3s_RETURN void
#define glVertexAttrib3s_ARG_NAMES index, x, y, z
#define glVertexAttrib3s_ARG_EXPAND GLuint index, GLshort x, GLshort y, GLshort z
#define glVertexAttrib3s_PACKED PACKED_glVertexAttrib3s
#define glVertexAttrib3s_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttrib3s_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttrib3s(_index, _x, _y, _z) ({ \
    glVertexAttrib3s_PACKED *packed_data = malloc(sizeof(glVertexAttrib3s_PACKED)); \
    packed_data->index = glVertexAttrib3s_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.x = (GLshort)_x; \
    packed_data->args.y = (GLshort)_y; \
    packed_data->args.z = (GLshort)_z; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttrib3s(packed, ret_v) do { \
    PACKED_glVertexAttrib3s *unpacked = (PACKED_glVertexAttrib3s *)packed; \
    ARGS_glVertexAttrib3s *args = (ARGS_glVertexAttrib3s *)&unpacked->args; \
    glVertexAttrib3s(args->index, args->x, args->y, args->z);; \
} while(0)
void glVertexAttrib3s(glVertexAttrib3s_ARG_EXPAND);
typedef void (*glVertexAttrib3s_PTR)(glVertexAttrib3s_ARG_EXPAND);
#define glVertexAttrib3sARB_INDEX 2411
#define glVertexAttrib3sARB_RETURN void
#define glVertexAttrib3sARB_ARG_NAMES index, x, y, z
#define glVertexAttrib3sARB_ARG_EXPAND GLuint index, GLshort x, GLshort y, GLshort z
#define glVertexAttrib3sARB_PACKED PACKED_glVertexAttrib3sARB
#define glVertexAttrib3sARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttrib3sARB_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttrib3sARB(_index, _x, _y, _z) ({ \
    glVertexAttrib3sARB_PACKED *packed_data = malloc(sizeof(glVertexAttrib3sARB_PACKED)); \
    packed_data->index = glVertexAttrib3sARB_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.x = (GLshort)_x; \
    packed_data->args.y = (GLshort)_y; \
    packed_data->args.z = (GLshort)_z; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttrib3sARB(packed, ret_v) do { \
    PACKED_glVertexAttrib3sARB *unpacked = (PACKED_glVertexAttrib3sARB *)packed; \
    ARGS_glVertexAttrib3sARB *args = (ARGS_glVertexAttrib3sARB *)&unpacked->args; \
    glVertexAttrib3sARB(args->index, args->x, args->y, args->z);; \
} while(0)
void glVertexAttrib3sARB(glVertexAttrib3sARB_ARG_EXPAND);
typedef void (*glVertexAttrib3sARB_PTR)(glVertexAttrib3sARB_ARG_EXPAND);
#define glVertexAttrib3sNV_INDEX 2412
#define glVertexAttrib3sNV_RETURN void
#define glVertexAttrib3sNV_ARG_NAMES index, x, y, z
#define glVertexAttrib3sNV_ARG_EXPAND GLuint index, GLshort x, GLshort y, GLshort z
#define glVertexAttrib3sNV_PACKED PACKED_glVertexAttrib3sNV
#define glVertexAttrib3sNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttrib3sNV_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttrib3sNV(_index, _x, _y, _z) ({ \
    glVertexAttrib3sNV_PACKED *packed_data = malloc(sizeof(glVertexAttrib3sNV_PACKED)); \
    packed_data->index = glVertexAttrib3sNV_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.x = (GLshort)_x; \
    packed_data->args.y = (GLshort)_y; \
    packed_data->args.z = (GLshort)_z; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttrib3sNV(packed, ret_v) do { \
    PACKED_glVertexAttrib3sNV *unpacked = (PACKED_glVertexAttrib3sNV *)packed; \
    ARGS_glVertexAttrib3sNV *args = (ARGS_glVertexAttrib3sNV *)&unpacked->args; \
    glVertexAttrib3sNV(args->index, args->x, args->y, args->z);; \
} while(0)
void glVertexAttrib3sNV(glVertexAttrib3sNV_ARG_EXPAND);
typedef void (*glVertexAttrib3sNV_PTR)(glVertexAttrib3sNV_ARG_EXPAND);
#define glVertexAttrib3sv_INDEX 2413
#define glVertexAttrib3sv_RETURN void
#define glVertexAttrib3sv_ARG_NAMES index, v
#define glVertexAttrib3sv_ARG_EXPAND GLuint index, const GLshort * v
#define glVertexAttrib3sv_PACKED PACKED_glVertexAttrib3sv
#define glVertexAttrib3sv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttrib3sv_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttrib3sv(_index, _v) ({ \
    glVertexAttrib3sv_PACKED *packed_data = malloc(sizeof(glVertexAttrib3sv_PACKED)); \
    packed_data->index = glVertexAttrib3sv_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.v = (GLshort *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttrib3sv(packed, ret_v) do { \
    PACKED_glVertexAttrib3sv *unpacked = (PACKED_glVertexAttrib3sv *)packed; \
    ARGS_glVertexAttrib3sv *args = (ARGS_glVertexAttrib3sv *)&unpacked->args; \
    glVertexAttrib3sv(args->index, args->v);; \
} while(0)
void glVertexAttrib3sv(glVertexAttrib3sv_ARG_EXPAND);
typedef void (*glVertexAttrib3sv_PTR)(glVertexAttrib3sv_ARG_EXPAND);
#define glVertexAttrib3svARB_INDEX 2414
#define glVertexAttrib3svARB_RETURN void
#define glVertexAttrib3svARB_ARG_NAMES index, v
#define glVertexAttrib3svARB_ARG_EXPAND GLuint index, const GLshort * v
#define glVertexAttrib3svARB_PACKED PACKED_glVertexAttrib3svARB
#define glVertexAttrib3svARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttrib3svARB_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttrib3svARB(_index, _v) ({ \
    glVertexAttrib3svARB_PACKED *packed_data = malloc(sizeof(glVertexAttrib3svARB_PACKED)); \
    packed_data->index = glVertexAttrib3svARB_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.v = (GLshort *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttrib3svARB(packed, ret_v) do { \
    PACKED_glVertexAttrib3svARB *unpacked = (PACKED_glVertexAttrib3svARB *)packed; \
    ARGS_glVertexAttrib3svARB *args = (ARGS_glVertexAttrib3svARB *)&unpacked->args; \
    glVertexAttrib3svARB(args->index, args->v);; \
} while(0)
void glVertexAttrib3svARB(glVertexAttrib3svARB_ARG_EXPAND);
typedef void (*glVertexAttrib3svARB_PTR)(glVertexAttrib3svARB_ARG_EXPAND);
#define glVertexAttrib3svNV_INDEX 2415
#define glVertexAttrib3svNV_RETURN void
#define glVertexAttrib3svNV_ARG_NAMES index, v
#define glVertexAttrib3svNV_ARG_EXPAND GLuint index, const GLshort * v
#define glVertexAttrib3svNV_PACKED PACKED_glVertexAttrib3svNV
#define glVertexAttrib3svNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttrib3svNV_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttrib3svNV(_index, _v) ({ \
    glVertexAttrib3svNV_PACKED *packed_data = malloc(sizeof(glVertexAttrib3svNV_PACKED)); \
    packed_data->index = glVertexAttrib3svNV_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.v = (GLshort *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttrib3svNV(packed, ret_v) do { \
    PACKED_glVertexAttrib3svNV *unpacked = (PACKED_glVertexAttrib3svNV *)packed; \
    ARGS_glVertexAttrib3svNV *args = (ARGS_glVertexAttrib3svNV *)&unpacked->args; \
    glVertexAttrib3svNV(args->index, args->v);; \
} while(0)
void glVertexAttrib3svNV(glVertexAttrib3svNV_ARG_EXPAND);
typedef void (*glVertexAttrib3svNV_PTR)(glVertexAttrib3svNV_ARG_EXPAND);
#define glVertexAttrib4Nbv_INDEX 2416
#define glVertexAttrib4Nbv_RETURN void
#define glVertexAttrib4Nbv_ARG_NAMES index, v
#define glVertexAttrib4Nbv_ARG_EXPAND GLuint index, const GLbyte * v
#define glVertexAttrib4Nbv_PACKED PACKED_glVertexAttrib4Nbv
#define glVertexAttrib4Nbv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttrib4Nbv_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttrib4Nbv(_index, _v) ({ \
    glVertexAttrib4Nbv_PACKED *packed_data = malloc(sizeof(glVertexAttrib4Nbv_PACKED)); \
    packed_data->index = glVertexAttrib4Nbv_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.v = (GLbyte *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttrib4Nbv(packed, ret_v) do { \
    PACKED_glVertexAttrib4Nbv *unpacked = (PACKED_glVertexAttrib4Nbv *)packed; \
    ARGS_glVertexAttrib4Nbv *args = (ARGS_glVertexAttrib4Nbv *)&unpacked->args; \
    glVertexAttrib4Nbv(args->index, args->v);; \
} while(0)
void glVertexAttrib4Nbv(glVertexAttrib4Nbv_ARG_EXPAND);
typedef void (*glVertexAttrib4Nbv_PTR)(glVertexAttrib4Nbv_ARG_EXPAND);
#define glVertexAttrib4NbvARB_INDEX 2417
#define glVertexAttrib4NbvARB_RETURN void
#define glVertexAttrib4NbvARB_ARG_NAMES index, v
#define glVertexAttrib4NbvARB_ARG_EXPAND GLuint index, const GLbyte * v
#define glVertexAttrib4NbvARB_PACKED PACKED_glVertexAttrib4NbvARB
#define glVertexAttrib4NbvARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttrib4NbvARB_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttrib4NbvARB(_index, _v) ({ \
    glVertexAttrib4NbvARB_PACKED *packed_data = malloc(sizeof(glVertexAttrib4NbvARB_PACKED)); \
    packed_data->index = glVertexAttrib4NbvARB_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.v = (GLbyte *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttrib4NbvARB(packed, ret_v) do { \
    PACKED_glVertexAttrib4NbvARB *unpacked = (PACKED_glVertexAttrib4NbvARB *)packed; \
    ARGS_glVertexAttrib4NbvARB *args = (ARGS_glVertexAttrib4NbvARB *)&unpacked->args; \
    glVertexAttrib4NbvARB(args->index, args->v);; \
} while(0)
void glVertexAttrib4NbvARB(glVertexAttrib4NbvARB_ARG_EXPAND);
typedef void (*glVertexAttrib4NbvARB_PTR)(glVertexAttrib4NbvARB_ARG_EXPAND);
#define glVertexAttrib4Niv_INDEX 2418
#define glVertexAttrib4Niv_RETURN void
#define glVertexAttrib4Niv_ARG_NAMES index, v
#define glVertexAttrib4Niv_ARG_EXPAND GLuint index, const GLint * v
#define glVertexAttrib4Niv_PACKED PACKED_glVertexAttrib4Niv
#define glVertexAttrib4Niv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttrib4Niv_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttrib4Niv(_index, _v) ({ \
    glVertexAttrib4Niv_PACKED *packed_data = malloc(sizeof(glVertexAttrib4Niv_PACKED)); \
    packed_data->index = glVertexAttrib4Niv_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.v = (GLint *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttrib4Niv(packed, ret_v) do { \
    PACKED_glVertexAttrib4Niv *unpacked = (PACKED_glVertexAttrib4Niv *)packed; \
    ARGS_glVertexAttrib4Niv *args = (ARGS_glVertexAttrib4Niv *)&unpacked->args; \
    glVertexAttrib4Niv(args->index, args->v);; \
} while(0)
void glVertexAttrib4Niv(glVertexAttrib4Niv_ARG_EXPAND);
typedef void (*glVertexAttrib4Niv_PTR)(glVertexAttrib4Niv_ARG_EXPAND);
#define glVertexAttrib4NivARB_INDEX 2419
#define glVertexAttrib4NivARB_RETURN void
#define glVertexAttrib4NivARB_ARG_NAMES index, v
#define glVertexAttrib4NivARB_ARG_EXPAND GLuint index, const GLint * v
#define glVertexAttrib4NivARB_PACKED PACKED_glVertexAttrib4NivARB
#define glVertexAttrib4NivARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttrib4NivARB_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttrib4NivARB(_index, _v) ({ \
    glVertexAttrib4NivARB_PACKED *packed_data = malloc(sizeof(glVertexAttrib4NivARB_PACKED)); \
    packed_data->index = glVertexAttrib4NivARB_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.v = (GLint *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttrib4NivARB(packed, ret_v) do { \
    PACKED_glVertexAttrib4NivARB *unpacked = (PACKED_glVertexAttrib4NivARB *)packed; \
    ARGS_glVertexAttrib4NivARB *args = (ARGS_glVertexAttrib4NivARB *)&unpacked->args; \
    glVertexAttrib4NivARB(args->index, args->v);; \
} while(0)
void glVertexAttrib4NivARB(glVertexAttrib4NivARB_ARG_EXPAND);
typedef void (*glVertexAttrib4NivARB_PTR)(glVertexAttrib4NivARB_ARG_EXPAND);
#define glVertexAttrib4Nsv_INDEX 2420
#define glVertexAttrib4Nsv_RETURN void
#define glVertexAttrib4Nsv_ARG_NAMES index, v
#define glVertexAttrib4Nsv_ARG_EXPAND GLuint index, const GLshort * v
#define glVertexAttrib4Nsv_PACKED PACKED_glVertexAttrib4Nsv
#define glVertexAttrib4Nsv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttrib4Nsv_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttrib4Nsv(_index, _v) ({ \
    glVertexAttrib4Nsv_PACKED *packed_data = malloc(sizeof(glVertexAttrib4Nsv_PACKED)); \
    packed_data->index = glVertexAttrib4Nsv_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.v = (GLshort *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttrib4Nsv(packed, ret_v) do { \
    PACKED_glVertexAttrib4Nsv *unpacked = (PACKED_glVertexAttrib4Nsv *)packed; \
    ARGS_glVertexAttrib4Nsv *args = (ARGS_glVertexAttrib4Nsv *)&unpacked->args; \
    glVertexAttrib4Nsv(args->index, args->v);; \
} while(0)
void glVertexAttrib4Nsv(glVertexAttrib4Nsv_ARG_EXPAND);
typedef void (*glVertexAttrib4Nsv_PTR)(glVertexAttrib4Nsv_ARG_EXPAND);
#define glVertexAttrib4NsvARB_INDEX 2421
#define glVertexAttrib4NsvARB_RETURN void
#define glVertexAttrib4NsvARB_ARG_NAMES index, v
#define glVertexAttrib4NsvARB_ARG_EXPAND GLuint index, const GLshort * v
#define glVertexAttrib4NsvARB_PACKED PACKED_glVertexAttrib4NsvARB
#define glVertexAttrib4NsvARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttrib4NsvARB_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttrib4NsvARB(_index, _v) ({ \
    glVertexAttrib4NsvARB_PACKED *packed_data = malloc(sizeof(glVertexAttrib4NsvARB_PACKED)); \
    packed_data->index = glVertexAttrib4NsvARB_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.v = (GLshort *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttrib4NsvARB(packed, ret_v) do { \
    PACKED_glVertexAttrib4NsvARB *unpacked = (PACKED_glVertexAttrib4NsvARB *)packed; \
    ARGS_glVertexAttrib4NsvARB *args = (ARGS_glVertexAttrib4NsvARB *)&unpacked->args; \
    glVertexAttrib4NsvARB(args->index, args->v);; \
} while(0)
void glVertexAttrib4NsvARB(glVertexAttrib4NsvARB_ARG_EXPAND);
typedef void (*glVertexAttrib4NsvARB_PTR)(glVertexAttrib4NsvARB_ARG_EXPAND);
#define glVertexAttrib4Nub_INDEX 2422
#define glVertexAttrib4Nub_RETURN void
#define glVertexAttrib4Nub_ARG_NAMES index, x, y, z, w
#define glVertexAttrib4Nub_ARG_EXPAND GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w
#define glVertexAttrib4Nub_PACKED PACKED_glVertexAttrib4Nub
#define glVertexAttrib4Nub_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttrib4Nub_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttrib4Nub(_index, _x, _y, _z, _w) ({ \
    glVertexAttrib4Nub_PACKED *packed_data = malloc(sizeof(glVertexAttrib4Nub_PACKED)); \
    packed_data->index = glVertexAttrib4Nub_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.x = (GLubyte)_x; \
    packed_data->args.y = (GLubyte)_y; \
    packed_data->args.z = (GLubyte)_z; \
    packed_data->args.w = (GLubyte)_w; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttrib4Nub(packed, ret_v) do { \
    PACKED_glVertexAttrib4Nub *unpacked = (PACKED_glVertexAttrib4Nub *)packed; \
    ARGS_glVertexAttrib4Nub *args = (ARGS_glVertexAttrib4Nub *)&unpacked->args; \
    glVertexAttrib4Nub(args->index, args->x, args->y, args->z, args->w);; \
} while(0)
void glVertexAttrib4Nub(glVertexAttrib4Nub_ARG_EXPAND);
typedef void (*glVertexAttrib4Nub_PTR)(glVertexAttrib4Nub_ARG_EXPAND);
#define glVertexAttrib4NubARB_INDEX 2423
#define glVertexAttrib4NubARB_RETURN void
#define glVertexAttrib4NubARB_ARG_NAMES index, x, y, z, w
#define glVertexAttrib4NubARB_ARG_EXPAND GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w
#define glVertexAttrib4NubARB_PACKED PACKED_glVertexAttrib4NubARB
#define glVertexAttrib4NubARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttrib4NubARB_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttrib4NubARB(_index, _x, _y, _z, _w) ({ \
    glVertexAttrib4NubARB_PACKED *packed_data = malloc(sizeof(glVertexAttrib4NubARB_PACKED)); \
    packed_data->index = glVertexAttrib4NubARB_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.x = (GLubyte)_x; \
    packed_data->args.y = (GLubyte)_y; \
    packed_data->args.z = (GLubyte)_z; \
    packed_data->args.w = (GLubyte)_w; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttrib4NubARB(packed, ret_v) do { \
    PACKED_glVertexAttrib4NubARB *unpacked = (PACKED_glVertexAttrib4NubARB *)packed; \
    ARGS_glVertexAttrib4NubARB *args = (ARGS_glVertexAttrib4NubARB *)&unpacked->args; \
    glVertexAttrib4NubARB(args->index, args->x, args->y, args->z, args->w);; \
} while(0)
void glVertexAttrib4NubARB(glVertexAttrib4NubARB_ARG_EXPAND);
typedef void (*glVertexAttrib4NubARB_PTR)(glVertexAttrib4NubARB_ARG_EXPAND);
#define glVertexAttrib4Nubv_INDEX 2424
#define glVertexAttrib4Nubv_RETURN void
#define glVertexAttrib4Nubv_ARG_NAMES index, v
#define glVertexAttrib4Nubv_ARG_EXPAND GLuint index, const GLubyte * v
#define glVertexAttrib4Nubv_PACKED PACKED_glVertexAttrib4Nubv
#define glVertexAttrib4Nubv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttrib4Nubv_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttrib4Nubv(_index, _v) ({ \
    glVertexAttrib4Nubv_PACKED *packed_data = malloc(sizeof(glVertexAttrib4Nubv_PACKED)); \
    packed_data->index = glVertexAttrib4Nubv_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.v = (GLubyte *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttrib4Nubv(packed, ret_v) do { \
    PACKED_glVertexAttrib4Nubv *unpacked = (PACKED_glVertexAttrib4Nubv *)packed; \
    ARGS_glVertexAttrib4Nubv *args = (ARGS_glVertexAttrib4Nubv *)&unpacked->args; \
    glVertexAttrib4Nubv(args->index, args->v);; \
} while(0)
void glVertexAttrib4Nubv(glVertexAttrib4Nubv_ARG_EXPAND);
typedef void (*glVertexAttrib4Nubv_PTR)(glVertexAttrib4Nubv_ARG_EXPAND);
#define glVertexAttrib4NubvARB_INDEX 2425
#define glVertexAttrib4NubvARB_RETURN void
#define glVertexAttrib4NubvARB_ARG_NAMES index, v
#define glVertexAttrib4NubvARB_ARG_EXPAND GLuint index, const GLubyte * v
#define glVertexAttrib4NubvARB_PACKED PACKED_glVertexAttrib4NubvARB
#define glVertexAttrib4NubvARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttrib4NubvARB_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttrib4NubvARB(_index, _v) ({ \
    glVertexAttrib4NubvARB_PACKED *packed_data = malloc(sizeof(glVertexAttrib4NubvARB_PACKED)); \
    packed_data->index = glVertexAttrib4NubvARB_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.v = (GLubyte *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttrib4NubvARB(packed, ret_v) do { \
    PACKED_glVertexAttrib4NubvARB *unpacked = (PACKED_glVertexAttrib4NubvARB *)packed; \
    ARGS_glVertexAttrib4NubvARB *args = (ARGS_glVertexAttrib4NubvARB *)&unpacked->args; \
    glVertexAttrib4NubvARB(args->index, args->v);; \
} while(0)
void glVertexAttrib4NubvARB(glVertexAttrib4NubvARB_ARG_EXPAND);
typedef void (*glVertexAttrib4NubvARB_PTR)(glVertexAttrib4NubvARB_ARG_EXPAND);
#define glVertexAttrib4Nuiv_INDEX 2426
#define glVertexAttrib4Nuiv_RETURN void
#define glVertexAttrib4Nuiv_ARG_NAMES index, v
#define glVertexAttrib4Nuiv_ARG_EXPAND GLuint index, const GLuint * v
#define glVertexAttrib4Nuiv_PACKED PACKED_glVertexAttrib4Nuiv
#define glVertexAttrib4Nuiv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttrib4Nuiv_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttrib4Nuiv(_index, _v) ({ \
    glVertexAttrib4Nuiv_PACKED *packed_data = malloc(sizeof(glVertexAttrib4Nuiv_PACKED)); \
    packed_data->index = glVertexAttrib4Nuiv_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.v = (GLuint *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttrib4Nuiv(packed, ret_v) do { \
    PACKED_glVertexAttrib4Nuiv *unpacked = (PACKED_glVertexAttrib4Nuiv *)packed; \
    ARGS_glVertexAttrib4Nuiv *args = (ARGS_glVertexAttrib4Nuiv *)&unpacked->args; \
    glVertexAttrib4Nuiv(args->index, args->v);; \
} while(0)
void glVertexAttrib4Nuiv(glVertexAttrib4Nuiv_ARG_EXPAND);
typedef void (*glVertexAttrib4Nuiv_PTR)(glVertexAttrib4Nuiv_ARG_EXPAND);
#define glVertexAttrib4NuivARB_INDEX 2427
#define glVertexAttrib4NuivARB_RETURN void
#define glVertexAttrib4NuivARB_ARG_NAMES index, v
#define glVertexAttrib4NuivARB_ARG_EXPAND GLuint index, const GLuint * v
#define glVertexAttrib4NuivARB_PACKED PACKED_glVertexAttrib4NuivARB
#define glVertexAttrib4NuivARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttrib4NuivARB_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttrib4NuivARB(_index, _v) ({ \
    glVertexAttrib4NuivARB_PACKED *packed_data = malloc(sizeof(glVertexAttrib4NuivARB_PACKED)); \
    packed_data->index = glVertexAttrib4NuivARB_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.v = (GLuint *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttrib4NuivARB(packed, ret_v) do { \
    PACKED_glVertexAttrib4NuivARB *unpacked = (PACKED_glVertexAttrib4NuivARB *)packed; \
    ARGS_glVertexAttrib4NuivARB *args = (ARGS_glVertexAttrib4NuivARB *)&unpacked->args; \
    glVertexAttrib4NuivARB(args->index, args->v);; \
} while(0)
void glVertexAttrib4NuivARB(glVertexAttrib4NuivARB_ARG_EXPAND);
typedef void (*glVertexAttrib4NuivARB_PTR)(glVertexAttrib4NuivARB_ARG_EXPAND);
#define glVertexAttrib4Nusv_INDEX 2428
#define glVertexAttrib4Nusv_RETURN void
#define glVertexAttrib4Nusv_ARG_NAMES index, v
#define glVertexAttrib4Nusv_ARG_EXPAND GLuint index, const GLushort * v
#define glVertexAttrib4Nusv_PACKED PACKED_glVertexAttrib4Nusv
#define glVertexAttrib4Nusv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttrib4Nusv_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttrib4Nusv(_index, _v) ({ \
    glVertexAttrib4Nusv_PACKED *packed_data = malloc(sizeof(glVertexAttrib4Nusv_PACKED)); \
    packed_data->index = glVertexAttrib4Nusv_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.v = (GLushort *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttrib4Nusv(packed, ret_v) do { \
    PACKED_glVertexAttrib4Nusv *unpacked = (PACKED_glVertexAttrib4Nusv *)packed; \
    ARGS_glVertexAttrib4Nusv *args = (ARGS_glVertexAttrib4Nusv *)&unpacked->args; \
    glVertexAttrib4Nusv(args->index, args->v);; \
} while(0)
void glVertexAttrib4Nusv(glVertexAttrib4Nusv_ARG_EXPAND);
typedef void (*glVertexAttrib4Nusv_PTR)(glVertexAttrib4Nusv_ARG_EXPAND);
#define glVertexAttrib4NusvARB_INDEX 2429
#define glVertexAttrib4NusvARB_RETURN void
#define glVertexAttrib4NusvARB_ARG_NAMES index, v
#define glVertexAttrib4NusvARB_ARG_EXPAND GLuint index, const GLushort * v
#define glVertexAttrib4NusvARB_PACKED PACKED_glVertexAttrib4NusvARB
#define glVertexAttrib4NusvARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttrib4NusvARB_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttrib4NusvARB(_index, _v) ({ \
    glVertexAttrib4NusvARB_PACKED *packed_data = malloc(sizeof(glVertexAttrib4NusvARB_PACKED)); \
    packed_data->index = glVertexAttrib4NusvARB_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.v = (GLushort *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttrib4NusvARB(packed, ret_v) do { \
    PACKED_glVertexAttrib4NusvARB *unpacked = (PACKED_glVertexAttrib4NusvARB *)packed; \
    ARGS_glVertexAttrib4NusvARB *args = (ARGS_glVertexAttrib4NusvARB *)&unpacked->args; \
    glVertexAttrib4NusvARB(args->index, args->v);; \
} while(0)
void glVertexAttrib4NusvARB(glVertexAttrib4NusvARB_ARG_EXPAND);
typedef void (*glVertexAttrib4NusvARB_PTR)(glVertexAttrib4NusvARB_ARG_EXPAND);
#define glVertexAttrib4bv_INDEX 2430
#define glVertexAttrib4bv_RETURN void
#define glVertexAttrib4bv_ARG_NAMES index, v
#define glVertexAttrib4bv_ARG_EXPAND GLuint index, const GLbyte * v
#define glVertexAttrib4bv_PACKED PACKED_glVertexAttrib4bv
#define glVertexAttrib4bv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttrib4bv_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttrib4bv(_index, _v) ({ \
    glVertexAttrib4bv_PACKED *packed_data = malloc(sizeof(glVertexAttrib4bv_PACKED)); \
    packed_data->index = glVertexAttrib4bv_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.v = (GLbyte *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttrib4bv(packed, ret_v) do { \
    PACKED_glVertexAttrib4bv *unpacked = (PACKED_glVertexAttrib4bv *)packed; \
    ARGS_glVertexAttrib4bv *args = (ARGS_glVertexAttrib4bv *)&unpacked->args; \
    glVertexAttrib4bv(args->index, args->v);; \
} while(0)
void glVertexAttrib4bv(glVertexAttrib4bv_ARG_EXPAND);
typedef void (*glVertexAttrib4bv_PTR)(glVertexAttrib4bv_ARG_EXPAND);
#define glVertexAttrib4bvARB_INDEX 2431
#define glVertexAttrib4bvARB_RETURN void
#define glVertexAttrib4bvARB_ARG_NAMES index, v
#define glVertexAttrib4bvARB_ARG_EXPAND GLuint index, const GLbyte * v
#define glVertexAttrib4bvARB_PACKED PACKED_glVertexAttrib4bvARB
#define glVertexAttrib4bvARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttrib4bvARB_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttrib4bvARB(_index, _v) ({ \
    glVertexAttrib4bvARB_PACKED *packed_data = malloc(sizeof(glVertexAttrib4bvARB_PACKED)); \
    packed_data->index = glVertexAttrib4bvARB_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.v = (GLbyte *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttrib4bvARB(packed, ret_v) do { \
    PACKED_glVertexAttrib4bvARB *unpacked = (PACKED_glVertexAttrib4bvARB *)packed; \
    ARGS_glVertexAttrib4bvARB *args = (ARGS_glVertexAttrib4bvARB *)&unpacked->args; \
    glVertexAttrib4bvARB(args->index, args->v);; \
} while(0)
void glVertexAttrib4bvARB(glVertexAttrib4bvARB_ARG_EXPAND);
typedef void (*glVertexAttrib4bvARB_PTR)(glVertexAttrib4bvARB_ARG_EXPAND);
#define glVertexAttrib4d_INDEX 2432
#define glVertexAttrib4d_RETURN void
#define glVertexAttrib4d_ARG_NAMES index, x, y, z, w
#define glVertexAttrib4d_ARG_EXPAND GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w
#define glVertexAttrib4d_PACKED PACKED_glVertexAttrib4d
#define glVertexAttrib4d_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttrib4d_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttrib4d(_index, _x, _y, _z, _w) ({ \
    glVertexAttrib4d_PACKED *packed_data = malloc(sizeof(glVertexAttrib4d_PACKED)); \
    packed_data->index = glVertexAttrib4d_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.x = (GLdouble)_x; \
    packed_data->args.y = (GLdouble)_y; \
    packed_data->args.z = (GLdouble)_z; \
    packed_data->args.w = (GLdouble)_w; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttrib4d(packed, ret_v) do { \
    PACKED_glVertexAttrib4d *unpacked = (PACKED_glVertexAttrib4d *)packed; \
    ARGS_glVertexAttrib4d *args = (ARGS_glVertexAttrib4d *)&unpacked->args; \
    glVertexAttrib4d(args->index, args->x, args->y, args->z, args->w);; \
} while(0)
void glVertexAttrib4d(glVertexAttrib4d_ARG_EXPAND);
typedef void (*glVertexAttrib4d_PTR)(glVertexAttrib4d_ARG_EXPAND);
#define glVertexAttrib4dARB_INDEX 2433
#define glVertexAttrib4dARB_RETURN void
#define glVertexAttrib4dARB_ARG_NAMES index, x, y, z, w
#define glVertexAttrib4dARB_ARG_EXPAND GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w
#define glVertexAttrib4dARB_PACKED PACKED_glVertexAttrib4dARB
#define glVertexAttrib4dARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttrib4dARB_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttrib4dARB(_index, _x, _y, _z, _w) ({ \
    glVertexAttrib4dARB_PACKED *packed_data = malloc(sizeof(glVertexAttrib4dARB_PACKED)); \
    packed_data->index = glVertexAttrib4dARB_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.x = (GLdouble)_x; \
    packed_data->args.y = (GLdouble)_y; \
    packed_data->args.z = (GLdouble)_z; \
    packed_data->args.w = (GLdouble)_w; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttrib4dARB(packed, ret_v) do { \
    PACKED_glVertexAttrib4dARB *unpacked = (PACKED_glVertexAttrib4dARB *)packed; \
    ARGS_glVertexAttrib4dARB *args = (ARGS_glVertexAttrib4dARB *)&unpacked->args; \
    glVertexAttrib4dARB(args->index, args->x, args->y, args->z, args->w);; \
} while(0)
void glVertexAttrib4dARB(glVertexAttrib4dARB_ARG_EXPAND);
typedef void (*glVertexAttrib4dARB_PTR)(glVertexAttrib4dARB_ARG_EXPAND);
#define glVertexAttrib4dNV_INDEX 2434
#define glVertexAttrib4dNV_RETURN void
#define glVertexAttrib4dNV_ARG_NAMES index, x, y, z, w
#define glVertexAttrib4dNV_ARG_EXPAND GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w
#define glVertexAttrib4dNV_PACKED PACKED_glVertexAttrib4dNV
#define glVertexAttrib4dNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttrib4dNV_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttrib4dNV(_index, _x, _y, _z, _w) ({ \
    glVertexAttrib4dNV_PACKED *packed_data = malloc(sizeof(glVertexAttrib4dNV_PACKED)); \
    packed_data->index = glVertexAttrib4dNV_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.x = (GLdouble)_x; \
    packed_data->args.y = (GLdouble)_y; \
    packed_data->args.z = (GLdouble)_z; \
    packed_data->args.w = (GLdouble)_w; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttrib4dNV(packed, ret_v) do { \
    PACKED_glVertexAttrib4dNV *unpacked = (PACKED_glVertexAttrib4dNV *)packed; \
    ARGS_glVertexAttrib4dNV *args = (ARGS_glVertexAttrib4dNV *)&unpacked->args; \
    glVertexAttrib4dNV(args->index, args->x, args->y, args->z, args->w);; \
} while(0)
void glVertexAttrib4dNV(glVertexAttrib4dNV_ARG_EXPAND);
typedef void (*glVertexAttrib4dNV_PTR)(glVertexAttrib4dNV_ARG_EXPAND);
#define glVertexAttrib4dv_INDEX 2435
#define glVertexAttrib4dv_RETURN void
#define glVertexAttrib4dv_ARG_NAMES index, v
#define glVertexAttrib4dv_ARG_EXPAND GLuint index, const GLdouble * v
#define glVertexAttrib4dv_PACKED PACKED_glVertexAttrib4dv
#define glVertexAttrib4dv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttrib4dv_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttrib4dv(_index, _v) ({ \
    glVertexAttrib4dv_PACKED *packed_data = malloc(sizeof(glVertexAttrib4dv_PACKED)); \
    packed_data->index = glVertexAttrib4dv_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.v = (GLdouble *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttrib4dv(packed, ret_v) do { \
    PACKED_glVertexAttrib4dv *unpacked = (PACKED_glVertexAttrib4dv *)packed; \
    ARGS_glVertexAttrib4dv *args = (ARGS_glVertexAttrib4dv *)&unpacked->args; \
    glVertexAttrib4dv(args->index, args->v);; \
} while(0)
void glVertexAttrib4dv(glVertexAttrib4dv_ARG_EXPAND);
typedef void (*glVertexAttrib4dv_PTR)(glVertexAttrib4dv_ARG_EXPAND);
#define glVertexAttrib4dvARB_INDEX 2436
#define glVertexAttrib4dvARB_RETURN void
#define glVertexAttrib4dvARB_ARG_NAMES index, v
#define glVertexAttrib4dvARB_ARG_EXPAND GLuint index, const GLdouble * v
#define glVertexAttrib4dvARB_PACKED PACKED_glVertexAttrib4dvARB
#define glVertexAttrib4dvARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttrib4dvARB_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttrib4dvARB(_index, _v) ({ \
    glVertexAttrib4dvARB_PACKED *packed_data = malloc(sizeof(glVertexAttrib4dvARB_PACKED)); \
    packed_data->index = glVertexAttrib4dvARB_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.v = (GLdouble *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttrib4dvARB(packed, ret_v) do { \
    PACKED_glVertexAttrib4dvARB *unpacked = (PACKED_glVertexAttrib4dvARB *)packed; \
    ARGS_glVertexAttrib4dvARB *args = (ARGS_glVertexAttrib4dvARB *)&unpacked->args; \
    glVertexAttrib4dvARB(args->index, args->v);; \
} while(0)
void glVertexAttrib4dvARB(glVertexAttrib4dvARB_ARG_EXPAND);
typedef void (*glVertexAttrib4dvARB_PTR)(glVertexAttrib4dvARB_ARG_EXPAND);
#define glVertexAttrib4dvNV_INDEX 2437
#define glVertexAttrib4dvNV_RETURN void
#define glVertexAttrib4dvNV_ARG_NAMES index, v
#define glVertexAttrib4dvNV_ARG_EXPAND GLuint index, const GLdouble * v
#define glVertexAttrib4dvNV_PACKED PACKED_glVertexAttrib4dvNV
#define glVertexAttrib4dvNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttrib4dvNV_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttrib4dvNV(_index, _v) ({ \
    glVertexAttrib4dvNV_PACKED *packed_data = malloc(sizeof(glVertexAttrib4dvNV_PACKED)); \
    packed_data->index = glVertexAttrib4dvNV_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.v = (GLdouble *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttrib4dvNV(packed, ret_v) do { \
    PACKED_glVertexAttrib4dvNV *unpacked = (PACKED_glVertexAttrib4dvNV *)packed; \
    ARGS_glVertexAttrib4dvNV *args = (ARGS_glVertexAttrib4dvNV *)&unpacked->args; \
    glVertexAttrib4dvNV(args->index, args->v);; \
} while(0)
void glVertexAttrib4dvNV(glVertexAttrib4dvNV_ARG_EXPAND);
typedef void (*glVertexAttrib4dvNV_PTR)(glVertexAttrib4dvNV_ARG_EXPAND);
#define glVertexAttrib4f_INDEX 2438
#define glVertexAttrib4f_RETURN void
#define glVertexAttrib4f_ARG_NAMES index, x, y, z, w
#define glVertexAttrib4f_ARG_EXPAND GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w
#define glVertexAttrib4f_PACKED PACKED_glVertexAttrib4f
#define glVertexAttrib4f_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttrib4f_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttrib4f(_index, _x, _y, _z, _w) ({ \
    glVertexAttrib4f_PACKED *packed_data = malloc(sizeof(glVertexAttrib4f_PACKED)); \
    packed_data->index = glVertexAttrib4f_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.x = (GLfloat)_x; \
    packed_data->args.y = (GLfloat)_y; \
    packed_data->args.z = (GLfloat)_z; \
    packed_data->args.w = (GLfloat)_w; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttrib4f(packed, ret_v) do { \
    PACKED_glVertexAttrib4f *unpacked = (PACKED_glVertexAttrib4f *)packed; \
    ARGS_glVertexAttrib4f *args = (ARGS_glVertexAttrib4f *)&unpacked->args; \
    glVertexAttrib4f(args->index, args->x, args->y, args->z, args->w);; \
} while(0)
void glVertexAttrib4f(glVertexAttrib4f_ARG_EXPAND);
typedef void (*glVertexAttrib4f_PTR)(glVertexAttrib4f_ARG_EXPAND);
#define glVertexAttrib4fARB_INDEX 2439
#define glVertexAttrib4fARB_RETURN void
#define glVertexAttrib4fARB_ARG_NAMES index, x, y, z, w
#define glVertexAttrib4fARB_ARG_EXPAND GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w
#define glVertexAttrib4fARB_PACKED PACKED_glVertexAttrib4fARB
#define glVertexAttrib4fARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttrib4fARB_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttrib4fARB(_index, _x, _y, _z, _w) ({ \
    glVertexAttrib4fARB_PACKED *packed_data = malloc(sizeof(glVertexAttrib4fARB_PACKED)); \
    packed_data->index = glVertexAttrib4fARB_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.x = (GLfloat)_x; \
    packed_data->args.y = (GLfloat)_y; \
    packed_data->args.z = (GLfloat)_z; \
    packed_data->args.w = (GLfloat)_w; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttrib4fARB(packed, ret_v) do { \
    PACKED_glVertexAttrib4fARB *unpacked = (PACKED_glVertexAttrib4fARB *)packed; \
    ARGS_glVertexAttrib4fARB *args = (ARGS_glVertexAttrib4fARB *)&unpacked->args; \
    glVertexAttrib4fARB(args->index, args->x, args->y, args->z, args->w);; \
} while(0)
void glVertexAttrib4fARB(glVertexAttrib4fARB_ARG_EXPAND);
typedef void (*glVertexAttrib4fARB_PTR)(glVertexAttrib4fARB_ARG_EXPAND);
#define glVertexAttrib4fNV_INDEX 2440
#define glVertexAttrib4fNV_RETURN void
#define glVertexAttrib4fNV_ARG_NAMES index, x, y, z, w
#define glVertexAttrib4fNV_ARG_EXPAND GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w
#define glVertexAttrib4fNV_PACKED PACKED_glVertexAttrib4fNV
#define glVertexAttrib4fNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttrib4fNV_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttrib4fNV(_index, _x, _y, _z, _w) ({ \
    glVertexAttrib4fNV_PACKED *packed_data = malloc(sizeof(glVertexAttrib4fNV_PACKED)); \
    packed_data->index = glVertexAttrib4fNV_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.x = (GLfloat)_x; \
    packed_data->args.y = (GLfloat)_y; \
    packed_data->args.z = (GLfloat)_z; \
    packed_data->args.w = (GLfloat)_w; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttrib4fNV(packed, ret_v) do { \
    PACKED_glVertexAttrib4fNV *unpacked = (PACKED_glVertexAttrib4fNV *)packed; \
    ARGS_glVertexAttrib4fNV *args = (ARGS_glVertexAttrib4fNV *)&unpacked->args; \
    glVertexAttrib4fNV(args->index, args->x, args->y, args->z, args->w);; \
} while(0)
void glVertexAttrib4fNV(glVertexAttrib4fNV_ARG_EXPAND);
typedef void (*glVertexAttrib4fNV_PTR)(glVertexAttrib4fNV_ARG_EXPAND);
#define glVertexAttrib4fv_INDEX 2441
#define glVertexAttrib4fv_RETURN void
#define glVertexAttrib4fv_ARG_NAMES index, v
#define glVertexAttrib4fv_ARG_EXPAND GLuint index, const GLfloat * v
#define glVertexAttrib4fv_PACKED PACKED_glVertexAttrib4fv
#define glVertexAttrib4fv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttrib4fv_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttrib4fv(_index, _v) ({ \
    glVertexAttrib4fv_PACKED *packed_data = malloc(sizeof(glVertexAttrib4fv_PACKED)); \
    packed_data->index = glVertexAttrib4fv_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.v = (GLfloat *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttrib4fv(packed, ret_v) do { \
    PACKED_glVertexAttrib4fv *unpacked = (PACKED_glVertexAttrib4fv *)packed; \
    ARGS_glVertexAttrib4fv *args = (ARGS_glVertexAttrib4fv *)&unpacked->args; \
    glVertexAttrib4fv(args->index, args->v);; \
} while(0)
void glVertexAttrib4fv(glVertexAttrib4fv_ARG_EXPAND);
typedef void (*glVertexAttrib4fv_PTR)(glVertexAttrib4fv_ARG_EXPAND);
#define glVertexAttrib4fvARB_INDEX 2442
#define glVertexAttrib4fvARB_RETURN void
#define glVertexAttrib4fvARB_ARG_NAMES index, v
#define glVertexAttrib4fvARB_ARG_EXPAND GLuint index, const GLfloat * v
#define glVertexAttrib4fvARB_PACKED PACKED_glVertexAttrib4fvARB
#define glVertexAttrib4fvARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttrib4fvARB_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttrib4fvARB(_index, _v) ({ \
    glVertexAttrib4fvARB_PACKED *packed_data = malloc(sizeof(glVertexAttrib4fvARB_PACKED)); \
    packed_data->index = glVertexAttrib4fvARB_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.v = (GLfloat *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttrib4fvARB(packed, ret_v) do { \
    PACKED_glVertexAttrib4fvARB *unpacked = (PACKED_glVertexAttrib4fvARB *)packed; \
    ARGS_glVertexAttrib4fvARB *args = (ARGS_glVertexAttrib4fvARB *)&unpacked->args; \
    glVertexAttrib4fvARB(args->index, args->v);; \
} while(0)
void glVertexAttrib4fvARB(glVertexAttrib4fvARB_ARG_EXPAND);
typedef void (*glVertexAttrib4fvARB_PTR)(glVertexAttrib4fvARB_ARG_EXPAND);
#define glVertexAttrib4fvNV_INDEX 2443
#define glVertexAttrib4fvNV_RETURN void
#define glVertexAttrib4fvNV_ARG_NAMES index, v
#define glVertexAttrib4fvNV_ARG_EXPAND GLuint index, const GLfloat * v
#define glVertexAttrib4fvNV_PACKED PACKED_glVertexAttrib4fvNV
#define glVertexAttrib4fvNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttrib4fvNV_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttrib4fvNV(_index, _v) ({ \
    glVertexAttrib4fvNV_PACKED *packed_data = malloc(sizeof(glVertexAttrib4fvNV_PACKED)); \
    packed_data->index = glVertexAttrib4fvNV_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.v = (GLfloat *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttrib4fvNV(packed, ret_v) do { \
    PACKED_glVertexAttrib4fvNV *unpacked = (PACKED_glVertexAttrib4fvNV *)packed; \
    ARGS_glVertexAttrib4fvNV *args = (ARGS_glVertexAttrib4fvNV *)&unpacked->args; \
    glVertexAttrib4fvNV(args->index, args->v);; \
} while(0)
void glVertexAttrib4fvNV(glVertexAttrib4fvNV_ARG_EXPAND);
typedef void (*glVertexAttrib4fvNV_PTR)(glVertexAttrib4fvNV_ARG_EXPAND);
#define glVertexAttrib4hNV_INDEX 2444
#define glVertexAttrib4hNV_RETURN void
#define glVertexAttrib4hNV_ARG_NAMES index, x, y, z, w
#define glVertexAttrib4hNV_ARG_EXPAND GLuint index, GLhalfNV x, GLhalfNV y, GLhalfNV z, GLhalfNV w
#define glVertexAttrib4hNV_PACKED PACKED_glVertexAttrib4hNV
#define glVertexAttrib4hNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttrib4hNV_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttrib4hNV(_index, _x, _y, _z, _w) ({ \
    glVertexAttrib4hNV_PACKED *packed_data = malloc(sizeof(glVertexAttrib4hNV_PACKED)); \
    packed_data->index = glVertexAttrib4hNV_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.x = (GLhalfNV)_x; \
    packed_data->args.y = (GLhalfNV)_y; \
    packed_data->args.z = (GLhalfNV)_z; \
    packed_data->args.w = (GLhalfNV)_w; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttrib4hNV(packed, ret_v) do { \
    PACKED_glVertexAttrib4hNV *unpacked = (PACKED_glVertexAttrib4hNV *)packed; \
    ARGS_glVertexAttrib4hNV *args = (ARGS_glVertexAttrib4hNV *)&unpacked->args; \
    glVertexAttrib4hNV(args->index, args->x, args->y, args->z, args->w);; \
} while(0)
void glVertexAttrib4hNV(glVertexAttrib4hNV_ARG_EXPAND);
typedef void (*glVertexAttrib4hNV_PTR)(glVertexAttrib4hNV_ARG_EXPAND);
#define glVertexAttrib4hvNV_INDEX 2445
#define glVertexAttrib4hvNV_RETURN void
#define glVertexAttrib4hvNV_ARG_NAMES index, v
#define glVertexAttrib4hvNV_ARG_EXPAND GLuint index, const GLhalfNV * v
#define glVertexAttrib4hvNV_PACKED PACKED_glVertexAttrib4hvNV
#define glVertexAttrib4hvNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttrib4hvNV_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttrib4hvNV(_index, _v) ({ \
    glVertexAttrib4hvNV_PACKED *packed_data = malloc(sizeof(glVertexAttrib4hvNV_PACKED)); \
    packed_data->index = glVertexAttrib4hvNV_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.v = (GLhalfNV *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttrib4hvNV(packed, ret_v) do { \
    PACKED_glVertexAttrib4hvNV *unpacked = (PACKED_glVertexAttrib4hvNV *)packed; \
    ARGS_glVertexAttrib4hvNV *args = (ARGS_glVertexAttrib4hvNV *)&unpacked->args; \
    glVertexAttrib4hvNV(args->index, args->v);; \
} while(0)
void glVertexAttrib4hvNV(glVertexAttrib4hvNV_ARG_EXPAND);
typedef void (*glVertexAttrib4hvNV_PTR)(glVertexAttrib4hvNV_ARG_EXPAND);
#define glVertexAttrib4iv_INDEX 2446
#define glVertexAttrib4iv_RETURN void
#define glVertexAttrib4iv_ARG_NAMES index, v
#define glVertexAttrib4iv_ARG_EXPAND GLuint index, const GLint * v
#define glVertexAttrib4iv_PACKED PACKED_glVertexAttrib4iv
#define glVertexAttrib4iv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttrib4iv_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttrib4iv(_index, _v) ({ \
    glVertexAttrib4iv_PACKED *packed_data = malloc(sizeof(glVertexAttrib4iv_PACKED)); \
    packed_data->index = glVertexAttrib4iv_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.v = (GLint *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttrib4iv(packed, ret_v) do { \
    PACKED_glVertexAttrib4iv *unpacked = (PACKED_glVertexAttrib4iv *)packed; \
    ARGS_glVertexAttrib4iv *args = (ARGS_glVertexAttrib4iv *)&unpacked->args; \
    glVertexAttrib4iv(args->index, args->v);; \
} while(0)
void glVertexAttrib4iv(glVertexAttrib4iv_ARG_EXPAND);
typedef void (*glVertexAttrib4iv_PTR)(glVertexAttrib4iv_ARG_EXPAND);
#define glVertexAttrib4ivARB_INDEX 2447
#define glVertexAttrib4ivARB_RETURN void
#define glVertexAttrib4ivARB_ARG_NAMES index, v
#define glVertexAttrib4ivARB_ARG_EXPAND GLuint index, const GLint * v
#define glVertexAttrib4ivARB_PACKED PACKED_glVertexAttrib4ivARB
#define glVertexAttrib4ivARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttrib4ivARB_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttrib4ivARB(_index, _v) ({ \
    glVertexAttrib4ivARB_PACKED *packed_data = malloc(sizeof(glVertexAttrib4ivARB_PACKED)); \
    packed_data->index = glVertexAttrib4ivARB_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.v = (GLint *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttrib4ivARB(packed, ret_v) do { \
    PACKED_glVertexAttrib4ivARB *unpacked = (PACKED_glVertexAttrib4ivARB *)packed; \
    ARGS_glVertexAttrib4ivARB *args = (ARGS_glVertexAttrib4ivARB *)&unpacked->args; \
    glVertexAttrib4ivARB(args->index, args->v);; \
} while(0)
void glVertexAttrib4ivARB(glVertexAttrib4ivARB_ARG_EXPAND);
typedef void (*glVertexAttrib4ivARB_PTR)(glVertexAttrib4ivARB_ARG_EXPAND);
#define glVertexAttrib4s_INDEX 2448
#define glVertexAttrib4s_RETURN void
#define glVertexAttrib4s_ARG_NAMES index, x, y, z, w
#define glVertexAttrib4s_ARG_EXPAND GLuint index, GLshort x, GLshort y, GLshort z, GLshort w
#define glVertexAttrib4s_PACKED PACKED_glVertexAttrib4s
#define glVertexAttrib4s_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttrib4s_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttrib4s(_index, _x, _y, _z, _w) ({ \
    glVertexAttrib4s_PACKED *packed_data = malloc(sizeof(glVertexAttrib4s_PACKED)); \
    packed_data->index = glVertexAttrib4s_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.x = (GLshort)_x; \
    packed_data->args.y = (GLshort)_y; \
    packed_data->args.z = (GLshort)_z; \
    packed_data->args.w = (GLshort)_w; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttrib4s(packed, ret_v) do { \
    PACKED_glVertexAttrib4s *unpacked = (PACKED_glVertexAttrib4s *)packed; \
    ARGS_glVertexAttrib4s *args = (ARGS_glVertexAttrib4s *)&unpacked->args; \
    glVertexAttrib4s(args->index, args->x, args->y, args->z, args->w);; \
} while(0)
void glVertexAttrib4s(glVertexAttrib4s_ARG_EXPAND);
typedef void (*glVertexAttrib4s_PTR)(glVertexAttrib4s_ARG_EXPAND);
#define glVertexAttrib4sARB_INDEX 2449
#define glVertexAttrib4sARB_RETURN void
#define glVertexAttrib4sARB_ARG_NAMES index, x, y, z, w
#define glVertexAttrib4sARB_ARG_EXPAND GLuint index, GLshort x, GLshort y, GLshort z, GLshort w
#define glVertexAttrib4sARB_PACKED PACKED_glVertexAttrib4sARB
#define glVertexAttrib4sARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttrib4sARB_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttrib4sARB(_index, _x, _y, _z, _w) ({ \
    glVertexAttrib4sARB_PACKED *packed_data = malloc(sizeof(glVertexAttrib4sARB_PACKED)); \
    packed_data->index = glVertexAttrib4sARB_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.x = (GLshort)_x; \
    packed_data->args.y = (GLshort)_y; \
    packed_data->args.z = (GLshort)_z; \
    packed_data->args.w = (GLshort)_w; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttrib4sARB(packed, ret_v) do { \
    PACKED_glVertexAttrib4sARB *unpacked = (PACKED_glVertexAttrib4sARB *)packed; \
    ARGS_glVertexAttrib4sARB *args = (ARGS_glVertexAttrib4sARB *)&unpacked->args; \
    glVertexAttrib4sARB(args->index, args->x, args->y, args->z, args->w);; \
} while(0)
void glVertexAttrib4sARB(glVertexAttrib4sARB_ARG_EXPAND);
typedef void (*glVertexAttrib4sARB_PTR)(glVertexAttrib4sARB_ARG_EXPAND);
#define glVertexAttrib4sNV_INDEX 2450
#define glVertexAttrib4sNV_RETURN void
#define glVertexAttrib4sNV_ARG_NAMES index, x, y, z, w
#define glVertexAttrib4sNV_ARG_EXPAND GLuint index, GLshort x, GLshort y, GLshort z, GLshort w
#define glVertexAttrib4sNV_PACKED PACKED_glVertexAttrib4sNV
#define glVertexAttrib4sNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttrib4sNV_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttrib4sNV(_index, _x, _y, _z, _w) ({ \
    glVertexAttrib4sNV_PACKED *packed_data = malloc(sizeof(glVertexAttrib4sNV_PACKED)); \
    packed_data->index = glVertexAttrib4sNV_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.x = (GLshort)_x; \
    packed_data->args.y = (GLshort)_y; \
    packed_data->args.z = (GLshort)_z; \
    packed_data->args.w = (GLshort)_w; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttrib4sNV(packed, ret_v) do { \
    PACKED_glVertexAttrib4sNV *unpacked = (PACKED_glVertexAttrib4sNV *)packed; \
    ARGS_glVertexAttrib4sNV *args = (ARGS_glVertexAttrib4sNV *)&unpacked->args; \
    glVertexAttrib4sNV(args->index, args->x, args->y, args->z, args->w);; \
} while(0)
void glVertexAttrib4sNV(glVertexAttrib4sNV_ARG_EXPAND);
typedef void (*glVertexAttrib4sNV_PTR)(glVertexAttrib4sNV_ARG_EXPAND);
#define glVertexAttrib4sv_INDEX 2451
#define glVertexAttrib4sv_RETURN void
#define glVertexAttrib4sv_ARG_NAMES index, v
#define glVertexAttrib4sv_ARG_EXPAND GLuint index, const GLshort * v
#define glVertexAttrib4sv_PACKED PACKED_glVertexAttrib4sv
#define glVertexAttrib4sv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttrib4sv_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttrib4sv(_index, _v) ({ \
    glVertexAttrib4sv_PACKED *packed_data = malloc(sizeof(glVertexAttrib4sv_PACKED)); \
    packed_data->index = glVertexAttrib4sv_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.v = (GLshort *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttrib4sv(packed, ret_v) do { \
    PACKED_glVertexAttrib4sv *unpacked = (PACKED_glVertexAttrib4sv *)packed; \
    ARGS_glVertexAttrib4sv *args = (ARGS_glVertexAttrib4sv *)&unpacked->args; \
    glVertexAttrib4sv(args->index, args->v);; \
} while(0)
void glVertexAttrib4sv(glVertexAttrib4sv_ARG_EXPAND);
typedef void (*glVertexAttrib4sv_PTR)(glVertexAttrib4sv_ARG_EXPAND);
#define glVertexAttrib4svARB_INDEX 2452
#define glVertexAttrib4svARB_RETURN void
#define glVertexAttrib4svARB_ARG_NAMES index, v
#define glVertexAttrib4svARB_ARG_EXPAND GLuint index, const GLshort * v
#define glVertexAttrib4svARB_PACKED PACKED_glVertexAttrib4svARB
#define glVertexAttrib4svARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttrib4svARB_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttrib4svARB(_index, _v) ({ \
    glVertexAttrib4svARB_PACKED *packed_data = malloc(sizeof(glVertexAttrib4svARB_PACKED)); \
    packed_data->index = glVertexAttrib4svARB_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.v = (GLshort *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttrib4svARB(packed, ret_v) do { \
    PACKED_glVertexAttrib4svARB *unpacked = (PACKED_glVertexAttrib4svARB *)packed; \
    ARGS_glVertexAttrib4svARB *args = (ARGS_glVertexAttrib4svARB *)&unpacked->args; \
    glVertexAttrib4svARB(args->index, args->v);; \
} while(0)
void glVertexAttrib4svARB(glVertexAttrib4svARB_ARG_EXPAND);
typedef void (*glVertexAttrib4svARB_PTR)(glVertexAttrib4svARB_ARG_EXPAND);
#define glVertexAttrib4svNV_INDEX 2453
#define glVertexAttrib4svNV_RETURN void
#define glVertexAttrib4svNV_ARG_NAMES index, v
#define glVertexAttrib4svNV_ARG_EXPAND GLuint index, const GLshort * v
#define glVertexAttrib4svNV_PACKED PACKED_glVertexAttrib4svNV
#define glVertexAttrib4svNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttrib4svNV_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttrib4svNV(_index, _v) ({ \
    glVertexAttrib4svNV_PACKED *packed_data = malloc(sizeof(glVertexAttrib4svNV_PACKED)); \
    packed_data->index = glVertexAttrib4svNV_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.v = (GLshort *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttrib4svNV(packed, ret_v) do { \
    PACKED_glVertexAttrib4svNV *unpacked = (PACKED_glVertexAttrib4svNV *)packed; \
    ARGS_glVertexAttrib4svNV *args = (ARGS_glVertexAttrib4svNV *)&unpacked->args; \
    glVertexAttrib4svNV(args->index, args->v);; \
} while(0)
void glVertexAttrib4svNV(glVertexAttrib4svNV_ARG_EXPAND);
typedef void (*glVertexAttrib4svNV_PTR)(glVertexAttrib4svNV_ARG_EXPAND);
#define glVertexAttrib4ubNV_INDEX 2454
#define glVertexAttrib4ubNV_RETURN void
#define glVertexAttrib4ubNV_ARG_NAMES index, x, y, z, w
#define glVertexAttrib4ubNV_ARG_EXPAND GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w
#define glVertexAttrib4ubNV_PACKED PACKED_glVertexAttrib4ubNV
#define glVertexAttrib4ubNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttrib4ubNV_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttrib4ubNV(_index, _x, _y, _z, _w) ({ \
    glVertexAttrib4ubNV_PACKED *packed_data = malloc(sizeof(glVertexAttrib4ubNV_PACKED)); \
    packed_data->index = glVertexAttrib4ubNV_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.x = (GLubyte)_x; \
    packed_data->args.y = (GLubyte)_y; \
    packed_data->args.z = (GLubyte)_z; \
    packed_data->args.w = (GLubyte)_w; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttrib4ubNV(packed, ret_v) do { \
    PACKED_glVertexAttrib4ubNV *unpacked = (PACKED_glVertexAttrib4ubNV *)packed; \
    ARGS_glVertexAttrib4ubNV *args = (ARGS_glVertexAttrib4ubNV *)&unpacked->args; \
    glVertexAttrib4ubNV(args->index, args->x, args->y, args->z, args->w);; \
} while(0)
void glVertexAttrib4ubNV(glVertexAttrib4ubNV_ARG_EXPAND);
typedef void (*glVertexAttrib4ubNV_PTR)(glVertexAttrib4ubNV_ARG_EXPAND);
#define glVertexAttrib4ubv_INDEX 2455
#define glVertexAttrib4ubv_RETURN void
#define glVertexAttrib4ubv_ARG_NAMES index, v
#define glVertexAttrib4ubv_ARG_EXPAND GLuint index, const GLubyte * v
#define glVertexAttrib4ubv_PACKED PACKED_glVertexAttrib4ubv
#define glVertexAttrib4ubv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttrib4ubv_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttrib4ubv(_index, _v) ({ \
    glVertexAttrib4ubv_PACKED *packed_data = malloc(sizeof(glVertexAttrib4ubv_PACKED)); \
    packed_data->index = glVertexAttrib4ubv_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.v = (GLubyte *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttrib4ubv(packed, ret_v) do { \
    PACKED_glVertexAttrib4ubv *unpacked = (PACKED_glVertexAttrib4ubv *)packed; \
    ARGS_glVertexAttrib4ubv *args = (ARGS_glVertexAttrib4ubv *)&unpacked->args; \
    glVertexAttrib4ubv(args->index, args->v);; \
} while(0)
void glVertexAttrib4ubv(glVertexAttrib4ubv_ARG_EXPAND);
typedef void (*glVertexAttrib4ubv_PTR)(glVertexAttrib4ubv_ARG_EXPAND);
#define glVertexAttrib4ubvARB_INDEX 2456
#define glVertexAttrib4ubvARB_RETURN void
#define glVertexAttrib4ubvARB_ARG_NAMES index, v
#define glVertexAttrib4ubvARB_ARG_EXPAND GLuint index, const GLubyte * v
#define glVertexAttrib4ubvARB_PACKED PACKED_glVertexAttrib4ubvARB
#define glVertexAttrib4ubvARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttrib4ubvARB_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttrib4ubvARB(_index, _v) ({ \
    glVertexAttrib4ubvARB_PACKED *packed_data = malloc(sizeof(glVertexAttrib4ubvARB_PACKED)); \
    packed_data->index = glVertexAttrib4ubvARB_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.v = (GLubyte *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttrib4ubvARB(packed, ret_v) do { \
    PACKED_glVertexAttrib4ubvARB *unpacked = (PACKED_glVertexAttrib4ubvARB *)packed; \
    ARGS_glVertexAttrib4ubvARB *args = (ARGS_glVertexAttrib4ubvARB *)&unpacked->args; \
    glVertexAttrib4ubvARB(args->index, args->v);; \
} while(0)
void glVertexAttrib4ubvARB(glVertexAttrib4ubvARB_ARG_EXPAND);
typedef void (*glVertexAttrib4ubvARB_PTR)(glVertexAttrib4ubvARB_ARG_EXPAND);
#define glVertexAttrib4ubvNV_INDEX 2457
#define glVertexAttrib4ubvNV_RETURN void
#define glVertexAttrib4ubvNV_ARG_NAMES index, v
#define glVertexAttrib4ubvNV_ARG_EXPAND GLuint index, const GLubyte * v
#define glVertexAttrib4ubvNV_PACKED PACKED_glVertexAttrib4ubvNV
#define glVertexAttrib4ubvNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttrib4ubvNV_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttrib4ubvNV(_index, _v) ({ \
    glVertexAttrib4ubvNV_PACKED *packed_data = malloc(sizeof(glVertexAttrib4ubvNV_PACKED)); \
    packed_data->index = glVertexAttrib4ubvNV_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.v = (GLubyte *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttrib4ubvNV(packed, ret_v) do { \
    PACKED_glVertexAttrib4ubvNV *unpacked = (PACKED_glVertexAttrib4ubvNV *)packed; \
    ARGS_glVertexAttrib4ubvNV *args = (ARGS_glVertexAttrib4ubvNV *)&unpacked->args; \
    glVertexAttrib4ubvNV(args->index, args->v);; \
} while(0)
void glVertexAttrib4ubvNV(glVertexAttrib4ubvNV_ARG_EXPAND);
typedef void (*glVertexAttrib4ubvNV_PTR)(glVertexAttrib4ubvNV_ARG_EXPAND);
#define glVertexAttrib4uiv_INDEX 2458
#define glVertexAttrib4uiv_RETURN void
#define glVertexAttrib4uiv_ARG_NAMES index, v
#define glVertexAttrib4uiv_ARG_EXPAND GLuint index, const GLuint * v
#define glVertexAttrib4uiv_PACKED PACKED_glVertexAttrib4uiv
#define glVertexAttrib4uiv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttrib4uiv_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttrib4uiv(_index, _v) ({ \
    glVertexAttrib4uiv_PACKED *packed_data = malloc(sizeof(glVertexAttrib4uiv_PACKED)); \
    packed_data->index = glVertexAttrib4uiv_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.v = (GLuint *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttrib4uiv(packed, ret_v) do { \
    PACKED_glVertexAttrib4uiv *unpacked = (PACKED_glVertexAttrib4uiv *)packed; \
    ARGS_glVertexAttrib4uiv *args = (ARGS_glVertexAttrib4uiv *)&unpacked->args; \
    glVertexAttrib4uiv(args->index, args->v);; \
} while(0)
void glVertexAttrib4uiv(glVertexAttrib4uiv_ARG_EXPAND);
typedef void (*glVertexAttrib4uiv_PTR)(glVertexAttrib4uiv_ARG_EXPAND);
#define glVertexAttrib4uivARB_INDEX 2459
#define glVertexAttrib4uivARB_RETURN void
#define glVertexAttrib4uivARB_ARG_NAMES index, v
#define glVertexAttrib4uivARB_ARG_EXPAND GLuint index, const GLuint * v
#define glVertexAttrib4uivARB_PACKED PACKED_glVertexAttrib4uivARB
#define glVertexAttrib4uivARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttrib4uivARB_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttrib4uivARB(_index, _v) ({ \
    glVertexAttrib4uivARB_PACKED *packed_data = malloc(sizeof(glVertexAttrib4uivARB_PACKED)); \
    packed_data->index = glVertexAttrib4uivARB_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.v = (GLuint *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttrib4uivARB(packed, ret_v) do { \
    PACKED_glVertexAttrib4uivARB *unpacked = (PACKED_glVertexAttrib4uivARB *)packed; \
    ARGS_glVertexAttrib4uivARB *args = (ARGS_glVertexAttrib4uivARB *)&unpacked->args; \
    glVertexAttrib4uivARB(args->index, args->v);; \
} while(0)
void glVertexAttrib4uivARB(glVertexAttrib4uivARB_ARG_EXPAND);
typedef void (*glVertexAttrib4uivARB_PTR)(glVertexAttrib4uivARB_ARG_EXPAND);
#define glVertexAttrib4usv_INDEX 2460
#define glVertexAttrib4usv_RETURN void
#define glVertexAttrib4usv_ARG_NAMES index, v
#define glVertexAttrib4usv_ARG_EXPAND GLuint index, const GLushort * v
#define glVertexAttrib4usv_PACKED PACKED_glVertexAttrib4usv
#define glVertexAttrib4usv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttrib4usv_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttrib4usv(_index, _v) ({ \
    glVertexAttrib4usv_PACKED *packed_data = malloc(sizeof(glVertexAttrib4usv_PACKED)); \
    packed_data->index = glVertexAttrib4usv_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.v = (GLushort *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttrib4usv(packed, ret_v) do { \
    PACKED_glVertexAttrib4usv *unpacked = (PACKED_glVertexAttrib4usv *)packed; \
    ARGS_glVertexAttrib4usv *args = (ARGS_glVertexAttrib4usv *)&unpacked->args; \
    glVertexAttrib4usv(args->index, args->v);; \
} while(0)
void glVertexAttrib4usv(glVertexAttrib4usv_ARG_EXPAND);
typedef void (*glVertexAttrib4usv_PTR)(glVertexAttrib4usv_ARG_EXPAND);
#define glVertexAttrib4usvARB_INDEX 2461
#define glVertexAttrib4usvARB_RETURN void
#define glVertexAttrib4usvARB_ARG_NAMES index, v
#define glVertexAttrib4usvARB_ARG_EXPAND GLuint index, const GLushort * v
#define glVertexAttrib4usvARB_PACKED PACKED_glVertexAttrib4usvARB
#define glVertexAttrib4usvARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttrib4usvARB_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttrib4usvARB(_index, _v) ({ \
    glVertexAttrib4usvARB_PACKED *packed_data = malloc(sizeof(glVertexAttrib4usvARB_PACKED)); \
    packed_data->index = glVertexAttrib4usvARB_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.v = (GLushort *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttrib4usvARB(packed, ret_v) do { \
    PACKED_glVertexAttrib4usvARB *unpacked = (PACKED_glVertexAttrib4usvARB *)packed; \
    ARGS_glVertexAttrib4usvARB *args = (ARGS_glVertexAttrib4usvARB *)&unpacked->args; \
    glVertexAttrib4usvARB(args->index, args->v);; \
} while(0)
void glVertexAttrib4usvARB(glVertexAttrib4usvARB_ARG_EXPAND);
typedef void (*glVertexAttrib4usvARB_PTR)(glVertexAttrib4usvARB_ARG_EXPAND);
#define glVertexAttribArrayObjectATI_INDEX 2462
#define glVertexAttribArrayObjectATI_RETURN void
#define glVertexAttribArrayObjectATI_ARG_NAMES index, size, type, normalized, stride, buffer, offset
#define glVertexAttribArrayObjectATI_ARG_EXPAND GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, GLuint buffer, GLuint offset
#define glVertexAttribArrayObjectATI_PACKED PACKED_glVertexAttribArrayObjectATI
#define glVertexAttribArrayObjectATI_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttribArrayObjectATI_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttribArrayObjectATI(_index, _size, _type, _normalized, _stride, _buffer, _offset) ({ \
    glVertexAttribArrayObjectATI_PACKED *packed_data = malloc(sizeof(glVertexAttribArrayObjectATI_PACKED)); \
    packed_data->index = glVertexAttribArrayObjectATI_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.size = (GLint)_size; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.normalized = (GLboolean)_normalized; \
    packed_data->args.stride = (GLsizei)_stride; \
    packed_data->args.buffer = (GLuint)_buffer; \
    packed_data->args.offset = (GLuint)_offset; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttribArrayObjectATI(packed, ret_v) do { \
    PACKED_glVertexAttribArrayObjectATI *unpacked = (PACKED_glVertexAttribArrayObjectATI *)packed; \
    ARGS_glVertexAttribArrayObjectATI *args = (ARGS_glVertexAttribArrayObjectATI *)&unpacked->args; \
    glVertexAttribArrayObjectATI(args->index, args->size, args->type, args->normalized, args->stride, args->buffer, args->offset);; \
} while(0)
void glVertexAttribArrayObjectATI(glVertexAttribArrayObjectATI_ARG_EXPAND);
typedef void (*glVertexAttribArrayObjectATI_PTR)(glVertexAttribArrayObjectATI_ARG_EXPAND);
#define glVertexAttribBinding_INDEX 2463
#define glVertexAttribBinding_RETURN void
#define glVertexAttribBinding_ARG_NAMES attribindex, bindingindex
#define glVertexAttribBinding_ARG_EXPAND GLuint attribindex, GLuint bindingindex
#define glVertexAttribBinding_PACKED PACKED_glVertexAttribBinding
#define glVertexAttribBinding_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttribBinding_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttribBinding(_attribindex, _bindingindex) ({ \
    glVertexAttribBinding_PACKED *packed_data = malloc(sizeof(glVertexAttribBinding_PACKED)); \
    packed_data->index = glVertexAttribBinding_INDEX; \
    packed_data->args.attribindex = (GLuint)_attribindex; \
    packed_data->args.bindingindex = (GLuint)_bindingindex; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttribBinding(packed, ret_v) do { \
    PACKED_glVertexAttribBinding *unpacked = (PACKED_glVertexAttribBinding *)packed; \
    ARGS_glVertexAttribBinding *args = (ARGS_glVertexAttribBinding *)&unpacked->args; \
    glVertexAttribBinding(args->attribindex, args->bindingindex);; \
} while(0)
void glVertexAttribBinding(glVertexAttribBinding_ARG_EXPAND);
typedef void (*glVertexAttribBinding_PTR)(glVertexAttribBinding_ARG_EXPAND);
#define glVertexAttribDivisor_INDEX 2464
#define glVertexAttribDivisor_RETURN void
#define glVertexAttribDivisor_ARG_NAMES index, divisor
#define glVertexAttribDivisor_ARG_EXPAND GLuint index, GLuint divisor
#define glVertexAttribDivisor_PACKED PACKED_glVertexAttribDivisor
#define glVertexAttribDivisor_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttribDivisor_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttribDivisor(_index, _divisor) ({ \
    glVertexAttribDivisor_PACKED *packed_data = malloc(sizeof(glVertexAttribDivisor_PACKED)); \
    packed_data->index = glVertexAttribDivisor_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.divisor = (GLuint)_divisor; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttribDivisor(packed, ret_v) do { \
    PACKED_glVertexAttribDivisor *unpacked = (PACKED_glVertexAttribDivisor *)packed; \
    ARGS_glVertexAttribDivisor *args = (ARGS_glVertexAttribDivisor *)&unpacked->args; \
    glVertexAttribDivisor(args->index, args->divisor);; \
} while(0)
void glVertexAttribDivisor(glVertexAttribDivisor_ARG_EXPAND);
typedef void (*glVertexAttribDivisor_PTR)(glVertexAttribDivisor_ARG_EXPAND);
#define glVertexAttribDivisorARB_INDEX 2465
#define glVertexAttribDivisorARB_RETURN void
#define glVertexAttribDivisorARB_ARG_NAMES index, divisor
#define glVertexAttribDivisorARB_ARG_EXPAND GLuint index, GLuint divisor
#define glVertexAttribDivisorARB_PACKED PACKED_glVertexAttribDivisorARB
#define glVertexAttribDivisorARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttribDivisorARB_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttribDivisorARB(_index, _divisor) ({ \
    glVertexAttribDivisorARB_PACKED *packed_data = malloc(sizeof(glVertexAttribDivisorARB_PACKED)); \
    packed_data->index = glVertexAttribDivisorARB_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.divisor = (GLuint)_divisor; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttribDivisorARB(packed, ret_v) do { \
    PACKED_glVertexAttribDivisorARB *unpacked = (PACKED_glVertexAttribDivisorARB *)packed; \
    ARGS_glVertexAttribDivisorARB *args = (ARGS_glVertexAttribDivisorARB *)&unpacked->args; \
    glVertexAttribDivisorARB(args->index, args->divisor);; \
} while(0)
void glVertexAttribDivisorARB(glVertexAttribDivisorARB_ARG_EXPAND);
typedef void (*glVertexAttribDivisorARB_PTR)(glVertexAttribDivisorARB_ARG_EXPAND);
#define glVertexAttribFormat_INDEX 2466
#define glVertexAttribFormat_RETURN void
#define glVertexAttribFormat_ARG_NAMES attribindex, size, type, normalized, relativeoffset
#define glVertexAttribFormat_ARG_EXPAND GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset
#define glVertexAttribFormat_PACKED PACKED_glVertexAttribFormat
#define glVertexAttribFormat_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttribFormat_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttribFormat(_attribindex, _size, _type, _normalized, _relativeoffset) ({ \
    glVertexAttribFormat_PACKED *packed_data = malloc(sizeof(glVertexAttribFormat_PACKED)); \
    packed_data->index = glVertexAttribFormat_INDEX; \
    packed_data->args.attribindex = (GLuint)_attribindex; \
    packed_data->args.size = (GLint)_size; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.normalized = (GLboolean)_normalized; \
    packed_data->args.relativeoffset = (GLuint)_relativeoffset; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttribFormat(packed, ret_v) do { \
    PACKED_glVertexAttribFormat *unpacked = (PACKED_glVertexAttribFormat *)packed; \
    ARGS_glVertexAttribFormat *args = (ARGS_glVertexAttribFormat *)&unpacked->args; \
    glVertexAttribFormat(args->attribindex, args->size, args->type, args->normalized, args->relativeoffset);; \
} while(0)
void glVertexAttribFormat(glVertexAttribFormat_ARG_EXPAND);
typedef void (*glVertexAttribFormat_PTR)(glVertexAttribFormat_ARG_EXPAND);
#define glVertexAttribFormatNV_INDEX 2467
#define glVertexAttribFormatNV_RETURN void
#define glVertexAttribFormatNV_ARG_NAMES index, size, type, normalized, stride
#define glVertexAttribFormatNV_ARG_EXPAND GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride
#define glVertexAttribFormatNV_PACKED PACKED_glVertexAttribFormatNV
#define glVertexAttribFormatNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttribFormatNV_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttribFormatNV(_index, _size, _type, _normalized, _stride) ({ \
    glVertexAttribFormatNV_PACKED *packed_data = malloc(sizeof(glVertexAttribFormatNV_PACKED)); \
    packed_data->index = glVertexAttribFormatNV_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.size = (GLint)_size; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.normalized = (GLboolean)_normalized; \
    packed_data->args.stride = (GLsizei)_stride; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttribFormatNV(packed, ret_v) do { \
    PACKED_glVertexAttribFormatNV *unpacked = (PACKED_glVertexAttribFormatNV *)packed; \
    ARGS_glVertexAttribFormatNV *args = (ARGS_glVertexAttribFormatNV *)&unpacked->args; \
    glVertexAttribFormatNV(args->index, args->size, args->type, args->normalized, args->stride);; \
} while(0)
void glVertexAttribFormatNV(glVertexAttribFormatNV_ARG_EXPAND);
typedef void (*glVertexAttribFormatNV_PTR)(glVertexAttribFormatNV_ARG_EXPAND);
#define glVertexAttribI1i_INDEX 2468
#define glVertexAttribI1i_RETURN void
#define glVertexAttribI1i_ARG_NAMES index, x
#define glVertexAttribI1i_ARG_EXPAND GLuint index, GLint x
#define glVertexAttribI1i_PACKED PACKED_glVertexAttribI1i
#define glVertexAttribI1i_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttribI1i_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttribI1i(_index, _x) ({ \
    glVertexAttribI1i_PACKED *packed_data = malloc(sizeof(glVertexAttribI1i_PACKED)); \
    packed_data->index = glVertexAttribI1i_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.x = (GLint)_x; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttribI1i(packed, ret_v) do { \
    PACKED_glVertexAttribI1i *unpacked = (PACKED_glVertexAttribI1i *)packed; \
    ARGS_glVertexAttribI1i *args = (ARGS_glVertexAttribI1i *)&unpacked->args; \
    glVertexAttribI1i(args->index, args->x);; \
} while(0)
void glVertexAttribI1i(glVertexAttribI1i_ARG_EXPAND);
typedef void (*glVertexAttribI1i_PTR)(glVertexAttribI1i_ARG_EXPAND);
#define glVertexAttribI1iEXT_INDEX 2469
#define glVertexAttribI1iEXT_RETURN void
#define glVertexAttribI1iEXT_ARG_NAMES index, x
#define glVertexAttribI1iEXT_ARG_EXPAND GLuint index, GLint x
#define glVertexAttribI1iEXT_PACKED PACKED_glVertexAttribI1iEXT
#define glVertexAttribI1iEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttribI1iEXT_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttribI1iEXT(_index, _x) ({ \
    glVertexAttribI1iEXT_PACKED *packed_data = malloc(sizeof(glVertexAttribI1iEXT_PACKED)); \
    packed_data->index = glVertexAttribI1iEXT_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.x = (GLint)_x; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttribI1iEXT(packed, ret_v) do { \
    PACKED_glVertexAttribI1iEXT *unpacked = (PACKED_glVertexAttribI1iEXT *)packed; \
    ARGS_glVertexAttribI1iEXT *args = (ARGS_glVertexAttribI1iEXT *)&unpacked->args; \
    glVertexAttribI1iEXT(args->index, args->x);; \
} while(0)
void glVertexAttribI1iEXT(glVertexAttribI1iEXT_ARG_EXPAND);
typedef void (*glVertexAttribI1iEXT_PTR)(glVertexAttribI1iEXT_ARG_EXPAND);
#define glVertexAttribI1iv_INDEX 2470
#define glVertexAttribI1iv_RETURN void
#define glVertexAttribI1iv_ARG_NAMES index, v
#define glVertexAttribI1iv_ARG_EXPAND GLuint index, const GLint * v
#define glVertexAttribI1iv_PACKED PACKED_glVertexAttribI1iv
#define glVertexAttribI1iv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttribI1iv_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttribI1iv(_index, _v) ({ \
    glVertexAttribI1iv_PACKED *packed_data = malloc(sizeof(glVertexAttribI1iv_PACKED)); \
    packed_data->index = glVertexAttribI1iv_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.v = (GLint *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttribI1iv(packed, ret_v) do { \
    PACKED_glVertexAttribI1iv *unpacked = (PACKED_glVertexAttribI1iv *)packed; \
    ARGS_glVertexAttribI1iv *args = (ARGS_glVertexAttribI1iv *)&unpacked->args; \
    glVertexAttribI1iv(args->index, args->v);; \
} while(0)
void glVertexAttribI1iv(glVertexAttribI1iv_ARG_EXPAND);
typedef void (*glVertexAttribI1iv_PTR)(glVertexAttribI1iv_ARG_EXPAND);
#define glVertexAttribI1ivEXT_INDEX 2471
#define glVertexAttribI1ivEXT_RETURN void
#define glVertexAttribI1ivEXT_ARG_NAMES index, v
#define glVertexAttribI1ivEXT_ARG_EXPAND GLuint index, const GLint * v
#define glVertexAttribI1ivEXT_PACKED PACKED_glVertexAttribI1ivEXT
#define glVertexAttribI1ivEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttribI1ivEXT_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttribI1ivEXT(_index, _v) ({ \
    glVertexAttribI1ivEXT_PACKED *packed_data = malloc(sizeof(glVertexAttribI1ivEXT_PACKED)); \
    packed_data->index = glVertexAttribI1ivEXT_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.v = (GLint *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttribI1ivEXT(packed, ret_v) do { \
    PACKED_glVertexAttribI1ivEXT *unpacked = (PACKED_glVertexAttribI1ivEXT *)packed; \
    ARGS_glVertexAttribI1ivEXT *args = (ARGS_glVertexAttribI1ivEXT *)&unpacked->args; \
    glVertexAttribI1ivEXT(args->index, args->v);; \
} while(0)
void glVertexAttribI1ivEXT(glVertexAttribI1ivEXT_ARG_EXPAND);
typedef void (*glVertexAttribI1ivEXT_PTR)(glVertexAttribI1ivEXT_ARG_EXPAND);
#define glVertexAttribI1ui_INDEX 2472
#define glVertexAttribI1ui_RETURN void
#define glVertexAttribI1ui_ARG_NAMES index, x
#define glVertexAttribI1ui_ARG_EXPAND GLuint index, GLuint x
#define glVertexAttribI1ui_PACKED PACKED_glVertexAttribI1ui
#define glVertexAttribI1ui_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttribI1ui_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttribI1ui(_index, _x) ({ \
    glVertexAttribI1ui_PACKED *packed_data = malloc(sizeof(glVertexAttribI1ui_PACKED)); \
    packed_data->index = glVertexAttribI1ui_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.x = (GLuint)_x; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttribI1ui(packed, ret_v) do { \
    PACKED_glVertexAttribI1ui *unpacked = (PACKED_glVertexAttribI1ui *)packed; \
    ARGS_glVertexAttribI1ui *args = (ARGS_glVertexAttribI1ui *)&unpacked->args; \
    glVertexAttribI1ui(args->index, args->x);; \
} while(0)
void glVertexAttribI1ui(glVertexAttribI1ui_ARG_EXPAND);
typedef void (*glVertexAttribI1ui_PTR)(glVertexAttribI1ui_ARG_EXPAND);
#define glVertexAttribI1uiEXT_INDEX 2473
#define glVertexAttribI1uiEXT_RETURN void
#define glVertexAttribI1uiEXT_ARG_NAMES index, x
#define glVertexAttribI1uiEXT_ARG_EXPAND GLuint index, GLuint x
#define glVertexAttribI1uiEXT_PACKED PACKED_glVertexAttribI1uiEXT
#define glVertexAttribI1uiEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttribI1uiEXT_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttribI1uiEXT(_index, _x) ({ \
    glVertexAttribI1uiEXT_PACKED *packed_data = malloc(sizeof(glVertexAttribI1uiEXT_PACKED)); \
    packed_data->index = glVertexAttribI1uiEXT_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.x = (GLuint)_x; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttribI1uiEXT(packed, ret_v) do { \
    PACKED_glVertexAttribI1uiEXT *unpacked = (PACKED_glVertexAttribI1uiEXT *)packed; \
    ARGS_glVertexAttribI1uiEXT *args = (ARGS_glVertexAttribI1uiEXT *)&unpacked->args; \
    glVertexAttribI1uiEXT(args->index, args->x);; \
} while(0)
void glVertexAttribI1uiEXT(glVertexAttribI1uiEXT_ARG_EXPAND);
typedef void (*glVertexAttribI1uiEXT_PTR)(glVertexAttribI1uiEXT_ARG_EXPAND);
#define glVertexAttribI1uiv_INDEX 2474
#define glVertexAttribI1uiv_RETURN void
#define glVertexAttribI1uiv_ARG_NAMES index, v
#define glVertexAttribI1uiv_ARG_EXPAND GLuint index, const GLuint * v
#define glVertexAttribI1uiv_PACKED PACKED_glVertexAttribI1uiv
#define glVertexAttribI1uiv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttribI1uiv_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttribI1uiv(_index, _v) ({ \
    glVertexAttribI1uiv_PACKED *packed_data = malloc(sizeof(glVertexAttribI1uiv_PACKED)); \
    packed_data->index = glVertexAttribI1uiv_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.v = (GLuint *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttribI1uiv(packed, ret_v) do { \
    PACKED_glVertexAttribI1uiv *unpacked = (PACKED_glVertexAttribI1uiv *)packed; \
    ARGS_glVertexAttribI1uiv *args = (ARGS_glVertexAttribI1uiv *)&unpacked->args; \
    glVertexAttribI1uiv(args->index, args->v);; \
} while(0)
void glVertexAttribI1uiv(glVertexAttribI1uiv_ARG_EXPAND);
typedef void (*glVertexAttribI1uiv_PTR)(glVertexAttribI1uiv_ARG_EXPAND);
#define glVertexAttribI1uivEXT_INDEX 2475
#define glVertexAttribI1uivEXT_RETURN void
#define glVertexAttribI1uivEXT_ARG_NAMES index, v
#define glVertexAttribI1uivEXT_ARG_EXPAND GLuint index, const GLuint * v
#define glVertexAttribI1uivEXT_PACKED PACKED_glVertexAttribI1uivEXT
#define glVertexAttribI1uivEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttribI1uivEXT_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttribI1uivEXT(_index, _v) ({ \
    glVertexAttribI1uivEXT_PACKED *packed_data = malloc(sizeof(glVertexAttribI1uivEXT_PACKED)); \
    packed_data->index = glVertexAttribI1uivEXT_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.v = (GLuint *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttribI1uivEXT(packed, ret_v) do { \
    PACKED_glVertexAttribI1uivEXT *unpacked = (PACKED_glVertexAttribI1uivEXT *)packed; \
    ARGS_glVertexAttribI1uivEXT *args = (ARGS_glVertexAttribI1uivEXT *)&unpacked->args; \
    glVertexAttribI1uivEXT(args->index, args->v);; \
} while(0)
void glVertexAttribI1uivEXT(glVertexAttribI1uivEXT_ARG_EXPAND);
typedef void (*glVertexAttribI1uivEXT_PTR)(glVertexAttribI1uivEXT_ARG_EXPAND);
#define glVertexAttribI2i_INDEX 2476
#define glVertexAttribI2i_RETURN void
#define glVertexAttribI2i_ARG_NAMES index, x, y
#define glVertexAttribI2i_ARG_EXPAND GLuint index, GLint x, GLint y
#define glVertexAttribI2i_PACKED PACKED_glVertexAttribI2i
#define glVertexAttribI2i_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttribI2i_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttribI2i(_index, _x, _y) ({ \
    glVertexAttribI2i_PACKED *packed_data = malloc(sizeof(glVertexAttribI2i_PACKED)); \
    packed_data->index = glVertexAttribI2i_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.x = (GLint)_x; \
    packed_data->args.y = (GLint)_y; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttribI2i(packed, ret_v) do { \
    PACKED_glVertexAttribI2i *unpacked = (PACKED_glVertexAttribI2i *)packed; \
    ARGS_glVertexAttribI2i *args = (ARGS_glVertexAttribI2i *)&unpacked->args; \
    glVertexAttribI2i(args->index, args->x, args->y);; \
} while(0)
void glVertexAttribI2i(glVertexAttribI2i_ARG_EXPAND);
typedef void (*glVertexAttribI2i_PTR)(glVertexAttribI2i_ARG_EXPAND);
#define glVertexAttribI2iEXT_INDEX 2477
#define glVertexAttribI2iEXT_RETURN void
#define glVertexAttribI2iEXT_ARG_NAMES index, x, y
#define glVertexAttribI2iEXT_ARG_EXPAND GLuint index, GLint x, GLint y
#define glVertexAttribI2iEXT_PACKED PACKED_glVertexAttribI2iEXT
#define glVertexAttribI2iEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttribI2iEXT_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttribI2iEXT(_index, _x, _y) ({ \
    glVertexAttribI2iEXT_PACKED *packed_data = malloc(sizeof(glVertexAttribI2iEXT_PACKED)); \
    packed_data->index = glVertexAttribI2iEXT_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.x = (GLint)_x; \
    packed_data->args.y = (GLint)_y; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttribI2iEXT(packed, ret_v) do { \
    PACKED_glVertexAttribI2iEXT *unpacked = (PACKED_glVertexAttribI2iEXT *)packed; \
    ARGS_glVertexAttribI2iEXT *args = (ARGS_glVertexAttribI2iEXT *)&unpacked->args; \
    glVertexAttribI2iEXT(args->index, args->x, args->y);; \
} while(0)
void glVertexAttribI2iEXT(glVertexAttribI2iEXT_ARG_EXPAND);
typedef void (*glVertexAttribI2iEXT_PTR)(glVertexAttribI2iEXT_ARG_EXPAND);
#define glVertexAttribI2iv_INDEX 2478
#define glVertexAttribI2iv_RETURN void
#define glVertexAttribI2iv_ARG_NAMES index, v
#define glVertexAttribI2iv_ARG_EXPAND GLuint index, const GLint * v
#define glVertexAttribI2iv_PACKED PACKED_glVertexAttribI2iv
#define glVertexAttribI2iv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttribI2iv_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttribI2iv(_index, _v) ({ \
    glVertexAttribI2iv_PACKED *packed_data = malloc(sizeof(glVertexAttribI2iv_PACKED)); \
    packed_data->index = glVertexAttribI2iv_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.v = (GLint *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttribI2iv(packed, ret_v) do { \
    PACKED_glVertexAttribI2iv *unpacked = (PACKED_glVertexAttribI2iv *)packed; \
    ARGS_glVertexAttribI2iv *args = (ARGS_glVertexAttribI2iv *)&unpacked->args; \
    glVertexAttribI2iv(args->index, args->v);; \
} while(0)
void glVertexAttribI2iv(glVertexAttribI2iv_ARG_EXPAND);
typedef void (*glVertexAttribI2iv_PTR)(glVertexAttribI2iv_ARG_EXPAND);
#define glVertexAttribI2ivEXT_INDEX 2479
#define glVertexAttribI2ivEXT_RETURN void
#define glVertexAttribI2ivEXT_ARG_NAMES index, v
#define glVertexAttribI2ivEXT_ARG_EXPAND GLuint index, const GLint * v
#define glVertexAttribI2ivEXT_PACKED PACKED_glVertexAttribI2ivEXT
#define glVertexAttribI2ivEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttribI2ivEXT_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttribI2ivEXT(_index, _v) ({ \
    glVertexAttribI2ivEXT_PACKED *packed_data = malloc(sizeof(glVertexAttribI2ivEXT_PACKED)); \
    packed_data->index = glVertexAttribI2ivEXT_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.v = (GLint *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttribI2ivEXT(packed, ret_v) do { \
    PACKED_glVertexAttribI2ivEXT *unpacked = (PACKED_glVertexAttribI2ivEXT *)packed; \
    ARGS_glVertexAttribI2ivEXT *args = (ARGS_glVertexAttribI2ivEXT *)&unpacked->args; \
    glVertexAttribI2ivEXT(args->index, args->v);; \
} while(0)
void glVertexAttribI2ivEXT(glVertexAttribI2ivEXT_ARG_EXPAND);
typedef void (*glVertexAttribI2ivEXT_PTR)(glVertexAttribI2ivEXT_ARG_EXPAND);
#define glVertexAttribI2ui_INDEX 2480
#define glVertexAttribI2ui_RETURN void
#define glVertexAttribI2ui_ARG_NAMES index, x, y
#define glVertexAttribI2ui_ARG_EXPAND GLuint index, GLuint x, GLuint y
#define glVertexAttribI2ui_PACKED PACKED_glVertexAttribI2ui
#define glVertexAttribI2ui_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttribI2ui_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttribI2ui(_index, _x, _y) ({ \
    glVertexAttribI2ui_PACKED *packed_data = malloc(sizeof(glVertexAttribI2ui_PACKED)); \
    packed_data->index = glVertexAttribI2ui_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.x = (GLuint)_x; \
    packed_data->args.y = (GLuint)_y; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttribI2ui(packed, ret_v) do { \
    PACKED_glVertexAttribI2ui *unpacked = (PACKED_glVertexAttribI2ui *)packed; \
    ARGS_glVertexAttribI2ui *args = (ARGS_glVertexAttribI2ui *)&unpacked->args; \
    glVertexAttribI2ui(args->index, args->x, args->y);; \
} while(0)
void glVertexAttribI2ui(glVertexAttribI2ui_ARG_EXPAND);
typedef void (*glVertexAttribI2ui_PTR)(glVertexAttribI2ui_ARG_EXPAND);
#define glVertexAttribI2uiEXT_INDEX 2481
#define glVertexAttribI2uiEXT_RETURN void
#define glVertexAttribI2uiEXT_ARG_NAMES index, x, y
#define glVertexAttribI2uiEXT_ARG_EXPAND GLuint index, GLuint x, GLuint y
#define glVertexAttribI2uiEXT_PACKED PACKED_glVertexAttribI2uiEXT
#define glVertexAttribI2uiEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttribI2uiEXT_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttribI2uiEXT(_index, _x, _y) ({ \
    glVertexAttribI2uiEXT_PACKED *packed_data = malloc(sizeof(glVertexAttribI2uiEXT_PACKED)); \
    packed_data->index = glVertexAttribI2uiEXT_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.x = (GLuint)_x; \
    packed_data->args.y = (GLuint)_y; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttribI2uiEXT(packed, ret_v) do { \
    PACKED_glVertexAttribI2uiEXT *unpacked = (PACKED_glVertexAttribI2uiEXT *)packed; \
    ARGS_glVertexAttribI2uiEXT *args = (ARGS_glVertexAttribI2uiEXT *)&unpacked->args; \
    glVertexAttribI2uiEXT(args->index, args->x, args->y);; \
} while(0)
void glVertexAttribI2uiEXT(glVertexAttribI2uiEXT_ARG_EXPAND);
typedef void (*glVertexAttribI2uiEXT_PTR)(glVertexAttribI2uiEXT_ARG_EXPAND);
#define glVertexAttribI2uiv_INDEX 2482
#define glVertexAttribI2uiv_RETURN void
#define glVertexAttribI2uiv_ARG_NAMES index, v
#define glVertexAttribI2uiv_ARG_EXPAND GLuint index, const GLuint * v
#define glVertexAttribI2uiv_PACKED PACKED_glVertexAttribI2uiv
#define glVertexAttribI2uiv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttribI2uiv_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttribI2uiv(_index, _v) ({ \
    glVertexAttribI2uiv_PACKED *packed_data = malloc(sizeof(glVertexAttribI2uiv_PACKED)); \
    packed_data->index = glVertexAttribI2uiv_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.v = (GLuint *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttribI2uiv(packed, ret_v) do { \
    PACKED_glVertexAttribI2uiv *unpacked = (PACKED_glVertexAttribI2uiv *)packed; \
    ARGS_glVertexAttribI2uiv *args = (ARGS_glVertexAttribI2uiv *)&unpacked->args; \
    glVertexAttribI2uiv(args->index, args->v);; \
} while(0)
void glVertexAttribI2uiv(glVertexAttribI2uiv_ARG_EXPAND);
typedef void (*glVertexAttribI2uiv_PTR)(glVertexAttribI2uiv_ARG_EXPAND);
#define glVertexAttribI2uivEXT_INDEX 2483
#define glVertexAttribI2uivEXT_RETURN void
#define glVertexAttribI2uivEXT_ARG_NAMES index, v
#define glVertexAttribI2uivEXT_ARG_EXPAND GLuint index, const GLuint * v
#define glVertexAttribI2uivEXT_PACKED PACKED_glVertexAttribI2uivEXT
#define glVertexAttribI2uivEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttribI2uivEXT_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttribI2uivEXT(_index, _v) ({ \
    glVertexAttribI2uivEXT_PACKED *packed_data = malloc(sizeof(glVertexAttribI2uivEXT_PACKED)); \
    packed_data->index = glVertexAttribI2uivEXT_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.v = (GLuint *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttribI2uivEXT(packed, ret_v) do { \
    PACKED_glVertexAttribI2uivEXT *unpacked = (PACKED_glVertexAttribI2uivEXT *)packed; \
    ARGS_glVertexAttribI2uivEXT *args = (ARGS_glVertexAttribI2uivEXT *)&unpacked->args; \
    glVertexAttribI2uivEXT(args->index, args->v);; \
} while(0)
void glVertexAttribI2uivEXT(glVertexAttribI2uivEXT_ARG_EXPAND);
typedef void (*glVertexAttribI2uivEXT_PTR)(glVertexAttribI2uivEXT_ARG_EXPAND);
#define glVertexAttribI3i_INDEX 2484
#define glVertexAttribI3i_RETURN void
#define glVertexAttribI3i_ARG_NAMES index, x, y, z
#define glVertexAttribI3i_ARG_EXPAND GLuint index, GLint x, GLint y, GLint z
#define glVertexAttribI3i_PACKED PACKED_glVertexAttribI3i
#define glVertexAttribI3i_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttribI3i_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttribI3i(_index, _x, _y, _z) ({ \
    glVertexAttribI3i_PACKED *packed_data = malloc(sizeof(glVertexAttribI3i_PACKED)); \
    packed_data->index = glVertexAttribI3i_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.x = (GLint)_x; \
    packed_data->args.y = (GLint)_y; \
    packed_data->args.z = (GLint)_z; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttribI3i(packed, ret_v) do { \
    PACKED_glVertexAttribI3i *unpacked = (PACKED_glVertexAttribI3i *)packed; \
    ARGS_glVertexAttribI3i *args = (ARGS_glVertexAttribI3i *)&unpacked->args; \
    glVertexAttribI3i(args->index, args->x, args->y, args->z);; \
} while(0)
void glVertexAttribI3i(glVertexAttribI3i_ARG_EXPAND);
typedef void (*glVertexAttribI3i_PTR)(glVertexAttribI3i_ARG_EXPAND);
#define glVertexAttribI3iEXT_INDEX 2485
#define glVertexAttribI3iEXT_RETURN void
#define glVertexAttribI3iEXT_ARG_NAMES index, x, y, z
#define glVertexAttribI3iEXT_ARG_EXPAND GLuint index, GLint x, GLint y, GLint z
#define glVertexAttribI3iEXT_PACKED PACKED_glVertexAttribI3iEXT
#define glVertexAttribI3iEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttribI3iEXT_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttribI3iEXT(_index, _x, _y, _z) ({ \
    glVertexAttribI3iEXT_PACKED *packed_data = malloc(sizeof(glVertexAttribI3iEXT_PACKED)); \
    packed_data->index = glVertexAttribI3iEXT_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.x = (GLint)_x; \
    packed_data->args.y = (GLint)_y; \
    packed_data->args.z = (GLint)_z; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttribI3iEXT(packed, ret_v) do { \
    PACKED_glVertexAttribI3iEXT *unpacked = (PACKED_glVertexAttribI3iEXT *)packed; \
    ARGS_glVertexAttribI3iEXT *args = (ARGS_glVertexAttribI3iEXT *)&unpacked->args; \
    glVertexAttribI3iEXT(args->index, args->x, args->y, args->z);; \
} while(0)
void glVertexAttribI3iEXT(glVertexAttribI3iEXT_ARG_EXPAND);
typedef void (*glVertexAttribI3iEXT_PTR)(glVertexAttribI3iEXT_ARG_EXPAND);
#define glVertexAttribI3iv_INDEX 2486
#define glVertexAttribI3iv_RETURN void
#define glVertexAttribI3iv_ARG_NAMES index, v
#define glVertexAttribI3iv_ARG_EXPAND GLuint index, const GLint * v
#define glVertexAttribI3iv_PACKED PACKED_glVertexAttribI3iv
#define glVertexAttribI3iv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttribI3iv_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttribI3iv(_index, _v) ({ \
    glVertexAttribI3iv_PACKED *packed_data = malloc(sizeof(glVertexAttribI3iv_PACKED)); \
    packed_data->index = glVertexAttribI3iv_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.v = (GLint *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttribI3iv(packed, ret_v) do { \
    PACKED_glVertexAttribI3iv *unpacked = (PACKED_glVertexAttribI3iv *)packed; \
    ARGS_glVertexAttribI3iv *args = (ARGS_glVertexAttribI3iv *)&unpacked->args; \
    glVertexAttribI3iv(args->index, args->v);; \
} while(0)
void glVertexAttribI3iv(glVertexAttribI3iv_ARG_EXPAND);
typedef void (*glVertexAttribI3iv_PTR)(glVertexAttribI3iv_ARG_EXPAND);
#define glVertexAttribI3ivEXT_INDEX 2487
#define glVertexAttribI3ivEXT_RETURN void
#define glVertexAttribI3ivEXT_ARG_NAMES index, v
#define glVertexAttribI3ivEXT_ARG_EXPAND GLuint index, const GLint * v
#define glVertexAttribI3ivEXT_PACKED PACKED_glVertexAttribI3ivEXT
#define glVertexAttribI3ivEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttribI3ivEXT_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttribI3ivEXT(_index, _v) ({ \
    glVertexAttribI3ivEXT_PACKED *packed_data = malloc(sizeof(glVertexAttribI3ivEXT_PACKED)); \
    packed_data->index = glVertexAttribI3ivEXT_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.v = (GLint *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttribI3ivEXT(packed, ret_v) do { \
    PACKED_glVertexAttribI3ivEXT *unpacked = (PACKED_glVertexAttribI3ivEXT *)packed; \
    ARGS_glVertexAttribI3ivEXT *args = (ARGS_glVertexAttribI3ivEXT *)&unpacked->args; \
    glVertexAttribI3ivEXT(args->index, args->v);; \
} while(0)
void glVertexAttribI3ivEXT(glVertexAttribI3ivEXT_ARG_EXPAND);
typedef void (*glVertexAttribI3ivEXT_PTR)(glVertexAttribI3ivEXT_ARG_EXPAND);
#define glVertexAttribI3ui_INDEX 2488
#define glVertexAttribI3ui_RETURN void
#define glVertexAttribI3ui_ARG_NAMES index, x, y, z
#define glVertexAttribI3ui_ARG_EXPAND GLuint index, GLuint x, GLuint y, GLuint z
#define glVertexAttribI3ui_PACKED PACKED_glVertexAttribI3ui
#define glVertexAttribI3ui_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttribI3ui_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttribI3ui(_index, _x, _y, _z) ({ \
    glVertexAttribI3ui_PACKED *packed_data = malloc(sizeof(glVertexAttribI3ui_PACKED)); \
    packed_data->index = glVertexAttribI3ui_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.x = (GLuint)_x; \
    packed_data->args.y = (GLuint)_y; \
    packed_data->args.z = (GLuint)_z; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttribI3ui(packed, ret_v) do { \
    PACKED_glVertexAttribI3ui *unpacked = (PACKED_glVertexAttribI3ui *)packed; \
    ARGS_glVertexAttribI3ui *args = (ARGS_glVertexAttribI3ui *)&unpacked->args; \
    glVertexAttribI3ui(args->index, args->x, args->y, args->z);; \
} while(0)
void glVertexAttribI3ui(glVertexAttribI3ui_ARG_EXPAND);
typedef void (*glVertexAttribI3ui_PTR)(glVertexAttribI3ui_ARG_EXPAND);
#define glVertexAttribI3uiEXT_INDEX 2489
#define glVertexAttribI3uiEXT_RETURN void
#define glVertexAttribI3uiEXT_ARG_NAMES index, x, y, z
#define glVertexAttribI3uiEXT_ARG_EXPAND GLuint index, GLuint x, GLuint y, GLuint z
#define glVertexAttribI3uiEXT_PACKED PACKED_glVertexAttribI3uiEXT
#define glVertexAttribI3uiEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttribI3uiEXT_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttribI3uiEXT(_index, _x, _y, _z) ({ \
    glVertexAttribI3uiEXT_PACKED *packed_data = malloc(sizeof(glVertexAttribI3uiEXT_PACKED)); \
    packed_data->index = glVertexAttribI3uiEXT_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.x = (GLuint)_x; \
    packed_data->args.y = (GLuint)_y; \
    packed_data->args.z = (GLuint)_z; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttribI3uiEXT(packed, ret_v) do { \
    PACKED_glVertexAttribI3uiEXT *unpacked = (PACKED_glVertexAttribI3uiEXT *)packed; \
    ARGS_glVertexAttribI3uiEXT *args = (ARGS_glVertexAttribI3uiEXT *)&unpacked->args; \
    glVertexAttribI3uiEXT(args->index, args->x, args->y, args->z);; \
} while(0)
void glVertexAttribI3uiEXT(glVertexAttribI3uiEXT_ARG_EXPAND);
typedef void (*glVertexAttribI3uiEXT_PTR)(glVertexAttribI3uiEXT_ARG_EXPAND);
#define glVertexAttribI3uiv_INDEX 2490
#define glVertexAttribI3uiv_RETURN void
#define glVertexAttribI3uiv_ARG_NAMES index, v
#define glVertexAttribI3uiv_ARG_EXPAND GLuint index, const GLuint * v
#define glVertexAttribI3uiv_PACKED PACKED_glVertexAttribI3uiv
#define glVertexAttribI3uiv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttribI3uiv_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttribI3uiv(_index, _v) ({ \
    glVertexAttribI3uiv_PACKED *packed_data = malloc(sizeof(glVertexAttribI3uiv_PACKED)); \
    packed_data->index = glVertexAttribI3uiv_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.v = (GLuint *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttribI3uiv(packed, ret_v) do { \
    PACKED_glVertexAttribI3uiv *unpacked = (PACKED_glVertexAttribI3uiv *)packed; \
    ARGS_glVertexAttribI3uiv *args = (ARGS_glVertexAttribI3uiv *)&unpacked->args; \
    glVertexAttribI3uiv(args->index, args->v);; \
} while(0)
void glVertexAttribI3uiv(glVertexAttribI3uiv_ARG_EXPAND);
typedef void (*glVertexAttribI3uiv_PTR)(glVertexAttribI3uiv_ARG_EXPAND);
#define glVertexAttribI3uivEXT_INDEX 2491
#define glVertexAttribI3uivEXT_RETURN void
#define glVertexAttribI3uivEXT_ARG_NAMES index, v
#define glVertexAttribI3uivEXT_ARG_EXPAND GLuint index, const GLuint * v
#define glVertexAttribI3uivEXT_PACKED PACKED_glVertexAttribI3uivEXT
#define glVertexAttribI3uivEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttribI3uivEXT_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttribI3uivEXT(_index, _v) ({ \
    glVertexAttribI3uivEXT_PACKED *packed_data = malloc(sizeof(glVertexAttribI3uivEXT_PACKED)); \
    packed_data->index = glVertexAttribI3uivEXT_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.v = (GLuint *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttribI3uivEXT(packed, ret_v) do { \
    PACKED_glVertexAttribI3uivEXT *unpacked = (PACKED_glVertexAttribI3uivEXT *)packed; \
    ARGS_glVertexAttribI3uivEXT *args = (ARGS_glVertexAttribI3uivEXT *)&unpacked->args; \
    glVertexAttribI3uivEXT(args->index, args->v);; \
} while(0)
void glVertexAttribI3uivEXT(glVertexAttribI3uivEXT_ARG_EXPAND);
typedef void (*glVertexAttribI3uivEXT_PTR)(glVertexAttribI3uivEXT_ARG_EXPAND);
#define glVertexAttribI4bv_INDEX 2492
#define glVertexAttribI4bv_RETURN void
#define glVertexAttribI4bv_ARG_NAMES index, v
#define glVertexAttribI4bv_ARG_EXPAND GLuint index, const GLbyte * v
#define glVertexAttribI4bv_PACKED PACKED_glVertexAttribI4bv
#define glVertexAttribI4bv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttribI4bv_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttribI4bv(_index, _v) ({ \
    glVertexAttribI4bv_PACKED *packed_data = malloc(sizeof(glVertexAttribI4bv_PACKED)); \
    packed_data->index = glVertexAttribI4bv_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.v = (GLbyte *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttribI4bv(packed, ret_v) do { \
    PACKED_glVertexAttribI4bv *unpacked = (PACKED_glVertexAttribI4bv *)packed; \
    ARGS_glVertexAttribI4bv *args = (ARGS_glVertexAttribI4bv *)&unpacked->args; \
    glVertexAttribI4bv(args->index, args->v);; \
} while(0)
void glVertexAttribI4bv(glVertexAttribI4bv_ARG_EXPAND);
typedef void (*glVertexAttribI4bv_PTR)(glVertexAttribI4bv_ARG_EXPAND);
#define glVertexAttribI4bvEXT_INDEX 2493
#define glVertexAttribI4bvEXT_RETURN void
#define glVertexAttribI4bvEXT_ARG_NAMES index, v
#define glVertexAttribI4bvEXT_ARG_EXPAND GLuint index, const GLbyte * v
#define glVertexAttribI4bvEXT_PACKED PACKED_glVertexAttribI4bvEXT
#define glVertexAttribI4bvEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttribI4bvEXT_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttribI4bvEXT(_index, _v) ({ \
    glVertexAttribI4bvEXT_PACKED *packed_data = malloc(sizeof(glVertexAttribI4bvEXT_PACKED)); \
    packed_data->index = glVertexAttribI4bvEXT_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.v = (GLbyte *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttribI4bvEXT(packed, ret_v) do { \
    PACKED_glVertexAttribI4bvEXT *unpacked = (PACKED_glVertexAttribI4bvEXT *)packed; \
    ARGS_glVertexAttribI4bvEXT *args = (ARGS_glVertexAttribI4bvEXT *)&unpacked->args; \
    glVertexAttribI4bvEXT(args->index, args->v);; \
} while(0)
void glVertexAttribI4bvEXT(glVertexAttribI4bvEXT_ARG_EXPAND);
typedef void (*glVertexAttribI4bvEXT_PTR)(glVertexAttribI4bvEXT_ARG_EXPAND);
#define glVertexAttribI4i_INDEX 2494
#define glVertexAttribI4i_RETURN void
#define glVertexAttribI4i_ARG_NAMES index, x, y, z, w
#define glVertexAttribI4i_ARG_EXPAND GLuint index, GLint x, GLint y, GLint z, GLint w
#define glVertexAttribI4i_PACKED PACKED_glVertexAttribI4i
#define glVertexAttribI4i_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttribI4i_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttribI4i(_index, _x, _y, _z, _w) ({ \
    glVertexAttribI4i_PACKED *packed_data = malloc(sizeof(glVertexAttribI4i_PACKED)); \
    packed_data->index = glVertexAttribI4i_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.x = (GLint)_x; \
    packed_data->args.y = (GLint)_y; \
    packed_data->args.z = (GLint)_z; \
    packed_data->args.w = (GLint)_w; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttribI4i(packed, ret_v) do { \
    PACKED_glVertexAttribI4i *unpacked = (PACKED_glVertexAttribI4i *)packed; \
    ARGS_glVertexAttribI4i *args = (ARGS_glVertexAttribI4i *)&unpacked->args; \
    glVertexAttribI4i(args->index, args->x, args->y, args->z, args->w);; \
} while(0)
void glVertexAttribI4i(glVertexAttribI4i_ARG_EXPAND);
typedef void (*glVertexAttribI4i_PTR)(glVertexAttribI4i_ARG_EXPAND);
#define glVertexAttribI4iEXT_INDEX 2495
#define glVertexAttribI4iEXT_RETURN void
#define glVertexAttribI4iEXT_ARG_NAMES index, x, y, z, w
#define glVertexAttribI4iEXT_ARG_EXPAND GLuint index, GLint x, GLint y, GLint z, GLint w
#define glVertexAttribI4iEXT_PACKED PACKED_glVertexAttribI4iEXT
#define glVertexAttribI4iEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttribI4iEXT_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttribI4iEXT(_index, _x, _y, _z, _w) ({ \
    glVertexAttribI4iEXT_PACKED *packed_data = malloc(sizeof(glVertexAttribI4iEXT_PACKED)); \
    packed_data->index = glVertexAttribI4iEXT_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.x = (GLint)_x; \
    packed_data->args.y = (GLint)_y; \
    packed_data->args.z = (GLint)_z; \
    packed_data->args.w = (GLint)_w; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttribI4iEXT(packed, ret_v) do { \
    PACKED_glVertexAttribI4iEXT *unpacked = (PACKED_glVertexAttribI4iEXT *)packed; \
    ARGS_glVertexAttribI4iEXT *args = (ARGS_glVertexAttribI4iEXT *)&unpacked->args; \
    glVertexAttribI4iEXT(args->index, args->x, args->y, args->z, args->w);; \
} while(0)
void glVertexAttribI4iEXT(glVertexAttribI4iEXT_ARG_EXPAND);
typedef void (*glVertexAttribI4iEXT_PTR)(glVertexAttribI4iEXT_ARG_EXPAND);
#define glVertexAttribI4iv_INDEX 2496
#define glVertexAttribI4iv_RETURN void
#define glVertexAttribI4iv_ARG_NAMES index, v
#define glVertexAttribI4iv_ARG_EXPAND GLuint index, const GLint * v
#define glVertexAttribI4iv_PACKED PACKED_glVertexAttribI4iv
#define glVertexAttribI4iv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttribI4iv_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttribI4iv(_index, _v) ({ \
    glVertexAttribI4iv_PACKED *packed_data = malloc(sizeof(glVertexAttribI4iv_PACKED)); \
    packed_data->index = glVertexAttribI4iv_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.v = (GLint *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttribI4iv(packed, ret_v) do { \
    PACKED_glVertexAttribI4iv *unpacked = (PACKED_glVertexAttribI4iv *)packed; \
    ARGS_glVertexAttribI4iv *args = (ARGS_glVertexAttribI4iv *)&unpacked->args; \
    glVertexAttribI4iv(args->index, args->v);; \
} while(0)
void glVertexAttribI4iv(glVertexAttribI4iv_ARG_EXPAND);
typedef void (*glVertexAttribI4iv_PTR)(glVertexAttribI4iv_ARG_EXPAND);
#define glVertexAttribI4ivEXT_INDEX 2497
#define glVertexAttribI4ivEXT_RETURN void
#define glVertexAttribI4ivEXT_ARG_NAMES index, v
#define glVertexAttribI4ivEXT_ARG_EXPAND GLuint index, const GLint * v
#define glVertexAttribI4ivEXT_PACKED PACKED_glVertexAttribI4ivEXT
#define glVertexAttribI4ivEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttribI4ivEXT_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttribI4ivEXT(_index, _v) ({ \
    glVertexAttribI4ivEXT_PACKED *packed_data = malloc(sizeof(glVertexAttribI4ivEXT_PACKED)); \
    packed_data->index = glVertexAttribI4ivEXT_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.v = (GLint *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttribI4ivEXT(packed, ret_v) do { \
    PACKED_glVertexAttribI4ivEXT *unpacked = (PACKED_glVertexAttribI4ivEXT *)packed; \
    ARGS_glVertexAttribI4ivEXT *args = (ARGS_glVertexAttribI4ivEXT *)&unpacked->args; \
    glVertexAttribI4ivEXT(args->index, args->v);; \
} while(0)
void glVertexAttribI4ivEXT(glVertexAttribI4ivEXT_ARG_EXPAND);
typedef void (*glVertexAttribI4ivEXT_PTR)(glVertexAttribI4ivEXT_ARG_EXPAND);
#define glVertexAttribI4sv_INDEX 2498
#define glVertexAttribI4sv_RETURN void
#define glVertexAttribI4sv_ARG_NAMES index, v
#define glVertexAttribI4sv_ARG_EXPAND GLuint index, const GLshort * v
#define glVertexAttribI4sv_PACKED PACKED_glVertexAttribI4sv
#define glVertexAttribI4sv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttribI4sv_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttribI4sv(_index, _v) ({ \
    glVertexAttribI4sv_PACKED *packed_data = malloc(sizeof(glVertexAttribI4sv_PACKED)); \
    packed_data->index = glVertexAttribI4sv_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.v = (GLshort *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttribI4sv(packed, ret_v) do { \
    PACKED_glVertexAttribI4sv *unpacked = (PACKED_glVertexAttribI4sv *)packed; \
    ARGS_glVertexAttribI4sv *args = (ARGS_glVertexAttribI4sv *)&unpacked->args; \
    glVertexAttribI4sv(args->index, args->v);; \
} while(0)
void glVertexAttribI4sv(glVertexAttribI4sv_ARG_EXPAND);
typedef void (*glVertexAttribI4sv_PTR)(glVertexAttribI4sv_ARG_EXPAND);
#define glVertexAttribI4svEXT_INDEX 2499
#define glVertexAttribI4svEXT_RETURN void
#define glVertexAttribI4svEXT_ARG_NAMES index, v
#define glVertexAttribI4svEXT_ARG_EXPAND GLuint index, const GLshort * v
#define glVertexAttribI4svEXT_PACKED PACKED_glVertexAttribI4svEXT
#define glVertexAttribI4svEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttribI4svEXT_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttribI4svEXT(_index, _v) ({ \
    glVertexAttribI4svEXT_PACKED *packed_data = malloc(sizeof(glVertexAttribI4svEXT_PACKED)); \
    packed_data->index = glVertexAttribI4svEXT_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.v = (GLshort *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttribI4svEXT(packed, ret_v) do { \
    PACKED_glVertexAttribI4svEXT *unpacked = (PACKED_glVertexAttribI4svEXT *)packed; \
    ARGS_glVertexAttribI4svEXT *args = (ARGS_glVertexAttribI4svEXT *)&unpacked->args; \
    glVertexAttribI4svEXT(args->index, args->v);; \
} while(0)
void glVertexAttribI4svEXT(glVertexAttribI4svEXT_ARG_EXPAND);
typedef void (*glVertexAttribI4svEXT_PTR)(glVertexAttribI4svEXT_ARG_EXPAND);
#define glVertexAttribI4ubv_INDEX 2500
#define glVertexAttribI4ubv_RETURN void
#define glVertexAttribI4ubv_ARG_NAMES index, v
#define glVertexAttribI4ubv_ARG_EXPAND GLuint index, const GLubyte * v
#define glVertexAttribI4ubv_PACKED PACKED_glVertexAttribI4ubv
#define glVertexAttribI4ubv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttribI4ubv_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttribI4ubv(_index, _v) ({ \
    glVertexAttribI4ubv_PACKED *packed_data = malloc(sizeof(glVertexAttribI4ubv_PACKED)); \
    packed_data->index = glVertexAttribI4ubv_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.v = (GLubyte *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttribI4ubv(packed, ret_v) do { \
    PACKED_glVertexAttribI4ubv *unpacked = (PACKED_glVertexAttribI4ubv *)packed; \
    ARGS_glVertexAttribI4ubv *args = (ARGS_glVertexAttribI4ubv *)&unpacked->args; \
    glVertexAttribI4ubv(args->index, args->v);; \
} while(0)
void glVertexAttribI4ubv(glVertexAttribI4ubv_ARG_EXPAND);
typedef void (*glVertexAttribI4ubv_PTR)(glVertexAttribI4ubv_ARG_EXPAND);
#define glVertexAttribI4ubvEXT_INDEX 2501
#define glVertexAttribI4ubvEXT_RETURN void
#define glVertexAttribI4ubvEXT_ARG_NAMES index, v
#define glVertexAttribI4ubvEXT_ARG_EXPAND GLuint index, const GLubyte * v
#define glVertexAttribI4ubvEXT_PACKED PACKED_glVertexAttribI4ubvEXT
#define glVertexAttribI4ubvEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttribI4ubvEXT_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttribI4ubvEXT(_index, _v) ({ \
    glVertexAttribI4ubvEXT_PACKED *packed_data = malloc(sizeof(glVertexAttribI4ubvEXT_PACKED)); \
    packed_data->index = glVertexAttribI4ubvEXT_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.v = (GLubyte *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttribI4ubvEXT(packed, ret_v) do { \
    PACKED_glVertexAttribI4ubvEXT *unpacked = (PACKED_glVertexAttribI4ubvEXT *)packed; \
    ARGS_glVertexAttribI4ubvEXT *args = (ARGS_glVertexAttribI4ubvEXT *)&unpacked->args; \
    glVertexAttribI4ubvEXT(args->index, args->v);; \
} while(0)
void glVertexAttribI4ubvEXT(glVertexAttribI4ubvEXT_ARG_EXPAND);
typedef void (*glVertexAttribI4ubvEXT_PTR)(glVertexAttribI4ubvEXT_ARG_EXPAND);
#define glVertexAttribI4ui_INDEX 2502
#define glVertexAttribI4ui_RETURN void
#define glVertexAttribI4ui_ARG_NAMES index, x, y, z, w
#define glVertexAttribI4ui_ARG_EXPAND GLuint index, GLuint x, GLuint y, GLuint z, GLuint w
#define glVertexAttribI4ui_PACKED PACKED_glVertexAttribI4ui
#define glVertexAttribI4ui_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttribI4ui_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttribI4ui(_index, _x, _y, _z, _w) ({ \
    glVertexAttribI4ui_PACKED *packed_data = malloc(sizeof(glVertexAttribI4ui_PACKED)); \
    packed_data->index = glVertexAttribI4ui_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.x = (GLuint)_x; \
    packed_data->args.y = (GLuint)_y; \
    packed_data->args.z = (GLuint)_z; \
    packed_data->args.w = (GLuint)_w; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttribI4ui(packed, ret_v) do { \
    PACKED_glVertexAttribI4ui *unpacked = (PACKED_glVertexAttribI4ui *)packed; \
    ARGS_glVertexAttribI4ui *args = (ARGS_glVertexAttribI4ui *)&unpacked->args; \
    glVertexAttribI4ui(args->index, args->x, args->y, args->z, args->w);; \
} while(0)
void glVertexAttribI4ui(glVertexAttribI4ui_ARG_EXPAND);
typedef void (*glVertexAttribI4ui_PTR)(glVertexAttribI4ui_ARG_EXPAND);
#define glVertexAttribI4uiEXT_INDEX 2503
#define glVertexAttribI4uiEXT_RETURN void
#define glVertexAttribI4uiEXT_ARG_NAMES index, x, y, z, w
#define glVertexAttribI4uiEXT_ARG_EXPAND GLuint index, GLuint x, GLuint y, GLuint z, GLuint w
#define glVertexAttribI4uiEXT_PACKED PACKED_glVertexAttribI4uiEXT
#define glVertexAttribI4uiEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttribI4uiEXT_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttribI4uiEXT(_index, _x, _y, _z, _w) ({ \
    glVertexAttribI4uiEXT_PACKED *packed_data = malloc(sizeof(glVertexAttribI4uiEXT_PACKED)); \
    packed_data->index = glVertexAttribI4uiEXT_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.x = (GLuint)_x; \
    packed_data->args.y = (GLuint)_y; \
    packed_data->args.z = (GLuint)_z; \
    packed_data->args.w = (GLuint)_w; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttribI4uiEXT(packed, ret_v) do { \
    PACKED_glVertexAttribI4uiEXT *unpacked = (PACKED_glVertexAttribI4uiEXT *)packed; \
    ARGS_glVertexAttribI4uiEXT *args = (ARGS_glVertexAttribI4uiEXT *)&unpacked->args; \
    glVertexAttribI4uiEXT(args->index, args->x, args->y, args->z, args->w);; \
} while(0)
void glVertexAttribI4uiEXT(glVertexAttribI4uiEXT_ARG_EXPAND);
typedef void (*glVertexAttribI4uiEXT_PTR)(glVertexAttribI4uiEXT_ARG_EXPAND);
#define glVertexAttribI4uiv_INDEX 2504
#define glVertexAttribI4uiv_RETURN void
#define glVertexAttribI4uiv_ARG_NAMES index, v
#define glVertexAttribI4uiv_ARG_EXPAND GLuint index, const GLuint * v
#define glVertexAttribI4uiv_PACKED PACKED_glVertexAttribI4uiv
#define glVertexAttribI4uiv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttribI4uiv_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttribI4uiv(_index, _v) ({ \
    glVertexAttribI4uiv_PACKED *packed_data = malloc(sizeof(glVertexAttribI4uiv_PACKED)); \
    packed_data->index = glVertexAttribI4uiv_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.v = (GLuint *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttribI4uiv(packed, ret_v) do { \
    PACKED_glVertexAttribI4uiv *unpacked = (PACKED_glVertexAttribI4uiv *)packed; \
    ARGS_glVertexAttribI4uiv *args = (ARGS_glVertexAttribI4uiv *)&unpacked->args; \
    glVertexAttribI4uiv(args->index, args->v);; \
} while(0)
void glVertexAttribI4uiv(glVertexAttribI4uiv_ARG_EXPAND);
typedef void (*glVertexAttribI4uiv_PTR)(glVertexAttribI4uiv_ARG_EXPAND);
#define glVertexAttribI4uivEXT_INDEX 2505
#define glVertexAttribI4uivEXT_RETURN void
#define glVertexAttribI4uivEXT_ARG_NAMES index, v
#define glVertexAttribI4uivEXT_ARG_EXPAND GLuint index, const GLuint * v
#define glVertexAttribI4uivEXT_PACKED PACKED_glVertexAttribI4uivEXT
#define glVertexAttribI4uivEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttribI4uivEXT_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttribI4uivEXT(_index, _v) ({ \
    glVertexAttribI4uivEXT_PACKED *packed_data = malloc(sizeof(glVertexAttribI4uivEXT_PACKED)); \
    packed_data->index = glVertexAttribI4uivEXT_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.v = (GLuint *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttribI4uivEXT(packed, ret_v) do { \
    PACKED_glVertexAttribI4uivEXT *unpacked = (PACKED_glVertexAttribI4uivEXT *)packed; \
    ARGS_glVertexAttribI4uivEXT *args = (ARGS_glVertexAttribI4uivEXT *)&unpacked->args; \
    glVertexAttribI4uivEXT(args->index, args->v);; \
} while(0)
void glVertexAttribI4uivEXT(glVertexAttribI4uivEXT_ARG_EXPAND);
typedef void (*glVertexAttribI4uivEXT_PTR)(glVertexAttribI4uivEXT_ARG_EXPAND);
#define glVertexAttribI4usv_INDEX 2506
#define glVertexAttribI4usv_RETURN void
#define glVertexAttribI4usv_ARG_NAMES index, v
#define glVertexAttribI4usv_ARG_EXPAND GLuint index, const GLushort * v
#define glVertexAttribI4usv_PACKED PACKED_glVertexAttribI4usv
#define glVertexAttribI4usv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttribI4usv_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttribI4usv(_index, _v) ({ \
    glVertexAttribI4usv_PACKED *packed_data = malloc(sizeof(glVertexAttribI4usv_PACKED)); \
    packed_data->index = glVertexAttribI4usv_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.v = (GLushort *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttribI4usv(packed, ret_v) do { \
    PACKED_glVertexAttribI4usv *unpacked = (PACKED_glVertexAttribI4usv *)packed; \
    ARGS_glVertexAttribI4usv *args = (ARGS_glVertexAttribI4usv *)&unpacked->args; \
    glVertexAttribI4usv(args->index, args->v);; \
} while(0)
void glVertexAttribI4usv(glVertexAttribI4usv_ARG_EXPAND);
typedef void (*glVertexAttribI4usv_PTR)(glVertexAttribI4usv_ARG_EXPAND);
#define glVertexAttribI4usvEXT_INDEX 2507
#define glVertexAttribI4usvEXT_RETURN void
#define glVertexAttribI4usvEXT_ARG_NAMES index, v
#define glVertexAttribI4usvEXT_ARG_EXPAND GLuint index, const GLushort * v
#define glVertexAttribI4usvEXT_PACKED PACKED_glVertexAttribI4usvEXT
#define glVertexAttribI4usvEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttribI4usvEXT_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttribI4usvEXT(_index, _v) ({ \
    glVertexAttribI4usvEXT_PACKED *packed_data = malloc(sizeof(glVertexAttribI4usvEXT_PACKED)); \
    packed_data->index = glVertexAttribI4usvEXT_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.v = (GLushort *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttribI4usvEXT(packed, ret_v) do { \
    PACKED_glVertexAttribI4usvEXT *unpacked = (PACKED_glVertexAttribI4usvEXT *)packed; \
    ARGS_glVertexAttribI4usvEXT *args = (ARGS_glVertexAttribI4usvEXT *)&unpacked->args; \
    glVertexAttribI4usvEXT(args->index, args->v);; \
} while(0)
void glVertexAttribI4usvEXT(glVertexAttribI4usvEXT_ARG_EXPAND);
typedef void (*glVertexAttribI4usvEXT_PTR)(glVertexAttribI4usvEXT_ARG_EXPAND);
#define glVertexAttribIFormat_INDEX 2508
#define glVertexAttribIFormat_RETURN void
#define glVertexAttribIFormat_ARG_NAMES attribindex, size, type, relativeoffset
#define glVertexAttribIFormat_ARG_EXPAND GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset
#define glVertexAttribIFormat_PACKED PACKED_glVertexAttribIFormat
#define glVertexAttribIFormat_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttribIFormat_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttribIFormat(_attribindex, _size, _type, _relativeoffset) ({ \
    glVertexAttribIFormat_PACKED *packed_data = malloc(sizeof(glVertexAttribIFormat_PACKED)); \
    packed_data->index = glVertexAttribIFormat_INDEX; \
    packed_data->args.attribindex = (GLuint)_attribindex; \
    packed_data->args.size = (GLint)_size; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.relativeoffset = (GLuint)_relativeoffset; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttribIFormat(packed, ret_v) do { \
    PACKED_glVertexAttribIFormat *unpacked = (PACKED_glVertexAttribIFormat *)packed; \
    ARGS_glVertexAttribIFormat *args = (ARGS_glVertexAttribIFormat *)&unpacked->args; \
    glVertexAttribIFormat(args->attribindex, args->size, args->type, args->relativeoffset);; \
} while(0)
void glVertexAttribIFormat(glVertexAttribIFormat_ARG_EXPAND);
typedef void (*glVertexAttribIFormat_PTR)(glVertexAttribIFormat_ARG_EXPAND);
#define glVertexAttribIFormatNV_INDEX 2509
#define glVertexAttribIFormatNV_RETURN void
#define glVertexAttribIFormatNV_ARG_NAMES index, size, type, stride
#define glVertexAttribIFormatNV_ARG_EXPAND GLuint index, GLint size, GLenum type, GLsizei stride
#define glVertexAttribIFormatNV_PACKED PACKED_glVertexAttribIFormatNV
#define glVertexAttribIFormatNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttribIFormatNV_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttribIFormatNV(_index, _size, _type, _stride) ({ \
    glVertexAttribIFormatNV_PACKED *packed_data = malloc(sizeof(glVertexAttribIFormatNV_PACKED)); \
    packed_data->index = glVertexAttribIFormatNV_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.size = (GLint)_size; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.stride = (GLsizei)_stride; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttribIFormatNV(packed, ret_v) do { \
    PACKED_glVertexAttribIFormatNV *unpacked = (PACKED_glVertexAttribIFormatNV *)packed; \
    ARGS_glVertexAttribIFormatNV *args = (ARGS_glVertexAttribIFormatNV *)&unpacked->args; \
    glVertexAttribIFormatNV(args->index, args->size, args->type, args->stride);; \
} while(0)
void glVertexAttribIFormatNV(glVertexAttribIFormatNV_ARG_EXPAND);
typedef void (*glVertexAttribIFormatNV_PTR)(glVertexAttribIFormatNV_ARG_EXPAND);
#define glVertexAttribIPointer_INDEX 2510
#define glVertexAttribIPointer_RETURN void
#define glVertexAttribIPointer_ARG_NAMES index, size, type, stride, pointer
#define glVertexAttribIPointer_ARG_EXPAND GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid * pointer
#define glVertexAttribIPointer_PACKED PACKED_glVertexAttribIPointer
#define glVertexAttribIPointer_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttribIPointer_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttribIPointer(_index, _size, _type, _stride, _pointer) ({ \
    glVertexAttribIPointer_PACKED *packed_data = malloc(sizeof(glVertexAttribIPointer_PACKED)); \
    packed_data->index = glVertexAttribIPointer_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.size = (GLint)_size; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.stride = (GLsizei)_stride; \
    packed_data->args.pointer = (GLvoid *)_pointer; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttribIPointer(packed, ret_v) do { \
    PACKED_glVertexAttribIPointer *unpacked = (PACKED_glVertexAttribIPointer *)packed; \
    ARGS_glVertexAttribIPointer *args = (ARGS_glVertexAttribIPointer *)&unpacked->args; \
    glVertexAttribIPointer(args->index, args->size, args->type, args->stride, args->pointer);; \
} while(0)
void glVertexAttribIPointer(glVertexAttribIPointer_ARG_EXPAND);
typedef void (*glVertexAttribIPointer_PTR)(glVertexAttribIPointer_ARG_EXPAND);
#define glVertexAttribIPointerEXT_INDEX 2511
#define glVertexAttribIPointerEXT_RETURN void
#define glVertexAttribIPointerEXT_ARG_NAMES index, size, type, stride, pointer
#define glVertexAttribIPointerEXT_ARG_EXPAND GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid * pointer
#define glVertexAttribIPointerEXT_PACKED PACKED_glVertexAttribIPointerEXT
#define glVertexAttribIPointerEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttribIPointerEXT_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttribIPointerEXT(_index, _size, _type, _stride, _pointer) ({ \
    glVertexAttribIPointerEXT_PACKED *packed_data = malloc(sizeof(glVertexAttribIPointerEXT_PACKED)); \
    packed_data->index = glVertexAttribIPointerEXT_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.size = (GLint)_size; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.stride = (GLsizei)_stride; \
    packed_data->args.pointer = (GLvoid *)_pointer; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttribIPointerEXT(packed, ret_v) do { \
    PACKED_glVertexAttribIPointerEXT *unpacked = (PACKED_glVertexAttribIPointerEXT *)packed; \
    ARGS_glVertexAttribIPointerEXT *args = (ARGS_glVertexAttribIPointerEXT *)&unpacked->args; \
    glVertexAttribIPointerEXT(args->index, args->size, args->type, args->stride, args->pointer);; \
} while(0)
void glVertexAttribIPointerEXT(glVertexAttribIPointerEXT_ARG_EXPAND);
typedef void (*glVertexAttribIPointerEXT_PTR)(glVertexAttribIPointerEXT_ARG_EXPAND);
#define glVertexAttribL1d_INDEX 2512
#define glVertexAttribL1d_RETURN void
#define glVertexAttribL1d_ARG_NAMES index, x
#define glVertexAttribL1d_ARG_EXPAND GLuint index, GLdouble x
#define glVertexAttribL1d_PACKED PACKED_glVertexAttribL1d
#define glVertexAttribL1d_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttribL1d_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttribL1d(_index, _x) ({ \
    glVertexAttribL1d_PACKED *packed_data = malloc(sizeof(glVertexAttribL1d_PACKED)); \
    packed_data->index = glVertexAttribL1d_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.x = (GLdouble)_x; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttribL1d(packed, ret_v) do { \
    PACKED_glVertexAttribL1d *unpacked = (PACKED_glVertexAttribL1d *)packed; \
    ARGS_glVertexAttribL1d *args = (ARGS_glVertexAttribL1d *)&unpacked->args; \
    glVertexAttribL1d(args->index, args->x);; \
} while(0)
void glVertexAttribL1d(glVertexAttribL1d_ARG_EXPAND);
typedef void (*glVertexAttribL1d_PTR)(glVertexAttribL1d_ARG_EXPAND);
#define glVertexAttribL1dEXT_INDEX 2513
#define glVertexAttribL1dEXT_RETURN void
#define glVertexAttribL1dEXT_ARG_NAMES index, x
#define glVertexAttribL1dEXT_ARG_EXPAND GLuint index, GLdouble x
#define glVertexAttribL1dEXT_PACKED PACKED_glVertexAttribL1dEXT
#define glVertexAttribL1dEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttribL1dEXT_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttribL1dEXT(_index, _x) ({ \
    glVertexAttribL1dEXT_PACKED *packed_data = malloc(sizeof(glVertexAttribL1dEXT_PACKED)); \
    packed_data->index = glVertexAttribL1dEXT_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.x = (GLdouble)_x; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttribL1dEXT(packed, ret_v) do { \
    PACKED_glVertexAttribL1dEXT *unpacked = (PACKED_glVertexAttribL1dEXT *)packed; \
    ARGS_glVertexAttribL1dEXT *args = (ARGS_glVertexAttribL1dEXT *)&unpacked->args; \
    glVertexAttribL1dEXT(args->index, args->x);; \
} while(0)
void glVertexAttribL1dEXT(glVertexAttribL1dEXT_ARG_EXPAND);
typedef void (*glVertexAttribL1dEXT_PTR)(glVertexAttribL1dEXT_ARG_EXPAND);
#define glVertexAttribL1dv_INDEX 2514
#define glVertexAttribL1dv_RETURN void
#define glVertexAttribL1dv_ARG_NAMES index, v
#define glVertexAttribL1dv_ARG_EXPAND GLuint index, const GLdouble * v
#define glVertexAttribL1dv_PACKED PACKED_glVertexAttribL1dv
#define glVertexAttribL1dv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttribL1dv_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttribL1dv(_index, _v) ({ \
    glVertexAttribL1dv_PACKED *packed_data = malloc(sizeof(glVertexAttribL1dv_PACKED)); \
    packed_data->index = glVertexAttribL1dv_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.v = (GLdouble *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttribL1dv(packed, ret_v) do { \
    PACKED_glVertexAttribL1dv *unpacked = (PACKED_glVertexAttribL1dv *)packed; \
    ARGS_glVertexAttribL1dv *args = (ARGS_glVertexAttribL1dv *)&unpacked->args; \
    glVertexAttribL1dv(args->index, args->v);; \
} while(0)
void glVertexAttribL1dv(glVertexAttribL1dv_ARG_EXPAND);
typedef void (*glVertexAttribL1dv_PTR)(glVertexAttribL1dv_ARG_EXPAND);
#define glVertexAttribL1dvEXT_INDEX 2515
#define glVertexAttribL1dvEXT_RETURN void
#define glVertexAttribL1dvEXT_ARG_NAMES index, v
#define glVertexAttribL1dvEXT_ARG_EXPAND GLuint index, const GLdouble * v
#define glVertexAttribL1dvEXT_PACKED PACKED_glVertexAttribL1dvEXT
#define glVertexAttribL1dvEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttribL1dvEXT_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttribL1dvEXT(_index, _v) ({ \
    glVertexAttribL1dvEXT_PACKED *packed_data = malloc(sizeof(glVertexAttribL1dvEXT_PACKED)); \
    packed_data->index = glVertexAttribL1dvEXT_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.v = (GLdouble *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttribL1dvEXT(packed, ret_v) do { \
    PACKED_glVertexAttribL1dvEXT *unpacked = (PACKED_glVertexAttribL1dvEXT *)packed; \
    ARGS_glVertexAttribL1dvEXT *args = (ARGS_glVertexAttribL1dvEXT *)&unpacked->args; \
    glVertexAttribL1dvEXT(args->index, args->v);; \
} while(0)
void glVertexAttribL1dvEXT(glVertexAttribL1dvEXT_ARG_EXPAND);
typedef void (*glVertexAttribL1dvEXT_PTR)(glVertexAttribL1dvEXT_ARG_EXPAND);
#define glVertexAttribL1i64NV_INDEX 2516
#define glVertexAttribL1i64NV_RETURN void
#define glVertexAttribL1i64NV_ARG_NAMES index, x
#define glVertexAttribL1i64NV_ARG_EXPAND GLuint index, GLint64EXT x
#define glVertexAttribL1i64NV_PACKED PACKED_glVertexAttribL1i64NV
#define glVertexAttribL1i64NV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttribL1i64NV_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttribL1i64NV(_index, _x) ({ \
    glVertexAttribL1i64NV_PACKED *packed_data = malloc(sizeof(glVertexAttribL1i64NV_PACKED)); \
    packed_data->index = glVertexAttribL1i64NV_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.x = (GLint64EXT)_x; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttribL1i64NV(packed, ret_v) do { \
    PACKED_glVertexAttribL1i64NV *unpacked = (PACKED_glVertexAttribL1i64NV *)packed; \
    ARGS_glVertexAttribL1i64NV *args = (ARGS_glVertexAttribL1i64NV *)&unpacked->args; \
    glVertexAttribL1i64NV(args->index, args->x);; \
} while(0)
void glVertexAttribL1i64NV(glVertexAttribL1i64NV_ARG_EXPAND);
typedef void (*glVertexAttribL1i64NV_PTR)(glVertexAttribL1i64NV_ARG_EXPAND);
#define glVertexAttribL1i64vNV_INDEX 2517
#define glVertexAttribL1i64vNV_RETURN void
#define glVertexAttribL1i64vNV_ARG_NAMES index, v
#define glVertexAttribL1i64vNV_ARG_EXPAND GLuint index, const GLint64EXT * v
#define glVertexAttribL1i64vNV_PACKED PACKED_glVertexAttribL1i64vNV
#define glVertexAttribL1i64vNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttribL1i64vNV_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttribL1i64vNV(_index, _v) ({ \
    glVertexAttribL1i64vNV_PACKED *packed_data = malloc(sizeof(glVertexAttribL1i64vNV_PACKED)); \
    packed_data->index = glVertexAttribL1i64vNV_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.v = (GLint64EXT *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttribL1i64vNV(packed, ret_v) do { \
    PACKED_glVertexAttribL1i64vNV *unpacked = (PACKED_glVertexAttribL1i64vNV *)packed; \
    ARGS_glVertexAttribL1i64vNV *args = (ARGS_glVertexAttribL1i64vNV *)&unpacked->args; \
    glVertexAttribL1i64vNV(args->index, args->v);; \
} while(0)
void glVertexAttribL1i64vNV(glVertexAttribL1i64vNV_ARG_EXPAND);
typedef void (*glVertexAttribL1i64vNV_PTR)(glVertexAttribL1i64vNV_ARG_EXPAND);
#define glVertexAttribL1ui64NV_INDEX 2518
#define glVertexAttribL1ui64NV_RETURN void
#define glVertexAttribL1ui64NV_ARG_NAMES index, x
#define glVertexAttribL1ui64NV_ARG_EXPAND GLuint index, GLuint64EXT x
#define glVertexAttribL1ui64NV_PACKED PACKED_glVertexAttribL1ui64NV
#define glVertexAttribL1ui64NV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttribL1ui64NV_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttribL1ui64NV(_index, _x) ({ \
    glVertexAttribL1ui64NV_PACKED *packed_data = malloc(sizeof(glVertexAttribL1ui64NV_PACKED)); \
    packed_data->index = glVertexAttribL1ui64NV_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.x = (GLuint64EXT)_x; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttribL1ui64NV(packed, ret_v) do { \
    PACKED_glVertexAttribL1ui64NV *unpacked = (PACKED_glVertexAttribL1ui64NV *)packed; \
    ARGS_glVertexAttribL1ui64NV *args = (ARGS_glVertexAttribL1ui64NV *)&unpacked->args; \
    glVertexAttribL1ui64NV(args->index, args->x);; \
} while(0)
void glVertexAttribL1ui64NV(glVertexAttribL1ui64NV_ARG_EXPAND);
typedef void (*glVertexAttribL1ui64NV_PTR)(glVertexAttribL1ui64NV_ARG_EXPAND);
#define glVertexAttribL1ui64vNV_INDEX 2519
#define glVertexAttribL1ui64vNV_RETURN void
#define glVertexAttribL1ui64vNV_ARG_NAMES index, v
#define glVertexAttribL1ui64vNV_ARG_EXPAND GLuint index, const GLuint64EXT * v
#define glVertexAttribL1ui64vNV_PACKED PACKED_glVertexAttribL1ui64vNV
#define glVertexAttribL1ui64vNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttribL1ui64vNV_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttribL1ui64vNV(_index, _v) ({ \
    glVertexAttribL1ui64vNV_PACKED *packed_data = malloc(sizeof(glVertexAttribL1ui64vNV_PACKED)); \
    packed_data->index = glVertexAttribL1ui64vNV_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.v = (GLuint64EXT *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttribL1ui64vNV(packed, ret_v) do { \
    PACKED_glVertexAttribL1ui64vNV *unpacked = (PACKED_glVertexAttribL1ui64vNV *)packed; \
    ARGS_glVertexAttribL1ui64vNV *args = (ARGS_glVertexAttribL1ui64vNV *)&unpacked->args; \
    glVertexAttribL1ui64vNV(args->index, args->v);; \
} while(0)
void glVertexAttribL1ui64vNV(glVertexAttribL1ui64vNV_ARG_EXPAND);
typedef void (*glVertexAttribL1ui64vNV_PTR)(glVertexAttribL1ui64vNV_ARG_EXPAND);
#define glVertexAttribL2d_INDEX 2520
#define glVertexAttribL2d_RETURN void
#define glVertexAttribL2d_ARG_NAMES index, x, y
#define glVertexAttribL2d_ARG_EXPAND GLuint index, GLdouble x, GLdouble y
#define glVertexAttribL2d_PACKED PACKED_glVertexAttribL2d
#define glVertexAttribL2d_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttribL2d_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttribL2d(_index, _x, _y) ({ \
    glVertexAttribL2d_PACKED *packed_data = malloc(sizeof(glVertexAttribL2d_PACKED)); \
    packed_data->index = glVertexAttribL2d_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.x = (GLdouble)_x; \
    packed_data->args.y = (GLdouble)_y; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttribL2d(packed, ret_v) do { \
    PACKED_glVertexAttribL2d *unpacked = (PACKED_glVertexAttribL2d *)packed; \
    ARGS_glVertexAttribL2d *args = (ARGS_glVertexAttribL2d *)&unpacked->args; \
    glVertexAttribL2d(args->index, args->x, args->y);; \
} while(0)
void glVertexAttribL2d(glVertexAttribL2d_ARG_EXPAND);
typedef void (*glVertexAttribL2d_PTR)(glVertexAttribL2d_ARG_EXPAND);
#define glVertexAttribL2dEXT_INDEX 2521
#define glVertexAttribL2dEXT_RETURN void
#define glVertexAttribL2dEXT_ARG_NAMES index, x, y
#define glVertexAttribL2dEXT_ARG_EXPAND GLuint index, GLdouble x, GLdouble y
#define glVertexAttribL2dEXT_PACKED PACKED_glVertexAttribL2dEXT
#define glVertexAttribL2dEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttribL2dEXT_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttribL2dEXT(_index, _x, _y) ({ \
    glVertexAttribL2dEXT_PACKED *packed_data = malloc(sizeof(glVertexAttribL2dEXT_PACKED)); \
    packed_data->index = glVertexAttribL2dEXT_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.x = (GLdouble)_x; \
    packed_data->args.y = (GLdouble)_y; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttribL2dEXT(packed, ret_v) do { \
    PACKED_glVertexAttribL2dEXT *unpacked = (PACKED_glVertexAttribL2dEXT *)packed; \
    ARGS_glVertexAttribL2dEXT *args = (ARGS_glVertexAttribL2dEXT *)&unpacked->args; \
    glVertexAttribL2dEXT(args->index, args->x, args->y);; \
} while(0)
void glVertexAttribL2dEXT(glVertexAttribL2dEXT_ARG_EXPAND);
typedef void (*glVertexAttribL2dEXT_PTR)(glVertexAttribL2dEXT_ARG_EXPAND);
#define glVertexAttribL2dv_INDEX 2522
#define glVertexAttribL2dv_RETURN void
#define glVertexAttribL2dv_ARG_NAMES index, v
#define glVertexAttribL2dv_ARG_EXPAND GLuint index, const GLdouble * v
#define glVertexAttribL2dv_PACKED PACKED_glVertexAttribL2dv
#define glVertexAttribL2dv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttribL2dv_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttribL2dv(_index, _v) ({ \
    glVertexAttribL2dv_PACKED *packed_data = malloc(sizeof(glVertexAttribL2dv_PACKED)); \
    packed_data->index = glVertexAttribL2dv_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.v = (GLdouble *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttribL2dv(packed, ret_v) do { \
    PACKED_glVertexAttribL2dv *unpacked = (PACKED_glVertexAttribL2dv *)packed; \
    ARGS_glVertexAttribL2dv *args = (ARGS_glVertexAttribL2dv *)&unpacked->args; \
    glVertexAttribL2dv(args->index, args->v);; \
} while(0)
void glVertexAttribL2dv(glVertexAttribL2dv_ARG_EXPAND);
typedef void (*glVertexAttribL2dv_PTR)(glVertexAttribL2dv_ARG_EXPAND);
#define glVertexAttribL2dvEXT_INDEX 2523
#define glVertexAttribL2dvEXT_RETURN void
#define glVertexAttribL2dvEXT_ARG_NAMES index, v
#define glVertexAttribL2dvEXT_ARG_EXPAND GLuint index, const GLdouble * v
#define glVertexAttribL2dvEXT_PACKED PACKED_glVertexAttribL2dvEXT
#define glVertexAttribL2dvEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttribL2dvEXT_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttribL2dvEXT(_index, _v) ({ \
    glVertexAttribL2dvEXT_PACKED *packed_data = malloc(sizeof(glVertexAttribL2dvEXT_PACKED)); \
    packed_data->index = glVertexAttribL2dvEXT_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.v = (GLdouble *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttribL2dvEXT(packed, ret_v) do { \
    PACKED_glVertexAttribL2dvEXT *unpacked = (PACKED_glVertexAttribL2dvEXT *)packed; \
    ARGS_glVertexAttribL2dvEXT *args = (ARGS_glVertexAttribL2dvEXT *)&unpacked->args; \
    glVertexAttribL2dvEXT(args->index, args->v);; \
} while(0)
void glVertexAttribL2dvEXT(glVertexAttribL2dvEXT_ARG_EXPAND);
typedef void (*glVertexAttribL2dvEXT_PTR)(glVertexAttribL2dvEXT_ARG_EXPAND);
#define glVertexAttribL2i64NV_INDEX 2524
#define glVertexAttribL2i64NV_RETURN void
#define glVertexAttribL2i64NV_ARG_NAMES index, x, y
#define glVertexAttribL2i64NV_ARG_EXPAND GLuint index, GLint64EXT x, GLint64EXT y
#define glVertexAttribL2i64NV_PACKED PACKED_glVertexAttribL2i64NV
#define glVertexAttribL2i64NV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttribL2i64NV_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttribL2i64NV(_index, _x, _y) ({ \
    glVertexAttribL2i64NV_PACKED *packed_data = malloc(sizeof(glVertexAttribL2i64NV_PACKED)); \
    packed_data->index = glVertexAttribL2i64NV_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.x = (GLint64EXT)_x; \
    packed_data->args.y = (GLint64EXT)_y; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttribL2i64NV(packed, ret_v) do { \
    PACKED_glVertexAttribL2i64NV *unpacked = (PACKED_glVertexAttribL2i64NV *)packed; \
    ARGS_glVertexAttribL2i64NV *args = (ARGS_glVertexAttribL2i64NV *)&unpacked->args; \
    glVertexAttribL2i64NV(args->index, args->x, args->y);; \
} while(0)
void glVertexAttribL2i64NV(glVertexAttribL2i64NV_ARG_EXPAND);
typedef void (*glVertexAttribL2i64NV_PTR)(glVertexAttribL2i64NV_ARG_EXPAND);
#define glVertexAttribL2i64vNV_INDEX 2525
#define glVertexAttribL2i64vNV_RETURN void
#define glVertexAttribL2i64vNV_ARG_NAMES index, v
#define glVertexAttribL2i64vNV_ARG_EXPAND GLuint index, const GLint64EXT * v
#define glVertexAttribL2i64vNV_PACKED PACKED_glVertexAttribL2i64vNV
#define glVertexAttribL2i64vNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttribL2i64vNV_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttribL2i64vNV(_index, _v) ({ \
    glVertexAttribL2i64vNV_PACKED *packed_data = malloc(sizeof(glVertexAttribL2i64vNV_PACKED)); \
    packed_data->index = glVertexAttribL2i64vNV_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.v = (GLint64EXT *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttribL2i64vNV(packed, ret_v) do { \
    PACKED_glVertexAttribL2i64vNV *unpacked = (PACKED_glVertexAttribL2i64vNV *)packed; \
    ARGS_glVertexAttribL2i64vNV *args = (ARGS_glVertexAttribL2i64vNV *)&unpacked->args; \
    glVertexAttribL2i64vNV(args->index, args->v);; \
} while(0)
void glVertexAttribL2i64vNV(glVertexAttribL2i64vNV_ARG_EXPAND);
typedef void (*glVertexAttribL2i64vNV_PTR)(glVertexAttribL2i64vNV_ARG_EXPAND);
#define glVertexAttribL2ui64NV_INDEX 2526
#define glVertexAttribL2ui64NV_RETURN void
#define glVertexAttribL2ui64NV_ARG_NAMES index, x, y
#define glVertexAttribL2ui64NV_ARG_EXPAND GLuint index, GLuint64EXT x, GLuint64EXT y
#define glVertexAttribL2ui64NV_PACKED PACKED_glVertexAttribL2ui64NV
#define glVertexAttribL2ui64NV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttribL2ui64NV_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttribL2ui64NV(_index, _x, _y) ({ \
    glVertexAttribL2ui64NV_PACKED *packed_data = malloc(sizeof(glVertexAttribL2ui64NV_PACKED)); \
    packed_data->index = glVertexAttribL2ui64NV_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.x = (GLuint64EXT)_x; \
    packed_data->args.y = (GLuint64EXT)_y; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttribL2ui64NV(packed, ret_v) do { \
    PACKED_glVertexAttribL2ui64NV *unpacked = (PACKED_glVertexAttribL2ui64NV *)packed; \
    ARGS_glVertexAttribL2ui64NV *args = (ARGS_glVertexAttribL2ui64NV *)&unpacked->args; \
    glVertexAttribL2ui64NV(args->index, args->x, args->y);; \
} while(0)
void glVertexAttribL2ui64NV(glVertexAttribL2ui64NV_ARG_EXPAND);
typedef void (*glVertexAttribL2ui64NV_PTR)(glVertexAttribL2ui64NV_ARG_EXPAND);
#define glVertexAttribL2ui64vNV_INDEX 2527
#define glVertexAttribL2ui64vNV_RETURN void
#define glVertexAttribL2ui64vNV_ARG_NAMES index, v
#define glVertexAttribL2ui64vNV_ARG_EXPAND GLuint index, const GLuint64EXT * v
#define glVertexAttribL2ui64vNV_PACKED PACKED_glVertexAttribL2ui64vNV
#define glVertexAttribL2ui64vNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttribL2ui64vNV_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttribL2ui64vNV(_index, _v) ({ \
    glVertexAttribL2ui64vNV_PACKED *packed_data = malloc(sizeof(glVertexAttribL2ui64vNV_PACKED)); \
    packed_data->index = glVertexAttribL2ui64vNV_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.v = (GLuint64EXT *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttribL2ui64vNV(packed, ret_v) do { \
    PACKED_glVertexAttribL2ui64vNV *unpacked = (PACKED_glVertexAttribL2ui64vNV *)packed; \
    ARGS_glVertexAttribL2ui64vNV *args = (ARGS_glVertexAttribL2ui64vNV *)&unpacked->args; \
    glVertexAttribL2ui64vNV(args->index, args->v);; \
} while(0)
void glVertexAttribL2ui64vNV(glVertexAttribL2ui64vNV_ARG_EXPAND);
typedef void (*glVertexAttribL2ui64vNV_PTR)(glVertexAttribL2ui64vNV_ARG_EXPAND);
#define glVertexAttribL3d_INDEX 2528
#define glVertexAttribL3d_RETURN void
#define glVertexAttribL3d_ARG_NAMES index, x, y, z
#define glVertexAttribL3d_ARG_EXPAND GLuint index, GLdouble x, GLdouble y, GLdouble z
#define glVertexAttribL3d_PACKED PACKED_glVertexAttribL3d
#define glVertexAttribL3d_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttribL3d_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttribL3d(_index, _x, _y, _z) ({ \
    glVertexAttribL3d_PACKED *packed_data = malloc(sizeof(glVertexAttribL3d_PACKED)); \
    packed_data->index = glVertexAttribL3d_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.x = (GLdouble)_x; \
    packed_data->args.y = (GLdouble)_y; \
    packed_data->args.z = (GLdouble)_z; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttribL3d(packed, ret_v) do { \
    PACKED_glVertexAttribL3d *unpacked = (PACKED_glVertexAttribL3d *)packed; \
    ARGS_glVertexAttribL3d *args = (ARGS_glVertexAttribL3d *)&unpacked->args; \
    glVertexAttribL3d(args->index, args->x, args->y, args->z);; \
} while(0)
void glVertexAttribL3d(glVertexAttribL3d_ARG_EXPAND);
typedef void (*glVertexAttribL3d_PTR)(glVertexAttribL3d_ARG_EXPAND);
#define glVertexAttribL3dEXT_INDEX 2529
#define glVertexAttribL3dEXT_RETURN void
#define glVertexAttribL3dEXT_ARG_NAMES index, x, y, z
#define glVertexAttribL3dEXT_ARG_EXPAND GLuint index, GLdouble x, GLdouble y, GLdouble z
#define glVertexAttribL3dEXT_PACKED PACKED_glVertexAttribL3dEXT
#define glVertexAttribL3dEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttribL3dEXT_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttribL3dEXT(_index, _x, _y, _z) ({ \
    glVertexAttribL3dEXT_PACKED *packed_data = malloc(sizeof(glVertexAttribL3dEXT_PACKED)); \
    packed_data->index = glVertexAttribL3dEXT_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.x = (GLdouble)_x; \
    packed_data->args.y = (GLdouble)_y; \
    packed_data->args.z = (GLdouble)_z; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttribL3dEXT(packed, ret_v) do { \
    PACKED_glVertexAttribL3dEXT *unpacked = (PACKED_glVertexAttribL3dEXT *)packed; \
    ARGS_glVertexAttribL3dEXT *args = (ARGS_glVertexAttribL3dEXT *)&unpacked->args; \
    glVertexAttribL3dEXT(args->index, args->x, args->y, args->z);; \
} while(0)
void glVertexAttribL3dEXT(glVertexAttribL3dEXT_ARG_EXPAND);
typedef void (*glVertexAttribL3dEXT_PTR)(glVertexAttribL3dEXT_ARG_EXPAND);
#define glVertexAttribL3dv_INDEX 2530
#define glVertexAttribL3dv_RETURN void
#define glVertexAttribL3dv_ARG_NAMES index, v
#define glVertexAttribL3dv_ARG_EXPAND GLuint index, const GLdouble * v
#define glVertexAttribL3dv_PACKED PACKED_glVertexAttribL3dv
#define glVertexAttribL3dv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttribL3dv_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttribL3dv(_index, _v) ({ \
    glVertexAttribL3dv_PACKED *packed_data = malloc(sizeof(glVertexAttribL3dv_PACKED)); \
    packed_data->index = glVertexAttribL3dv_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.v = (GLdouble *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttribL3dv(packed, ret_v) do { \
    PACKED_glVertexAttribL3dv *unpacked = (PACKED_glVertexAttribL3dv *)packed; \
    ARGS_glVertexAttribL3dv *args = (ARGS_glVertexAttribL3dv *)&unpacked->args; \
    glVertexAttribL3dv(args->index, args->v);; \
} while(0)
void glVertexAttribL3dv(glVertexAttribL3dv_ARG_EXPAND);
typedef void (*glVertexAttribL3dv_PTR)(glVertexAttribL3dv_ARG_EXPAND);
#define glVertexAttribL3dvEXT_INDEX 2531
#define glVertexAttribL3dvEXT_RETURN void
#define glVertexAttribL3dvEXT_ARG_NAMES index, v
#define glVertexAttribL3dvEXT_ARG_EXPAND GLuint index, const GLdouble * v
#define glVertexAttribL3dvEXT_PACKED PACKED_glVertexAttribL3dvEXT
#define glVertexAttribL3dvEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttribL3dvEXT_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttribL3dvEXT(_index, _v) ({ \
    glVertexAttribL3dvEXT_PACKED *packed_data = malloc(sizeof(glVertexAttribL3dvEXT_PACKED)); \
    packed_data->index = glVertexAttribL3dvEXT_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.v = (GLdouble *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttribL3dvEXT(packed, ret_v) do { \
    PACKED_glVertexAttribL3dvEXT *unpacked = (PACKED_glVertexAttribL3dvEXT *)packed; \
    ARGS_glVertexAttribL3dvEXT *args = (ARGS_glVertexAttribL3dvEXT *)&unpacked->args; \
    glVertexAttribL3dvEXT(args->index, args->v);; \
} while(0)
void glVertexAttribL3dvEXT(glVertexAttribL3dvEXT_ARG_EXPAND);
typedef void (*glVertexAttribL3dvEXT_PTR)(glVertexAttribL3dvEXT_ARG_EXPAND);
#define glVertexAttribL3i64NV_INDEX 2532
#define glVertexAttribL3i64NV_RETURN void
#define glVertexAttribL3i64NV_ARG_NAMES index, x, y, z
#define glVertexAttribL3i64NV_ARG_EXPAND GLuint index, GLint64EXT x, GLint64EXT y, GLint64EXT z
#define glVertexAttribL3i64NV_PACKED PACKED_glVertexAttribL3i64NV
#define glVertexAttribL3i64NV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttribL3i64NV_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttribL3i64NV(_index, _x, _y, _z) ({ \
    glVertexAttribL3i64NV_PACKED *packed_data = malloc(sizeof(glVertexAttribL3i64NV_PACKED)); \
    packed_data->index = glVertexAttribL3i64NV_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.x = (GLint64EXT)_x; \
    packed_data->args.y = (GLint64EXT)_y; \
    packed_data->args.z = (GLint64EXT)_z; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttribL3i64NV(packed, ret_v) do { \
    PACKED_glVertexAttribL3i64NV *unpacked = (PACKED_glVertexAttribL3i64NV *)packed; \
    ARGS_glVertexAttribL3i64NV *args = (ARGS_glVertexAttribL3i64NV *)&unpacked->args; \
    glVertexAttribL3i64NV(args->index, args->x, args->y, args->z);; \
} while(0)
void glVertexAttribL3i64NV(glVertexAttribL3i64NV_ARG_EXPAND);
typedef void (*glVertexAttribL3i64NV_PTR)(glVertexAttribL3i64NV_ARG_EXPAND);
#define glVertexAttribL3i64vNV_INDEX 2533
#define glVertexAttribL3i64vNV_RETURN void
#define glVertexAttribL3i64vNV_ARG_NAMES index, v
#define glVertexAttribL3i64vNV_ARG_EXPAND GLuint index, const GLint64EXT * v
#define glVertexAttribL3i64vNV_PACKED PACKED_glVertexAttribL3i64vNV
#define glVertexAttribL3i64vNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttribL3i64vNV_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttribL3i64vNV(_index, _v) ({ \
    glVertexAttribL3i64vNV_PACKED *packed_data = malloc(sizeof(glVertexAttribL3i64vNV_PACKED)); \
    packed_data->index = glVertexAttribL3i64vNV_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.v = (GLint64EXT *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttribL3i64vNV(packed, ret_v) do { \
    PACKED_glVertexAttribL3i64vNV *unpacked = (PACKED_glVertexAttribL3i64vNV *)packed; \
    ARGS_glVertexAttribL3i64vNV *args = (ARGS_glVertexAttribL3i64vNV *)&unpacked->args; \
    glVertexAttribL3i64vNV(args->index, args->v);; \
} while(0)
void glVertexAttribL3i64vNV(glVertexAttribL3i64vNV_ARG_EXPAND);
typedef void (*glVertexAttribL3i64vNV_PTR)(glVertexAttribL3i64vNV_ARG_EXPAND);
#define glVertexAttribL3ui64NV_INDEX 2534
#define glVertexAttribL3ui64NV_RETURN void
#define glVertexAttribL3ui64NV_ARG_NAMES index, x, y, z
#define glVertexAttribL3ui64NV_ARG_EXPAND GLuint index, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z
#define glVertexAttribL3ui64NV_PACKED PACKED_glVertexAttribL3ui64NV
#define glVertexAttribL3ui64NV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttribL3ui64NV_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttribL3ui64NV(_index, _x, _y, _z) ({ \
    glVertexAttribL3ui64NV_PACKED *packed_data = malloc(sizeof(glVertexAttribL3ui64NV_PACKED)); \
    packed_data->index = glVertexAttribL3ui64NV_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.x = (GLuint64EXT)_x; \
    packed_data->args.y = (GLuint64EXT)_y; \
    packed_data->args.z = (GLuint64EXT)_z; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttribL3ui64NV(packed, ret_v) do { \
    PACKED_glVertexAttribL3ui64NV *unpacked = (PACKED_glVertexAttribL3ui64NV *)packed; \
    ARGS_glVertexAttribL3ui64NV *args = (ARGS_glVertexAttribL3ui64NV *)&unpacked->args; \
    glVertexAttribL3ui64NV(args->index, args->x, args->y, args->z);; \
} while(0)
void glVertexAttribL3ui64NV(glVertexAttribL3ui64NV_ARG_EXPAND);
typedef void (*glVertexAttribL3ui64NV_PTR)(glVertexAttribL3ui64NV_ARG_EXPAND);
#define glVertexAttribL3ui64vNV_INDEX 2535
#define glVertexAttribL3ui64vNV_RETURN void
#define glVertexAttribL3ui64vNV_ARG_NAMES index, v
#define glVertexAttribL3ui64vNV_ARG_EXPAND GLuint index, const GLuint64EXT * v
#define glVertexAttribL3ui64vNV_PACKED PACKED_glVertexAttribL3ui64vNV
#define glVertexAttribL3ui64vNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttribL3ui64vNV_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttribL3ui64vNV(_index, _v) ({ \
    glVertexAttribL3ui64vNV_PACKED *packed_data = malloc(sizeof(glVertexAttribL3ui64vNV_PACKED)); \
    packed_data->index = glVertexAttribL3ui64vNV_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.v = (GLuint64EXT *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttribL3ui64vNV(packed, ret_v) do { \
    PACKED_glVertexAttribL3ui64vNV *unpacked = (PACKED_glVertexAttribL3ui64vNV *)packed; \
    ARGS_glVertexAttribL3ui64vNV *args = (ARGS_glVertexAttribL3ui64vNV *)&unpacked->args; \
    glVertexAttribL3ui64vNV(args->index, args->v);; \
} while(0)
void glVertexAttribL3ui64vNV(glVertexAttribL3ui64vNV_ARG_EXPAND);
typedef void (*glVertexAttribL3ui64vNV_PTR)(glVertexAttribL3ui64vNV_ARG_EXPAND);
#define glVertexAttribL4d_INDEX 2536
#define glVertexAttribL4d_RETURN void
#define glVertexAttribL4d_ARG_NAMES index, x, y, z, w
#define glVertexAttribL4d_ARG_EXPAND GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w
#define glVertexAttribL4d_PACKED PACKED_glVertexAttribL4d
#define glVertexAttribL4d_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttribL4d_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttribL4d(_index, _x, _y, _z, _w) ({ \
    glVertexAttribL4d_PACKED *packed_data = malloc(sizeof(glVertexAttribL4d_PACKED)); \
    packed_data->index = glVertexAttribL4d_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.x = (GLdouble)_x; \
    packed_data->args.y = (GLdouble)_y; \
    packed_data->args.z = (GLdouble)_z; \
    packed_data->args.w = (GLdouble)_w; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttribL4d(packed, ret_v) do { \
    PACKED_glVertexAttribL4d *unpacked = (PACKED_glVertexAttribL4d *)packed; \
    ARGS_glVertexAttribL4d *args = (ARGS_glVertexAttribL4d *)&unpacked->args; \
    glVertexAttribL4d(args->index, args->x, args->y, args->z, args->w);; \
} while(0)
void glVertexAttribL4d(glVertexAttribL4d_ARG_EXPAND);
typedef void (*glVertexAttribL4d_PTR)(glVertexAttribL4d_ARG_EXPAND);
#define glVertexAttribL4dEXT_INDEX 2537
#define glVertexAttribL4dEXT_RETURN void
#define glVertexAttribL4dEXT_ARG_NAMES index, x, y, z, w
#define glVertexAttribL4dEXT_ARG_EXPAND GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w
#define glVertexAttribL4dEXT_PACKED PACKED_glVertexAttribL4dEXT
#define glVertexAttribL4dEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttribL4dEXT_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttribL4dEXT(_index, _x, _y, _z, _w) ({ \
    glVertexAttribL4dEXT_PACKED *packed_data = malloc(sizeof(glVertexAttribL4dEXT_PACKED)); \
    packed_data->index = glVertexAttribL4dEXT_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.x = (GLdouble)_x; \
    packed_data->args.y = (GLdouble)_y; \
    packed_data->args.z = (GLdouble)_z; \
    packed_data->args.w = (GLdouble)_w; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttribL4dEXT(packed, ret_v) do { \
    PACKED_glVertexAttribL4dEXT *unpacked = (PACKED_glVertexAttribL4dEXT *)packed; \
    ARGS_glVertexAttribL4dEXT *args = (ARGS_glVertexAttribL4dEXT *)&unpacked->args; \
    glVertexAttribL4dEXT(args->index, args->x, args->y, args->z, args->w);; \
} while(0)
void glVertexAttribL4dEXT(glVertexAttribL4dEXT_ARG_EXPAND);
typedef void (*glVertexAttribL4dEXT_PTR)(glVertexAttribL4dEXT_ARG_EXPAND);
#define glVertexAttribL4dv_INDEX 2538
#define glVertexAttribL4dv_RETURN void
#define glVertexAttribL4dv_ARG_NAMES index, v
#define glVertexAttribL4dv_ARG_EXPAND GLuint index, const GLdouble * v
#define glVertexAttribL4dv_PACKED PACKED_glVertexAttribL4dv
#define glVertexAttribL4dv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttribL4dv_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttribL4dv(_index, _v) ({ \
    glVertexAttribL4dv_PACKED *packed_data = malloc(sizeof(glVertexAttribL4dv_PACKED)); \
    packed_data->index = glVertexAttribL4dv_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.v = (GLdouble *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttribL4dv(packed, ret_v) do { \
    PACKED_glVertexAttribL4dv *unpacked = (PACKED_glVertexAttribL4dv *)packed; \
    ARGS_glVertexAttribL4dv *args = (ARGS_glVertexAttribL4dv *)&unpacked->args; \
    glVertexAttribL4dv(args->index, args->v);; \
} while(0)
void glVertexAttribL4dv(glVertexAttribL4dv_ARG_EXPAND);
typedef void (*glVertexAttribL4dv_PTR)(glVertexAttribL4dv_ARG_EXPAND);
#define glVertexAttribL4dvEXT_INDEX 2539
#define glVertexAttribL4dvEXT_RETURN void
#define glVertexAttribL4dvEXT_ARG_NAMES index, v
#define glVertexAttribL4dvEXT_ARG_EXPAND GLuint index, const GLdouble * v
#define glVertexAttribL4dvEXT_PACKED PACKED_glVertexAttribL4dvEXT
#define glVertexAttribL4dvEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttribL4dvEXT_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttribL4dvEXT(_index, _v) ({ \
    glVertexAttribL4dvEXT_PACKED *packed_data = malloc(sizeof(glVertexAttribL4dvEXT_PACKED)); \
    packed_data->index = glVertexAttribL4dvEXT_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.v = (GLdouble *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttribL4dvEXT(packed, ret_v) do { \
    PACKED_glVertexAttribL4dvEXT *unpacked = (PACKED_glVertexAttribL4dvEXT *)packed; \
    ARGS_glVertexAttribL4dvEXT *args = (ARGS_glVertexAttribL4dvEXT *)&unpacked->args; \
    glVertexAttribL4dvEXT(args->index, args->v);; \
} while(0)
void glVertexAttribL4dvEXT(glVertexAttribL4dvEXT_ARG_EXPAND);
typedef void (*glVertexAttribL4dvEXT_PTR)(glVertexAttribL4dvEXT_ARG_EXPAND);
#define glVertexAttribL4i64NV_INDEX 2540
#define glVertexAttribL4i64NV_RETURN void
#define glVertexAttribL4i64NV_ARG_NAMES index, x, y, z, w
#define glVertexAttribL4i64NV_ARG_EXPAND GLuint index, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w
#define glVertexAttribL4i64NV_PACKED PACKED_glVertexAttribL4i64NV
#define glVertexAttribL4i64NV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttribL4i64NV_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttribL4i64NV(_index, _x, _y, _z, _w) ({ \
    glVertexAttribL4i64NV_PACKED *packed_data = malloc(sizeof(glVertexAttribL4i64NV_PACKED)); \
    packed_data->index = glVertexAttribL4i64NV_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.x = (GLint64EXT)_x; \
    packed_data->args.y = (GLint64EXT)_y; \
    packed_data->args.z = (GLint64EXT)_z; \
    packed_data->args.w = (GLint64EXT)_w; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttribL4i64NV(packed, ret_v) do { \
    PACKED_glVertexAttribL4i64NV *unpacked = (PACKED_glVertexAttribL4i64NV *)packed; \
    ARGS_glVertexAttribL4i64NV *args = (ARGS_glVertexAttribL4i64NV *)&unpacked->args; \
    glVertexAttribL4i64NV(args->index, args->x, args->y, args->z, args->w);; \
} while(0)
void glVertexAttribL4i64NV(glVertexAttribL4i64NV_ARG_EXPAND);
typedef void (*glVertexAttribL4i64NV_PTR)(glVertexAttribL4i64NV_ARG_EXPAND);
#define glVertexAttribL4i64vNV_INDEX 2541
#define glVertexAttribL4i64vNV_RETURN void
#define glVertexAttribL4i64vNV_ARG_NAMES index, v
#define glVertexAttribL4i64vNV_ARG_EXPAND GLuint index, const GLint64EXT * v
#define glVertexAttribL4i64vNV_PACKED PACKED_glVertexAttribL4i64vNV
#define glVertexAttribL4i64vNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttribL4i64vNV_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttribL4i64vNV(_index, _v) ({ \
    glVertexAttribL4i64vNV_PACKED *packed_data = malloc(sizeof(glVertexAttribL4i64vNV_PACKED)); \
    packed_data->index = glVertexAttribL4i64vNV_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.v = (GLint64EXT *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttribL4i64vNV(packed, ret_v) do { \
    PACKED_glVertexAttribL4i64vNV *unpacked = (PACKED_glVertexAttribL4i64vNV *)packed; \
    ARGS_glVertexAttribL4i64vNV *args = (ARGS_glVertexAttribL4i64vNV *)&unpacked->args; \
    glVertexAttribL4i64vNV(args->index, args->v);; \
} while(0)
void glVertexAttribL4i64vNV(glVertexAttribL4i64vNV_ARG_EXPAND);
typedef void (*glVertexAttribL4i64vNV_PTR)(glVertexAttribL4i64vNV_ARG_EXPAND);
#define glVertexAttribL4ui64NV_INDEX 2542
#define glVertexAttribL4ui64NV_RETURN void
#define glVertexAttribL4ui64NV_ARG_NAMES index, x, y, z, w
#define glVertexAttribL4ui64NV_ARG_EXPAND GLuint index, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w
#define glVertexAttribL4ui64NV_PACKED PACKED_glVertexAttribL4ui64NV
#define glVertexAttribL4ui64NV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttribL4ui64NV_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttribL4ui64NV(_index, _x, _y, _z, _w) ({ \
    glVertexAttribL4ui64NV_PACKED *packed_data = malloc(sizeof(glVertexAttribL4ui64NV_PACKED)); \
    packed_data->index = glVertexAttribL4ui64NV_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.x = (GLuint64EXT)_x; \
    packed_data->args.y = (GLuint64EXT)_y; \
    packed_data->args.z = (GLuint64EXT)_z; \
    packed_data->args.w = (GLuint64EXT)_w; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttribL4ui64NV(packed, ret_v) do { \
    PACKED_glVertexAttribL4ui64NV *unpacked = (PACKED_glVertexAttribL4ui64NV *)packed; \
    ARGS_glVertexAttribL4ui64NV *args = (ARGS_glVertexAttribL4ui64NV *)&unpacked->args; \
    glVertexAttribL4ui64NV(args->index, args->x, args->y, args->z, args->w);; \
} while(0)
void glVertexAttribL4ui64NV(glVertexAttribL4ui64NV_ARG_EXPAND);
typedef void (*glVertexAttribL4ui64NV_PTR)(glVertexAttribL4ui64NV_ARG_EXPAND);
#define glVertexAttribL4ui64vNV_INDEX 2543
#define glVertexAttribL4ui64vNV_RETURN void
#define glVertexAttribL4ui64vNV_ARG_NAMES index, v
#define glVertexAttribL4ui64vNV_ARG_EXPAND GLuint index, const GLuint64EXT * v
#define glVertexAttribL4ui64vNV_PACKED PACKED_glVertexAttribL4ui64vNV
#define glVertexAttribL4ui64vNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttribL4ui64vNV_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttribL4ui64vNV(_index, _v) ({ \
    glVertexAttribL4ui64vNV_PACKED *packed_data = malloc(sizeof(glVertexAttribL4ui64vNV_PACKED)); \
    packed_data->index = glVertexAttribL4ui64vNV_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.v = (GLuint64EXT *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttribL4ui64vNV(packed, ret_v) do { \
    PACKED_glVertexAttribL4ui64vNV *unpacked = (PACKED_glVertexAttribL4ui64vNV *)packed; \
    ARGS_glVertexAttribL4ui64vNV *args = (ARGS_glVertexAttribL4ui64vNV *)&unpacked->args; \
    glVertexAttribL4ui64vNV(args->index, args->v);; \
} while(0)
void glVertexAttribL4ui64vNV(glVertexAttribL4ui64vNV_ARG_EXPAND);
typedef void (*glVertexAttribL4ui64vNV_PTR)(glVertexAttribL4ui64vNV_ARG_EXPAND);
#define glVertexAttribLFormat_INDEX 2544
#define glVertexAttribLFormat_RETURN void
#define glVertexAttribLFormat_ARG_NAMES attribindex, size, type, relativeoffset
#define glVertexAttribLFormat_ARG_EXPAND GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset
#define glVertexAttribLFormat_PACKED PACKED_glVertexAttribLFormat
#define glVertexAttribLFormat_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttribLFormat_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttribLFormat(_attribindex, _size, _type, _relativeoffset) ({ \
    glVertexAttribLFormat_PACKED *packed_data = malloc(sizeof(glVertexAttribLFormat_PACKED)); \
    packed_data->index = glVertexAttribLFormat_INDEX; \
    packed_data->args.attribindex = (GLuint)_attribindex; \
    packed_data->args.size = (GLint)_size; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.relativeoffset = (GLuint)_relativeoffset; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttribLFormat(packed, ret_v) do { \
    PACKED_glVertexAttribLFormat *unpacked = (PACKED_glVertexAttribLFormat *)packed; \
    ARGS_glVertexAttribLFormat *args = (ARGS_glVertexAttribLFormat *)&unpacked->args; \
    glVertexAttribLFormat(args->attribindex, args->size, args->type, args->relativeoffset);; \
} while(0)
void glVertexAttribLFormat(glVertexAttribLFormat_ARG_EXPAND);
typedef void (*glVertexAttribLFormat_PTR)(glVertexAttribLFormat_ARG_EXPAND);
#define glVertexAttribLFormatNV_INDEX 2545
#define glVertexAttribLFormatNV_RETURN void
#define glVertexAttribLFormatNV_ARG_NAMES index, size, type, stride
#define glVertexAttribLFormatNV_ARG_EXPAND GLuint index, GLint size, GLenum type, GLsizei stride
#define glVertexAttribLFormatNV_PACKED PACKED_glVertexAttribLFormatNV
#define glVertexAttribLFormatNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttribLFormatNV_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttribLFormatNV(_index, _size, _type, _stride) ({ \
    glVertexAttribLFormatNV_PACKED *packed_data = malloc(sizeof(glVertexAttribLFormatNV_PACKED)); \
    packed_data->index = glVertexAttribLFormatNV_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.size = (GLint)_size; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.stride = (GLsizei)_stride; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttribLFormatNV(packed, ret_v) do { \
    PACKED_glVertexAttribLFormatNV *unpacked = (PACKED_glVertexAttribLFormatNV *)packed; \
    ARGS_glVertexAttribLFormatNV *args = (ARGS_glVertexAttribLFormatNV *)&unpacked->args; \
    glVertexAttribLFormatNV(args->index, args->size, args->type, args->stride);; \
} while(0)
void glVertexAttribLFormatNV(glVertexAttribLFormatNV_ARG_EXPAND);
typedef void (*glVertexAttribLFormatNV_PTR)(glVertexAttribLFormatNV_ARG_EXPAND);
#define glVertexAttribLPointer_INDEX 2546
#define glVertexAttribLPointer_RETURN void
#define glVertexAttribLPointer_ARG_NAMES index, size, type, stride, pointer
#define glVertexAttribLPointer_ARG_EXPAND GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid * pointer
#define glVertexAttribLPointer_PACKED PACKED_glVertexAttribLPointer
#define glVertexAttribLPointer_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttribLPointer_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttribLPointer(_index, _size, _type, _stride, _pointer) ({ \
    glVertexAttribLPointer_PACKED *packed_data = malloc(sizeof(glVertexAttribLPointer_PACKED)); \
    packed_data->index = glVertexAttribLPointer_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.size = (GLint)_size; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.stride = (GLsizei)_stride; \
    packed_data->args.pointer = (GLvoid *)_pointer; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttribLPointer(packed, ret_v) do { \
    PACKED_glVertexAttribLPointer *unpacked = (PACKED_glVertexAttribLPointer *)packed; \
    ARGS_glVertexAttribLPointer *args = (ARGS_glVertexAttribLPointer *)&unpacked->args; \
    glVertexAttribLPointer(args->index, args->size, args->type, args->stride, args->pointer);; \
} while(0)
void glVertexAttribLPointer(glVertexAttribLPointer_ARG_EXPAND);
typedef void (*glVertexAttribLPointer_PTR)(glVertexAttribLPointer_ARG_EXPAND);
#define glVertexAttribLPointerEXT_INDEX 2547
#define glVertexAttribLPointerEXT_RETURN void
#define glVertexAttribLPointerEXT_ARG_NAMES index, size, type, stride, pointer
#define glVertexAttribLPointerEXT_ARG_EXPAND GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid * pointer
#define glVertexAttribLPointerEXT_PACKED PACKED_glVertexAttribLPointerEXT
#define glVertexAttribLPointerEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttribLPointerEXT_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttribLPointerEXT(_index, _size, _type, _stride, _pointer) ({ \
    glVertexAttribLPointerEXT_PACKED *packed_data = malloc(sizeof(glVertexAttribLPointerEXT_PACKED)); \
    packed_data->index = glVertexAttribLPointerEXT_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.size = (GLint)_size; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.stride = (GLsizei)_stride; \
    packed_data->args.pointer = (GLvoid *)_pointer; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttribLPointerEXT(packed, ret_v) do { \
    PACKED_glVertexAttribLPointerEXT *unpacked = (PACKED_glVertexAttribLPointerEXT *)packed; \
    ARGS_glVertexAttribLPointerEXT *args = (ARGS_glVertexAttribLPointerEXT *)&unpacked->args; \
    glVertexAttribLPointerEXT(args->index, args->size, args->type, args->stride, args->pointer);; \
} while(0)
void glVertexAttribLPointerEXT(glVertexAttribLPointerEXT_ARG_EXPAND);
typedef void (*glVertexAttribLPointerEXT_PTR)(glVertexAttribLPointerEXT_ARG_EXPAND);
#define glVertexAttribP1ui_INDEX 2548
#define glVertexAttribP1ui_RETURN void
#define glVertexAttribP1ui_ARG_NAMES index, type, normalized, value
#define glVertexAttribP1ui_ARG_EXPAND GLuint index, GLenum type, GLboolean normalized, GLuint value
#define glVertexAttribP1ui_PACKED PACKED_glVertexAttribP1ui
#define glVertexAttribP1ui_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttribP1ui_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttribP1ui(_index, _type, _normalized, _value) ({ \
    glVertexAttribP1ui_PACKED *packed_data = malloc(sizeof(glVertexAttribP1ui_PACKED)); \
    packed_data->index = glVertexAttribP1ui_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.normalized = (GLboolean)_normalized; \
    packed_data->args.value = (GLuint)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttribP1ui(packed, ret_v) do { \
    PACKED_glVertexAttribP1ui *unpacked = (PACKED_glVertexAttribP1ui *)packed; \
    ARGS_glVertexAttribP1ui *args = (ARGS_glVertexAttribP1ui *)&unpacked->args; \
    glVertexAttribP1ui(args->index, args->type, args->normalized, args->value);; \
} while(0)
void glVertexAttribP1ui(glVertexAttribP1ui_ARG_EXPAND);
typedef void (*glVertexAttribP1ui_PTR)(glVertexAttribP1ui_ARG_EXPAND);
#define glVertexAttribP1uiv_INDEX 2549
#define glVertexAttribP1uiv_RETURN void
#define glVertexAttribP1uiv_ARG_NAMES index, type, normalized, value
#define glVertexAttribP1uiv_ARG_EXPAND GLuint index, GLenum type, GLboolean normalized, const GLuint * value
#define glVertexAttribP1uiv_PACKED PACKED_glVertexAttribP1uiv
#define glVertexAttribP1uiv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttribP1uiv_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttribP1uiv(_index, _type, _normalized, _value) ({ \
    glVertexAttribP1uiv_PACKED *packed_data = malloc(sizeof(glVertexAttribP1uiv_PACKED)); \
    packed_data->index = glVertexAttribP1uiv_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.normalized = (GLboolean)_normalized; \
    packed_data->args.value = (GLuint *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttribP1uiv(packed, ret_v) do { \
    PACKED_glVertexAttribP1uiv *unpacked = (PACKED_glVertexAttribP1uiv *)packed; \
    ARGS_glVertexAttribP1uiv *args = (ARGS_glVertexAttribP1uiv *)&unpacked->args; \
    glVertexAttribP1uiv(args->index, args->type, args->normalized, args->value);; \
} while(0)
void glVertexAttribP1uiv(glVertexAttribP1uiv_ARG_EXPAND);
typedef void (*glVertexAttribP1uiv_PTR)(glVertexAttribP1uiv_ARG_EXPAND);
#define glVertexAttribP2ui_INDEX 2550
#define glVertexAttribP2ui_RETURN void
#define glVertexAttribP2ui_ARG_NAMES index, type, normalized, value
#define glVertexAttribP2ui_ARG_EXPAND GLuint index, GLenum type, GLboolean normalized, GLuint value
#define glVertexAttribP2ui_PACKED PACKED_glVertexAttribP2ui
#define glVertexAttribP2ui_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttribP2ui_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttribP2ui(_index, _type, _normalized, _value) ({ \
    glVertexAttribP2ui_PACKED *packed_data = malloc(sizeof(glVertexAttribP2ui_PACKED)); \
    packed_data->index = glVertexAttribP2ui_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.normalized = (GLboolean)_normalized; \
    packed_data->args.value = (GLuint)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttribP2ui(packed, ret_v) do { \
    PACKED_glVertexAttribP2ui *unpacked = (PACKED_glVertexAttribP2ui *)packed; \
    ARGS_glVertexAttribP2ui *args = (ARGS_glVertexAttribP2ui *)&unpacked->args; \
    glVertexAttribP2ui(args->index, args->type, args->normalized, args->value);; \
} while(0)
void glVertexAttribP2ui(glVertexAttribP2ui_ARG_EXPAND);
typedef void (*glVertexAttribP2ui_PTR)(glVertexAttribP2ui_ARG_EXPAND);
#define glVertexAttribP2uiv_INDEX 2551
#define glVertexAttribP2uiv_RETURN void
#define glVertexAttribP2uiv_ARG_NAMES index, type, normalized, value
#define glVertexAttribP2uiv_ARG_EXPAND GLuint index, GLenum type, GLboolean normalized, const GLuint * value
#define glVertexAttribP2uiv_PACKED PACKED_glVertexAttribP2uiv
#define glVertexAttribP2uiv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttribP2uiv_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttribP2uiv(_index, _type, _normalized, _value) ({ \
    glVertexAttribP2uiv_PACKED *packed_data = malloc(sizeof(glVertexAttribP2uiv_PACKED)); \
    packed_data->index = glVertexAttribP2uiv_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.normalized = (GLboolean)_normalized; \
    packed_data->args.value = (GLuint *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttribP2uiv(packed, ret_v) do { \
    PACKED_glVertexAttribP2uiv *unpacked = (PACKED_glVertexAttribP2uiv *)packed; \
    ARGS_glVertexAttribP2uiv *args = (ARGS_glVertexAttribP2uiv *)&unpacked->args; \
    glVertexAttribP2uiv(args->index, args->type, args->normalized, args->value);; \
} while(0)
void glVertexAttribP2uiv(glVertexAttribP2uiv_ARG_EXPAND);
typedef void (*glVertexAttribP2uiv_PTR)(glVertexAttribP2uiv_ARG_EXPAND);
#define glVertexAttribP3ui_INDEX 2552
#define glVertexAttribP3ui_RETURN void
#define glVertexAttribP3ui_ARG_NAMES index, type, normalized, value
#define glVertexAttribP3ui_ARG_EXPAND GLuint index, GLenum type, GLboolean normalized, GLuint value
#define glVertexAttribP3ui_PACKED PACKED_glVertexAttribP3ui
#define glVertexAttribP3ui_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttribP3ui_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttribP3ui(_index, _type, _normalized, _value) ({ \
    glVertexAttribP3ui_PACKED *packed_data = malloc(sizeof(glVertexAttribP3ui_PACKED)); \
    packed_data->index = glVertexAttribP3ui_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.normalized = (GLboolean)_normalized; \
    packed_data->args.value = (GLuint)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttribP3ui(packed, ret_v) do { \
    PACKED_glVertexAttribP3ui *unpacked = (PACKED_glVertexAttribP3ui *)packed; \
    ARGS_glVertexAttribP3ui *args = (ARGS_glVertexAttribP3ui *)&unpacked->args; \
    glVertexAttribP3ui(args->index, args->type, args->normalized, args->value);; \
} while(0)
void glVertexAttribP3ui(glVertexAttribP3ui_ARG_EXPAND);
typedef void (*glVertexAttribP3ui_PTR)(glVertexAttribP3ui_ARG_EXPAND);
#define glVertexAttribP3uiv_INDEX 2553
#define glVertexAttribP3uiv_RETURN void
#define glVertexAttribP3uiv_ARG_NAMES index, type, normalized, value
#define glVertexAttribP3uiv_ARG_EXPAND GLuint index, GLenum type, GLboolean normalized, const GLuint * value
#define glVertexAttribP3uiv_PACKED PACKED_glVertexAttribP3uiv
#define glVertexAttribP3uiv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttribP3uiv_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttribP3uiv(_index, _type, _normalized, _value) ({ \
    glVertexAttribP3uiv_PACKED *packed_data = malloc(sizeof(glVertexAttribP3uiv_PACKED)); \
    packed_data->index = glVertexAttribP3uiv_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.normalized = (GLboolean)_normalized; \
    packed_data->args.value = (GLuint *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttribP3uiv(packed, ret_v) do { \
    PACKED_glVertexAttribP3uiv *unpacked = (PACKED_glVertexAttribP3uiv *)packed; \
    ARGS_glVertexAttribP3uiv *args = (ARGS_glVertexAttribP3uiv *)&unpacked->args; \
    glVertexAttribP3uiv(args->index, args->type, args->normalized, args->value);; \
} while(0)
void glVertexAttribP3uiv(glVertexAttribP3uiv_ARG_EXPAND);
typedef void (*glVertexAttribP3uiv_PTR)(glVertexAttribP3uiv_ARG_EXPAND);
#define glVertexAttribP4ui_INDEX 2554
#define glVertexAttribP4ui_RETURN void
#define glVertexAttribP4ui_ARG_NAMES index, type, normalized, value
#define glVertexAttribP4ui_ARG_EXPAND GLuint index, GLenum type, GLboolean normalized, GLuint value
#define glVertexAttribP4ui_PACKED PACKED_glVertexAttribP4ui
#define glVertexAttribP4ui_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttribP4ui_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttribP4ui(_index, _type, _normalized, _value) ({ \
    glVertexAttribP4ui_PACKED *packed_data = malloc(sizeof(glVertexAttribP4ui_PACKED)); \
    packed_data->index = glVertexAttribP4ui_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.normalized = (GLboolean)_normalized; \
    packed_data->args.value = (GLuint)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttribP4ui(packed, ret_v) do { \
    PACKED_glVertexAttribP4ui *unpacked = (PACKED_glVertexAttribP4ui *)packed; \
    ARGS_glVertexAttribP4ui *args = (ARGS_glVertexAttribP4ui *)&unpacked->args; \
    glVertexAttribP4ui(args->index, args->type, args->normalized, args->value);; \
} while(0)
void glVertexAttribP4ui(glVertexAttribP4ui_ARG_EXPAND);
typedef void (*glVertexAttribP4ui_PTR)(glVertexAttribP4ui_ARG_EXPAND);
#define glVertexAttribP4uiv_INDEX 2555
#define glVertexAttribP4uiv_RETURN void
#define glVertexAttribP4uiv_ARG_NAMES index, type, normalized, value
#define glVertexAttribP4uiv_ARG_EXPAND GLuint index, GLenum type, GLboolean normalized, const GLuint * value
#define glVertexAttribP4uiv_PACKED PACKED_glVertexAttribP4uiv
#define glVertexAttribP4uiv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttribP4uiv_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttribP4uiv(_index, _type, _normalized, _value) ({ \
    glVertexAttribP4uiv_PACKED *packed_data = malloc(sizeof(glVertexAttribP4uiv_PACKED)); \
    packed_data->index = glVertexAttribP4uiv_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.normalized = (GLboolean)_normalized; \
    packed_data->args.value = (GLuint *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttribP4uiv(packed, ret_v) do { \
    PACKED_glVertexAttribP4uiv *unpacked = (PACKED_glVertexAttribP4uiv *)packed; \
    ARGS_glVertexAttribP4uiv *args = (ARGS_glVertexAttribP4uiv *)&unpacked->args; \
    glVertexAttribP4uiv(args->index, args->type, args->normalized, args->value);; \
} while(0)
void glVertexAttribP4uiv(glVertexAttribP4uiv_ARG_EXPAND);
typedef void (*glVertexAttribP4uiv_PTR)(glVertexAttribP4uiv_ARG_EXPAND);
#define glVertexAttribPointer_INDEX 2556
#define glVertexAttribPointer_RETURN void
#define glVertexAttribPointer_ARG_NAMES index, size, type, normalized, stride, pointer
#define glVertexAttribPointer_ARG_EXPAND GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid * pointer
#define glVertexAttribPointer_PACKED PACKED_glVertexAttribPointer
#define glVertexAttribPointer_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttribPointer_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttribPointer(_index, _size, _type, _normalized, _stride, _pointer) ({ \
    glVertexAttribPointer_PACKED *packed_data = malloc(sizeof(glVertexAttribPointer_PACKED)); \
    packed_data->index = glVertexAttribPointer_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.size = (GLint)_size; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.normalized = (GLboolean)_normalized; \
    packed_data->args.stride = (GLsizei)_stride; \
    packed_data->args.pointer = (GLvoid *)_pointer; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttribPointer(packed, ret_v) do { \
    PACKED_glVertexAttribPointer *unpacked = (PACKED_glVertexAttribPointer *)packed; \
    ARGS_glVertexAttribPointer *args = (ARGS_glVertexAttribPointer *)&unpacked->args; \
    glVertexAttribPointer(args->index, args->size, args->type, args->normalized, args->stride, args->pointer);; \
} while(0)
void glVertexAttribPointer(glVertexAttribPointer_ARG_EXPAND);
typedef void (*glVertexAttribPointer_PTR)(glVertexAttribPointer_ARG_EXPAND);
#define glVertexAttribPointerARB_INDEX 2557
#define glVertexAttribPointerARB_RETURN void
#define glVertexAttribPointerARB_ARG_NAMES index, size, type, normalized, stride, pointer
#define glVertexAttribPointerARB_ARG_EXPAND GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid * pointer
#define glVertexAttribPointerARB_PACKED PACKED_glVertexAttribPointerARB
#define glVertexAttribPointerARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttribPointerARB_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttribPointerARB(_index, _size, _type, _normalized, _stride, _pointer) ({ \
    glVertexAttribPointerARB_PACKED *packed_data = malloc(sizeof(glVertexAttribPointerARB_PACKED)); \
    packed_data->index = glVertexAttribPointerARB_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.size = (GLint)_size; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.normalized = (GLboolean)_normalized; \
    packed_data->args.stride = (GLsizei)_stride; \
    packed_data->args.pointer = (GLvoid *)_pointer; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttribPointerARB(packed, ret_v) do { \
    PACKED_glVertexAttribPointerARB *unpacked = (PACKED_glVertexAttribPointerARB *)packed; \
    ARGS_glVertexAttribPointerARB *args = (ARGS_glVertexAttribPointerARB *)&unpacked->args; \
    glVertexAttribPointerARB(args->index, args->size, args->type, args->normalized, args->stride, args->pointer);; \
} while(0)
void glVertexAttribPointerARB(glVertexAttribPointerARB_ARG_EXPAND);
typedef void (*glVertexAttribPointerARB_PTR)(glVertexAttribPointerARB_ARG_EXPAND);
#define glVertexAttribPointerNV_INDEX 2558
#define glVertexAttribPointerNV_RETURN void
#define glVertexAttribPointerNV_ARG_NAMES index, fsize, type, stride, pointer
#define glVertexAttribPointerNV_ARG_EXPAND GLuint index, GLint fsize, GLenum type, GLsizei stride, const GLvoid * pointer
#define glVertexAttribPointerNV_PACKED PACKED_glVertexAttribPointerNV
#define glVertexAttribPointerNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttribPointerNV_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttribPointerNV(_index, _fsize, _type, _stride, _pointer) ({ \
    glVertexAttribPointerNV_PACKED *packed_data = malloc(sizeof(glVertexAttribPointerNV_PACKED)); \
    packed_data->index = glVertexAttribPointerNV_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.fsize = (GLint)_fsize; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.stride = (GLsizei)_stride; \
    packed_data->args.pointer = (GLvoid *)_pointer; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttribPointerNV(packed, ret_v) do { \
    PACKED_glVertexAttribPointerNV *unpacked = (PACKED_glVertexAttribPointerNV *)packed; \
    ARGS_glVertexAttribPointerNV *args = (ARGS_glVertexAttribPointerNV *)&unpacked->args; \
    glVertexAttribPointerNV(args->index, args->fsize, args->type, args->stride, args->pointer);; \
} while(0)
void glVertexAttribPointerNV(glVertexAttribPointerNV_ARG_EXPAND);
typedef void (*glVertexAttribPointerNV_PTR)(glVertexAttribPointerNV_ARG_EXPAND);
#define glVertexAttribs1dvNV_INDEX 2559
#define glVertexAttribs1dvNV_RETURN void
#define glVertexAttribs1dvNV_ARG_NAMES index, count, v
#define glVertexAttribs1dvNV_ARG_EXPAND GLuint index, GLsizei count, const GLdouble * v
#define glVertexAttribs1dvNV_PACKED PACKED_glVertexAttribs1dvNV
#define glVertexAttribs1dvNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttribs1dvNV_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttribs1dvNV(_index, _count, _v) ({ \
    glVertexAttribs1dvNV_PACKED *packed_data = malloc(sizeof(glVertexAttribs1dvNV_PACKED)); \
    packed_data->index = glVertexAttribs1dvNV_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.v = (GLdouble *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttribs1dvNV(packed, ret_v) do { \
    PACKED_glVertexAttribs1dvNV *unpacked = (PACKED_glVertexAttribs1dvNV *)packed; \
    ARGS_glVertexAttribs1dvNV *args = (ARGS_glVertexAttribs1dvNV *)&unpacked->args; \
    glVertexAttribs1dvNV(args->index, args->count, args->v);; \
} while(0)
void glVertexAttribs1dvNV(glVertexAttribs1dvNV_ARG_EXPAND);
typedef void (*glVertexAttribs1dvNV_PTR)(glVertexAttribs1dvNV_ARG_EXPAND);
#define glVertexAttribs1fvNV_INDEX 2560
#define glVertexAttribs1fvNV_RETURN void
#define glVertexAttribs1fvNV_ARG_NAMES index, count, v
#define glVertexAttribs1fvNV_ARG_EXPAND GLuint index, GLsizei count, const GLfloat * v
#define glVertexAttribs1fvNV_PACKED PACKED_glVertexAttribs1fvNV
#define glVertexAttribs1fvNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttribs1fvNV_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttribs1fvNV(_index, _count, _v) ({ \
    glVertexAttribs1fvNV_PACKED *packed_data = malloc(sizeof(glVertexAttribs1fvNV_PACKED)); \
    packed_data->index = glVertexAttribs1fvNV_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.v = (GLfloat *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttribs1fvNV(packed, ret_v) do { \
    PACKED_glVertexAttribs1fvNV *unpacked = (PACKED_glVertexAttribs1fvNV *)packed; \
    ARGS_glVertexAttribs1fvNV *args = (ARGS_glVertexAttribs1fvNV *)&unpacked->args; \
    glVertexAttribs1fvNV(args->index, args->count, args->v);; \
} while(0)
void glVertexAttribs1fvNV(glVertexAttribs1fvNV_ARG_EXPAND);
typedef void (*glVertexAttribs1fvNV_PTR)(glVertexAttribs1fvNV_ARG_EXPAND);
#define glVertexAttribs1hvNV_INDEX 2561
#define glVertexAttribs1hvNV_RETURN void
#define glVertexAttribs1hvNV_ARG_NAMES index, n, v
#define glVertexAttribs1hvNV_ARG_EXPAND GLuint index, GLsizei n, const GLhalfNV * v
#define glVertexAttribs1hvNV_PACKED PACKED_glVertexAttribs1hvNV
#define glVertexAttribs1hvNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttribs1hvNV_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttribs1hvNV(_index, _n, _v) ({ \
    glVertexAttribs1hvNV_PACKED *packed_data = malloc(sizeof(glVertexAttribs1hvNV_PACKED)); \
    packed_data->index = glVertexAttribs1hvNV_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.n = (GLsizei)_n; \
    packed_data->args.v = (GLhalfNV *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttribs1hvNV(packed, ret_v) do { \
    PACKED_glVertexAttribs1hvNV *unpacked = (PACKED_glVertexAttribs1hvNV *)packed; \
    ARGS_glVertexAttribs1hvNV *args = (ARGS_glVertexAttribs1hvNV *)&unpacked->args; \
    glVertexAttribs1hvNV(args->index, args->n, args->v);; \
} while(0)
void glVertexAttribs1hvNV(glVertexAttribs1hvNV_ARG_EXPAND);
typedef void (*glVertexAttribs1hvNV_PTR)(glVertexAttribs1hvNV_ARG_EXPAND);
#define glVertexAttribs1svNV_INDEX 2562
#define glVertexAttribs1svNV_RETURN void
#define glVertexAttribs1svNV_ARG_NAMES index, count, v
#define glVertexAttribs1svNV_ARG_EXPAND GLuint index, GLsizei count, const GLshort * v
#define glVertexAttribs1svNV_PACKED PACKED_glVertexAttribs1svNV
#define glVertexAttribs1svNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttribs1svNV_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttribs1svNV(_index, _count, _v) ({ \
    glVertexAttribs1svNV_PACKED *packed_data = malloc(sizeof(glVertexAttribs1svNV_PACKED)); \
    packed_data->index = glVertexAttribs1svNV_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.v = (GLshort *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttribs1svNV(packed, ret_v) do { \
    PACKED_glVertexAttribs1svNV *unpacked = (PACKED_glVertexAttribs1svNV *)packed; \
    ARGS_glVertexAttribs1svNV *args = (ARGS_glVertexAttribs1svNV *)&unpacked->args; \
    glVertexAttribs1svNV(args->index, args->count, args->v);; \
} while(0)
void glVertexAttribs1svNV(glVertexAttribs1svNV_ARG_EXPAND);
typedef void (*glVertexAttribs1svNV_PTR)(glVertexAttribs1svNV_ARG_EXPAND);
#define glVertexAttribs2dvNV_INDEX 2563
#define glVertexAttribs2dvNV_RETURN void
#define glVertexAttribs2dvNV_ARG_NAMES index, count, v
#define glVertexAttribs2dvNV_ARG_EXPAND GLuint index, GLsizei count, const GLdouble * v
#define glVertexAttribs2dvNV_PACKED PACKED_glVertexAttribs2dvNV
#define glVertexAttribs2dvNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttribs2dvNV_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttribs2dvNV(_index, _count, _v) ({ \
    glVertexAttribs2dvNV_PACKED *packed_data = malloc(sizeof(glVertexAttribs2dvNV_PACKED)); \
    packed_data->index = glVertexAttribs2dvNV_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.v = (GLdouble *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttribs2dvNV(packed, ret_v) do { \
    PACKED_glVertexAttribs2dvNV *unpacked = (PACKED_glVertexAttribs2dvNV *)packed; \
    ARGS_glVertexAttribs2dvNV *args = (ARGS_glVertexAttribs2dvNV *)&unpacked->args; \
    glVertexAttribs2dvNV(args->index, args->count, args->v);; \
} while(0)
void glVertexAttribs2dvNV(glVertexAttribs2dvNV_ARG_EXPAND);
typedef void (*glVertexAttribs2dvNV_PTR)(glVertexAttribs2dvNV_ARG_EXPAND);
#define glVertexAttribs2fvNV_INDEX 2564
#define glVertexAttribs2fvNV_RETURN void
#define glVertexAttribs2fvNV_ARG_NAMES index, count, v
#define glVertexAttribs2fvNV_ARG_EXPAND GLuint index, GLsizei count, const GLfloat * v
#define glVertexAttribs2fvNV_PACKED PACKED_glVertexAttribs2fvNV
#define glVertexAttribs2fvNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttribs2fvNV_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttribs2fvNV(_index, _count, _v) ({ \
    glVertexAttribs2fvNV_PACKED *packed_data = malloc(sizeof(glVertexAttribs2fvNV_PACKED)); \
    packed_data->index = glVertexAttribs2fvNV_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.v = (GLfloat *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttribs2fvNV(packed, ret_v) do { \
    PACKED_glVertexAttribs2fvNV *unpacked = (PACKED_glVertexAttribs2fvNV *)packed; \
    ARGS_glVertexAttribs2fvNV *args = (ARGS_glVertexAttribs2fvNV *)&unpacked->args; \
    glVertexAttribs2fvNV(args->index, args->count, args->v);; \
} while(0)
void glVertexAttribs2fvNV(glVertexAttribs2fvNV_ARG_EXPAND);
typedef void (*glVertexAttribs2fvNV_PTR)(glVertexAttribs2fvNV_ARG_EXPAND);
#define glVertexAttribs2hvNV_INDEX 2565
#define glVertexAttribs2hvNV_RETURN void
#define glVertexAttribs2hvNV_ARG_NAMES index, n, v
#define glVertexAttribs2hvNV_ARG_EXPAND GLuint index, GLsizei n, const GLhalfNV * v
#define glVertexAttribs2hvNV_PACKED PACKED_glVertexAttribs2hvNV
#define glVertexAttribs2hvNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttribs2hvNV_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttribs2hvNV(_index, _n, _v) ({ \
    glVertexAttribs2hvNV_PACKED *packed_data = malloc(sizeof(glVertexAttribs2hvNV_PACKED)); \
    packed_data->index = glVertexAttribs2hvNV_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.n = (GLsizei)_n; \
    packed_data->args.v = (GLhalfNV *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttribs2hvNV(packed, ret_v) do { \
    PACKED_glVertexAttribs2hvNV *unpacked = (PACKED_glVertexAttribs2hvNV *)packed; \
    ARGS_glVertexAttribs2hvNV *args = (ARGS_glVertexAttribs2hvNV *)&unpacked->args; \
    glVertexAttribs2hvNV(args->index, args->n, args->v);; \
} while(0)
void glVertexAttribs2hvNV(glVertexAttribs2hvNV_ARG_EXPAND);
typedef void (*glVertexAttribs2hvNV_PTR)(glVertexAttribs2hvNV_ARG_EXPAND);
#define glVertexAttribs2svNV_INDEX 2566
#define glVertexAttribs2svNV_RETURN void
#define glVertexAttribs2svNV_ARG_NAMES index, count, v
#define glVertexAttribs2svNV_ARG_EXPAND GLuint index, GLsizei count, const GLshort * v
#define glVertexAttribs2svNV_PACKED PACKED_glVertexAttribs2svNV
#define glVertexAttribs2svNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttribs2svNV_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttribs2svNV(_index, _count, _v) ({ \
    glVertexAttribs2svNV_PACKED *packed_data = malloc(sizeof(glVertexAttribs2svNV_PACKED)); \
    packed_data->index = glVertexAttribs2svNV_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.v = (GLshort *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttribs2svNV(packed, ret_v) do { \
    PACKED_glVertexAttribs2svNV *unpacked = (PACKED_glVertexAttribs2svNV *)packed; \
    ARGS_glVertexAttribs2svNV *args = (ARGS_glVertexAttribs2svNV *)&unpacked->args; \
    glVertexAttribs2svNV(args->index, args->count, args->v);; \
} while(0)
void glVertexAttribs2svNV(glVertexAttribs2svNV_ARG_EXPAND);
typedef void (*glVertexAttribs2svNV_PTR)(glVertexAttribs2svNV_ARG_EXPAND);
#define glVertexAttribs3dvNV_INDEX 2567
#define glVertexAttribs3dvNV_RETURN void
#define glVertexAttribs3dvNV_ARG_NAMES index, count, v
#define glVertexAttribs3dvNV_ARG_EXPAND GLuint index, GLsizei count, const GLdouble * v
#define glVertexAttribs3dvNV_PACKED PACKED_glVertexAttribs3dvNV
#define glVertexAttribs3dvNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttribs3dvNV_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttribs3dvNV(_index, _count, _v) ({ \
    glVertexAttribs3dvNV_PACKED *packed_data = malloc(sizeof(glVertexAttribs3dvNV_PACKED)); \
    packed_data->index = glVertexAttribs3dvNV_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.v = (GLdouble *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttribs3dvNV(packed, ret_v) do { \
    PACKED_glVertexAttribs3dvNV *unpacked = (PACKED_glVertexAttribs3dvNV *)packed; \
    ARGS_glVertexAttribs3dvNV *args = (ARGS_glVertexAttribs3dvNV *)&unpacked->args; \
    glVertexAttribs3dvNV(args->index, args->count, args->v);; \
} while(0)
void glVertexAttribs3dvNV(glVertexAttribs3dvNV_ARG_EXPAND);
typedef void (*glVertexAttribs3dvNV_PTR)(glVertexAttribs3dvNV_ARG_EXPAND);
#define glVertexAttribs3fvNV_INDEX 2568
#define glVertexAttribs3fvNV_RETURN void
#define glVertexAttribs3fvNV_ARG_NAMES index, count, v
#define glVertexAttribs3fvNV_ARG_EXPAND GLuint index, GLsizei count, const GLfloat * v
#define glVertexAttribs3fvNV_PACKED PACKED_glVertexAttribs3fvNV
#define glVertexAttribs3fvNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttribs3fvNV_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttribs3fvNV(_index, _count, _v) ({ \
    glVertexAttribs3fvNV_PACKED *packed_data = malloc(sizeof(glVertexAttribs3fvNV_PACKED)); \
    packed_data->index = glVertexAttribs3fvNV_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.v = (GLfloat *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttribs3fvNV(packed, ret_v) do { \
    PACKED_glVertexAttribs3fvNV *unpacked = (PACKED_glVertexAttribs3fvNV *)packed; \
    ARGS_glVertexAttribs3fvNV *args = (ARGS_glVertexAttribs3fvNV *)&unpacked->args; \
    glVertexAttribs3fvNV(args->index, args->count, args->v);; \
} while(0)
void glVertexAttribs3fvNV(glVertexAttribs3fvNV_ARG_EXPAND);
typedef void (*glVertexAttribs3fvNV_PTR)(glVertexAttribs3fvNV_ARG_EXPAND);
#define glVertexAttribs3hvNV_INDEX 2569
#define glVertexAttribs3hvNV_RETURN void
#define glVertexAttribs3hvNV_ARG_NAMES index, n, v
#define glVertexAttribs3hvNV_ARG_EXPAND GLuint index, GLsizei n, const GLhalfNV * v
#define glVertexAttribs3hvNV_PACKED PACKED_glVertexAttribs3hvNV
#define glVertexAttribs3hvNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttribs3hvNV_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttribs3hvNV(_index, _n, _v) ({ \
    glVertexAttribs3hvNV_PACKED *packed_data = malloc(sizeof(glVertexAttribs3hvNV_PACKED)); \
    packed_data->index = glVertexAttribs3hvNV_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.n = (GLsizei)_n; \
    packed_data->args.v = (GLhalfNV *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttribs3hvNV(packed, ret_v) do { \
    PACKED_glVertexAttribs3hvNV *unpacked = (PACKED_glVertexAttribs3hvNV *)packed; \
    ARGS_glVertexAttribs3hvNV *args = (ARGS_glVertexAttribs3hvNV *)&unpacked->args; \
    glVertexAttribs3hvNV(args->index, args->n, args->v);; \
} while(0)
void glVertexAttribs3hvNV(glVertexAttribs3hvNV_ARG_EXPAND);
typedef void (*glVertexAttribs3hvNV_PTR)(glVertexAttribs3hvNV_ARG_EXPAND);
#define glVertexAttribs3svNV_INDEX 2570
#define glVertexAttribs3svNV_RETURN void
#define glVertexAttribs3svNV_ARG_NAMES index, count, v
#define glVertexAttribs3svNV_ARG_EXPAND GLuint index, GLsizei count, const GLshort * v
#define glVertexAttribs3svNV_PACKED PACKED_glVertexAttribs3svNV
#define glVertexAttribs3svNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttribs3svNV_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttribs3svNV(_index, _count, _v) ({ \
    glVertexAttribs3svNV_PACKED *packed_data = malloc(sizeof(glVertexAttribs3svNV_PACKED)); \
    packed_data->index = glVertexAttribs3svNV_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.v = (GLshort *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttribs3svNV(packed, ret_v) do { \
    PACKED_glVertexAttribs3svNV *unpacked = (PACKED_glVertexAttribs3svNV *)packed; \
    ARGS_glVertexAttribs3svNV *args = (ARGS_glVertexAttribs3svNV *)&unpacked->args; \
    glVertexAttribs3svNV(args->index, args->count, args->v);; \
} while(0)
void glVertexAttribs3svNV(glVertexAttribs3svNV_ARG_EXPAND);
typedef void (*glVertexAttribs3svNV_PTR)(glVertexAttribs3svNV_ARG_EXPAND);
#define glVertexAttribs4dvNV_INDEX 2571
#define glVertexAttribs4dvNV_RETURN void
#define glVertexAttribs4dvNV_ARG_NAMES index, count, v
#define glVertexAttribs4dvNV_ARG_EXPAND GLuint index, GLsizei count, const GLdouble * v
#define glVertexAttribs4dvNV_PACKED PACKED_glVertexAttribs4dvNV
#define glVertexAttribs4dvNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttribs4dvNV_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttribs4dvNV(_index, _count, _v) ({ \
    glVertexAttribs4dvNV_PACKED *packed_data = malloc(sizeof(glVertexAttribs4dvNV_PACKED)); \
    packed_data->index = glVertexAttribs4dvNV_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.v = (GLdouble *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttribs4dvNV(packed, ret_v) do { \
    PACKED_glVertexAttribs4dvNV *unpacked = (PACKED_glVertexAttribs4dvNV *)packed; \
    ARGS_glVertexAttribs4dvNV *args = (ARGS_glVertexAttribs4dvNV *)&unpacked->args; \
    glVertexAttribs4dvNV(args->index, args->count, args->v);; \
} while(0)
void glVertexAttribs4dvNV(glVertexAttribs4dvNV_ARG_EXPAND);
typedef void (*glVertexAttribs4dvNV_PTR)(glVertexAttribs4dvNV_ARG_EXPAND);
#define glVertexAttribs4fvNV_INDEX 2572
#define glVertexAttribs4fvNV_RETURN void
#define glVertexAttribs4fvNV_ARG_NAMES index, count, v
#define glVertexAttribs4fvNV_ARG_EXPAND GLuint index, GLsizei count, const GLfloat * v
#define glVertexAttribs4fvNV_PACKED PACKED_glVertexAttribs4fvNV
#define glVertexAttribs4fvNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttribs4fvNV_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttribs4fvNV(_index, _count, _v) ({ \
    glVertexAttribs4fvNV_PACKED *packed_data = malloc(sizeof(glVertexAttribs4fvNV_PACKED)); \
    packed_data->index = glVertexAttribs4fvNV_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.v = (GLfloat *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttribs4fvNV(packed, ret_v) do { \
    PACKED_glVertexAttribs4fvNV *unpacked = (PACKED_glVertexAttribs4fvNV *)packed; \
    ARGS_glVertexAttribs4fvNV *args = (ARGS_glVertexAttribs4fvNV *)&unpacked->args; \
    glVertexAttribs4fvNV(args->index, args->count, args->v);; \
} while(0)
void glVertexAttribs4fvNV(glVertexAttribs4fvNV_ARG_EXPAND);
typedef void (*glVertexAttribs4fvNV_PTR)(glVertexAttribs4fvNV_ARG_EXPAND);
#define glVertexAttribs4hvNV_INDEX 2573
#define glVertexAttribs4hvNV_RETURN void
#define glVertexAttribs4hvNV_ARG_NAMES index, n, v
#define glVertexAttribs4hvNV_ARG_EXPAND GLuint index, GLsizei n, const GLhalfNV * v
#define glVertexAttribs4hvNV_PACKED PACKED_glVertexAttribs4hvNV
#define glVertexAttribs4hvNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttribs4hvNV_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttribs4hvNV(_index, _n, _v) ({ \
    glVertexAttribs4hvNV_PACKED *packed_data = malloc(sizeof(glVertexAttribs4hvNV_PACKED)); \
    packed_data->index = glVertexAttribs4hvNV_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.n = (GLsizei)_n; \
    packed_data->args.v = (GLhalfNV *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttribs4hvNV(packed, ret_v) do { \
    PACKED_glVertexAttribs4hvNV *unpacked = (PACKED_glVertexAttribs4hvNV *)packed; \
    ARGS_glVertexAttribs4hvNV *args = (ARGS_glVertexAttribs4hvNV *)&unpacked->args; \
    glVertexAttribs4hvNV(args->index, args->n, args->v);; \
} while(0)
void glVertexAttribs4hvNV(glVertexAttribs4hvNV_ARG_EXPAND);
typedef void (*glVertexAttribs4hvNV_PTR)(glVertexAttribs4hvNV_ARG_EXPAND);
#define glVertexAttribs4svNV_INDEX 2574
#define glVertexAttribs4svNV_RETURN void
#define glVertexAttribs4svNV_ARG_NAMES index, count, v
#define glVertexAttribs4svNV_ARG_EXPAND GLuint index, GLsizei count, const GLshort * v
#define glVertexAttribs4svNV_PACKED PACKED_glVertexAttribs4svNV
#define glVertexAttribs4svNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttribs4svNV_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttribs4svNV(_index, _count, _v) ({ \
    glVertexAttribs4svNV_PACKED *packed_data = malloc(sizeof(glVertexAttribs4svNV_PACKED)); \
    packed_data->index = glVertexAttribs4svNV_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.v = (GLshort *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttribs4svNV(packed, ret_v) do { \
    PACKED_glVertexAttribs4svNV *unpacked = (PACKED_glVertexAttribs4svNV *)packed; \
    ARGS_glVertexAttribs4svNV *args = (ARGS_glVertexAttribs4svNV *)&unpacked->args; \
    glVertexAttribs4svNV(args->index, args->count, args->v);; \
} while(0)
void glVertexAttribs4svNV(glVertexAttribs4svNV_ARG_EXPAND);
typedef void (*glVertexAttribs4svNV_PTR)(glVertexAttribs4svNV_ARG_EXPAND);
#define glVertexAttribs4ubvNV_INDEX 2575
#define glVertexAttribs4ubvNV_RETURN void
#define glVertexAttribs4ubvNV_ARG_NAMES index, count, v
#define glVertexAttribs4ubvNV_ARG_EXPAND GLuint index, GLsizei count, const GLubyte * v
#define glVertexAttribs4ubvNV_PACKED PACKED_glVertexAttribs4ubvNV
#define glVertexAttribs4ubvNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexAttribs4ubvNV_NOT_VOID_WRAP(...) {}
#define pack_glVertexAttribs4ubvNV(_index, _count, _v) ({ \
    glVertexAttribs4ubvNV_PACKED *packed_data = malloc(sizeof(glVertexAttribs4ubvNV_PACKED)); \
    packed_data->index = glVertexAttribs4ubvNV_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.v = (GLubyte *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexAttribs4ubvNV(packed, ret_v) do { \
    PACKED_glVertexAttribs4ubvNV *unpacked = (PACKED_glVertexAttribs4ubvNV *)packed; \
    ARGS_glVertexAttribs4ubvNV *args = (ARGS_glVertexAttribs4ubvNV *)&unpacked->args; \
    glVertexAttribs4ubvNV(args->index, args->count, args->v);; \
} while(0)
void glVertexAttribs4ubvNV(glVertexAttribs4ubvNV_ARG_EXPAND);
typedef void (*glVertexAttribs4ubvNV_PTR)(glVertexAttribs4ubvNV_ARG_EXPAND);
#define glVertexBindingDivisor_INDEX 2576
#define glVertexBindingDivisor_RETURN void
#define glVertexBindingDivisor_ARG_NAMES bindingindex, divisor
#define glVertexBindingDivisor_ARG_EXPAND GLuint bindingindex, GLuint divisor
#define glVertexBindingDivisor_PACKED PACKED_glVertexBindingDivisor
#define glVertexBindingDivisor_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexBindingDivisor_NOT_VOID_WRAP(...) {}
#define pack_glVertexBindingDivisor(_bindingindex, _divisor) ({ \
    glVertexBindingDivisor_PACKED *packed_data = malloc(sizeof(glVertexBindingDivisor_PACKED)); \
    packed_data->index = glVertexBindingDivisor_INDEX; \
    packed_data->args.bindingindex = (GLuint)_bindingindex; \
    packed_data->args.divisor = (GLuint)_divisor; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexBindingDivisor(packed, ret_v) do { \
    PACKED_glVertexBindingDivisor *unpacked = (PACKED_glVertexBindingDivisor *)packed; \
    ARGS_glVertexBindingDivisor *args = (ARGS_glVertexBindingDivisor *)&unpacked->args; \
    glVertexBindingDivisor(args->bindingindex, args->divisor);; \
} while(0)
void glVertexBindingDivisor(glVertexBindingDivisor_ARG_EXPAND);
typedef void (*glVertexBindingDivisor_PTR)(glVertexBindingDivisor_ARG_EXPAND);
#define glVertexBlendARB_INDEX 2577
#define glVertexBlendARB_RETURN void
#define glVertexBlendARB_ARG_NAMES count
#define glVertexBlendARB_ARG_EXPAND GLint count
#define glVertexBlendARB_PACKED PACKED_glVertexBlendARB
#define glVertexBlendARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexBlendARB_NOT_VOID_WRAP(...) {}
#define pack_glVertexBlendARB(_count) ({ \
    glVertexBlendARB_PACKED *packed_data = malloc(sizeof(glVertexBlendARB_PACKED)); \
    packed_data->index = glVertexBlendARB_INDEX; \
    packed_data->args.count = (GLint)_count; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexBlendARB(packed, ret_v) do { \
    PACKED_glVertexBlendARB *unpacked = (PACKED_glVertexBlendARB *)packed; \
    ARGS_glVertexBlendARB *args = (ARGS_glVertexBlendARB *)&unpacked->args; \
    glVertexBlendARB(args->count);; \
} while(0)
void glVertexBlendARB(glVertexBlendARB_ARG_EXPAND);
typedef void (*glVertexBlendARB_PTR)(glVertexBlendARB_ARG_EXPAND);
#define glVertexBlendEnvfATI_INDEX 2578
#define glVertexBlendEnvfATI_RETURN void
#define glVertexBlendEnvfATI_ARG_NAMES pname, param
#define glVertexBlendEnvfATI_ARG_EXPAND GLenum pname, GLfloat param
#define glVertexBlendEnvfATI_PACKED PACKED_glVertexBlendEnvfATI
#define glVertexBlendEnvfATI_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexBlendEnvfATI_NOT_VOID_WRAP(...) {}
#define pack_glVertexBlendEnvfATI(_pname, _param) ({ \
    glVertexBlendEnvfATI_PACKED *packed_data = malloc(sizeof(glVertexBlendEnvfATI_PACKED)); \
    packed_data->index = glVertexBlendEnvfATI_INDEX; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.param = (GLfloat)_param; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexBlendEnvfATI(packed, ret_v) do { \
    PACKED_glVertexBlendEnvfATI *unpacked = (PACKED_glVertexBlendEnvfATI *)packed; \
    ARGS_glVertexBlendEnvfATI *args = (ARGS_glVertexBlendEnvfATI *)&unpacked->args; \
    glVertexBlendEnvfATI(args->pname, args->param);; \
} while(0)
void glVertexBlendEnvfATI(glVertexBlendEnvfATI_ARG_EXPAND);
typedef void (*glVertexBlendEnvfATI_PTR)(glVertexBlendEnvfATI_ARG_EXPAND);
#define glVertexBlendEnviATI_INDEX 2579
#define glVertexBlendEnviATI_RETURN void
#define glVertexBlendEnviATI_ARG_NAMES pname, param
#define glVertexBlendEnviATI_ARG_EXPAND GLenum pname, GLint param
#define glVertexBlendEnviATI_PACKED PACKED_glVertexBlendEnviATI
#define glVertexBlendEnviATI_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexBlendEnviATI_NOT_VOID_WRAP(...) {}
#define pack_glVertexBlendEnviATI(_pname, _param) ({ \
    glVertexBlendEnviATI_PACKED *packed_data = malloc(sizeof(glVertexBlendEnviATI_PACKED)); \
    packed_data->index = glVertexBlendEnviATI_INDEX; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.param = (GLint)_param; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexBlendEnviATI(packed, ret_v) do { \
    PACKED_glVertexBlendEnviATI *unpacked = (PACKED_glVertexBlendEnviATI *)packed; \
    ARGS_glVertexBlendEnviATI *args = (ARGS_glVertexBlendEnviATI *)&unpacked->args; \
    glVertexBlendEnviATI(args->pname, args->param);; \
} while(0)
void glVertexBlendEnviATI(glVertexBlendEnviATI_ARG_EXPAND);
typedef void (*glVertexBlendEnviATI_PTR)(glVertexBlendEnviATI_ARG_EXPAND);
#define glVertexFormatNV_INDEX 2580
#define glVertexFormatNV_RETURN void
#define glVertexFormatNV_ARG_NAMES size, type, stride
#define glVertexFormatNV_ARG_EXPAND GLint size, GLenum type, GLsizei stride
#define glVertexFormatNV_PACKED PACKED_glVertexFormatNV
#define glVertexFormatNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexFormatNV_NOT_VOID_WRAP(...) {}
#define pack_glVertexFormatNV(_size, _type, _stride) ({ \
    glVertexFormatNV_PACKED *packed_data = malloc(sizeof(glVertexFormatNV_PACKED)); \
    packed_data->index = glVertexFormatNV_INDEX; \
    packed_data->args.size = (GLint)_size; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.stride = (GLsizei)_stride; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexFormatNV(packed, ret_v) do { \
    PACKED_glVertexFormatNV *unpacked = (PACKED_glVertexFormatNV *)packed; \
    ARGS_glVertexFormatNV *args = (ARGS_glVertexFormatNV *)&unpacked->args; \
    glVertexFormatNV(args->size, args->type, args->stride);; \
} while(0)
void glVertexFormatNV(glVertexFormatNV_ARG_EXPAND);
typedef void (*glVertexFormatNV_PTR)(glVertexFormatNV_ARG_EXPAND);
#define glVertexP2ui_INDEX 2581
#define glVertexP2ui_RETURN void
#define glVertexP2ui_ARG_NAMES type, value
#define glVertexP2ui_ARG_EXPAND GLenum type, GLuint value
#define glVertexP2ui_PACKED PACKED_glVertexP2ui
#define glVertexP2ui_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexP2ui_NOT_VOID_WRAP(...) {}
#define pack_glVertexP2ui(_type, _value) ({ \
    glVertexP2ui_PACKED *packed_data = malloc(sizeof(glVertexP2ui_PACKED)); \
    packed_data->index = glVertexP2ui_INDEX; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.value = (GLuint)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexP2ui(packed, ret_v) do { \
    PACKED_glVertexP2ui *unpacked = (PACKED_glVertexP2ui *)packed; \
    ARGS_glVertexP2ui *args = (ARGS_glVertexP2ui *)&unpacked->args; \
    glVertexP2ui(args->type, args->value);; \
} while(0)
void glVertexP2ui(glVertexP2ui_ARG_EXPAND);
typedef void (*glVertexP2ui_PTR)(glVertexP2ui_ARG_EXPAND);
#define glVertexP2uiv_INDEX 2582
#define glVertexP2uiv_RETURN void
#define glVertexP2uiv_ARG_NAMES type, value
#define glVertexP2uiv_ARG_EXPAND GLenum type, const GLuint * value
#define glVertexP2uiv_PACKED PACKED_glVertexP2uiv
#define glVertexP2uiv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexP2uiv_NOT_VOID_WRAP(...) {}
#define pack_glVertexP2uiv(_type, _value) ({ \
    glVertexP2uiv_PACKED *packed_data = malloc(sizeof(glVertexP2uiv_PACKED)); \
    packed_data->index = glVertexP2uiv_INDEX; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.value = (GLuint *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexP2uiv(packed, ret_v) do { \
    PACKED_glVertexP2uiv *unpacked = (PACKED_glVertexP2uiv *)packed; \
    ARGS_glVertexP2uiv *args = (ARGS_glVertexP2uiv *)&unpacked->args; \
    glVertexP2uiv(args->type, args->value);; \
} while(0)
void glVertexP2uiv(glVertexP2uiv_ARG_EXPAND);
typedef void (*glVertexP2uiv_PTR)(glVertexP2uiv_ARG_EXPAND);
#define glVertexP3ui_INDEX 2583
#define glVertexP3ui_RETURN void
#define glVertexP3ui_ARG_NAMES type, value
#define glVertexP3ui_ARG_EXPAND GLenum type, GLuint value
#define glVertexP3ui_PACKED PACKED_glVertexP3ui
#define glVertexP3ui_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexP3ui_NOT_VOID_WRAP(...) {}
#define pack_glVertexP3ui(_type, _value) ({ \
    glVertexP3ui_PACKED *packed_data = malloc(sizeof(glVertexP3ui_PACKED)); \
    packed_data->index = glVertexP3ui_INDEX; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.value = (GLuint)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexP3ui(packed, ret_v) do { \
    PACKED_glVertexP3ui *unpacked = (PACKED_glVertexP3ui *)packed; \
    ARGS_glVertexP3ui *args = (ARGS_glVertexP3ui *)&unpacked->args; \
    glVertexP3ui(args->type, args->value);; \
} while(0)
void glVertexP3ui(glVertexP3ui_ARG_EXPAND);
typedef void (*glVertexP3ui_PTR)(glVertexP3ui_ARG_EXPAND);
#define glVertexP3uiv_INDEX 2584
#define glVertexP3uiv_RETURN void
#define glVertexP3uiv_ARG_NAMES type, value
#define glVertexP3uiv_ARG_EXPAND GLenum type, const GLuint * value
#define glVertexP3uiv_PACKED PACKED_glVertexP3uiv
#define glVertexP3uiv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexP3uiv_NOT_VOID_WRAP(...) {}
#define pack_glVertexP3uiv(_type, _value) ({ \
    glVertexP3uiv_PACKED *packed_data = malloc(sizeof(glVertexP3uiv_PACKED)); \
    packed_data->index = glVertexP3uiv_INDEX; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.value = (GLuint *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexP3uiv(packed, ret_v) do { \
    PACKED_glVertexP3uiv *unpacked = (PACKED_glVertexP3uiv *)packed; \
    ARGS_glVertexP3uiv *args = (ARGS_glVertexP3uiv *)&unpacked->args; \
    glVertexP3uiv(args->type, args->value);; \
} while(0)
void glVertexP3uiv(glVertexP3uiv_ARG_EXPAND);
typedef void (*glVertexP3uiv_PTR)(glVertexP3uiv_ARG_EXPAND);
#define glVertexP4ui_INDEX 2585
#define glVertexP4ui_RETURN void
#define glVertexP4ui_ARG_NAMES type, value
#define glVertexP4ui_ARG_EXPAND GLenum type, GLuint value
#define glVertexP4ui_PACKED PACKED_glVertexP4ui
#define glVertexP4ui_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexP4ui_NOT_VOID_WRAP(...) {}
#define pack_glVertexP4ui(_type, _value) ({ \
    glVertexP4ui_PACKED *packed_data = malloc(sizeof(glVertexP4ui_PACKED)); \
    packed_data->index = glVertexP4ui_INDEX; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.value = (GLuint)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexP4ui(packed, ret_v) do { \
    PACKED_glVertexP4ui *unpacked = (PACKED_glVertexP4ui *)packed; \
    ARGS_glVertexP4ui *args = (ARGS_glVertexP4ui *)&unpacked->args; \
    glVertexP4ui(args->type, args->value);; \
} while(0)
void glVertexP4ui(glVertexP4ui_ARG_EXPAND);
typedef void (*glVertexP4ui_PTR)(glVertexP4ui_ARG_EXPAND);
#define glVertexP4uiv_INDEX 2586
#define glVertexP4uiv_RETURN void
#define glVertexP4uiv_ARG_NAMES type, value
#define glVertexP4uiv_ARG_EXPAND GLenum type, const GLuint * value
#define glVertexP4uiv_PACKED PACKED_glVertexP4uiv
#define glVertexP4uiv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexP4uiv_NOT_VOID_WRAP(...) {}
#define pack_glVertexP4uiv(_type, _value) ({ \
    glVertexP4uiv_PACKED *packed_data = malloc(sizeof(glVertexP4uiv_PACKED)); \
    packed_data->index = glVertexP4uiv_INDEX; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.value = (GLuint *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexP4uiv(packed, ret_v) do { \
    PACKED_glVertexP4uiv *unpacked = (PACKED_glVertexP4uiv *)packed; \
    ARGS_glVertexP4uiv *args = (ARGS_glVertexP4uiv *)&unpacked->args; \
    glVertexP4uiv(args->type, args->value);; \
} while(0)
void glVertexP4uiv(glVertexP4uiv_ARG_EXPAND);
typedef void (*glVertexP4uiv_PTR)(glVertexP4uiv_ARG_EXPAND);
#define glVertexPointer_INDEX 2587
#define glVertexPointer_RETURN void
#define glVertexPointer_ARG_NAMES size, type, stride, pointer
#define glVertexPointer_ARG_EXPAND GLint size, GLenum type, GLsizei stride, const GLvoid * pointer
#define glVertexPointer_PACKED PACKED_glVertexPointer
#define glVertexPointer_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexPointer_NOT_VOID_WRAP(...) {}
#define pack_glVertexPointer(_size, _type, _stride, _pointer) ({ \
    glVertexPointer_PACKED *packed_data = malloc(sizeof(glVertexPointer_PACKED)); \
    packed_data->index = glVertexPointer_INDEX; \
    packed_data->args.size = (GLint)_size; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.stride = (GLsizei)_stride; \
    packed_data->args.pointer = (GLvoid *)_pointer; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexPointer(packed, ret_v) do { \
    PACKED_glVertexPointer *unpacked = (PACKED_glVertexPointer *)packed; \
    ARGS_glVertexPointer *args = (ARGS_glVertexPointer *)&unpacked->args; \
    glVertexPointer(args->size, args->type, args->stride, args->pointer);; \
} while(0)
void glVertexPointer(glVertexPointer_ARG_EXPAND);
typedef void (*glVertexPointer_PTR)(glVertexPointer_ARG_EXPAND);
#define glVertexPointerEXT_INDEX 2588
#define glVertexPointerEXT_RETURN void
#define glVertexPointerEXT_ARG_NAMES size, type, stride, count, pointer
#define glVertexPointerEXT_ARG_EXPAND GLint size, GLenum type, GLsizei stride, GLsizei count, const GLvoid * pointer
#define glVertexPointerEXT_PACKED PACKED_glVertexPointerEXT
#define glVertexPointerEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexPointerEXT_NOT_VOID_WRAP(...) {}
#define pack_glVertexPointerEXT(_size, _type, _stride, _count, _pointer) ({ \
    glVertexPointerEXT_PACKED *packed_data = malloc(sizeof(glVertexPointerEXT_PACKED)); \
    packed_data->index = glVertexPointerEXT_INDEX; \
    packed_data->args.size = (GLint)_size; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.stride = (GLsizei)_stride; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.pointer = (GLvoid *)_pointer; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexPointerEXT(packed, ret_v) do { \
    PACKED_glVertexPointerEXT *unpacked = (PACKED_glVertexPointerEXT *)packed; \
    ARGS_glVertexPointerEXT *args = (ARGS_glVertexPointerEXT *)&unpacked->args; \
    glVertexPointerEXT(args->size, args->type, args->stride, args->count, args->pointer);; \
} while(0)
void glVertexPointerEXT(glVertexPointerEXT_ARG_EXPAND);
typedef void (*glVertexPointerEXT_PTR)(glVertexPointerEXT_ARG_EXPAND);
#define glVertexPointerListIBM_INDEX 2589
#define glVertexPointerListIBM_RETURN void
#define glVertexPointerListIBM_ARG_NAMES size, type, stride, pointer, ptrstride
#define glVertexPointerListIBM_ARG_EXPAND GLint size, GLenum type, GLint stride, const GLvoid * pointer, GLint ptrstride
#define glVertexPointerListIBM_PACKED PACKED_glVertexPointerListIBM
#define glVertexPointerListIBM_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexPointerListIBM_NOT_VOID_WRAP(...) {}
#define pack_glVertexPointerListIBM(_size, _type, _stride, _pointer, _ptrstride) ({ \
    glVertexPointerListIBM_PACKED *packed_data = malloc(sizeof(glVertexPointerListIBM_PACKED)); \
    packed_data->index = glVertexPointerListIBM_INDEX; \
    packed_data->args.size = (GLint)_size; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.stride = (GLint)_stride; \
    packed_data->args.pointer = (GLvoid *)_pointer; \
    packed_data->args.ptrstride = (GLint)_ptrstride; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexPointerListIBM(packed, ret_v) do { \
    PACKED_glVertexPointerListIBM *unpacked = (PACKED_glVertexPointerListIBM *)packed; \
    ARGS_glVertexPointerListIBM *args = (ARGS_glVertexPointerListIBM *)&unpacked->args; \
    glVertexPointerListIBM(args->size, args->type, args->stride, args->pointer, args->ptrstride);; \
} while(0)
void glVertexPointerListIBM(glVertexPointerListIBM_ARG_EXPAND);
typedef void (*glVertexPointerListIBM_PTR)(glVertexPointerListIBM_ARG_EXPAND);
#define glVertexPointervINTEL_INDEX 2590
#define glVertexPointervINTEL_RETURN void
#define glVertexPointervINTEL_ARG_NAMES size, type, pointer
#define glVertexPointervINTEL_ARG_EXPAND GLint size, GLenum type, const GLvoid * pointer
#define glVertexPointervINTEL_PACKED PACKED_glVertexPointervINTEL
#define glVertexPointervINTEL_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexPointervINTEL_NOT_VOID_WRAP(...) {}
#define pack_glVertexPointervINTEL(_size, _type, _pointer) ({ \
    glVertexPointervINTEL_PACKED *packed_data = malloc(sizeof(glVertexPointervINTEL_PACKED)); \
    packed_data->index = glVertexPointervINTEL_INDEX; \
    packed_data->args.size = (GLint)_size; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.pointer = (GLvoid *)_pointer; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexPointervINTEL(packed, ret_v) do { \
    PACKED_glVertexPointervINTEL *unpacked = (PACKED_glVertexPointervINTEL *)packed; \
    ARGS_glVertexPointervINTEL *args = (ARGS_glVertexPointervINTEL *)&unpacked->args; \
    glVertexPointervINTEL(args->size, args->type, args->pointer);; \
} while(0)
void glVertexPointervINTEL(glVertexPointervINTEL_ARG_EXPAND);
typedef void (*glVertexPointervINTEL_PTR)(glVertexPointervINTEL_ARG_EXPAND);
#define glVertexStream1dATI_INDEX 2591
#define glVertexStream1dATI_RETURN void
#define glVertexStream1dATI_ARG_NAMES stream, x
#define glVertexStream1dATI_ARG_EXPAND GLenum stream, GLdouble x
#define glVertexStream1dATI_PACKED PACKED_glVertexStream1dATI
#define glVertexStream1dATI_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexStream1dATI_NOT_VOID_WRAP(...) {}
#define pack_glVertexStream1dATI(_stream, _x) ({ \
    glVertexStream1dATI_PACKED *packed_data = malloc(sizeof(glVertexStream1dATI_PACKED)); \
    packed_data->index = glVertexStream1dATI_INDEX; \
    packed_data->args.stream = (GLenum)_stream; \
    packed_data->args.x = (GLdouble)_x; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexStream1dATI(packed, ret_v) do { \
    PACKED_glVertexStream1dATI *unpacked = (PACKED_glVertexStream1dATI *)packed; \
    ARGS_glVertexStream1dATI *args = (ARGS_glVertexStream1dATI *)&unpacked->args; \
    glVertexStream1dATI(args->stream, args->x);; \
} while(0)
void glVertexStream1dATI(glVertexStream1dATI_ARG_EXPAND);
typedef void (*glVertexStream1dATI_PTR)(glVertexStream1dATI_ARG_EXPAND);
#define glVertexStream1dvATI_INDEX 2592
#define glVertexStream1dvATI_RETURN void
#define glVertexStream1dvATI_ARG_NAMES stream, coords
#define glVertexStream1dvATI_ARG_EXPAND GLenum stream, const GLdouble * coords
#define glVertexStream1dvATI_PACKED PACKED_glVertexStream1dvATI
#define glVertexStream1dvATI_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexStream1dvATI_NOT_VOID_WRAP(...) {}
#define pack_glVertexStream1dvATI(_stream, _coords) ({ \
    glVertexStream1dvATI_PACKED *packed_data = malloc(sizeof(glVertexStream1dvATI_PACKED)); \
    packed_data->index = glVertexStream1dvATI_INDEX; \
    packed_data->args.stream = (GLenum)_stream; \
    packed_data->args.coords = (GLdouble *)_coords; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexStream1dvATI(packed, ret_v) do { \
    PACKED_glVertexStream1dvATI *unpacked = (PACKED_glVertexStream1dvATI *)packed; \
    ARGS_glVertexStream1dvATI *args = (ARGS_glVertexStream1dvATI *)&unpacked->args; \
    glVertexStream1dvATI(args->stream, args->coords);; \
} while(0)
void glVertexStream1dvATI(glVertexStream1dvATI_ARG_EXPAND);
typedef void (*glVertexStream1dvATI_PTR)(glVertexStream1dvATI_ARG_EXPAND);
#define glVertexStream1fATI_INDEX 2593
#define glVertexStream1fATI_RETURN void
#define glVertexStream1fATI_ARG_NAMES stream, x
#define glVertexStream1fATI_ARG_EXPAND GLenum stream, GLfloat x
#define glVertexStream1fATI_PACKED PACKED_glVertexStream1fATI
#define glVertexStream1fATI_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexStream1fATI_NOT_VOID_WRAP(...) {}
#define pack_glVertexStream1fATI(_stream, _x) ({ \
    glVertexStream1fATI_PACKED *packed_data = malloc(sizeof(glVertexStream1fATI_PACKED)); \
    packed_data->index = glVertexStream1fATI_INDEX; \
    packed_data->args.stream = (GLenum)_stream; \
    packed_data->args.x = (GLfloat)_x; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexStream1fATI(packed, ret_v) do { \
    PACKED_glVertexStream1fATI *unpacked = (PACKED_glVertexStream1fATI *)packed; \
    ARGS_glVertexStream1fATI *args = (ARGS_glVertexStream1fATI *)&unpacked->args; \
    glVertexStream1fATI(args->stream, args->x);; \
} while(0)
void glVertexStream1fATI(glVertexStream1fATI_ARG_EXPAND);
typedef void (*glVertexStream1fATI_PTR)(glVertexStream1fATI_ARG_EXPAND);
#define glVertexStream1fvATI_INDEX 2594
#define glVertexStream1fvATI_RETURN void
#define glVertexStream1fvATI_ARG_NAMES stream, coords
#define glVertexStream1fvATI_ARG_EXPAND GLenum stream, const GLfloat * coords
#define glVertexStream1fvATI_PACKED PACKED_glVertexStream1fvATI
#define glVertexStream1fvATI_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexStream1fvATI_NOT_VOID_WRAP(...) {}
#define pack_glVertexStream1fvATI(_stream, _coords) ({ \
    glVertexStream1fvATI_PACKED *packed_data = malloc(sizeof(glVertexStream1fvATI_PACKED)); \
    packed_data->index = glVertexStream1fvATI_INDEX; \
    packed_data->args.stream = (GLenum)_stream; \
    packed_data->args.coords = (GLfloat *)_coords; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexStream1fvATI(packed, ret_v) do { \
    PACKED_glVertexStream1fvATI *unpacked = (PACKED_glVertexStream1fvATI *)packed; \
    ARGS_glVertexStream1fvATI *args = (ARGS_glVertexStream1fvATI *)&unpacked->args; \
    glVertexStream1fvATI(args->stream, args->coords);; \
} while(0)
void glVertexStream1fvATI(glVertexStream1fvATI_ARG_EXPAND);
typedef void (*glVertexStream1fvATI_PTR)(glVertexStream1fvATI_ARG_EXPAND);
#define glVertexStream1iATI_INDEX 2595
#define glVertexStream1iATI_RETURN void
#define glVertexStream1iATI_ARG_NAMES stream, x
#define glVertexStream1iATI_ARG_EXPAND GLenum stream, GLint x
#define glVertexStream1iATI_PACKED PACKED_glVertexStream1iATI
#define glVertexStream1iATI_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexStream1iATI_NOT_VOID_WRAP(...) {}
#define pack_glVertexStream1iATI(_stream, _x) ({ \
    glVertexStream1iATI_PACKED *packed_data = malloc(sizeof(glVertexStream1iATI_PACKED)); \
    packed_data->index = glVertexStream1iATI_INDEX; \
    packed_data->args.stream = (GLenum)_stream; \
    packed_data->args.x = (GLint)_x; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexStream1iATI(packed, ret_v) do { \
    PACKED_glVertexStream1iATI *unpacked = (PACKED_glVertexStream1iATI *)packed; \
    ARGS_glVertexStream1iATI *args = (ARGS_glVertexStream1iATI *)&unpacked->args; \
    glVertexStream1iATI(args->stream, args->x);; \
} while(0)
void glVertexStream1iATI(glVertexStream1iATI_ARG_EXPAND);
typedef void (*glVertexStream1iATI_PTR)(glVertexStream1iATI_ARG_EXPAND);
#define glVertexStream1ivATI_INDEX 2596
#define glVertexStream1ivATI_RETURN void
#define glVertexStream1ivATI_ARG_NAMES stream, coords
#define glVertexStream1ivATI_ARG_EXPAND GLenum stream, const GLint * coords
#define glVertexStream1ivATI_PACKED PACKED_glVertexStream1ivATI
#define glVertexStream1ivATI_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexStream1ivATI_NOT_VOID_WRAP(...) {}
#define pack_glVertexStream1ivATI(_stream, _coords) ({ \
    glVertexStream1ivATI_PACKED *packed_data = malloc(sizeof(glVertexStream1ivATI_PACKED)); \
    packed_data->index = glVertexStream1ivATI_INDEX; \
    packed_data->args.stream = (GLenum)_stream; \
    packed_data->args.coords = (GLint *)_coords; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexStream1ivATI(packed, ret_v) do { \
    PACKED_glVertexStream1ivATI *unpacked = (PACKED_glVertexStream1ivATI *)packed; \
    ARGS_glVertexStream1ivATI *args = (ARGS_glVertexStream1ivATI *)&unpacked->args; \
    glVertexStream1ivATI(args->stream, args->coords);; \
} while(0)
void glVertexStream1ivATI(glVertexStream1ivATI_ARG_EXPAND);
typedef void (*glVertexStream1ivATI_PTR)(glVertexStream1ivATI_ARG_EXPAND);
#define glVertexStream1sATI_INDEX 2597
#define glVertexStream1sATI_RETURN void
#define glVertexStream1sATI_ARG_NAMES stream, x
#define glVertexStream1sATI_ARG_EXPAND GLenum stream, GLshort x
#define glVertexStream1sATI_PACKED PACKED_glVertexStream1sATI
#define glVertexStream1sATI_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexStream1sATI_NOT_VOID_WRAP(...) {}
#define pack_glVertexStream1sATI(_stream, _x) ({ \
    glVertexStream1sATI_PACKED *packed_data = malloc(sizeof(glVertexStream1sATI_PACKED)); \
    packed_data->index = glVertexStream1sATI_INDEX; \
    packed_data->args.stream = (GLenum)_stream; \
    packed_data->args.x = (GLshort)_x; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexStream1sATI(packed, ret_v) do { \
    PACKED_glVertexStream1sATI *unpacked = (PACKED_glVertexStream1sATI *)packed; \
    ARGS_glVertexStream1sATI *args = (ARGS_glVertexStream1sATI *)&unpacked->args; \
    glVertexStream1sATI(args->stream, args->x);; \
} while(0)
void glVertexStream1sATI(glVertexStream1sATI_ARG_EXPAND);
typedef void (*glVertexStream1sATI_PTR)(glVertexStream1sATI_ARG_EXPAND);
#define glVertexStream1svATI_INDEX 2598
#define glVertexStream1svATI_RETURN void
#define glVertexStream1svATI_ARG_NAMES stream, coords
#define glVertexStream1svATI_ARG_EXPAND GLenum stream, const GLshort * coords
#define glVertexStream1svATI_PACKED PACKED_glVertexStream1svATI
#define glVertexStream1svATI_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexStream1svATI_NOT_VOID_WRAP(...) {}
#define pack_glVertexStream1svATI(_stream, _coords) ({ \
    glVertexStream1svATI_PACKED *packed_data = malloc(sizeof(glVertexStream1svATI_PACKED)); \
    packed_data->index = glVertexStream1svATI_INDEX; \
    packed_data->args.stream = (GLenum)_stream; \
    packed_data->args.coords = (GLshort *)_coords; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexStream1svATI(packed, ret_v) do { \
    PACKED_glVertexStream1svATI *unpacked = (PACKED_glVertexStream1svATI *)packed; \
    ARGS_glVertexStream1svATI *args = (ARGS_glVertexStream1svATI *)&unpacked->args; \
    glVertexStream1svATI(args->stream, args->coords);; \
} while(0)
void glVertexStream1svATI(glVertexStream1svATI_ARG_EXPAND);
typedef void (*glVertexStream1svATI_PTR)(glVertexStream1svATI_ARG_EXPAND);
#define glVertexStream2dATI_INDEX 2599
#define glVertexStream2dATI_RETURN void
#define glVertexStream2dATI_ARG_NAMES stream, x, y
#define glVertexStream2dATI_ARG_EXPAND GLenum stream, GLdouble x, GLdouble y
#define glVertexStream2dATI_PACKED PACKED_glVertexStream2dATI
#define glVertexStream2dATI_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexStream2dATI_NOT_VOID_WRAP(...) {}
#define pack_glVertexStream2dATI(_stream, _x, _y) ({ \
    glVertexStream2dATI_PACKED *packed_data = malloc(sizeof(glVertexStream2dATI_PACKED)); \
    packed_data->index = glVertexStream2dATI_INDEX; \
    packed_data->args.stream = (GLenum)_stream; \
    packed_data->args.x = (GLdouble)_x; \
    packed_data->args.y = (GLdouble)_y; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexStream2dATI(packed, ret_v) do { \
    PACKED_glVertexStream2dATI *unpacked = (PACKED_glVertexStream2dATI *)packed; \
    ARGS_glVertexStream2dATI *args = (ARGS_glVertexStream2dATI *)&unpacked->args; \
    glVertexStream2dATI(args->stream, args->x, args->y);; \
} while(0)
void glVertexStream2dATI(glVertexStream2dATI_ARG_EXPAND);
typedef void (*glVertexStream2dATI_PTR)(glVertexStream2dATI_ARG_EXPAND);
#define glVertexStream2dvATI_INDEX 2600
#define glVertexStream2dvATI_RETURN void
#define glVertexStream2dvATI_ARG_NAMES stream, coords
#define glVertexStream2dvATI_ARG_EXPAND GLenum stream, const GLdouble * coords
#define glVertexStream2dvATI_PACKED PACKED_glVertexStream2dvATI
#define glVertexStream2dvATI_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexStream2dvATI_NOT_VOID_WRAP(...) {}
#define pack_glVertexStream2dvATI(_stream, _coords) ({ \
    glVertexStream2dvATI_PACKED *packed_data = malloc(sizeof(glVertexStream2dvATI_PACKED)); \
    packed_data->index = glVertexStream2dvATI_INDEX; \
    packed_data->args.stream = (GLenum)_stream; \
    packed_data->args.coords = (GLdouble *)_coords; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexStream2dvATI(packed, ret_v) do { \
    PACKED_glVertexStream2dvATI *unpacked = (PACKED_glVertexStream2dvATI *)packed; \
    ARGS_glVertexStream2dvATI *args = (ARGS_glVertexStream2dvATI *)&unpacked->args; \
    glVertexStream2dvATI(args->stream, args->coords);; \
} while(0)
void glVertexStream2dvATI(glVertexStream2dvATI_ARG_EXPAND);
typedef void (*glVertexStream2dvATI_PTR)(glVertexStream2dvATI_ARG_EXPAND);
#define glVertexStream2fATI_INDEX 2601
#define glVertexStream2fATI_RETURN void
#define glVertexStream2fATI_ARG_NAMES stream, x, y
#define glVertexStream2fATI_ARG_EXPAND GLenum stream, GLfloat x, GLfloat y
#define glVertexStream2fATI_PACKED PACKED_glVertexStream2fATI
#define glVertexStream2fATI_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexStream2fATI_NOT_VOID_WRAP(...) {}
#define pack_glVertexStream2fATI(_stream, _x, _y) ({ \
    glVertexStream2fATI_PACKED *packed_data = malloc(sizeof(glVertexStream2fATI_PACKED)); \
    packed_data->index = glVertexStream2fATI_INDEX; \
    packed_data->args.stream = (GLenum)_stream; \
    packed_data->args.x = (GLfloat)_x; \
    packed_data->args.y = (GLfloat)_y; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexStream2fATI(packed, ret_v) do { \
    PACKED_glVertexStream2fATI *unpacked = (PACKED_glVertexStream2fATI *)packed; \
    ARGS_glVertexStream2fATI *args = (ARGS_glVertexStream2fATI *)&unpacked->args; \
    glVertexStream2fATI(args->stream, args->x, args->y);; \
} while(0)
void glVertexStream2fATI(glVertexStream2fATI_ARG_EXPAND);
typedef void (*glVertexStream2fATI_PTR)(glVertexStream2fATI_ARG_EXPAND);
#define glVertexStream2fvATI_INDEX 2602
#define glVertexStream2fvATI_RETURN void
#define glVertexStream2fvATI_ARG_NAMES stream, coords
#define glVertexStream2fvATI_ARG_EXPAND GLenum stream, const GLfloat * coords
#define glVertexStream2fvATI_PACKED PACKED_glVertexStream2fvATI
#define glVertexStream2fvATI_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexStream2fvATI_NOT_VOID_WRAP(...) {}
#define pack_glVertexStream2fvATI(_stream, _coords) ({ \
    glVertexStream2fvATI_PACKED *packed_data = malloc(sizeof(glVertexStream2fvATI_PACKED)); \
    packed_data->index = glVertexStream2fvATI_INDEX; \
    packed_data->args.stream = (GLenum)_stream; \
    packed_data->args.coords = (GLfloat *)_coords; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexStream2fvATI(packed, ret_v) do { \
    PACKED_glVertexStream2fvATI *unpacked = (PACKED_glVertexStream2fvATI *)packed; \
    ARGS_glVertexStream2fvATI *args = (ARGS_glVertexStream2fvATI *)&unpacked->args; \
    glVertexStream2fvATI(args->stream, args->coords);; \
} while(0)
void glVertexStream2fvATI(glVertexStream2fvATI_ARG_EXPAND);
typedef void (*glVertexStream2fvATI_PTR)(glVertexStream2fvATI_ARG_EXPAND);
#define glVertexStream2iATI_INDEX 2603
#define glVertexStream2iATI_RETURN void
#define glVertexStream2iATI_ARG_NAMES stream, x, y
#define glVertexStream2iATI_ARG_EXPAND GLenum stream, GLint x, GLint y
#define glVertexStream2iATI_PACKED PACKED_glVertexStream2iATI
#define glVertexStream2iATI_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexStream2iATI_NOT_VOID_WRAP(...) {}
#define pack_glVertexStream2iATI(_stream, _x, _y) ({ \
    glVertexStream2iATI_PACKED *packed_data = malloc(sizeof(glVertexStream2iATI_PACKED)); \
    packed_data->index = glVertexStream2iATI_INDEX; \
    packed_data->args.stream = (GLenum)_stream; \
    packed_data->args.x = (GLint)_x; \
    packed_data->args.y = (GLint)_y; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexStream2iATI(packed, ret_v) do { \
    PACKED_glVertexStream2iATI *unpacked = (PACKED_glVertexStream2iATI *)packed; \
    ARGS_glVertexStream2iATI *args = (ARGS_glVertexStream2iATI *)&unpacked->args; \
    glVertexStream2iATI(args->stream, args->x, args->y);; \
} while(0)
void glVertexStream2iATI(glVertexStream2iATI_ARG_EXPAND);
typedef void (*glVertexStream2iATI_PTR)(glVertexStream2iATI_ARG_EXPAND);
#define glVertexStream2ivATI_INDEX 2604
#define glVertexStream2ivATI_RETURN void
#define glVertexStream2ivATI_ARG_NAMES stream, coords
#define glVertexStream2ivATI_ARG_EXPAND GLenum stream, const GLint * coords
#define glVertexStream2ivATI_PACKED PACKED_glVertexStream2ivATI
#define glVertexStream2ivATI_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexStream2ivATI_NOT_VOID_WRAP(...) {}
#define pack_glVertexStream2ivATI(_stream, _coords) ({ \
    glVertexStream2ivATI_PACKED *packed_data = malloc(sizeof(glVertexStream2ivATI_PACKED)); \
    packed_data->index = glVertexStream2ivATI_INDEX; \
    packed_data->args.stream = (GLenum)_stream; \
    packed_data->args.coords = (GLint *)_coords; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexStream2ivATI(packed, ret_v) do { \
    PACKED_glVertexStream2ivATI *unpacked = (PACKED_glVertexStream2ivATI *)packed; \
    ARGS_glVertexStream2ivATI *args = (ARGS_glVertexStream2ivATI *)&unpacked->args; \
    glVertexStream2ivATI(args->stream, args->coords);; \
} while(0)
void glVertexStream2ivATI(glVertexStream2ivATI_ARG_EXPAND);
typedef void (*glVertexStream2ivATI_PTR)(glVertexStream2ivATI_ARG_EXPAND);
#define glVertexStream2sATI_INDEX 2605
#define glVertexStream2sATI_RETURN void
#define glVertexStream2sATI_ARG_NAMES stream, x, y
#define glVertexStream2sATI_ARG_EXPAND GLenum stream, GLshort x, GLshort y
#define glVertexStream2sATI_PACKED PACKED_glVertexStream2sATI
#define glVertexStream2sATI_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexStream2sATI_NOT_VOID_WRAP(...) {}
#define pack_glVertexStream2sATI(_stream, _x, _y) ({ \
    glVertexStream2sATI_PACKED *packed_data = malloc(sizeof(glVertexStream2sATI_PACKED)); \
    packed_data->index = glVertexStream2sATI_INDEX; \
    packed_data->args.stream = (GLenum)_stream; \
    packed_data->args.x = (GLshort)_x; \
    packed_data->args.y = (GLshort)_y; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexStream2sATI(packed, ret_v) do { \
    PACKED_glVertexStream2sATI *unpacked = (PACKED_glVertexStream2sATI *)packed; \
    ARGS_glVertexStream2sATI *args = (ARGS_glVertexStream2sATI *)&unpacked->args; \
    glVertexStream2sATI(args->stream, args->x, args->y);; \
} while(0)
void glVertexStream2sATI(glVertexStream2sATI_ARG_EXPAND);
typedef void (*glVertexStream2sATI_PTR)(glVertexStream2sATI_ARG_EXPAND);
#define glVertexStream2svATI_INDEX 2606
#define glVertexStream2svATI_RETURN void
#define glVertexStream2svATI_ARG_NAMES stream, coords
#define glVertexStream2svATI_ARG_EXPAND GLenum stream, const GLshort * coords
#define glVertexStream2svATI_PACKED PACKED_glVertexStream2svATI
#define glVertexStream2svATI_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexStream2svATI_NOT_VOID_WRAP(...) {}
#define pack_glVertexStream2svATI(_stream, _coords) ({ \
    glVertexStream2svATI_PACKED *packed_data = malloc(sizeof(glVertexStream2svATI_PACKED)); \
    packed_data->index = glVertexStream2svATI_INDEX; \
    packed_data->args.stream = (GLenum)_stream; \
    packed_data->args.coords = (GLshort *)_coords; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexStream2svATI(packed, ret_v) do { \
    PACKED_glVertexStream2svATI *unpacked = (PACKED_glVertexStream2svATI *)packed; \
    ARGS_glVertexStream2svATI *args = (ARGS_glVertexStream2svATI *)&unpacked->args; \
    glVertexStream2svATI(args->stream, args->coords);; \
} while(0)
void glVertexStream2svATI(glVertexStream2svATI_ARG_EXPAND);
typedef void (*glVertexStream2svATI_PTR)(glVertexStream2svATI_ARG_EXPAND);
#define glVertexStream3dATI_INDEX 2607
#define glVertexStream3dATI_RETURN void
#define glVertexStream3dATI_ARG_NAMES stream, x, y, z
#define glVertexStream3dATI_ARG_EXPAND GLenum stream, GLdouble x, GLdouble y, GLdouble z
#define glVertexStream3dATI_PACKED PACKED_glVertexStream3dATI
#define glVertexStream3dATI_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexStream3dATI_NOT_VOID_WRAP(...) {}
#define pack_glVertexStream3dATI(_stream, _x, _y, _z) ({ \
    glVertexStream3dATI_PACKED *packed_data = malloc(sizeof(glVertexStream3dATI_PACKED)); \
    packed_data->index = glVertexStream3dATI_INDEX; \
    packed_data->args.stream = (GLenum)_stream; \
    packed_data->args.x = (GLdouble)_x; \
    packed_data->args.y = (GLdouble)_y; \
    packed_data->args.z = (GLdouble)_z; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexStream3dATI(packed, ret_v) do { \
    PACKED_glVertexStream3dATI *unpacked = (PACKED_glVertexStream3dATI *)packed; \
    ARGS_glVertexStream3dATI *args = (ARGS_glVertexStream3dATI *)&unpacked->args; \
    glVertexStream3dATI(args->stream, args->x, args->y, args->z);; \
} while(0)
void glVertexStream3dATI(glVertexStream3dATI_ARG_EXPAND);
typedef void (*glVertexStream3dATI_PTR)(glVertexStream3dATI_ARG_EXPAND);
#define glVertexStream3dvATI_INDEX 2608
#define glVertexStream3dvATI_RETURN void
#define glVertexStream3dvATI_ARG_NAMES stream, coords
#define glVertexStream3dvATI_ARG_EXPAND GLenum stream, const GLdouble * coords
#define glVertexStream3dvATI_PACKED PACKED_glVertexStream3dvATI
#define glVertexStream3dvATI_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexStream3dvATI_NOT_VOID_WRAP(...) {}
#define pack_glVertexStream3dvATI(_stream, _coords) ({ \
    glVertexStream3dvATI_PACKED *packed_data = malloc(sizeof(glVertexStream3dvATI_PACKED)); \
    packed_data->index = glVertexStream3dvATI_INDEX; \
    packed_data->args.stream = (GLenum)_stream; \
    packed_data->args.coords = (GLdouble *)_coords; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexStream3dvATI(packed, ret_v) do { \
    PACKED_glVertexStream3dvATI *unpacked = (PACKED_glVertexStream3dvATI *)packed; \
    ARGS_glVertexStream3dvATI *args = (ARGS_glVertexStream3dvATI *)&unpacked->args; \
    glVertexStream3dvATI(args->stream, args->coords);; \
} while(0)
void glVertexStream3dvATI(glVertexStream3dvATI_ARG_EXPAND);
typedef void (*glVertexStream3dvATI_PTR)(glVertexStream3dvATI_ARG_EXPAND);
#define glVertexStream3fATI_INDEX 2609
#define glVertexStream3fATI_RETURN void
#define glVertexStream3fATI_ARG_NAMES stream, x, y, z
#define glVertexStream3fATI_ARG_EXPAND GLenum stream, GLfloat x, GLfloat y, GLfloat z
#define glVertexStream3fATI_PACKED PACKED_glVertexStream3fATI
#define glVertexStream3fATI_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexStream3fATI_NOT_VOID_WRAP(...) {}
#define pack_glVertexStream3fATI(_stream, _x, _y, _z) ({ \
    glVertexStream3fATI_PACKED *packed_data = malloc(sizeof(glVertexStream3fATI_PACKED)); \
    packed_data->index = glVertexStream3fATI_INDEX; \
    packed_data->args.stream = (GLenum)_stream; \
    packed_data->args.x = (GLfloat)_x; \
    packed_data->args.y = (GLfloat)_y; \
    packed_data->args.z = (GLfloat)_z; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexStream3fATI(packed, ret_v) do { \
    PACKED_glVertexStream3fATI *unpacked = (PACKED_glVertexStream3fATI *)packed; \
    ARGS_glVertexStream3fATI *args = (ARGS_glVertexStream3fATI *)&unpacked->args; \
    glVertexStream3fATI(args->stream, args->x, args->y, args->z);; \
} while(0)
void glVertexStream3fATI(glVertexStream3fATI_ARG_EXPAND);
typedef void (*glVertexStream3fATI_PTR)(glVertexStream3fATI_ARG_EXPAND);
#define glVertexStream3fvATI_INDEX 2610
#define glVertexStream3fvATI_RETURN void
#define glVertexStream3fvATI_ARG_NAMES stream, coords
#define glVertexStream3fvATI_ARG_EXPAND GLenum stream, const GLfloat * coords
#define glVertexStream3fvATI_PACKED PACKED_glVertexStream3fvATI
#define glVertexStream3fvATI_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexStream3fvATI_NOT_VOID_WRAP(...) {}
#define pack_glVertexStream3fvATI(_stream, _coords) ({ \
    glVertexStream3fvATI_PACKED *packed_data = malloc(sizeof(glVertexStream3fvATI_PACKED)); \
    packed_data->index = glVertexStream3fvATI_INDEX; \
    packed_data->args.stream = (GLenum)_stream; \
    packed_data->args.coords = (GLfloat *)_coords; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexStream3fvATI(packed, ret_v) do { \
    PACKED_glVertexStream3fvATI *unpacked = (PACKED_glVertexStream3fvATI *)packed; \
    ARGS_glVertexStream3fvATI *args = (ARGS_glVertexStream3fvATI *)&unpacked->args; \
    glVertexStream3fvATI(args->stream, args->coords);; \
} while(0)
void glVertexStream3fvATI(glVertexStream3fvATI_ARG_EXPAND);
typedef void (*glVertexStream3fvATI_PTR)(glVertexStream3fvATI_ARG_EXPAND);
#define glVertexStream3iATI_INDEX 2611
#define glVertexStream3iATI_RETURN void
#define glVertexStream3iATI_ARG_NAMES stream, x, y, z
#define glVertexStream3iATI_ARG_EXPAND GLenum stream, GLint x, GLint y, GLint z
#define glVertexStream3iATI_PACKED PACKED_glVertexStream3iATI
#define glVertexStream3iATI_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexStream3iATI_NOT_VOID_WRAP(...) {}
#define pack_glVertexStream3iATI(_stream, _x, _y, _z) ({ \
    glVertexStream3iATI_PACKED *packed_data = malloc(sizeof(glVertexStream3iATI_PACKED)); \
    packed_data->index = glVertexStream3iATI_INDEX; \
    packed_data->args.stream = (GLenum)_stream; \
    packed_data->args.x = (GLint)_x; \
    packed_data->args.y = (GLint)_y; \
    packed_data->args.z = (GLint)_z; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexStream3iATI(packed, ret_v) do { \
    PACKED_glVertexStream3iATI *unpacked = (PACKED_glVertexStream3iATI *)packed; \
    ARGS_glVertexStream3iATI *args = (ARGS_glVertexStream3iATI *)&unpacked->args; \
    glVertexStream3iATI(args->stream, args->x, args->y, args->z);; \
} while(0)
void glVertexStream3iATI(glVertexStream3iATI_ARG_EXPAND);
typedef void (*glVertexStream3iATI_PTR)(glVertexStream3iATI_ARG_EXPAND);
#define glVertexStream3ivATI_INDEX 2612
#define glVertexStream3ivATI_RETURN void
#define glVertexStream3ivATI_ARG_NAMES stream, coords
#define glVertexStream3ivATI_ARG_EXPAND GLenum stream, const GLint * coords
#define glVertexStream3ivATI_PACKED PACKED_glVertexStream3ivATI
#define glVertexStream3ivATI_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexStream3ivATI_NOT_VOID_WRAP(...) {}
#define pack_glVertexStream3ivATI(_stream, _coords) ({ \
    glVertexStream3ivATI_PACKED *packed_data = malloc(sizeof(glVertexStream3ivATI_PACKED)); \
    packed_data->index = glVertexStream3ivATI_INDEX; \
    packed_data->args.stream = (GLenum)_stream; \
    packed_data->args.coords = (GLint *)_coords; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexStream3ivATI(packed, ret_v) do { \
    PACKED_glVertexStream3ivATI *unpacked = (PACKED_glVertexStream3ivATI *)packed; \
    ARGS_glVertexStream3ivATI *args = (ARGS_glVertexStream3ivATI *)&unpacked->args; \
    glVertexStream3ivATI(args->stream, args->coords);; \
} while(0)
void glVertexStream3ivATI(glVertexStream3ivATI_ARG_EXPAND);
typedef void (*glVertexStream3ivATI_PTR)(glVertexStream3ivATI_ARG_EXPAND);
#define glVertexStream3sATI_INDEX 2613
#define glVertexStream3sATI_RETURN void
#define glVertexStream3sATI_ARG_NAMES stream, x, y, z
#define glVertexStream3sATI_ARG_EXPAND GLenum stream, GLshort x, GLshort y, GLshort z
#define glVertexStream3sATI_PACKED PACKED_glVertexStream3sATI
#define glVertexStream3sATI_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexStream3sATI_NOT_VOID_WRAP(...) {}
#define pack_glVertexStream3sATI(_stream, _x, _y, _z) ({ \
    glVertexStream3sATI_PACKED *packed_data = malloc(sizeof(glVertexStream3sATI_PACKED)); \
    packed_data->index = glVertexStream3sATI_INDEX; \
    packed_data->args.stream = (GLenum)_stream; \
    packed_data->args.x = (GLshort)_x; \
    packed_data->args.y = (GLshort)_y; \
    packed_data->args.z = (GLshort)_z; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexStream3sATI(packed, ret_v) do { \
    PACKED_glVertexStream3sATI *unpacked = (PACKED_glVertexStream3sATI *)packed; \
    ARGS_glVertexStream3sATI *args = (ARGS_glVertexStream3sATI *)&unpacked->args; \
    glVertexStream3sATI(args->stream, args->x, args->y, args->z);; \
} while(0)
void glVertexStream3sATI(glVertexStream3sATI_ARG_EXPAND);
typedef void (*glVertexStream3sATI_PTR)(glVertexStream3sATI_ARG_EXPAND);
#define glVertexStream3svATI_INDEX 2614
#define glVertexStream3svATI_RETURN void
#define glVertexStream3svATI_ARG_NAMES stream, coords
#define glVertexStream3svATI_ARG_EXPAND GLenum stream, const GLshort * coords
#define glVertexStream3svATI_PACKED PACKED_glVertexStream3svATI
#define glVertexStream3svATI_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexStream3svATI_NOT_VOID_WRAP(...) {}
#define pack_glVertexStream3svATI(_stream, _coords) ({ \
    glVertexStream3svATI_PACKED *packed_data = malloc(sizeof(glVertexStream3svATI_PACKED)); \
    packed_data->index = glVertexStream3svATI_INDEX; \
    packed_data->args.stream = (GLenum)_stream; \
    packed_data->args.coords = (GLshort *)_coords; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexStream3svATI(packed, ret_v) do { \
    PACKED_glVertexStream3svATI *unpacked = (PACKED_glVertexStream3svATI *)packed; \
    ARGS_glVertexStream3svATI *args = (ARGS_glVertexStream3svATI *)&unpacked->args; \
    glVertexStream3svATI(args->stream, args->coords);; \
} while(0)
void glVertexStream3svATI(glVertexStream3svATI_ARG_EXPAND);
typedef void (*glVertexStream3svATI_PTR)(glVertexStream3svATI_ARG_EXPAND);
#define glVertexStream4dATI_INDEX 2615
#define glVertexStream4dATI_RETURN void
#define glVertexStream4dATI_ARG_NAMES stream, x, y, z, w
#define glVertexStream4dATI_ARG_EXPAND GLenum stream, GLdouble x, GLdouble y, GLdouble z, GLdouble w
#define glVertexStream4dATI_PACKED PACKED_glVertexStream4dATI
#define glVertexStream4dATI_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexStream4dATI_NOT_VOID_WRAP(...) {}
#define pack_glVertexStream4dATI(_stream, _x, _y, _z, _w) ({ \
    glVertexStream4dATI_PACKED *packed_data = malloc(sizeof(glVertexStream4dATI_PACKED)); \
    packed_data->index = glVertexStream4dATI_INDEX; \
    packed_data->args.stream = (GLenum)_stream; \
    packed_data->args.x = (GLdouble)_x; \
    packed_data->args.y = (GLdouble)_y; \
    packed_data->args.z = (GLdouble)_z; \
    packed_data->args.w = (GLdouble)_w; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexStream4dATI(packed, ret_v) do { \
    PACKED_glVertexStream4dATI *unpacked = (PACKED_glVertexStream4dATI *)packed; \
    ARGS_glVertexStream4dATI *args = (ARGS_glVertexStream4dATI *)&unpacked->args; \
    glVertexStream4dATI(args->stream, args->x, args->y, args->z, args->w);; \
} while(0)
void glVertexStream4dATI(glVertexStream4dATI_ARG_EXPAND);
typedef void (*glVertexStream4dATI_PTR)(glVertexStream4dATI_ARG_EXPAND);
#define glVertexStream4dvATI_INDEX 2616
#define glVertexStream4dvATI_RETURN void
#define glVertexStream4dvATI_ARG_NAMES stream, coords
#define glVertexStream4dvATI_ARG_EXPAND GLenum stream, const GLdouble * coords
#define glVertexStream4dvATI_PACKED PACKED_glVertexStream4dvATI
#define glVertexStream4dvATI_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexStream4dvATI_NOT_VOID_WRAP(...) {}
#define pack_glVertexStream4dvATI(_stream, _coords) ({ \
    glVertexStream4dvATI_PACKED *packed_data = malloc(sizeof(glVertexStream4dvATI_PACKED)); \
    packed_data->index = glVertexStream4dvATI_INDEX; \
    packed_data->args.stream = (GLenum)_stream; \
    packed_data->args.coords = (GLdouble *)_coords; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexStream4dvATI(packed, ret_v) do { \
    PACKED_glVertexStream4dvATI *unpacked = (PACKED_glVertexStream4dvATI *)packed; \
    ARGS_glVertexStream4dvATI *args = (ARGS_glVertexStream4dvATI *)&unpacked->args; \
    glVertexStream4dvATI(args->stream, args->coords);; \
} while(0)
void glVertexStream4dvATI(glVertexStream4dvATI_ARG_EXPAND);
typedef void (*glVertexStream4dvATI_PTR)(glVertexStream4dvATI_ARG_EXPAND);
#define glVertexStream4fATI_INDEX 2617
#define glVertexStream4fATI_RETURN void
#define glVertexStream4fATI_ARG_NAMES stream, x, y, z, w
#define glVertexStream4fATI_ARG_EXPAND GLenum stream, GLfloat x, GLfloat y, GLfloat z, GLfloat w
#define glVertexStream4fATI_PACKED PACKED_glVertexStream4fATI
#define glVertexStream4fATI_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexStream4fATI_NOT_VOID_WRAP(...) {}
#define pack_glVertexStream4fATI(_stream, _x, _y, _z, _w) ({ \
    glVertexStream4fATI_PACKED *packed_data = malloc(sizeof(glVertexStream4fATI_PACKED)); \
    packed_data->index = glVertexStream4fATI_INDEX; \
    packed_data->args.stream = (GLenum)_stream; \
    packed_data->args.x = (GLfloat)_x; \
    packed_data->args.y = (GLfloat)_y; \
    packed_data->args.z = (GLfloat)_z; \
    packed_data->args.w = (GLfloat)_w; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexStream4fATI(packed, ret_v) do { \
    PACKED_glVertexStream4fATI *unpacked = (PACKED_glVertexStream4fATI *)packed; \
    ARGS_glVertexStream4fATI *args = (ARGS_glVertexStream4fATI *)&unpacked->args; \
    glVertexStream4fATI(args->stream, args->x, args->y, args->z, args->w);; \
} while(0)
void glVertexStream4fATI(glVertexStream4fATI_ARG_EXPAND);
typedef void (*glVertexStream4fATI_PTR)(glVertexStream4fATI_ARG_EXPAND);
#define glVertexStream4fvATI_INDEX 2618
#define glVertexStream4fvATI_RETURN void
#define glVertexStream4fvATI_ARG_NAMES stream, coords
#define glVertexStream4fvATI_ARG_EXPAND GLenum stream, const GLfloat * coords
#define glVertexStream4fvATI_PACKED PACKED_glVertexStream4fvATI
#define glVertexStream4fvATI_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexStream4fvATI_NOT_VOID_WRAP(...) {}
#define pack_glVertexStream4fvATI(_stream, _coords) ({ \
    glVertexStream4fvATI_PACKED *packed_data = malloc(sizeof(glVertexStream4fvATI_PACKED)); \
    packed_data->index = glVertexStream4fvATI_INDEX; \
    packed_data->args.stream = (GLenum)_stream; \
    packed_data->args.coords = (GLfloat *)_coords; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexStream4fvATI(packed, ret_v) do { \
    PACKED_glVertexStream4fvATI *unpacked = (PACKED_glVertexStream4fvATI *)packed; \
    ARGS_glVertexStream4fvATI *args = (ARGS_glVertexStream4fvATI *)&unpacked->args; \
    glVertexStream4fvATI(args->stream, args->coords);; \
} while(0)
void glVertexStream4fvATI(glVertexStream4fvATI_ARG_EXPAND);
typedef void (*glVertexStream4fvATI_PTR)(glVertexStream4fvATI_ARG_EXPAND);
#define glVertexStream4iATI_INDEX 2619
#define glVertexStream4iATI_RETURN void
#define glVertexStream4iATI_ARG_NAMES stream, x, y, z, w
#define glVertexStream4iATI_ARG_EXPAND GLenum stream, GLint x, GLint y, GLint z, GLint w
#define glVertexStream4iATI_PACKED PACKED_glVertexStream4iATI
#define glVertexStream4iATI_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexStream4iATI_NOT_VOID_WRAP(...) {}
#define pack_glVertexStream4iATI(_stream, _x, _y, _z, _w) ({ \
    glVertexStream4iATI_PACKED *packed_data = malloc(sizeof(glVertexStream4iATI_PACKED)); \
    packed_data->index = glVertexStream4iATI_INDEX; \
    packed_data->args.stream = (GLenum)_stream; \
    packed_data->args.x = (GLint)_x; \
    packed_data->args.y = (GLint)_y; \
    packed_data->args.z = (GLint)_z; \
    packed_data->args.w = (GLint)_w; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexStream4iATI(packed, ret_v) do { \
    PACKED_glVertexStream4iATI *unpacked = (PACKED_glVertexStream4iATI *)packed; \
    ARGS_glVertexStream4iATI *args = (ARGS_glVertexStream4iATI *)&unpacked->args; \
    glVertexStream4iATI(args->stream, args->x, args->y, args->z, args->w);; \
} while(0)
void glVertexStream4iATI(glVertexStream4iATI_ARG_EXPAND);
typedef void (*glVertexStream4iATI_PTR)(glVertexStream4iATI_ARG_EXPAND);
#define glVertexStream4ivATI_INDEX 2620
#define glVertexStream4ivATI_RETURN void
#define glVertexStream4ivATI_ARG_NAMES stream, coords
#define glVertexStream4ivATI_ARG_EXPAND GLenum stream, const GLint * coords
#define glVertexStream4ivATI_PACKED PACKED_glVertexStream4ivATI
#define glVertexStream4ivATI_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexStream4ivATI_NOT_VOID_WRAP(...) {}
#define pack_glVertexStream4ivATI(_stream, _coords) ({ \
    glVertexStream4ivATI_PACKED *packed_data = malloc(sizeof(glVertexStream4ivATI_PACKED)); \
    packed_data->index = glVertexStream4ivATI_INDEX; \
    packed_data->args.stream = (GLenum)_stream; \
    packed_data->args.coords = (GLint *)_coords; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexStream4ivATI(packed, ret_v) do { \
    PACKED_glVertexStream4ivATI *unpacked = (PACKED_glVertexStream4ivATI *)packed; \
    ARGS_glVertexStream4ivATI *args = (ARGS_glVertexStream4ivATI *)&unpacked->args; \
    glVertexStream4ivATI(args->stream, args->coords);; \
} while(0)
void glVertexStream4ivATI(glVertexStream4ivATI_ARG_EXPAND);
typedef void (*glVertexStream4ivATI_PTR)(glVertexStream4ivATI_ARG_EXPAND);
#define glVertexStream4sATI_INDEX 2621
#define glVertexStream4sATI_RETURN void
#define glVertexStream4sATI_ARG_NAMES stream, x, y, z, w
#define glVertexStream4sATI_ARG_EXPAND GLenum stream, GLshort x, GLshort y, GLshort z, GLshort w
#define glVertexStream4sATI_PACKED PACKED_glVertexStream4sATI
#define glVertexStream4sATI_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexStream4sATI_NOT_VOID_WRAP(...) {}
#define pack_glVertexStream4sATI(_stream, _x, _y, _z, _w) ({ \
    glVertexStream4sATI_PACKED *packed_data = malloc(sizeof(glVertexStream4sATI_PACKED)); \
    packed_data->index = glVertexStream4sATI_INDEX; \
    packed_data->args.stream = (GLenum)_stream; \
    packed_data->args.x = (GLshort)_x; \
    packed_data->args.y = (GLshort)_y; \
    packed_data->args.z = (GLshort)_z; \
    packed_data->args.w = (GLshort)_w; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexStream4sATI(packed, ret_v) do { \
    PACKED_glVertexStream4sATI *unpacked = (PACKED_glVertexStream4sATI *)packed; \
    ARGS_glVertexStream4sATI *args = (ARGS_glVertexStream4sATI *)&unpacked->args; \
    glVertexStream4sATI(args->stream, args->x, args->y, args->z, args->w);; \
} while(0)
void glVertexStream4sATI(glVertexStream4sATI_ARG_EXPAND);
typedef void (*glVertexStream4sATI_PTR)(glVertexStream4sATI_ARG_EXPAND);
#define glVertexStream4svATI_INDEX 2622
#define glVertexStream4svATI_RETURN void
#define glVertexStream4svATI_ARG_NAMES stream, coords
#define glVertexStream4svATI_ARG_EXPAND GLenum stream, const GLshort * coords
#define glVertexStream4svATI_PACKED PACKED_glVertexStream4svATI
#define glVertexStream4svATI_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexStream4svATI_NOT_VOID_WRAP(...) {}
#define pack_glVertexStream4svATI(_stream, _coords) ({ \
    glVertexStream4svATI_PACKED *packed_data = malloc(sizeof(glVertexStream4svATI_PACKED)); \
    packed_data->index = glVertexStream4svATI_INDEX; \
    packed_data->args.stream = (GLenum)_stream; \
    packed_data->args.coords = (GLshort *)_coords; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexStream4svATI(packed, ret_v) do { \
    PACKED_glVertexStream4svATI *unpacked = (PACKED_glVertexStream4svATI *)packed; \
    ARGS_glVertexStream4svATI *args = (ARGS_glVertexStream4svATI *)&unpacked->args; \
    glVertexStream4svATI(args->stream, args->coords);; \
} while(0)
void glVertexStream4svATI(glVertexStream4svATI_ARG_EXPAND);
typedef void (*glVertexStream4svATI_PTR)(glVertexStream4svATI_ARG_EXPAND);
#define glVertexWeightPointerEXT_INDEX 2623
#define glVertexWeightPointerEXT_RETURN void
#define glVertexWeightPointerEXT_ARG_NAMES size, type, stride, pointer
#define glVertexWeightPointerEXT_ARG_EXPAND GLint size, GLenum type, GLsizei stride, const GLvoid * pointer
#define glVertexWeightPointerEXT_PACKED PACKED_glVertexWeightPointerEXT
#define glVertexWeightPointerEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexWeightPointerEXT_NOT_VOID_WRAP(...) {}
#define pack_glVertexWeightPointerEXT(_size, _type, _stride, _pointer) ({ \
    glVertexWeightPointerEXT_PACKED *packed_data = malloc(sizeof(glVertexWeightPointerEXT_PACKED)); \
    packed_data->index = glVertexWeightPointerEXT_INDEX; \
    packed_data->args.size = (GLint)_size; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.stride = (GLsizei)_stride; \
    packed_data->args.pointer = (GLvoid *)_pointer; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexWeightPointerEXT(packed, ret_v) do { \
    PACKED_glVertexWeightPointerEXT *unpacked = (PACKED_glVertexWeightPointerEXT *)packed; \
    ARGS_glVertexWeightPointerEXT *args = (ARGS_glVertexWeightPointerEXT *)&unpacked->args; \
    glVertexWeightPointerEXT(args->size, args->type, args->stride, args->pointer);; \
} while(0)
void glVertexWeightPointerEXT(glVertexWeightPointerEXT_ARG_EXPAND);
typedef void (*glVertexWeightPointerEXT_PTR)(glVertexWeightPointerEXT_ARG_EXPAND);
#define glVertexWeightfEXT_INDEX 2624
#define glVertexWeightfEXT_RETURN void
#define glVertexWeightfEXT_ARG_NAMES weight
#define glVertexWeightfEXT_ARG_EXPAND GLfloat weight
#define glVertexWeightfEXT_PACKED PACKED_glVertexWeightfEXT
#define glVertexWeightfEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexWeightfEXT_NOT_VOID_WRAP(...) {}
#define pack_glVertexWeightfEXT(_weight) ({ \
    glVertexWeightfEXT_PACKED *packed_data = malloc(sizeof(glVertexWeightfEXT_PACKED)); \
    packed_data->index = glVertexWeightfEXT_INDEX; \
    packed_data->args.weight = (GLfloat)_weight; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexWeightfEXT(packed, ret_v) do { \
    PACKED_glVertexWeightfEXT *unpacked = (PACKED_glVertexWeightfEXT *)packed; \
    ARGS_glVertexWeightfEXT *args = (ARGS_glVertexWeightfEXT *)&unpacked->args; \
    glVertexWeightfEXT(args->weight);; \
} while(0)
void glVertexWeightfEXT(glVertexWeightfEXT_ARG_EXPAND);
typedef void (*glVertexWeightfEXT_PTR)(glVertexWeightfEXT_ARG_EXPAND);
#define glVertexWeightfvEXT_INDEX 2625
#define glVertexWeightfvEXT_RETURN void
#define glVertexWeightfvEXT_ARG_NAMES weight
#define glVertexWeightfvEXT_ARG_EXPAND const GLfloat * weight
#define glVertexWeightfvEXT_PACKED PACKED_glVertexWeightfvEXT
#define glVertexWeightfvEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexWeightfvEXT_NOT_VOID_WRAP(...) {}
#define pack_glVertexWeightfvEXT(_weight) ({ \
    glVertexWeightfvEXT_PACKED *packed_data = malloc(sizeof(glVertexWeightfvEXT_PACKED)); \
    packed_data->index = glVertexWeightfvEXT_INDEX; \
    packed_data->args.weight = (GLfloat *)_weight; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexWeightfvEXT(packed, ret_v) do { \
    PACKED_glVertexWeightfvEXT *unpacked = (PACKED_glVertexWeightfvEXT *)packed; \
    ARGS_glVertexWeightfvEXT *args = (ARGS_glVertexWeightfvEXT *)&unpacked->args; \
    glVertexWeightfvEXT(args->weight);; \
} while(0)
void glVertexWeightfvEXT(glVertexWeightfvEXT_ARG_EXPAND);
typedef void (*glVertexWeightfvEXT_PTR)(glVertexWeightfvEXT_ARG_EXPAND);
#define glVertexWeighthNV_INDEX 2626
#define glVertexWeighthNV_RETURN void
#define glVertexWeighthNV_ARG_NAMES weight
#define glVertexWeighthNV_ARG_EXPAND GLhalfNV weight
#define glVertexWeighthNV_PACKED PACKED_glVertexWeighthNV
#define glVertexWeighthNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexWeighthNV_NOT_VOID_WRAP(...) {}
#define pack_glVertexWeighthNV(_weight) ({ \
    glVertexWeighthNV_PACKED *packed_data = malloc(sizeof(glVertexWeighthNV_PACKED)); \
    packed_data->index = glVertexWeighthNV_INDEX; \
    packed_data->args.weight = (GLhalfNV)_weight; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexWeighthNV(packed, ret_v) do { \
    PACKED_glVertexWeighthNV *unpacked = (PACKED_glVertexWeighthNV *)packed; \
    ARGS_glVertexWeighthNV *args = (ARGS_glVertexWeighthNV *)&unpacked->args; \
    glVertexWeighthNV(args->weight);; \
} while(0)
void glVertexWeighthNV(glVertexWeighthNV_ARG_EXPAND);
typedef void (*glVertexWeighthNV_PTR)(glVertexWeighthNV_ARG_EXPAND);
#define glVertexWeighthvNV_INDEX 2627
#define glVertexWeighthvNV_RETURN void
#define glVertexWeighthvNV_ARG_NAMES weight
#define glVertexWeighthvNV_ARG_EXPAND const GLhalfNV * weight
#define glVertexWeighthvNV_PACKED PACKED_glVertexWeighthvNV
#define glVertexWeighthvNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVertexWeighthvNV_NOT_VOID_WRAP(...) {}
#define pack_glVertexWeighthvNV(_weight) ({ \
    glVertexWeighthvNV_PACKED *packed_data = malloc(sizeof(glVertexWeighthvNV_PACKED)); \
    packed_data->index = glVertexWeighthvNV_INDEX; \
    packed_data->args.weight = (GLhalfNV *)_weight; \
    (packed_call_t *)packed_data; \
})
#define call_glVertexWeighthvNV(packed, ret_v) do { \
    PACKED_glVertexWeighthvNV *unpacked = (PACKED_glVertexWeighthvNV *)packed; \
    ARGS_glVertexWeighthvNV *args = (ARGS_glVertexWeighthvNV *)&unpacked->args; \
    glVertexWeighthvNV(args->weight);; \
} while(0)
void glVertexWeighthvNV(glVertexWeighthvNV_ARG_EXPAND);
typedef void (*glVertexWeighthvNV_PTR)(glVertexWeighthvNV_ARG_EXPAND);
#define glVideoCaptureNV_INDEX 2628
#define glVideoCaptureNV_RETURN GLenum
#define glVideoCaptureNV_ARG_NAMES video_capture_slot, sequence_num, capture_time
#define glVideoCaptureNV_ARG_EXPAND GLuint video_capture_slot, GLuint * sequence_num, GLuint64EXT * capture_time
#define glVideoCaptureNV_PACKED PACKED_glVideoCaptureNV
#define glVideoCaptureNV_VOID_ONLY_WRAP(...) {}
#define glVideoCaptureNV_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glVideoCaptureNV(_video_capture_slot, _sequence_num, _capture_time) ({ \
    glVideoCaptureNV_PACKED *packed_data = malloc(sizeof(glVideoCaptureNV_PACKED)); \
    packed_data->index = glVideoCaptureNV_INDEX; \
    packed_data->args.video_capture_slot = (GLuint)_video_capture_slot; \
    packed_data->args.sequence_num = (GLuint *)_sequence_num; \
    packed_data->args.capture_time = (GLuint64EXT *)_capture_time; \
    (packed_call_t *)packed_data; \
})
#define call_glVideoCaptureNV(packed, ret_v) do { \
    PACKED_glVideoCaptureNV *unpacked = (PACKED_glVideoCaptureNV *)packed; \
    ARGS_glVideoCaptureNV *args = (ARGS_glVideoCaptureNV *)&unpacked->args; \
    GLenum *ret = (GLenum *)ret_v; \
    if (ret != NULL) { \
        *ret = glVideoCaptureNV(args->video_capture_slot, args->sequence_num, args->capture_time);; \
    } else { \
        glVideoCaptureNV(args->video_capture_slot, args->sequence_num, args->capture_time);; \
    } \
} while(0)
GLenum glVideoCaptureNV(glVideoCaptureNV_ARG_EXPAND);
typedef GLenum (*glVideoCaptureNV_PTR)(glVideoCaptureNV_ARG_EXPAND);
#define glVideoCaptureStreamParameterdvNV_INDEX 2629
#define glVideoCaptureStreamParameterdvNV_RETURN void
#define glVideoCaptureStreamParameterdvNV_ARG_NAMES video_capture_slot, stream, pname, params
#define glVideoCaptureStreamParameterdvNV_ARG_EXPAND GLuint video_capture_slot, GLuint stream, GLenum pname, const GLdouble * params
#define glVideoCaptureStreamParameterdvNV_PACKED PACKED_glVideoCaptureStreamParameterdvNV
#define glVideoCaptureStreamParameterdvNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVideoCaptureStreamParameterdvNV_NOT_VOID_WRAP(...) {}
#define pack_glVideoCaptureStreamParameterdvNV(_video_capture_slot, _stream, _pname, _params) ({ \
    glVideoCaptureStreamParameterdvNV_PACKED *packed_data = malloc(sizeof(glVideoCaptureStreamParameterdvNV_PACKED)); \
    packed_data->index = glVideoCaptureStreamParameterdvNV_INDEX; \
    packed_data->args.video_capture_slot = (GLuint)_video_capture_slot; \
    packed_data->args.stream = (GLuint)_stream; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLdouble *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glVideoCaptureStreamParameterdvNV(packed, ret_v) do { \
    PACKED_glVideoCaptureStreamParameterdvNV *unpacked = (PACKED_glVideoCaptureStreamParameterdvNV *)packed; \
    ARGS_glVideoCaptureStreamParameterdvNV *args = (ARGS_glVideoCaptureStreamParameterdvNV *)&unpacked->args; \
    glVideoCaptureStreamParameterdvNV(args->video_capture_slot, args->stream, args->pname, args->params);; \
} while(0)
void glVideoCaptureStreamParameterdvNV(glVideoCaptureStreamParameterdvNV_ARG_EXPAND);
typedef void (*glVideoCaptureStreamParameterdvNV_PTR)(glVideoCaptureStreamParameterdvNV_ARG_EXPAND);
#define glVideoCaptureStreamParameterfvNV_INDEX 2630
#define glVideoCaptureStreamParameterfvNV_RETURN void
#define glVideoCaptureStreamParameterfvNV_ARG_NAMES video_capture_slot, stream, pname, params
#define glVideoCaptureStreamParameterfvNV_ARG_EXPAND GLuint video_capture_slot, GLuint stream, GLenum pname, const GLfloat * params
#define glVideoCaptureStreamParameterfvNV_PACKED PACKED_glVideoCaptureStreamParameterfvNV
#define glVideoCaptureStreamParameterfvNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVideoCaptureStreamParameterfvNV_NOT_VOID_WRAP(...) {}
#define pack_glVideoCaptureStreamParameterfvNV(_video_capture_slot, _stream, _pname, _params) ({ \
    glVideoCaptureStreamParameterfvNV_PACKED *packed_data = malloc(sizeof(glVideoCaptureStreamParameterfvNV_PACKED)); \
    packed_data->index = glVideoCaptureStreamParameterfvNV_INDEX; \
    packed_data->args.video_capture_slot = (GLuint)_video_capture_slot; \
    packed_data->args.stream = (GLuint)_stream; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLfloat *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glVideoCaptureStreamParameterfvNV(packed, ret_v) do { \
    PACKED_glVideoCaptureStreamParameterfvNV *unpacked = (PACKED_glVideoCaptureStreamParameterfvNV *)packed; \
    ARGS_glVideoCaptureStreamParameterfvNV *args = (ARGS_glVideoCaptureStreamParameterfvNV *)&unpacked->args; \
    glVideoCaptureStreamParameterfvNV(args->video_capture_slot, args->stream, args->pname, args->params);; \
} while(0)
void glVideoCaptureStreamParameterfvNV(glVideoCaptureStreamParameterfvNV_ARG_EXPAND);
typedef void (*glVideoCaptureStreamParameterfvNV_PTR)(glVideoCaptureStreamParameterfvNV_ARG_EXPAND);
#define glVideoCaptureStreamParameterivNV_INDEX 2631
#define glVideoCaptureStreamParameterivNV_RETURN void
#define glVideoCaptureStreamParameterivNV_ARG_NAMES video_capture_slot, stream, pname, params
#define glVideoCaptureStreamParameterivNV_ARG_EXPAND GLuint video_capture_slot, GLuint stream, GLenum pname, const GLint * params
#define glVideoCaptureStreamParameterivNV_PACKED PACKED_glVideoCaptureStreamParameterivNV
#define glVideoCaptureStreamParameterivNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glVideoCaptureStreamParameterivNV_NOT_VOID_WRAP(...) {}
#define pack_glVideoCaptureStreamParameterivNV(_video_capture_slot, _stream, _pname, _params) ({ \
    glVideoCaptureStreamParameterivNV_PACKED *packed_data = malloc(sizeof(glVideoCaptureStreamParameterivNV_PACKED)); \
    packed_data->index = glVideoCaptureStreamParameterivNV_INDEX; \
    packed_data->args.video_capture_slot = (GLuint)_video_capture_slot; \
    packed_data->args.stream = (GLuint)_stream; \
    packed_data->args.pname = (GLenum)_pname; \
    packed_data->args.params = (GLint *)_params; \
    (packed_call_t *)packed_data; \
})
#define call_glVideoCaptureStreamParameterivNV(packed, ret_v) do { \
    PACKED_glVideoCaptureStreamParameterivNV *unpacked = (PACKED_glVideoCaptureStreamParameterivNV *)packed; \
    ARGS_glVideoCaptureStreamParameterivNV *args = (ARGS_glVideoCaptureStreamParameterivNV *)&unpacked->args; \
    glVideoCaptureStreamParameterivNV(args->video_capture_slot, args->stream, args->pname, args->params);; \
} while(0)
void glVideoCaptureStreamParameterivNV(glVideoCaptureStreamParameterivNV_ARG_EXPAND);
typedef void (*glVideoCaptureStreamParameterivNV_PTR)(glVideoCaptureStreamParameterivNV_ARG_EXPAND);
#define glViewport_INDEX 2632
#define glViewport_RETURN void
#define glViewport_ARG_NAMES x, y, width, height
#define glViewport_ARG_EXPAND GLint x, GLint y, GLsizei width, GLsizei height
#define glViewport_PACKED PACKED_glViewport
#define glViewport_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glViewport_NOT_VOID_WRAP(...) {}
#define pack_glViewport(_x, _y, _width, _height) ({ \
    glViewport_PACKED *packed_data = malloc(sizeof(glViewport_PACKED)); \
    packed_data->index = glViewport_INDEX; \
    packed_data->args.x = (GLint)_x; \
    packed_data->args.y = (GLint)_y; \
    packed_data->args.width = (GLsizei)_width; \
    packed_data->args.height = (GLsizei)_height; \
    (packed_call_t *)packed_data; \
})
#define call_glViewport(packed, ret_v) do { \
    PACKED_glViewport *unpacked = (PACKED_glViewport *)packed; \
    ARGS_glViewport *args = (ARGS_glViewport *)&unpacked->args; \
    glViewport(args->x, args->y, args->width, args->height);; \
} while(0)
void glViewport(glViewport_ARG_EXPAND);
typedef void (*glViewport_PTR)(glViewport_ARG_EXPAND);
#define glViewportArrayv_INDEX 2633
#define glViewportArrayv_RETURN void
#define glViewportArrayv_ARG_NAMES first, count, v
#define glViewportArrayv_ARG_EXPAND GLuint first, GLsizei count, const GLfloat * v
#define glViewportArrayv_PACKED PACKED_glViewportArrayv
#define glViewportArrayv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glViewportArrayv_NOT_VOID_WRAP(...) {}
#define pack_glViewportArrayv(_first, _count, _v) ({ \
    glViewportArrayv_PACKED *packed_data = malloc(sizeof(glViewportArrayv_PACKED)); \
    packed_data->index = glViewportArrayv_INDEX; \
    packed_data->args.first = (GLuint)_first; \
    packed_data->args.count = (GLsizei)_count; \
    packed_data->args.v = (GLfloat *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glViewportArrayv(packed, ret_v) do { \
    PACKED_glViewportArrayv *unpacked = (PACKED_glViewportArrayv *)packed; \
    ARGS_glViewportArrayv *args = (ARGS_glViewportArrayv *)&unpacked->args; \
    glViewportArrayv(args->first, args->count, args->v);; \
} while(0)
void glViewportArrayv(glViewportArrayv_ARG_EXPAND);
typedef void (*glViewportArrayv_PTR)(glViewportArrayv_ARG_EXPAND);
#define glViewportIndexedf_INDEX 2634
#define glViewportIndexedf_RETURN void
#define glViewportIndexedf_ARG_NAMES index, x, y, w, h
#define glViewportIndexedf_ARG_EXPAND GLuint index, GLfloat x, GLfloat y, GLfloat w, GLfloat h
#define glViewportIndexedf_PACKED PACKED_glViewportIndexedf
#define glViewportIndexedf_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glViewportIndexedf_NOT_VOID_WRAP(...) {}
#define pack_glViewportIndexedf(_index, _x, _y, _w, _h) ({ \
    glViewportIndexedf_PACKED *packed_data = malloc(sizeof(glViewportIndexedf_PACKED)); \
    packed_data->index = glViewportIndexedf_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.x = (GLfloat)_x; \
    packed_data->args.y = (GLfloat)_y; \
    packed_data->args.w = (GLfloat)_w; \
    packed_data->args.h = (GLfloat)_h; \
    (packed_call_t *)packed_data; \
})
#define call_glViewportIndexedf(packed, ret_v) do { \
    PACKED_glViewportIndexedf *unpacked = (PACKED_glViewportIndexedf *)packed; \
    ARGS_glViewportIndexedf *args = (ARGS_glViewportIndexedf *)&unpacked->args; \
    glViewportIndexedf(args->index, args->x, args->y, args->w, args->h);; \
} while(0)
void glViewportIndexedf(glViewportIndexedf_ARG_EXPAND);
typedef void (*glViewportIndexedf_PTR)(glViewportIndexedf_ARG_EXPAND);
#define glViewportIndexedfv_INDEX 2635
#define glViewportIndexedfv_RETURN void
#define glViewportIndexedfv_ARG_NAMES index, v
#define glViewportIndexedfv_ARG_EXPAND GLuint index, const GLfloat * v
#define glViewportIndexedfv_PACKED PACKED_glViewportIndexedfv
#define glViewportIndexedfv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glViewportIndexedfv_NOT_VOID_WRAP(...) {}
#define pack_glViewportIndexedfv(_index, _v) ({ \
    glViewportIndexedfv_PACKED *packed_data = malloc(sizeof(glViewportIndexedfv_PACKED)); \
    packed_data->index = glViewportIndexedfv_INDEX; \
    packed_data->args.index = (GLuint)_index; \
    packed_data->args.v = (GLfloat *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glViewportIndexedfv(packed, ret_v) do { \
    PACKED_glViewportIndexedfv *unpacked = (PACKED_glViewportIndexedfv *)packed; \
    ARGS_glViewportIndexedfv *args = (ARGS_glViewportIndexedfv *)&unpacked->args; \
    glViewportIndexedfv(args->index, args->v);; \
} while(0)
void glViewportIndexedfv(glViewportIndexedfv_ARG_EXPAND);
typedef void (*glViewportIndexedfv_PTR)(glViewportIndexedfv_ARG_EXPAND);
#define glWaitSync_INDEX 2636
#define glWaitSync_RETURN void
#define glWaitSync_ARG_NAMES sync, flags, timeout
#define glWaitSync_ARG_EXPAND GLsync sync, GLbitfield flags, GLuint64 timeout
#define glWaitSync_PACKED PACKED_glWaitSync
#define glWaitSync_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glWaitSync_NOT_VOID_WRAP(...) {}
#define pack_glWaitSync(_sync, _flags, _timeout) ({ \
    glWaitSync_PACKED *packed_data = malloc(sizeof(glWaitSync_PACKED)); \
    packed_data->index = glWaitSync_INDEX; \
    packed_data->args.sync = (GLsync)_sync; \
    packed_data->args.flags = (GLbitfield)_flags; \
    packed_data->args.timeout = (GLuint64)_timeout; \
    (packed_call_t *)packed_data; \
})
#define call_glWaitSync(packed, ret_v) do { \
    PACKED_glWaitSync *unpacked = (PACKED_glWaitSync *)packed; \
    ARGS_glWaitSync *args = (ARGS_glWaitSync *)&unpacked->args; \
    glWaitSync(args->sync, args->flags, args->timeout);; \
} while(0)
void glWaitSync(glWaitSync_ARG_EXPAND);
typedef void (*glWaitSync_PTR)(glWaitSync_ARG_EXPAND);
#define glWeightPathsNV_INDEX 2637
#define glWeightPathsNV_RETURN void
#define glWeightPathsNV_ARG_NAMES resultPath, numPaths, paths, weights
#define glWeightPathsNV_ARG_EXPAND GLuint resultPath, GLsizei numPaths, const GLuint * paths, const GLfloat * weights
#define glWeightPathsNV_PACKED PACKED_glWeightPathsNV
#define glWeightPathsNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glWeightPathsNV_NOT_VOID_WRAP(...) {}
#define pack_glWeightPathsNV(_resultPath, _numPaths, _paths, _weights) ({ \
    glWeightPathsNV_PACKED *packed_data = malloc(sizeof(glWeightPathsNV_PACKED)); \
    packed_data->index = glWeightPathsNV_INDEX; \
    packed_data->args.resultPath = (GLuint)_resultPath; \
    packed_data->args.numPaths = (GLsizei)_numPaths; \
    packed_data->args.paths = (GLuint *)_paths; \
    packed_data->args.weights = (GLfloat *)_weights; \
    (packed_call_t *)packed_data; \
})
#define call_glWeightPathsNV(packed, ret_v) do { \
    PACKED_glWeightPathsNV *unpacked = (PACKED_glWeightPathsNV *)packed; \
    ARGS_glWeightPathsNV *args = (ARGS_glWeightPathsNV *)&unpacked->args; \
    glWeightPathsNV(args->resultPath, args->numPaths, args->paths, args->weights);; \
} while(0)
void glWeightPathsNV(glWeightPathsNV_ARG_EXPAND);
typedef void (*glWeightPathsNV_PTR)(glWeightPathsNV_ARG_EXPAND);
#define glWeightPointerARB_INDEX 2638
#define glWeightPointerARB_RETURN void
#define glWeightPointerARB_ARG_NAMES size, type, stride, pointer
#define glWeightPointerARB_ARG_EXPAND GLint size, GLenum type, GLsizei stride, const GLvoid * pointer
#define glWeightPointerARB_PACKED PACKED_glWeightPointerARB
#define glWeightPointerARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glWeightPointerARB_NOT_VOID_WRAP(...) {}
#define pack_glWeightPointerARB(_size, _type, _stride, _pointer) ({ \
    glWeightPointerARB_PACKED *packed_data = malloc(sizeof(glWeightPointerARB_PACKED)); \
    packed_data->index = glWeightPointerARB_INDEX; \
    packed_data->args.size = (GLint)_size; \
    packed_data->args.type = (GLenum)_type; \
    packed_data->args.stride = (GLsizei)_stride; \
    packed_data->args.pointer = (GLvoid *)_pointer; \
    (packed_call_t *)packed_data; \
})
#define call_glWeightPointerARB(packed, ret_v) do { \
    PACKED_glWeightPointerARB *unpacked = (PACKED_glWeightPointerARB *)packed; \
    ARGS_glWeightPointerARB *args = (ARGS_glWeightPointerARB *)&unpacked->args; \
    glWeightPointerARB(args->size, args->type, args->stride, args->pointer);; \
} while(0)
void glWeightPointerARB(glWeightPointerARB_ARG_EXPAND);
typedef void (*glWeightPointerARB_PTR)(glWeightPointerARB_ARG_EXPAND);
#define glWeightbvARB_INDEX 2639
#define glWeightbvARB_RETURN void
#define glWeightbvARB_ARG_NAMES size, weights
#define glWeightbvARB_ARG_EXPAND GLint size, const GLbyte * weights
#define glWeightbvARB_PACKED PACKED_glWeightbvARB
#define glWeightbvARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glWeightbvARB_NOT_VOID_WRAP(...) {}
#define pack_glWeightbvARB(_size, _weights) ({ \
    glWeightbvARB_PACKED *packed_data = malloc(sizeof(glWeightbvARB_PACKED)); \
    packed_data->index = glWeightbvARB_INDEX; \
    packed_data->args.size = (GLint)_size; \
    packed_data->args.weights = (GLbyte *)_weights; \
    (packed_call_t *)packed_data; \
})
#define call_glWeightbvARB(packed, ret_v) do { \
    PACKED_glWeightbvARB *unpacked = (PACKED_glWeightbvARB *)packed; \
    ARGS_glWeightbvARB *args = (ARGS_glWeightbvARB *)&unpacked->args; \
    glWeightbvARB(args->size, args->weights);; \
} while(0)
void glWeightbvARB(glWeightbvARB_ARG_EXPAND);
typedef void (*glWeightbvARB_PTR)(glWeightbvARB_ARG_EXPAND);
#define glWeightdvARB_INDEX 2640
#define glWeightdvARB_RETURN void
#define glWeightdvARB_ARG_NAMES size, weights
#define glWeightdvARB_ARG_EXPAND GLint size, const GLdouble * weights
#define glWeightdvARB_PACKED PACKED_glWeightdvARB
#define glWeightdvARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glWeightdvARB_NOT_VOID_WRAP(...) {}
#define pack_glWeightdvARB(_size, _weights) ({ \
    glWeightdvARB_PACKED *packed_data = malloc(sizeof(glWeightdvARB_PACKED)); \
    packed_data->index = glWeightdvARB_INDEX; \
    packed_data->args.size = (GLint)_size; \
    packed_data->args.weights = (GLdouble *)_weights; \
    (packed_call_t *)packed_data; \
})
#define call_glWeightdvARB(packed, ret_v) do { \
    PACKED_glWeightdvARB *unpacked = (PACKED_glWeightdvARB *)packed; \
    ARGS_glWeightdvARB *args = (ARGS_glWeightdvARB *)&unpacked->args; \
    glWeightdvARB(args->size, args->weights);; \
} while(0)
void glWeightdvARB(glWeightdvARB_ARG_EXPAND);
typedef void (*glWeightdvARB_PTR)(glWeightdvARB_ARG_EXPAND);
#define glWeightfvARB_INDEX 2641
#define glWeightfvARB_RETURN void
#define glWeightfvARB_ARG_NAMES size, weights
#define glWeightfvARB_ARG_EXPAND GLint size, const GLfloat * weights
#define glWeightfvARB_PACKED PACKED_glWeightfvARB
#define glWeightfvARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glWeightfvARB_NOT_VOID_WRAP(...) {}
#define pack_glWeightfvARB(_size, _weights) ({ \
    glWeightfvARB_PACKED *packed_data = malloc(sizeof(glWeightfvARB_PACKED)); \
    packed_data->index = glWeightfvARB_INDEX; \
    packed_data->args.size = (GLint)_size; \
    packed_data->args.weights = (GLfloat *)_weights; \
    (packed_call_t *)packed_data; \
})
#define call_glWeightfvARB(packed, ret_v) do { \
    PACKED_glWeightfvARB *unpacked = (PACKED_glWeightfvARB *)packed; \
    ARGS_glWeightfvARB *args = (ARGS_glWeightfvARB *)&unpacked->args; \
    glWeightfvARB(args->size, args->weights);; \
} while(0)
void glWeightfvARB(glWeightfvARB_ARG_EXPAND);
typedef void (*glWeightfvARB_PTR)(glWeightfvARB_ARG_EXPAND);
#define glWeightivARB_INDEX 2642
#define glWeightivARB_RETURN void
#define glWeightivARB_ARG_NAMES size, weights
#define glWeightivARB_ARG_EXPAND GLint size, const GLint * weights
#define glWeightivARB_PACKED PACKED_glWeightivARB
#define glWeightivARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glWeightivARB_NOT_VOID_WRAP(...) {}
#define pack_glWeightivARB(_size, _weights) ({ \
    glWeightivARB_PACKED *packed_data = malloc(sizeof(glWeightivARB_PACKED)); \
    packed_data->index = glWeightivARB_INDEX; \
    packed_data->args.size = (GLint)_size; \
    packed_data->args.weights = (GLint *)_weights; \
    (packed_call_t *)packed_data; \
})
#define call_glWeightivARB(packed, ret_v) do { \
    PACKED_glWeightivARB *unpacked = (PACKED_glWeightivARB *)packed; \
    ARGS_glWeightivARB *args = (ARGS_glWeightivARB *)&unpacked->args; \
    glWeightivARB(args->size, args->weights);; \
} while(0)
void glWeightivARB(glWeightivARB_ARG_EXPAND);
typedef void (*glWeightivARB_PTR)(glWeightivARB_ARG_EXPAND);
#define glWeightsvARB_INDEX 2643
#define glWeightsvARB_RETURN void
#define glWeightsvARB_ARG_NAMES size, weights
#define glWeightsvARB_ARG_EXPAND GLint size, const GLshort * weights
#define glWeightsvARB_PACKED PACKED_glWeightsvARB
#define glWeightsvARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glWeightsvARB_NOT_VOID_WRAP(...) {}
#define pack_glWeightsvARB(_size, _weights) ({ \
    glWeightsvARB_PACKED *packed_data = malloc(sizeof(glWeightsvARB_PACKED)); \
    packed_data->index = glWeightsvARB_INDEX; \
    packed_data->args.size = (GLint)_size; \
    packed_data->args.weights = (GLshort *)_weights; \
    (packed_call_t *)packed_data; \
})
#define call_glWeightsvARB(packed, ret_v) do { \
    PACKED_glWeightsvARB *unpacked = (PACKED_glWeightsvARB *)packed; \
    ARGS_glWeightsvARB *args = (ARGS_glWeightsvARB *)&unpacked->args; \
    glWeightsvARB(args->size, args->weights);; \
} while(0)
void glWeightsvARB(glWeightsvARB_ARG_EXPAND);
typedef void (*glWeightsvARB_PTR)(glWeightsvARB_ARG_EXPAND);
#define glWeightubvARB_INDEX 2644
#define glWeightubvARB_RETURN void
#define glWeightubvARB_ARG_NAMES size, weights
#define glWeightubvARB_ARG_EXPAND GLint size, const GLubyte * weights
#define glWeightubvARB_PACKED PACKED_glWeightubvARB
#define glWeightubvARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glWeightubvARB_NOT_VOID_WRAP(...) {}
#define pack_glWeightubvARB(_size, _weights) ({ \
    glWeightubvARB_PACKED *packed_data = malloc(sizeof(glWeightubvARB_PACKED)); \
    packed_data->index = glWeightubvARB_INDEX; \
    packed_data->args.size = (GLint)_size; \
    packed_data->args.weights = (GLubyte *)_weights; \
    (packed_call_t *)packed_data; \
})
#define call_glWeightubvARB(packed, ret_v) do { \
    PACKED_glWeightubvARB *unpacked = (PACKED_glWeightubvARB *)packed; \
    ARGS_glWeightubvARB *args = (ARGS_glWeightubvARB *)&unpacked->args; \
    glWeightubvARB(args->size, args->weights);; \
} while(0)
void glWeightubvARB(glWeightubvARB_ARG_EXPAND);
typedef void (*glWeightubvARB_PTR)(glWeightubvARB_ARG_EXPAND);
#define glWeightuivARB_INDEX 2645
#define glWeightuivARB_RETURN void
#define glWeightuivARB_ARG_NAMES size, weights
#define glWeightuivARB_ARG_EXPAND GLint size, const GLuint * weights
#define glWeightuivARB_PACKED PACKED_glWeightuivARB
#define glWeightuivARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glWeightuivARB_NOT_VOID_WRAP(...) {}
#define pack_glWeightuivARB(_size, _weights) ({ \
    glWeightuivARB_PACKED *packed_data = malloc(sizeof(glWeightuivARB_PACKED)); \
    packed_data->index = glWeightuivARB_INDEX; \
    packed_data->args.size = (GLint)_size; \
    packed_data->args.weights = (GLuint *)_weights; \
    (packed_call_t *)packed_data; \
})
#define call_glWeightuivARB(packed, ret_v) do { \
    PACKED_glWeightuivARB *unpacked = (PACKED_glWeightuivARB *)packed; \
    ARGS_glWeightuivARB *args = (ARGS_glWeightuivARB *)&unpacked->args; \
    glWeightuivARB(args->size, args->weights);; \
} while(0)
void glWeightuivARB(glWeightuivARB_ARG_EXPAND);
typedef void (*glWeightuivARB_PTR)(glWeightuivARB_ARG_EXPAND);
#define glWeightusvARB_INDEX 2646
#define glWeightusvARB_RETURN void
#define glWeightusvARB_ARG_NAMES size, weights
#define glWeightusvARB_ARG_EXPAND GLint size, const GLushort * weights
#define glWeightusvARB_PACKED PACKED_glWeightusvARB
#define glWeightusvARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glWeightusvARB_NOT_VOID_WRAP(...) {}
#define pack_glWeightusvARB(_size, _weights) ({ \
    glWeightusvARB_PACKED *packed_data = malloc(sizeof(glWeightusvARB_PACKED)); \
    packed_data->index = glWeightusvARB_INDEX; \
    packed_data->args.size = (GLint)_size; \
    packed_data->args.weights = (GLushort *)_weights; \
    (packed_call_t *)packed_data; \
})
#define call_glWeightusvARB(packed, ret_v) do { \
    PACKED_glWeightusvARB *unpacked = (PACKED_glWeightusvARB *)packed; \
    ARGS_glWeightusvARB *args = (ARGS_glWeightusvARB *)&unpacked->args; \
    glWeightusvARB(args->size, args->weights);; \
} while(0)
void glWeightusvARB(glWeightusvARB_ARG_EXPAND);
typedef void (*glWeightusvARB_PTR)(glWeightusvARB_ARG_EXPAND);
#define glWindowPos2d_INDEX 2647
#define glWindowPos2d_RETURN void
#define glWindowPos2d_ARG_NAMES x, y
#define glWindowPos2d_ARG_EXPAND GLdouble x, GLdouble y
#define glWindowPos2d_PACKED PACKED_glWindowPos2d
#define glWindowPos2d_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glWindowPos2d_NOT_VOID_WRAP(...) {}
#define pack_glWindowPos2d(_x, _y) ({ \
    glWindowPos2d_PACKED *packed_data = malloc(sizeof(glWindowPos2d_PACKED)); \
    packed_data->index = glWindowPos2d_INDEX; \
    packed_data->args.x = (GLdouble)_x; \
    packed_data->args.y = (GLdouble)_y; \
    (packed_call_t *)packed_data; \
})
#define call_glWindowPos2d(packed, ret_v) do { \
    PACKED_glWindowPos2d *unpacked = (PACKED_glWindowPos2d *)packed; \
    ARGS_glWindowPos2d *args = (ARGS_glWindowPos2d *)&unpacked->args; \
    glWindowPos2d(args->x, args->y);; \
} while(0)
void glWindowPos2d(glWindowPos2d_ARG_EXPAND);
typedef void (*glWindowPos2d_PTR)(glWindowPos2d_ARG_EXPAND);
#define glWindowPos2dARB_INDEX 2648
#define glWindowPos2dARB_RETURN void
#define glWindowPos2dARB_ARG_NAMES x, y
#define glWindowPos2dARB_ARG_EXPAND GLdouble x, GLdouble y
#define glWindowPos2dARB_PACKED PACKED_glWindowPos2dARB
#define glWindowPos2dARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glWindowPos2dARB_NOT_VOID_WRAP(...) {}
#define pack_glWindowPos2dARB(_x, _y) ({ \
    glWindowPos2dARB_PACKED *packed_data = malloc(sizeof(glWindowPos2dARB_PACKED)); \
    packed_data->index = glWindowPos2dARB_INDEX; \
    packed_data->args.x = (GLdouble)_x; \
    packed_data->args.y = (GLdouble)_y; \
    (packed_call_t *)packed_data; \
})
#define call_glWindowPos2dARB(packed, ret_v) do { \
    PACKED_glWindowPos2dARB *unpacked = (PACKED_glWindowPos2dARB *)packed; \
    ARGS_glWindowPos2dARB *args = (ARGS_glWindowPos2dARB *)&unpacked->args; \
    glWindowPos2dARB(args->x, args->y);; \
} while(0)
void glWindowPos2dARB(glWindowPos2dARB_ARG_EXPAND);
typedef void (*glWindowPos2dARB_PTR)(glWindowPos2dARB_ARG_EXPAND);
#define glWindowPos2dMESA_INDEX 2649
#define glWindowPos2dMESA_RETURN void
#define glWindowPos2dMESA_ARG_NAMES x, y
#define glWindowPos2dMESA_ARG_EXPAND GLdouble x, GLdouble y
#define glWindowPos2dMESA_PACKED PACKED_glWindowPos2dMESA
#define glWindowPos2dMESA_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glWindowPos2dMESA_NOT_VOID_WRAP(...) {}
#define pack_glWindowPos2dMESA(_x, _y) ({ \
    glWindowPos2dMESA_PACKED *packed_data = malloc(sizeof(glWindowPos2dMESA_PACKED)); \
    packed_data->index = glWindowPos2dMESA_INDEX; \
    packed_data->args.x = (GLdouble)_x; \
    packed_data->args.y = (GLdouble)_y; \
    (packed_call_t *)packed_data; \
})
#define call_glWindowPos2dMESA(packed, ret_v) do { \
    PACKED_glWindowPos2dMESA *unpacked = (PACKED_glWindowPos2dMESA *)packed; \
    ARGS_glWindowPos2dMESA *args = (ARGS_glWindowPos2dMESA *)&unpacked->args; \
    glWindowPos2dMESA(args->x, args->y);; \
} while(0)
void glWindowPos2dMESA(glWindowPos2dMESA_ARG_EXPAND);
typedef void (*glWindowPos2dMESA_PTR)(glWindowPos2dMESA_ARG_EXPAND);
#define glWindowPos2dv_INDEX 2650
#define glWindowPos2dv_RETURN void
#define glWindowPos2dv_ARG_NAMES v
#define glWindowPos2dv_ARG_EXPAND const GLdouble * v
#define glWindowPos2dv_PACKED PACKED_glWindowPos2dv
#define glWindowPos2dv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glWindowPos2dv_NOT_VOID_WRAP(...) {}
#define pack_glWindowPos2dv(_v) ({ \
    glWindowPos2dv_PACKED *packed_data = malloc(sizeof(glWindowPos2dv_PACKED)); \
    packed_data->index = glWindowPos2dv_INDEX; \
    packed_data->args.v = (GLdouble *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glWindowPos2dv(packed, ret_v) do { \
    PACKED_glWindowPos2dv *unpacked = (PACKED_glWindowPos2dv *)packed; \
    ARGS_glWindowPos2dv *args = (ARGS_glWindowPos2dv *)&unpacked->args; \
    glWindowPos2dv(args->v);; \
} while(0)
void glWindowPos2dv(glWindowPos2dv_ARG_EXPAND);
typedef void (*glWindowPos2dv_PTR)(glWindowPos2dv_ARG_EXPAND);
#define glWindowPos2dvARB_INDEX 2651
#define glWindowPos2dvARB_RETURN void
#define glWindowPos2dvARB_ARG_NAMES v
#define glWindowPos2dvARB_ARG_EXPAND const GLdouble * v
#define glWindowPos2dvARB_PACKED PACKED_glWindowPos2dvARB
#define glWindowPos2dvARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glWindowPos2dvARB_NOT_VOID_WRAP(...) {}
#define pack_glWindowPos2dvARB(_v) ({ \
    glWindowPos2dvARB_PACKED *packed_data = malloc(sizeof(glWindowPos2dvARB_PACKED)); \
    packed_data->index = glWindowPos2dvARB_INDEX; \
    packed_data->args.v = (GLdouble *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glWindowPos2dvARB(packed, ret_v) do { \
    PACKED_glWindowPos2dvARB *unpacked = (PACKED_glWindowPos2dvARB *)packed; \
    ARGS_glWindowPos2dvARB *args = (ARGS_glWindowPos2dvARB *)&unpacked->args; \
    glWindowPos2dvARB(args->v);; \
} while(0)
void glWindowPos2dvARB(glWindowPos2dvARB_ARG_EXPAND);
typedef void (*glWindowPos2dvARB_PTR)(glWindowPos2dvARB_ARG_EXPAND);
#define glWindowPos2dvMESA_INDEX 2652
#define glWindowPos2dvMESA_RETURN void
#define glWindowPos2dvMESA_ARG_NAMES v
#define glWindowPos2dvMESA_ARG_EXPAND const GLdouble * v
#define glWindowPos2dvMESA_PACKED PACKED_glWindowPos2dvMESA
#define glWindowPos2dvMESA_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glWindowPos2dvMESA_NOT_VOID_WRAP(...) {}
#define pack_glWindowPos2dvMESA(_v) ({ \
    glWindowPos2dvMESA_PACKED *packed_data = malloc(sizeof(glWindowPos2dvMESA_PACKED)); \
    packed_data->index = glWindowPos2dvMESA_INDEX; \
    packed_data->args.v = (GLdouble *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glWindowPos2dvMESA(packed, ret_v) do { \
    PACKED_glWindowPos2dvMESA *unpacked = (PACKED_glWindowPos2dvMESA *)packed; \
    ARGS_glWindowPos2dvMESA *args = (ARGS_glWindowPos2dvMESA *)&unpacked->args; \
    glWindowPos2dvMESA(args->v);; \
} while(0)
void glWindowPos2dvMESA(glWindowPos2dvMESA_ARG_EXPAND);
typedef void (*glWindowPos2dvMESA_PTR)(glWindowPos2dvMESA_ARG_EXPAND);
#define glWindowPos2f_INDEX 2653
#define glWindowPos2f_RETURN void
#define glWindowPos2f_ARG_NAMES x, y
#define glWindowPos2f_ARG_EXPAND GLfloat x, GLfloat y
#define glWindowPos2f_PACKED PACKED_glWindowPos2f
#define glWindowPos2f_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glWindowPos2f_NOT_VOID_WRAP(...) {}
#define pack_glWindowPos2f(_x, _y) ({ \
    glWindowPos2f_PACKED *packed_data = malloc(sizeof(glWindowPos2f_PACKED)); \
    packed_data->index = glWindowPos2f_INDEX; \
    packed_data->args.x = (GLfloat)_x; \
    packed_data->args.y = (GLfloat)_y; \
    (packed_call_t *)packed_data; \
})
#define call_glWindowPos2f(packed, ret_v) do { \
    PACKED_glWindowPos2f *unpacked = (PACKED_glWindowPos2f *)packed; \
    ARGS_glWindowPos2f *args = (ARGS_glWindowPos2f *)&unpacked->args; \
    glWindowPos2f(args->x, args->y);; \
} while(0)
void glWindowPos2f(glWindowPos2f_ARG_EXPAND);
typedef void (*glWindowPos2f_PTR)(glWindowPos2f_ARG_EXPAND);
#define glWindowPos2fARB_INDEX 2654
#define glWindowPos2fARB_RETURN void
#define glWindowPos2fARB_ARG_NAMES x, y
#define glWindowPos2fARB_ARG_EXPAND GLfloat x, GLfloat y
#define glWindowPos2fARB_PACKED PACKED_glWindowPos2fARB
#define glWindowPos2fARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glWindowPos2fARB_NOT_VOID_WRAP(...) {}
#define pack_glWindowPos2fARB(_x, _y) ({ \
    glWindowPos2fARB_PACKED *packed_data = malloc(sizeof(glWindowPos2fARB_PACKED)); \
    packed_data->index = glWindowPos2fARB_INDEX; \
    packed_data->args.x = (GLfloat)_x; \
    packed_data->args.y = (GLfloat)_y; \
    (packed_call_t *)packed_data; \
})
#define call_glWindowPos2fARB(packed, ret_v) do { \
    PACKED_glWindowPos2fARB *unpacked = (PACKED_glWindowPos2fARB *)packed; \
    ARGS_glWindowPos2fARB *args = (ARGS_glWindowPos2fARB *)&unpacked->args; \
    glWindowPos2fARB(args->x, args->y);; \
} while(0)
void glWindowPos2fARB(glWindowPos2fARB_ARG_EXPAND);
typedef void (*glWindowPos2fARB_PTR)(glWindowPos2fARB_ARG_EXPAND);
#define glWindowPos2fMESA_INDEX 2655
#define glWindowPos2fMESA_RETURN void
#define glWindowPos2fMESA_ARG_NAMES x, y
#define glWindowPos2fMESA_ARG_EXPAND GLfloat x, GLfloat y
#define glWindowPos2fMESA_PACKED PACKED_glWindowPos2fMESA
#define glWindowPos2fMESA_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glWindowPos2fMESA_NOT_VOID_WRAP(...) {}
#define pack_glWindowPos2fMESA(_x, _y) ({ \
    glWindowPos2fMESA_PACKED *packed_data = malloc(sizeof(glWindowPos2fMESA_PACKED)); \
    packed_data->index = glWindowPos2fMESA_INDEX; \
    packed_data->args.x = (GLfloat)_x; \
    packed_data->args.y = (GLfloat)_y; \
    (packed_call_t *)packed_data; \
})
#define call_glWindowPos2fMESA(packed, ret_v) do { \
    PACKED_glWindowPos2fMESA *unpacked = (PACKED_glWindowPos2fMESA *)packed; \
    ARGS_glWindowPos2fMESA *args = (ARGS_glWindowPos2fMESA *)&unpacked->args; \
    glWindowPos2fMESA(args->x, args->y);; \
} while(0)
void glWindowPos2fMESA(glWindowPos2fMESA_ARG_EXPAND);
typedef void (*glWindowPos2fMESA_PTR)(glWindowPos2fMESA_ARG_EXPAND);
#define glWindowPos2fv_INDEX 2656
#define glWindowPos2fv_RETURN void
#define glWindowPos2fv_ARG_NAMES v
#define glWindowPos2fv_ARG_EXPAND const GLfloat * v
#define glWindowPos2fv_PACKED PACKED_glWindowPos2fv
#define glWindowPos2fv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glWindowPos2fv_NOT_VOID_WRAP(...) {}
#define pack_glWindowPos2fv(_v) ({ \
    glWindowPos2fv_PACKED *packed_data = malloc(sizeof(glWindowPos2fv_PACKED)); \
    packed_data->index = glWindowPos2fv_INDEX; \
    packed_data->args.v = (GLfloat *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glWindowPos2fv(packed, ret_v) do { \
    PACKED_glWindowPos2fv *unpacked = (PACKED_glWindowPos2fv *)packed; \
    ARGS_glWindowPos2fv *args = (ARGS_glWindowPos2fv *)&unpacked->args; \
    glWindowPos2fv(args->v);; \
} while(0)
void glWindowPos2fv(glWindowPos2fv_ARG_EXPAND);
typedef void (*glWindowPos2fv_PTR)(glWindowPos2fv_ARG_EXPAND);
#define glWindowPos2fvARB_INDEX 2657
#define glWindowPos2fvARB_RETURN void
#define glWindowPos2fvARB_ARG_NAMES v
#define glWindowPos2fvARB_ARG_EXPAND const GLfloat * v
#define glWindowPos2fvARB_PACKED PACKED_glWindowPos2fvARB
#define glWindowPos2fvARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glWindowPos2fvARB_NOT_VOID_WRAP(...) {}
#define pack_glWindowPos2fvARB(_v) ({ \
    glWindowPos2fvARB_PACKED *packed_data = malloc(sizeof(glWindowPos2fvARB_PACKED)); \
    packed_data->index = glWindowPos2fvARB_INDEX; \
    packed_data->args.v = (GLfloat *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glWindowPos2fvARB(packed, ret_v) do { \
    PACKED_glWindowPos2fvARB *unpacked = (PACKED_glWindowPos2fvARB *)packed; \
    ARGS_glWindowPos2fvARB *args = (ARGS_glWindowPos2fvARB *)&unpacked->args; \
    glWindowPos2fvARB(args->v);; \
} while(0)
void glWindowPos2fvARB(glWindowPos2fvARB_ARG_EXPAND);
typedef void (*glWindowPos2fvARB_PTR)(glWindowPos2fvARB_ARG_EXPAND);
#define glWindowPos2fvMESA_INDEX 2658
#define glWindowPos2fvMESA_RETURN void
#define glWindowPos2fvMESA_ARG_NAMES v
#define glWindowPos2fvMESA_ARG_EXPAND const GLfloat * v
#define glWindowPos2fvMESA_PACKED PACKED_glWindowPos2fvMESA
#define glWindowPos2fvMESA_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glWindowPos2fvMESA_NOT_VOID_WRAP(...) {}
#define pack_glWindowPos2fvMESA(_v) ({ \
    glWindowPos2fvMESA_PACKED *packed_data = malloc(sizeof(glWindowPos2fvMESA_PACKED)); \
    packed_data->index = glWindowPos2fvMESA_INDEX; \
    packed_data->args.v = (GLfloat *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glWindowPos2fvMESA(packed, ret_v) do { \
    PACKED_glWindowPos2fvMESA *unpacked = (PACKED_glWindowPos2fvMESA *)packed; \
    ARGS_glWindowPos2fvMESA *args = (ARGS_glWindowPos2fvMESA *)&unpacked->args; \
    glWindowPos2fvMESA(args->v);; \
} while(0)
void glWindowPos2fvMESA(glWindowPos2fvMESA_ARG_EXPAND);
typedef void (*glWindowPos2fvMESA_PTR)(glWindowPos2fvMESA_ARG_EXPAND);
#define glWindowPos2i_INDEX 2659
#define glWindowPos2i_RETURN void
#define glWindowPos2i_ARG_NAMES x, y
#define glWindowPos2i_ARG_EXPAND GLint x, GLint y
#define glWindowPos2i_PACKED PACKED_glWindowPos2i
#define glWindowPos2i_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glWindowPos2i_NOT_VOID_WRAP(...) {}
#define pack_glWindowPos2i(_x, _y) ({ \
    glWindowPos2i_PACKED *packed_data = malloc(sizeof(glWindowPos2i_PACKED)); \
    packed_data->index = glWindowPos2i_INDEX; \
    packed_data->args.x = (GLint)_x; \
    packed_data->args.y = (GLint)_y; \
    (packed_call_t *)packed_data; \
})
#define call_glWindowPos2i(packed, ret_v) do { \
    PACKED_glWindowPos2i *unpacked = (PACKED_glWindowPos2i *)packed; \
    ARGS_glWindowPos2i *args = (ARGS_glWindowPos2i *)&unpacked->args; \
    glWindowPos2i(args->x, args->y);; \
} while(0)
void glWindowPos2i(glWindowPos2i_ARG_EXPAND);
typedef void (*glWindowPos2i_PTR)(glWindowPos2i_ARG_EXPAND);
#define glWindowPos2iARB_INDEX 2660
#define glWindowPos2iARB_RETURN void
#define glWindowPos2iARB_ARG_NAMES x, y
#define glWindowPos2iARB_ARG_EXPAND GLint x, GLint y
#define glWindowPos2iARB_PACKED PACKED_glWindowPos2iARB
#define glWindowPos2iARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glWindowPos2iARB_NOT_VOID_WRAP(...) {}
#define pack_glWindowPos2iARB(_x, _y) ({ \
    glWindowPos2iARB_PACKED *packed_data = malloc(sizeof(glWindowPos2iARB_PACKED)); \
    packed_data->index = glWindowPos2iARB_INDEX; \
    packed_data->args.x = (GLint)_x; \
    packed_data->args.y = (GLint)_y; \
    (packed_call_t *)packed_data; \
})
#define call_glWindowPos2iARB(packed, ret_v) do { \
    PACKED_glWindowPos2iARB *unpacked = (PACKED_glWindowPos2iARB *)packed; \
    ARGS_glWindowPos2iARB *args = (ARGS_glWindowPos2iARB *)&unpacked->args; \
    glWindowPos2iARB(args->x, args->y);; \
} while(0)
void glWindowPos2iARB(glWindowPos2iARB_ARG_EXPAND);
typedef void (*glWindowPos2iARB_PTR)(glWindowPos2iARB_ARG_EXPAND);
#define glWindowPos2iMESA_INDEX 2661
#define glWindowPos2iMESA_RETURN void
#define glWindowPos2iMESA_ARG_NAMES x, y
#define glWindowPos2iMESA_ARG_EXPAND GLint x, GLint y
#define glWindowPos2iMESA_PACKED PACKED_glWindowPos2iMESA
#define glWindowPos2iMESA_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glWindowPos2iMESA_NOT_VOID_WRAP(...) {}
#define pack_glWindowPos2iMESA(_x, _y) ({ \
    glWindowPos2iMESA_PACKED *packed_data = malloc(sizeof(glWindowPos2iMESA_PACKED)); \
    packed_data->index = glWindowPos2iMESA_INDEX; \
    packed_data->args.x = (GLint)_x; \
    packed_data->args.y = (GLint)_y; \
    (packed_call_t *)packed_data; \
})
#define call_glWindowPos2iMESA(packed, ret_v) do { \
    PACKED_glWindowPos2iMESA *unpacked = (PACKED_glWindowPos2iMESA *)packed; \
    ARGS_glWindowPos2iMESA *args = (ARGS_glWindowPos2iMESA *)&unpacked->args; \
    glWindowPos2iMESA(args->x, args->y);; \
} while(0)
void glWindowPos2iMESA(glWindowPos2iMESA_ARG_EXPAND);
typedef void (*glWindowPos2iMESA_PTR)(glWindowPos2iMESA_ARG_EXPAND);
#define glWindowPos2iv_INDEX 2662
#define glWindowPos2iv_RETURN void
#define glWindowPos2iv_ARG_NAMES v
#define glWindowPos2iv_ARG_EXPAND const GLint * v
#define glWindowPos2iv_PACKED PACKED_glWindowPos2iv
#define glWindowPos2iv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glWindowPos2iv_NOT_VOID_WRAP(...) {}
#define pack_glWindowPos2iv(_v) ({ \
    glWindowPos2iv_PACKED *packed_data = malloc(sizeof(glWindowPos2iv_PACKED)); \
    packed_data->index = glWindowPos2iv_INDEX; \
    packed_data->args.v = (GLint *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glWindowPos2iv(packed, ret_v) do { \
    PACKED_glWindowPos2iv *unpacked = (PACKED_glWindowPos2iv *)packed; \
    ARGS_glWindowPos2iv *args = (ARGS_glWindowPos2iv *)&unpacked->args; \
    glWindowPos2iv(args->v);; \
} while(0)
void glWindowPos2iv(glWindowPos2iv_ARG_EXPAND);
typedef void (*glWindowPos2iv_PTR)(glWindowPos2iv_ARG_EXPAND);
#define glWindowPos2ivARB_INDEX 2663
#define glWindowPos2ivARB_RETURN void
#define glWindowPos2ivARB_ARG_NAMES v
#define glWindowPos2ivARB_ARG_EXPAND const GLint * v
#define glWindowPos2ivARB_PACKED PACKED_glWindowPos2ivARB
#define glWindowPos2ivARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glWindowPos2ivARB_NOT_VOID_WRAP(...) {}
#define pack_glWindowPos2ivARB(_v) ({ \
    glWindowPos2ivARB_PACKED *packed_data = malloc(sizeof(glWindowPos2ivARB_PACKED)); \
    packed_data->index = glWindowPos2ivARB_INDEX; \
    packed_data->args.v = (GLint *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glWindowPos2ivARB(packed, ret_v) do { \
    PACKED_glWindowPos2ivARB *unpacked = (PACKED_glWindowPos2ivARB *)packed; \
    ARGS_glWindowPos2ivARB *args = (ARGS_glWindowPos2ivARB *)&unpacked->args; \
    glWindowPos2ivARB(args->v);; \
} while(0)
void glWindowPos2ivARB(glWindowPos2ivARB_ARG_EXPAND);
typedef void (*glWindowPos2ivARB_PTR)(glWindowPos2ivARB_ARG_EXPAND);
#define glWindowPos2ivMESA_INDEX 2664
#define glWindowPos2ivMESA_RETURN void
#define glWindowPos2ivMESA_ARG_NAMES v
#define glWindowPos2ivMESA_ARG_EXPAND const GLint * v
#define glWindowPos2ivMESA_PACKED PACKED_glWindowPos2ivMESA
#define glWindowPos2ivMESA_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glWindowPos2ivMESA_NOT_VOID_WRAP(...) {}
#define pack_glWindowPos2ivMESA(_v) ({ \
    glWindowPos2ivMESA_PACKED *packed_data = malloc(sizeof(glWindowPos2ivMESA_PACKED)); \
    packed_data->index = glWindowPos2ivMESA_INDEX; \
    packed_data->args.v = (GLint *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glWindowPos2ivMESA(packed, ret_v) do { \
    PACKED_glWindowPos2ivMESA *unpacked = (PACKED_glWindowPos2ivMESA *)packed; \
    ARGS_glWindowPos2ivMESA *args = (ARGS_glWindowPos2ivMESA *)&unpacked->args; \
    glWindowPos2ivMESA(args->v);; \
} while(0)
void glWindowPos2ivMESA(glWindowPos2ivMESA_ARG_EXPAND);
typedef void (*glWindowPos2ivMESA_PTR)(glWindowPos2ivMESA_ARG_EXPAND);
#define glWindowPos2s_INDEX 2665
#define glWindowPos2s_RETURN void
#define glWindowPos2s_ARG_NAMES x, y
#define glWindowPos2s_ARG_EXPAND GLshort x, GLshort y
#define glWindowPos2s_PACKED PACKED_glWindowPos2s
#define glWindowPos2s_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glWindowPos2s_NOT_VOID_WRAP(...) {}
#define pack_glWindowPos2s(_x, _y) ({ \
    glWindowPos2s_PACKED *packed_data = malloc(sizeof(glWindowPos2s_PACKED)); \
    packed_data->index = glWindowPos2s_INDEX; \
    packed_data->args.x = (GLshort)_x; \
    packed_data->args.y = (GLshort)_y; \
    (packed_call_t *)packed_data; \
})
#define call_glWindowPos2s(packed, ret_v) do { \
    PACKED_glWindowPos2s *unpacked = (PACKED_glWindowPos2s *)packed; \
    ARGS_glWindowPos2s *args = (ARGS_glWindowPos2s *)&unpacked->args; \
    glWindowPos2s(args->x, args->y);; \
} while(0)
void glWindowPos2s(glWindowPos2s_ARG_EXPAND);
typedef void (*glWindowPos2s_PTR)(glWindowPos2s_ARG_EXPAND);
#define glWindowPos2sARB_INDEX 2666
#define glWindowPos2sARB_RETURN void
#define glWindowPos2sARB_ARG_NAMES x, y
#define glWindowPos2sARB_ARG_EXPAND GLshort x, GLshort y
#define glWindowPos2sARB_PACKED PACKED_glWindowPos2sARB
#define glWindowPos2sARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glWindowPos2sARB_NOT_VOID_WRAP(...) {}
#define pack_glWindowPos2sARB(_x, _y) ({ \
    glWindowPos2sARB_PACKED *packed_data = malloc(sizeof(glWindowPos2sARB_PACKED)); \
    packed_data->index = glWindowPos2sARB_INDEX; \
    packed_data->args.x = (GLshort)_x; \
    packed_data->args.y = (GLshort)_y; \
    (packed_call_t *)packed_data; \
})
#define call_glWindowPos2sARB(packed, ret_v) do { \
    PACKED_glWindowPos2sARB *unpacked = (PACKED_glWindowPos2sARB *)packed; \
    ARGS_glWindowPos2sARB *args = (ARGS_glWindowPos2sARB *)&unpacked->args; \
    glWindowPos2sARB(args->x, args->y);; \
} while(0)
void glWindowPos2sARB(glWindowPos2sARB_ARG_EXPAND);
typedef void (*glWindowPos2sARB_PTR)(glWindowPos2sARB_ARG_EXPAND);
#define glWindowPos2sMESA_INDEX 2667
#define glWindowPos2sMESA_RETURN void
#define glWindowPos2sMESA_ARG_NAMES x, y
#define glWindowPos2sMESA_ARG_EXPAND GLshort x, GLshort y
#define glWindowPos2sMESA_PACKED PACKED_glWindowPos2sMESA
#define glWindowPos2sMESA_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glWindowPos2sMESA_NOT_VOID_WRAP(...) {}
#define pack_glWindowPos2sMESA(_x, _y) ({ \
    glWindowPos2sMESA_PACKED *packed_data = malloc(sizeof(glWindowPos2sMESA_PACKED)); \
    packed_data->index = glWindowPos2sMESA_INDEX; \
    packed_data->args.x = (GLshort)_x; \
    packed_data->args.y = (GLshort)_y; \
    (packed_call_t *)packed_data; \
})
#define call_glWindowPos2sMESA(packed, ret_v) do { \
    PACKED_glWindowPos2sMESA *unpacked = (PACKED_glWindowPos2sMESA *)packed; \
    ARGS_glWindowPos2sMESA *args = (ARGS_glWindowPos2sMESA *)&unpacked->args; \
    glWindowPos2sMESA(args->x, args->y);; \
} while(0)
void glWindowPos2sMESA(glWindowPos2sMESA_ARG_EXPAND);
typedef void (*glWindowPos2sMESA_PTR)(glWindowPos2sMESA_ARG_EXPAND);
#define glWindowPos2sv_INDEX 2668
#define glWindowPos2sv_RETURN void
#define glWindowPos2sv_ARG_NAMES v
#define glWindowPos2sv_ARG_EXPAND const GLshort * v
#define glWindowPos2sv_PACKED PACKED_glWindowPos2sv
#define glWindowPos2sv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glWindowPos2sv_NOT_VOID_WRAP(...) {}
#define pack_glWindowPos2sv(_v) ({ \
    glWindowPos2sv_PACKED *packed_data = malloc(sizeof(glWindowPos2sv_PACKED)); \
    packed_data->index = glWindowPos2sv_INDEX; \
    packed_data->args.v = (GLshort *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glWindowPos2sv(packed, ret_v) do { \
    PACKED_glWindowPos2sv *unpacked = (PACKED_glWindowPos2sv *)packed; \
    ARGS_glWindowPos2sv *args = (ARGS_glWindowPos2sv *)&unpacked->args; \
    glWindowPos2sv(args->v);; \
} while(0)
void glWindowPos2sv(glWindowPos2sv_ARG_EXPAND);
typedef void (*glWindowPos2sv_PTR)(glWindowPos2sv_ARG_EXPAND);
#define glWindowPos2svARB_INDEX 2669
#define glWindowPos2svARB_RETURN void
#define glWindowPos2svARB_ARG_NAMES v
#define glWindowPos2svARB_ARG_EXPAND const GLshort * v
#define glWindowPos2svARB_PACKED PACKED_glWindowPos2svARB
#define glWindowPos2svARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glWindowPos2svARB_NOT_VOID_WRAP(...) {}
#define pack_glWindowPos2svARB(_v) ({ \
    glWindowPos2svARB_PACKED *packed_data = malloc(sizeof(glWindowPos2svARB_PACKED)); \
    packed_data->index = glWindowPos2svARB_INDEX; \
    packed_data->args.v = (GLshort *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glWindowPos2svARB(packed, ret_v) do { \
    PACKED_glWindowPos2svARB *unpacked = (PACKED_glWindowPos2svARB *)packed; \
    ARGS_glWindowPos2svARB *args = (ARGS_glWindowPos2svARB *)&unpacked->args; \
    glWindowPos2svARB(args->v);; \
} while(0)
void glWindowPos2svARB(glWindowPos2svARB_ARG_EXPAND);
typedef void (*glWindowPos2svARB_PTR)(glWindowPos2svARB_ARG_EXPAND);
#define glWindowPos2svMESA_INDEX 2670
#define glWindowPos2svMESA_RETURN void
#define glWindowPos2svMESA_ARG_NAMES v
#define glWindowPos2svMESA_ARG_EXPAND const GLshort * v
#define glWindowPos2svMESA_PACKED PACKED_glWindowPos2svMESA
#define glWindowPos2svMESA_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glWindowPos2svMESA_NOT_VOID_WRAP(...) {}
#define pack_glWindowPos2svMESA(_v) ({ \
    glWindowPos2svMESA_PACKED *packed_data = malloc(sizeof(glWindowPos2svMESA_PACKED)); \
    packed_data->index = glWindowPos2svMESA_INDEX; \
    packed_data->args.v = (GLshort *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glWindowPos2svMESA(packed, ret_v) do { \
    PACKED_glWindowPos2svMESA *unpacked = (PACKED_glWindowPos2svMESA *)packed; \
    ARGS_glWindowPos2svMESA *args = (ARGS_glWindowPos2svMESA *)&unpacked->args; \
    glWindowPos2svMESA(args->v);; \
} while(0)
void glWindowPos2svMESA(glWindowPos2svMESA_ARG_EXPAND);
typedef void (*glWindowPos2svMESA_PTR)(glWindowPos2svMESA_ARG_EXPAND);
#define glWindowPos3d_INDEX 2671
#define glWindowPos3d_RETURN void
#define glWindowPos3d_ARG_NAMES x, y, z
#define glWindowPos3d_ARG_EXPAND GLdouble x, GLdouble y, GLdouble z
#define glWindowPos3d_PACKED PACKED_glWindowPos3d
#define glWindowPos3d_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glWindowPos3d_NOT_VOID_WRAP(...) {}
#define pack_glWindowPos3d(_x, _y, _z) ({ \
    glWindowPos3d_PACKED *packed_data = malloc(sizeof(glWindowPos3d_PACKED)); \
    packed_data->index = glWindowPos3d_INDEX; \
    packed_data->args.x = (GLdouble)_x; \
    packed_data->args.y = (GLdouble)_y; \
    packed_data->args.z = (GLdouble)_z; \
    (packed_call_t *)packed_data; \
})
#define call_glWindowPos3d(packed, ret_v) do { \
    PACKED_glWindowPos3d *unpacked = (PACKED_glWindowPos3d *)packed; \
    ARGS_glWindowPos3d *args = (ARGS_glWindowPos3d *)&unpacked->args; \
    glWindowPos3d(args->x, args->y, args->z);; \
} while(0)
void glWindowPos3d(glWindowPos3d_ARG_EXPAND);
typedef void (*glWindowPos3d_PTR)(glWindowPos3d_ARG_EXPAND);
#define glWindowPos3dARB_INDEX 2672
#define glWindowPos3dARB_RETURN void
#define glWindowPos3dARB_ARG_NAMES x, y, z
#define glWindowPos3dARB_ARG_EXPAND GLdouble x, GLdouble y, GLdouble z
#define glWindowPos3dARB_PACKED PACKED_glWindowPos3dARB
#define glWindowPos3dARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glWindowPos3dARB_NOT_VOID_WRAP(...) {}
#define pack_glWindowPos3dARB(_x, _y, _z) ({ \
    glWindowPos3dARB_PACKED *packed_data = malloc(sizeof(glWindowPos3dARB_PACKED)); \
    packed_data->index = glWindowPos3dARB_INDEX; \
    packed_data->args.x = (GLdouble)_x; \
    packed_data->args.y = (GLdouble)_y; \
    packed_data->args.z = (GLdouble)_z; \
    (packed_call_t *)packed_data; \
})
#define call_glWindowPos3dARB(packed, ret_v) do { \
    PACKED_glWindowPos3dARB *unpacked = (PACKED_glWindowPos3dARB *)packed; \
    ARGS_glWindowPos3dARB *args = (ARGS_glWindowPos3dARB *)&unpacked->args; \
    glWindowPos3dARB(args->x, args->y, args->z);; \
} while(0)
void glWindowPos3dARB(glWindowPos3dARB_ARG_EXPAND);
typedef void (*glWindowPos3dARB_PTR)(glWindowPos3dARB_ARG_EXPAND);
#define glWindowPos3dMESA_INDEX 2673
#define glWindowPos3dMESA_RETURN void
#define glWindowPos3dMESA_ARG_NAMES x, y, z
#define glWindowPos3dMESA_ARG_EXPAND GLdouble x, GLdouble y, GLdouble z
#define glWindowPos3dMESA_PACKED PACKED_glWindowPos3dMESA
#define glWindowPos3dMESA_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glWindowPos3dMESA_NOT_VOID_WRAP(...) {}
#define pack_glWindowPos3dMESA(_x, _y, _z) ({ \
    glWindowPos3dMESA_PACKED *packed_data = malloc(sizeof(glWindowPos3dMESA_PACKED)); \
    packed_data->index = glWindowPos3dMESA_INDEX; \
    packed_data->args.x = (GLdouble)_x; \
    packed_data->args.y = (GLdouble)_y; \
    packed_data->args.z = (GLdouble)_z; \
    (packed_call_t *)packed_data; \
})
#define call_glWindowPos3dMESA(packed, ret_v) do { \
    PACKED_glWindowPos3dMESA *unpacked = (PACKED_glWindowPos3dMESA *)packed; \
    ARGS_glWindowPos3dMESA *args = (ARGS_glWindowPos3dMESA *)&unpacked->args; \
    glWindowPos3dMESA(args->x, args->y, args->z);; \
} while(0)
void glWindowPos3dMESA(glWindowPos3dMESA_ARG_EXPAND);
typedef void (*glWindowPos3dMESA_PTR)(glWindowPos3dMESA_ARG_EXPAND);
#define glWindowPos3dv_INDEX 2674
#define glWindowPos3dv_RETURN void
#define glWindowPos3dv_ARG_NAMES v
#define glWindowPos3dv_ARG_EXPAND const GLdouble * v
#define glWindowPos3dv_PACKED PACKED_glWindowPos3dv
#define glWindowPos3dv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glWindowPos3dv_NOT_VOID_WRAP(...) {}
#define pack_glWindowPos3dv(_v) ({ \
    glWindowPos3dv_PACKED *packed_data = malloc(sizeof(glWindowPos3dv_PACKED)); \
    packed_data->index = glWindowPos3dv_INDEX; \
    packed_data->args.v = (GLdouble *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glWindowPos3dv(packed, ret_v) do { \
    PACKED_glWindowPos3dv *unpacked = (PACKED_glWindowPos3dv *)packed; \
    ARGS_glWindowPos3dv *args = (ARGS_glWindowPos3dv *)&unpacked->args; \
    glWindowPos3dv(args->v);; \
} while(0)
void glWindowPos3dv(glWindowPos3dv_ARG_EXPAND);
typedef void (*glWindowPos3dv_PTR)(glWindowPos3dv_ARG_EXPAND);
#define glWindowPos3dvARB_INDEX 2675
#define glWindowPos3dvARB_RETURN void
#define glWindowPos3dvARB_ARG_NAMES v
#define glWindowPos3dvARB_ARG_EXPAND const GLdouble * v
#define glWindowPos3dvARB_PACKED PACKED_glWindowPos3dvARB
#define glWindowPos3dvARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glWindowPos3dvARB_NOT_VOID_WRAP(...) {}
#define pack_glWindowPos3dvARB(_v) ({ \
    glWindowPos3dvARB_PACKED *packed_data = malloc(sizeof(glWindowPos3dvARB_PACKED)); \
    packed_data->index = glWindowPos3dvARB_INDEX; \
    packed_data->args.v = (GLdouble *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glWindowPos3dvARB(packed, ret_v) do { \
    PACKED_glWindowPos3dvARB *unpacked = (PACKED_glWindowPos3dvARB *)packed; \
    ARGS_glWindowPos3dvARB *args = (ARGS_glWindowPos3dvARB *)&unpacked->args; \
    glWindowPos3dvARB(args->v);; \
} while(0)
void glWindowPos3dvARB(glWindowPos3dvARB_ARG_EXPAND);
typedef void (*glWindowPos3dvARB_PTR)(glWindowPos3dvARB_ARG_EXPAND);
#define glWindowPos3dvMESA_INDEX 2676
#define glWindowPos3dvMESA_RETURN void
#define glWindowPos3dvMESA_ARG_NAMES v
#define glWindowPos3dvMESA_ARG_EXPAND const GLdouble * v
#define glWindowPos3dvMESA_PACKED PACKED_glWindowPos3dvMESA
#define glWindowPos3dvMESA_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glWindowPos3dvMESA_NOT_VOID_WRAP(...) {}
#define pack_glWindowPos3dvMESA(_v) ({ \
    glWindowPos3dvMESA_PACKED *packed_data = malloc(sizeof(glWindowPos3dvMESA_PACKED)); \
    packed_data->index = glWindowPos3dvMESA_INDEX; \
    packed_data->args.v = (GLdouble *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glWindowPos3dvMESA(packed, ret_v) do { \
    PACKED_glWindowPos3dvMESA *unpacked = (PACKED_glWindowPos3dvMESA *)packed; \
    ARGS_glWindowPos3dvMESA *args = (ARGS_glWindowPos3dvMESA *)&unpacked->args; \
    glWindowPos3dvMESA(args->v);; \
} while(0)
void glWindowPos3dvMESA(glWindowPos3dvMESA_ARG_EXPAND);
typedef void (*glWindowPos3dvMESA_PTR)(glWindowPos3dvMESA_ARG_EXPAND);
#define glWindowPos3f_INDEX 2677
#define glWindowPos3f_RETURN void
#define glWindowPos3f_ARG_NAMES x, y, z
#define glWindowPos3f_ARG_EXPAND GLfloat x, GLfloat y, GLfloat z
#define glWindowPos3f_PACKED PACKED_glWindowPos3f
#define glWindowPos3f_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glWindowPos3f_NOT_VOID_WRAP(...) {}
#define pack_glWindowPos3f(_x, _y, _z) ({ \
    glWindowPos3f_PACKED *packed_data = malloc(sizeof(glWindowPos3f_PACKED)); \
    packed_data->index = glWindowPos3f_INDEX; \
    packed_data->args.x = (GLfloat)_x; \
    packed_data->args.y = (GLfloat)_y; \
    packed_data->args.z = (GLfloat)_z; \
    (packed_call_t *)packed_data; \
})
#define call_glWindowPos3f(packed, ret_v) do { \
    PACKED_glWindowPos3f *unpacked = (PACKED_glWindowPos3f *)packed; \
    ARGS_glWindowPos3f *args = (ARGS_glWindowPos3f *)&unpacked->args; \
    glWindowPos3f(args->x, args->y, args->z);; \
} while(0)
void glWindowPos3f(glWindowPos3f_ARG_EXPAND);
typedef void (*glWindowPos3f_PTR)(glWindowPos3f_ARG_EXPAND);
#define glWindowPos3fARB_INDEX 2678
#define glWindowPos3fARB_RETURN void
#define glWindowPos3fARB_ARG_NAMES x, y, z
#define glWindowPos3fARB_ARG_EXPAND GLfloat x, GLfloat y, GLfloat z
#define glWindowPos3fARB_PACKED PACKED_glWindowPos3fARB
#define glWindowPos3fARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glWindowPos3fARB_NOT_VOID_WRAP(...) {}
#define pack_glWindowPos3fARB(_x, _y, _z) ({ \
    glWindowPos3fARB_PACKED *packed_data = malloc(sizeof(glWindowPos3fARB_PACKED)); \
    packed_data->index = glWindowPos3fARB_INDEX; \
    packed_data->args.x = (GLfloat)_x; \
    packed_data->args.y = (GLfloat)_y; \
    packed_data->args.z = (GLfloat)_z; \
    (packed_call_t *)packed_data; \
})
#define call_glWindowPos3fARB(packed, ret_v) do { \
    PACKED_glWindowPos3fARB *unpacked = (PACKED_glWindowPos3fARB *)packed; \
    ARGS_glWindowPos3fARB *args = (ARGS_glWindowPos3fARB *)&unpacked->args; \
    glWindowPos3fARB(args->x, args->y, args->z);; \
} while(0)
void glWindowPos3fARB(glWindowPos3fARB_ARG_EXPAND);
typedef void (*glWindowPos3fARB_PTR)(glWindowPos3fARB_ARG_EXPAND);
#define glWindowPos3fMESA_INDEX 2679
#define glWindowPos3fMESA_RETURN void
#define glWindowPos3fMESA_ARG_NAMES x, y, z
#define glWindowPos3fMESA_ARG_EXPAND GLfloat x, GLfloat y, GLfloat z
#define glWindowPos3fMESA_PACKED PACKED_glWindowPos3fMESA
#define glWindowPos3fMESA_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glWindowPos3fMESA_NOT_VOID_WRAP(...) {}
#define pack_glWindowPos3fMESA(_x, _y, _z) ({ \
    glWindowPos3fMESA_PACKED *packed_data = malloc(sizeof(glWindowPos3fMESA_PACKED)); \
    packed_data->index = glWindowPos3fMESA_INDEX; \
    packed_data->args.x = (GLfloat)_x; \
    packed_data->args.y = (GLfloat)_y; \
    packed_data->args.z = (GLfloat)_z; \
    (packed_call_t *)packed_data; \
})
#define call_glWindowPos3fMESA(packed, ret_v) do { \
    PACKED_glWindowPos3fMESA *unpacked = (PACKED_glWindowPos3fMESA *)packed; \
    ARGS_glWindowPos3fMESA *args = (ARGS_glWindowPos3fMESA *)&unpacked->args; \
    glWindowPos3fMESA(args->x, args->y, args->z);; \
} while(0)
void glWindowPos3fMESA(glWindowPos3fMESA_ARG_EXPAND);
typedef void (*glWindowPos3fMESA_PTR)(glWindowPos3fMESA_ARG_EXPAND);
#define glWindowPos3fv_INDEX 2680
#define glWindowPos3fv_RETURN void
#define glWindowPos3fv_ARG_NAMES v
#define glWindowPos3fv_ARG_EXPAND const GLfloat * v
#define glWindowPos3fv_PACKED PACKED_glWindowPos3fv
#define glWindowPos3fv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glWindowPos3fv_NOT_VOID_WRAP(...) {}
#define pack_glWindowPos3fv(_v) ({ \
    glWindowPos3fv_PACKED *packed_data = malloc(sizeof(glWindowPos3fv_PACKED)); \
    packed_data->index = glWindowPos3fv_INDEX; \
    packed_data->args.v = (GLfloat *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glWindowPos3fv(packed, ret_v) do { \
    PACKED_glWindowPos3fv *unpacked = (PACKED_glWindowPos3fv *)packed; \
    ARGS_glWindowPos3fv *args = (ARGS_glWindowPos3fv *)&unpacked->args; \
    glWindowPos3fv(args->v);; \
} while(0)
void glWindowPos3fv(glWindowPos3fv_ARG_EXPAND);
typedef void (*glWindowPos3fv_PTR)(glWindowPos3fv_ARG_EXPAND);
#define glWindowPos3fvARB_INDEX 2681
#define glWindowPos3fvARB_RETURN void
#define glWindowPos3fvARB_ARG_NAMES v
#define glWindowPos3fvARB_ARG_EXPAND const GLfloat * v
#define glWindowPos3fvARB_PACKED PACKED_glWindowPos3fvARB
#define glWindowPos3fvARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glWindowPos3fvARB_NOT_VOID_WRAP(...) {}
#define pack_glWindowPos3fvARB(_v) ({ \
    glWindowPos3fvARB_PACKED *packed_data = malloc(sizeof(glWindowPos3fvARB_PACKED)); \
    packed_data->index = glWindowPos3fvARB_INDEX; \
    packed_data->args.v = (GLfloat *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glWindowPos3fvARB(packed, ret_v) do { \
    PACKED_glWindowPos3fvARB *unpacked = (PACKED_glWindowPos3fvARB *)packed; \
    ARGS_glWindowPos3fvARB *args = (ARGS_glWindowPos3fvARB *)&unpacked->args; \
    glWindowPos3fvARB(args->v);; \
} while(0)
void glWindowPos3fvARB(glWindowPos3fvARB_ARG_EXPAND);
typedef void (*glWindowPos3fvARB_PTR)(glWindowPos3fvARB_ARG_EXPAND);
#define glWindowPos3fvMESA_INDEX 2682
#define glWindowPos3fvMESA_RETURN void
#define glWindowPos3fvMESA_ARG_NAMES v
#define glWindowPos3fvMESA_ARG_EXPAND const GLfloat * v
#define glWindowPos3fvMESA_PACKED PACKED_glWindowPos3fvMESA
#define glWindowPos3fvMESA_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glWindowPos3fvMESA_NOT_VOID_WRAP(...) {}
#define pack_glWindowPos3fvMESA(_v) ({ \
    glWindowPos3fvMESA_PACKED *packed_data = malloc(sizeof(glWindowPos3fvMESA_PACKED)); \
    packed_data->index = glWindowPos3fvMESA_INDEX; \
    packed_data->args.v = (GLfloat *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glWindowPos3fvMESA(packed, ret_v) do { \
    PACKED_glWindowPos3fvMESA *unpacked = (PACKED_glWindowPos3fvMESA *)packed; \
    ARGS_glWindowPos3fvMESA *args = (ARGS_glWindowPos3fvMESA *)&unpacked->args; \
    glWindowPos3fvMESA(args->v);; \
} while(0)
void glWindowPos3fvMESA(glWindowPos3fvMESA_ARG_EXPAND);
typedef void (*glWindowPos3fvMESA_PTR)(glWindowPos3fvMESA_ARG_EXPAND);
#define glWindowPos3i_INDEX 2683
#define glWindowPos3i_RETURN void
#define glWindowPos3i_ARG_NAMES x, y, z
#define glWindowPos3i_ARG_EXPAND GLint x, GLint y, GLint z
#define glWindowPos3i_PACKED PACKED_glWindowPos3i
#define glWindowPos3i_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glWindowPos3i_NOT_VOID_WRAP(...) {}
#define pack_glWindowPos3i(_x, _y, _z) ({ \
    glWindowPos3i_PACKED *packed_data = malloc(sizeof(glWindowPos3i_PACKED)); \
    packed_data->index = glWindowPos3i_INDEX; \
    packed_data->args.x = (GLint)_x; \
    packed_data->args.y = (GLint)_y; \
    packed_data->args.z = (GLint)_z; \
    (packed_call_t *)packed_data; \
})
#define call_glWindowPos3i(packed, ret_v) do { \
    PACKED_glWindowPos3i *unpacked = (PACKED_glWindowPos3i *)packed; \
    ARGS_glWindowPos3i *args = (ARGS_glWindowPos3i *)&unpacked->args; \
    glWindowPos3i(args->x, args->y, args->z);; \
} while(0)
void glWindowPos3i(glWindowPos3i_ARG_EXPAND);
typedef void (*glWindowPos3i_PTR)(glWindowPos3i_ARG_EXPAND);
#define glWindowPos3iARB_INDEX 2684
#define glWindowPos3iARB_RETURN void
#define glWindowPos3iARB_ARG_NAMES x, y, z
#define glWindowPos3iARB_ARG_EXPAND GLint x, GLint y, GLint z
#define glWindowPos3iARB_PACKED PACKED_glWindowPos3iARB
#define glWindowPos3iARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glWindowPos3iARB_NOT_VOID_WRAP(...) {}
#define pack_glWindowPos3iARB(_x, _y, _z) ({ \
    glWindowPos3iARB_PACKED *packed_data = malloc(sizeof(glWindowPos3iARB_PACKED)); \
    packed_data->index = glWindowPos3iARB_INDEX; \
    packed_data->args.x = (GLint)_x; \
    packed_data->args.y = (GLint)_y; \
    packed_data->args.z = (GLint)_z; \
    (packed_call_t *)packed_data; \
})
#define call_glWindowPos3iARB(packed, ret_v) do { \
    PACKED_glWindowPos3iARB *unpacked = (PACKED_glWindowPos3iARB *)packed; \
    ARGS_glWindowPos3iARB *args = (ARGS_glWindowPos3iARB *)&unpacked->args; \
    glWindowPos3iARB(args->x, args->y, args->z);; \
} while(0)
void glWindowPos3iARB(glWindowPos3iARB_ARG_EXPAND);
typedef void (*glWindowPos3iARB_PTR)(glWindowPos3iARB_ARG_EXPAND);
#define glWindowPos3iMESA_INDEX 2685
#define glWindowPos3iMESA_RETURN void
#define glWindowPos3iMESA_ARG_NAMES x, y, z
#define glWindowPos3iMESA_ARG_EXPAND GLint x, GLint y, GLint z
#define glWindowPos3iMESA_PACKED PACKED_glWindowPos3iMESA
#define glWindowPos3iMESA_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glWindowPos3iMESA_NOT_VOID_WRAP(...) {}
#define pack_glWindowPos3iMESA(_x, _y, _z) ({ \
    glWindowPos3iMESA_PACKED *packed_data = malloc(sizeof(glWindowPos3iMESA_PACKED)); \
    packed_data->index = glWindowPos3iMESA_INDEX; \
    packed_data->args.x = (GLint)_x; \
    packed_data->args.y = (GLint)_y; \
    packed_data->args.z = (GLint)_z; \
    (packed_call_t *)packed_data; \
})
#define call_glWindowPos3iMESA(packed, ret_v) do { \
    PACKED_glWindowPos3iMESA *unpacked = (PACKED_glWindowPos3iMESA *)packed; \
    ARGS_glWindowPos3iMESA *args = (ARGS_glWindowPos3iMESA *)&unpacked->args; \
    glWindowPos3iMESA(args->x, args->y, args->z);; \
} while(0)
void glWindowPos3iMESA(glWindowPos3iMESA_ARG_EXPAND);
typedef void (*glWindowPos3iMESA_PTR)(glWindowPos3iMESA_ARG_EXPAND);
#define glWindowPos3iv_INDEX 2686
#define glWindowPos3iv_RETURN void
#define glWindowPos3iv_ARG_NAMES v
#define glWindowPos3iv_ARG_EXPAND const GLint * v
#define glWindowPos3iv_PACKED PACKED_glWindowPos3iv
#define glWindowPos3iv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glWindowPos3iv_NOT_VOID_WRAP(...) {}
#define pack_glWindowPos3iv(_v) ({ \
    glWindowPos3iv_PACKED *packed_data = malloc(sizeof(glWindowPos3iv_PACKED)); \
    packed_data->index = glWindowPos3iv_INDEX; \
    packed_data->args.v = (GLint *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glWindowPos3iv(packed, ret_v) do { \
    PACKED_glWindowPos3iv *unpacked = (PACKED_glWindowPos3iv *)packed; \
    ARGS_glWindowPos3iv *args = (ARGS_glWindowPos3iv *)&unpacked->args; \
    glWindowPos3iv(args->v);; \
} while(0)
void glWindowPos3iv(glWindowPos3iv_ARG_EXPAND);
typedef void (*glWindowPos3iv_PTR)(glWindowPos3iv_ARG_EXPAND);
#define glWindowPos3ivARB_INDEX 2687
#define glWindowPos3ivARB_RETURN void
#define glWindowPos3ivARB_ARG_NAMES v
#define glWindowPos3ivARB_ARG_EXPAND const GLint * v
#define glWindowPos3ivARB_PACKED PACKED_glWindowPos3ivARB
#define glWindowPos3ivARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glWindowPos3ivARB_NOT_VOID_WRAP(...) {}
#define pack_glWindowPos3ivARB(_v) ({ \
    glWindowPos3ivARB_PACKED *packed_data = malloc(sizeof(glWindowPos3ivARB_PACKED)); \
    packed_data->index = glWindowPos3ivARB_INDEX; \
    packed_data->args.v = (GLint *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glWindowPos3ivARB(packed, ret_v) do { \
    PACKED_glWindowPos3ivARB *unpacked = (PACKED_glWindowPos3ivARB *)packed; \
    ARGS_glWindowPos3ivARB *args = (ARGS_glWindowPos3ivARB *)&unpacked->args; \
    glWindowPos3ivARB(args->v);; \
} while(0)
void glWindowPos3ivARB(glWindowPos3ivARB_ARG_EXPAND);
typedef void (*glWindowPos3ivARB_PTR)(glWindowPos3ivARB_ARG_EXPAND);
#define glWindowPos3ivMESA_INDEX 2688
#define glWindowPos3ivMESA_RETURN void
#define glWindowPos3ivMESA_ARG_NAMES v
#define glWindowPos3ivMESA_ARG_EXPAND const GLint * v
#define glWindowPos3ivMESA_PACKED PACKED_glWindowPos3ivMESA
#define glWindowPos3ivMESA_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glWindowPos3ivMESA_NOT_VOID_WRAP(...) {}
#define pack_glWindowPos3ivMESA(_v) ({ \
    glWindowPos3ivMESA_PACKED *packed_data = malloc(sizeof(glWindowPos3ivMESA_PACKED)); \
    packed_data->index = glWindowPos3ivMESA_INDEX; \
    packed_data->args.v = (GLint *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glWindowPos3ivMESA(packed, ret_v) do { \
    PACKED_glWindowPos3ivMESA *unpacked = (PACKED_glWindowPos3ivMESA *)packed; \
    ARGS_glWindowPos3ivMESA *args = (ARGS_glWindowPos3ivMESA *)&unpacked->args; \
    glWindowPos3ivMESA(args->v);; \
} while(0)
void glWindowPos3ivMESA(glWindowPos3ivMESA_ARG_EXPAND);
typedef void (*glWindowPos3ivMESA_PTR)(glWindowPos3ivMESA_ARG_EXPAND);
#define glWindowPos3s_INDEX 2689
#define glWindowPos3s_RETURN void
#define glWindowPos3s_ARG_NAMES x, y, z
#define glWindowPos3s_ARG_EXPAND GLshort x, GLshort y, GLshort z
#define glWindowPos3s_PACKED PACKED_glWindowPos3s
#define glWindowPos3s_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glWindowPos3s_NOT_VOID_WRAP(...) {}
#define pack_glWindowPos3s(_x, _y, _z) ({ \
    glWindowPos3s_PACKED *packed_data = malloc(sizeof(glWindowPos3s_PACKED)); \
    packed_data->index = glWindowPos3s_INDEX; \
    packed_data->args.x = (GLshort)_x; \
    packed_data->args.y = (GLshort)_y; \
    packed_data->args.z = (GLshort)_z; \
    (packed_call_t *)packed_data; \
})
#define call_glWindowPos3s(packed, ret_v) do { \
    PACKED_glWindowPos3s *unpacked = (PACKED_glWindowPos3s *)packed; \
    ARGS_glWindowPos3s *args = (ARGS_glWindowPos3s *)&unpacked->args; \
    glWindowPos3s(args->x, args->y, args->z);; \
} while(0)
void glWindowPos3s(glWindowPos3s_ARG_EXPAND);
typedef void (*glWindowPos3s_PTR)(glWindowPos3s_ARG_EXPAND);
#define glWindowPos3sARB_INDEX 2690
#define glWindowPos3sARB_RETURN void
#define glWindowPos3sARB_ARG_NAMES x, y, z
#define glWindowPos3sARB_ARG_EXPAND GLshort x, GLshort y, GLshort z
#define glWindowPos3sARB_PACKED PACKED_glWindowPos3sARB
#define glWindowPos3sARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glWindowPos3sARB_NOT_VOID_WRAP(...) {}
#define pack_glWindowPos3sARB(_x, _y, _z) ({ \
    glWindowPos3sARB_PACKED *packed_data = malloc(sizeof(glWindowPos3sARB_PACKED)); \
    packed_data->index = glWindowPos3sARB_INDEX; \
    packed_data->args.x = (GLshort)_x; \
    packed_data->args.y = (GLshort)_y; \
    packed_data->args.z = (GLshort)_z; \
    (packed_call_t *)packed_data; \
})
#define call_glWindowPos3sARB(packed, ret_v) do { \
    PACKED_glWindowPos3sARB *unpacked = (PACKED_glWindowPos3sARB *)packed; \
    ARGS_glWindowPos3sARB *args = (ARGS_glWindowPos3sARB *)&unpacked->args; \
    glWindowPos3sARB(args->x, args->y, args->z);; \
} while(0)
void glWindowPos3sARB(glWindowPos3sARB_ARG_EXPAND);
typedef void (*glWindowPos3sARB_PTR)(glWindowPos3sARB_ARG_EXPAND);
#define glWindowPos3sMESA_INDEX 2691
#define glWindowPos3sMESA_RETURN void
#define glWindowPos3sMESA_ARG_NAMES x, y, z
#define glWindowPos3sMESA_ARG_EXPAND GLshort x, GLshort y, GLshort z
#define glWindowPos3sMESA_PACKED PACKED_glWindowPos3sMESA
#define glWindowPos3sMESA_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glWindowPos3sMESA_NOT_VOID_WRAP(...) {}
#define pack_glWindowPos3sMESA(_x, _y, _z) ({ \
    glWindowPos3sMESA_PACKED *packed_data = malloc(sizeof(glWindowPos3sMESA_PACKED)); \
    packed_data->index = glWindowPos3sMESA_INDEX; \
    packed_data->args.x = (GLshort)_x; \
    packed_data->args.y = (GLshort)_y; \
    packed_data->args.z = (GLshort)_z; \
    (packed_call_t *)packed_data; \
})
#define call_glWindowPos3sMESA(packed, ret_v) do { \
    PACKED_glWindowPos3sMESA *unpacked = (PACKED_glWindowPos3sMESA *)packed; \
    ARGS_glWindowPos3sMESA *args = (ARGS_glWindowPos3sMESA *)&unpacked->args; \
    glWindowPos3sMESA(args->x, args->y, args->z);; \
} while(0)
void glWindowPos3sMESA(glWindowPos3sMESA_ARG_EXPAND);
typedef void (*glWindowPos3sMESA_PTR)(glWindowPos3sMESA_ARG_EXPAND);
#define glWindowPos3sv_INDEX 2692
#define glWindowPos3sv_RETURN void
#define glWindowPos3sv_ARG_NAMES v
#define glWindowPos3sv_ARG_EXPAND const GLshort * v
#define glWindowPos3sv_PACKED PACKED_glWindowPos3sv
#define glWindowPos3sv_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glWindowPos3sv_NOT_VOID_WRAP(...) {}
#define pack_glWindowPos3sv(_v) ({ \
    glWindowPos3sv_PACKED *packed_data = malloc(sizeof(glWindowPos3sv_PACKED)); \
    packed_data->index = glWindowPos3sv_INDEX; \
    packed_data->args.v = (GLshort *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glWindowPos3sv(packed, ret_v) do { \
    PACKED_glWindowPos3sv *unpacked = (PACKED_glWindowPos3sv *)packed; \
    ARGS_glWindowPos3sv *args = (ARGS_glWindowPos3sv *)&unpacked->args; \
    glWindowPos3sv(args->v);; \
} while(0)
void glWindowPos3sv(glWindowPos3sv_ARG_EXPAND);
typedef void (*glWindowPos3sv_PTR)(glWindowPos3sv_ARG_EXPAND);
#define glWindowPos3svARB_INDEX 2693
#define glWindowPos3svARB_RETURN void
#define glWindowPos3svARB_ARG_NAMES v
#define glWindowPos3svARB_ARG_EXPAND const GLshort * v
#define glWindowPos3svARB_PACKED PACKED_glWindowPos3svARB
#define glWindowPos3svARB_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glWindowPos3svARB_NOT_VOID_WRAP(...) {}
#define pack_glWindowPos3svARB(_v) ({ \
    glWindowPos3svARB_PACKED *packed_data = malloc(sizeof(glWindowPos3svARB_PACKED)); \
    packed_data->index = glWindowPos3svARB_INDEX; \
    packed_data->args.v = (GLshort *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glWindowPos3svARB(packed, ret_v) do { \
    PACKED_glWindowPos3svARB *unpacked = (PACKED_glWindowPos3svARB *)packed; \
    ARGS_glWindowPos3svARB *args = (ARGS_glWindowPos3svARB *)&unpacked->args; \
    glWindowPos3svARB(args->v);; \
} while(0)
void glWindowPos3svARB(glWindowPos3svARB_ARG_EXPAND);
typedef void (*glWindowPos3svARB_PTR)(glWindowPos3svARB_ARG_EXPAND);
#define glWindowPos3svMESA_INDEX 2694
#define glWindowPos3svMESA_RETURN void
#define glWindowPos3svMESA_ARG_NAMES v
#define glWindowPos3svMESA_ARG_EXPAND const GLshort * v
#define glWindowPos3svMESA_PACKED PACKED_glWindowPos3svMESA
#define glWindowPos3svMESA_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glWindowPos3svMESA_NOT_VOID_WRAP(...) {}
#define pack_glWindowPos3svMESA(_v) ({ \
    glWindowPos3svMESA_PACKED *packed_data = malloc(sizeof(glWindowPos3svMESA_PACKED)); \
    packed_data->index = glWindowPos3svMESA_INDEX; \
    packed_data->args.v = (GLshort *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glWindowPos3svMESA(packed, ret_v) do { \
    PACKED_glWindowPos3svMESA *unpacked = (PACKED_glWindowPos3svMESA *)packed; \
    ARGS_glWindowPos3svMESA *args = (ARGS_glWindowPos3svMESA *)&unpacked->args; \
    glWindowPos3svMESA(args->v);; \
} while(0)
void glWindowPos3svMESA(glWindowPos3svMESA_ARG_EXPAND);
typedef void (*glWindowPos3svMESA_PTR)(glWindowPos3svMESA_ARG_EXPAND);
#define glWindowPos4dMESA_INDEX 2695
#define glWindowPos4dMESA_RETURN void
#define glWindowPos4dMESA_ARG_NAMES x, y, z, w
#define glWindowPos4dMESA_ARG_EXPAND GLdouble x, GLdouble y, GLdouble z, GLdouble w
#define glWindowPos4dMESA_PACKED PACKED_glWindowPos4dMESA
#define glWindowPos4dMESA_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glWindowPos4dMESA_NOT_VOID_WRAP(...) {}
#define pack_glWindowPos4dMESA(_x, _y, _z, _w) ({ \
    glWindowPos4dMESA_PACKED *packed_data = malloc(sizeof(glWindowPos4dMESA_PACKED)); \
    packed_data->index = glWindowPos4dMESA_INDEX; \
    packed_data->args.x = (GLdouble)_x; \
    packed_data->args.y = (GLdouble)_y; \
    packed_data->args.z = (GLdouble)_z; \
    packed_data->args.w = (GLdouble)_w; \
    (packed_call_t *)packed_data; \
})
#define call_glWindowPos4dMESA(packed, ret_v) do { \
    PACKED_glWindowPos4dMESA *unpacked = (PACKED_glWindowPos4dMESA *)packed; \
    ARGS_glWindowPos4dMESA *args = (ARGS_glWindowPos4dMESA *)&unpacked->args; \
    glWindowPos4dMESA(args->x, args->y, args->z, args->w);; \
} while(0)
void glWindowPos4dMESA(glWindowPos4dMESA_ARG_EXPAND);
typedef void (*glWindowPos4dMESA_PTR)(glWindowPos4dMESA_ARG_EXPAND);
#define glWindowPos4dvMESA_INDEX 2696
#define glWindowPos4dvMESA_RETURN void
#define glWindowPos4dvMESA_ARG_NAMES v
#define glWindowPos4dvMESA_ARG_EXPAND const GLdouble * v
#define glWindowPos4dvMESA_PACKED PACKED_glWindowPos4dvMESA
#define glWindowPos4dvMESA_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glWindowPos4dvMESA_NOT_VOID_WRAP(...) {}
#define pack_glWindowPos4dvMESA(_v) ({ \
    glWindowPos4dvMESA_PACKED *packed_data = malloc(sizeof(glWindowPos4dvMESA_PACKED)); \
    packed_data->index = glWindowPos4dvMESA_INDEX; \
    packed_data->args.v = (GLdouble *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glWindowPos4dvMESA(packed, ret_v) do { \
    PACKED_glWindowPos4dvMESA *unpacked = (PACKED_glWindowPos4dvMESA *)packed; \
    ARGS_glWindowPos4dvMESA *args = (ARGS_glWindowPos4dvMESA *)&unpacked->args; \
    glWindowPos4dvMESA(args->v);; \
} while(0)
void glWindowPos4dvMESA(glWindowPos4dvMESA_ARG_EXPAND);
typedef void (*glWindowPos4dvMESA_PTR)(glWindowPos4dvMESA_ARG_EXPAND);
#define glWindowPos4fMESA_INDEX 2697
#define glWindowPos4fMESA_RETURN void
#define glWindowPos4fMESA_ARG_NAMES x, y, z, w
#define glWindowPos4fMESA_ARG_EXPAND GLfloat x, GLfloat y, GLfloat z, GLfloat w
#define glWindowPos4fMESA_PACKED PACKED_glWindowPos4fMESA
#define glWindowPos4fMESA_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glWindowPos4fMESA_NOT_VOID_WRAP(...) {}
#define pack_glWindowPos4fMESA(_x, _y, _z, _w) ({ \
    glWindowPos4fMESA_PACKED *packed_data = malloc(sizeof(glWindowPos4fMESA_PACKED)); \
    packed_data->index = glWindowPos4fMESA_INDEX; \
    packed_data->args.x = (GLfloat)_x; \
    packed_data->args.y = (GLfloat)_y; \
    packed_data->args.z = (GLfloat)_z; \
    packed_data->args.w = (GLfloat)_w; \
    (packed_call_t *)packed_data; \
})
#define call_glWindowPos4fMESA(packed, ret_v) do { \
    PACKED_glWindowPos4fMESA *unpacked = (PACKED_glWindowPos4fMESA *)packed; \
    ARGS_glWindowPos4fMESA *args = (ARGS_glWindowPos4fMESA *)&unpacked->args; \
    glWindowPos4fMESA(args->x, args->y, args->z, args->w);; \
} while(0)
void glWindowPos4fMESA(glWindowPos4fMESA_ARG_EXPAND);
typedef void (*glWindowPos4fMESA_PTR)(glWindowPos4fMESA_ARG_EXPAND);
#define glWindowPos4fvMESA_INDEX 2698
#define glWindowPos4fvMESA_RETURN void
#define glWindowPos4fvMESA_ARG_NAMES v
#define glWindowPos4fvMESA_ARG_EXPAND const GLfloat * v
#define glWindowPos4fvMESA_PACKED PACKED_glWindowPos4fvMESA
#define glWindowPos4fvMESA_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glWindowPos4fvMESA_NOT_VOID_WRAP(...) {}
#define pack_glWindowPos4fvMESA(_v) ({ \
    glWindowPos4fvMESA_PACKED *packed_data = malloc(sizeof(glWindowPos4fvMESA_PACKED)); \
    packed_data->index = glWindowPos4fvMESA_INDEX; \
    packed_data->args.v = (GLfloat *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glWindowPos4fvMESA(packed, ret_v) do { \
    PACKED_glWindowPos4fvMESA *unpacked = (PACKED_glWindowPos4fvMESA *)packed; \
    ARGS_glWindowPos4fvMESA *args = (ARGS_glWindowPos4fvMESA *)&unpacked->args; \
    glWindowPos4fvMESA(args->v);; \
} while(0)
void glWindowPos4fvMESA(glWindowPos4fvMESA_ARG_EXPAND);
typedef void (*glWindowPos4fvMESA_PTR)(glWindowPos4fvMESA_ARG_EXPAND);
#define glWindowPos4iMESA_INDEX 2699
#define glWindowPos4iMESA_RETURN void
#define glWindowPos4iMESA_ARG_NAMES x, y, z, w
#define glWindowPos4iMESA_ARG_EXPAND GLint x, GLint y, GLint z, GLint w
#define glWindowPos4iMESA_PACKED PACKED_glWindowPos4iMESA
#define glWindowPos4iMESA_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glWindowPos4iMESA_NOT_VOID_WRAP(...) {}
#define pack_glWindowPos4iMESA(_x, _y, _z, _w) ({ \
    glWindowPos4iMESA_PACKED *packed_data = malloc(sizeof(glWindowPos4iMESA_PACKED)); \
    packed_data->index = glWindowPos4iMESA_INDEX; \
    packed_data->args.x = (GLint)_x; \
    packed_data->args.y = (GLint)_y; \
    packed_data->args.z = (GLint)_z; \
    packed_data->args.w = (GLint)_w; \
    (packed_call_t *)packed_data; \
})
#define call_glWindowPos4iMESA(packed, ret_v) do { \
    PACKED_glWindowPos4iMESA *unpacked = (PACKED_glWindowPos4iMESA *)packed; \
    ARGS_glWindowPos4iMESA *args = (ARGS_glWindowPos4iMESA *)&unpacked->args; \
    glWindowPos4iMESA(args->x, args->y, args->z, args->w);; \
} while(0)
void glWindowPos4iMESA(glWindowPos4iMESA_ARG_EXPAND);
typedef void (*glWindowPos4iMESA_PTR)(glWindowPos4iMESA_ARG_EXPAND);
#define glWindowPos4ivMESA_INDEX 2700
#define glWindowPos4ivMESA_RETURN void
#define glWindowPos4ivMESA_ARG_NAMES v
#define glWindowPos4ivMESA_ARG_EXPAND const GLint * v
#define glWindowPos4ivMESA_PACKED PACKED_glWindowPos4ivMESA
#define glWindowPos4ivMESA_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glWindowPos4ivMESA_NOT_VOID_WRAP(...) {}
#define pack_glWindowPos4ivMESA(_v) ({ \
    glWindowPos4ivMESA_PACKED *packed_data = malloc(sizeof(glWindowPos4ivMESA_PACKED)); \
    packed_data->index = glWindowPos4ivMESA_INDEX; \
    packed_data->args.v = (GLint *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glWindowPos4ivMESA(packed, ret_v) do { \
    PACKED_glWindowPos4ivMESA *unpacked = (PACKED_glWindowPos4ivMESA *)packed; \
    ARGS_glWindowPos4ivMESA *args = (ARGS_glWindowPos4ivMESA *)&unpacked->args; \
    glWindowPos4ivMESA(args->v);; \
} while(0)
void glWindowPos4ivMESA(glWindowPos4ivMESA_ARG_EXPAND);
typedef void (*glWindowPos4ivMESA_PTR)(glWindowPos4ivMESA_ARG_EXPAND);
#define glWindowPos4sMESA_INDEX 2701
#define glWindowPos4sMESA_RETURN void
#define glWindowPos4sMESA_ARG_NAMES x, y, z, w
#define glWindowPos4sMESA_ARG_EXPAND GLshort x, GLshort y, GLshort z, GLshort w
#define glWindowPos4sMESA_PACKED PACKED_glWindowPos4sMESA
#define glWindowPos4sMESA_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glWindowPos4sMESA_NOT_VOID_WRAP(...) {}
#define pack_glWindowPos4sMESA(_x, _y, _z, _w) ({ \
    glWindowPos4sMESA_PACKED *packed_data = malloc(sizeof(glWindowPos4sMESA_PACKED)); \
    packed_data->index = glWindowPos4sMESA_INDEX; \
    packed_data->args.x = (GLshort)_x; \
    packed_data->args.y = (GLshort)_y; \
    packed_data->args.z = (GLshort)_z; \
    packed_data->args.w = (GLshort)_w; \
    (packed_call_t *)packed_data; \
})
#define call_glWindowPos4sMESA(packed, ret_v) do { \
    PACKED_glWindowPos4sMESA *unpacked = (PACKED_glWindowPos4sMESA *)packed; \
    ARGS_glWindowPos4sMESA *args = (ARGS_glWindowPos4sMESA *)&unpacked->args; \
    glWindowPos4sMESA(args->x, args->y, args->z, args->w);; \
} while(0)
void glWindowPos4sMESA(glWindowPos4sMESA_ARG_EXPAND);
typedef void (*glWindowPos4sMESA_PTR)(glWindowPos4sMESA_ARG_EXPAND);
#define glWindowPos4svMESA_INDEX 2702
#define glWindowPos4svMESA_RETURN void
#define glWindowPos4svMESA_ARG_NAMES v
#define glWindowPos4svMESA_ARG_EXPAND const GLshort * v
#define glWindowPos4svMESA_PACKED PACKED_glWindowPos4svMESA
#define glWindowPos4svMESA_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glWindowPos4svMESA_NOT_VOID_WRAP(...) {}
#define pack_glWindowPos4svMESA(_v) ({ \
    glWindowPos4svMESA_PACKED *packed_data = malloc(sizeof(glWindowPos4svMESA_PACKED)); \
    packed_data->index = glWindowPos4svMESA_INDEX; \
    packed_data->args.v = (GLshort *)_v; \
    (packed_call_t *)packed_data; \
})
#define call_glWindowPos4svMESA(packed, ret_v) do { \
    PACKED_glWindowPos4svMESA *unpacked = (PACKED_glWindowPos4svMESA *)packed; \
    ARGS_glWindowPos4svMESA *args = (ARGS_glWindowPos4svMESA *)&unpacked->args; \
    glWindowPos4svMESA(args->v);; \
} while(0)
void glWindowPos4svMESA(glWindowPos4svMESA_ARG_EXPAND);
typedef void (*glWindowPos4svMESA_PTR)(glWindowPos4svMESA_ARG_EXPAND);
#define glWriteMaskEXT_INDEX 2703
#define glWriteMaskEXT_RETURN void
#define glWriteMaskEXT_ARG_NAMES res, in, outX, outY, outZ, outW
#define glWriteMaskEXT_ARG_EXPAND GLuint res, GLuint in, GLenum outX, GLenum outY, GLenum outZ, GLenum outW
#define glWriteMaskEXT_PACKED PACKED_glWriteMaskEXT
#define glWriteMaskEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glWriteMaskEXT_NOT_VOID_WRAP(...) {}
#define pack_glWriteMaskEXT(_res, _in, _outX, _outY, _outZ, _outW) ({ \
    glWriteMaskEXT_PACKED *packed_data = malloc(sizeof(glWriteMaskEXT_PACKED)); \
    packed_data->index = glWriteMaskEXT_INDEX; \
    packed_data->args.res = (GLuint)_res; \
    packed_data->args.in = (GLuint)_in; \
    packed_data->args.outX = (GLenum)_outX; \
    packed_data->args.outY = (GLenum)_outY; \
    packed_data->args.outZ = (GLenum)_outZ; \
    packed_data->args.outW = (GLenum)_outW; \
    (packed_call_t *)packed_data; \
})
#define call_glWriteMaskEXT(packed, ret_v) do { \
    PACKED_glWriteMaskEXT *unpacked = (PACKED_glWriteMaskEXT *)packed; \
    ARGS_glWriteMaskEXT *args = (ARGS_glWriteMaskEXT *)&unpacked->args; \
    glWriteMaskEXT(args->res, args->in, args->outX, args->outY, args->outZ, args->outW);; \
} while(0)
void glWriteMaskEXT(glWriteMaskEXT_ARG_EXPAND);
typedef void (*glWriteMaskEXT_PTR)(glWriteMaskEXT_ARG_EXPAND);
#define glXAssociateDMPbufferSGIX_INDEX 2704
#define glXAssociateDMPbufferSGIX_RETURN Bool
#define glXAssociateDMPbufferSGIX_ARG_NAMES dpy, pbuffer, params, dmbuffer
#define glXAssociateDMPbufferSGIX_ARG_EXPAND Display * dpy, GLXPbufferSGIX pbuffer, DMparams * params, DMbuffer dmbuffer
#define glXAssociateDMPbufferSGIX_PACKED PACKED_glXAssociateDMPbufferSGIX
#define glXAssociateDMPbufferSGIX_VOID_ONLY_WRAP(...) {}
#define glXAssociateDMPbufferSGIX_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glXAssociateDMPbufferSGIX(_dpy, _pbuffer, _params, _dmbuffer) ({ \
    glXAssociateDMPbufferSGIX_PACKED *packed_data = malloc(sizeof(glXAssociateDMPbufferSGIX_PACKED)); \
    packed_data->index = glXAssociateDMPbufferSGIX_INDEX; \
    packed_data->args.dpy = (Display *)_dpy; \
    packed_data->args.pbuffer = (GLXPbufferSGIX)_pbuffer; \
    packed_data->args.params = (DMparams *)_params; \
    packed_data->args.dmbuffer = (DMbuffer)_dmbuffer; \
    (packed_call_t *)packed_data; \
})
#define call_glXAssociateDMPbufferSGIX(packed, ret_v) do { \
    PACKED_glXAssociateDMPbufferSGIX *unpacked = (PACKED_glXAssociateDMPbufferSGIX *)packed; \
    ARGS_glXAssociateDMPbufferSGIX *args = (ARGS_glXAssociateDMPbufferSGIX *)&unpacked->args; \
    Bool *ret = (Bool *)ret_v; \
    if (ret != NULL) { \
        *ret = glXAssociateDMPbufferSGIX(args->dpy, args->pbuffer, args->params, args->dmbuffer);; \
    } else { \
        glXAssociateDMPbufferSGIX(args->dpy, args->pbuffer, args->params, args->dmbuffer);; \
    } \
} while(0)
Bool glXAssociateDMPbufferSGIX(glXAssociateDMPbufferSGIX_ARG_EXPAND);
typedef Bool (*glXAssociateDMPbufferSGIX_PTR)(glXAssociateDMPbufferSGIX_ARG_EXPAND);
#define glXBindChannelToWindowSGIX_INDEX 2705
#define glXBindChannelToWindowSGIX_RETURN int
#define glXBindChannelToWindowSGIX_ARG_NAMES display, screen, channel, window
#define glXBindChannelToWindowSGIX_ARG_EXPAND Display * display, int screen, int channel, Window window
#define glXBindChannelToWindowSGIX_PACKED PACKED_glXBindChannelToWindowSGIX
#define glXBindChannelToWindowSGIX_VOID_ONLY_WRAP(...) {}
#define glXBindChannelToWindowSGIX_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glXBindChannelToWindowSGIX(_display, _screen, _channel, _window) ({ \
    glXBindChannelToWindowSGIX_PACKED *packed_data = malloc(sizeof(glXBindChannelToWindowSGIX_PACKED)); \
    packed_data->index = glXBindChannelToWindowSGIX_INDEX; \
    packed_data->args.display = (Display *)_display; \
    packed_data->args.screen = (int)_screen; \
    packed_data->args.channel = (int)_channel; \
    packed_data->args.window = (Window)_window; \
    (packed_call_t *)packed_data; \
})
#define call_glXBindChannelToWindowSGIX(packed, ret_v) do { \
    PACKED_glXBindChannelToWindowSGIX *unpacked = (PACKED_glXBindChannelToWindowSGIX *)packed; \
    ARGS_glXBindChannelToWindowSGIX *args = (ARGS_glXBindChannelToWindowSGIX *)&unpacked->args; \
    int *ret = (int *)ret_v; \
    if (ret != NULL) { \
        *ret = glXBindChannelToWindowSGIX(args->display, args->screen, args->channel, args->window);; \
    } else { \
        glXBindChannelToWindowSGIX(args->display, args->screen, args->channel, args->window);; \
    } \
} while(0)
int glXBindChannelToWindowSGIX(glXBindChannelToWindowSGIX_ARG_EXPAND);
typedef int (*glXBindChannelToWindowSGIX_PTR)(glXBindChannelToWindowSGIX_ARG_EXPAND);
#define glXBindHyperpipeSGIX_INDEX 2706
#define glXBindHyperpipeSGIX_RETURN int
#define glXBindHyperpipeSGIX_ARG_NAMES dpy, hpId
#define glXBindHyperpipeSGIX_ARG_EXPAND Display * dpy, int hpId
#define glXBindHyperpipeSGIX_PACKED PACKED_glXBindHyperpipeSGIX
#define glXBindHyperpipeSGIX_VOID_ONLY_WRAP(...) {}
#define glXBindHyperpipeSGIX_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glXBindHyperpipeSGIX(_dpy, _hpId) ({ \
    glXBindHyperpipeSGIX_PACKED *packed_data = malloc(sizeof(glXBindHyperpipeSGIX_PACKED)); \
    packed_data->index = glXBindHyperpipeSGIX_INDEX; \
    packed_data->args.dpy = (Display *)_dpy; \
    packed_data->args.hpId = (int)_hpId; \
    (packed_call_t *)packed_data; \
})
#define call_glXBindHyperpipeSGIX(packed, ret_v) do { \
    PACKED_glXBindHyperpipeSGIX *unpacked = (PACKED_glXBindHyperpipeSGIX *)packed; \
    ARGS_glXBindHyperpipeSGIX *args = (ARGS_glXBindHyperpipeSGIX *)&unpacked->args; \
    int *ret = (int *)ret_v; \
    if (ret != NULL) { \
        *ret = glXBindHyperpipeSGIX(args->dpy, args->hpId);; \
    } else { \
        glXBindHyperpipeSGIX(args->dpy, args->hpId);; \
    } \
} while(0)
int glXBindHyperpipeSGIX(glXBindHyperpipeSGIX_ARG_EXPAND);
typedef int (*glXBindHyperpipeSGIX_PTR)(glXBindHyperpipeSGIX_ARG_EXPAND);
#define glXBindSwapBarrierNV_INDEX 2707
#define glXBindSwapBarrierNV_RETURN Bool
#define glXBindSwapBarrierNV_ARG_NAMES dpy, group, barrier
#define glXBindSwapBarrierNV_ARG_EXPAND Display * dpy, GLuint group, GLuint barrier
#define glXBindSwapBarrierNV_PACKED PACKED_glXBindSwapBarrierNV
#define glXBindSwapBarrierNV_VOID_ONLY_WRAP(...) {}
#define glXBindSwapBarrierNV_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glXBindSwapBarrierNV(_dpy, _group, _barrier) ({ \
    glXBindSwapBarrierNV_PACKED *packed_data = malloc(sizeof(glXBindSwapBarrierNV_PACKED)); \
    packed_data->index = glXBindSwapBarrierNV_INDEX; \
    packed_data->args.dpy = (Display *)_dpy; \
    packed_data->args.group = (GLuint)_group; \
    packed_data->args.barrier = (GLuint)_barrier; \
    (packed_call_t *)packed_data; \
})
#define call_glXBindSwapBarrierNV(packed, ret_v) do { \
    PACKED_glXBindSwapBarrierNV *unpacked = (PACKED_glXBindSwapBarrierNV *)packed; \
    ARGS_glXBindSwapBarrierNV *args = (ARGS_glXBindSwapBarrierNV *)&unpacked->args; \
    Bool *ret = (Bool *)ret_v; \
    if (ret != NULL) { \
        *ret = glXBindSwapBarrierNV(args->dpy, args->group, args->barrier);; \
    } else { \
        glXBindSwapBarrierNV(args->dpy, args->group, args->barrier);; \
    } \
} while(0)
Bool glXBindSwapBarrierNV(glXBindSwapBarrierNV_ARG_EXPAND);
typedef Bool (*glXBindSwapBarrierNV_PTR)(glXBindSwapBarrierNV_ARG_EXPAND);
#define glXBindSwapBarrierSGIX_INDEX 2708
#define glXBindSwapBarrierSGIX_RETURN void
#define glXBindSwapBarrierSGIX_ARG_NAMES dpy, drawable, barrier
#define glXBindSwapBarrierSGIX_ARG_EXPAND Display * dpy, GLXDrawable drawable, int barrier
#define glXBindSwapBarrierSGIX_PACKED PACKED_glXBindSwapBarrierSGIX
#define glXBindSwapBarrierSGIX_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glXBindSwapBarrierSGIX_NOT_VOID_WRAP(...) {}
#define pack_glXBindSwapBarrierSGIX(_dpy, _drawable, _barrier) ({ \
    glXBindSwapBarrierSGIX_PACKED *packed_data = malloc(sizeof(glXBindSwapBarrierSGIX_PACKED)); \
    packed_data->index = glXBindSwapBarrierSGIX_INDEX; \
    packed_data->args.dpy = (Display *)_dpy; \
    packed_data->args.drawable = (GLXDrawable)_drawable; \
    packed_data->args.barrier = (int)_barrier; \
    (packed_call_t *)packed_data; \
})
#define call_glXBindSwapBarrierSGIX(packed, ret_v) do { \
    PACKED_glXBindSwapBarrierSGIX *unpacked = (PACKED_glXBindSwapBarrierSGIX *)packed; \
    ARGS_glXBindSwapBarrierSGIX *args = (ARGS_glXBindSwapBarrierSGIX *)&unpacked->args; \
    glXBindSwapBarrierSGIX(args->dpy, args->drawable, args->barrier);; \
} while(0)
void glXBindSwapBarrierSGIX(glXBindSwapBarrierSGIX_ARG_EXPAND);
typedef void (*glXBindSwapBarrierSGIX_PTR)(glXBindSwapBarrierSGIX_ARG_EXPAND);
#define glXBindTexImageEXT_INDEX 2709
#define glXBindTexImageEXT_RETURN void
#define glXBindTexImageEXT_ARG_NAMES dpy, drawable, buffer, attrib_list
#define glXBindTexImageEXT_ARG_EXPAND Display * dpy, GLXDrawable drawable, int buffer, const int * attrib_list
#define glXBindTexImageEXT_PACKED PACKED_glXBindTexImageEXT
#define glXBindTexImageEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glXBindTexImageEXT_NOT_VOID_WRAP(...) {}
#define pack_glXBindTexImageEXT(_dpy, _drawable, _buffer, _attrib_list) ({ \
    glXBindTexImageEXT_PACKED *packed_data = malloc(sizeof(glXBindTexImageEXT_PACKED)); \
    packed_data->index = glXBindTexImageEXT_INDEX; \
    packed_data->args.dpy = (Display *)_dpy; \
    packed_data->args.drawable = (GLXDrawable)_drawable; \
    packed_data->args.buffer = (int)_buffer; \
    packed_data->args.attrib_list = (int *)_attrib_list; \
    (packed_call_t *)packed_data; \
})
#define call_glXBindTexImageEXT(packed, ret_v) do { \
    PACKED_glXBindTexImageEXT *unpacked = (PACKED_glXBindTexImageEXT *)packed; \
    ARGS_glXBindTexImageEXT *args = (ARGS_glXBindTexImageEXT *)&unpacked->args; \
    glXBindTexImageEXT(args->dpy, args->drawable, args->buffer, args->attrib_list);; \
} while(0)
void glXBindTexImageEXT(glXBindTexImageEXT_ARG_EXPAND);
typedef void (*glXBindTexImageEXT_PTR)(glXBindTexImageEXT_ARG_EXPAND);
#define glXBindVideoCaptureDeviceNV_INDEX 2710
#define glXBindVideoCaptureDeviceNV_RETURN int
#define glXBindVideoCaptureDeviceNV_ARG_NAMES dpy, video_capture_slot, device
#define glXBindVideoCaptureDeviceNV_ARG_EXPAND Display * dpy, unsigned int video_capture_slot, GLXVideoCaptureDeviceNV device
#define glXBindVideoCaptureDeviceNV_PACKED PACKED_glXBindVideoCaptureDeviceNV
#define glXBindVideoCaptureDeviceNV_VOID_ONLY_WRAP(...) {}
#define glXBindVideoCaptureDeviceNV_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glXBindVideoCaptureDeviceNV(_dpy, _video_capture_slot, _device) ({ \
    glXBindVideoCaptureDeviceNV_PACKED *packed_data = malloc(sizeof(glXBindVideoCaptureDeviceNV_PACKED)); \
    packed_data->index = glXBindVideoCaptureDeviceNV_INDEX; \
    packed_data->args.dpy = (Display *)_dpy; \
    packed_data->args.video_capture_slot = (unsigned int)_video_capture_slot; \
    packed_data->args.device = (GLXVideoCaptureDeviceNV)_device; \
    (packed_call_t *)packed_data; \
})
#define call_glXBindVideoCaptureDeviceNV(packed, ret_v) do { \
    PACKED_glXBindVideoCaptureDeviceNV *unpacked = (PACKED_glXBindVideoCaptureDeviceNV *)packed; \
    ARGS_glXBindVideoCaptureDeviceNV *args = (ARGS_glXBindVideoCaptureDeviceNV *)&unpacked->args; \
    int *ret = (int *)ret_v; \
    if (ret != NULL) { \
        *ret = glXBindVideoCaptureDeviceNV(args->dpy, args->video_capture_slot, args->device);; \
    } else { \
        glXBindVideoCaptureDeviceNV(args->dpy, args->video_capture_slot, args->device);; \
    } \
} while(0)
int glXBindVideoCaptureDeviceNV(glXBindVideoCaptureDeviceNV_ARG_EXPAND);
typedef int (*glXBindVideoCaptureDeviceNV_PTR)(glXBindVideoCaptureDeviceNV_ARG_EXPAND);
#define glXBindVideoDeviceNV_INDEX 2711
#define glXBindVideoDeviceNV_RETURN int
#define glXBindVideoDeviceNV_ARG_NAMES dpy, video_slot, video_device, attrib_list
#define glXBindVideoDeviceNV_ARG_EXPAND Display * dpy, unsigned int video_slot, unsigned int video_device, const int * attrib_list
#define glXBindVideoDeviceNV_PACKED PACKED_glXBindVideoDeviceNV
#define glXBindVideoDeviceNV_VOID_ONLY_WRAP(...) {}
#define glXBindVideoDeviceNV_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glXBindVideoDeviceNV(_dpy, _video_slot, _video_device, _attrib_list) ({ \
    glXBindVideoDeviceNV_PACKED *packed_data = malloc(sizeof(glXBindVideoDeviceNV_PACKED)); \
    packed_data->index = glXBindVideoDeviceNV_INDEX; \
    packed_data->args.dpy = (Display *)_dpy; \
    packed_data->args.video_slot = (unsigned int)_video_slot; \
    packed_data->args.video_device = (unsigned int)_video_device; \
    packed_data->args.attrib_list = (int *)_attrib_list; \
    (packed_call_t *)packed_data; \
})
#define call_glXBindVideoDeviceNV(packed, ret_v) do { \
    PACKED_glXBindVideoDeviceNV *unpacked = (PACKED_glXBindVideoDeviceNV *)packed; \
    ARGS_glXBindVideoDeviceNV *args = (ARGS_glXBindVideoDeviceNV *)&unpacked->args; \
    int *ret = (int *)ret_v; \
    if (ret != NULL) { \
        *ret = glXBindVideoDeviceNV(args->dpy, args->video_slot, args->video_device, args->attrib_list);; \
    } else { \
        glXBindVideoDeviceNV(args->dpy, args->video_slot, args->video_device, args->attrib_list);; \
    } \
} while(0)
int glXBindVideoDeviceNV(glXBindVideoDeviceNV_ARG_EXPAND);
typedef int (*glXBindVideoDeviceNV_PTR)(glXBindVideoDeviceNV_ARG_EXPAND);
#define glXBindVideoImageNV_INDEX 2712
#define glXBindVideoImageNV_RETURN int
#define glXBindVideoImageNV_ARG_NAMES dpy, VideoDevice, pbuf, iVideoBuffer
#define glXBindVideoImageNV_ARG_EXPAND Display * dpy, GLXVideoDeviceNV VideoDevice, GLXPbuffer pbuf, int iVideoBuffer
#define glXBindVideoImageNV_PACKED PACKED_glXBindVideoImageNV
#define glXBindVideoImageNV_VOID_ONLY_WRAP(...) {}
#define glXBindVideoImageNV_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glXBindVideoImageNV(_dpy, _VideoDevice, _pbuf, _iVideoBuffer) ({ \
    glXBindVideoImageNV_PACKED *packed_data = malloc(sizeof(glXBindVideoImageNV_PACKED)); \
    packed_data->index = glXBindVideoImageNV_INDEX; \
    packed_data->args.dpy = (Display *)_dpy; \
    packed_data->args.VideoDevice = (GLXVideoDeviceNV)_VideoDevice; \
    packed_data->args.pbuf = (GLXPbuffer)_pbuf; \
    packed_data->args.iVideoBuffer = (int)_iVideoBuffer; \
    (packed_call_t *)packed_data; \
})
#define call_glXBindVideoImageNV(packed, ret_v) do { \
    PACKED_glXBindVideoImageNV *unpacked = (PACKED_glXBindVideoImageNV *)packed; \
    ARGS_glXBindVideoImageNV *args = (ARGS_glXBindVideoImageNV *)&unpacked->args; \
    int *ret = (int *)ret_v; \
    if (ret != NULL) { \
        *ret = glXBindVideoImageNV(args->dpy, args->VideoDevice, args->pbuf, args->iVideoBuffer);; \
    } else { \
        glXBindVideoImageNV(args->dpy, args->VideoDevice, args->pbuf, args->iVideoBuffer);; \
    } \
} while(0)
int glXBindVideoImageNV(glXBindVideoImageNV_ARG_EXPAND);
typedef int (*glXBindVideoImageNV_PTR)(glXBindVideoImageNV_ARG_EXPAND);
#define glXChangeDrawableAttributes_INDEX 2713
#define glXChangeDrawableAttributes_RETURN void
#define glXChangeDrawableAttributes_ARG_NAMES drawable
#define glXChangeDrawableAttributes_ARG_EXPAND uint32_t drawable
#define glXChangeDrawableAttributes_PACKED PACKED_glXChangeDrawableAttributes
#define glXChangeDrawableAttributes_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glXChangeDrawableAttributes_NOT_VOID_WRAP(...) {}
#define pack_glXChangeDrawableAttributes(_drawable) ({ \
    glXChangeDrawableAttributes_PACKED *packed_data = malloc(sizeof(glXChangeDrawableAttributes_PACKED)); \
    packed_data->index = glXChangeDrawableAttributes_INDEX; \
    packed_data->args.drawable = (uint32_t)_drawable; \
    (packed_call_t *)packed_data; \
})
#define call_glXChangeDrawableAttributes(packed, ret_v) do { \
    PACKED_glXChangeDrawableAttributes *unpacked = (PACKED_glXChangeDrawableAttributes *)packed; \
    ARGS_glXChangeDrawableAttributes *args = (ARGS_glXChangeDrawableAttributes *)&unpacked->args; \
    glXChangeDrawableAttributes(args->drawable);; \
} while(0)
void glXChangeDrawableAttributes(glXChangeDrawableAttributes_ARG_EXPAND);
typedef void (*glXChangeDrawableAttributes_PTR)(glXChangeDrawableAttributes_ARG_EXPAND);
#define glXChangeDrawableAttributesSGIX_INDEX 2714
#define glXChangeDrawableAttributesSGIX_RETURN void
#define glXChangeDrawableAttributesSGIX_ARG_NAMES drawable
#define glXChangeDrawableAttributesSGIX_ARG_EXPAND uint32_t drawable
#define glXChangeDrawableAttributesSGIX_PACKED PACKED_glXChangeDrawableAttributesSGIX
#define glXChangeDrawableAttributesSGIX_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glXChangeDrawableAttributesSGIX_NOT_VOID_WRAP(...) {}
#define pack_glXChangeDrawableAttributesSGIX(_drawable) ({ \
    glXChangeDrawableAttributesSGIX_PACKED *packed_data = malloc(sizeof(glXChangeDrawableAttributesSGIX_PACKED)); \
    packed_data->index = glXChangeDrawableAttributesSGIX_INDEX; \
    packed_data->args.drawable = (uint32_t)_drawable; \
    (packed_call_t *)packed_data; \
})
#define call_glXChangeDrawableAttributesSGIX(packed, ret_v) do { \
    PACKED_glXChangeDrawableAttributesSGIX *unpacked = (PACKED_glXChangeDrawableAttributesSGIX *)packed; \
    ARGS_glXChangeDrawableAttributesSGIX *args = (ARGS_glXChangeDrawableAttributesSGIX *)&unpacked->args; \
    glXChangeDrawableAttributesSGIX(args->drawable);; \
} while(0)
void glXChangeDrawableAttributesSGIX(glXChangeDrawableAttributesSGIX_ARG_EXPAND);
typedef void (*glXChangeDrawableAttributesSGIX_PTR)(glXChangeDrawableAttributesSGIX_ARG_EXPAND);
#define glXChannelRectSGIX_INDEX 2715
#define glXChannelRectSGIX_RETURN int
#define glXChannelRectSGIX_ARG_NAMES display, screen, channel, x, y, w, h
#define glXChannelRectSGIX_ARG_EXPAND Display * display, int screen, int channel, int x, int y, int w, int h
#define glXChannelRectSGIX_PACKED PACKED_glXChannelRectSGIX
#define glXChannelRectSGIX_VOID_ONLY_WRAP(...) {}
#define glXChannelRectSGIX_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glXChannelRectSGIX(_display, _screen, _channel, _x, _y, _w, _h) ({ \
    glXChannelRectSGIX_PACKED *packed_data = malloc(sizeof(glXChannelRectSGIX_PACKED)); \
    packed_data->index = glXChannelRectSGIX_INDEX; \
    packed_data->args.display = (Display *)_display; \
    packed_data->args.screen = (int)_screen; \
    packed_data->args.channel = (int)_channel; \
    packed_data->args.x = (int)_x; \
    packed_data->args.y = (int)_y; \
    packed_data->args.w = (int)_w; \
    packed_data->args.h = (int)_h; \
    (packed_call_t *)packed_data; \
})
#define call_glXChannelRectSGIX(packed, ret_v) do { \
    PACKED_glXChannelRectSGIX *unpacked = (PACKED_glXChannelRectSGIX *)packed; \
    ARGS_glXChannelRectSGIX *args = (ARGS_glXChannelRectSGIX *)&unpacked->args; \
    int *ret = (int *)ret_v; \
    if (ret != NULL) { \
        *ret = glXChannelRectSGIX(args->display, args->screen, args->channel, args->x, args->y, args->w, args->h);; \
    } else { \
        glXChannelRectSGIX(args->display, args->screen, args->channel, args->x, args->y, args->w, args->h);; \
    } \
} while(0)
int glXChannelRectSGIX(glXChannelRectSGIX_ARG_EXPAND);
typedef int (*glXChannelRectSGIX_PTR)(glXChannelRectSGIX_ARG_EXPAND);
#define glXChannelRectSyncSGIX_INDEX 2716
#define glXChannelRectSyncSGIX_RETURN int
#define glXChannelRectSyncSGIX_ARG_NAMES display, screen, channel, synctype
#define glXChannelRectSyncSGIX_ARG_EXPAND Display * display, int screen, int channel, GLenum synctype
#define glXChannelRectSyncSGIX_PACKED PACKED_glXChannelRectSyncSGIX
#define glXChannelRectSyncSGIX_VOID_ONLY_WRAP(...) {}
#define glXChannelRectSyncSGIX_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glXChannelRectSyncSGIX(_display, _screen, _channel, _synctype) ({ \
    glXChannelRectSyncSGIX_PACKED *packed_data = malloc(sizeof(glXChannelRectSyncSGIX_PACKED)); \
    packed_data->index = glXChannelRectSyncSGIX_INDEX; \
    packed_data->args.display = (Display *)_display; \
    packed_data->args.screen = (int)_screen; \
    packed_data->args.channel = (int)_channel; \
    packed_data->args.synctype = (GLenum)_synctype; \
    (packed_call_t *)packed_data; \
})
#define call_glXChannelRectSyncSGIX(packed, ret_v) do { \
    PACKED_glXChannelRectSyncSGIX *unpacked = (PACKED_glXChannelRectSyncSGIX *)packed; \
    ARGS_glXChannelRectSyncSGIX *args = (ARGS_glXChannelRectSyncSGIX *)&unpacked->args; \
    int *ret = (int *)ret_v; \
    if (ret != NULL) { \
        *ret = glXChannelRectSyncSGIX(args->display, args->screen, args->channel, args->synctype);; \
    } else { \
        glXChannelRectSyncSGIX(args->display, args->screen, args->channel, args->synctype);; \
    } \
} while(0)
int glXChannelRectSyncSGIX(glXChannelRectSyncSGIX_ARG_EXPAND);
typedef int (*glXChannelRectSyncSGIX_PTR)(glXChannelRectSyncSGIX_ARG_EXPAND);
#define glXChooseFBConfig_INDEX 2717
#define glXChooseFBConfig_RETURN GLXFBConfig *
#define glXChooseFBConfig_ARG_NAMES dpy, screen, attrib_list, nelements
#define glXChooseFBConfig_ARG_EXPAND Display * dpy, int screen, const int * attrib_list, int * nelements
#define glXChooseFBConfig_PACKED PACKED_glXChooseFBConfig
#define glXChooseFBConfig_VOID_ONLY_WRAP(...) {}
#define glXChooseFBConfig_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glXChooseFBConfig(_dpy, _screen, _attrib_list, _nelements) ({ \
    glXChooseFBConfig_PACKED *packed_data = malloc(sizeof(glXChooseFBConfig_PACKED)); \
    packed_data->index = glXChooseFBConfig_INDEX; \
    packed_data->args.dpy = (Display *)_dpy; \
    packed_data->args.screen = (int)_screen; \
    packed_data->args.attrib_list = (int *)_attrib_list; \
    packed_data->args.nelements = (int *)_nelements; \
    (packed_call_t *)packed_data; \
})
#define call_glXChooseFBConfig(packed, ret_v) do { \
    PACKED_glXChooseFBConfig *unpacked = (PACKED_glXChooseFBConfig *)packed; \
    ARGS_glXChooseFBConfig *args = (ARGS_glXChooseFBConfig *)&unpacked->args; \
    GLXFBConfig * *ret = (GLXFBConfig * *)ret_v; \
    if (ret != NULL) { \
        *ret = glXChooseFBConfig(args->dpy, args->screen, args->attrib_list, args->nelements);; \
    } else { \
        glXChooseFBConfig(args->dpy, args->screen, args->attrib_list, args->nelements);; \
    } \
} while(0)
GLXFBConfig * glXChooseFBConfig(glXChooseFBConfig_ARG_EXPAND);
typedef GLXFBConfig * (*glXChooseFBConfig_PTR)(glXChooseFBConfig_ARG_EXPAND);
#define glXChooseFBConfigSGIX_INDEX 2718
#define glXChooseFBConfigSGIX_RETURN GLXFBConfigSGIX *
#define glXChooseFBConfigSGIX_ARG_NAMES dpy, screen, attrib_list, nelements
#define glXChooseFBConfigSGIX_ARG_EXPAND Display * dpy, int screen, int * attrib_list, int * nelements
#define glXChooseFBConfigSGIX_PACKED PACKED_glXChooseFBConfigSGIX
#define glXChooseFBConfigSGIX_VOID_ONLY_WRAP(...) {}
#define glXChooseFBConfigSGIX_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glXChooseFBConfigSGIX(_dpy, _screen, _attrib_list, _nelements) ({ \
    glXChooseFBConfigSGIX_PACKED *packed_data = malloc(sizeof(glXChooseFBConfigSGIX_PACKED)); \
    packed_data->index = glXChooseFBConfigSGIX_INDEX; \
    packed_data->args.dpy = (Display *)_dpy; \
    packed_data->args.screen = (int)_screen; \
    packed_data->args.attrib_list = (int *)_attrib_list; \
    packed_data->args.nelements = (int *)_nelements; \
    (packed_call_t *)packed_data; \
})
#define call_glXChooseFBConfigSGIX(packed, ret_v) do { \
    PACKED_glXChooseFBConfigSGIX *unpacked = (PACKED_glXChooseFBConfigSGIX *)packed; \
    ARGS_glXChooseFBConfigSGIX *args = (ARGS_glXChooseFBConfigSGIX *)&unpacked->args; \
    GLXFBConfigSGIX * *ret = (GLXFBConfigSGIX * *)ret_v; \
    if (ret != NULL) { \
        *ret = glXChooseFBConfigSGIX(args->dpy, args->screen, args->attrib_list, args->nelements);; \
    } else { \
        glXChooseFBConfigSGIX(args->dpy, args->screen, args->attrib_list, args->nelements);; \
    } \
} while(0)
GLXFBConfigSGIX * glXChooseFBConfigSGIX(glXChooseFBConfigSGIX_ARG_EXPAND);
typedef GLXFBConfigSGIX * (*glXChooseFBConfigSGIX_PTR)(glXChooseFBConfigSGIX_ARG_EXPAND);
#define glXChooseVisual_INDEX 2719
#define glXChooseVisual_RETURN XVisualInfo *
#define glXChooseVisual_ARG_NAMES dpy, screen, attribList
#define glXChooseVisual_ARG_EXPAND Display * dpy, int screen, int * attribList
#define glXChooseVisual_PACKED PACKED_glXChooseVisual
#define glXChooseVisual_VOID_ONLY_WRAP(...) {}
#define glXChooseVisual_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glXChooseVisual(_dpy, _screen, _attribList) ({ \
    glXChooseVisual_PACKED *packed_data = malloc(sizeof(glXChooseVisual_PACKED)); \
    packed_data->index = glXChooseVisual_INDEX; \
    packed_data->args.dpy = (Display *)_dpy; \
    packed_data->args.screen = (int)_screen; \
    packed_data->args.attribList = (int *)_attribList; \
    (packed_call_t *)packed_data; \
})
#define call_glXChooseVisual(packed, ret_v) do { \
    PACKED_glXChooseVisual *unpacked = (PACKED_glXChooseVisual *)packed; \
    ARGS_glXChooseVisual *args = (ARGS_glXChooseVisual *)&unpacked->args; \
    XVisualInfo * *ret = (XVisualInfo * *)ret_v; \
    if (ret != NULL) { \
        *ret = glXChooseVisual(args->dpy, args->screen, args->attribList);; \
    } else { \
        glXChooseVisual(args->dpy, args->screen, args->attribList);; \
    } \
} while(0)
XVisualInfo * glXChooseVisual(glXChooseVisual_ARG_EXPAND);
typedef XVisualInfo * (*glXChooseVisual_PTR)(glXChooseVisual_ARG_EXPAND);
#define glXClientInfo_INDEX 2720
#define glXClientInfo_RETURN void
#define glXClientInfo_ARG_NAMES 
#define glXClientInfo_ARG_EXPAND 
#define glXClientInfo_PACKED PACKED_glXClientInfo
#define glXClientInfo_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glXClientInfo_NOT_VOID_WRAP(...) {}
#define pack_glXClientInfo() ({ \
    glXClientInfo_PACKED *packed_data = malloc(sizeof(glXClientInfo_PACKED)); \
    packed_data->index = glXClientInfo_INDEX; \
    (packed_call_t *)packed_data; \
})
#define call_glXClientInfo(packed, ret_v) do { \
    glXClientInfo();; \
} while(0)
void glXClientInfo(glXClientInfo_ARG_EXPAND);
typedef void (*glXClientInfo_PTR)(glXClientInfo_ARG_EXPAND);
#define glXCopyContext_INDEX 2721
#define glXCopyContext_RETURN void
#define glXCopyContext_ARG_NAMES dpy, src, dst, mask
#define glXCopyContext_ARG_EXPAND Display * dpy, GLXContext src, GLXContext dst, unsigned long mask
#define glXCopyContext_PACKED PACKED_glXCopyContext
#define glXCopyContext_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glXCopyContext_NOT_VOID_WRAP(...) {}
#define pack_glXCopyContext(_dpy, _src, _dst, _mask) ({ \
    glXCopyContext_PACKED *packed_data = malloc(sizeof(glXCopyContext_PACKED)); \
    packed_data->index = glXCopyContext_INDEX; \
    packed_data->args.dpy = (Display *)_dpy; \
    packed_data->args.src = (GLXContext)_src; \
    packed_data->args.dst = (GLXContext)_dst; \
    packed_data->args.mask = (unsigned long)_mask; \
    (packed_call_t *)packed_data; \
})
#define call_glXCopyContext(packed, ret_v) do { \
    PACKED_glXCopyContext *unpacked = (PACKED_glXCopyContext *)packed; \
    ARGS_glXCopyContext *args = (ARGS_glXCopyContext *)&unpacked->args; \
    glXCopyContext(args->dpy, args->src, args->dst, args->mask);; \
} while(0)
void glXCopyContext(glXCopyContext_ARG_EXPAND);
typedef void (*glXCopyContext_PTR)(glXCopyContext_ARG_EXPAND);
#define glXCopyImageSubDataNV_INDEX 2722
#define glXCopyImageSubDataNV_RETURN void
#define glXCopyImageSubDataNV_ARG_NAMES dpy, srcCtx, srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstCtx, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, width, height, depth
#define glXCopyImageSubDataNV_ARG_EXPAND Display * dpy, GLXContext srcCtx, GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLXContext dstCtx, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei width, GLsizei height, GLsizei depth
#define glXCopyImageSubDataNV_PACKED PACKED_glXCopyImageSubDataNV
#define glXCopyImageSubDataNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glXCopyImageSubDataNV_NOT_VOID_WRAP(...) {}
#define pack_glXCopyImageSubDataNV(_dpy, _srcCtx, _srcName, _srcTarget, _srcLevel, _srcX, _srcY, _srcZ, _dstCtx, _dstName, _dstTarget, _dstLevel, _dstX, _dstY, _dstZ, _width, _height, _depth) ({ \
    glXCopyImageSubDataNV_PACKED *packed_data = malloc(sizeof(glXCopyImageSubDataNV_PACKED)); \
    packed_data->index = glXCopyImageSubDataNV_INDEX; \
    packed_data->args.dpy = (Display *)_dpy; \
    packed_data->args.srcCtx = (GLXContext)_srcCtx; \
    packed_data->args.srcName = (GLuint)_srcName; \
    packed_data->args.srcTarget = (GLenum)_srcTarget; \
    packed_data->args.srcLevel = (GLint)_srcLevel; \
    packed_data->args.srcX = (GLint)_srcX; \
    packed_data->args.srcY = (GLint)_srcY; \
    packed_data->args.srcZ = (GLint)_srcZ; \
    packed_data->args.dstCtx = (GLXContext)_dstCtx; \
    packed_data->args.dstName = (GLuint)_dstName; \
    packed_data->args.dstTarget = (GLenum)_dstTarget; \
    packed_data->args.dstLevel = (GLint)_dstLevel; \
    packed_data->args.dstX = (GLint)_dstX; \
    packed_data->args.dstY = (GLint)_dstY; \
    packed_data->args.dstZ = (GLint)_dstZ; \
    packed_data->args.width = (GLsizei)_width; \
    packed_data->args.height = (GLsizei)_height; \
    packed_data->args.depth = (GLsizei)_depth; \
    (packed_call_t *)packed_data; \
})
#define call_glXCopyImageSubDataNV(packed, ret_v) do { \
    PACKED_glXCopyImageSubDataNV *unpacked = (PACKED_glXCopyImageSubDataNV *)packed; \
    ARGS_glXCopyImageSubDataNV *args = (ARGS_glXCopyImageSubDataNV *)&unpacked->args; \
    glXCopyImageSubDataNV(args->dpy, args->srcCtx, args->srcName, args->srcTarget, args->srcLevel, args->srcX, args->srcY, args->srcZ, args->dstCtx, args->dstName, args->dstTarget, args->dstLevel, args->dstX, args->dstY, args->dstZ, args->width, args->height, args->depth);; \
} while(0)
void glXCopyImageSubDataNV(glXCopyImageSubDataNV_ARG_EXPAND);
typedef void (*glXCopyImageSubDataNV_PTR)(glXCopyImageSubDataNV_ARG_EXPAND);
#define glXCopySubBufferMESA_INDEX 2723
#define glXCopySubBufferMESA_RETURN void
#define glXCopySubBufferMESA_ARG_NAMES dpy, drawable, x, y, width, height
#define glXCopySubBufferMESA_ARG_EXPAND Display * dpy, GLXDrawable drawable, int x, int y, int width, int height
#define glXCopySubBufferMESA_PACKED PACKED_glXCopySubBufferMESA
#define glXCopySubBufferMESA_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glXCopySubBufferMESA_NOT_VOID_WRAP(...) {}
#define pack_glXCopySubBufferMESA(_dpy, _drawable, _x, _y, _width, _height) ({ \
    glXCopySubBufferMESA_PACKED *packed_data = malloc(sizeof(glXCopySubBufferMESA_PACKED)); \
    packed_data->index = glXCopySubBufferMESA_INDEX; \
    packed_data->args.dpy = (Display *)_dpy; \
    packed_data->args.drawable = (GLXDrawable)_drawable; \
    packed_data->args.x = (int)_x; \
    packed_data->args.y = (int)_y; \
    packed_data->args.width = (int)_width; \
    packed_data->args.height = (int)_height; \
    (packed_call_t *)packed_data; \
})
#define call_glXCopySubBufferMESA(packed, ret_v) do { \
    PACKED_glXCopySubBufferMESA *unpacked = (PACKED_glXCopySubBufferMESA *)packed; \
    ARGS_glXCopySubBufferMESA *args = (ARGS_glXCopySubBufferMESA *)&unpacked->args; \
    glXCopySubBufferMESA(args->dpy, args->drawable, args->x, args->y, args->width, args->height);; \
} while(0)
void glXCopySubBufferMESA(glXCopySubBufferMESA_ARG_EXPAND);
typedef void (*glXCopySubBufferMESA_PTR)(glXCopySubBufferMESA_ARG_EXPAND);
#define glXCreateContext_INDEX 2724
#define glXCreateContext_RETURN GLXContext
#define glXCreateContext_ARG_NAMES dpy, vis, shareList, direct
#define glXCreateContext_ARG_EXPAND Display * dpy, XVisualInfo * vis, GLXContext shareList, Bool direct
#define glXCreateContext_PACKED PACKED_glXCreateContext
#define glXCreateContext_VOID_ONLY_WRAP(...) {}
#define glXCreateContext_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glXCreateContext(_dpy, _vis, _shareList, _direct) ({ \
    glXCreateContext_PACKED *packed_data = malloc(sizeof(glXCreateContext_PACKED)); \
    packed_data->index = glXCreateContext_INDEX; \
    packed_data->args.dpy = (Display *)_dpy; \
    packed_data->args.vis = (XVisualInfo *)_vis; \
    packed_data->args.shareList = (GLXContext)_shareList; \
    packed_data->args.direct = (Bool)_direct; \
    (packed_call_t *)packed_data; \
})
#define call_glXCreateContext(packed, ret_v) do { \
    PACKED_glXCreateContext *unpacked = (PACKED_glXCreateContext *)packed; \
    ARGS_glXCreateContext *args = (ARGS_glXCreateContext *)&unpacked->args; \
    GLXContext *ret = (GLXContext *)ret_v; \
    if (ret != NULL) { \
        *ret = glXCreateContext(args->dpy, args->vis, args->shareList, args->direct);; \
    } else { \
        glXCreateContext(args->dpy, args->vis, args->shareList, args->direct);; \
    } \
} while(0)
GLXContext glXCreateContext(glXCreateContext_ARG_EXPAND);
typedef GLXContext (*glXCreateContext_PTR)(glXCreateContext_ARG_EXPAND);
#define glXCreateContextAttribsARB_INDEX 2725
#define glXCreateContextAttribsARB_RETURN GLXContext
#define glXCreateContextAttribsARB_ARG_NAMES dpy, config, share_context, direct, attrib_list
#define glXCreateContextAttribsARB_ARG_EXPAND Display * dpy, GLXFBConfig config, GLXContext share_context, Bool direct, const int * attrib_list
#define glXCreateContextAttribsARB_PACKED PACKED_glXCreateContextAttribsARB
#define glXCreateContextAttribsARB_VOID_ONLY_WRAP(...) {}
#define glXCreateContextAttribsARB_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glXCreateContextAttribsARB(_dpy, _config, _share_context, _direct, _attrib_list) ({ \
    glXCreateContextAttribsARB_PACKED *packed_data = malloc(sizeof(glXCreateContextAttribsARB_PACKED)); \
    packed_data->index = glXCreateContextAttribsARB_INDEX; \
    packed_data->args.dpy = (Display *)_dpy; \
    packed_data->args.config = (GLXFBConfig)_config; \
    packed_data->args.share_context = (GLXContext)_share_context; \
    packed_data->args.direct = (Bool)_direct; \
    packed_data->args.attrib_list = (int *)_attrib_list; \
    (packed_call_t *)packed_data; \
})
#define call_glXCreateContextAttribsARB(packed, ret_v) do { \
    PACKED_glXCreateContextAttribsARB *unpacked = (PACKED_glXCreateContextAttribsARB *)packed; \
    ARGS_glXCreateContextAttribsARB *args = (ARGS_glXCreateContextAttribsARB *)&unpacked->args; \
    GLXContext *ret = (GLXContext *)ret_v; \
    if (ret != NULL) { \
        *ret = glXCreateContextAttribsARB(args->dpy, args->config, args->share_context, args->direct, args->attrib_list);; \
    } else { \
        glXCreateContextAttribsARB(args->dpy, args->config, args->share_context, args->direct, args->attrib_list);; \
    } \
} while(0)
GLXContext glXCreateContextAttribsARB(glXCreateContextAttribsARB_ARG_EXPAND);
typedef GLXContext (*glXCreateContextAttribsARB_PTR)(glXCreateContextAttribsARB_ARG_EXPAND);
#define glXCreateContextWithConfigSGIX_INDEX 2726
#define glXCreateContextWithConfigSGIX_RETURN GLXContext
#define glXCreateContextWithConfigSGIX_ARG_NAMES dpy, config, render_type, share_list, direct
#define glXCreateContextWithConfigSGIX_ARG_EXPAND Display * dpy, GLXFBConfigSGIX config, int render_type, GLXContext share_list, Bool direct
#define glXCreateContextWithConfigSGIX_PACKED PACKED_glXCreateContextWithConfigSGIX
#define glXCreateContextWithConfigSGIX_VOID_ONLY_WRAP(...) {}
#define glXCreateContextWithConfigSGIX_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glXCreateContextWithConfigSGIX(_dpy, _config, _render_type, _share_list, _direct) ({ \
    glXCreateContextWithConfigSGIX_PACKED *packed_data = malloc(sizeof(glXCreateContextWithConfigSGIX_PACKED)); \
    packed_data->index = glXCreateContextWithConfigSGIX_INDEX; \
    packed_data->args.dpy = (Display *)_dpy; \
    packed_data->args.config = (GLXFBConfigSGIX)_config; \
    packed_data->args.render_type = (int)_render_type; \
    packed_data->args.share_list = (GLXContext)_share_list; \
    packed_data->args.direct = (Bool)_direct; \
    (packed_call_t *)packed_data; \
})
#define call_glXCreateContextWithConfigSGIX(packed, ret_v) do { \
    PACKED_glXCreateContextWithConfigSGIX *unpacked = (PACKED_glXCreateContextWithConfigSGIX *)packed; \
    ARGS_glXCreateContextWithConfigSGIX *args = (ARGS_glXCreateContextWithConfigSGIX *)&unpacked->args; \
    GLXContext *ret = (GLXContext *)ret_v; \
    if (ret != NULL) { \
        *ret = glXCreateContextWithConfigSGIX(args->dpy, args->config, args->render_type, args->share_list, args->direct);; \
    } else { \
        glXCreateContextWithConfigSGIX(args->dpy, args->config, args->render_type, args->share_list, args->direct);; \
    } \
} while(0)
GLXContext glXCreateContextWithConfigSGIX(glXCreateContextWithConfigSGIX_ARG_EXPAND);
typedef GLXContext (*glXCreateContextWithConfigSGIX_PTR)(glXCreateContextWithConfigSGIX_ARG_EXPAND);
#define glXCreateGLXPbufferSGIX_INDEX 2727
#define glXCreateGLXPbufferSGIX_RETURN GLXPbufferSGIX
#define glXCreateGLXPbufferSGIX_ARG_NAMES dpy, config, width, height, attrib_list
#define glXCreateGLXPbufferSGIX_ARG_EXPAND Display * dpy, GLXFBConfigSGIX config, unsigned int width, unsigned int height, int * attrib_list
#define glXCreateGLXPbufferSGIX_PACKED PACKED_glXCreateGLXPbufferSGIX
#define glXCreateGLXPbufferSGIX_VOID_ONLY_WRAP(...) {}
#define glXCreateGLXPbufferSGIX_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glXCreateGLXPbufferSGIX(_dpy, _config, _width, _height, _attrib_list) ({ \
    glXCreateGLXPbufferSGIX_PACKED *packed_data = malloc(sizeof(glXCreateGLXPbufferSGIX_PACKED)); \
    packed_data->index = glXCreateGLXPbufferSGIX_INDEX; \
    packed_data->args.dpy = (Display *)_dpy; \
    packed_data->args.config = (GLXFBConfigSGIX)_config; \
    packed_data->args.width = (unsigned int)_width; \
    packed_data->args.height = (unsigned int)_height; \
    packed_data->args.attrib_list = (int *)_attrib_list; \
    (packed_call_t *)packed_data; \
})
#define call_glXCreateGLXPbufferSGIX(packed, ret_v) do { \
    PACKED_glXCreateGLXPbufferSGIX *unpacked = (PACKED_glXCreateGLXPbufferSGIX *)packed; \
    ARGS_glXCreateGLXPbufferSGIX *args = (ARGS_glXCreateGLXPbufferSGIX *)&unpacked->args; \
    GLXPbufferSGIX *ret = (GLXPbufferSGIX *)ret_v; \
    if (ret != NULL) { \
        *ret = glXCreateGLXPbufferSGIX(args->dpy, args->config, args->width, args->height, args->attrib_list);; \
    } else { \
        glXCreateGLXPbufferSGIX(args->dpy, args->config, args->width, args->height, args->attrib_list);; \
    } \
} while(0)
GLXPbufferSGIX glXCreateGLXPbufferSGIX(glXCreateGLXPbufferSGIX_ARG_EXPAND);
typedef GLXPbufferSGIX (*glXCreateGLXPbufferSGIX_PTR)(glXCreateGLXPbufferSGIX_ARG_EXPAND);
#define glXCreateGLXPixmap_INDEX 2728
#define glXCreateGLXPixmap_RETURN GLXPixmap
#define glXCreateGLXPixmap_ARG_NAMES dpy, visual, pixmap
#define glXCreateGLXPixmap_ARG_EXPAND Display * dpy, XVisualInfo * visual, Pixmap pixmap
#define glXCreateGLXPixmap_PACKED PACKED_glXCreateGLXPixmap
#define glXCreateGLXPixmap_VOID_ONLY_WRAP(...) {}
#define glXCreateGLXPixmap_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glXCreateGLXPixmap(_dpy, _visual, _pixmap) ({ \
    glXCreateGLXPixmap_PACKED *packed_data = malloc(sizeof(glXCreateGLXPixmap_PACKED)); \
    packed_data->index = glXCreateGLXPixmap_INDEX; \
    packed_data->args.dpy = (Display *)_dpy; \
    packed_data->args.visual = (XVisualInfo *)_visual; \
    packed_data->args.pixmap = (Pixmap)_pixmap; \
    (packed_call_t *)packed_data; \
})
#define call_glXCreateGLXPixmap(packed, ret_v) do { \
    PACKED_glXCreateGLXPixmap *unpacked = (PACKED_glXCreateGLXPixmap *)packed; \
    ARGS_glXCreateGLXPixmap *args = (ARGS_glXCreateGLXPixmap *)&unpacked->args; \
    GLXPixmap *ret = (GLXPixmap *)ret_v; \
    if (ret != NULL) { \
        *ret = glXCreateGLXPixmap(args->dpy, args->visual, args->pixmap);; \
    } else { \
        glXCreateGLXPixmap(args->dpy, args->visual, args->pixmap);; \
    } \
} while(0)
GLXPixmap glXCreateGLXPixmap(glXCreateGLXPixmap_ARG_EXPAND);
typedef GLXPixmap (*glXCreateGLXPixmap_PTR)(glXCreateGLXPixmap_ARG_EXPAND);
#define glXCreateGLXPixmapMESA_INDEX 2729
#define glXCreateGLXPixmapMESA_RETURN GLXPixmap
#define glXCreateGLXPixmapMESA_ARG_NAMES dpy, visual, pixmap, cmap
#define glXCreateGLXPixmapMESA_ARG_EXPAND Display * dpy, XVisualInfo * visual, Pixmap pixmap, Colormap cmap
#define glXCreateGLXPixmapMESA_PACKED PACKED_glXCreateGLXPixmapMESA
#define glXCreateGLXPixmapMESA_VOID_ONLY_WRAP(...) {}
#define glXCreateGLXPixmapMESA_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glXCreateGLXPixmapMESA(_dpy, _visual, _pixmap, _cmap) ({ \
    glXCreateGLXPixmapMESA_PACKED *packed_data = malloc(sizeof(glXCreateGLXPixmapMESA_PACKED)); \
    packed_data->index = glXCreateGLXPixmapMESA_INDEX; \
    packed_data->args.dpy = (Display *)_dpy; \
    packed_data->args.visual = (XVisualInfo *)_visual; \
    packed_data->args.pixmap = (Pixmap)_pixmap; \
    packed_data->args.cmap = (Colormap)_cmap; \
    (packed_call_t *)packed_data; \
})
#define call_glXCreateGLXPixmapMESA(packed, ret_v) do { \
    PACKED_glXCreateGLXPixmapMESA *unpacked = (PACKED_glXCreateGLXPixmapMESA *)packed; \
    ARGS_glXCreateGLXPixmapMESA *args = (ARGS_glXCreateGLXPixmapMESA *)&unpacked->args; \
    GLXPixmap *ret = (GLXPixmap *)ret_v; \
    if (ret != NULL) { \
        *ret = glXCreateGLXPixmapMESA(args->dpy, args->visual, args->pixmap, args->cmap);; \
    } else { \
        glXCreateGLXPixmapMESA(args->dpy, args->visual, args->pixmap, args->cmap);; \
    } \
} while(0)
GLXPixmap glXCreateGLXPixmapMESA(glXCreateGLXPixmapMESA_ARG_EXPAND);
typedef GLXPixmap (*glXCreateGLXPixmapMESA_PTR)(glXCreateGLXPixmapMESA_ARG_EXPAND);
#define glXCreateGLXPixmapWithConfigSGIX_INDEX 2730
#define glXCreateGLXPixmapWithConfigSGIX_RETURN GLXPixmap
#define glXCreateGLXPixmapWithConfigSGIX_ARG_NAMES dpy, config, pixmap
#define glXCreateGLXPixmapWithConfigSGIX_ARG_EXPAND Display * dpy, GLXFBConfigSGIX config, Pixmap pixmap
#define glXCreateGLXPixmapWithConfigSGIX_PACKED PACKED_glXCreateGLXPixmapWithConfigSGIX
#define glXCreateGLXPixmapWithConfigSGIX_VOID_ONLY_WRAP(...) {}
#define glXCreateGLXPixmapWithConfigSGIX_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glXCreateGLXPixmapWithConfigSGIX(_dpy, _config, _pixmap) ({ \
    glXCreateGLXPixmapWithConfigSGIX_PACKED *packed_data = malloc(sizeof(glXCreateGLXPixmapWithConfigSGIX_PACKED)); \
    packed_data->index = glXCreateGLXPixmapWithConfigSGIX_INDEX; \
    packed_data->args.dpy = (Display *)_dpy; \
    packed_data->args.config = (GLXFBConfigSGIX)_config; \
    packed_data->args.pixmap = (Pixmap)_pixmap; \
    (packed_call_t *)packed_data; \
})
#define call_glXCreateGLXPixmapWithConfigSGIX(packed, ret_v) do { \
    PACKED_glXCreateGLXPixmapWithConfigSGIX *unpacked = (PACKED_glXCreateGLXPixmapWithConfigSGIX *)packed; \
    ARGS_glXCreateGLXPixmapWithConfigSGIX *args = (ARGS_glXCreateGLXPixmapWithConfigSGIX *)&unpacked->args; \
    GLXPixmap *ret = (GLXPixmap *)ret_v; \
    if (ret != NULL) { \
        *ret = glXCreateGLXPixmapWithConfigSGIX(args->dpy, args->config, args->pixmap);; \
    } else { \
        glXCreateGLXPixmapWithConfigSGIX(args->dpy, args->config, args->pixmap);; \
    } \
} while(0)
GLXPixmap glXCreateGLXPixmapWithConfigSGIX(glXCreateGLXPixmapWithConfigSGIX_ARG_EXPAND);
typedef GLXPixmap (*glXCreateGLXPixmapWithConfigSGIX_PTR)(glXCreateGLXPixmapWithConfigSGIX_ARG_EXPAND);
#define glXCreateGLXVideoSourceSGIX_INDEX 2731
#define glXCreateGLXVideoSourceSGIX_RETURN GLXVideoSourceSGIX
#define glXCreateGLXVideoSourceSGIX_ARG_NAMES display, screen, server, path, nodeClass, drainNode
#define glXCreateGLXVideoSourceSGIX_ARG_EXPAND Display * display, int screen, VLServer server, VLPath path, int nodeClass, VLNode drainNode
#define glXCreateGLXVideoSourceSGIX_PACKED PACKED_glXCreateGLXVideoSourceSGIX
#define glXCreateGLXVideoSourceSGIX_VOID_ONLY_WRAP(...) {}
#define glXCreateGLXVideoSourceSGIX_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glXCreateGLXVideoSourceSGIX(_display, _screen, _server, _path, _nodeClass, _drainNode) ({ \
    glXCreateGLXVideoSourceSGIX_PACKED *packed_data = malloc(sizeof(glXCreateGLXVideoSourceSGIX_PACKED)); \
    packed_data->index = glXCreateGLXVideoSourceSGIX_INDEX; \
    packed_data->args.display = (Display *)_display; \
    packed_data->args.screen = (int)_screen; \
    packed_data->args.server = (VLServer)_server; \
    packed_data->args.path = (VLPath)_path; \
    packed_data->args.nodeClass = (int)_nodeClass; \
    packed_data->args.drainNode = (VLNode)_drainNode; \
    (packed_call_t *)packed_data; \
})
#define call_glXCreateGLXVideoSourceSGIX(packed, ret_v) do { \
    PACKED_glXCreateGLXVideoSourceSGIX *unpacked = (PACKED_glXCreateGLXVideoSourceSGIX *)packed; \
    ARGS_glXCreateGLXVideoSourceSGIX *args = (ARGS_glXCreateGLXVideoSourceSGIX *)&unpacked->args; \
    GLXVideoSourceSGIX *ret = (GLXVideoSourceSGIX *)ret_v; \
    if (ret != NULL) { \
        *ret = glXCreateGLXVideoSourceSGIX(args->display, args->screen, args->server, args->path, args->nodeClass, args->drainNode);; \
    } else { \
        glXCreateGLXVideoSourceSGIX(args->display, args->screen, args->server, args->path, args->nodeClass, args->drainNode);; \
    } \
} while(0)
GLXVideoSourceSGIX glXCreateGLXVideoSourceSGIX(glXCreateGLXVideoSourceSGIX_ARG_EXPAND);
typedef GLXVideoSourceSGIX (*glXCreateGLXVideoSourceSGIX_PTR)(glXCreateGLXVideoSourceSGIX_ARG_EXPAND);
#define glXCreateNewContext_INDEX 2732
#define glXCreateNewContext_RETURN GLXContext
#define glXCreateNewContext_ARG_NAMES dpy, config, render_type, share_list, direct
#define glXCreateNewContext_ARG_EXPAND Display * dpy, GLXFBConfig config, int render_type, GLXContext share_list, Bool direct
#define glXCreateNewContext_PACKED PACKED_glXCreateNewContext
#define glXCreateNewContext_VOID_ONLY_WRAP(...) {}
#define glXCreateNewContext_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glXCreateNewContext(_dpy, _config, _render_type, _share_list, _direct) ({ \
    glXCreateNewContext_PACKED *packed_data = malloc(sizeof(glXCreateNewContext_PACKED)); \
    packed_data->index = glXCreateNewContext_INDEX; \
    packed_data->args.dpy = (Display *)_dpy; \
    packed_data->args.config = (GLXFBConfig)_config; \
    packed_data->args.render_type = (int)_render_type; \
    packed_data->args.share_list = (GLXContext)_share_list; \
    packed_data->args.direct = (Bool)_direct; \
    (packed_call_t *)packed_data; \
})
#define call_glXCreateNewContext(packed, ret_v) do { \
    PACKED_glXCreateNewContext *unpacked = (PACKED_glXCreateNewContext *)packed; \
    ARGS_glXCreateNewContext *args = (ARGS_glXCreateNewContext *)&unpacked->args; \
    GLXContext *ret = (GLXContext *)ret_v; \
    if (ret != NULL) { \
        *ret = glXCreateNewContext(args->dpy, args->config, args->render_type, args->share_list, args->direct);; \
    } else { \
        glXCreateNewContext(args->dpy, args->config, args->render_type, args->share_list, args->direct);; \
    } \
} while(0)
GLXContext glXCreateNewContext(glXCreateNewContext_ARG_EXPAND);
typedef GLXContext (*glXCreateNewContext_PTR)(glXCreateNewContext_ARG_EXPAND);
#define glXCreatePbuffer_INDEX 2733
#define glXCreatePbuffer_RETURN GLXPbuffer
#define glXCreatePbuffer_ARG_NAMES dpy, config, attrib_list
#define glXCreatePbuffer_ARG_EXPAND Display * dpy, GLXFBConfig config, const int * attrib_list
#define glXCreatePbuffer_PACKED PACKED_glXCreatePbuffer
#define glXCreatePbuffer_VOID_ONLY_WRAP(...) {}
#define glXCreatePbuffer_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glXCreatePbuffer(_dpy, _config, _attrib_list) ({ \
    glXCreatePbuffer_PACKED *packed_data = malloc(sizeof(glXCreatePbuffer_PACKED)); \
    packed_data->index = glXCreatePbuffer_INDEX; \
    packed_data->args.dpy = (Display *)_dpy; \
    packed_data->args.config = (GLXFBConfig)_config; \
    packed_data->args.attrib_list = (int *)_attrib_list; \
    (packed_call_t *)packed_data; \
})
#define call_glXCreatePbuffer(packed, ret_v) do { \
    PACKED_glXCreatePbuffer *unpacked = (PACKED_glXCreatePbuffer *)packed; \
    ARGS_glXCreatePbuffer *args = (ARGS_glXCreatePbuffer *)&unpacked->args; \
    GLXPbuffer *ret = (GLXPbuffer *)ret_v; \
    if (ret != NULL) { \
        *ret = glXCreatePbuffer(args->dpy, args->config, args->attrib_list);; \
    } else { \
        glXCreatePbuffer(args->dpy, args->config, args->attrib_list);; \
    } \
} while(0)
GLXPbuffer glXCreatePbuffer(glXCreatePbuffer_ARG_EXPAND);
typedef GLXPbuffer (*glXCreatePbuffer_PTR)(glXCreatePbuffer_ARG_EXPAND);
#define glXCreatePixmap_INDEX 2734
#define glXCreatePixmap_RETURN GLXPixmap
#define glXCreatePixmap_ARG_NAMES dpy, config, pixmap, attrib_list
#define glXCreatePixmap_ARG_EXPAND Display * dpy, GLXFBConfig config, Pixmap pixmap, const int * attrib_list
#define glXCreatePixmap_PACKED PACKED_glXCreatePixmap
#define glXCreatePixmap_VOID_ONLY_WRAP(...) {}
#define glXCreatePixmap_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glXCreatePixmap(_dpy, _config, _pixmap, _attrib_list) ({ \
    glXCreatePixmap_PACKED *packed_data = malloc(sizeof(glXCreatePixmap_PACKED)); \
    packed_data->index = glXCreatePixmap_INDEX; \
    packed_data->args.dpy = (Display *)_dpy; \
    packed_data->args.config = (GLXFBConfig)_config; \
    packed_data->args.pixmap = (Pixmap)_pixmap; \
    packed_data->args.attrib_list = (int *)_attrib_list; \
    (packed_call_t *)packed_data; \
})
#define call_glXCreatePixmap(packed, ret_v) do { \
    PACKED_glXCreatePixmap *unpacked = (PACKED_glXCreatePixmap *)packed; \
    ARGS_glXCreatePixmap *args = (ARGS_glXCreatePixmap *)&unpacked->args; \
    GLXPixmap *ret = (GLXPixmap *)ret_v; \
    if (ret != NULL) { \
        *ret = glXCreatePixmap(args->dpy, args->config, args->pixmap, args->attrib_list);; \
    } else { \
        glXCreatePixmap(args->dpy, args->config, args->pixmap, args->attrib_list);; \
    } \
} while(0)
GLXPixmap glXCreatePixmap(glXCreatePixmap_ARG_EXPAND);
typedef GLXPixmap (*glXCreatePixmap_PTR)(glXCreatePixmap_ARG_EXPAND);
#define glXCreateWindow_INDEX 2735
#define glXCreateWindow_RETURN GLXWindow
#define glXCreateWindow_ARG_NAMES dpy, config, win, attrib_list
#define glXCreateWindow_ARG_EXPAND Display * dpy, GLXFBConfig config, Window win, const int * attrib_list
#define glXCreateWindow_PACKED PACKED_glXCreateWindow
#define glXCreateWindow_VOID_ONLY_WRAP(...) {}
#define glXCreateWindow_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glXCreateWindow(_dpy, _config, _win, _attrib_list) ({ \
    glXCreateWindow_PACKED *packed_data = malloc(sizeof(glXCreateWindow_PACKED)); \
    packed_data->index = glXCreateWindow_INDEX; \
    packed_data->args.dpy = (Display *)_dpy; \
    packed_data->args.config = (GLXFBConfig)_config; \
    packed_data->args.win = (Window)_win; \
    packed_data->args.attrib_list = (int *)_attrib_list; \
    (packed_call_t *)packed_data; \
})
#define call_glXCreateWindow(packed, ret_v) do { \
    PACKED_glXCreateWindow *unpacked = (PACKED_glXCreateWindow *)packed; \
    ARGS_glXCreateWindow *args = (ARGS_glXCreateWindow *)&unpacked->args; \
    GLXWindow *ret = (GLXWindow *)ret_v; \
    if (ret != NULL) { \
        *ret = glXCreateWindow(args->dpy, args->config, args->win, args->attrib_list);; \
    } else { \
        glXCreateWindow(args->dpy, args->config, args->win, args->attrib_list);; \
    } \
} while(0)
GLXWindow glXCreateWindow(glXCreateWindow_ARG_EXPAND);
typedef GLXWindow (*glXCreateWindow_PTR)(glXCreateWindow_ARG_EXPAND);
#define glXCushionSGI_INDEX 2736
#define glXCushionSGI_RETURN void
#define glXCushionSGI_ARG_NAMES dpy, window, cushion
#define glXCushionSGI_ARG_EXPAND Display * dpy, Window window, float cushion
#define glXCushionSGI_PACKED PACKED_glXCushionSGI
#define glXCushionSGI_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glXCushionSGI_NOT_VOID_WRAP(...) {}
#define pack_glXCushionSGI(_dpy, _window, _cushion) ({ \
    glXCushionSGI_PACKED *packed_data = malloc(sizeof(glXCushionSGI_PACKED)); \
    packed_data->index = glXCushionSGI_INDEX; \
    packed_data->args.dpy = (Display *)_dpy; \
    packed_data->args.window = (Window)_window; \
    packed_data->args.cushion = (float)_cushion; \
    (packed_call_t *)packed_data; \
})
#define call_glXCushionSGI(packed, ret_v) do { \
    PACKED_glXCushionSGI *unpacked = (PACKED_glXCushionSGI *)packed; \
    ARGS_glXCushionSGI *args = (ARGS_glXCushionSGI *)&unpacked->args; \
    glXCushionSGI(args->dpy, args->window, args->cushion);; \
} while(0)
void glXCushionSGI(glXCushionSGI_ARG_EXPAND);
typedef void (*glXCushionSGI_PTR)(glXCushionSGI_ARG_EXPAND);
#define glXDestroyContext_INDEX 2737
#define glXDestroyContext_RETURN void
#define glXDestroyContext_ARG_NAMES dpy, ctx
#define glXDestroyContext_ARG_EXPAND Display * dpy, GLXContext ctx
#define glXDestroyContext_PACKED PACKED_glXDestroyContext
#define glXDestroyContext_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glXDestroyContext_NOT_VOID_WRAP(...) {}
#define pack_glXDestroyContext(_dpy, _ctx) ({ \
    glXDestroyContext_PACKED *packed_data = malloc(sizeof(glXDestroyContext_PACKED)); \
    packed_data->index = glXDestroyContext_INDEX; \
    packed_data->args.dpy = (Display *)_dpy; \
    packed_data->args.ctx = (GLXContext)_ctx; \
    (packed_call_t *)packed_data; \
})
#define call_glXDestroyContext(packed, ret_v) do { \
    PACKED_glXDestroyContext *unpacked = (PACKED_glXDestroyContext *)packed; \
    ARGS_glXDestroyContext *args = (ARGS_glXDestroyContext *)&unpacked->args; \
    glXDestroyContext(args->dpy, args->ctx);; \
} while(0)
void glXDestroyContext(glXDestroyContext_ARG_EXPAND);
typedef void (*glXDestroyContext_PTR)(glXDestroyContext_ARG_EXPAND);
#define glXDestroyGLXPbufferSGIX_INDEX 2738
#define glXDestroyGLXPbufferSGIX_RETURN void
#define glXDestroyGLXPbufferSGIX_ARG_NAMES dpy, pbuf
#define glXDestroyGLXPbufferSGIX_ARG_EXPAND Display * dpy, GLXPbufferSGIX pbuf
#define glXDestroyGLXPbufferSGIX_PACKED PACKED_glXDestroyGLXPbufferSGIX
#define glXDestroyGLXPbufferSGIX_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glXDestroyGLXPbufferSGIX_NOT_VOID_WRAP(...) {}
#define pack_glXDestroyGLXPbufferSGIX(_dpy, _pbuf) ({ \
    glXDestroyGLXPbufferSGIX_PACKED *packed_data = malloc(sizeof(glXDestroyGLXPbufferSGIX_PACKED)); \
    packed_data->index = glXDestroyGLXPbufferSGIX_INDEX; \
    packed_data->args.dpy = (Display *)_dpy; \
    packed_data->args.pbuf = (GLXPbufferSGIX)_pbuf; \
    (packed_call_t *)packed_data; \
})
#define call_glXDestroyGLXPbufferSGIX(packed, ret_v) do { \
    PACKED_glXDestroyGLXPbufferSGIX *unpacked = (PACKED_glXDestroyGLXPbufferSGIX *)packed; \
    ARGS_glXDestroyGLXPbufferSGIX *args = (ARGS_glXDestroyGLXPbufferSGIX *)&unpacked->args; \
    glXDestroyGLXPbufferSGIX(args->dpy, args->pbuf);; \
} while(0)
void glXDestroyGLXPbufferSGIX(glXDestroyGLXPbufferSGIX_ARG_EXPAND);
typedef void (*glXDestroyGLXPbufferSGIX_PTR)(glXDestroyGLXPbufferSGIX_ARG_EXPAND);
#define glXDestroyGLXPixmap_INDEX 2739
#define glXDestroyGLXPixmap_RETURN void
#define glXDestroyGLXPixmap_ARG_NAMES dpy, pixmap
#define glXDestroyGLXPixmap_ARG_EXPAND Display * dpy, GLXPixmap pixmap
#define glXDestroyGLXPixmap_PACKED PACKED_glXDestroyGLXPixmap
#define glXDestroyGLXPixmap_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glXDestroyGLXPixmap_NOT_VOID_WRAP(...) {}
#define pack_glXDestroyGLXPixmap(_dpy, _pixmap) ({ \
    glXDestroyGLXPixmap_PACKED *packed_data = malloc(sizeof(glXDestroyGLXPixmap_PACKED)); \
    packed_data->index = glXDestroyGLXPixmap_INDEX; \
    packed_data->args.dpy = (Display *)_dpy; \
    packed_data->args.pixmap = (GLXPixmap)_pixmap; \
    (packed_call_t *)packed_data; \
})
#define call_glXDestroyGLXPixmap(packed, ret_v) do { \
    PACKED_glXDestroyGLXPixmap *unpacked = (PACKED_glXDestroyGLXPixmap *)packed; \
    ARGS_glXDestroyGLXPixmap *args = (ARGS_glXDestroyGLXPixmap *)&unpacked->args; \
    glXDestroyGLXPixmap(args->dpy, args->pixmap);; \
} while(0)
void glXDestroyGLXPixmap(glXDestroyGLXPixmap_ARG_EXPAND);
typedef void (*glXDestroyGLXPixmap_PTR)(glXDestroyGLXPixmap_ARG_EXPAND);
#define glXDestroyGLXVideoSourceSGIX_INDEX 2740
#define glXDestroyGLXVideoSourceSGIX_RETURN void
#define glXDestroyGLXVideoSourceSGIX_ARG_NAMES dpy, glxvideosource
#define glXDestroyGLXVideoSourceSGIX_ARG_EXPAND Display * dpy, GLXVideoSourceSGIX glxvideosource
#define glXDestroyGLXVideoSourceSGIX_PACKED PACKED_glXDestroyGLXVideoSourceSGIX
#define glXDestroyGLXVideoSourceSGIX_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glXDestroyGLXVideoSourceSGIX_NOT_VOID_WRAP(...) {}
#define pack_glXDestroyGLXVideoSourceSGIX(_dpy, _glxvideosource) ({ \
    glXDestroyGLXVideoSourceSGIX_PACKED *packed_data = malloc(sizeof(glXDestroyGLXVideoSourceSGIX_PACKED)); \
    packed_data->index = glXDestroyGLXVideoSourceSGIX_INDEX; \
    packed_data->args.dpy = (Display *)_dpy; \
    packed_data->args.glxvideosource = (GLXVideoSourceSGIX)_glxvideosource; \
    (packed_call_t *)packed_data; \
})
#define call_glXDestroyGLXVideoSourceSGIX(packed, ret_v) do { \
    PACKED_glXDestroyGLXVideoSourceSGIX *unpacked = (PACKED_glXDestroyGLXVideoSourceSGIX *)packed; \
    ARGS_glXDestroyGLXVideoSourceSGIX *args = (ARGS_glXDestroyGLXVideoSourceSGIX *)&unpacked->args; \
    glXDestroyGLXVideoSourceSGIX(args->dpy, args->glxvideosource);; \
} while(0)
void glXDestroyGLXVideoSourceSGIX(glXDestroyGLXVideoSourceSGIX_ARG_EXPAND);
typedef void (*glXDestroyGLXVideoSourceSGIX_PTR)(glXDestroyGLXVideoSourceSGIX_ARG_EXPAND);
#define glXDestroyHyperpipeConfigSGIX_INDEX 2741
#define glXDestroyHyperpipeConfigSGIX_RETURN int
#define glXDestroyHyperpipeConfigSGIX_ARG_NAMES dpy, hpId
#define glXDestroyHyperpipeConfigSGIX_ARG_EXPAND Display * dpy, int hpId
#define glXDestroyHyperpipeConfigSGIX_PACKED PACKED_glXDestroyHyperpipeConfigSGIX
#define glXDestroyHyperpipeConfigSGIX_VOID_ONLY_WRAP(...) {}
#define glXDestroyHyperpipeConfigSGIX_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glXDestroyHyperpipeConfigSGIX(_dpy, _hpId) ({ \
    glXDestroyHyperpipeConfigSGIX_PACKED *packed_data = malloc(sizeof(glXDestroyHyperpipeConfigSGIX_PACKED)); \
    packed_data->index = glXDestroyHyperpipeConfigSGIX_INDEX; \
    packed_data->args.dpy = (Display *)_dpy; \
    packed_data->args.hpId = (int)_hpId; \
    (packed_call_t *)packed_data; \
})
#define call_glXDestroyHyperpipeConfigSGIX(packed, ret_v) do { \
    PACKED_glXDestroyHyperpipeConfigSGIX *unpacked = (PACKED_glXDestroyHyperpipeConfigSGIX *)packed; \
    ARGS_glXDestroyHyperpipeConfigSGIX *args = (ARGS_glXDestroyHyperpipeConfigSGIX *)&unpacked->args; \
    int *ret = (int *)ret_v; \
    if (ret != NULL) { \
        *ret = glXDestroyHyperpipeConfigSGIX(args->dpy, args->hpId);; \
    } else { \
        glXDestroyHyperpipeConfigSGIX(args->dpy, args->hpId);; \
    } \
} while(0)
int glXDestroyHyperpipeConfigSGIX(glXDestroyHyperpipeConfigSGIX_ARG_EXPAND);
typedef int (*glXDestroyHyperpipeConfigSGIX_PTR)(glXDestroyHyperpipeConfigSGIX_ARG_EXPAND);
#define glXDestroyPbuffer_INDEX 2742
#define glXDestroyPbuffer_RETURN void
#define glXDestroyPbuffer_ARG_NAMES dpy, pbuf
#define glXDestroyPbuffer_ARG_EXPAND Display * dpy, GLXPbuffer pbuf
#define glXDestroyPbuffer_PACKED PACKED_glXDestroyPbuffer
#define glXDestroyPbuffer_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glXDestroyPbuffer_NOT_VOID_WRAP(...) {}
#define pack_glXDestroyPbuffer(_dpy, _pbuf) ({ \
    glXDestroyPbuffer_PACKED *packed_data = malloc(sizeof(glXDestroyPbuffer_PACKED)); \
    packed_data->index = glXDestroyPbuffer_INDEX; \
    packed_data->args.dpy = (Display *)_dpy; \
    packed_data->args.pbuf = (GLXPbuffer)_pbuf; \
    (packed_call_t *)packed_data; \
})
#define call_glXDestroyPbuffer(packed, ret_v) do { \
    PACKED_glXDestroyPbuffer *unpacked = (PACKED_glXDestroyPbuffer *)packed; \
    ARGS_glXDestroyPbuffer *args = (ARGS_glXDestroyPbuffer *)&unpacked->args; \
    glXDestroyPbuffer(args->dpy, args->pbuf);; \
} while(0)
void glXDestroyPbuffer(glXDestroyPbuffer_ARG_EXPAND);
typedef void (*glXDestroyPbuffer_PTR)(glXDestroyPbuffer_ARG_EXPAND);
#define glXDestroyPixmap_INDEX 2743
#define glXDestroyPixmap_RETURN void
#define glXDestroyPixmap_ARG_NAMES dpy, pixmap
#define glXDestroyPixmap_ARG_EXPAND Display * dpy, GLXPixmap pixmap
#define glXDestroyPixmap_PACKED PACKED_glXDestroyPixmap
#define glXDestroyPixmap_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glXDestroyPixmap_NOT_VOID_WRAP(...) {}
#define pack_glXDestroyPixmap(_dpy, _pixmap) ({ \
    glXDestroyPixmap_PACKED *packed_data = malloc(sizeof(glXDestroyPixmap_PACKED)); \
    packed_data->index = glXDestroyPixmap_INDEX; \
    packed_data->args.dpy = (Display *)_dpy; \
    packed_data->args.pixmap = (GLXPixmap)_pixmap; \
    (packed_call_t *)packed_data; \
})
#define call_glXDestroyPixmap(packed, ret_v) do { \
    PACKED_glXDestroyPixmap *unpacked = (PACKED_glXDestroyPixmap *)packed; \
    ARGS_glXDestroyPixmap *args = (ARGS_glXDestroyPixmap *)&unpacked->args; \
    glXDestroyPixmap(args->dpy, args->pixmap);; \
} while(0)
void glXDestroyPixmap(glXDestroyPixmap_ARG_EXPAND);
typedef void (*glXDestroyPixmap_PTR)(glXDestroyPixmap_ARG_EXPAND);
#define glXDestroyWindow_INDEX 2744
#define glXDestroyWindow_RETURN void
#define glXDestroyWindow_ARG_NAMES dpy, win
#define glXDestroyWindow_ARG_EXPAND Display * dpy, GLXWindow win
#define glXDestroyWindow_PACKED PACKED_glXDestroyWindow
#define glXDestroyWindow_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glXDestroyWindow_NOT_VOID_WRAP(...) {}
#define pack_glXDestroyWindow(_dpy, _win) ({ \
    glXDestroyWindow_PACKED *packed_data = malloc(sizeof(glXDestroyWindow_PACKED)); \
    packed_data->index = glXDestroyWindow_INDEX; \
    packed_data->args.dpy = (Display *)_dpy; \
    packed_data->args.win = (GLXWindow)_win; \
    (packed_call_t *)packed_data; \
})
#define call_glXDestroyWindow(packed, ret_v) do { \
    PACKED_glXDestroyWindow *unpacked = (PACKED_glXDestroyWindow *)packed; \
    ARGS_glXDestroyWindow *args = (ARGS_glXDestroyWindow *)&unpacked->args; \
    glXDestroyWindow(args->dpy, args->win);; \
} while(0)
void glXDestroyWindow(glXDestroyWindow_ARG_EXPAND);
typedef void (*glXDestroyWindow_PTR)(glXDestroyWindow_ARG_EXPAND);
#define glXEnumerateVideoCaptureDevicesNV_INDEX 2745
#define glXEnumerateVideoCaptureDevicesNV_RETURN GLXVideoCaptureDeviceNV *
#define glXEnumerateVideoCaptureDevicesNV_ARG_NAMES dpy, screen, nelements
#define glXEnumerateVideoCaptureDevicesNV_ARG_EXPAND Display * dpy, int screen, int * nelements
#define glXEnumerateVideoCaptureDevicesNV_PACKED PACKED_glXEnumerateVideoCaptureDevicesNV
#define glXEnumerateVideoCaptureDevicesNV_VOID_ONLY_WRAP(...) {}
#define glXEnumerateVideoCaptureDevicesNV_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glXEnumerateVideoCaptureDevicesNV(_dpy, _screen, _nelements) ({ \
    glXEnumerateVideoCaptureDevicesNV_PACKED *packed_data = malloc(sizeof(glXEnumerateVideoCaptureDevicesNV_PACKED)); \
    packed_data->index = glXEnumerateVideoCaptureDevicesNV_INDEX; \
    packed_data->args.dpy = (Display *)_dpy; \
    packed_data->args.screen = (int)_screen; \
    packed_data->args.nelements = (int *)_nelements; \
    (packed_call_t *)packed_data; \
})
#define call_glXEnumerateVideoCaptureDevicesNV(packed, ret_v) do { \
    PACKED_glXEnumerateVideoCaptureDevicesNV *unpacked = (PACKED_glXEnumerateVideoCaptureDevicesNV *)packed; \
    ARGS_glXEnumerateVideoCaptureDevicesNV *args = (ARGS_glXEnumerateVideoCaptureDevicesNV *)&unpacked->args; \
    GLXVideoCaptureDeviceNV * *ret = (GLXVideoCaptureDeviceNV * *)ret_v; \
    if (ret != NULL) { \
        *ret = glXEnumerateVideoCaptureDevicesNV(args->dpy, args->screen, args->nelements);; \
    } else { \
        glXEnumerateVideoCaptureDevicesNV(args->dpy, args->screen, args->nelements);; \
    } \
} while(0)
GLXVideoCaptureDeviceNV * glXEnumerateVideoCaptureDevicesNV(glXEnumerateVideoCaptureDevicesNV_ARG_EXPAND);
typedef GLXVideoCaptureDeviceNV * (*glXEnumerateVideoCaptureDevicesNV_PTR)(glXEnumerateVideoCaptureDevicesNV_ARG_EXPAND);
#define glXEnumerateVideoDevicesNV_INDEX 2746
#define glXEnumerateVideoDevicesNV_RETURN unsigned int *
#define glXEnumerateVideoDevicesNV_ARG_NAMES dpy, screen, nelements
#define glXEnumerateVideoDevicesNV_ARG_EXPAND Display * dpy, int screen, int * nelements
#define glXEnumerateVideoDevicesNV_PACKED PACKED_glXEnumerateVideoDevicesNV
#define glXEnumerateVideoDevicesNV_VOID_ONLY_WRAP(...) {}
#define glXEnumerateVideoDevicesNV_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glXEnumerateVideoDevicesNV(_dpy, _screen, _nelements) ({ \
    glXEnumerateVideoDevicesNV_PACKED *packed_data = malloc(sizeof(glXEnumerateVideoDevicesNV_PACKED)); \
    packed_data->index = glXEnumerateVideoDevicesNV_INDEX; \
    packed_data->args.dpy = (Display *)_dpy; \
    packed_data->args.screen = (int)_screen; \
    packed_data->args.nelements = (int *)_nelements; \
    (packed_call_t *)packed_data; \
})
#define call_glXEnumerateVideoDevicesNV(packed, ret_v) do { \
    PACKED_glXEnumerateVideoDevicesNV *unpacked = (PACKED_glXEnumerateVideoDevicesNV *)packed; \
    ARGS_glXEnumerateVideoDevicesNV *args = (ARGS_glXEnumerateVideoDevicesNV *)&unpacked->args; \
    unsigned int * *ret = (unsigned int * *)ret_v; \
    if (ret != NULL) { \
        *ret = glXEnumerateVideoDevicesNV(args->dpy, args->screen, args->nelements);; \
    } else { \
        glXEnumerateVideoDevicesNV(args->dpy, args->screen, args->nelements);; \
    } \
} while(0)
unsigned int * glXEnumerateVideoDevicesNV(glXEnumerateVideoDevicesNV_ARG_EXPAND);
typedef unsigned int * (*glXEnumerateVideoDevicesNV_PTR)(glXEnumerateVideoDevicesNV_ARG_EXPAND);
#define glXFreeContextEXT_INDEX 2747
#define glXFreeContextEXT_RETURN void
#define glXFreeContextEXT_ARG_NAMES dpy, context
#define glXFreeContextEXT_ARG_EXPAND Display * dpy, GLXContext context
#define glXFreeContextEXT_PACKED PACKED_glXFreeContextEXT
#define glXFreeContextEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glXFreeContextEXT_NOT_VOID_WRAP(...) {}
#define pack_glXFreeContextEXT(_dpy, _context) ({ \
    glXFreeContextEXT_PACKED *packed_data = malloc(sizeof(glXFreeContextEXT_PACKED)); \
    packed_data->index = glXFreeContextEXT_INDEX; \
    packed_data->args.dpy = (Display *)_dpy; \
    packed_data->args.context = (GLXContext)_context; \
    (packed_call_t *)packed_data; \
})
#define call_glXFreeContextEXT(packed, ret_v) do { \
    PACKED_glXFreeContextEXT *unpacked = (PACKED_glXFreeContextEXT *)packed; \
    ARGS_glXFreeContextEXT *args = (ARGS_glXFreeContextEXT *)&unpacked->args; \
    glXFreeContextEXT(args->dpy, args->context);; \
} while(0)
void glXFreeContextEXT(glXFreeContextEXT_ARG_EXPAND);
typedef void (*glXFreeContextEXT_PTR)(glXFreeContextEXT_ARG_EXPAND);
#define glXGetAGPOffsetMESA_INDEX 2748
#define glXGetAGPOffsetMESA_RETURN unsigned int
#define glXGetAGPOffsetMESA_ARG_NAMES pointer
#define glXGetAGPOffsetMESA_ARG_EXPAND const void * pointer
#define glXGetAGPOffsetMESA_PACKED PACKED_glXGetAGPOffsetMESA
#define glXGetAGPOffsetMESA_VOID_ONLY_WRAP(...) {}
#define glXGetAGPOffsetMESA_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glXGetAGPOffsetMESA(_pointer) ({ \
    glXGetAGPOffsetMESA_PACKED *packed_data = malloc(sizeof(glXGetAGPOffsetMESA_PACKED)); \
    packed_data->index = glXGetAGPOffsetMESA_INDEX; \
    packed_data->args.pointer = (void *)_pointer; \
    (packed_call_t *)packed_data; \
})
#define call_glXGetAGPOffsetMESA(packed, ret_v) do { \
    PACKED_glXGetAGPOffsetMESA *unpacked = (PACKED_glXGetAGPOffsetMESA *)packed; \
    ARGS_glXGetAGPOffsetMESA *args = (ARGS_glXGetAGPOffsetMESA *)&unpacked->args; \
    unsigned int *ret = (unsigned int *)ret_v; \
    if (ret != NULL) { \
        *ret = glXGetAGPOffsetMESA(args->pointer);; \
    } else { \
        glXGetAGPOffsetMESA(args->pointer);; \
    } \
} while(0)
unsigned int glXGetAGPOffsetMESA(glXGetAGPOffsetMESA_ARG_EXPAND);
typedef unsigned int (*glXGetAGPOffsetMESA_PTR)(glXGetAGPOffsetMESA_ARG_EXPAND);
#define glXGetClientString_INDEX 2749
#define glXGetClientString_RETURN const char *
#define glXGetClientString_ARG_NAMES display, name
#define glXGetClientString_ARG_EXPAND Display * display, int name
#define glXGetClientString_PACKED PACKED_glXGetClientString
#define glXGetClientString_VOID_ONLY_WRAP(...) {}
#define glXGetClientString_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glXGetClientString(_display, _name) ({ \
    glXGetClientString_PACKED *packed_data = malloc(sizeof(glXGetClientString_PACKED)); \
    packed_data->index = glXGetClientString_INDEX; \
    packed_data->args.display = (Display *)_display; \
    packed_data->args.name = (int)_name; \
    (packed_call_t *)packed_data; \
})
#define call_glXGetClientString(packed, ret_v) do { \
    PACKED_glXGetClientString *unpacked = (PACKED_glXGetClientString *)packed; \
    ARGS_glXGetClientString *args = (ARGS_glXGetClientString *)&unpacked->args; \
    const char * *ret = (const char * *)ret_v; \
    if (ret != NULL) { \
        *ret = glXGetClientString(args->display, args->name);; \
    } else { \
        glXGetClientString(args->display, args->name);; \
    } \
} while(0)
const char * glXGetClientString(glXGetClientString_ARG_EXPAND);
typedef const char * (*glXGetClientString_PTR)(glXGetClientString_ARG_EXPAND);
#define glXGetConfig_INDEX 2750
#define glXGetConfig_RETURN int
#define glXGetConfig_ARG_NAMES display, visual, attribute, value
#define glXGetConfig_ARG_EXPAND Display * display, XVisualInfo * visual, int attribute, int * value
#define glXGetConfig_PACKED PACKED_glXGetConfig
#define glXGetConfig_VOID_ONLY_WRAP(...) {}
#define glXGetConfig_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glXGetConfig(_display, _visual, _attribute, _value) ({ \
    glXGetConfig_PACKED *packed_data = malloc(sizeof(glXGetConfig_PACKED)); \
    packed_data->index = glXGetConfig_INDEX; \
    packed_data->args.display = (Display *)_display; \
    packed_data->args.visual = (XVisualInfo *)_visual; \
    packed_data->args.attribute = (int)_attribute; \
    packed_data->args.value = (int *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glXGetConfig(packed, ret_v) do { \
    PACKED_glXGetConfig *unpacked = (PACKED_glXGetConfig *)packed; \
    ARGS_glXGetConfig *args = (ARGS_glXGetConfig *)&unpacked->args; \
    int *ret = (int *)ret_v; \
    if (ret != NULL) { \
        *ret = glXGetConfig(args->display, args->visual, args->attribute, args->value);; \
    } else { \
        glXGetConfig(args->display, args->visual, args->attribute, args->value);; \
    } \
} while(0)
int glXGetConfig(glXGetConfig_ARG_EXPAND);
typedef int (*glXGetConfig_PTR)(glXGetConfig_ARG_EXPAND);
#define glXGetContextIDEXT_INDEX 2751
#define glXGetContextIDEXT_RETURN GLXContextID
#define glXGetContextIDEXT_ARG_NAMES context
#define glXGetContextIDEXT_ARG_EXPAND const GLXContext context
#define glXGetContextIDEXT_PACKED PACKED_glXGetContextIDEXT
#define glXGetContextIDEXT_VOID_ONLY_WRAP(...) {}
#define glXGetContextIDEXT_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glXGetContextIDEXT(_context) ({ \
    glXGetContextIDEXT_PACKED *packed_data = malloc(sizeof(glXGetContextIDEXT_PACKED)); \
    packed_data->index = glXGetContextIDEXT_INDEX; \
    packed_data->args.context = (GLXContext)_context; \
    (packed_call_t *)packed_data; \
})
#define call_glXGetContextIDEXT(packed, ret_v) do { \
    PACKED_glXGetContextIDEXT *unpacked = (PACKED_glXGetContextIDEXT *)packed; \
    ARGS_glXGetContextIDEXT *args = (ARGS_glXGetContextIDEXT *)&unpacked->args; \
    GLXContextID *ret = (GLXContextID *)ret_v; \
    if (ret != NULL) { \
        *ret = glXGetContextIDEXT(args->context);; \
    } else { \
        glXGetContextIDEXT(args->context);; \
    } \
} while(0)
GLXContextID glXGetContextIDEXT(glXGetContextIDEXT_ARG_EXPAND);
typedef GLXContextID (*glXGetContextIDEXT_PTR)(glXGetContextIDEXT_ARG_EXPAND);
#define glXGetCurrentContext_INDEX 2752
#define glXGetCurrentContext_RETURN GLXContext
#define glXGetCurrentContext_ARG_NAMES 
#define glXGetCurrentContext_ARG_EXPAND 
#define glXGetCurrentContext_PACKED PACKED_glXGetCurrentContext
#define glXGetCurrentContext_VOID_ONLY_WRAP(...) {}
#define glXGetCurrentContext_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glXGetCurrentContext() ({ \
    glXGetCurrentContext_PACKED *packed_data = malloc(sizeof(glXGetCurrentContext_PACKED)); \
    packed_data->index = glXGetCurrentContext_INDEX; \
    (packed_call_t *)packed_data; \
})
#define call_glXGetCurrentContext(packed, ret_v) do { \
    GLXContext *ret = (GLXContext *)ret_v; \
    if (ret != NULL) { \
        *ret = glXGetCurrentContext();; \
    } else { \
        glXGetCurrentContext();; \
    } \
} while(0)
GLXContext glXGetCurrentContext(glXGetCurrentContext_ARG_EXPAND);
typedef GLXContext (*glXGetCurrentContext_PTR)(glXGetCurrentContext_ARG_EXPAND);
#define glXGetCurrentDisplay_INDEX 2753
#define glXGetCurrentDisplay_RETURN Display *
#define glXGetCurrentDisplay_ARG_NAMES 
#define glXGetCurrentDisplay_ARG_EXPAND 
#define glXGetCurrentDisplay_PACKED PACKED_glXGetCurrentDisplay
#define glXGetCurrentDisplay_VOID_ONLY_WRAP(...) {}
#define glXGetCurrentDisplay_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glXGetCurrentDisplay() ({ \
    glXGetCurrentDisplay_PACKED *packed_data = malloc(sizeof(glXGetCurrentDisplay_PACKED)); \
    packed_data->index = glXGetCurrentDisplay_INDEX; \
    (packed_call_t *)packed_data; \
})
#define call_glXGetCurrentDisplay(packed, ret_v) do { \
    Display * *ret = (Display * *)ret_v; \
    if (ret != NULL) { \
        *ret = glXGetCurrentDisplay();; \
    } else { \
        glXGetCurrentDisplay();; \
    } \
} while(0)
Display * glXGetCurrentDisplay(glXGetCurrentDisplay_ARG_EXPAND);
typedef Display * (*glXGetCurrentDisplay_PTR)(glXGetCurrentDisplay_ARG_EXPAND);
#define glXGetCurrentDisplayEXT_INDEX 2754
#define glXGetCurrentDisplayEXT_RETURN Display *
#define glXGetCurrentDisplayEXT_ARG_NAMES 
#define glXGetCurrentDisplayEXT_ARG_EXPAND 
#define glXGetCurrentDisplayEXT_PACKED PACKED_glXGetCurrentDisplayEXT
#define glXGetCurrentDisplayEXT_VOID_ONLY_WRAP(...) {}
#define glXGetCurrentDisplayEXT_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glXGetCurrentDisplayEXT() ({ \
    glXGetCurrentDisplayEXT_PACKED *packed_data = malloc(sizeof(glXGetCurrentDisplayEXT_PACKED)); \
    packed_data->index = glXGetCurrentDisplayEXT_INDEX; \
    (packed_call_t *)packed_data; \
})
#define call_glXGetCurrentDisplayEXT(packed, ret_v) do { \
    Display * *ret = (Display * *)ret_v; \
    if (ret != NULL) { \
        *ret = glXGetCurrentDisplayEXT();; \
    } else { \
        glXGetCurrentDisplayEXT();; \
    } \
} while(0)
Display * glXGetCurrentDisplayEXT(glXGetCurrentDisplayEXT_ARG_EXPAND);
typedef Display * (*glXGetCurrentDisplayEXT_PTR)(glXGetCurrentDisplayEXT_ARG_EXPAND);
#define glXGetCurrentDrawable_INDEX 2755
#define glXGetCurrentDrawable_RETURN GLXDrawable
#define glXGetCurrentDrawable_ARG_NAMES 
#define glXGetCurrentDrawable_ARG_EXPAND 
#define glXGetCurrentDrawable_PACKED PACKED_glXGetCurrentDrawable
#define glXGetCurrentDrawable_VOID_ONLY_WRAP(...) {}
#define glXGetCurrentDrawable_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glXGetCurrentDrawable() ({ \
    glXGetCurrentDrawable_PACKED *packed_data = malloc(sizeof(glXGetCurrentDrawable_PACKED)); \
    packed_data->index = glXGetCurrentDrawable_INDEX; \
    (packed_call_t *)packed_data; \
})
#define call_glXGetCurrentDrawable(packed, ret_v) do { \
    GLXDrawable *ret = (GLXDrawable *)ret_v; \
    if (ret != NULL) { \
        *ret = glXGetCurrentDrawable();; \
    } else { \
        glXGetCurrentDrawable();; \
    } \
} while(0)
GLXDrawable glXGetCurrentDrawable(glXGetCurrentDrawable_ARG_EXPAND);
typedef GLXDrawable (*glXGetCurrentDrawable_PTR)(glXGetCurrentDrawable_ARG_EXPAND);
#define glXGetCurrentReadDrawable_INDEX 2756
#define glXGetCurrentReadDrawable_RETURN GLXDrawable
#define glXGetCurrentReadDrawable_ARG_NAMES 
#define glXGetCurrentReadDrawable_ARG_EXPAND 
#define glXGetCurrentReadDrawable_PACKED PACKED_glXGetCurrentReadDrawable
#define glXGetCurrentReadDrawable_VOID_ONLY_WRAP(...) {}
#define glXGetCurrentReadDrawable_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glXGetCurrentReadDrawable() ({ \
    glXGetCurrentReadDrawable_PACKED *packed_data = malloc(sizeof(glXGetCurrentReadDrawable_PACKED)); \
    packed_data->index = glXGetCurrentReadDrawable_INDEX; \
    (packed_call_t *)packed_data; \
})
#define call_glXGetCurrentReadDrawable(packed, ret_v) do { \
    GLXDrawable *ret = (GLXDrawable *)ret_v; \
    if (ret != NULL) { \
        *ret = glXGetCurrentReadDrawable();; \
    } else { \
        glXGetCurrentReadDrawable();; \
    } \
} while(0)
GLXDrawable glXGetCurrentReadDrawable(glXGetCurrentReadDrawable_ARG_EXPAND);
typedef GLXDrawable (*glXGetCurrentReadDrawable_PTR)(glXGetCurrentReadDrawable_ARG_EXPAND);
#define glXGetCurrentReadDrawableSGI_INDEX 2757
#define glXGetCurrentReadDrawableSGI_RETURN GLXDrawable
#define glXGetCurrentReadDrawableSGI_ARG_NAMES 
#define glXGetCurrentReadDrawableSGI_ARG_EXPAND 
#define glXGetCurrentReadDrawableSGI_PACKED PACKED_glXGetCurrentReadDrawableSGI
#define glXGetCurrentReadDrawableSGI_VOID_ONLY_WRAP(...) {}
#define glXGetCurrentReadDrawableSGI_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glXGetCurrentReadDrawableSGI() ({ \
    glXGetCurrentReadDrawableSGI_PACKED *packed_data = malloc(sizeof(glXGetCurrentReadDrawableSGI_PACKED)); \
    packed_data->index = glXGetCurrentReadDrawableSGI_INDEX; \
    (packed_call_t *)packed_data; \
})
#define call_glXGetCurrentReadDrawableSGI(packed, ret_v) do { \
    GLXDrawable *ret = (GLXDrawable *)ret_v; \
    if (ret != NULL) { \
        *ret = glXGetCurrentReadDrawableSGI();; \
    } else { \
        glXGetCurrentReadDrawableSGI();; \
    } \
} while(0)
GLXDrawable glXGetCurrentReadDrawableSGI(glXGetCurrentReadDrawableSGI_ARG_EXPAND);
typedef GLXDrawable (*glXGetCurrentReadDrawableSGI_PTR)(glXGetCurrentReadDrawableSGI_ARG_EXPAND);
#define glXGetDrawableAttributes_INDEX 2758
#define glXGetDrawableAttributes_RETURN void
#define glXGetDrawableAttributes_ARG_NAMES drawable
#define glXGetDrawableAttributes_ARG_EXPAND uint32_t drawable
#define glXGetDrawableAttributes_PACKED PACKED_glXGetDrawableAttributes
#define glXGetDrawableAttributes_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glXGetDrawableAttributes_NOT_VOID_WRAP(...) {}
#define pack_glXGetDrawableAttributes(_drawable) ({ \
    glXGetDrawableAttributes_PACKED *packed_data = malloc(sizeof(glXGetDrawableAttributes_PACKED)); \
    packed_data->index = glXGetDrawableAttributes_INDEX; \
    packed_data->args.drawable = (uint32_t)_drawable; \
    (packed_call_t *)packed_data; \
})
#define call_glXGetDrawableAttributes(packed, ret_v) do { \
    PACKED_glXGetDrawableAttributes *unpacked = (PACKED_glXGetDrawableAttributes *)packed; \
    ARGS_glXGetDrawableAttributes *args = (ARGS_glXGetDrawableAttributes *)&unpacked->args; \
    glXGetDrawableAttributes(args->drawable);; \
} while(0)
void glXGetDrawableAttributes(glXGetDrawableAttributes_ARG_EXPAND);
typedef void (*glXGetDrawableAttributes_PTR)(glXGetDrawableAttributes_ARG_EXPAND);
#define glXGetDrawableAttributesSGIX_INDEX 2759
#define glXGetDrawableAttributesSGIX_RETURN void
#define glXGetDrawableAttributesSGIX_ARG_NAMES drawable
#define glXGetDrawableAttributesSGIX_ARG_EXPAND uint32_t drawable
#define glXGetDrawableAttributesSGIX_PACKED PACKED_glXGetDrawableAttributesSGIX
#define glXGetDrawableAttributesSGIX_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glXGetDrawableAttributesSGIX_NOT_VOID_WRAP(...) {}
#define pack_glXGetDrawableAttributesSGIX(_drawable) ({ \
    glXGetDrawableAttributesSGIX_PACKED *packed_data = malloc(sizeof(glXGetDrawableAttributesSGIX_PACKED)); \
    packed_data->index = glXGetDrawableAttributesSGIX_INDEX; \
    packed_data->args.drawable = (uint32_t)_drawable; \
    (packed_call_t *)packed_data; \
})
#define call_glXGetDrawableAttributesSGIX(packed, ret_v) do { \
    PACKED_glXGetDrawableAttributesSGIX *unpacked = (PACKED_glXGetDrawableAttributesSGIX *)packed; \
    ARGS_glXGetDrawableAttributesSGIX *args = (ARGS_glXGetDrawableAttributesSGIX *)&unpacked->args; \
    glXGetDrawableAttributesSGIX(args->drawable);; \
} while(0)
void glXGetDrawableAttributesSGIX(glXGetDrawableAttributesSGIX_ARG_EXPAND);
typedef void (*glXGetDrawableAttributesSGIX_PTR)(glXGetDrawableAttributesSGIX_ARG_EXPAND);
#define glXGetFBConfigAttrib_INDEX 2760
#define glXGetFBConfigAttrib_RETURN int
#define glXGetFBConfigAttrib_ARG_NAMES dpy, config, attribute, value
#define glXGetFBConfigAttrib_ARG_EXPAND Display * dpy, GLXFBConfig config, int attribute, int * value
#define glXGetFBConfigAttrib_PACKED PACKED_glXGetFBConfigAttrib
#define glXGetFBConfigAttrib_VOID_ONLY_WRAP(...) {}
#define glXGetFBConfigAttrib_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glXGetFBConfigAttrib(_dpy, _config, _attribute, _value) ({ \
    glXGetFBConfigAttrib_PACKED *packed_data = malloc(sizeof(glXGetFBConfigAttrib_PACKED)); \
    packed_data->index = glXGetFBConfigAttrib_INDEX; \
    packed_data->args.dpy = (Display *)_dpy; \
    packed_data->args.config = (GLXFBConfig)_config; \
    packed_data->args.attribute = (int)_attribute; \
    packed_data->args.value = (int *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glXGetFBConfigAttrib(packed, ret_v) do { \
    PACKED_glXGetFBConfigAttrib *unpacked = (PACKED_glXGetFBConfigAttrib *)packed; \
    ARGS_glXGetFBConfigAttrib *args = (ARGS_glXGetFBConfigAttrib *)&unpacked->args; \
    int *ret = (int *)ret_v; \
    if (ret != NULL) { \
        *ret = glXGetFBConfigAttrib(args->dpy, args->config, args->attribute, args->value);; \
    } else { \
        glXGetFBConfigAttrib(args->dpy, args->config, args->attribute, args->value);; \
    } \
} while(0)
int glXGetFBConfigAttrib(glXGetFBConfigAttrib_ARG_EXPAND);
typedef int (*glXGetFBConfigAttrib_PTR)(glXGetFBConfigAttrib_ARG_EXPAND);
#define glXGetFBConfigAttribSGIX_INDEX 2761
#define glXGetFBConfigAttribSGIX_RETURN int
#define glXGetFBConfigAttribSGIX_ARG_NAMES dpy, config, attribute, value
#define glXGetFBConfigAttribSGIX_ARG_EXPAND Display * dpy, GLXFBConfigSGIX config, int attribute, int * value
#define glXGetFBConfigAttribSGIX_PACKED PACKED_glXGetFBConfigAttribSGIX
#define glXGetFBConfigAttribSGIX_VOID_ONLY_WRAP(...) {}
#define glXGetFBConfigAttribSGIX_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glXGetFBConfigAttribSGIX(_dpy, _config, _attribute, _value) ({ \
    glXGetFBConfigAttribSGIX_PACKED *packed_data = malloc(sizeof(glXGetFBConfigAttribSGIX_PACKED)); \
    packed_data->index = glXGetFBConfigAttribSGIX_INDEX; \
    packed_data->args.dpy = (Display *)_dpy; \
    packed_data->args.config = (GLXFBConfigSGIX)_config; \
    packed_data->args.attribute = (int)_attribute; \
    packed_data->args.value = (int *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glXGetFBConfigAttribSGIX(packed, ret_v) do { \
    PACKED_glXGetFBConfigAttribSGIX *unpacked = (PACKED_glXGetFBConfigAttribSGIX *)packed; \
    ARGS_glXGetFBConfigAttribSGIX *args = (ARGS_glXGetFBConfigAttribSGIX *)&unpacked->args; \
    int *ret = (int *)ret_v; \
    if (ret != NULL) { \
        *ret = glXGetFBConfigAttribSGIX(args->dpy, args->config, args->attribute, args->value);; \
    } else { \
        glXGetFBConfigAttribSGIX(args->dpy, args->config, args->attribute, args->value);; \
    } \
} while(0)
int glXGetFBConfigAttribSGIX(glXGetFBConfigAttribSGIX_ARG_EXPAND);
typedef int (*glXGetFBConfigAttribSGIX_PTR)(glXGetFBConfigAttribSGIX_ARG_EXPAND);
#define glXGetFBConfigFromVisualSGIX_INDEX 2762
#define glXGetFBConfigFromVisualSGIX_RETURN GLXFBConfigSGIX
#define glXGetFBConfigFromVisualSGIX_ARG_NAMES dpy, vis
#define glXGetFBConfigFromVisualSGIX_ARG_EXPAND Display * dpy, XVisualInfo * vis
#define glXGetFBConfigFromVisualSGIX_PACKED PACKED_glXGetFBConfigFromVisualSGIX
#define glXGetFBConfigFromVisualSGIX_VOID_ONLY_WRAP(...) {}
#define glXGetFBConfigFromVisualSGIX_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glXGetFBConfigFromVisualSGIX(_dpy, _vis) ({ \
    glXGetFBConfigFromVisualSGIX_PACKED *packed_data = malloc(sizeof(glXGetFBConfigFromVisualSGIX_PACKED)); \
    packed_data->index = glXGetFBConfigFromVisualSGIX_INDEX; \
    packed_data->args.dpy = (Display *)_dpy; \
    packed_data->args.vis = (XVisualInfo *)_vis; \
    (packed_call_t *)packed_data; \
})
#define call_glXGetFBConfigFromVisualSGIX(packed, ret_v) do { \
    PACKED_glXGetFBConfigFromVisualSGIX *unpacked = (PACKED_glXGetFBConfigFromVisualSGIX *)packed; \
    ARGS_glXGetFBConfigFromVisualSGIX *args = (ARGS_glXGetFBConfigFromVisualSGIX *)&unpacked->args; \
    GLXFBConfigSGIX *ret = (GLXFBConfigSGIX *)ret_v; \
    if (ret != NULL) { \
        *ret = glXGetFBConfigFromVisualSGIX(args->dpy, args->vis);; \
    } else { \
        glXGetFBConfigFromVisualSGIX(args->dpy, args->vis);; \
    } \
} while(0)
GLXFBConfigSGIX glXGetFBConfigFromVisualSGIX(glXGetFBConfigFromVisualSGIX_ARG_EXPAND);
typedef GLXFBConfigSGIX (*glXGetFBConfigFromVisualSGIX_PTR)(glXGetFBConfigFromVisualSGIX_ARG_EXPAND);
#define glXGetFBConfigs_INDEX 2763
#define glXGetFBConfigs_RETURN GLXFBConfig *
#define glXGetFBConfigs_ARG_NAMES dpy, screen, nelements
#define glXGetFBConfigs_ARG_EXPAND Display * dpy, int screen, int * nelements
#define glXGetFBConfigs_PACKED PACKED_glXGetFBConfigs
#define glXGetFBConfigs_VOID_ONLY_WRAP(...) {}
#define glXGetFBConfigs_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glXGetFBConfigs(_dpy, _screen, _nelements) ({ \
    glXGetFBConfigs_PACKED *packed_data = malloc(sizeof(glXGetFBConfigs_PACKED)); \
    packed_data->index = glXGetFBConfigs_INDEX; \
    packed_data->args.dpy = (Display *)_dpy; \
    packed_data->args.screen = (int)_screen; \
    packed_data->args.nelements = (int *)_nelements; \
    (packed_call_t *)packed_data; \
})
#define call_glXGetFBConfigs(packed, ret_v) do { \
    PACKED_glXGetFBConfigs *unpacked = (PACKED_glXGetFBConfigs *)packed; \
    ARGS_glXGetFBConfigs *args = (ARGS_glXGetFBConfigs *)&unpacked->args; \
    GLXFBConfig * *ret = (GLXFBConfig * *)ret_v; \
    if (ret != NULL) { \
        *ret = glXGetFBConfigs(args->dpy, args->screen, args->nelements);; \
    } else { \
        glXGetFBConfigs(args->dpy, args->screen, args->nelements);; \
    } \
} while(0)
GLXFBConfig * glXGetFBConfigs(glXGetFBConfigs_ARG_EXPAND);
typedef GLXFBConfig * (*glXGetFBConfigs_PTR)(glXGetFBConfigs_ARG_EXPAND);
#define glXGetFBConfigsSGIX_INDEX 2764
#define glXGetFBConfigsSGIX_RETURN void
#define glXGetFBConfigsSGIX_ARG_NAMES 
#define glXGetFBConfigsSGIX_ARG_EXPAND 
#define glXGetFBConfigsSGIX_PACKED PACKED_glXGetFBConfigsSGIX
#define glXGetFBConfigsSGIX_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glXGetFBConfigsSGIX_NOT_VOID_WRAP(...) {}
#define pack_glXGetFBConfigsSGIX() ({ \
    glXGetFBConfigsSGIX_PACKED *packed_data = malloc(sizeof(glXGetFBConfigsSGIX_PACKED)); \
    packed_data->index = glXGetFBConfigsSGIX_INDEX; \
    (packed_call_t *)packed_data; \
})
#define call_glXGetFBConfigsSGIX(packed, ret_v) do { \
    glXGetFBConfigsSGIX();; \
} while(0)
void glXGetFBConfigsSGIX(glXGetFBConfigsSGIX_ARG_EXPAND);
typedef void (*glXGetFBConfigsSGIX_PTR)(glXGetFBConfigsSGIX_ARG_EXPAND);
#define glXGetMscRateOML_INDEX 2765
#define glXGetMscRateOML_RETURN Bool
#define glXGetMscRateOML_ARG_NAMES dpy, drawable, numerator, denominator
#define glXGetMscRateOML_ARG_EXPAND Display * dpy, GLXDrawable drawable, int32_t * numerator, int32_t * denominator
#define glXGetMscRateOML_PACKED PACKED_glXGetMscRateOML
#define glXGetMscRateOML_VOID_ONLY_WRAP(...) {}
#define glXGetMscRateOML_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glXGetMscRateOML(_dpy, _drawable, _numerator, _denominator) ({ \
    glXGetMscRateOML_PACKED *packed_data = malloc(sizeof(glXGetMscRateOML_PACKED)); \
    packed_data->index = glXGetMscRateOML_INDEX; \
    packed_data->args.dpy = (Display *)_dpy; \
    packed_data->args.drawable = (GLXDrawable)_drawable; \
    packed_data->args.numerator = (int32_t *)_numerator; \
    packed_data->args.denominator = (int32_t *)_denominator; \
    (packed_call_t *)packed_data; \
})
#define call_glXGetMscRateOML(packed, ret_v) do { \
    PACKED_glXGetMscRateOML *unpacked = (PACKED_glXGetMscRateOML *)packed; \
    ARGS_glXGetMscRateOML *args = (ARGS_glXGetMscRateOML *)&unpacked->args; \
    Bool *ret = (Bool *)ret_v; \
    if (ret != NULL) { \
        *ret = glXGetMscRateOML(args->dpy, args->drawable, args->numerator, args->denominator);; \
    } else { \
        glXGetMscRateOML(args->dpy, args->drawable, args->numerator, args->denominator);; \
    } \
} while(0)
Bool glXGetMscRateOML(glXGetMscRateOML_ARG_EXPAND);
typedef Bool (*glXGetMscRateOML_PTR)(glXGetMscRateOML_ARG_EXPAND);
#define glXGetProcAddress_INDEX 2766
#define glXGetProcAddress_RETURN __GLXextFuncPtr
#define glXGetProcAddress_ARG_NAMES procName
#define glXGetProcAddress_ARG_EXPAND const GLubyte * procName
#define glXGetProcAddress_PACKED PACKED_glXGetProcAddress
#define glXGetProcAddress_VOID_ONLY_WRAP(...) {}
#define glXGetProcAddress_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glXGetProcAddress(_procName) ({ \
    glXGetProcAddress_PACKED *packed_data = malloc(sizeof(glXGetProcAddress_PACKED)); \
    packed_data->index = glXGetProcAddress_INDEX; \
    packed_data->args.procName = (GLubyte *)_procName; \
    (packed_call_t *)packed_data; \
})
#define call_glXGetProcAddress(packed, ret_v) do { \
    PACKED_glXGetProcAddress *unpacked = (PACKED_glXGetProcAddress *)packed; \
    ARGS_glXGetProcAddress *args = (ARGS_glXGetProcAddress *)&unpacked->args; \
    __GLXextFuncPtr *ret = (__GLXextFuncPtr *)ret_v; \
    if (ret != NULL) { \
        *ret = glXGetProcAddress(args->procName);; \
    } else { \
        glXGetProcAddress(args->procName);; \
    } \
} while(0)
__GLXextFuncPtr glXGetProcAddress(glXGetProcAddress_ARG_EXPAND);
typedef __GLXextFuncPtr (*glXGetProcAddress_PTR)(glXGetProcAddress_ARG_EXPAND);
#define glXGetProcAddressARB_INDEX 2767
#define glXGetProcAddressARB_RETURN __GLXextFuncPtr
#define glXGetProcAddressARB_ARG_NAMES procName
#define glXGetProcAddressARB_ARG_EXPAND const GLubyte * procName
#define glXGetProcAddressARB_PACKED PACKED_glXGetProcAddressARB
#define glXGetProcAddressARB_VOID_ONLY_WRAP(...) {}
#define glXGetProcAddressARB_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glXGetProcAddressARB(_procName) ({ \
    glXGetProcAddressARB_PACKED *packed_data = malloc(sizeof(glXGetProcAddressARB_PACKED)); \
    packed_data->index = glXGetProcAddressARB_INDEX; \
    packed_data->args.procName = (GLubyte *)_procName; \
    (packed_call_t *)packed_data; \
})
#define call_glXGetProcAddressARB(packed, ret_v) do { \
    PACKED_glXGetProcAddressARB *unpacked = (PACKED_glXGetProcAddressARB *)packed; \
    ARGS_glXGetProcAddressARB *args = (ARGS_glXGetProcAddressARB *)&unpacked->args; \
    __GLXextFuncPtr *ret = (__GLXextFuncPtr *)ret_v; \
    if (ret != NULL) { \
        *ret = glXGetProcAddressARB(args->procName);; \
    } else { \
        glXGetProcAddressARB(args->procName);; \
    } \
} while(0)
__GLXextFuncPtr glXGetProcAddressARB(glXGetProcAddressARB_ARG_EXPAND);
typedef __GLXextFuncPtr (*glXGetProcAddressARB_PTR)(glXGetProcAddressARB_ARG_EXPAND);
#define glXGetSelectedEvent_INDEX 2768
#define glXGetSelectedEvent_RETURN void
#define glXGetSelectedEvent_ARG_NAMES dpy, draw, event_mask
#define glXGetSelectedEvent_ARG_EXPAND Display * dpy, GLXDrawable draw, unsigned long * event_mask
#define glXGetSelectedEvent_PACKED PACKED_glXGetSelectedEvent
#define glXGetSelectedEvent_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glXGetSelectedEvent_NOT_VOID_WRAP(...) {}
#define pack_glXGetSelectedEvent(_dpy, _draw, _event_mask) ({ \
    glXGetSelectedEvent_PACKED *packed_data = malloc(sizeof(glXGetSelectedEvent_PACKED)); \
    packed_data->index = glXGetSelectedEvent_INDEX; \
    packed_data->args.dpy = (Display *)_dpy; \
    packed_data->args.draw = (GLXDrawable)_draw; \
    packed_data->args.event_mask = (unsigned long *)_event_mask; \
    (packed_call_t *)packed_data; \
})
#define call_glXGetSelectedEvent(packed, ret_v) do { \
    PACKED_glXGetSelectedEvent *unpacked = (PACKED_glXGetSelectedEvent *)packed; \
    ARGS_glXGetSelectedEvent *args = (ARGS_glXGetSelectedEvent *)&unpacked->args; \
    glXGetSelectedEvent(args->dpy, args->draw, args->event_mask);; \
} while(0)
void glXGetSelectedEvent(glXGetSelectedEvent_ARG_EXPAND);
typedef void (*glXGetSelectedEvent_PTR)(glXGetSelectedEvent_ARG_EXPAND);
#define glXGetSelectedEventSGIX_INDEX 2769
#define glXGetSelectedEventSGIX_RETURN void
#define glXGetSelectedEventSGIX_ARG_NAMES dpy, drawable, mask
#define glXGetSelectedEventSGIX_ARG_EXPAND Display * dpy, GLXDrawable drawable, unsigned long * mask
#define glXGetSelectedEventSGIX_PACKED PACKED_glXGetSelectedEventSGIX
#define glXGetSelectedEventSGIX_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glXGetSelectedEventSGIX_NOT_VOID_WRAP(...) {}
#define pack_glXGetSelectedEventSGIX(_dpy, _drawable, _mask) ({ \
    glXGetSelectedEventSGIX_PACKED *packed_data = malloc(sizeof(glXGetSelectedEventSGIX_PACKED)); \
    packed_data->index = glXGetSelectedEventSGIX_INDEX; \
    packed_data->args.dpy = (Display *)_dpy; \
    packed_data->args.drawable = (GLXDrawable)_drawable; \
    packed_data->args.mask = (unsigned long *)_mask; \
    (packed_call_t *)packed_data; \
})
#define call_glXGetSelectedEventSGIX(packed, ret_v) do { \
    PACKED_glXGetSelectedEventSGIX *unpacked = (PACKED_glXGetSelectedEventSGIX *)packed; \
    ARGS_glXGetSelectedEventSGIX *args = (ARGS_glXGetSelectedEventSGIX *)&unpacked->args; \
    glXGetSelectedEventSGIX(args->dpy, args->drawable, args->mask);; \
} while(0)
void glXGetSelectedEventSGIX(glXGetSelectedEventSGIX_ARG_EXPAND);
typedef void (*glXGetSelectedEventSGIX_PTR)(glXGetSelectedEventSGIX_ARG_EXPAND);
#define glXGetSyncValuesOML_INDEX 2770
#define glXGetSyncValuesOML_RETURN Bool
#define glXGetSyncValuesOML_ARG_NAMES dpy, drawable, ust, msc, sbc
#define glXGetSyncValuesOML_ARG_EXPAND Display * dpy, GLXDrawable drawable, int64_t * ust, int64_t * msc, int64_t * sbc
#define glXGetSyncValuesOML_PACKED PACKED_glXGetSyncValuesOML
#define glXGetSyncValuesOML_VOID_ONLY_WRAP(...) {}
#define glXGetSyncValuesOML_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glXGetSyncValuesOML(_dpy, _drawable, _ust, _msc, _sbc) ({ \
    glXGetSyncValuesOML_PACKED *packed_data = malloc(sizeof(glXGetSyncValuesOML_PACKED)); \
    packed_data->index = glXGetSyncValuesOML_INDEX; \
    packed_data->args.dpy = (Display *)_dpy; \
    packed_data->args.drawable = (GLXDrawable)_drawable; \
    packed_data->args.ust = (int64_t *)_ust; \
    packed_data->args.msc = (int64_t *)_msc; \
    packed_data->args.sbc = (int64_t *)_sbc; \
    (packed_call_t *)packed_data; \
})
#define call_glXGetSyncValuesOML(packed, ret_v) do { \
    PACKED_glXGetSyncValuesOML *unpacked = (PACKED_glXGetSyncValuesOML *)packed; \
    ARGS_glXGetSyncValuesOML *args = (ARGS_glXGetSyncValuesOML *)&unpacked->args; \
    Bool *ret = (Bool *)ret_v; \
    if (ret != NULL) { \
        *ret = glXGetSyncValuesOML(args->dpy, args->drawable, args->ust, args->msc, args->sbc);; \
    } else { \
        glXGetSyncValuesOML(args->dpy, args->drawable, args->ust, args->msc, args->sbc);; \
    } \
} while(0)
Bool glXGetSyncValuesOML(glXGetSyncValuesOML_ARG_EXPAND);
typedef Bool (*glXGetSyncValuesOML_PTR)(glXGetSyncValuesOML_ARG_EXPAND);
#define glXGetTransparentIndexSUN_INDEX 2771
#define glXGetTransparentIndexSUN_RETURN Status
#define glXGetTransparentIndexSUN_ARG_NAMES dpy, overlay, underlay, pTransparentIndex
#define glXGetTransparentIndexSUN_ARG_EXPAND Display * dpy, Window overlay, Window underlay, long * pTransparentIndex
#define glXGetTransparentIndexSUN_PACKED PACKED_glXGetTransparentIndexSUN
#define glXGetTransparentIndexSUN_VOID_ONLY_WRAP(...) {}
#define glXGetTransparentIndexSUN_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glXGetTransparentIndexSUN(_dpy, _overlay, _underlay, _pTransparentIndex) ({ \
    glXGetTransparentIndexSUN_PACKED *packed_data = malloc(sizeof(glXGetTransparentIndexSUN_PACKED)); \
    packed_data->index = glXGetTransparentIndexSUN_INDEX; \
    packed_data->args.dpy = (Display *)_dpy; \
    packed_data->args.overlay = (Window)_overlay; \
    packed_data->args.underlay = (Window)_underlay; \
    packed_data->args.pTransparentIndex = (long *)_pTransparentIndex; \
    (packed_call_t *)packed_data; \
})
#define call_glXGetTransparentIndexSUN(packed, ret_v) do { \
    PACKED_glXGetTransparentIndexSUN *unpacked = (PACKED_glXGetTransparentIndexSUN *)packed; \
    ARGS_glXGetTransparentIndexSUN *args = (ARGS_glXGetTransparentIndexSUN *)&unpacked->args; \
    Status *ret = (Status *)ret_v; \
    if (ret != NULL) { \
        *ret = glXGetTransparentIndexSUN(args->dpy, args->overlay, args->underlay, args->pTransparentIndex);; \
    } else { \
        glXGetTransparentIndexSUN(args->dpy, args->overlay, args->underlay, args->pTransparentIndex);; \
    } \
} while(0)
Status glXGetTransparentIndexSUN(glXGetTransparentIndexSUN_ARG_EXPAND);
typedef Status (*glXGetTransparentIndexSUN_PTR)(glXGetTransparentIndexSUN_ARG_EXPAND);
#define glXGetVideoDeviceNV_INDEX 2772
#define glXGetVideoDeviceNV_RETURN int
#define glXGetVideoDeviceNV_ARG_NAMES dpy, screen, numVideoDevices, pVideoDevice
#define glXGetVideoDeviceNV_ARG_EXPAND Display * dpy, int screen, int numVideoDevices, GLXVideoDeviceNV * pVideoDevice
#define glXGetVideoDeviceNV_PACKED PACKED_glXGetVideoDeviceNV
#define glXGetVideoDeviceNV_VOID_ONLY_WRAP(...) {}
#define glXGetVideoDeviceNV_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glXGetVideoDeviceNV(_dpy, _screen, _numVideoDevices, _pVideoDevice) ({ \
    glXGetVideoDeviceNV_PACKED *packed_data = malloc(sizeof(glXGetVideoDeviceNV_PACKED)); \
    packed_data->index = glXGetVideoDeviceNV_INDEX; \
    packed_data->args.dpy = (Display *)_dpy; \
    packed_data->args.screen = (int)_screen; \
    packed_data->args.numVideoDevices = (int)_numVideoDevices; \
    packed_data->args.pVideoDevice = (GLXVideoDeviceNV *)_pVideoDevice; \
    (packed_call_t *)packed_data; \
})
#define call_glXGetVideoDeviceNV(packed, ret_v) do { \
    PACKED_glXGetVideoDeviceNV *unpacked = (PACKED_glXGetVideoDeviceNV *)packed; \
    ARGS_glXGetVideoDeviceNV *args = (ARGS_glXGetVideoDeviceNV *)&unpacked->args; \
    int *ret = (int *)ret_v; \
    if (ret != NULL) { \
        *ret = glXGetVideoDeviceNV(args->dpy, args->screen, args->numVideoDevices, args->pVideoDevice);; \
    } else { \
        glXGetVideoDeviceNV(args->dpy, args->screen, args->numVideoDevices, args->pVideoDevice);; \
    } \
} while(0)
int glXGetVideoDeviceNV(glXGetVideoDeviceNV_ARG_EXPAND);
typedef int (*glXGetVideoDeviceNV_PTR)(glXGetVideoDeviceNV_ARG_EXPAND);
#define glXGetVideoInfoNV_INDEX 2773
#define glXGetVideoInfoNV_RETURN int
#define glXGetVideoInfoNV_ARG_NAMES dpy, screen, VideoDevice, pulCounterOutputPbuffer, pulCounterOutputVideo
#define glXGetVideoInfoNV_ARG_EXPAND Display * dpy, int screen, GLXVideoDeviceNV VideoDevice, unsigned long * pulCounterOutputPbuffer, unsigned long * pulCounterOutputVideo
#define glXGetVideoInfoNV_PACKED PACKED_glXGetVideoInfoNV
#define glXGetVideoInfoNV_VOID_ONLY_WRAP(...) {}
#define glXGetVideoInfoNV_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glXGetVideoInfoNV(_dpy, _screen, _VideoDevice, _pulCounterOutputPbuffer, _pulCounterOutputVideo) ({ \
    glXGetVideoInfoNV_PACKED *packed_data = malloc(sizeof(glXGetVideoInfoNV_PACKED)); \
    packed_data->index = glXGetVideoInfoNV_INDEX; \
    packed_data->args.dpy = (Display *)_dpy; \
    packed_data->args.screen = (int)_screen; \
    packed_data->args.VideoDevice = (GLXVideoDeviceNV)_VideoDevice; \
    packed_data->args.pulCounterOutputPbuffer = (unsigned long *)_pulCounterOutputPbuffer; \
    packed_data->args.pulCounterOutputVideo = (unsigned long *)_pulCounterOutputVideo; \
    (packed_call_t *)packed_data; \
})
#define call_glXGetVideoInfoNV(packed, ret_v) do { \
    PACKED_glXGetVideoInfoNV *unpacked = (PACKED_glXGetVideoInfoNV *)packed; \
    ARGS_glXGetVideoInfoNV *args = (ARGS_glXGetVideoInfoNV *)&unpacked->args; \
    int *ret = (int *)ret_v; \
    if (ret != NULL) { \
        *ret = glXGetVideoInfoNV(args->dpy, args->screen, args->VideoDevice, args->pulCounterOutputPbuffer, args->pulCounterOutputVideo);; \
    } else { \
        glXGetVideoInfoNV(args->dpy, args->screen, args->VideoDevice, args->pulCounterOutputPbuffer, args->pulCounterOutputVideo);; \
    } \
} while(0)
int glXGetVideoInfoNV(glXGetVideoInfoNV_ARG_EXPAND);
typedef int (*glXGetVideoInfoNV_PTR)(glXGetVideoInfoNV_ARG_EXPAND);
#define glXGetVideoSyncSGI_INDEX 2774
#define glXGetVideoSyncSGI_RETURN int
#define glXGetVideoSyncSGI_ARG_NAMES count
#define glXGetVideoSyncSGI_ARG_EXPAND unsigned int * count
#define glXGetVideoSyncSGI_PACKED PACKED_glXGetVideoSyncSGI
#define glXGetVideoSyncSGI_VOID_ONLY_WRAP(...) {}
#define glXGetVideoSyncSGI_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glXGetVideoSyncSGI(_count) ({ \
    glXGetVideoSyncSGI_PACKED *packed_data = malloc(sizeof(glXGetVideoSyncSGI_PACKED)); \
    packed_data->index = glXGetVideoSyncSGI_INDEX; \
    packed_data->args.count = (unsigned int *)_count; \
    (packed_call_t *)packed_data; \
})
#define call_glXGetVideoSyncSGI(packed, ret_v) do { \
    PACKED_glXGetVideoSyncSGI *unpacked = (PACKED_glXGetVideoSyncSGI *)packed; \
    ARGS_glXGetVideoSyncSGI *args = (ARGS_glXGetVideoSyncSGI *)&unpacked->args; \
    int *ret = (int *)ret_v; \
    if (ret != NULL) { \
        *ret = glXGetVideoSyncSGI(args->count);; \
    } else { \
        glXGetVideoSyncSGI(args->count);; \
    } \
} while(0)
int glXGetVideoSyncSGI(glXGetVideoSyncSGI_ARG_EXPAND);
typedef int (*glXGetVideoSyncSGI_PTR)(glXGetVideoSyncSGI_ARG_EXPAND);
#define glXGetVisualConfigs_INDEX 2775
#define glXGetVisualConfigs_RETURN void
#define glXGetVisualConfigs_ARG_NAMES 
#define glXGetVisualConfigs_ARG_EXPAND 
#define glXGetVisualConfigs_PACKED PACKED_glXGetVisualConfigs
#define glXGetVisualConfigs_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glXGetVisualConfigs_NOT_VOID_WRAP(...) {}
#define pack_glXGetVisualConfigs() ({ \
    glXGetVisualConfigs_PACKED *packed_data = malloc(sizeof(glXGetVisualConfigs_PACKED)); \
    packed_data->index = glXGetVisualConfigs_INDEX; \
    (packed_call_t *)packed_data; \
})
#define call_glXGetVisualConfigs(packed, ret_v) do { \
    glXGetVisualConfigs();; \
} while(0)
void glXGetVisualConfigs(glXGetVisualConfigs_ARG_EXPAND);
typedef void (*glXGetVisualConfigs_PTR)(glXGetVisualConfigs_ARG_EXPAND);
#define glXGetVisualFromFBConfig_INDEX 2776
#define glXGetVisualFromFBConfig_RETURN XVisualInfo *
#define glXGetVisualFromFBConfig_ARG_NAMES dpy, config
#define glXGetVisualFromFBConfig_ARG_EXPAND Display * dpy, GLXFBConfig config
#define glXGetVisualFromFBConfig_PACKED PACKED_glXGetVisualFromFBConfig
#define glXGetVisualFromFBConfig_VOID_ONLY_WRAP(...) {}
#define glXGetVisualFromFBConfig_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glXGetVisualFromFBConfig(_dpy, _config) ({ \
    glXGetVisualFromFBConfig_PACKED *packed_data = malloc(sizeof(glXGetVisualFromFBConfig_PACKED)); \
    packed_data->index = glXGetVisualFromFBConfig_INDEX; \
    packed_data->args.dpy = (Display *)_dpy; \
    packed_data->args.config = (GLXFBConfig)_config; \
    (packed_call_t *)packed_data; \
})
#define call_glXGetVisualFromFBConfig(packed, ret_v) do { \
    PACKED_glXGetVisualFromFBConfig *unpacked = (PACKED_glXGetVisualFromFBConfig *)packed; \
    ARGS_glXGetVisualFromFBConfig *args = (ARGS_glXGetVisualFromFBConfig *)&unpacked->args; \
    XVisualInfo * *ret = (XVisualInfo * *)ret_v; \
    if (ret != NULL) { \
        *ret = glXGetVisualFromFBConfig(args->dpy, args->config);; \
    } else { \
        glXGetVisualFromFBConfig(args->dpy, args->config);; \
    } \
} while(0)
XVisualInfo * glXGetVisualFromFBConfig(glXGetVisualFromFBConfig_ARG_EXPAND);
typedef XVisualInfo * (*glXGetVisualFromFBConfig_PTR)(glXGetVisualFromFBConfig_ARG_EXPAND);
#define glXGetVisualFromFBConfigSGIX_INDEX 2777
#define glXGetVisualFromFBConfigSGIX_RETURN XVisualInfo *
#define glXGetVisualFromFBConfigSGIX_ARG_NAMES dpy, config
#define glXGetVisualFromFBConfigSGIX_ARG_EXPAND Display * dpy, GLXFBConfigSGIX config
#define glXGetVisualFromFBConfigSGIX_PACKED PACKED_glXGetVisualFromFBConfigSGIX
#define glXGetVisualFromFBConfigSGIX_VOID_ONLY_WRAP(...) {}
#define glXGetVisualFromFBConfigSGIX_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glXGetVisualFromFBConfigSGIX(_dpy, _config) ({ \
    glXGetVisualFromFBConfigSGIX_PACKED *packed_data = malloc(sizeof(glXGetVisualFromFBConfigSGIX_PACKED)); \
    packed_data->index = glXGetVisualFromFBConfigSGIX_INDEX; \
    packed_data->args.dpy = (Display *)_dpy; \
    packed_data->args.config = (GLXFBConfigSGIX)_config; \
    (packed_call_t *)packed_data; \
})
#define call_glXGetVisualFromFBConfigSGIX(packed, ret_v) do { \
    PACKED_glXGetVisualFromFBConfigSGIX *unpacked = (PACKED_glXGetVisualFromFBConfigSGIX *)packed; \
    ARGS_glXGetVisualFromFBConfigSGIX *args = (ARGS_glXGetVisualFromFBConfigSGIX *)&unpacked->args; \
    XVisualInfo * *ret = (XVisualInfo * *)ret_v; \
    if (ret != NULL) { \
        *ret = glXGetVisualFromFBConfigSGIX(args->dpy, args->config);; \
    } else { \
        glXGetVisualFromFBConfigSGIX(args->dpy, args->config);; \
    } \
} while(0)
XVisualInfo * glXGetVisualFromFBConfigSGIX(glXGetVisualFromFBConfigSGIX_ARG_EXPAND);
typedef XVisualInfo * (*glXGetVisualFromFBConfigSGIX_PTR)(glXGetVisualFromFBConfigSGIX_ARG_EXPAND);
#define glXHyperpipeAttribSGIX_INDEX 2778
#define glXHyperpipeAttribSGIX_RETURN int
#define glXHyperpipeAttribSGIX_ARG_NAMES dpy, timeSlice, attrib, size, attribList
#define glXHyperpipeAttribSGIX_ARG_EXPAND Display * dpy, int timeSlice, int attrib, int size, void * attribList
#define glXHyperpipeAttribSGIX_PACKED PACKED_glXHyperpipeAttribSGIX
#define glXHyperpipeAttribSGIX_VOID_ONLY_WRAP(...) {}
#define glXHyperpipeAttribSGIX_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glXHyperpipeAttribSGIX(_dpy, _timeSlice, _attrib, _size, _attribList) ({ \
    glXHyperpipeAttribSGIX_PACKED *packed_data = malloc(sizeof(glXHyperpipeAttribSGIX_PACKED)); \
    packed_data->index = glXHyperpipeAttribSGIX_INDEX; \
    packed_data->args.dpy = (Display *)_dpy; \
    packed_data->args.timeSlice = (int)_timeSlice; \
    packed_data->args.attrib = (int)_attrib; \
    packed_data->args.size = (int)_size; \
    packed_data->args.attribList = (void *)_attribList; \
    (packed_call_t *)packed_data; \
})
#define call_glXHyperpipeAttribSGIX(packed, ret_v) do { \
    PACKED_glXHyperpipeAttribSGIX *unpacked = (PACKED_glXHyperpipeAttribSGIX *)packed; \
    ARGS_glXHyperpipeAttribSGIX *args = (ARGS_glXHyperpipeAttribSGIX *)&unpacked->args; \
    int *ret = (int *)ret_v; \
    if (ret != NULL) { \
        *ret = glXHyperpipeAttribSGIX(args->dpy, args->timeSlice, args->attrib, args->size, args->attribList);; \
    } else { \
        glXHyperpipeAttribSGIX(args->dpy, args->timeSlice, args->attrib, args->size, args->attribList);; \
    } \
} while(0)
int glXHyperpipeAttribSGIX(glXHyperpipeAttribSGIX_ARG_EXPAND);
typedef int (*glXHyperpipeAttribSGIX_PTR)(glXHyperpipeAttribSGIX_ARG_EXPAND);
#define glXHyperpipeConfigSGIX_INDEX 2779
#define glXHyperpipeConfigSGIX_RETURN int
#define glXHyperpipeConfigSGIX_ARG_NAMES dpy, networkId, npipes, cfg, hpId
#define glXHyperpipeConfigSGIX_ARG_EXPAND Display * dpy, int networkId, int npipes, GLXHyperpipeConfigSGIX * cfg, int * hpId
#define glXHyperpipeConfigSGIX_PACKED PACKED_glXHyperpipeConfigSGIX
#define glXHyperpipeConfigSGIX_VOID_ONLY_WRAP(...) {}
#define glXHyperpipeConfigSGIX_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glXHyperpipeConfigSGIX(_dpy, _networkId, _npipes, _cfg, _hpId) ({ \
    glXHyperpipeConfigSGIX_PACKED *packed_data = malloc(sizeof(glXHyperpipeConfigSGIX_PACKED)); \
    packed_data->index = glXHyperpipeConfigSGIX_INDEX; \
    packed_data->args.dpy = (Display *)_dpy; \
    packed_data->args.networkId = (int)_networkId; \
    packed_data->args.npipes = (int)_npipes; \
    packed_data->args.cfg = (GLXHyperpipeConfigSGIX *)_cfg; \
    packed_data->args.hpId = (int *)_hpId; \
    (packed_call_t *)packed_data; \
})
#define call_glXHyperpipeConfigSGIX(packed, ret_v) do { \
    PACKED_glXHyperpipeConfigSGIX *unpacked = (PACKED_glXHyperpipeConfigSGIX *)packed; \
    ARGS_glXHyperpipeConfigSGIX *args = (ARGS_glXHyperpipeConfigSGIX *)&unpacked->args; \
    int *ret = (int *)ret_v; \
    if (ret != NULL) { \
        *ret = glXHyperpipeConfigSGIX(args->dpy, args->networkId, args->npipes, args->cfg, args->hpId);; \
    } else { \
        glXHyperpipeConfigSGIX(args->dpy, args->networkId, args->npipes, args->cfg, args->hpId);; \
    } \
} while(0)
int glXHyperpipeConfigSGIX(glXHyperpipeConfigSGIX_ARG_EXPAND);
typedef int (*glXHyperpipeConfigSGIX_PTR)(glXHyperpipeConfigSGIX_ARG_EXPAND);
#define glXImportContextEXT_INDEX 2780
#define glXImportContextEXT_RETURN GLXContext
#define glXImportContextEXT_ARG_NAMES dpy, contextID
#define glXImportContextEXT_ARG_EXPAND Display * dpy, GLXContextID contextID
#define glXImportContextEXT_PACKED PACKED_glXImportContextEXT
#define glXImportContextEXT_VOID_ONLY_WRAP(...) {}
#define glXImportContextEXT_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glXImportContextEXT(_dpy, _contextID) ({ \
    glXImportContextEXT_PACKED *packed_data = malloc(sizeof(glXImportContextEXT_PACKED)); \
    packed_data->index = glXImportContextEXT_INDEX; \
    packed_data->args.dpy = (Display *)_dpy; \
    packed_data->args.contextID = (GLXContextID)_contextID; \
    (packed_call_t *)packed_data; \
})
#define call_glXImportContextEXT(packed, ret_v) do { \
    PACKED_glXImportContextEXT *unpacked = (PACKED_glXImportContextEXT *)packed; \
    ARGS_glXImportContextEXT *args = (ARGS_glXImportContextEXT *)&unpacked->args; \
    GLXContext *ret = (GLXContext *)ret_v; \
    if (ret != NULL) { \
        *ret = glXImportContextEXT(args->dpy, args->contextID);; \
    } else { \
        glXImportContextEXT(args->dpy, args->contextID);; \
    } \
} while(0)
GLXContext glXImportContextEXT(glXImportContextEXT_ARG_EXPAND);
typedef GLXContext (*glXImportContextEXT_PTR)(glXImportContextEXT_ARG_EXPAND);
#define glXIsDirect_INDEX 2781
#define glXIsDirect_RETURN Bool
#define glXIsDirect_ARG_NAMES dpy, ctx
#define glXIsDirect_ARG_EXPAND Display * dpy, GLXContext ctx
#define glXIsDirect_PACKED PACKED_glXIsDirect
#define glXIsDirect_VOID_ONLY_WRAP(...) {}
#define glXIsDirect_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glXIsDirect(_dpy, _ctx) ({ \
    glXIsDirect_PACKED *packed_data = malloc(sizeof(glXIsDirect_PACKED)); \
    packed_data->index = glXIsDirect_INDEX; \
    packed_data->args.dpy = (Display *)_dpy; \
    packed_data->args.ctx = (GLXContext)_ctx; \
    (packed_call_t *)packed_data; \
})
#define call_glXIsDirect(packed, ret_v) do { \
    PACKED_glXIsDirect *unpacked = (PACKED_glXIsDirect *)packed; \
    ARGS_glXIsDirect *args = (ARGS_glXIsDirect *)&unpacked->args; \
    Bool *ret = (Bool *)ret_v; \
    if (ret != NULL) { \
        *ret = glXIsDirect(args->dpy, args->ctx);; \
    } else { \
        glXIsDirect(args->dpy, args->ctx);; \
    } \
} while(0)
Bool glXIsDirect(glXIsDirect_ARG_EXPAND);
typedef Bool (*glXIsDirect_PTR)(glXIsDirect_ARG_EXPAND);
#define glXJoinSwapGroupNV_INDEX 2782
#define glXJoinSwapGroupNV_RETURN Bool
#define glXJoinSwapGroupNV_ARG_NAMES dpy, drawable, group
#define glXJoinSwapGroupNV_ARG_EXPAND Display * dpy, GLXDrawable drawable, GLuint group
#define glXJoinSwapGroupNV_PACKED PACKED_glXJoinSwapGroupNV
#define glXJoinSwapGroupNV_VOID_ONLY_WRAP(...) {}
#define glXJoinSwapGroupNV_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glXJoinSwapGroupNV(_dpy, _drawable, _group) ({ \
    glXJoinSwapGroupNV_PACKED *packed_data = malloc(sizeof(glXJoinSwapGroupNV_PACKED)); \
    packed_data->index = glXJoinSwapGroupNV_INDEX; \
    packed_data->args.dpy = (Display *)_dpy; \
    packed_data->args.drawable = (GLXDrawable)_drawable; \
    packed_data->args.group = (GLuint)_group; \
    (packed_call_t *)packed_data; \
})
#define call_glXJoinSwapGroupNV(packed, ret_v) do { \
    PACKED_glXJoinSwapGroupNV *unpacked = (PACKED_glXJoinSwapGroupNV *)packed; \
    ARGS_glXJoinSwapGroupNV *args = (ARGS_glXJoinSwapGroupNV *)&unpacked->args; \
    Bool *ret = (Bool *)ret_v; \
    if (ret != NULL) { \
        *ret = glXJoinSwapGroupNV(args->dpy, args->drawable, args->group);; \
    } else { \
        glXJoinSwapGroupNV(args->dpy, args->drawable, args->group);; \
    } \
} while(0)
Bool glXJoinSwapGroupNV(glXJoinSwapGroupNV_ARG_EXPAND);
typedef Bool (*glXJoinSwapGroupNV_PTR)(glXJoinSwapGroupNV_ARG_EXPAND);
#define glXJoinSwapGroupSGIX_INDEX 2783
#define glXJoinSwapGroupSGIX_RETURN void
#define glXJoinSwapGroupSGIX_ARG_NAMES dpy, drawable, member
#define glXJoinSwapGroupSGIX_ARG_EXPAND Display * dpy, GLXDrawable drawable, GLXDrawable member
#define glXJoinSwapGroupSGIX_PACKED PACKED_glXJoinSwapGroupSGIX
#define glXJoinSwapGroupSGIX_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glXJoinSwapGroupSGIX_NOT_VOID_WRAP(...) {}
#define pack_glXJoinSwapGroupSGIX(_dpy, _drawable, _member) ({ \
    glXJoinSwapGroupSGIX_PACKED *packed_data = malloc(sizeof(glXJoinSwapGroupSGIX_PACKED)); \
    packed_data->index = glXJoinSwapGroupSGIX_INDEX; \
    packed_data->args.dpy = (Display *)_dpy; \
    packed_data->args.drawable = (GLXDrawable)_drawable; \
    packed_data->args.member = (GLXDrawable)_member; \
    (packed_call_t *)packed_data; \
})
#define call_glXJoinSwapGroupSGIX(packed, ret_v) do { \
    PACKED_glXJoinSwapGroupSGIX *unpacked = (PACKED_glXJoinSwapGroupSGIX *)packed; \
    ARGS_glXJoinSwapGroupSGIX *args = (ARGS_glXJoinSwapGroupSGIX *)&unpacked->args; \
    glXJoinSwapGroupSGIX(args->dpy, args->drawable, args->member);; \
} while(0)
void glXJoinSwapGroupSGIX(glXJoinSwapGroupSGIX_ARG_EXPAND);
typedef void (*glXJoinSwapGroupSGIX_PTR)(glXJoinSwapGroupSGIX_ARG_EXPAND);
#define glXLockVideoCaptureDeviceNV_INDEX 2784
#define glXLockVideoCaptureDeviceNV_RETURN void
#define glXLockVideoCaptureDeviceNV_ARG_NAMES dpy, device
#define glXLockVideoCaptureDeviceNV_ARG_EXPAND Display * dpy, GLXVideoCaptureDeviceNV device
#define glXLockVideoCaptureDeviceNV_PACKED PACKED_glXLockVideoCaptureDeviceNV
#define glXLockVideoCaptureDeviceNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glXLockVideoCaptureDeviceNV_NOT_VOID_WRAP(...) {}
#define pack_glXLockVideoCaptureDeviceNV(_dpy, _device) ({ \
    glXLockVideoCaptureDeviceNV_PACKED *packed_data = malloc(sizeof(glXLockVideoCaptureDeviceNV_PACKED)); \
    packed_data->index = glXLockVideoCaptureDeviceNV_INDEX; \
    packed_data->args.dpy = (Display *)_dpy; \
    packed_data->args.device = (GLXVideoCaptureDeviceNV)_device; \
    (packed_call_t *)packed_data; \
})
#define call_glXLockVideoCaptureDeviceNV(packed, ret_v) do { \
    PACKED_glXLockVideoCaptureDeviceNV *unpacked = (PACKED_glXLockVideoCaptureDeviceNV *)packed; \
    ARGS_glXLockVideoCaptureDeviceNV *args = (ARGS_glXLockVideoCaptureDeviceNV *)&unpacked->args; \
    glXLockVideoCaptureDeviceNV(args->dpy, args->device);; \
} while(0)
void glXLockVideoCaptureDeviceNV(glXLockVideoCaptureDeviceNV_ARG_EXPAND);
typedef void (*glXLockVideoCaptureDeviceNV_PTR)(glXLockVideoCaptureDeviceNV_ARG_EXPAND);
#define glXMakeContextCurrent_INDEX 2785
#define glXMakeContextCurrent_RETURN Bool
#define glXMakeContextCurrent_ARG_NAMES dpy, draw, read, ctx
#define glXMakeContextCurrent_ARG_EXPAND Display * dpy, GLXDrawable draw, GLXDrawable read, GLXContext ctx
#define glXMakeContextCurrent_PACKED PACKED_glXMakeContextCurrent
#define glXMakeContextCurrent_VOID_ONLY_WRAP(...) {}
#define glXMakeContextCurrent_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glXMakeContextCurrent(_dpy, _draw, _read, _ctx) ({ \
    glXMakeContextCurrent_PACKED *packed_data = malloc(sizeof(glXMakeContextCurrent_PACKED)); \
    packed_data->index = glXMakeContextCurrent_INDEX; \
    packed_data->args.dpy = (Display *)_dpy; \
    packed_data->args.draw = (GLXDrawable)_draw; \
    packed_data->args.read = (GLXDrawable)_read; \
    packed_data->args.ctx = (GLXContext)_ctx; \
    (packed_call_t *)packed_data; \
})
#define call_glXMakeContextCurrent(packed, ret_v) do { \
    PACKED_glXMakeContextCurrent *unpacked = (PACKED_glXMakeContextCurrent *)packed; \
    ARGS_glXMakeContextCurrent *args = (ARGS_glXMakeContextCurrent *)&unpacked->args; \
    Bool *ret = (Bool *)ret_v; \
    if (ret != NULL) { \
        *ret = glXMakeContextCurrent(args->dpy, args->draw, args->read, args->ctx);; \
    } else { \
        glXMakeContextCurrent(args->dpy, args->draw, args->read, args->ctx);; \
    } \
} while(0)
Bool glXMakeContextCurrent(glXMakeContextCurrent_ARG_EXPAND);
typedef Bool (*glXMakeContextCurrent_PTR)(glXMakeContextCurrent_ARG_EXPAND);
#define glXMakeCurrent_INDEX 2786
#define glXMakeCurrent_RETURN Bool
#define glXMakeCurrent_ARG_NAMES dpy, drawable, ctx
#define glXMakeCurrent_ARG_EXPAND Display * dpy, GLXDrawable drawable, GLXContext ctx
#define glXMakeCurrent_PACKED PACKED_glXMakeCurrent
#define glXMakeCurrent_VOID_ONLY_WRAP(...) {}
#define glXMakeCurrent_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glXMakeCurrent(_dpy, _drawable, _ctx) ({ \
    glXMakeCurrent_PACKED *packed_data = malloc(sizeof(glXMakeCurrent_PACKED)); \
    packed_data->index = glXMakeCurrent_INDEX; \
    packed_data->args.dpy = (Display *)_dpy; \
    packed_data->args.drawable = (GLXDrawable)_drawable; \
    packed_data->args.ctx = (GLXContext)_ctx; \
    (packed_call_t *)packed_data; \
})
#define call_glXMakeCurrent(packed, ret_v) do { \
    PACKED_glXMakeCurrent *unpacked = (PACKED_glXMakeCurrent *)packed; \
    ARGS_glXMakeCurrent *args = (ARGS_glXMakeCurrent *)&unpacked->args; \
    Bool *ret = (Bool *)ret_v; \
    if (ret != NULL) { \
        *ret = glXMakeCurrent(args->dpy, args->drawable, args->ctx);; \
    } else { \
        glXMakeCurrent(args->dpy, args->drawable, args->ctx);; \
    } \
} while(0)
Bool glXMakeCurrent(glXMakeCurrent_ARG_EXPAND);
typedef Bool (*glXMakeCurrent_PTR)(glXMakeCurrent_ARG_EXPAND);
#define glXMakeCurrentReadSGI_INDEX 2787
#define glXMakeCurrentReadSGI_RETURN Bool
#define glXMakeCurrentReadSGI_ARG_NAMES dpy, draw, read, ctx
#define glXMakeCurrentReadSGI_ARG_EXPAND Display * dpy, GLXDrawable draw, GLXDrawable read, GLXContext ctx
#define glXMakeCurrentReadSGI_PACKED PACKED_glXMakeCurrentReadSGI
#define glXMakeCurrentReadSGI_VOID_ONLY_WRAP(...) {}
#define glXMakeCurrentReadSGI_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glXMakeCurrentReadSGI(_dpy, _draw, _read, _ctx) ({ \
    glXMakeCurrentReadSGI_PACKED *packed_data = malloc(sizeof(glXMakeCurrentReadSGI_PACKED)); \
    packed_data->index = glXMakeCurrentReadSGI_INDEX; \
    packed_data->args.dpy = (Display *)_dpy; \
    packed_data->args.draw = (GLXDrawable)_draw; \
    packed_data->args.read = (GLXDrawable)_read; \
    packed_data->args.ctx = (GLXContext)_ctx; \
    (packed_call_t *)packed_data; \
})
#define call_glXMakeCurrentReadSGI(packed, ret_v) do { \
    PACKED_glXMakeCurrentReadSGI *unpacked = (PACKED_glXMakeCurrentReadSGI *)packed; \
    ARGS_glXMakeCurrentReadSGI *args = (ARGS_glXMakeCurrentReadSGI *)&unpacked->args; \
    Bool *ret = (Bool *)ret_v; \
    if (ret != NULL) { \
        *ret = glXMakeCurrentReadSGI(args->dpy, args->draw, args->read, args->ctx);; \
    } else { \
        glXMakeCurrentReadSGI(args->dpy, args->draw, args->read, args->ctx);; \
    } \
} while(0)
Bool glXMakeCurrentReadSGI(glXMakeCurrentReadSGI_ARG_EXPAND);
typedef Bool (*glXMakeCurrentReadSGI_PTR)(glXMakeCurrentReadSGI_ARG_EXPAND);
#define glXQueryChannelDeltasSGIX_INDEX 2788
#define glXQueryChannelDeltasSGIX_RETURN int
#define glXQueryChannelDeltasSGIX_ARG_NAMES display, screen, channel, x, y, w, h
#define glXQueryChannelDeltasSGIX_ARG_EXPAND Display * display, int screen, int channel, int * x, int * y, int * w, int * h
#define glXQueryChannelDeltasSGIX_PACKED PACKED_glXQueryChannelDeltasSGIX
#define glXQueryChannelDeltasSGIX_VOID_ONLY_WRAP(...) {}
#define glXQueryChannelDeltasSGIX_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glXQueryChannelDeltasSGIX(_display, _screen, _channel, _x, _y, _w, _h) ({ \
    glXQueryChannelDeltasSGIX_PACKED *packed_data = malloc(sizeof(glXQueryChannelDeltasSGIX_PACKED)); \
    packed_data->index = glXQueryChannelDeltasSGIX_INDEX; \
    packed_data->args.display = (Display *)_display; \
    packed_data->args.screen = (int)_screen; \
    packed_data->args.channel = (int)_channel; \
    packed_data->args.x = (int *)_x; \
    packed_data->args.y = (int *)_y; \
    packed_data->args.w = (int *)_w; \
    packed_data->args.h = (int *)_h; \
    (packed_call_t *)packed_data; \
})
#define call_glXQueryChannelDeltasSGIX(packed, ret_v) do { \
    PACKED_glXQueryChannelDeltasSGIX *unpacked = (PACKED_glXQueryChannelDeltasSGIX *)packed; \
    ARGS_glXQueryChannelDeltasSGIX *args = (ARGS_glXQueryChannelDeltasSGIX *)&unpacked->args; \
    int *ret = (int *)ret_v; \
    if (ret != NULL) { \
        *ret = glXQueryChannelDeltasSGIX(args->display, args->screen, args->channel, args->x, args->y, args->w, args->h);; \
    } else { \
        glXQueryChannelDeltasSGIX(args->display, args->screen, args->channel, args->x, args->y, args->w, args->h);; \
    } \
} while(0)
int glXQueryChannelDeltasSGIX(glXQueryChannelDeltasSGIX_ARG_EXPAND);
typedef int (*glXQueryChannelDeltasSGIX_PTR)(glXQueryChannelDeltasSGIX_ARG_EXPAND);
#define glXQueryChannelRectSGIX_INDEX 2789
#define glXQueryChannelRectSGIX_RETURN int
#define glXQueryChannelRectSGIX_ARG_NAMES display, screen, channel, dx, dy, dw, dh
#define glXQueryChannelRectSGIX_ARG_EXPAND Display * display, int screen, int channel, int * dx, int * dy, int * dw, int * dh
#define glXQueryChannelRectSGIX_PACKED PACKED_glXQueryChannelRectSGIX
#define glXQueryChannelRectSGIX_VOID_ONLY_WRAP(...) {}
#define glXQueryChannelRectSGIX_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glXQueryChannelRectSGIX(_display, _screen, _channel, _dx, _dy, _dw, _dh) ({ \
    glXQueryChannelRectSGIX_PACKED *packed_data = malloc(sizeof(glXQueryChannelRectSGIX_PACKED)); \
    packed_data->index = glXQueryChannelRectSGIX_INDEX; \
    packed_data->args.display = (Display *)_display; \
    packed_data->args.screen = (int)_screen; \
    packed_data->args.channel = (int)_channel; \
    packed_data->args.dx = (int *)_dx; \
    packed_data->args.dy = (int *)_dy; \
    packed_data->args.dw = (int *)_dw; \
    packed_data->args.dh = (int *)_dh; \
    (packed_call_t *)packed_data; \
})
#define call_glXQueryChannelRectSGIX(packed, ret_v) do { \
    PACKED_glXQueryChannelRectSGIX *unpacked = (PACKED_glXQueryChannelRectSGIX *)packed; \
    ARGS_glXQueryChannelRectSGIX *args = (ARGS_glXQueryChannelRectSGIX *)&unpacked->args; \
    int *ret = (int *)ret_v; \
    if (ret != NULL) { \
        *ret = glXQueryChannelRectSGIX(args->display, args->screen, args->channel, args->dx, args->dy, args->dw, args->dh);; \
    } else { \
        glXQueryChannelRectSGIX(args->display, args->screen, args->channel, args->dx, args->dy, args->dw, args->dh);; \
    } \
} while(0)
int glXQueryChannelRectSGIX(glXQueryChannelRectSGIX_ARG_EXPAND);
typedef int (*glXQueryChannelRectSGIX_PTR)(glXQueryChannelRectSGIX_ARG_EXPAND);
#define glXQueryContext_INDEX 2790
#define glXQueryContext_RETURN int
#define glXQueryContext_ARG_NAMES dpy, ctx, attribute, value
#define glXQueryContext_ARG_EXPAND Display * dpy, GLXContext ctx, int attribute, int * value
#define glXQueryContext_PACKED PACKED_glXQueryContext
#define glXQueryContext_VOID_ONLY_WRAP(...) {}
#define glXQueryContext_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glXQueryContext(_dpy, _ctx, _attribute, _value) ({ \
    glXQueryContext_PACKED *packed_data = malloc(sizeof(glXQueryContext_PACKED)); \
    packed_data->index = glXQueryContext_INDEX; \
    packed_data->args.dpy = (Display *)_dpy; \
    packed_data->args.ctx = (GLXContext)_ctx; \
    packed_data->args.attribute = (int)_attribute; \
    packed_data->args.value = (int *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glXQueryContext(packed, ret_v) do { \
    PACKED_glXQueryContext *unpacked = (PACKED_glXQueryContext *)packed; \
    ARGS_glXQueryContext *args = (ARGS_glXQueryContext *)&unpacked->args; \
    int *ret = (int *)ret_v; \
    if (ret != NULL) { \
        *ret = glXQueryContext(args->dpy, args->ctx, args->attribute, args->value);; \
    } else { \
        glXQueryContext(args->dpy, args->ctx, args->attribute, args->value);; \
    } \
} while(0)
int glXQueryContext(glXQueryContext_ARG_EXPAND);
typedef int (*glXQueryContext_PTR)(glXQueryContext_ARG_EXPAND);
#define glXQueryContextInfoEXT_INDEX 2791
#define glXQueryContextInfoEXT_RETURN int
#define glXQueryContextInfoEXT_ARG_NAMES dpy, context, attribute, value
#define glXQueryContextInfoEXT_ARG_EXPAND Display * dpy, GLXContext context, int attribute, int * value
#define glXQueryContextInfoEXT_PACKED PACKED_glXQueryContextInfoEXT
#define glXQueryContextInfoEXT_VOID_ONLY_WRAP(...) {}
#define glXQueryContextInfoEXT_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glXQueryContextInfoEXT(_dpy, _context, _attribute, _value) ({ \
    glXQueryContextInfoEXT_PACKED *packed_data = malloc(sizeof(glXQueryContextInfoEXT_PACKED)); \
    packed_data->index = glXQueryContextInfoEXT_INDEX; \
    packed_data->args.dpy = (Display *)_dpy; \
    packed_data->args.context = (GLXContext)_context; \
    packed_data->args.attribute = (int)_attribute; \
    packed_data->args.value = (int *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glXQueryContextInfoEXT(packed, ret_v) do { \
    PACKED_glXQueryContextInfoEXT *unpacked = (PACKED_glXQueryContextInfoEXT *)packed; \
    ARGS_glXQueryContextInfoEXT *args = (ARGS_glXQueryContextInfoEXT *)&unpacked->args; \
    int *ret = (int *)ret_v; \
    if (ret != NULL) { \
        *ret = glXQueryContextInfoEXT(args->dpy, args->context, args->attribute, args->value);; \
    } else { \
        glXQueryContextInfoEXT(args->dpy, args->context, args->attribute, args->value);; \
    } \
} while(0)
int glXQueryContextInfoEXT(glXQueryContextInfoEXT_ARG_EXPAND);
typedef int (*glXQueryContextInfoEXT_PTR)(glXQueryContextInfoEXT_ARG_EXPAND);
#define glXQueryDrawable_INDEX 2792
#define glXQueryDrawable_RETURN void
#define glXQueryDrawable_ARG_NAMES dpy, draw, attribute, value
#define glXQueryDrawable_ARG_EXPAND Display * dpy, GLXDrawable draw, int attribute, unsigned int * value
#define glXQueryDrawable_PACKED PACKED_glXQueryDrawable
#define glXQueryDrawable_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glXQueryDrawable_NOT_VOID_WRAP(...) {}
#define pack_glXQueryDrawable(_dpy, _draw, _attribute, _value) ({ \
    glXQueryDrawable_PACKED *packed_data = malloc(sizeof(glXQueryDrawable_PACKED)); \
    packed_data->index = glXQueryDrawable_INDEX; \
    packed_data->args.dpy = (Display *)_dpy; \
    packed_data->args.draw = (GLXDrawable)_draw; \
    packed_data->args.attribute = (int)_attribute; \
    packed_data->args.value = (unsigned int *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glXQueryDrawable(packed, ret_v) do { \
    PACKED_glXQueryDrawable *unpacked = (PACKED_glXQueryDrawable *)packed; \
    ARGS_glXQueryDrawable *args = (ARGS_glXQueryDrawable *)&unpacked->args; \
    glXQueryDrawable(args->dpy, args->draw, args->attribute, args->value);; \
} while(0)
void glXQueryDrawable(glXQueryDrawable_ARG_EXPAND);
typedef void (*glXQueryDrawable_PTR)(glXQueryDrawable_ARG_EXPAND);
#define glXQueryExtension_INDEX 2793
#define glXQueryExtension_RETURN Bool
#define glXQueryExtension_ARG_NAMES display, errorBase, eventBase
#define glXQueryExtension_ARG_EXPAND Display * display, int * errorBase, int * eventBase
#define glXQueryExtension_PACKED PACKED_glXQueryExtension
#define glXQueryExtension_VOID_ONLY_WRAP(...) {}
#define glXQueryExtension_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glXQueryExtension(_display, _errorBase, _eventBase) ({ \
    glXQueryExtension_PACKED *packed_data = malloc(sizeof(glXQueryExtension_PACKED)); \
    packed_data->index = glXQueryExtension_INDEX; \
    packed_data->args.display = (Display *)_display; \
    packed_data->args.errorBase = (int *)_errorBase; \
    packed_data->args.eventBase = (int *)_eventBase; \
    (packed_call_t *)packed_data; \
})
#define call_glXQueryExtension(packed, ret_v) do { \
    PACKED_glXQueryExtension *unpacked = (PACKED_glXQueryExtension *)packed; \
    ARGS_glXQueryExtension *args = (ARGS_glXQueryExtension *)&unpacked->args; \
    Bool *ret = (Bool *)ret_v; \
    if (ret != NULL) { \
        *ret = glXQueryExtension(args->display, args->errorBase, args->eventBase);; \
    } else { \
        glXQueryExtension(args->display, args->errorBase, args->eventBase);; \
    } \
} while(0)
Bool glXQueryExtension(glXQueryExtension_ARG_EXPAND);
typedef Bool (*glXQueryExtension_PTR)(glXQueryExtension_ARG_EXPAND);
#define glXQueryExtensionsString_INDEX 2794
#define glXQueryExtensionsString_RETURN const char *
#define glXQueryExtensionsString_ARG_NAMES dpy, screen
#define glXQueryExtensionsString_ARG_EXPAND Display * dpy, int screen
#define glXQueryExtensionsString_PACKED PACKED_glXQueryExtensionsString
#define glXQueryExtensionsString_VOID_ONLY_WRAP(...) {}
#define glXQueryExtensionsString_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glXQueryExtensionsString(_dpy, _screen) ({ \
    glXQueryExtensionsString_PACKED *packed_data = malloc(sizeof(glXQueryExtensionsString_PACKED)); \
    packed_data->index = glXQueryExtensionsString_INDEX; \
    packed_data->args.dpy = (Display *)_dpy; \
    packed_data->args.screen = (int)_screen; \
    (packed_call_t *)packed_data; \
})
#define call_glXQueryExtensionsString(packed, ret_v) do { \
    PACKED_glXQueryExtensionsString *unpacked = (PACKED_glXQueryExtensionsString *)packed; \
    ARGS_glXQueryExtensionsString *args = (ARGS_glXQueryExtensionsString *)&unpacked->args; \
    const char * *ret = (const char * *)ret_v; \
    if (ret != NULL) { \
        *ret = glXQueryExtensionsString(args->dpy, args->screen);; \
    } else { \
        glXQueryExtensionsString(args->dpy, args->screen);; \
    } \
} while(0)
const char * glXQueryExtensionsString(glXQueryExtensionsString_ARG_EXPAND);
typedef const char * (*glXQueryExtensionsString_PTR)(glXQueryExtensionsString_ARG_EXPAND);
#define glXQueryFrameCountNV_INDEX 2795
#define glXQueryFrameCountNV_RETURN Bool
#define glXQueryFrameCountNV_ARG_NAMES dpy, screen, count
#define glXQueryFrameCountNV_ARG_EXPAND Display * dpy, int screen, GLuint * count
#define glXQueryFrameCountNV_PACKED PACKED_glXQueryFrameCountNV
#define glXQueryFrameCountNV_VOID_ONLY_WRAP(...) {}
#define glXQueryFrameCountNV_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glXQueryFrameCountNV(_dpy, _screen, _count) ({ \
    glXQueryFrameCountNV_PACKED *packed_data = malloc(sizeof(glXQueryFrameCountNV_PACKED)); \
    packed_data->index = glXQueryFrameCountNV_INDEX; \
    packed_data->args.dpy = (Display *)_dpy; \
    packed_data->args.screen = (int)_screen; \
    packed_data->args.count = (GLuint *)_count; \
    (packed_call_t *)packed_data; \
})
#define call_glXQueryFrameCountNV(packed, ret_v) do { \
    PACKED_glXQueryFrameCountNV *unpacked = (PACKED_glXQueryFrameCountNV *)packed; \
    ARGS_glXQueryFrameCountNV *args = (ARGS_glXQueryFrameCountNV *)&unpacked->args; \
    Bool *ret = (Bool *)ret_v; \
    if (ret != NULL) { \
        *ret = glXQueryFrameCountNV(args->dpy, args->screen, args->count);; \
    } else { \
        glXQueryFrameCountNV(args->dpy, args->screen, args->count);; \
    } \
} while(0)
Bool glXQueryFrameCountNV(glXQueryFrameCountNV_ARG_EXPAND);
typedef Bool (*glXQueryFrameCountNV_PTR)(glXQueryFrameCountNV_ARG_EXPAND);
#define glXQueryGLXPbufferSGIX_INDEX 2796
#define glXQueryGLXPbufferSGIX_RETURN int
#define glXQueryGLXPbufferSGIX_ARG_NAMES dpy, pbuf, attribute, value
#define glXQueryGLXPbufferSGIX_ARG_EXPAND Display * dpy, GLXPbufferSGIX pbuf, int attribute, unsigned int * value
#define glXQueryGLXPbufferSGIX_PACKED PACKED_glXQueryGLXPbufferSGIX
#define glXQueryGLXPbufferSGIX_VOID_ONLY_WRAP(...) {}
#define glXQueryGLXPbufferSGIX_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glXQueryGLXPbufferSGIX(_dpy, _pbuf, _attribute, _value) ({ \
    glXQueryGLXPbufferSGIX_PACKED *packed_data = malloc(sizeof(glXQueryGLXPbufferSGIX_PACKED)); \
    packed_data->index = glXQueryGLXPbufferSGIX_INDEX; \
    packed_data->args.dpy = (Display *)_dpy; \
    packed_data->args.pbuf = (GLXPbufferSGIX)_pbuf; \
    packed_data->args.attribute = (int)_attribute; \
    packed_data->args.value = (unsigned int *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glXQueryGLXPbufferSGIX(packed, ret_v) do { \
    PACKED_glXQueryGLXPbufferSGIX *unpacked = (PACKED_glXQueryGLXPbufferSGIX *)packed; \
    ARGS_glXQueryGLXPbufferSGIX *args = (ARGS_glXQueryGLXPbufferSGIX *)&unpacked->args; \
    int *ret = (int *)ret_v; \
    if (ret != NULL) { \
        *ret = glXQueryGLXPbufferSGIX(args->dpy, args->pbuf, args->attribute, args->value);; \
    } else { \
        glXQueryGLXPbufferSGIX(args->dpy, args->pbuf, args->attribute, args->value);; \
    } \
} while(0)
int glXQueryGLXPbufferSGIX(glXQueryGLXPbufferSGIX_ARG_EXPAND);
typedef int (*glXQueryGLXPbufferSGIX_PTR)(glXQueryGLXPbufferSGIX_ARG_EXPAND);
#define glXQueryHyperpipeAttribSGIX_INDEX 2797
#define glXQueryHyperpipeAttribSGIX_RETURN int
#define glXQueryHyperpipeAttribSGIX_ARG_NAMES dpy, timeSlice, attrib, size, returnAttribList
#define glXQueryHyperpipeAttribSGIX_ARG_EXPAND Display * dpy, int timeSlice, int attrib, int size, void * returnAttribList
#define glXQueryHyperpipeAttribSGIX_PACKED PACKED_glXQueryHyperpipeAttribSGIX
#define glXQueryHyperpipeAttribSGIX_VOID_ONLY_WRAP(...) {}
#define glXQueryHyperpipeAttribSGIX_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glXQueryHyperpipeAttribSGIX(_dpy, _timeSlice, _attrib, _size, _returnAttribList) ({ \
    glXQueryHyperpipeAttribSGIX_PACKED *packed_data = malloc(sizeof(glXQueryHyperpipeAttribSGIX_PACKED)); \
    packed_data->index = glXQueryHyperpipeAttribSGIX_INDEX; \
    packed_data->args.dpy = (Display *)_dpy; \
    packed_data->args.timeSlice = (int)_timeSlice; \
    packed_data->args.attrib = (int)_attrib; \
    packed_data->args.size = (int)_size; \
    packed_data->args.returnAttribList = (void *)_returnAttribList; \
    (packed_call_t *)packed_data; \
})
#define call_glXQueryHyperpipeAttribSGIX(packed, ret_v) do { \
    PACKED_glXQueryHyperpipeAttribSGIX *unpacked = (PACKED_glXQueryHyperpipeAttribSGIX *)packed; \
    ARGS_glXQueryHyperpipeAttribSGIX *args = (ARGS_glXQueryHyperpipeAttribSGIX *)&unpacked->args; \
    int *ret = (int *)ret_v; \
    if (ret != NULL) { \
        *ret = glXQueryHyperpipeAttribSGIX(args->dpy, args->timeSlice, args->attrib, args->size, args->returnAttribList);; \
    } else { \
        glXQueryHyperpipeAttribSGIX(args->dpy, args->timeSlice, args->attrib, args->size, args->returnAttribList);; \
    } \
} while(0)
int glXQueryHyperpipeAttribSGIX(glXQueryHyperpipeAttribSGIX_ARG_EXPAND);
typedef int (*glXQueryHyperpipeAttribSGIX_PTR)(glXQueryHyperpipeAttribSGIX_ARG_EXPAND);
#define glXQueryHyperpipeBestAttribSGIX_INDEX 2798
#define glXQueryHyperpipeBestAttribSGIX_RETURN int
#define glXQueryHyperpipeBestAttribSGIX_ARG_NAMES dpy, timeSlice, attrib, size, attribList, returnAttribList
#define glXQueryHyperpipeBestAttribSGIX_ARG_EXPAND Display * dpy, int timeSlice, int attrib, int size, void * attribList, void * returnAttribList
#define glXQueryHyperpipeBestAttribSGIX_PACKED PACKED_glXQueryHyperpipeBestAttribSGIX
#define glXQueryHyperpipeBestAttribSGIX_VOID_ONLY_WRAP(...) {}
#define glXQueryHyperpipeBestAttribSGIX_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glXQueryHyperpipeBestAttribSGIX(_dpy, _timeSlice, _attrib, _size, _attribList, _returnAttribList) ({ \
    glXQueryHyperpipeBestAttribSGIX_PACKED *packed_data = malloc(sizeof(glXQueryHyperpipeBestAttribSGIX_PACKED)); \
    packed_data->index = glXQueryHyperpipeBestAttribSGIX_INDEX; \
    packed_data->args.dpy = (Display *)_dpy; \
    packed_data->args.timeSlice = (int)_timeSlice; \
    packed_data->args.attrib = (int)_attrib; \
    packed_data->args.size = (int)_size; \
    packed_data->args.attribList = (void *)_attribList; \
    packed_data->args.returnAttribList = (void *)_returnAttribList; \
    (packed_call_t *)packed_data; \
})
#define call_glXQueryHyperpipeBestAttribSGIX(packed, ret_v) do { \
    PACKED_glXQueryHyperpipeBestAttribSGIX *unpacked = (PACKED_glXQueryHyperpipeBestAttribSGIX *)packed; \
    ARGS_glXQueryHyperpipeBestAttribSGIX *args = (ARGS_glXQueryHyperpipeBestAttribSGIX *)&unpacked->args; \
    int *ret = (int *)ret_v; \
    if (ret != NULL) { \
        *ret = glXQueryHyperpipeBestAttribSGIX(args->dpy, args->timeSlice, args->attrib, args->size, args->attribList, args->returnAttribList);; \
    } else { \
        glXQueryHyperpipeBestAttribSGIX(args->dpy, args->timeSlice, args->attrib, args->size, args->attribList, args->returnAttribList);; \
    } \
} while(0)
int glXQueryHyperpipeBestAttribSGIX(glXQueryHyperpipeBestAttribSGIX_ARG_EXPAND);
typedef int (*glXQueryHyperpipeBestAttribSGIX_PTR)(glXQueryHyperpipeBestAttribSGIX_ARG_EXPAND);
#define glXQueryHyperpipeConfigSGIX_INDEX 2799
#define glXQueryHyperpipeConfigSGIX_RETURN GLXHyperpipeConfigSGIX *
#define glXQueryHyperpipeConfigSGIX_ARG_NAMES dpy, hpId, npipes
#define glXQueryHyperpipeConfigSGIX_ARG_EXPAND Display * dpy, int hpId, int * npipes
#define glXQueryHyperpipeConfigSGIX_PACKED PACKED_glXQueryHyperpipeConfigSGIX
#define glXQueryHyperpipeConfigSGIX_VOID_ONLY_WRAP(...) {}
#define glXQueryHyperpipeConfigSGIX_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glXQueryHyperpipeConfigSGIX(_dpy, _hpId, _npipes) ({ \
    glXQueryHyperpipeConfigSGIX_PACKED *packed_data = malloc(sizeof(glXQueryHyperpipeConfigSGIX_PACKED)); \
    packed_data->index = glXQueryHyperpipeConfigSGIX_INDEX; \
    packed_data->args.dpy = (Display *)_dpy; \
    packed_data->args.hpId = (int)_hpId; \
    packed_data->args.npipes = (int *)_npipes; \
    (packed_call_t *)packed_data; \
})
#define call_glXQueryHyperpipeConfigSGIX(packed, ret_v) do { \
    PACKED_glXQueryHyperpipeConfigSGIX *unpacked = (PACKED_glXQueryHyperpipeConfigSGIX *)packed; \
    ARGS_glXQueryHyperpipeConfigSGIX *args = (ARGS_glXQueryHyperpipeConfigSGIX *)&unpacked->args; \
    GLXHyperpipeConfigSGIX * *ret = (GLXHyperpipeConfigSGIX * *)ret_v; \
    if (ret != NULL) { \
        *ret = glXQueryHyperpipeConfigSGIX(args->dpy, args->hpId, args->npipes);; \
    } else { \
        glXQueryHyperpipeConfigSGIX(args->dpy, args->hpId, args->npipes);; \
    } \
} while(0)
GLXHyperpipeConfigSGIX * glXQueryHyperpipeConfigSGIX(glXQueryHyperpipeConfigSGIX_ARG_EXPAND);
typedef GLXHyperpipeConfigSGIX * (*glXQueryHyperpipeConfigSGIX_PTR)(glXQueryHyperpipeConfigSGIX_ARG_EXPAND);
#define glXQueryHyperpipeNetworkSGIX_INDEX 2800
#define glXQueryHyperpipeNetworkSGIX_RETURN GLXHyperpipeNetworkSGIX *
#define glXQueryHyperpipeNetworkSGIX_ARG_NAMES dpy, npipes
#define glXQueryHyperpipeNetworkSGIX_ARG_EXPAND Display * dpy, int * npipes
#define glXQueryHyperpipeNetworkSGIX_PACKED PACKED_glXQueryHyperpipeNetworkSGIX
#define glXQueryHyperpipeNetworkSGIX_VOID_ONLY_WRAP(...) {}
#define glXQueryHyperpipeNetworkSGIX_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glXQueryHyperpipeNetworkSGIX(_dpy, _npipes) ({ \
    glXQueryHyperpipeNetworkSGIX_PACKED *packed_data = malloc(sizeof(glXQueryHyperpipeNetworkSGIX_PACKED)); \
    packed_data->index = glXQueryHyperpipeNetworkSGIX_INDEX; \
    packed_data->args.dpy = (Display *)_dpy; \
    packed_data->args.npipes = (int *)_npipes; \
    (packed_call_t *)packed_data; \
})
#define call_glXQueryHyperpipeNetworkSGIX(packed, ret_v) do { \
    PACKED_glXQueryHyperpipeNetworkSGIX *unpacked = (PACKED_glXQueryHyperpipeNetworkSGIX *)packed; \
    ARGS_glXQueryHyperpipeNetworkSGIX *args = (ARGS_glXQueryHyperpipeNetworkSGIX *)&unpacked->args; \
    GLXHyperpipeNetworkSGIX * *ret = (GLXHyperpipeNetworkSGIX * *)ret_v; \
    if (ret != NULL) { \
        *ret = glXQueryHyperpipeNetworkSGIX(args->dpy, args->npipes);; \
    } else { \
        glXQueryHyperpipeNetworkSGIX(args->dpy, args->npipes);; \
    } \
} while(0)
GLXHyperpipeNetworkSGIX * glXQueryHyperpipeNetworkSGIX(glXQueryHyperpipeNetworkSGIX_ARG_EXPAND);
typedef GLXHyperpipeNetworkSGIX * (*glXQueryHyperpipeNetworkSGIX_PTR)(glXQueryHyperpipeNetworkSGIX_ARG_EXPAND);
#define glXQueryMaxSwapBarriersSGIX_INDEX 2801
#define glXQueryMaxSwapBarriersSGIX_RETURN Bool
#define glXQueryMaxSwapBarriersSGIX_ARG_NAMES dpy, screen, max
#define glXQueryMaxSwapBarriersSGIX_ARG_EXPAND Display * dpy, int screen, int * max
#define glXQueryMaxSwapBarriersSGIX_PACKED PACKED_glXQueryMaxSwapBarriersSGIX
#define glXQueryMaxSwapBarriersSGIX_VOID_ONLY_WRAP(...) {}
#define glXQueryMaxSwapBarriersSGIX_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glXQueryMaxSwapBarriersSGIX(_dpy, _screen, _max) ({ \
    glXQueryMaxSwapBarriersSGIX_PACKED *packed_data = malloc(sizeof(glXQueryMaxSwapBarriersSGIX_PACKED)); \
    packed_data->index = glXQueryMaxSwapBarriersSGIX_INDEX; \
    packed_data->args.dpy = (Display *)_dpy; \
    packed_data->args.screen = (int)_screen; \
    packed_data->args.max = (int *)_max; \
    (packed_call_t *)packed_data; \
})
#define call_glXQueryMaxSwapBarriersSGIX(packed, ret_v) do { \
    PACKED_glXQueryMaxSwapBarriersSGIX *unpacked = (PACKED_glXQueryMaxSwapBarriersSGIX *)packed; \
    ARGS_glXQueryMaxSwapBarriersSGIX *args = (ARGS_glXQueryMaxSwapBarriersSGIX *)&unpacked->args; \
    Bool *ret = (Bool *)ret_v; \
    if (ret != NULL) { \
        *ret = glXQueryMaxSwapBarriersSGIX(args->dpy, args->screen, args->max);; \
    } else { \
        glXQueryMaxSwapBarriersSGIX(args->dpy, args->screen, args->max);; \
    } \
} while(0)
Bool glXQueryMaxSwapBarriersSGIX(glXQueryMaxSwapBarriersSGIX_ARG_EXPAND);
typedef Bool (*glXQueryMaxSwapBarriersSGIX_PTR)(glXQueryMaxSwapBarriersSGIX_ARG_EXPAND);
#define glXQueryMaxSwapGroupsNV_INDEX 2802
#define glXQueryMaxSwapGroupsNV_RETURN Bool
#define glXQueryMaxSwapGroupsNV_ARG_NAMES dpy, screen, maxGroups, maxBarriers
#define glXQueryMaxSwapGroupsNV_ARG_EXPAND Display * dpy, int screen, GLuint * maxGroups, GLuint * maxBarriers
#define glXQueryMaxSwapGroupsNV_PACKED PACKED_glXQueryMaxSwapGroupsNV
#define glXQueryMaxSwapGroupsNV_VOID_ONLY_WRAP(...) {}
#define glXQueryMaxSwapGroupsNV_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glXQueryMaxSwapGroupsNV(_dpy, _screen, _maxGroups, _maxBarriers) ({ \
    glXQueryMaxSwapGroupsNV_PACKED *packed_data = malloc(sizeof(glXQueryMaxSwapGroupsNV_PACKED)); \
    packed_data->index = glXQueryMaxSwapGroupsNV_INDEX; \
    packed_data->args.dpy = (Display *)_dpy; \
    packed_data->args.screen = (int)_screen; \
    packed_data->args.maxGroups = (GLuint *)_maxGroups; \
    packed_data->args.maxBarriers = (GLuint *)_maxBarriers; \
    (packed_call_t *)packed_data; \
})
#define call_glXQueryMaxSwapGroupsNV(packed, ret_v) do { \
    PACKED_glXQueryMaxSwapGroupsNV *unpacked = (PACKED_glXQueryMaxSwapGroupsNV *)packed; \
    ARGS_glXQueryMaxSwapGroupsNV *args = (ARGS_glXQueryMaxSwapGroupsNV *)&unpacked->args; \
    Bool *ret = (Bool *)ret_v; \
    if (ret != NULL) { \
        *ret = glXQueryMaxSwapGroupsNV(args->dpy, args->screen, args->maxGroups, args->maxBarriers);; \
    } else { \
        glXQueryMaxSwapGroupsNV(args->dpy, args->screen, args->maxGroups, args->maxBarriers);; \
    } \
} while(0)
Bool glXQueryMaxSwapGroupsNV(glXQueryMaxSwapGroupsNV_ARG_EXPAND);
typedef Bool (*glXQueryMaxSwapGroupsNV_PTR)(glXQueryMaxSwapGroupsNV_ARG_EXPAND);
#define glXQueryServerString_INDEX 2803
#define glXQueryServerString_RETURN const char *
#define glXQueryServerString_ARG_NAMES dpy, screen, name
#define glXQueryServerString_ARG_EXPAND Display * dpy, int screen, int name
#define glXQueryServerString_PACKED PACKED_glXQueryServerString
#define glXQueryServerString_VOID_ONLY_WRAP(...) {}
#define glXQueryServerString_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glXQueryServerString(_dpy, _screen, _name) ({ \
    glXQueryServerString_PACKED *packed_data = malloc(sizeof(glXQueryServerString_PACKED)); \
    packed_data->index = glXQueryServerString_INDEX; \
    packed_data->args.dpy = (Display *)_dpy; \
    packed_data->args.screen = (int)_screen; \
    packed_data->args.name = (int)_name; \
    (packed_call_t *)packed_data; \
})
#define call_glXQueryServerString(packed, ret_v) do { \
    PACKED_glXQueryServerString *unpacked = (PACKED_glXQueryServerString *)packed; \
    ARGS_glXQueryServerString *args = (ARGS_glXQueryServerString *)&unpacked->args; \
    const char * *ret = (const char * *)ret_v; \
    if (ret != NULL) { \
        *ret = glXQueryServerString(args->dpy, args->screen, args->name);; \
    } else { \
        glXQueryServerString(args->dpy, args->screen, args->name);; \
    } \
} while(0)
const char * glXQueryServerString(glXQueryServerString_ARG_EXPAND);
typedef const char * (*glXQueryServerString_PTR)(glXQueryServerString_ARG_EXPAND);
#define glXQuerySwapGroupNV_INDEX 2804
#define glXQuerySwapGroupNV_RETURN Bool
#define glXQuerySwapGroupNV_ARG_NAMES dpy, drawable, group, barrier
#define glXQuerySwapGroupNV_ARG_EXPAND Display * dpy, GLXDrawable drawable, GLuint * group, GLuint * barrier
#define glXQuerySwapGroupNV_PACKED PACKED_glXQuerySwapGroupNV
#define glXQuerySwapGroupNV_VOID_ONLY_WRAP(...) {}
#define glXQuerySwapGroupNV_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glXQuerySwapGroupNV(_dpy, _drawable, _group, _barrier) ({ \
    glXQuerySwapGroupNV_PACKED *packed_data = malloc(sizeof(glXQuerySwapGroupNV_PACKED)); \
    packed_data->index = glXQuerySwapGroupNV_INDEX; \
    packed_data->args.dpy = (Display *)_dpy; \
    packed_data->args.drawable = (GLXDrawable)_drawable; \
    packed_data->args.group = (GLuint *)_group; \
    packed_data->args.barrier = (GLuint *)_barrier; \
    (packed_call_t *)packed_data; \
})
#define call_glXQuerySwapGroupNV(packed, ret_v) do { \
    PACKED_glXQuerySwapGroupNV *unpacked = (PACKED_glXQuerySwapGroupNV *)packed; \
    ARGS_glXQuerySwapGroupNV *args = (ARGS_glXQuerySwapGroupNV *)&unpacked->args; \
    Bool *ret = (Bool *)ret_v; \
    if (ret != NULL) { \
        *ret = glXQuerySwapGroupNV(args->dpy, args->drawable, args->group, args->barrier);; \
    } else { \
        glXQuerySwapGroupNV(args->dpy, args->drawable, args->group, args->barrier);; \
    } \
} while(0)
Bool glXQuerySwapGroupNV(glXQuerySwapGroupNV_ARG_EXPAND);
typedef Bool (*glXQuerySwapGroupNV_PTR)(glXQuerySwapGroupNV_ARG_EXPAND);
#define glXQueryVersion_INDEX 2805
#define glXQueryVersion_RETURN Bool
#define glXQueryVersion_ARG_NAMES dpy, maj, min
#define glXQueryVersion_ARG_EXPAND Display * dpy, int * maj, int * min
#define glXQueryVersion_PACKED PACKED_glXQueryVersion
#define glXQueryVersion_VOID_ONLY_WRAP(...) {}
#define glXQueryVersion_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glXQueryVersion(_dpy, _maj, _min) ({ \
    glXQueryVersion_PACKED *packed_data = malloc(sizeof(glXQueryVersion_PACKED)); \
    packed_data->index = glXQueryVersion_INDEX; \
    packed_data->args.dpy = (Display *)_dpy; \
    packed_data->args.maj = (int *)_maj; \
    packed_data->args.min = (int *)_min; \
    (packed_call_t *)packed_data; \
})
#define call_glXQueryVersion(packed, ret_v) do { \
    PACKED_glXQueryVersion *unpacked = (PACKED_glXQueryVersion *)packed; \
    ARGS_glXQueryVersion *args = (ARGS_glXQueryVersion *)&unpacked->args; \
    Bool *ret = (Bool *)ret_v; \
    if (ret != NULL) { \
        *ret = glXQueryVersion(args->dpy, args->maj, args->min);; \
    } else { \
        glXQueryVersion(args->dpy, args->maj, args->min);; \
    } \
} while(0)
Bool glXQueryVersion(glXQueryVersion_ARG_EXPAND);
typedef Bool (*glXQueryVersion_PTR)(glXQueryVersion_ARG_EXPAND);
#define glXQueryVideoCaptureDeviceNV_INDEX 2806
#define glXQueryVideoCaptureDeviceNV_RETURN int
#define glXQueryVideoCaptureDeviceNV_ARG_NAMES dpy, device, attribute, value
#define glXQueryVideoCaptureDeviceNV_ARG_EXPAND Display * dpy, GLXVideoCaptureDeviceNV device, int attribute, int * value
#define glXQueryVideoCaptureDeviceNV_PACKED PACKED_glXQueryVideoCaptureDeviceNV
#define glXQueryVideoCaptureDeviceNV_VOID_ONLY_WRAP(...) {}
#define glXQueryVideoCaptureDeviceNV_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glXQueryVideoCaptureDeviceNV(_dpy, _device, _attribute, _value) ({ \
    glXQueryVideoCaptureDeviceNV_PACKED *packed_data = malloc(sizeof(glXQueryVideoCaptureDeviceNV_PACKED)); \
    packed_data->index = glXQueryVideoCaptureDeviceNV_INDEX; \
    packed_data->args.dpy = (Display *)_dpy; \
    packed_data->args.device = (GLXVideoCaptureDeviceNV)_device; \
    packed_data->args.attribute = (int)_attribute; \
    packed_data->args.value = (int *)_value; \
    (packed_call_t *)packed_data; \
})
#define call_glXQueryVideoCaptureDeviceNV(packed, ret_v) do { \
    PACKED_glXQueryVideoCaptureDeviceNV *unpacked = (PACKED_glXQueryVideoCaptureDeviceNV *)packed; \
    ARGS_glXQueryVideoCaptureDeviceNV *args = (ARGS_glXQueryVideoCaptureDeviceNV *)&unpacked->args; \
    int *ret = (int *)ret_v; \
    if (ret != NULL) { \
        *ret = glXQueryVideoCaptureDeviceNV(args->dpy, args->device, args->attribute, args->value);; \
    } else { \
        glXQueryVideoCaptureDeviceNV(args->dpy, args->device, args->attribute, args->value);; \
    } \
} while(0)
int glXQueryVideoCaptureDeviceNV(glXQueryVideoCaptureDeviceNV_ARG_EXPAND);
typedef int (*glXQueryVideoCaptureDeviceNV_PTR)(glXQueryVideoCaptureDeviceNV_ARG_EXPAND);
#define glXReleaseBuffersMESA_INDEX 2807
#define glXReleaseBuffersMESA_RETURN Bool
#define glXReleaseBuffersMESA_ARG_NAMES dpy, drawable
#define glXReleaseBuffersMESA_ARG_EXPAND Display * dpy, GLXDrawable drawable
#define glXReleaseBuffersMESA_PACKED PACKED_glXReleaseBuffersMESA
#define glXReleaseBuffersMESA_VOID_ONLY_WRAP(...) {}
#define glXReleaseBuffersMESA_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glXReleaseBuffersMESA(_dpy, _drawable) ({ \
    glXReleaseBuffersMESA_PACKED *packed_data = malloc(sizeof(glXReleaseBuffersMESA_PACKED)); \
    packed_data->index = glXReleaseBuffersMESA_INDEX; \
    packed_data->args.dpy = (Display *)_dpy; \
    packed_data->args.drawable = (GLXDrawable)_drawable; \
    (packed_call_t *)packed_data; \
})
#define call_glXReleaseBuffersMESA(packed, ret_v) do { \
    PACKED_glXReleaseBuffersMESA *unpacked = (PACKED_glXReleaseBuffersMESA *)packed; \
    ARGS_glXReleaseBuffersMESA *args = (ARGS_glXReleaseBuffersMESA *)&unpacked->args; \
    Bool *ret = (Bool *)ret_v; \
    if (ret != NULL) { \
        *ret = glXReleaseBuffersMESA(args->dpy, args->drawable);; \
    } else { \
        glXReleaseBuffersMESA(args->dpy, args->drawable);; \
    } \
} while(0)
Bool glXReleaseBuffersMESA(glXReleaseBuffersMESA_ARG_EXPAND);
typedef Bool (*glXReleaseBuffersMESA_PTR)(glXReleaseBuffersMESA_ARG_EXPAND);
#define glXReleaseTexImageEXT_INDEX 2808
#define glXReleaseTexImageEXT_RETURN void
#define glXReleaseTexImageEXT_ARG_NAMES dpy, drawable, buffer
#define glXReleaseTexImageEXT_ARG_EXPAND Display * dpy, GLXDrawable drawable, int buffer
#define glXReleaseTexImageEXT_PACKED PACKED_glXReleaseTexImageEXT
#define glXReleaseTexImageEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glXReleaseTexImageEXT_NOT_VOID_WRAP(...) {}
#define pack_glXReleaseTexImageEXT(_dpy, _drawable, _buffer) ({ \
    glXReleaseTexImageEXT_PACKED *packed_data = malloc(sizeof(glXReleaseTexImageEXT_PACKED)); \
    packed_data->index = glXReleaseTexImageEXT_INDEX; \
    packed_data->args.dpy = (Display *)_dpy; \
    packed_data->args.drawable = (GLXDrawable)_drawable; \
    packed_data->args.buffer = (int)_buffer; \
    (packed_call_t *)packed_data; \
})
#define call_glXReleaseTexImageEXT(packed, ret_v) do { \
    PACKED_glXReleaseTexImageEXT *unpacked = (PACKED_glXReleaseTexImageEXT *)packed; \
    ARGS_glXReleaseTexImageEXT *args = (ARGS_glXReleaseTexImageEXT *)&unpacked->args; \
    glXReleaseTexImageEXT(args->dpy, args->drawable, args->buffer);; \
} while(0)
void glXReleaseTexImageEXT(glXReleaseTexImageEXT_ARG_EXPAND);
typedef void (*glXReleaseTexImageEXT_PTR)(glXReleaseTexImageEXT_ARG_EXPAND);
#define glXReleaseVideoCaptureDeviceNV_INDEX 2809
#define glXReleaseVideoCaptureDeviceNV_RETURN void
#define glXReleaseVideoCaptureDeviceNV_ARG_NAMES dpy, device
#define glXReleaseVideoCaptureDeviceNV_ARG_EXPAND Display * dpy, GLXVideoCaptureDeviceNV device
#define glXReleaseVideoCaptureDeviceNV_PACKED PACKED_glXReleaseVideoCaptureDeviceNV
#define glXReleaseVideoCaptureDeviceNV_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glXReleaseVideoCaptureDeviceNV_NOT_VOID_WRAP(...) {}
#define pack_glXReleaseVideoCaptureDeviceNV(_dpy, _device) ({ \
    glXReleaseVideoCaptureDeviceNV_PACKED *packed_data = malloc(sizeof(glXReleaseVideoCaptureDeviceNV_PACKED)); \
    packed_data->index = glXReleaseVideoCaptureDeviceNV_INDEX; \
    packed_data->args.dpy = (Display *)_dpy; \
    packed_data->args.device = (GLXVideoCaptureDeviceNV)_device; \
    (packed_call_t *)packed_data; \
})
#define call_glXReleaseVideoCaptureDeviceNV(packed, ret_v) do { \
    PACKED_glXReleaseVideoCaptureDeviceNV *unpacked = (PACKED_glXReleaseVideoCaptureDeviceNV *)packed; \
    ARGS_glXReleaseVideoCaptureDeviceNV *args = (ARGS_glXReleaseVideoCaptureDeviceNV *)&unpacked->args; \
    glXReleaseVideoCaptureDeviceNV(args->dpy, args->device);; \
} while(0)
void glXReleaseVideoCaptureDeviceNV(glXReleaseVideoCaptureDeviceNV_ARG_EXPAND);
typedef void (*glXReleaseVideoCaptureDeviceNV_PTR)(glXReleaseVideoCaptureDeviceNV_ARG_EXPAND);
#define glXReleaseVideoDeviceNV_INDEX 2810
#define glXReleaseVideoDeviceNV_RETURN int
#define glXReleaseVideoDeviceNV_ARG_NAMES dpy, screen, VideoDevice
#define glXReleaseVideoDeviceNV_ARG_EXPAND Display * dpy, int screen, GLXVideoDeviceNV VideoDevice
#define glXReleaseVideoDeviceNV_PACKED PACKED_glXReleaseVideoDeviceNV
#define glXReleaseVideoDeviceNV_VOID_ONLY_WRAP(...) {}
#define glXReleaseVideoDeviceNV_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glXReleaseVideoDeviceNV(_dpy, _screen, _VideoDevice) ({ \
    glXReleaseVideoDeviceNV_PACKED *packed_data = malloc(sizeof(glXReleaseVideoDeviceNV_PACKED)); \
    packed_data->index = glXReleaseVideoDeviceNV_INDEX; \
    packed_data->args.dpy = (Display *)_dpy; \
    packed_data->args.screen = (int)_screen; \
    packed_data->args.VideoDevice = (GLXVideoDeviceNV)_VideoDevice; \
    (packed_call_t *)packed_data; \
})
#define call_glXReleaseVideoDeviceNV(packed, ret_v) do { \
    PACKED_glXReleaseVideoDeviceNV *unpacked = (PACKED_glXReleaseVideoDeviceNV *)packed; \
    ARGS_glXReleaseVideoDeviceNV *args = (ARGS_glXReleaseVideoDeviceNV *)&unpacked->args; \
    int *ret = (int *)ret_v; \
    if (ret != NULL) { \
        *ret = glXReleaseVideoDeviceNV(args->dpy, args->screen, args->VideoDevice);; \
    } else { \
        glXReleaseVideoDeviceNV(args->dpy, args->screen, args->VideoDevice);; \
    } \
} while(0)
int glXReleaseVideoDeviceNV(glXReleaseVideoDeviceNV_ARG_EXPAND);
typedef int (*glXReleaseVideoDeviceNV_PTR)(glXReleaseVideoDeviceNV_ARG_EXPAND);
#define glXReleaseVideoImageNV_INDEX 2811
#define glXReleaseVideoImageNV_RETURN int
#define glXReleaseVideoImageNV_ARG_NAMES dpy, pbuf
#define glXReleaseVideoImageNV_ARG_EXPAND Display * dpy, GLXPbuffer pbuf
#define glXReleaseVideoImageNV_PACKED PACKED_glXReleaseVideoImageNV
#define glXReleaseVideoImageNV_VOID_ONLY_WRAP(...) {}
#define glXReleaseVideoImageNV_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glXReleaseVideoImageNV(_dpy, _pbuf) ({ \
    glXReleaseVideoImageNV_PACKED *packed_data = malloc(sizeof(glXReleaseVideoImageNV_PACKED)); \
    packed_data->index = glXReleaseVideoImageNV_INDEX; \
    packed_data->args.dpy = (Display *)_dpy; \
    packed_data->args.pbuf = (GLXPbuffer)_pbuf; \
    (packed_call_t *)packed_data; \
})
#define call_glXReleaseVideoImageNV(packed, ret_v) do { \
    PACKED_glXReleaseVideoImageNV *unpacked = (PACKED_glXReleaseVideoImageNV *)packed; \
    ARGS_glXReleaseVideoImageNV *args = (ARGS_glXReleaseVideoImageNV *)&unpacked->args; \
    int *ret = (int *)ret_v; \
    if (ret != NULL) { \
        *ret = glXReleaseVideoImageNV(args->dpy, args->pbuf);; \
    } else { \
        glXReleaseVideoImageNV(args->dpy, args->pbuf);; \
    } \
} while(0)
int glXReleaseVideoImageNV(glXReleaseVideoImageNV_ARG_EXPAND);
typedef int (*glXReleaseVideoImageNV_PTR)(glXReleaseVideoImageNV_ARG_EXPAND);
#define glXRender_INDEX 2812
#define glXRender_RETURN void
#define glXRender_ARG_NAMES 
#define glXRender_ARG_EXPAND 
#define glXRender_PACKED PACKED_glXRender
#define glXRender_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glXRender_NOT_VOID_WRAP(...) {}
#define pack_glXRender() ({ \
    glXRender_PACKED *packed_data = malloc(sizeof(glXRender_PACKED)); \
    packed_data->index = glXRender_INDEX; \
    (packed_call_t *)packed_data; \
})
#define call_glXRender(packed, ret_v) do { \
    glXRender();; \
} while(0)
void glXRender(glXRender_ARG_EXPAND);
typedef void (*glXRender_PTR)(glXRender_ARG_EXPAND);
#define glXRenderLarge_INDEX 2813
#define glXRenderLarge_RETURN void
#define glXRenderLarge_ARG_NAMES 
#define glXRenderLarge_ARG_EXPAND 
#define glXRenderLarge_PACKED PACKED_glXRenderLarge
#define glXRenderLarge_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glXRenderLarge_NOT_VOID_WRAP(...) {}
#define pack_glXRenderLarge() ({ \
    glXRenderLarge_PACKED *packed_data = malloc(sizeof(glXRenderLarge_PACKED)); \
    packed_data->index = glXRenderLarge_INDEX; \
    (packed_call_t *)packed_data; \
})
#define call_glXRenderLarge(packed, ret_v) do { \
    glXRenderLarge();; \
} while(0)
void glXRenderLarge(glXRenderLarge_ARG_EXPAND);
typedef void (*glXRenderLarge_PTR)(glXRenderLarge_ARG_EXPAND);
#define glXResetFrameCountNV_INDEX 2814
#define glXResetFrameCountNV_RETURN Bool
#define glXResetFrameCountNV_ARG_NAMES dpy, screen
#define glXResetFrameCountNV_ARG_EXPAND Display * dpy, int screen
#define glXResetFrameCountNV_PACKED PACKED_glXResetFrameCountNV
#define glXResetFrameCountNV_VOID_ONLY_WRAP(...) {}
#define glXResetFrameCountNV_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glXResetFrameCountNV(_dpy, _screen) ({ \
    glXResetFrameCountNV_PACKED *packed_data = malloc(sizeof(glXResetFrameCountNV_PACKED)); \
    packed_data->index = glXResetFrameCountNV_INDEX; \
    packed_data->args.dpy = (Display *)_dpy; \
    packed_data->args.screen = (int)_screen; \
    (packed_call_t *)packed_data; \
})
#define call_glXResetFrameCountNV(packed, ret_v) do { \
    PACKED_glXResetFrameCountNV *unpacked = (PACKED_glXResetFrameCountNV *)packed; \
    ARGS_glXResetFrameCountNV *args = (ARGS_glXResetFrameCountNV *)&unpacked->args; \
    Bool *ret = (Bool *)ret_v; \
    if (ret != NULL) { \
        *ret = glXResetFrameCountNV(args->dpy, args->screen);; \
    } else { \
        glXResetFrameCountNV(args->dpy, args->screen);; \
    } \
} while(0)
Bool glXResetFrameCountNV(glXResetFrameCountNV_ARG_EXPAND);
typedef Bool (*glXResetFrameCountNV_PTR)(glXResetFrameCountNV_ARG_EXPAND);
#define glXSelectEvent_INDEX 2815
#define glXSelectEvent_RETURN void
#define glXSelectEvent_ARG_NAMES dpy, draw, event_mask
#define glXSelectEvent_ARG_EXPAND Display * dpy, GLXDrawable draw, unsigned long event_mask
#define glXSelectEvent_PACKED PACKED_glXSelectEvent
#define glXSelectEvent_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glXSelectEvent_NOT_VOID_WRAP(...) {}
#define pack_glXSelectEvent(_dpy, _draw, _event_mask) ({ \
    glXSelectEvent_PACKED *packed_data = malloc(sizeof(glXSelectEvent_PACKED)); \
    packed_data->index = glXSelectEvent_INDEX; \
    packed_data->args.dpy = (Display *)_dpy; \
    packed_data->args.draw = (GLXDrawable)_draw; \
    packed_data->args.event_mask = (unsigned long)_event_mask; \
    (packed_call_t *)packed_data; \
})
#define call_glXSelectEvent(packed, ret_v) do { \
    PACKED_glXSelectEvent *unpacked = (PACKED_glXSelectEvent *)packed; \
    ARGS_glXSelectEvent *args = (ARGS_glXSelectEvent *)&unpacked->args; \
    glXSelectEvent(args->dpy, args->draw, args->event_mask);; \
} while(0)
void glXSelectEvent(glXSelectEvent_ARG_EXPAND);
typedef void (*glXSelectEvent_PTR)(glXSelectEvent_ARG_EXPAND);
#define glXSelectEventSGIX_INDEX 2816
#define glXSelectEventSGIX_RETURN void
#define glXSelectEventSGIX_ARG_NAMES dpy, drawable, mask
#define glXSelectEventSGIX_ARG_EXPAND Display * dpy, GLXDrawable drawable, unsigned long mask
#define glXSelectEventSGIX_PACKED PACKED_glXSelectEventSGIX
#define glXSelectEventSGIX_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glXSelectEventSGIX_NOT_VOID_WRAP(...) {}
#define pack_glXSelectEventSGIX(_dpy, _drawable, _mask) ({ \
    glXSelectEventSGIX_PACKED *packed_data = malloc(sizeof(glXSelectEventSGIX_PACKED)); \
    packed_data->index = glXSelectEventSGIX_INDEX; \
    packed_data->args.dpy = (Display *)_dpy; \
    packed_data->args.drawable = (GLXDrawable)_drawable; \
    packed_data->args.mask = (unsigned long)_mask; \
    (packed_call_t *)packed_data; \
})
#define call_glXSelectEventSGIX(packed, ret_v) do { \
    PACKED_glXSelectEventSGIX *unpacked = (PACKED_glXSelectEventSGIX *)packed; \
    ARGS_glXSelectEventSGIX *args = (ARGS_glXSelectEventSGIX *)&unpacked->args; \
    glXSelectEventSGIX(args->dpy, args->drawable, args->mask);; \
} while(0)
void glXSelectEventSGIX(glXSelectEventSGIX_ARG_EXPAND);
typedef void (*glXSelectEventSGIX_PTR)(glXSelectEventSGIX_ARG_EXPAND);
#define glXSendPbufferToVideoNV_INDEX 2817
#define glXSendPbufferToVideoNV_RETURN int
#define glXSendPbufferToVideoNV_ARG_NAMES dpy, pbuf, iBufferType, pulCounterPbuffer, bBlock
#define glXSendPbufferToVideoNV_ARG_EXPAND Display * dpy, GLXPbuffer pbuf, int iBufferType, unsigned long * pulCounterPbuffer, GLboolean bBlock
#define glXSendPbufferToVideoNV_PACKED PACKED_glXSendPbufferToVideoNV
#define glXSendPbufferToVideoNV_VOID_ONLY_WRAP(...) {}
#define glXSendPbufferToVideoNV_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glXSendPbufferToVideoNV(_dpy, _pbuf, _iBufferType, _pulCounterPbuffer, _bBlock) ({ \
    glXSendPbufferToVideoNV_PACKED *packed_data = malloc(sizeof(glXSendPbufferToVideoNV_PACKED)); \
    packed_data->index = glXSendPbufferToVideoNV_INDEX; \
    packed_data->args.dpy = (Display *)_dpy; \
    packed_data->args.pbuf = (GLXPbuffer)_pbuf; \
    packed_data->args.iBufferType = (int)_iBufferType; \
    packed_data->args.pulCounterPbuffer = (unsigned long *)_pulCounterPbuffer; \
    packed_data->args.bBlock = (GLboolean)_bBlock; \
    (packed_call_t *)packed_data; \
})
#define call_glXSendPbufferToVideoNV(packed, ret_v) do { \
    PACKED_glXSendPbufferToVideoNV *unpacked = (PACKED_glXSendPbufferToVideoNV *)packed; \
    ARGS_glXSendPbufferToVideoNV *args = (ARGS_glXSendPbufferToVideoNV *)&unpacked->args; \
    int *ret = (int *)ret_v; \
    if (ret != NULL) { \
        *ret = glXSendPbufferToVideoNV(args->dpy, args->pbuf, args->iBufferType, args->pulCounterPbuffer, args->bBlock);; \
    } else { \
        glXSendPbufferToVideoNV(args->dpy, args->pbuf, args->iBufferType, args->pulCounterPbuffer, args->bBlock);; \
    } \
} while(0)
int glXSendPbufferToVideoNV(glXSendPbufferToVideoNV_ARG_EXPAND);
typedef int (*glXSendPbufferToVideoNV_PTR)(glXSendPbufferToVideoNV_ARG_EXPAND);
#define glXSet3DfxModeMESA_INDEX 2818
#define glXSet3DfxModeMESA_RETURN Bool
#define glXSet3DfxModeMESA_ARG_NAMES mode
#define glXSet3DfxModeMESA_ARG_EXPAND int mode
#define glXSet3DfxModeMESA_PACKED PACKED_glXSet3DfxModeMESA
#define glXSet3DfxModeMESA_VOID_ONLY_WRAP(...) {}
#define glXSet3DfxModeMESA_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glXSet3DfxModeMESA(_mode) ({ \
    glXSet3DfxModeMESA_PACKED *packed_data = malloc(sizeof(glXSet3DfxModeMESA_PACKED)); \
    packed_data->index = glXSet3DfxModeMESA_INDEX; \
    packed_data->args.mode = (int)_mode; \
    (packed_call_t *)packed_data; \
})
#define call_glXSet3DfxModeMESA(packed, ret_v) do { \
    PACKED_glXSet3DfxModeMESA *unpacked = (PACKED_glXSet3DfxModeMESA *)packed; \
    ARGS_glXSet3DfxModeMESA *args = (ARGS_glXSet3DfxModeMESA *)&unpacked->args; \
    Bool *ret = (Bool *)ret_v; \
    if (ret != NULL) { \
        *ret = glXSet3DfxModeMESA(args->mode);; \
    } else { \
        glXSet3DfxModeMESA(args->mode);; \
    } \
} while(0)
Bool glXSet3DfxModeMESA(glXSet3DfxModeMESA_ARG_EXPAND);
typedef Bool (*glXSet3DfxModeMESA_PTR)(glXSet3DfxModeMESA_ARG_EXPAND);
#define glXSwapBuffers_INDEX 2819
#define glXSwapBuffers_RETURN void
#define glXSwapBuffers_ARG_NAMES dpy, drawable
#define glXSwapBuffers_ARG_EXPAND Display * dpy, GLXDrawable drawable
#define glXSwapBuffers_PACKED PACKED_glXSwapBuffers
#define glXSwapBuffers_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glXSwapBuffers_NOT_VOID_WRAP(...) {}
#define pack_glXSwapBuffers(_dpy, _drawable) ({ \
    glXSwapBuffers_PACKED *packed_data = malloc(sizeof(glXSwapBuffers_PACKED)); \
    packed_data->index = glXSwapBuffers_INDEX; \
    packed_data->args.dpy = (Display *)_dpy; \
    packed_data->args.drawable = (GLXDrawable)_drawable; \
    (packed_call_t *)packed_data; \
})
#define call_glXSwapBuffers(packed, ret_v) do { \
    PACKED_glXSwapBuffers *unpacked = (PACKED_glXSwapBuffers *)packed; \
    ARGS_glXSwapBuffers *args = (ARGS_glXSwapBuffers *)&unpacked->args; \
    glXSwapBuffers(args->dpy, args->drawable);; \
} while(0)
void glXSwapBuffers(glXSwapBuffers_ARG_EXPAND);
typedef void (*glXSwapBuffers_PTR)(glXSwapBuffers_ARG_EXPAND);
#define glXSwapBuffersMscOML_INDEX 2820
#define glXSwapBuffersMscOML_RETURN int64_t
#define glXSwapBuffersMscOML_ARG_NAMES dpy, drawable, target_msc, divisor, remainder
#define glXSwapBuffersMscOML_ARG_EXPAND Display * dpy, GLXDrawable drawable, int64_t target_msc, int64_t divisor, int64_t remainder
#define glXSwapBuffersMscOML_PACKED PACKED_glXSwapBuffersMscOML
#define glXSwapBuffersMscOML_VOID_ONLY_WRAP(...) {}
#define glXSwapBuffersMscOML_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glXSwapBuffersMscOML(_dpy, _drawable, _target_msc, _divisor, _remainder) ({ \
    glXSwapBuffersMscOML_PACKED *packed_data = malloc(sizeof(glXSwapBuffersMscOML_PACKED)); \
    packed_data->index = glXSwapBuffersMscOML_INDEX; \
    packed_data->args.dpy = (Display *)_dpy; \
    packed_data->args.drawable = (GLXDrawable)_drawable; \
    packed_data->args.target_msc = (int64_t)_target_msc; \
    packed_data->args.divisor = (int64_t)_divisor; \
    packed_data->args.remainder = (int64_t)_remainder; \
    (packed_call_t *)packed_data; \
})
#define call_glXSwapBuffersMscOML(packed, ret_v) do { \
    PACKED_glXSwapBuffersMscOML *unpacked = (PACKED_glXSwapBuffersMscOML *)packed; \
    ARGS_glXSwapBuffersMscOML *args = (ARGS_glXSwapBuffersMscOML *)&unpacked->args; \
    int64_t *ret = (int64_t *)ret_v; \
    if (ret != NULL) { \
        *ret = glXSwapBuffersMscOML(args->dpy, args->drawable, args->target_msc, args->divisor, args->remainder);; \
    } else { \
        glXSwapBuffersMscOML(args->dpy, args->drawable, args->target_msc, args->divisor, args->remainder);; \
    } \
} while(0)
int64_t glXSwapBuffersMscOML(glXSwapBuffersMscOML_ARG_EXPAND);
typedef int64_t (*glXSwapBuffersMscOML_PTR)(glXSwapBuffersMscOML_ARG_EXPAND);
#define glXSwapIntervalEXT_INDEX 2821
#define glXSwapIntervalEXT_RETURN void
#define glXSwapIntervalEXT_ARG_NAMES dpy, drawable, interval
#define glXSwapIntervalEXT_ARG_EXPAND Display * dpy, GLXDrawable drawable, int interval
#define glXSwapIntervalEXT_PACKED PACKED_glXSwapIntervalEXT
#define glXSwapIntervalEXT_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glXSwapIntervalEXT_NOT_VOID_WRAP(...) {}
#define pack_glXSwapIntervalEXT(_dpy, _drawable, _interval) ({ \
    glXSwapIntervalEXT_PACKED *packed_data = malloc(sizeof(glXSwapIntervalEXT_PACKED)); \
    packed_data->index = glXSwapIntervalEXT_INDEX; \
    packed_data->args.dpy = (Display *)_dpy; \
    packed_data->args.drawable = (GLXDrawable)_drawable; \
    packed_data->args.interval = (int)_interval; \
    (packed_call_t *)packed_data; \
})
#define call_glXSwapIntervalEXT(packed, ret_v) do { \
    PACKED_glXSwapIntervalEXT *unpacked = (PACKED_glXSwapIntervalEXT *)packed; \
    ARGS_glXSwapIntervalEXT *args = (ARGS_glXSwapIntervalEXT *)&unpacked->args; \
    glXSwapIntervalEXT(args->dpy, args->drawable, args->interval);; \
} while(0)
void glXSwapIntervalEXT(glXSwapIntervalEXT_ARG_EXPAND);
typedef void (*glXSwapIntervalEXT_PTR)(glXSwapIntervalEXT_ARG_EXPAND);
#define glXSwapIntervalMESA_INDEX 2822
#define glXSwapIntervalMESA_RETURN int
#define glXSwapIntervalMESA_ARG_NAMES interval
#define glXSwapIntervalMESA_ARG_EXPAND unsigned int interval
#define glXSwapIntervalMESA_PACKED PACKED_glXSwapIntervalMESA
#define glXSwapIntervalMESA_VOID_ONLY_WRAP(...) {}
#define glXSwapIntervalMESA_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glXSwapIntervalMESA(_interval) ({ \
    glXSwapIntervalMESA_PACKED *packed_data = malloc(sizeof(glXSwapIntervalMESA_PACKED)); \
    packed_data->index = glXSwapIntervalMESA_INDEX; \
    packed_data->args.interval = (unsigned int)_interval; \
    (packed_call_t *)packed_data; \
})
#define call_glXSwapIntervalMESA(packed, ret_v) do { \
    PACKED_glXSwapIntervalMESA *unpacked = (PACKED_glXSwapIntervalMESA *)packed; \
    ARGS_glXSwapIntervalMESA *args = (ARGS_glXSwapIntervalMESA *)&unpacked->args; \
    int *ret = (int *)ret_v; \
    if (ret != NULL) { \
        *ret = glXSwapIntervalMESA(args->interval);; \
    } else { \
        glXSwapIntervalMESA(args->interval);; \
    } \
} while(0)
int glXSwapIntervalMESA(glXSwapIntervalMESA_ARG_EXPAND);
typedef int (*glXSwapIntervalMESA_PTR)(glXSwapIntervalMESA_ARG_EXPAND);
#define glXSwapIntervalSGI_INDEX 2823
#define glXSwapIntervalSGI_RETURN int
#define glXSwapIntervalSGI_ARG_NAMES interval
#define glXSwapIntervalSGI_ARG_EXPAND int interval
#define glXSwapIntervalSGI_PACKED PACKED_glXSwapIntervalSGI
#define glXSwapIntervalSGI_VOID_ONLY_WRAP(...) {}
#define glXSwapIntervalSGI_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glXSwapIntervalSGI(_interval) ({ \
    glXSwapIntervalSGI_PACKED *packed_data = malloc(sizeof(glXSwapIntervalSGI_PACKED)); \
    packed_data->index = glXSwapIntervalSGI_INDEX; \
    packed_data->args.interval = (int)_interval; \
    (packed_call_t *)packed_data; \
})
#define call_glXSwapIntervalSGI(packed, ret_v) do { \
    PACKED_glXSwapIntervalSGI *unpacked = (PACKED_glXSwapIntervalSGI *)packed; \
    ARGS_glXSwapIntervalSGI *args = (ARGS_glXSwapIntervalSGI *)&unpacked->args; \
    int *ret = (int *)ret_v; \
    if (ret != NULL) { \
        *ret = glXSwapIntervalSGI(args->interval);; \
    } else { \
        glXSwapIntervalSGI(args->interval);; \
    } \
} while(0)
int glXSwapIntervalSGI(glXSwapIntervalSGI_ARG_EXPAND);
typedef int (*glXSwapIntervalSGI_PTR)(glXSwapIntervalSGI_ARG_EXPAND);
#define glXUseXFont_INDEX 2824
#define glXUseXFont_RETURN void
#define glXUseXFont_ARG_NAMES font, first, count, listBase
#define glXUseXFont_ARG_EXPAND Font font, int first, int count, int listBase
#define glXUseXFont_PACKED PACKED_glXUseXFont
#define glXUseXFont_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glXUseXFont_NOT_VOID_WRAP(...) {}
#define pack_glXUseXFont(_font, _first, _count, _listBase) ({ \
    glXUseXFont_PACKED *packed_data = malloc(sizeof(glXUseXFont_PACKED)); \
    packed_data->index = glXUseXFont_INDEX; \
    packed_data->args.font = (Font)_font; \
    packed_data->args.first = (int)_first; \
    packed_data->args.count = (int)_count; \
    packed_data->args.listBase = (int)_listBase; \
    (packed_call_t *)packed_data; \
})
#define call_glXUseXFont(packed, ret_v) do { \
    PACKED_glXUseXFont *unpacked = (PACKED_glXUseXFont *)packed; \
    ARGS_glXUseXFont *args = (ARGS_glXUseXFont *)&unpacked->args; \
    glXUseXFont(args->font, args->first, args->count, args->listBase);; \
} while(0)
void glXUseXFont(glXUseXFont_ARG_EXPAND);
typedef void (*glXUseXFont_PTR)(glXUseXFont_ARG_EXPAND);
#define glXVendorPrivate_INDEX 2825
#define glXVendorPrivate_RETURN void
#define glXVendorPrivate_ARG_NAMES 
#define glXVendorPrivate_ARG_EXPAND 
#define glXVendorPrivate_PACKED PACKED_glXVendorPrivate
#define glXVendorPrivate_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glXVendorPrivate_NOT_VOID_WRAP(...) {}
#define pack_glXVendorPrivate() ({ \
    glXVendorPrivate_PACKED *packed_data = malloc(sizeof(glXVendorPrivate_PACKED)); \
    packed_data->index = glXVendorPrivate_INDEX; \
    (packed_call_t *)packed_data; \
})
#define call_glXVendorPrivate(packed, ret_v) do { \
    glXVendorPrivate();; \
} while(0)
void glXVendorPrivate(glXVendorPrivate_ARG_EXPAND);
typedef void (*glXVendorPrivate_PTR)(glXVendorPrivate_ARG_EXPAND);
#define glXVendorPrivateWithReply_INDEX 2826
#define glXVendorPrivateWithReply_RETURN void
#define glXVendorPrivateWithReply_ARG_NAMES 
#define glXVendorPrivateWithReply_ARG_EXPAND 
#define glXVendorPrivateWithReply_PACKED PACKED_glXVendorPrivateWithReply
#define glXVendorPrivateWithReply_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glXVendorPrivateWithReply_NOT_VOID_WRAP(...) {}
#define pack_glXVendorPrivateWithReply() ({ \
    glXVendorPrivateWithReply_PACKED *packed_data = malloc(sizeof(glXVendorPrivateWithReply_PACKED)); \
    packed_data->index = glXVendorPrivateWithReply_INDEX; \
    (packed_call_t *)packed_data; \
})
#define call_glXVendorPrivateWithReply(packed, ret_v) do { \
    glXVendorPrivateWithReply();; \
} while(0)
void glXVendorPrivateWithReply(glXVendorPrivateWithReply_ARG_EXPAND);
typedef void (*glXVendorPrivateWithReply_PTR)(glXVendorPrivateWithReply_ARG_EXPAND);
#define glXWaitForMscOML_INDEX 2827
#define glXWaitForMscOML_RETURN Bool
#define glXWaitForMscOML_ARG_NAMES dpy, drawable, target_msc, divisor, remainder, ust, msc, sbc
#define glXWaitForMscOML_ARG_EXPAND Display * dpy, GLXDrawable drawable, int64_t target_msc, int64_t divisor, int64_t remainder, int64_t * ust, int64_t * msc, int64_t * sbc
#define glXWaitForMscOML_PACKED PACKED_glXWaitForMscOML
#define glXWaitForMscOML_VOID_ONLY_WRAP(...) {}
#define glXWaitForMscOML_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glXWaitForMscOML(_dpy, _drawable, _target_msc, _divisor, _remainder, _ust, _msc, _sbc) ({ \
    glXWaitForMscOML_PACKED *packed_data = malloc(sizeof(glXWaitForMscOML_PACKED)); \
    packed_data->index = glXWaitForMscOML_INDEX; \
    packed_data->args.dpy = (Display *)_dpy; \
    packed_data->args.drawable = (GLXDrawable)_drawable; \
    packed_data->args.target_msc = (int64_t)_target_msc; \
    packed_data->args.divisor = (int64_t)_divisor; \
    packed_data->args.remainder = (int64_t)_remainder; \
    packed_data->args.ust = (int64_t *)_ust; \
    packed_data->args.msc = (int64_t *)_msc; \
    packed_data->args.sbc = (int64_t *)_sbc; \
    (packed_call_t *)packed_data; \
})
#define call_glXWaitForMscOML(packed, ret_v) do { \
    PACKED_glXWaitForMscOML *unpacked = (PACKED_glXWaitForMscOML *)packed; \
    ARGS_glXWaitForMscOML *args = (ARGS_glXWaitForMscOML *)&unpacked->args; \
    Bool *ret = (Bool *)ret_v; \
    if (ret != NULL) { \
        *ret = glXWaitForMscOML(args->dpy, args->drawable, args->target_msc, args->divisor, args->remainder, args->ust, args->msc, args->sbc);; \
    } else { \
        glXWaitForMscOML(args->dpy, args->drawable, args->target_msc, args->divisor, args->remainder, args->ust, args->msc, args->sbc);; \
    } \
} while(0)
Bool glXWaitForMscOML(glXWaitForMscOML_ARG_EXPAND);
typedef Bool (*glXWaitForMscOML_PTR)(glXWaitForMscOML_ARG_EXPAND);
#define glXWaitForSbcOML_INDEX 2828
#define glXWaitForSbcOML_RETURN Bool
#define glXWaitForSbcOML_ARG_NAMES dpy, drawable, target_sbc, ust, msc, sbc
#define glXWaitForSbcOML_ARG_EXPAND Display * dpy, GLXDrawable drawable, int64_t target_sbc, int64_t * ust, int64_t * msc, int64_t * sbc
#define glXWaitForSbcOML_PACKED PACKED_glXWaitForSbcOML
#define glXWaitForSbcOML_VOID_ONLY_WRAP(...) {}
#define glXWaitForSbcOML_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glXWaitForSbcOML(_dpy, _drawable, _target_sbc, _ust, _msc, _sbc) ({ \
    glXWaitForSbcOML_PACKED *packed_data = malloc(sizeof(glXWaitForSbcOML_PACKED)); \
    packed_data->index = glXWaitForSbcOML_INDEX; \
    packed_data->args.dpy = (Display *)_dpy; \
    packed_data->args.drawable = (GLXDrawable)_drawable; \
    packed_data->args.target_sbc = (int64_t)_target_sbc; \
    packed_data->args.ust = (int64_t *)_ust; \
    packed_data->args.msc = (int64_t *)_msc; \
    packed_data->args.sbc = (int64_t *)_sbc; \
    (packed_call_t *)packed_data; \
})
#define call_glXWaitForSbcOML(packed, ret_v) do { \
    PACKED_glXWaitForSbcOML *unpacked = (PACKED_glXWaitForSbcOML *)packed; \
    ARGS_glXWaitForSbcOML *args = (ARGS_glXWaitForSbcOML *)&unpacked->args; \
    Bool *ret = (Bool *)ret_v; \
    if (ret != NULL) { \
        *ret = glXWaitForSbcOML(args->dpy, args->drawable, args->target_sbc, args->ust, args->msc, args->sbc);; \
    } else { \
        glXWaitForSbcOML(args->dpy, args->drawable, args->target_sbc, args->ust, args->msc, args->sbc);; \
    } \
} while(0)
Bool glXWaitForSbcOML(glXWaitForSbcOML_ARG_EXPAND);
typedef Bool (*glXWaitForSbcOML_PTR)(glXWaitForSbcOML_ARG_EXPAND);
#define glXWaitGL_INDEX 2829
#define glXWaitGL_RETURN void
#define glXWaitGL_ARG_NAMES 
#define glXWaitGL_ARG_EXPAND 
#define glXWaitGL_PACKED PACKED_glXWaitGL
#define glXWaitGL_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glXWaitGL_NOT_VOID_WRAP(...) {}
#define pack_glXWaitGL() ({ \
    glXWaitGL_PACKED *packed_data = malloc(sizeof(glXWaitGL_PACKED)); \
    packed_data->index = glXWaitGL_INDEX; \
    (packed_call_t *)packed_data; \
})
#define call_glXWaitGL(packed, ret_v) do { \
    glXWaitGL();; \
} while(0)
void glXWaitGL(glXWaitGL_ARG_EXPAND);
typedef void (*glXWaitGL_PTR)(glXWaitGL_ARG_EXPAND);
#define glXWaitVideoSyncSGI_INDEX 2830
#define glXWaitVideoSyncSGI_RETURN int
#define glXWaitVideoSyncSGI_ARG_NAMES divisor, remainder, count
#define glXWaitVideoSyncSGI_ARG_EXPAND int divisor, int remainder, unsigned int * count
#define glXWaitVideoSyncSGI_PACKED PACKED_glXWaitVideoSyncSGI
#define glXWaitVideoSyncSGI_VOID_ONLY_WRAP(...) {}
#define glXWaitVideoSyncSGI_NOT_VOID_WRAP(...) { __VA_ARGS__ }
#define pack_glXWaitVideoSyncSGI(_divisor, _remainder, _count) ({ \
    glXWaitVideoSyncSGI_PACKED *packed_data = malloc(sizeof(glXWaitVideoSyncSGI_PACKED)); \
    packed_data->index = glXWaitVideoSyncSGI_INDEX; \
    packed_data->args.divisor = (int)_divisor; \
    packed_data->args.remainder = (int)_remainder; \
    packed_data->args.count = (unsigned int *)_count; \
    (packed_call_t *)packed_data; \
})
#define call_glXWaitVideoSyncSGI(packed, ret_v) do { \
    PACKED_glXWaitVideoSyncSGI *unpacked = (PACKED_glXWaitVideoSyncSGI *)packed; \
    ARGS_glXWaitVideoSyncSGI *args = (ARGS_glXWaitVideoSyncSGI *)&unpacked->args; \
    int *ret = (int *)ret_v; \
    if (ret != NULL) { \
        *ret = glXWaitVideoSyncSGI(args->divisor, args->remainder, args->count);; \
    } else { \
        glXWaitVideoSyncSGI(args->divisor, args->remainder, args->count);; \
    } \
} while(0)
int glXWaitVideoSyncSGI(glXWaitVideoSyncSGI_ARG_EXPAND);
typedef int (*glXWaitVideoSyncSGI_PTR)(glXWaitVideoSyncSGI_ARG_EXPAND);
#define glXWaitX_INDEX 2831
#define glXWaitX_RETURN void
#define glXWaitX_ARG_NAMES 
#define glXWaitX_ARG_EXPAND 
#define glXWaitX_PACKED PACKED_glXWaitX
#define glXWaitX_VOID_ONLY_WRAP(...) { __VA_ARGS__ }
#define glXWaitX_NOT_VOID_WRAP(...) {}
#define pack_glXWaitX() ({ \
    glXWaitX_PACKED *packed_data = malloc(sizeof(glXWaitX_PACKED)); \
    packed_data->index = glXWaitX_INDEX; \
    (packed_call_t *)packed_data; \
})
#define call_glXWaitX(packed, ret_v) do { \
    glXWaitX();; \
} while(0)
void glXWaitX(glXWaitX_ARG_EXPAND);
typedef void (*glXWaitX_PTR)(glXWaitX_ARG_EXPAND);

#endif
